{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif sum := SumBSTRange(tc.root, tc.a, tc.b); sum != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, sum)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := SumBSTRange(tc.root, tc.min, tc.max); res != tc.want {\n\t\tt.Errorf(\"STR\", tc.root, tc.min, tc.max, tc.want, res)\n\t}\n}\n}"}
{"tgt": "return &linkLoop{\n\tHead: &linkLoopNode{},\n}", "gen": "return &linkLoop{\n\thead: &linkLoopNode{},\n}\n}"}
{"tgt": "return bindataRead(\n\t_assetsHomeCatJpg,\n\t\"STR\",\n)", "gen": "return &HomeCat{\n\tHomeCatJpg: HomeCatJpg{\n\t\tName: \"HomeCat\",\n\t\tData: _assetsHomeCatJpg,\n\t},\n}\n}"}
{"tgt": "max := 1000\nsum := 0\nfor i := 1; i < max; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)", "gen": "max := 1000\nsum := 0\nfor i := 1; i <= max; i++ {\n\tif i%3 == 0 || i%5 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.locs); !reflect.DeepEqual(bonuses, tc.bonuses) {\n\t\tt.Errorf(\"STR\", tc.bonuses, bonuses)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.input); !reflect.DeepEqual(bonuses, tc.output) {\n\t\tt.Errorf(\"STR\", tc.input, tc.output, bonuses)\n\t}\n}\n}"}
{"tgt": "max := 9999\nbiggestPandigital := 0\nvar numberMultiplied int\nfor i := max; i > 0; i-- {\n\tnumberMultiplied = i\n\tfor j := 1; len(digits(numberMultiplied)) <= 9; j++ {\n\t\tnumberMultiplied = concatenMultiplication(i, j)\n\t\tif IsPandigital(numberMultiplied) && numberMultiplied > biggestPandigital {\n\t\t\tfmt.Println(numberMultiplied)\n\t\t\tbiggestPandigital = numberMultiplied\n\t\t}\n\t}\n}", "gen": "for i := 9999; i > 0; i-- {\n\tfor j := 1; j < 10000; j++ {\n\t\tif IsPandigital(concatenMultiplication(i, j)) {\n\t\t\tfmt.Println(concatenMultiplication(i, j))\n\t\t\treturn\n\t\t}\n\t}\n}\n}"}
{"tgt": "for {\n\tswitch r := l.next(); {\n\tcase unicode.IsNumber(r):\n\tcase r == \"STR\":\n\t\tl.backup()\n\t\tl.emit(itemEnd)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase r == eof:\n\t\tl.emit(itemEnd)\n\t\treturn byteRangeSet\n\tdefault:\n\t\treturn l.error(\"STR\")\n\t}\n}", "gen": "for {\n\ttok := l.next()\n\tif tok == 0 {\n\t\tbreak\n\t}\n\tif unicode.IsNumber(rune(tok)) {\n\t\tl.backup()\n\t\tl.emit(4)\n\t\tl.chomp()\n\t} else if tok == 44 {\n\t\tl.emit(4)\n\t\tl.chomp()\n\t} else {\n\t\tl.error(fmt.Sprintf(\"unexpected token %c\", tok))\n\t}\n}\nreturn byteRangeSet\n}"}
{"tgt": "return func(treebinaryTreeIf, node interface{}) bool {\n\tn := node.(*gbtElement)\n\tif !tree.IsNil(n.Left) && n.Left.Key >= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Left, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif !tree.IsNil(n.Right) && n.Right.Key <= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Right, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif debug {\n\t\tfmt.Println(n)\n\t}\n\t*nodeCnt++\n\treturn false\n}", "gen": "t := new(T)\nt.root = n\nt.size = 1\nreturn t\n}"}
{"tgt": "iterator := func() <-chan VertexId {\n\tch := make(chan VertexId)\n\tgo func() {\n\t\tif connected, ok := g.edges[vertex]; ok {\n\t\t\tfor VertexId, _ := range connected {\n\t\t\t\tif g.IsEdge(vertex, VertexId) {\n\t\t\t\t\tch <- VertexId\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\nreturn VerticesIterable(&vertexIterableHelper{iterFunc: iterator})", "gen": "g := &graph.Graph{\n\tVertices: v,\n}\nreturn &vertexIterableHelper{\n\tVerticesIter: g.GetSuccessors,\n}\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 2, 1}, []int{0, 4, 1, 3, 2}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1}, []int{0}, []int{1}},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums, c.index)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums, c.index)\n\t\t}\n\t})\n}", "gen": "testCases := []struct {\n\tname  string\n\tnums  []int\n\tindex []int\n\texpect []int\n}{\n\t{\"STR\", []int{1, 2, 3, 4}, []int{0, 1, 2}, []int{1, 2, 3, 4}},\n\t{\"STR\", []int{1, 2, 3, 4}, []int{0, 1, 3}, []int{1, 2, 4, 4}},\n\t{\"STR\", []int{1, 2, 3, 4}, []int{0, 1, 4}, []int{1, 2, 3, 4}},\n\t{\"STR\", []int{1, 2, 3, 4}, []int{0, 3, 1}, []int{1, 2, 3, 4}},\n\t{\"STR\", []int{1, 2, 3, 4}, []int{0, 3, 2}, []int{1, 2, 3, 4}},\n\t{\"STR\", []int{1, 2, 3, 4}, []int{0, 4, 1}, []int{1, 2, 3, 4}},\n\t{\"STR\", []int{1, 2, 3, 4}, []int{0, 4, 2}, []int{1, 2, 3, 4}},\n\t{\"STR\", []int{1, 2, 3, 4}, []int{0, 4, 3}, []int{1, 2, 3, 4}},\n\t{\"STR\", []int{1, 2, 3, 4}, []int{1, 0, 2}, []int{1, 2, 3, 4}},\n\t{\"STR\", []int{1, 2, 3, 4}, []int{1, 0, 3}, []int{1, 2, 3, 4}},\n\t{\"STR\", []int{1, 2"}
{"tgt": "c.bw.WriteString(\"STR\")\nc.bw.WriteByte(space)\nc.bw.WriteString(key)\nc.bw.WriteByte(space)\nc.bw.Write(strconv.AppendInt(c.numScratch[:0], int64(timeout), 10))\n_, err = c.bw.Write(crlf)\nreturn", "gen": "buf.WriteString(space)\nbuf.WriteByte(space)\nbuf.WriteString(key)\nbuf.WriteByte(space)\nbuf.WriteString(value)\nbuf.WriteString(crlf)\nbuf.WriteString(crlf)\nreturn buf.String()\n}"}
{"tgt": "for V > 0 {\n\tV--\n\tif !isDroppedLeft(heights, K) && !isDroppedRight(heights, K) {\n\t\theights[K]++\n\t}\n}\nreturn heights", "gen": "for i := len(heights) - 1; i >= 0; i-- {\n\tif isDroppedLeft(heights, i) {\n\t\tif isDroppedRight(heights, i) {\n\t\t\theights[i]++\n\t\t}\n\t}\n}\nreturn heights\n}"}
{"tgt": "h := &IntMaxHeap{}\nheap.Init(h)\nheap.Push(h, 7)\nheap.Push(h, 3)\nheap.Push(h, 2)\nheap.Push(h, 1)\nheap.Push(h, 5)\nheap.Push(h, 5)\nheap.Push(h, 6)\nheap.Push(h, 7)\nfmt.Printf(\"STR\", (*h))\nfor h.Len() > 0 {\n\tfmt.Printf(\"STR\", heap.Pop(h))\n}", "gen": "h := &IntMaxHeap{}\nh.Init(h)\nh.Push(h, 1)\nh.Push(h, 2)\nh.Push(h, 3)\nh.Push(h, 4)\nh.Push(h, 5)\nh.Push(h, 6)\nh.Push(h, 7)\nh.Push(h, 8)\nh.Push(h, 9)\nh.Push(h, 10)\nh.Push(h, 11)\nh.Push(h, 12)\nh.Push(h, 13)\nh.Push(h, 14)\nh.Push(h, 15)\nh.Push(h, 16)\nh.Push(h, 17)\nh.Push(h, 18)\nh.Push(h, 19)\nh.Push(h, 20)\nh.Push(h, 21)\nh.Push(h, 22)\nh.Push(h, 23)\nh.Push(h, 24)\nh.Push(h, 25)\nh.Push(h, 26)\nh.Push(h, 27)\nh.Push(h, 28)\nh.Push(h, 29)\nh.Push(h, 30)\nh.Push(h, 31)\nh.Push(h, 32)\nh.Push(h, 33)\nh.Push(h, 34)\nh.Push(h, 35)\nh.Push(h, 36)\nh.Push(h, 37)\nh.Push(h, 38)\nh.Push(h, 39)\nh.Push(h, 40)\nh.Push(h, 41)"}
{"tgt": "sLen, pLen := len(s), len(p)\ndp := make([][]bool, sLen+1)\nfor i := range dp {\n\tdp[i] = make([]bool, pLen+1)\n}\ndp[sLen][pLen] = true\nfor i := sLen; i > -1; i-- {\n\tfor j := pLen - 1; j > -1; j-- {\n\t\tfirstMatch := i < sLen && (p[j] == s[i] || p[j] == '.')\n\t\tif j+1 < pLen && p[j+1] == '*' {\n\t\t\tdp[i][j] = dp[i][j+2] || firstMatch && dp[i+1][j]\n\t\t} else {\n\t\t\tdp[i][j] = firstMatch && dp[i+1][j+1]\n\t\t}\n\t}\n}\nreturn dp[0][0]", "gen": "var res [][]bool\nfor i := 0; i < len(s); i++ {\n\tfor j := 0; j < len(s); j++ {\n\t\tif i == 0 || j == 0 {\n\t\t\tres[i][j] = true\n\t\t} else {\n\t\t\tif s[i-1] == s[j-1] {\n\t\t\t\tres[i][j] = res[i-1][j-1]\n\t\t\t} else {\n\t\t\t\tres[i][j] = false\n\t\t\t}\n\t\t}\n\t}\n}\nreturn res[len(s)-1][len(s)-1]\n}"}
{"tgt": "l1 := len(board)\nif l1 == 0 {\n\treturn\n}\nl2 := len(board[0])\nif l2 == 0 {\n\treturn\n}\nvisit := make([][]bool, l1)\nfor i := 0; i < l1; i++ {\n\tvisit[i] = make([]bool, l2)\n}\nfor i := 0; i < l1; i++ {\n\tfor j := 0; j < l2; j++ {\n\t\tif !visit[i][j] {\n\t\t\thelper(board, visit, i, j)\n\t\t}\n\t}\n}", "gen": "if len(A) == 0 {\n\treturn nil\n}\nif len(A) == 1 {\n\treturn A[0]\n}\nvar res []bool\nfor i := 0; i < len(A); i++ {\n\tfor j := 0; j < len(A); j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tif A[i][j] == 1 {\n\t\t\tres = append(res, helper(A, i, j))\n\t\t}\n\t}\n}\nreturn res\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.nums); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.left, tc.right); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.left, tc.right, tc.expected, result)\n\t}\n}\n}"}
{"tgt": "sum := 100 * 101 / 2\nsqSum := sum * sum\nsumSq := 0\nfor i := 1; i <= 100; i++ {\n\tsumSq += i * i\n}\nfmt.Println(sqSum - sumSq)", "gen": "sum := 5050 * 5050\nfor i := 1; i <= 100; i++ {\n\tsum += i * i\n}\nfmt.Println(sum)\n}"}
{"tgt": "return x != y", "gen": "return a < b\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := MinimizeQux(tc.qux); !reflect.DeepEqual(res, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.qux, tc.expected, res)\n\t}\n}\n}"}
{"tgt": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 1, 3}},\n\t\tans1051{3},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 2, 3, 4}},\n\t\tans1051{5},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{0},\n\t},\n\t{\n\t\tpara1051{[]int{5, 4, 3, 2, 1}},\n\t\tans1051{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"STR\")\nfor i := 0; i < 4; i++ {\n\tfmt.Printf(\"STR\", heightChecker([]int{1, 1, 4, 2, 3, 1, 3, 4, 5, 2, 4, 5, 5, 5, 0}))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"STR\", got, tt.want)\n\t\t}\n\t})\n}", "gen": "tests := []struct {\n\tname  string\n\targs  [2][]int\n\twant  int\n\twant1 int\n}{\n\t{\n\t\tname: \"case1\",\n\t\targs: [2][]int{\n\t\t\t{1, 2, 3, 4},\n\t\t\t{1, 2, 3, 4},\n\t\t},\n\t\twant:  4,\n\t\twant1: 4,\n\t},\n\t{\n\t\tname: \"case2\",\n\t\targs: [2][]int{\n\t\t\t{1, 2, 3, 4},\n\t\t\t{1, 2, 3, 4},\n\t\t},\n\t\twant:  4,\n\t\twant1: 4,\n\t},\n}\nfor _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tgot, got1 := largestOverlap(tt.args[0], tt.args[1])\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"largestOverlap() = %v, want %v\", got, tt.want)\n\t\t}\n\t\tif got1 != tt.want1 {\n\t\t\tt.Errorf(\"largestOverlap() = %v, want %v\", got1, tt.want1)\n\t\t}\n\t})\n}\n}"}
{"tgt": "if m == 0 {\n\treturn 1\n}\nswitch n {\ncase 1:\n\treturn 2\ncase 2:\n\tif m == 1 {\n\t\treturn 3\n\t}\n\treturn 4\ndefault:\n\tswitch m {\n\tcase 1:\n\t\treturn 4\n\tcase 2:\n\t\treturn 7\n\tdefault:\n\t\treturn 8\n\t}\n}", "gen": "switch n {\ncase 0:\n\treturn 1\ncase 1:\n\treturn 2\ncase 2:\n\treturn 3\ncase 3:\n\treturn 4\ncase 4:\n\treturn 7\ncase 5:\n\treturn 8\n}\nreturn -1\n}"}
{"tgt": "sort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].End < intervals[j].End\n})\ncount := 0\ncurrent := -int(^uint(0)>>1) - 1\nfor _, interval := range intervals {\n\tif interval.Start >= current {\n\t\tcount++\n\t\tcurrent = interval.End\n\t}\n}\nreturn len(intervals) - count", "gen": "intervals := []Interval{{1, 2}, {2, 3}, {3, 4}, {1, 3}}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nvar min int\nfor i := 0; i < len(intervals); i++ {\n\tif intervals[i].Start > min {\n\t\tmin = intervals[i].End\n\t}\n}\nreturn min\n}"}
{"tgt": "switch rand.Intn(10) {\ncase 1, 9:\n\treturn io.EOF\ncase 5:\n\treturn errors.New(\"STR\")\ndefault:\n\td.Line = \"STR\"\n\tfmt.Println(\"STR\", d.Line)\n\treturn nil\n}", "gen": "n := rand.Intn(10)\nswitch n {\ncase 0, 1, 5:\n\tfmt.Println(\"EOF\")\ncase 9:\n\tfmt.Println(\"STR\")\n}\n}"}
{"tgt": "fmt.Println(subarrayBitwiseORs([]int{0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))", "gen": "fmt.Println(subarrayBitwiseORs([]int{1, 1, 1}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 1, 1}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 1, 1, 1}))\n}"}
{"tgt": "dummy := &ListNode{0, head}\nslow, fast := dummy, dummy\nfor fast.Next != nil && fast.Next.Next != nil {\n\tfast = fast.Next.Next\n\tslow = slow.Next\n}\nreturn slow.Next", "gen": "var res []*TreeNode\nfor root != nil {\n\tres = append(res, root)\n\troot = root.Right\n}\nreturn res\n}"}
{"tgt": "pairs := [...][2]int{{10, 7}, {1000, 983}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p26(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "for _, tc := range []struct{\n\tn, m int\n}{\n\t{10, 7},\n\t{1000, 983},\n} {\n\tif p26(tc.n, tc.m) != tc.n {\n\t\tt.Errorf(\"STR\", tc.n, tc.m, tc.n)\n\t}\n}\n}"}
{"tgt": "n := len(A)\nfor i := n - 2; i >= 0; i-- {\n\tA[i] += A[i+1]\n}\nmem := [101][33]int{}\nvar dp func(int, int) int\ndp = func(i, m int) int {\n\tif i+2*m >= n {\n\t\treturn A[i]\n\t}\n\tif mem[i][m] > 0 {\n\t\treturn mem[i][m]\n\t}\n\tres := 0\n\tfor x := 1; x <= 2*m; x++ {\n\t\tres = max(\n\t\t\tres,\n\t\t\tA[i]-dp(i+x, max(m, x)),\n\t\t)\n\t}\n\tmem[i][m] = res\n\treturn res\n}\nreturn dp(0, 1)", "gen": "n := len(stones)\ndp := make([][]int, n)\nfor i := range dp {\n\tdp[i] = make([]int, n)\n}\nfor i := n - 2; i >= 0; i-- {\n\tfor j := i + 1; j < n; j++ {\n\t\tdp[i][j] = max(dp[i+1][j-1]+stones[i], dp[i+1][j]+stones[j])\n\t}\n}\nreturn dp[0][n-1]\n}"}
{"tgt": "if n == 0 {\n\treturn 0\n}\nreturn n/5 + trailingZeroes(n/5)", "gen": "if n == 0 {\n\treturn 0\n}\nreturn trailingZeroes(n) + trailingZeroes(n/5)\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0}, 5},\n\t{\"STR\", []int{0, 0, 0, 0, 1}, []int{1, 0, 0, 0, 0}, 4},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums1, c.nums2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums1, c.nums2)\n\t\t}\n\t})\n}", "gen": "testdata := []struct {\n\tname     string\n\tnums1    []int\n\tnums2    []int\n\texpect   int\n\texpected string\n}{\n\t{\n\t\tname:     \"TESTCASE_1\",\n\t\tnums1:    []int{1, 2, 3},\n\t\tnums2:    []int{2, 1},\n\t\texpect:   1,\n\t\texpected: \"STR_1\",\n\t},\n\t{\n\t\tname:     \"TESTCASE_2\",\n\t\tnums1:    []int{1, 2, 3},\n\t\tnums2:    []int{2, 3},\n\t\texpect:   2,\n\t\texpected: \"STR_2\",\n\t},\n\t{\n\t\tname:     \"TESTCASE_3\",\n\t\tnums1:    []int{1, 2, 3},\n\t\tnums2:    []int{1, 2},\n\t\texpect:   3,\n\t\texpected: \"STR_3\",\n\t},\n\t{\n\t\tname:     \"TESTCASE_4\",\n\t\tnums1:    []int{1, 2, 3},\n\t\tnums2:    []int{1, 2, 3},\n\t\texpect:   6,\n\t\texpected: \"STR_4\",\n\t},\n\t{\n\t\tname:     \"TESTCASE_5\",\n\t\tnums1:    []int{1, 2, 3},\n\t\tnums2:    []int{1, 2, 3, 4, 7},\n\t\texpect:   10,\n\t\texpected: \"STR_5\",\n\t},\n}\nfor _, tc := range testdata {\n\tt.Run(tc.expected, func(t *testing.T) {\n\t\tSTR_1 := tc.name + tc.expected\n"}
{"tgt": "list.rear = nil", "gen": "return nil\n}"}
{"tgt": "if len(name) == 0 && len(typed) == 0 {\n\treturn true\n}\nif (len(name) == 0 && len(typed) != 0) || (len(name) != 0 && len(typed) == 0) {\n\treturn false\n}\nj := 0\nfor i := 0; i < len(name); i++ {\n\tif j < len(typed) && name[i] == typed[j] {\n\t\tj++\n\t\tcontinue\n\t} else {\n\t\tif i > 0 && j < len(typed) && name[i-1] == typed[j] {\n\t\t\tj++\n\t\t\ti--\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "if len(a) != len(b) {\n\treturn false\n}\nif len(a) == 0 {\n\treturn true\n}\nfor i := 0; i < len(a); i++ {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "factorial := new(big.Int).MulRange(1, 100)\nbytes := factorial.Append([]byte{}, 10)\nsum := 0\nfor b := range bytes {\n\tsum += int(bytes[b] - '0')\n}\nfmt.Println(\"STR\", sum)", "gen": "n := big.NewInt()\nn.MulRange(1, 100)\ns := n.Append(10)\nfor i := 0; i < len(s); i++ {\n\tfmt.Println(string(s[i]))\n}\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs int\n\texpect int\n}{\n\t{\"STR\", 2, 1},\n\t{\"STR\", 3, 2},\n\t{\"STR\", 4, 3},\n\t{\"STR\", 0, 0},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "var s = Solution{\n\tname: \"STR\",\n\tinputs: []int{\n\t\t2,\n\t\t1,\n\t},\n\texpect: 3,\n}\nSTRSTR := func(s, t string) int {\n\treturn 0\n}\nSTRSTRSTR := func(s, t string) int {\n\treturn 0\n}\nSTRSTRSTRSTR := func(s, t string) int {\n\treturn 0\n}\nSTRSTRSTRSTRSTR := func(s, t string) int {\n\treturn 0\n}\nSTRSTRSTRSTRSTRSTR := func(s, t string) int {\n\treturn 0\n}\nSTRSTRSTRSTRSTRSTRSTR := func(s, t string) int {\n\treturn 0\n}\nSTRSTRSTRSTRSTRSTRSTRSTR := func(s, t string) int {\n\treturn 0\n}\nSTRSTRSTRSTRSTRSTRSTRSTRSTR := func(s, t string) int {\n\treturn 0\n}\nSTRSTRSTRSTRSTRSTRSTRSTRSTRSTR := func(s, t string) int {\n\treturn 0\n}\nSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTR := func(s, t string) int {\n\treturn 0\n}\nSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTR := func(s, t string) int {\n\treturn 0\n}\nSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTR := func(s, t string) int {\n\treturn 0\n}\nSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTR := func(s, t string) int {\n\treturn 0\n}\nSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTR := func(s, t string) int {\n\treturn 0\n}\nSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTR := func(s, t string) int {\n\treturn 0\n}"}
{"tgt": "var low, mid, high int = 0, len(sorted) / 2, len(sorted)\nfor low < high {\n\tcurr := sorted[mid]\n\tswitch {\n\tcase curr == target:\n\t\treturn mid\n\tcase inRange(sorted[mid:high], target):\n\t\tlow = mid\n\t\tmid = (low + high) / 2\n\tdefault:\n\t\thigh = mid\n\t\tmid = (low + high) / 2\n\t}\n}\nreturn -1", "gen": "low, high := 0, len(nums)-1\nfor low <= high {\n\tmid := (low + high) / 2\n\tif nums[mid] == target {\n\t\treturn mid\n\t} else if nums[mid] < target {\n\t\tlow = mid + 1\n\t} else {\n\t\thigh = mid - 1\n\t}\n}\nreturn -1\n}"}
{"tgt": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nret := &ListNode{}\nif l1.Val <= l2.Val {\n\tret = l1\n\tret.Next = mergeTwoLists1(l1.Next, l2)\n} else {\n\tret = l2\n\tret.Next = mergeTwoLists1(l1, l2.Next)\n}\nreturn ret", "gen": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nif l1.Val > l2.Val {\n\treturn mergeTwoLists1(l2, l1)\n}\nhead := &ListNode{Val: 0}\ncur := head\nfor l1 != nil && l2 != nil {\n\tif l1.Val < l2.Val {\n\t\tcur.Next = l1\n\t\tl1 = l1.Next\n\t} else {\n\t\tcur.Next = l2\n\t\tl2 = l2.Next\n\t}\n\tcur = cur.Next\n}\nif l1 != nil {\n\tcur.Next = l1\n} else {\n\tcur.Next = l2\n}\nreturn head.Next\n}"}
{"tgt": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Print(sum, \"STR\")", "gen": "sum := 0\nfor i := 1; i <= 999; i++ {\n\tif i%3 == 0 || i%5 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "rets := make([][]int, numRows)\nif numRows == 0 {\n\treturn rets\n}\nrets[0] = []int{1}\nfor i := 1; i < numRows; i++ {\n\trets[i] = make([]int, i+1)\n\trets[i][0] = 1\n\trets[i][i] = 1\n\tfor j := 1; j < i; j++ {\n\t\trets[i][j] = rets[i-1][j-1] + rets[i-1][j]\n\t}\n}\nreturn rets", "gen": "res := make([][]int, len(nums))\nfor i := 0; i < len(nums); i++ {\n\tres[i] = make([]int, len(nums))\n\tfor j := 0; j < len(nums); j++ {\n\t\tres[i][j] = 1\n\t}\n\tfor j := i + 1; j < len(nums); j++ {\n\t\tres[i][j] = 1\n\t\tres[j][i] = 1\n\t}\n}\nreturn res\n}"}
{"tgt": "start := -1\nlenMax := 0\ndict := [256]int{}\nfor i := range dict {\n\tdict[i] = -1\n}\nfor i, r := range s {\n\tif v := dict[r]; v > start {\n\t\tstart = v\n\t}\n\tlength := i - start\n\tif length > lenMax {\n\t\tlenMax = length\n\t}\n\tdict[r] = i\n}\nreturn lenMax", "gen": "var max int\nvar maxIndex int\nfor i := 0; i < 256; i++ {\n\tmaxIndex = -1\n\tfor j := 0; j < len(s); j++ {\n\t\tif s[j] == byte(i) {\n\t\t\tmaxIndex = j\n\t\t}\n\t}\n\tif maxIndex > max {\n\t\tmax = maxIndex\n\t}\n}\nreturn max\n}"}
{"tgt": "nlen := len(nums)\nfor i := 0; i < nlen-2; i++ {\n\tif i != 0 && nums[i] == nums[i-1] {\n\t\tcontinue\n\t}\n\tleft, right := i+1, nlen-1\n\tfor left < right {\n\t\tsum := nums[i] + nums[left] + nums[right]\n\t\tif sum == target {\n\t\t\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tleft++\n\t\t\tright--\n\t\t} else if sum < target {\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tleft++\n\t\t} else {\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tright--\n\t\t}\n\t}\n}", "gen": "for i := 0; i < len(nums); i++ {\n\tfor j := i + 1; j < len(nums); j++ {\n\t\tif nums[i]+nums[j] == target {\n\t\t\treturn []int{i, j}\n\t\t}\n\t}\n\tfor j := len(nums) - 1; j > i; j-- {\n\t\tif nums[i]+nums[j] == target {\n\t\t\treturn []int{i, j}\n\t\t}\n\t}\n}\nreturn nil\n}"}
{"tgt": "return strings.ReplaceAll(r.element.Name, \"STR\", \"\")", "gen": "return strings.ReplaceAll(s, \"\\\\\", \"/\")\n}"}
{"tgt": "var res byte\nfor i := 0; i < len(s); i++ {\n\tres ^= s[i]\n}\nfor i := 0; i < len(t); i++ {\n\tres ^= t[i]\n}\nreturn res", "gen": "var res bool\nfor i := 0; i < len(s1); i++ {\n\tfor j := 0; j < len(s2); j++ {\n\t\tres ^= s1[i] == s2[j]\n\t}\n}\nreturn res\n}"}
{"tgt": "m := len(A)\nn := len(A[0])\nans := make([][]int, n)\nfor k := range ans {\n\tans[k] = make([]int, m)\n}\nfor r := 0; r < m; r++ {\n\tfor c := 0; c < n; c++ {\n\t\tans[c][r] = A[r][c]\n\t}\n}\nreturn ans", "gen": "n := len(nums)\nres := make([][]int, n)\nfor i := 0; i < n; i++ {\n\tres[i] = make([]int, n)\n\tfor j := 0; j < n; j++ {\n\t\tres[i][j] = nums[i]\n\t}\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tfor k := 0; k < n; k++ {\n\t\t\tres[i][j] = nums[i]\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "println(\"STR\", len(a))", "gen": "fmt.Println(\"STR\", len(s))\n}"}
{"tgt": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nc, res := []int{}, [][]int{}\nsort.Ints(candidates)\nfindcombinationSum(candidates, target, 0, c, &res)\nreturn res", "gen": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nsort.Ints(candidates)\nreturn findcombinationSum(candidates, target, []int{}, []int{})\n}"}
{"tgt": "for i := 0; i < len(A)-1; i++ {\n\tif A[i] == i {\n\t\tcontinue\n\t}\n\tif A[i] == i+1 && A[i+1] == i {\n\t\ti++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var res int\nfor i := 0; i < len(nums)-1; i++ {\n\tif nums[i] == nums[i+1] {\n\t\tres++\n\t} else {\n\t\tfor nums[i] < nums[i+1] {\n\t\t\ti++\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "for n := 0; n < 32; n++ {\n\tsquare[n] = gf2MatrixTimes(mat, mat[n])\n}", "gen": "for i := 0; i < 32; i++ {\n\tcrc[i] = gf2MatrixTimes(crc, crc[i])\n\tcrc[i] = crc[i] ^ crc[i+1]\n}\n}"}
{"tgt": "for i := 0; i < n; i++ {\n\tif len(squares) != i {\n\t\tprintln(\"STR\", len(squares), \"STR\", i)\n\t}\n\tsquares[i] = i * i\n\tfor j := 0; j <= i; j++ {\n\t\tif v, ok := squares[j]; !ok || v != j*j {\n\t\t\tif !ok {\n\t\t\t\tprintln(\"STR\", j)\n\t\t\t} else {\n\t\t\t\tprintln(\"STR\", j, v)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "var sum int\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tif m[i][j] == 1 {\n\t\t\tsum++\n\t\t}\n\t}\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tif m[i][j] == 0 {\n\t\t\tsum++\n\t\t}\n\t}\n}\nreturn sum\n}"}
{"tgt": "for j := 1; j <= 20; j++ {\n\tif num%j != 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "for i := 1; i <= 20; i++ {\n\tif n%i == 0 {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "if len(sorted) == 0 {\n\treturn nil\n}\nmid := len(sorted) / 2\nroot := &BST{Value: sorted[mid]}\nroot.Left = SortedSliceToBST(sorted[:mid])\nroot.Right = SortedSliceToBST(sorted[mid+1:])\nreturn root", "gen": "if len(nums) == 0 {\n\treturn nil\n}\nroot := &BST{}\nif len(nums) == 1 {\n\troot.Val = nums[0]\n\treturn root\n}\nroot.Val = nums[0]\nroot.Left = SortedSliceToBST(nums[1:len(nums)/2])\nroot.Right = SortedSliceToBST(nums[len(nums)/2+1:])\nreturn root\n}"}
{"tgt": "return x * y", "gen": "return float32(a.X*b.X + a.Y*b.Y + a.Z*b.Z)\n}"}
{"tgt": "i1 := 0\ni2 := 0\nval1 := 0\nval2 := 0\nfor i1 < len(version1) || i2 < len(version2) {\n\tval1, i1 = parseSeg(version1, i1)\n\tval2, i2 = parseSeg(version2, i2)\n\tif val1 > val2 {\n\t\treturn 1\n\t}\n\tif val1 < val2 {\n\t\treturn -1\n\t}\n}\nif i1 < len(version1) {\n\treturn 1\n}\nif i2 < len(version2) {\n\treturn -1\n}\nreturn 0", "gen": "var start, end int\nfor _, seg := range intervals {\n\tstart, end = parseSeg(seg)\n\tif start > end {\n\t\treturn -1\n\t}\n}\nfor _, seg := range points {\n\tstart, end = parseSeg(seg)\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start >= end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start >= end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start >= end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start >= end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start >= end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start >= end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start >= end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start >= end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start >= end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start >= end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start >= end {\n\t\t"}
{"tgt": "return this.Val", "gen": "return self.head.Value\n}"}
{"tgt": "str := \"STR\"\nfmt.Println(longestPalindrome(str))", "gen": "fmt.Println(longestPalindrome(STR))\n}"}
{"tgt": "dat, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\nnamesList := string(dat)\nnamesList = strings.Replace(namesList, \"STR\", \"STR\", -1)\nnames := strings.Split(namesList, \"STR\")\nsort.Strings(names)\nnamesScore := 0\nfor index, name := range names {\n\tnamesScore += nameScore(name) * (index + 1)\n}\nfmt.Println(namesScore)", "gen": "file, err := ioutil.ReadFile(\"names.txt\")\nif err != nil {\n\tpanic(err)\n}\nnames := strings.Split(strings.Replace(string(file), \"\\n\", \"\", -1), \",\")\nsort.Strings(names)\nvar score int\nfor _, name := range names {\n\tscore += nameScore(name)\n}\nfmt.Println(score)\n}"}
{"tgt": "res := 0\nsort.Ints(houses)\nsort.Ints(heaters)\nm, n := len(houses), len(heaters)\nindex := sort.SearchInts(heaters, houses[0])\nfor _, house := range houses {\n\tfor index < n && house > heaters[index] {\n\t\tindex++\n\t}\n\tif index == n {\n\t\treturn max(res, houses[m-1]-heaters[index-1])\n\t}\n\tleft := math.MaxInt32\n\tif index > 0 {\n\t\tleft = house - heaters[index-1]\n\t}\n\tright := heaters[index] - house\n\tres = max(res, min(left, right))\n}\nreturn res", "gen": "sort.Ints(A)\nsort.Ints(B)\ni := sort.SearchInts(A, B[0])\nj := sort.SearchInts(B, A[len(A)-1])\nif j == len(B) {\n\treturn max(A[len(A)-1], B[len(B)-1])\n}\nreturn max(A[len(A)-1], B[j-1])\n}"}
{"tgt": "l, r := &maxHeap{}, &minHeap{}\nheap.Init(l)\nheap.Init(r)\nreturn MedianFinder{l, r}", "gen": "return &maxHeap{\n\theap: heap.Init(maxHeap{}, 0, 0, 0),\n}, &minHeap{\n\theap: heap.Init(minHeap{}, 0, 0, 0),\n}\n}"}
{"tgt": "l := len(preorder)\nif l == 0 {\n\treturn nil\n}\nfor 1 < l && preorder[0] < preorder[l-1] {\n\tl--\n}\nreturn &TreeNode{\n\tVal:   preorder[0],\n\tLeft:  bstFromPreorder(preorder[1:l]),\n\tRight: bstFromPreorder(preorder[l:]),\n}", "gen": "if len(preorder) == 0 {\n\treturn nil\n}\nif preorder[0] == -1 {\n\treturn bstFromPreorder(preorder[1:])\n}\nif len(preorder) == 1 {\n\treturn &TreeNode{Val: preorder[0]}\n}\nif preorder[1] == -1 {\n\treturn &TreeNode{Val: preorder[0], Left: bstFromPreorder(preorder[2:])}\n}\nreturn &TreeNode{Val: preorder[0], Left: bstFromPreorder(preorder[1:]), Right: bstFromPreorder(preorder[1:])}\n}"}
{"tgt": "ln, err := net.Listen(\"STR\", \"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"STR\", conn.RemoteAddr())\n\tio.WriteString(conn, fmt.Sprint(time.Now()))\n\tconn.Close()\n}", "gen": "ln, err := net.Listen(\"tcp\", \"localhost:0\")\nif err != nil {\n\treturn\n}\ndefer ln.Close()\nfmt.Println(\"STR\", ln.Addr())\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer conn.Close()\n\tfmt.Println(\"STR\", time.Now())\n\tio.WriteString(conn, \"STR\")\n}\n}"}
{"tgt": "i, l := 0, len(bits)-1\nfor i < l {\n\ti += bits[i] + 1\n}\nreturn i == l", "gen": "n := len(nums) - 1\nfor i := 0; i < n; i++ {\n\tif nums[i] == nums[i+1] {\n\t\treturn true\n\t}\n}\nreturn false\n}"}
{"tgt": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"STR\", STR)\nSTR = defangIPaddr(STR)\nfmt.Printf(\"STR\", STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defangIPaddr(STR)\nSTR = defang"}
{"tgt": "start := 0\nend := len(s) - 1\nfor start < end {\n\ts[start], s[end] = s[end], s[start]\n\tstart++\n\tend--\n}\nreturn s", "gen": "for i := 0; i < len(nums)-1; i++ {\n\tfor j := len(nums) - 1; j > i; j-- {\n\t\tif nums[i] == nums[j] {\n\t\t\tnums = append(nums[:i], nums[i+1:]...)\n\t\t\tj = len(nums) - 1\n\t\t}\n\t}\n}\nreturn nums\n}"}
{"tgt": "for cur := t.root; cur != nil; {\n\tif cur.Key == key {\n\t\treturn cur\n\t} else if key < cur.Key {\n\t\tcur = cur.left\n\t} else {\n\t\tcur = cur.right\n\t}\n}\nreturn nil", "gen": "if root == nil {\n\treturn nil, nil\n}\nfor root != nil {\n\tif root.Value == value {\n\t\treturn root, root\n\t} else if root.Value > value {\n\t\troot = root.Left\n\t} else {\n\t\troot = root.Right\n\t}\n}\nreturn nil, nil\n}\n`\nif *flagDwarf {\n\tbuf := new(bytes.Buffer)\n\tif err := dwarf.Dwarf(buf, fset, files, pkg, funcDecls, typDecls, funcs, vars); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgot := buf.String()\n\tif got != want {\n\t\tt.Errorf(\"dwarf.Dwarf:\\n%s\", diff.LineDiff(want, got))\n\t}\n}\n}\n"}
{"tgt": "arr := randomSlice(0, 20, 10)\nnodeCnt := 0\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\nrotateNodes := make([]*gbtElement, 0, 0)\ngbt.InOrderWalk(gbt.Root(), func(GBTbinaryTreeIf, node interface{}) bool {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\trotateNodes = append(rotateNodes, node.(*gbtElement))\n\t}\n\treturn false\n})\nfor _, v := range rotateNodes {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\tgbt.LeftRotate(v)\n\t} else {\n\t\tgbt.RightRotate(v)\n\t}\n}\ngbt.InOrderWalk(gbt.Root(), checkGBT(t, &nodeCnt, *debug))\nif nodeCnt != len(arr) {\n\tt.Log(fmt.Sprintf(\"STR\", len(arr), nodeCnt))\n\tt.Fail()\n}", "gen": "slice := randomSlice(10, 20)\ntree := NewGBT()\nfor _, v := range slice {\n\ttree.Insert(v)\n}\nfor i := 0; i < len(slice); i++ {\n\tif tree.Get(slice[i]) != slice[i] {\n\t\tt.Log(fmt.Sprintf(\"STR\", i, tree.Get(slice[i])))\n\t\tt.Fail()\n\t}\n}\n}"}
{"tgt": "return WordDictionary{}", "gen": "return &Stack{\n\tdata: make([]interface{}, 0, 27),\n}\n}"}
{"tgt": "return xtime.Unix(int64(jt), 0)", "gen": "t := time.Unix(0, t.UnixNano())\nreturn Time{t}\n}"}
{"tgt": "return append(ints, added...)", "gen": "if len(s) > len(t) {\n\treturn s\n}\nreturn t\n}"}
{"tgt": "data, err := base64.StdEncoding.DecodeString(b64)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(data)", "gen": "decoded, err := base64.StdEncoding.DecodeString(s)\nif err != nil {\n\tpanic(err)\n}\nreturn hex.EncodeToString(decoded)\n}"}
{"tgt": "h := fnv.New64a()\n_, _ = h.Write([]byte(fmt.Sprintf(\"STR\", key)))\nhashValue := h.Sum64()\nreturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))", "gen": "h := z2fnv.New64a()\nh.Write([]byte(fmt.Sprintf(\"%s\", str)))\nreturn h.Sum64() & 0xffff\n}"}
{"tgt": "return fmt.Sprintf(\"STR\", p.Name, p.Age)", "gen": "return fmt.Sprintf(\"STR_%d\", s.Len())\n}"}
{"tgt": "parent := this\nfor _, ch := range prefix {\n\tif child, ok := parent.Children[ch]; ok {\n\t\tparent = child\n\t\tcontinue\n\t}\n\treturn false\n}\nreturn true", "gen": "var res int\nfor _, c := range s {\n\tif c > 127 {\n\t\tcontinue\n\t}\n\tres += trie[c].count\n}\nif res == 0 {\n\treturn false\n}\nreturn true\n}"}
{"tgt": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)", "gen": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)\n}"}
{"tgt": "close(p.work)\np.wg.Wait()", "gen": "close(c)\nwg.Wait()\n}"}
{"tgt": "m := make(map[int]struct{})\nfor _, num := range nums1 {\n\tm[num] = struct{}{}\n}\nnums := make([]int, 0)\nfor _, num := range nums2 {\n\tif _, ok := m[num]; ok {\n\t\tnums = append(nums, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn nums", "gen": "m := make(map[int]struct{})\nfor _, v := range nums {\n\tm[v] = struct{}{}\n}\nres := make([]int, 0)\nfor _, v := range nums {\n\tif _, ok := m[v]; !ok {\n\t\tres = append(res, v)\n\t\tdelete(m, v)\n\t}\n}\nreturn res\n}"}
{"tgt": "return h.FromHexString(string(b))", "gen": "return HashFromHexString(string(b))\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif denoms := EgyptianFractions(tc.numerator, tc.denominator); !reflect.DeepEqual(tc.denominators, denoms) {\n\t\tt.Errorf(\"STR\", tc.denominators, denoms)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tgot := EgyptianFractions(tc.n)\n\tif !reflect.DeepEqual(got, tc.want) {\n\t\tt.Errorf(\"STR\", tc.n, tc.want, got)\n\t}\n}\n}"}
{"tgt": "log.SetFlags(0)\nvar err error\ntpl := template.New(\"STR\")\ntpl = tpl.Funcs(template.FuncMap{\n\t\"STR\": func(str string) string {\n\t\treturn strings.ToUpper(str)\n\t},\n})\ntpl, err = tpl.ParseFiles(\"STR\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nerr = tpl.ExecuteTemplate(os.Stdout, \"STR\", Page{\n\tTitle: \"STR\",\n\tBody:  \"STR\",\n})\nif err != nil {\n\tlog.Fatalln(err)\n}", "gen": "log.SetFlags(log.Lshortfile)\nt := template.New(\"\").Funcs(map[string]interface{}{\n\t\"str\": func(s string) string {\n\t\treturn s\n\t},\n})\nt, err := t.ParseFiles(\"index.html\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nt.ExecuteTemplate(os.Stdout, \"index.html\", Page{\n\tTitle: \"Hello\",\n})\n}"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA `structs:\"STR\"`\n\tC  int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif ok {\n\tt.Error(\"STR\")\n}", "gen": "t := &testing.T{}\nif !HasZero(B{\n\tI: 123,\n}) {\n\tt.Error(\"STRUCT\")\n}\n}"}
{"tgt": "digits := convert(N + 1)\nbits := len(digits)\nnoRepeat := 0\nfor b := 1; b < bits; b++ {\n\tnoRepeat += 9 * count(9, b-1)\n}\nhasSeen := make(map[int]bool, 10)\nfor b := 0; b < bits; b++ {\n\td := 0\n\tif b == 0 {\n\t\td = 1\n\t}\n\tfor ; d < digits[b]; d++ {\n\t\tif !hasSeen[d] {\n\t\t\tnoRepeat += count(9-b, bits-b-1)\n\t\t}\n\t}\n\tif hasSeen[digits[b]] {\n\t\tbreak\n\t}\n\thasSeen[digits[b]] = true\n}\nreturn N - noRepeat", "gen": "res := convert(n)\ncount := 0\nfor i := 1; i <= 9; i++ {\n\tcount += count(res, i)\n}\nfor i := 1; i <= 9; i++ {\n\tfor j := 1; j <= 9; j++ {\n\t\tif j != i {\n\t\t\tcount += count(res, j)\n\t\t}\n\t}\n}\nreturn res - count\n}"}
{"tgt": "return me[0] == \"STR\"", "gen": "return len(s) == 1 && s[0] == 'a'\n}"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil {\n\t\t\tmax = max.Right\n\t\t}\n\t\tmax.Right = root\n\t\troot, root.Left = root.Left, nil\n\t}\n}\nreturn res", "gen": "var res []int\nfor head != nil {\n\tif head.Next == nil {\n\t\tres = append(res, head.Val)\n\t\tbreak\n\t}\n\tres = append(res, head.Val)\n\thead = head.Next\n}\nfor head != nil {\n\thead = head.Next\n}\nfor head != nil {\n\thead = head.Next\n}\nreturn res\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   0x5555,\n\t\twant: 8,\n\t},\n}\nfor _, tt := range tests {\n\tgot := hammingWeight(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "for _, num := range []uint32{0, 2, 7, 3, 8, 1, 21845, 8, 4} {\n\tif hammingWeight(num) != num.countBits() {\n\t\tt.Fatalf(\"STR\", num, num.countBits())\n\t}\n}\n}"}
{"tgt": "if a == nil && b == nil {\n\treturn true\n}\nif len(a) != len(b) {\n\treturn false\n}\nfor i := range a {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "if len(s) == 0 || len(s) == len(t) {\n\treturn false\n}\nif len(s) == len(t) {\n\treturn true\n}\nfor i := 0; i < len(s); i++ {\n\tif s[i] != t[i] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "return xtime.Unix(int64(jt), 0), nil", "gen": "return Time{time.Unix(t, 0)}\n}"}
{"tgt": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 0},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 11},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 19},\n\t\tans1208{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s, p.t, p.maxCost))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"STR\", STR)\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\"\nSTR = \"STR\""}
{"tgt": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{}\n} else if n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{intervals[0]}\nfor _, cur := range intervals[1:] {\n\tprevious := res[len(res)-1]\n\tif cur.Start <= previous.End {\n\t\tend := previous.End\n\t\tif cur.End > end {\n\t\t\tend = cur.End\n\t\t}\n\t\tres = append(res[:len(res)-1], Interval{Start: previous.Start, End: end})\n\t} else {\n\t\tres = append(res, cur)\n\t}\n}\nreturn res", "gen": "if len(intervals) == 0 {\n\treturn []Interval{}\n}\nif len(intervals) == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{{intervals[0].Start, intervals[0].End}}\nfor i := 1; i < len(intervals); i++ {\n\tif res[len(res)-1].End >= intervals[i].Start {\n\t\tres[len(res)-1].End = max(res[len(res)-1].End, intervals[i].End)\n\t} else {\n\t\tres = append(res, intervals[i])\n\t}\n}\nreturn res\n}"}
{"tgt": "result := make([]int, 0, len(left)+len(right))\nfor len(left) > 0 || len(right) > 0 {\n\tif len(left) == 0 {\n\t\treturn append(result, right...)\n\t}\n\tif len(right) == 0 {\n\t\treturn append(result, left...)\n\t}\n\tif left[0] <= right[0] {\n\t\tresult = append(result, left[0])\n\t\tleft = left[1:]\n\t} else {\n\t\tresult = append(result, right[0])\n\t\tright = right[1:]\n\t}\n}\nreturn result", "gen": "res := make([]int, 0)\nfor i := 0; i < len(nums); i++ {\n\tif i == 0 {\n\t\tres = append(res, nums[i])\n\t} else if i == len(nums)-1 {\n\t\tres = append(res, nums[i])\n\t} else {\n\t\tif nums[i] > nums[i-1] && nums[i] > nums[i+1] {\n\t\t\tres = append(res, nums[i])\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "t.Parallel()\nd := NewTimeMap()\nd.Set(1, 1, 0)\nd.Set(1, 2, 2)\nif result := d.Get(1, 1); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 3); result != 2 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 5)\nif result := d.Get(1, 0); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 10); result != 1 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 0)\nd.Set(1, 2, 0)\nif result := d.Get(1, 0); result != 2 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(2, 0); result != nil {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, -1); result != nil {\n\tt.Errorf(\"STR\")\n}", "gen": "t.Parallel()\ntm := NewTimeMap()\ntm.Set(0, 0)\ntm.Set(2, 2)\ntm.Set(1, 1)\nif tm.Get(0) != 0 {\n\tt.Errorf(\"STR\", 0, 0, tm.Get(0))\n}\nif tm.Get(2) != 2 {\n\tt.Errorf(\"STR\", 2, 2, tm.Get(2))\n}\nif tm.Get(1) != 1 {\n\tt.Errorf(\"STR\", 1, 1, tm.Get(1))\n}\ntm.Set(3, 3)\ntm.Set(5, 5)\nif tm.Get(3) != 3 {\n\tt.Errorf(\"STR\", 3, 3, tm.Get(3))\n}\nif tm.Get(5) != 5 {\n\tt.Errorf(\"STR\", 5, 5, tm.Get(5))\n}\ntm.Set(10, 10)\nif tm.Get(10) != 10 {\n\tt.Errorf(\"STR\", 10, 10, tm.Get(10))\n}\ntm.Set(0, 1)\nif tm.Get(0) != 1 {\n\tt.Errorf(\"STR\", 0, 1, tm.Get(0))\n}\ntm.Set(0, 2)\nif tm.Get(0) != 2 {\n\tt.Errorf(\"STR\", 0, 2, tm.Get(0))\n}\ntm.Set(0, 3)\nif tm.Get(0) != 3 {\n\tt.Errorf(\"STR\", 0, 3, tm.Get(0))\n}\ntm.Set(0, 4)\nif tm.Get(0) != 4 {\n\tt.Errorf(\"STR\", 0, "}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{2},\n\t\t\t{3, 4},\n\t\t\t{6, 5, 7},\n\t\t\t{4, 1, 8, 3},\n\t\t},\n\t\t11},\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{1},\n\t\t\t{2, 3},\n\t\t},\n\t\t3},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := minimumTotal(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "var s = Solution{\n\tname: \"STR\",\n\tinputs: [][]int{\n\t\t{2, 3, 4},\n\t\t{1, 2, 3, 4},\n\t\t{6, 5, 7},\n\t},\n\texpect: []int{1, 2, 3},\n}\nSTRSTR := func(s, t string) int {\n\tif len(t) == 0 {\n\t\treturn 0\n\t}\n\tif len(s) == 0 {\n\t\treturn -1\n\t}\n\tif len(t) > len(s) {\n\t\treturn -1\n\t}\n\tif s[0] == t[0] {\n\t\treturn STRSTR(s[1:], t[1:])\n\t}\n\treturn STRSTR(s[1:], t)\n}\nSTRSTRSTR := func(s, t string) int {\n\tif len(t) == 0 {\n\t\treturn 0\n\t}\n\tif len(s) == 0 {\n\t\treturn -1\n\t}\n\tif len(t) > len(s) {\n\t\treturn -1\n\t}\n\tif s[0] == t[0] {\n\t\treturn STRSTRSTR(s[1:], t[1:])\n\t}\n\treturn STRSTRSTR(s[1:], t)\n}\nSTRSTRSTRSTR := func(s, t string) int {\n\tif len(t) == 0 {\n\t\treturn 0\n\t}\n\tif len(s) == 0 {\n\t\treturn -1\n\t}\n\tif len(t) > len(s) {\n\t\treturn -1\n\t}\n\tif s[0] == t[0] {\n\t\treturn STRSTRSTRSTR(s[1:], t[1:])\n\t}\n\treturn STRSTRSTR"}
{"tgt": "pairs := [...][2]int{{15, 26}, {1000, 1366}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p16(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "for _, tc := range []struct{\n\tin  int\n\tout int\n}{\n\t{15, 1},\n\t{26, 2},\n\t{1000, 1366},\n} {\n\tif p16(tc.in) != tc.out {\n\t\tt.Errorf(\"STR\", tc.in, tc.out)\n\t}\n}\n}"}
{"tgt": "m := [26]int{}\nfor _, b := range B {\n\tcount := counter(b)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tm[i] = count[i]\n\t\t}\n\t}\n}\nres := []string{}\nfor _, a := range A {\n\tcount := counter(a)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tcontinueL\n\t\t}\n\t}\n\tres = append(res, a)\n}\nreturn res", "gen": "var res []string\nfor _, str := range strs {\n\tcounter := counter(str)\n\tfor i := 0; i < 26; i++ {\n\t\tif counter[i] == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tres = append(res, counter.String())\n\t}\n}\nreturn res\n}"}
{"tgt": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\ntmp := nums[0]\nmax := tmp\nfor i := 1; i < n; i++ {\n\tif tmp < 0 {\n\t\ttmp = nums[i]\n\t} else {\n\t\ttmp += nums[i]\n\t}\n\tif max < tmp {\n\t\tmax = tmp\n\t}\n}\nreturn max", "gen": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\nvar sum int\nfor i := 0; i < n; i++ {\n\tsum += nums[i]\n\tif sum < nums[i] {\n\t\tsum = nums[i]\n\t}\n}\nreturn sum\n}"}
{"tgt": "hash := uint32(0)\nfor i := len(sep) - 1; i >= 0; i-- {\n\thash = hash*PrimeRK + uint32(sep[i])\n}\nvar pow, sq uint32 = 1, PrimeRK\nfor i := len(sep); i > 0; i >>= 1 {\n\tif i&1 != 0 {\n\t\tpow *= sq\n\t}\n\tsq *= sq\n}\nreturn hash, pow", "gen": "var sum, mul int\nfor i := len(nums) - 1; i >= 0; i-- {\n\tsum += nums[i]\n\tmul *= nums[i]\n}\nreturn (sum + mul) % 16777619\n}"}
{"tgt": "b, _ := ioutil.ReadFile(\"STR\")\ns := strings.Replace(string(b), \"STR\", \"STR\", -1)\nnumData := strings.Split(s, \"STR\")\nfor _, n := range numData {\n\tnumber, err := strconv.Atoi(n)\n\tif err == nil {\n\t\tdata = append(data, number)\n\t}\n}", "gen": "data, err := ioutil.ReadFile(\"input.txt\")\nif err != nil {\n\tpanic(err)\n}\ndata = strings.Replace(string(data), \"\\n\", \"\", -1)\ndata = strings.Split(data, \",\")\nfor _, d := range data {\n\ti, _ := strconv.Atoi(d)\n\tdata = append(data, i)\n}\nreturn data\n}"}
{"tgt": "if len(A) == len(A[0]) {\n\tfor i := 0; i < len(A); i++ {\n\t\tfor j := 0; j < len(A); j++ {\n\t\t\tif i == j {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]\n\t\t}\n\t}\n\treturn A\n}\nres := make([][]int, len(A[0]))\nfor i := 0; i < len(res); i++ {\n\tres[i] = make([]int, len(A))\n\tfor j := 0; j < len(A); j++ {\n\t\tres[i][j] = A[j][i]\n\t}\n}\nreturn res", "gen": "if len(nums) == 0 {\n\treturn 0\n}\nif len(nums) == 1 {\n\treturn nums[0]\n}\nfor i := 0; i < len(nums); i++ {\n\tfor j := 0; j < len(nums); j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\tfor k := 0; k < len(nums); k++ {\n\t\t\tif k == i {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnums[k], nums[i] = nums[i], nums[k]\n\t\t}\n\t}\n}\nreturn nums[0]\n}"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := SumRevLLNum(tc.first, tc.second); !equal(result, tc.sum) {\n\t\tt.Errorf(\"STR\",\n\t\t\ttcid, String(result), String(tc.sum))\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := SumRevLLNum(tc.num); res != tc.expected {\n\t\tt.Errorf(\"STR\", tc.num, res, tc.expected)\n\t}\n}\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tm: 3,\n\t\tn: 3,\n\t\tops: [][]int{\n\t\t\t{2, 2},\n\t\t\t{3, 3},\n\t\t},\n\t\twant: 4,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxCount(tt.m, tt.n, tt.ops)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.m, got, tt.want)\n\t}\n}", "gen": "var res int\nfor _, test := range [][]int{\n\t{2, 2, 3, 3},\n\t{2, 2, 3, 3},\n} {\n\tif maxCount(test) != 4 {\n\t\tt.Fatalf(\"STR\", test, maxCount(test))\n\t}\n}\n}"}
{"tgt": "n := len(quality)\nworkers := make([][2]float64, n)\nfor i := 0; i < n; i++ {\n\tw, q := float64(wage[i]), float64(quality[i])\n\tworkers[i][0], workers[i][1] = w/q, q\n}\nsort.Slice(workers, func(i, j int) bool {\n\treturn workers[i][0] < workers[j][0]\n})\nres := math.MaxFloat64\nsum := 0.\nh := floatHeap{}\nfor _, w := range workers {\n\tsum += w[1]\n\theap.Push(&h, w[1])\n\tif len(h) > K {\n\t\tsum -= heap.Pop(&h).(float64)\n\t}\n\tif len(h) == K {\n\t\tres = min(res, sum*w[0])\n\t}\n}\nreturn res", "gen": "n := len(reqs)\ndp := make([]float64, n)\nfor i := 0; i < n; i++ {\n\tdp[i] = float64(reqs[i]) / float64(max)\n}\nsort.Slice(dp, func(i, j int) bool {\n\treturn dp[i] < dp[j]\n})\nmin := math.MaxFloat64\nfor i := 0; i < n; i++ {\n\tmin = min(min, dp[i]*float64(i))\n}\nreturn min\n}"}
{"tgt": "flag.Parse()\nroots := flag.Args()\nif len(roots) == 0 {\n\troots = []string{\"STR\"}\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, root := range roots {\n\t\twalkDir(root, fileSizes)\n\t}\n\tclose(fileSizes)\n}()\nvar nfiles, nbytes int64\nfor size := range fileSizes {\n\tnfiles++\n\tnbytes += size\n}\nprintDiskUsage(nfiles, nbytes)", "gen": "if len(os.Args) != 2 {\n\tfmt.Println(\"Usage:\", os.Args[0], \"FILE\")\n\tos.Exit(1)\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, path := range os.Args[1:] {\n\t\twalk(path, fileSizes)\n\t}\n\tclose(fileSizes)\n}()\nreturn <-fileSizes\n}"}
{"tgt": "var min int\ntotalPeople := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\ttotalPeople++\n\t}\n}\nif totalPeople < 2 {\n\treturn 0\n}\nmiddle := (totalPeople / 2) + (totalPeople % 2)\nindex := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\tmiddle--\n\t}\n\tif middle == 0 {\n\t\tindex = i\n\t\tbreak\n\t}\n}\nleftZero := 0\nleftZeroFound := false\nfor j := index - 1; j >= 0; j-- {\n\tif !leftZeroFound && seating[j] == 0 {\n\t\tleftZero = j\n\t\tleftZeroFound = true\n\t} else if seating[j] == 1 && j < leftZero {\n\t\tmin += abs(j - leftZero)\n\t\tleftZero--\n\t}\n}\nrightZero := 0\nrightZeroFound := false\nfor j := index + 1; j < len(seating); j++ {\n\tif !rightZeroFound && seating[j] == 0 {\n\t\trightZero = j\n\t\trightZeroFound = true\n\t} else if seating[j] == 1 && j > rightZero {\n\t\tmin += abs(j - rightZero)\n\t\trightZero++\n\t}\n}\nreturn min", "gen": "var res int\nvar count int\nfor _, n := range nums {\n\tif n == 1 {\n\t\tcount++\n\t} else {\n\t\tcount--\n\t}\n\tif count == 0 {\n\t\tres += 1\n\t}\n}\nfor i := 0; i < len(nums); i++ {\n\tif nums[i] == 1 {\n\t\tcount++\n\t} else {\n\t\tcount--\n\t}\n\tfor count == 0 {\n\t\tres += abs(nums[i] - nums[i-1])\n\t\tcount++\n\t}\n}\nreturn res\n}"}
{"tgt": "sum := 0\nprev := 1\ncurr := 1\nfor curr <= 4e6 {\n\tprev, curr = curr, prev+curr\n\tif curr%2 == 0 {\n\t\tsum += curr\n\t}\n}\nfmt.Println(sum)", "gen": "var sum, i int\nfor i = 1; i <= 4000000; i++ {\n\tif i%2 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "stack := make([]int, 0)\nresult := make([]int, len(T))\nfor i, t := range T {\n\tfor len(stack) > 0 && T[stack[len(stack)-1]] < t {\n\t\tresult[stack[len(stack)-1]] = i - stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t}\n\tstack = append(stack, i)\n}\nfor _, i := range stack {\n\tresult[i] = 0\n}\nreturn result", "gen": "res := make([]int, 0)\nfor _, num := range nums {\n\tif len(res) == 0 || res[len(res)-1] != num {\n\t\tres = append(res, num)\n\t} else {\n\t\tres[len(res)-1] = num\n\t}\n}\nreturn res\n}"}
{"tgt": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 2}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "var res [][]int\nfor i := 0; i < 3; i++ {\n\tfor j := 0; j < 3; j++ {\n\t\tfor k := 0; k < 3; k++ {\n\t\t\tif i == j || i == k || j == k {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tres = append(res, []int{i, j, k})\n\t\t}\n\t}\n}\nfor _, t := range res {\n\tfmt.Printf(\"STR\", t)\n}\nfor i := 0; i < 3; i++ {\n\tfor j := 0; j < 3; j++ {\n\t\tfor k := 0; k < 3; k++ {\n\t\t\tif i == j || i == k || j == k {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif isBoomerang([]int{t[0], t[1], t[2]}, []int{t[0], t[1], t[2]}, []int{t[0], t[1], t[2]}) {\n\t\t\t\tfmt.Printf(\"STR\", t)\n\t\t\t}\n\t\t}\n\t}\n}\n}"}
{"tgt": "out := 100\nif x := p33(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "t.Errorf(\"STR\", p33(100))\nif p33(100) != 100 {\n\tt.Errorf(\"STR\", p33(100))\n}\n}"}
