{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif sum := SumBSTRange(tc.root, tc.a, tc.b); sum != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, sum)\n\t}\n}", "gen": "t := testing.T{}\nt.Parallel()\nfor i := 0; i < len(testcases); i++ {\n\tif SumBSTRange(testcases[i].root, testcases[i].low, testcases[i].high) != testcases[i].sum {\n\t\tt.Errorf(\"SumBSTRange(%v, %v, %v) = %v; want %v\", testcases[i].root, testcases[i].low, testcases[i].high, SumBSTRange(testcases[i].root, testcases[i].low, testcases[i].high), testcases[i].sum)\n\t}\n}\n}\n"}
{"tgt": "return &linkLoop{\n\tHead: &linkLoopNode{},\n}", "gen": "var linkLoop *linkLoopNode\nlinkLoop = new(linkLoopNode)\nlinkLoop.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoop = new(linkLoopNode)\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return bindataRead(\n\t_assetsHomeCatJpg,\n\t\"STR\",\n)", "gen": "var homeCatJpg []byte\nvar homeCatJpg2 []byte\nvar homeCatJpg3 []byte\nvar homeCatJpg4 []byte\nvar homeCatJpg5 []byte\nhomeCatJpg = bindataRead(homeCatJpg, homeCatJpg2, homeCatJpg3, homeCatJpg4, homeCatJpg5, \".\", \"assets\", \"HomeCat.jpg\")\nreturn homeCatJpg\n}\n\n// func bindataRead(homeCatJpg []byte, homeCatJpg2 []byte, homeCatJpg3 []byte, homeCatJpg4 []byte, homeCatJpg5 []byte, dir string, subdir string, filename string) []byte {\n// \tvar buf []byte\n// \tvar err error\n// \tbuf, err = bindataRead(homeCatJpg, homeCatJpg2, homeCatJpg3, homeCatJpg4, homeCatJpg5, dir, subdir, filename)\n// \tif err != nil {\n// \t\tpanic(err)\n// \t}\n// \treturn buf\n// }\n\n// func bindataRead(homeCatJpg []byte, homeCatJpg2 []byte, homeCatJpg3 []byte, homeCatJpg4 []byte, homeCatJpg5 []byte, dir string, subdir string, filename string) ([]byte, error) {\n// \tvar buf []byte\n// \tvar err error\n// \tbuf, err = bindataRead(homeCatJpg, homeCatJpg2, homeCatJpg3, homeCatJpg4, homeCatJpg5, dir, subdir, filename)\n// \tif err != nil {\n// \t\treturn nil, err\n// \t}\n// \treturn buf, nil\n// }\n\n// func bindataRead(homeCatJpg []byte, homeCatJpg2 []byte, homeCatJpg3 []byte, homeCatJpg4 []byte, homeCatJpg5 []byte, dir string, subdir string, filename string) ([]byte, error) {\n// \tvar buf []byte\n// "}
{"tgt": "max := 1000\nsum := 0\nfor i := 1; i < max; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)", "gen": "var a int\nfor i := 1; i < 1000; i++ {\n\tif i%2 == 0 {\n\t\ta += i\n\t} else {\n\t\ta += i * i\n\t}\n}\nfmt.Println(a)\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.locs); !reflect.DeepEqual(bonuses, tc.bonuses) {\n\t\tt.Errorf(\"STR\", tc.bonuses, bonuses)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "max := 9999\nbiggestPandigital := 0\nvar numberMultiplied int\nfor i := max; i > 0; i-- {\n\tnumberMultiplied = i\n\tfor j := 1; len(digits(numberMultiplied)) <= 9; j++ {\n\t\tnumberMultiplied = concatenMultiplication(i, j)\n\t\tif IsPandigital(numberMultiplied) && numberMultiplied > biggestPandigital {\n\t\t\tfmt.Println(numberMultiplied)\n\t\t\tbiggestPandigital = numberMultiplied\n\t\t}\n\t}\n}", "gen": "var pandigital []int\nfor i := 9999; i > 0; i-- {\n\tif IsPandigital(i) {\n\t\tpandigital = append(pandigital, i)\n\t}\n}\nfor _, i := range pandigital {\n\tif IsPandigital(concatenMultiplication(i)) {\n\t\tfmt.Println(i)\n\t}\n}\n}"}
{"tgt": "for {\n\tswitch r := l.next(); {\n\tcase unicode.IsNumber(r):\n\tcase r == \"STR\":\n\t\tl.backup()\n\t\tl.emit(itemEnd)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase r == eof:\n\t\tl.emit(itemEnd)\n\t\treturn byteRangeSet\n\tdefault:\n\t\treturn l.error(\"STR\")\n\t}\n}", "gen": "var r *httprange.Lexer\nr = httprange.NewLexer([]byte(\"bytes=0-100\"))\nfor {\n\tif r.Next() == 44 {\n\t\tr.Backup()\n\t\tr.Emit(4)\n\t\tr.Chomp()\n\t\treturn byteRangeSet\n\t}\n\tif unicode.IsNumber(rune(r.Next())) {\n\t\tr.Backup()\n\t\tr.Emit(4)\n\t\tr.Chomp()\n\t\treturn byteRangeSet\n\t}\n\tif r.Next() == 44 {\n\t\tr.Backup()\n\t\tr.Emit(4)\n\t\tr.Chomp()\n\t\treturn byteRangeSet\n\t}\n\tif r.Next() == 0 {\n\t\tr.Backup()\n\t\tr.Emit(4)\n\t\tr.Chomp()\n\t\treturn byteRangeSet\n\t}\n}\n}\n"}
{"tgt": "return func(treebinaryTreeIf, node interface{}) bool {\n\tn := node.(*gbtElement)\n\tif !tree.IsNil(n.Left) && n.Left.Key >= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Left, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif !tree.IsNil(n.Right) && n.Right.Key <= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Right, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif debug {\n\t\tfmt.Println(n)\n\t}\n\t*nodeCnt++\n\treturn false\n}", "gen": "t := &testing.T{}\ncheckGBT(t, 1, true)\n}\n"}
{"tgt": "iterator := func() <-chan VertexId {\n\tch := make(chan VertexId)\n\tgo func() {\n\t\tif connected, ok := g.edges[vertex]; ok {\n\t\t\tfor VertexId, _ := range connected {\n\t\t\t\tif g.IsEdge(vertex, VertexId) {\n\t\t\t\t\tch <- VertexId\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\nreturn VerticesIterable(&vertexIterableHelper{iterFunc: iterator})", "gen": "g := graph.NewGraph()\nv1 := graph.NewVertex(1)\nv2 := graph.NewVertex(2)\ng.AddVertex(v1)\ng.AddVertex(v2)\ng.AddEdge(v1, v2)\nfmt.Println(g)\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 2, 1}, []int{0, 4, 1, 3, 2}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1}, []int{0}, []int{1}},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums, c.index)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums, c.index)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.nums = []int{1, 2, 3, 4}\nsolution.index = 0\nsolution.expect = 5\nsolution.name = \"TestSolution\"\ntesting.RunTests(&solution)\n}\n"}
{"tgt": "c.bw.WriteString(\"STR\")\nc.bw.WriteByte(space)\nc.bw.WriteString(key)\nc.bw.WriteByte(space)\nc.bw.Write(strconv.AppendInt(c.numScratch[:0], int64(timeout), 10))\n_, err = c.bw.Write(crlf)\nreturn", "gen": "var w io.Writer\nvar b *bufio.Writer\nvar err error\nvar s string\nvar i int\nvar n int64\nvar n2 int64\nvar n3 int64\nvar n4 int64\nvar n5 int64\nvar n6 int64\nvar n7 int64\nvar n8 int64\nvar n9 int64\nvar n10 int64\nvar n11 int64\nvar n12 int64\nvar n13 int64\nvar n14 int64\nvar n15 int64\nvar n16 int64\nvar n17 int64\nvar n18 int64\nvar n19 int64\nvar n20 int64\nvar n21 int64\nvar n22 int64\nvar n23 int64\nvar n24 int64\nvar n25 int64\nvar n26 int64\nvar n27 int64\nvar n28 int64\nvar n29 int64\nvar n30 int64\nvar n31 int64\nvar n32 int64\nvar n33 int64\nvar n34 int64\nvar n35 int64\nvar n36 int64\nvar n37 int64\nvar n38 int64\nvar n39 int64\nvar n40 int64\nvar n41 int64\nvar n42 int64\nvar n43 int64\nvar n44 int64\nvar n45 int64\nvar n46 int64\nvar n47 int64\nvar n48 int64\nvar n49 int64\nvar n50 int64\nvar n51 int64\nvar n52 int64\nvar n53 int64\nvar"}
{"tgt": "for V > 0 {\n\tV--\n\tif !isDroppedLeft(heights, K) && !isDroppedRight(heights, K) {\n\t\theights[K]++\n\t}\n}\nreturn heights", "gen": "var n, k int\nfmt.Scan(&n, &k)\na := make([]int, n)\nfor i := 0; i < n; i++ {\n\tfmt.Scan(&a[i])\n}\nfor i := 0; i < n; i++ {\n\tif isDroppedLeft(a, i, k) {\n\t\tcontinue\n\t}\n\tif isDroppedRight(a, i, k) {\n\t\tcontinue\n\t}\n\ta[i]++\n}\nfmt.Println(a[0], a[1], a[2])\n}\n"}
{"tgt": "h := &IntMaxHeap{}\nheap.Init(h)\nheap.Push(h, 7)\nheap.Push(h, 3)\nheap.Push(h, 2)\nheap.Push(h, 1)\nheap.Push(h, 5)\nheap.Push(h, 5)\nheap.Push(h, 6)\nheap.Push(h, 7)\nfmt.Printf(\"STR\", (*h))\nfor h.Len() > 0 {\n\tfmt.Printf(\"STR\", heap.Pop(h))\n}", "gen": "heap := &Solution{[]int{3, 2, 1}}\nheap.Init()\nheap.Push(2)\nheap.Push(1)\nheap.Push(5)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push"}
{"tgt": "sLen, pLen := len(s), len(p)\ndp := make([][]bool, sLen+1)\nfor i := range dp {\n\tdp[i] = make([]bool, pLen+1)\n}\ndp[sLen][pLen] = true\nfor i := sLen; i > -1; i-- {\n\tfor j := pLen - 1; j > -1; j-- {\n\t\tfirstMatch := i < sLen && (p[j] == s[i] || p[j] == '.')\n\t\tif j+1 < pLen && p[j+1] == '*' {\n\t\t\tdp[i][j] = dp[i][j+2] || firstMatch && dp[i+1][j]\n\t\t} else {\n\t\t\tdp[i][j] = firstMatch && dp[i+1][j+1]\n\t\t}\n\t}\n}\nreturn dp[0][0]", "gen": "var a []bool\nvar b []bool\nvar c []bool\nvar d bool\nvar e bool\nvar f bool\nvar g bool\nvar h bool\nvar i bool\nvar j bool\nvar k bool\nvar l bool\nvar m bool\nvar n bool\nvar o bool\nvar p bool\nvar q bool\nvar r bool\nvar s bool\nvar t bool\nvar u bool\nvar v bool\nvar w bool\nvar x bool\nvar y bool\nvar z bool\nvar aa bool\nvar bb bool\nvar cc bool\nvar dd bool\nvar ee bool\nvar ff bool\nvar gg bool\nvar hh bool\nvar ii bool\nvar jj bool\nvar kk bool\nvar ll bool\nvar mm bool\nvar nn bool\nvar oo bool\nvar pp bool\nvar qq bool\nvar rr bool\nvar ss bool\nvar tt bool\nvar uu bool\nvar vv bool\nvar ww bool\nvar xx bool\nvar yy bool\nvar zz bool\nvar aa bool\nvar bb bool\nvar cc bool\nvar dd bool\nvar ee bool\nvar ff bool\nvar gg bool\nvar hh bool\nvar ii bool\nvar jj bool\nvar kk bool\nvar ll bool\nvar mm bool\nvar nn bool\nvar oo bool\nvar pp bool\nvar qq bool\nvar rr bool\nvar ss bool\nvar tt bool\nvar uu bool\nvar vv bool\nvar ww bool\nvar x bool\nvar y bool\nvar z bool\nvar aa bool\nvar bb bool\nvar cc bool\nvar dd bool\nvar ee bool\nvar ff bool\nvar gg bool\nvar hh bool\nvar ii bool\nvar jj bool\nvar kk bool\nvar ll bool\nvar mm bool\nvar nn bool\nvar oo bool"}
{"tgt": "l1 := len(board)\nif l1 == 0 {\n\treturn\n}\nl2 := len(board[0])\nif l2 == 0 {\n\treturn\n}\nvisit := make([][]bool, l1)\nfor i := 0; i < l1; i++ {\n\tvisit[i] = make([]bool, l2)\n}\nfor i := 0; i < l1; i++ {\n\tfor j := 0; j < l2; j++ {\n\t\tif !visit[i][j] {\n\t\t\thelper(board, visit, i, j)\n\t\t}\n\t}\n}", "gen": "var a []bool\nvar b []bool\nvar c []bool\nvar d []bool\nvar e []bool\nvar f []bool\nvar g []bool\nvar h []bool\nvar i []bool\nvar j []bool\nvar k []bool\nvar l []bool\nvar m []bool\nvar n []bool\nvar o []bool\nvar p []bool\nvar q []bool\nvar r []bool\nvar s []bool\nvar t []bool\nvar u []bool\nvar v []bool\nvar w []bool\nvar x []bool\nvar y []bool\nvar z []bool\nvar aa []bool\nvar bb []bool\nvar cc []bool\nvar dd []bool\nvar ee []bool\nvar ff []bool\nvar gg []bool\nvar hh []bool\nvar ii []bool\nvar jj []bool\nvar kk []bool\nvar ll []bool\nvar mm []bool\nvar nn []bool\nvar oo []bool\nvar pp []bool\nvar qq []bool\nvar rr []bool\nvar ss []bool\nvar tt []bool\nvar uu []bool\nvar vv []bool\nvar ww []bool\nvar xx []bool\nvar yy []bool\nvar zz []bool\nvar aa1 []bool\nvar bb1 []bool\nvar cc1 []bool\nvar dd1 []bool\nvar ee1 []bool\nvar ff1 []bool\nvar gg1 []bool\nvar hh1 []bool\nvar ii1 []bool\nvar jj1 []bool\nvar kk1 []bool\nvar ll1 []bool\nvar mm1 []bool\nvar nn1 []bool\nvar oo1 []bool\nvar pp1 []bool\nvar qq1 []bool\nvar rr1 []bool\nvar ss1 []bool\nvar tt1 []bool\nvar uu1 []bool\nvar vv1 []bool\nvar ww1 []bool\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.nums); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t := testing.T{}\nt.Parallel()\nfor i, test := range testcases {\n\tif got := SmallerRightCount(test.input); !reflect.DeepEqual(got, test.want) {\n\t\tt.Errorf(\"SmallerRightCount(%v) = %v, want %v\", test.input, got, test.want)\n\t}\n}\n}\n"}
{"tgt": "sum := 100 * 101 / 2\nsqSum := sum * sum\nsumSq := 0\nfor i := 1; i <= 100; i++ {\n\tsumSq += i * i\n}\nfmt.Println(sqSum - sumSq)", "gen": "var a int\nfor i := 1; i <= 100; i++ {\n\ta += i\n}\nvar b int\nb = a\nvar c int\nc = b\nvar d int\nd = c\nvar e int\ne = d\nvar f int\nf = e\nvar g int\ng = f\nvar h int\nh = g\nvar i int\ni = h\nvar j int\nj = i\nvar k int\nk = j\nvar l int\nl = k\nvar m int\nm = l\nvar n int\nn = m\nvar o int\no = n\nvar p int\np = o\nvar q int\nq = p\nvar r int\nr = q\nvar s int\ns = r\nvar t int\nt = s\nvar u int\nu = t\nvar v int\nv = u\nvar w int\nw = v\nvar x int\nx = w\nvar y int\ny = x\nvar z int\nz = y\nvar aa int\naa = z\nvar bb int\nbb = aa\nvar cc int\ncc = bb\nvar dd int\ndd = cc\nvar ee int\nee = dd\nvar ff int\nff = ee\nvar gg int\ngg = ff\nvar hh int\nhh = gg\nvar ii int\nii = hh\nvar jj int\njj = ii\nvar kk int\nkk = jj\nvar ll int\nll = kk\nvar mm int\nmm = ll\nvar nn int\nnn = mm\nvar oo int\noo = nn\nvar pp int\npp = oo\nvar qq int\nqq = pp\nvar rr int\nrr = qq\nvar ss int\nss = rr\nvar tt int\ntt ="}
{"tgt": "return x != y", "gen": "var a float32 = 1.0\nvar b float32 = 2.0\nvar c bool\nif a < b {\n\tc = true\n} else {\n\tc = false\n}\nfmt.Println(c)\n}\n\n// 1. \u628a a < b \u8fd9\u4e2a\u6761\u4ef6\u5224\u65ad\u7684\u7ed3\u679c\u5b58\u50a8\u5230 eax \u5bc4\u5b58\u5668\u4e2d\uff0c\u7136\u540e\u628a eax \u5bc4\u5b58\u5668\u7684\u503c\u5b58\u50a8\u5230 c \u53d8\u91cf\u4e2d\n// 2. \u628a c \u53d8\u91cf\u7684\u503c\u5b58\u50a8\u5230 eax \u5bc4\u5b58\u5668\u4e2d\n// 3. \u628a eax \u5bc4\u5b58\u5668\u7684\u503c\u5b58\u50a8\u5230 c \u53d8\u91cf\u4e2d\n// 4. \u628a c \u53d8\u91cf\u7684\u503c\u5b58\u50a8\u5230 eax \u5bc4\u5b58\u5668\u4e2d\n// 5. \u628a eax \u5bc4\u5b58\u5668\u7684\u503c\u5b58\u50a8\u5230 c \u53d8\u91cf\u4e2d\n// 6. \u628a c \u53d8\u91cf\u7684\u503c\u5b58\u50a8\u5230 eax \u5bc4\u5b58\u5668\u4e2d\n// 7. \u628a eax \u5bc4\u5b58\u5668\u7684\u503c\u5b58\u50a8\u5230 c \u53d8\u91cf\u4e2d\n// 8. \u628a c \u53d8\u91cf\u7684\u503c\u5b58\u50a8\u5230 eax \u5bc4\u5b58\u5668\u4e2d\n// 9. \u628a eax \u5bc4\u5b58\u5668\u7684\u503c\u5b58\u50a8\u5230 c \u53d8\u91cf\u4e2d\n// 10. \u628a c \u53d8\u91cf\u7684\u503c\u5b58\u50a8\u5230 eax \u5bc4\u5b58\u5668\u4e2d\n// 11. \u628a eax \u5bc4\u5b58\u5668\u7684\u503c\u5b58\u50a8\u5230 c \u53d8\u91cf\u4e2d\n// 12. \u628a c \u53d8\u91cf\u7684\u503c\u5b58\u50a8\u5230 eax \u5bc4\u5b58\u5668\u4e2d\n// 13. \u628a eax \u5bc4\u5b58\u5668\u7684\u503c\u5b58\u50a8\u5230 c \u53d8\u91cf\u4e2d\n// 14. \u628a c \u53d8\u91cf\u7684\u503c\u5b58\ufffd\ufffd"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 1, 3}},\n\t\tans1051{3},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 2, 3, 4}},\n\t\tans1051{5},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{0},\n\t},\n\t{\n\t\tpara1051{[]int{5, 4, 3, 2, 1}},\n\t\tans1051{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%d %d %d\\n\", 1, 2, 3)\nfmt.Printf(\"%d %d %d\\n\", 4, 1, 2)\nfmt.Printf(\"%d %d %d\\n\", 3, 4, 2)\nfmt.Printf(\"%d %d %d\\n\", 5, 1, 2)\nfmt.Printf(\"%d %d %d\\n\", 5, 4, 3)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5,"}
{"tgt": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"STR\", got, tt.want)\n\t\t}\n\t})\n}", "gen": "tests := []struct {\n\targs    [2]string\n\twant    int\n\tname    string\n\targsLen int\n}{\n\t{\n\t\targs:    [2]string{\"abcde\", \"cdefg\"},\n\t\twant:    2,\n\t\tname:    \"test1\",\n\t\targsLen: 2,\n\t},\n\t{\n\t\targs:    [2]string{\"ab\", \"eidbaooo\"},\n\t\twant:    2,\n\t\tname:    \"test2\",\n\t\targsLen: 2,\n\t},\n\t{\n\t\targs:    [2]string{\"abcd\", \"dcba\"},\n\t\twant:    4,\n\t\tname:    \"test3\",\n\t\targsLen: 2,\n\t},\n\t{\n\t\targs:    [2]string{\"a\", \"aa\"},\n\t\twant:    0,\n\t\tname:    \"test4\",\n\t\targsLen: 2,\n\t},\n\t{\n\t\targs:    [2]string{\"a\", \"a\"},\n\t\twant:    1,\n\t\tname:    \"test5\",\n\t\targsLen: 2,\n\t},\n\t{\n\t\targs:    [2]string{\"abc\", \"abc\"},\n\t\twant:    3,\n\t\tname:    \"test6\",\n\t\targsLen: 2,\n\t},\n\t{\n\t\targs:    [2]string{\"abc\", \"abcd\"},\n\t\twant:    4,\n\t\tname:    \"test7\",\n\t\targsLen: 2,\n\t},\n\t{\n\t\targs:    [2]string{\"abcd\", \"abc\"},\n\t\twant:    4,\n\t\tname:    \"test8\",\n\t\targsLen: 2,\n\t},\n\t{"}
{"tgt": "if m == 0 {\n\treturn 1\n}\nswitch n {\ncase 1:\n\treturn 2\ncase 2:\n\tif m == 1 {\n\t\treturn 3\n\t}\n\treturn 4\ndefault:\n\tswitch m {\n\tcase 1:\n\t\treturn 4\n\tcase 2:\n\t\treturn 7\n\tdefault:\n\t\treturn 8\n\t}\n}", "gen": "var a int\nvar b int\nif a == 0 {\n\ta = 1\n} else if a == 1 {\n\ta = 2\n} else if a == 2 {\n\ta = 3\n} else {\n\ta = 4\n}\nif b == 0 {\n\tb = 1\n} else if b == 1 {\n\tb = 2\n} else if b == 2 {\n\tb = 3\n} else {\n\tb = 4\n}\nif a == 1 {\n\ta = 2\n} else if a == 2 {\n\ta = 3\n} else if a == 3 {\n\ta = 4\n} else {\n\ta = 5\n}\nif b == 1 {\n\tb = 2\n} else if b == 2 {\n\tb = 3\n} else if b == 3 {\n\tb = 4\n} else {\n\tb = 5\n}\nif a == 2 {\n\ta = 3\n} else if a == 3 {\n\ta = 4\n} else if a == 4 {\n\ta = 5\n} else {\n\ta = 6\n}\nif b == 2 {\n\tb = 3\n} else if b == 3 {\n\tb = 4\n} else if b == 4 {\n\tb = 5\n} else {\n\tb = 6\n}\nif a == 3 {\n\ta = 4\n} else if a == 4 {\n\ta = 5\n} else if a == 5 {\n\ta = 6\n} else {\n\ta = 7\n}\nif b == 3 {\n\tb = 4\n} else if b == 4 {\n\tb = 5\n} else if b == 5 {\n"}
{"tgt": "sort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].End < intervals[j].End\n})\ncount := 0\ncurrent := -int(^uint(0)>>1) - 1\nfor _, interval := range intervals {\n\tif interval.Start >= current {\n\t\tcount++\n\t\tcurrent = interval.End\n\t}\n}\nreturn len(intervals) - count", "gen": "intervals := []Interval{{1, 2}, {2, 3}, {3, 4}, {1, 3}}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nvar res []Interval\nfor _, interval := range intervals {\n\tif res == nil || res[len(res)-1].End < interval.Start {\n\t\tres = append(res, interval)\n\t} else {\n\t\tres[len(res)-1].End = max(res[len(res)-1].End, interval.End)\n\t}\n}\nreturn res\n}"}
{"tgt": "switch rand.Intn(10) {\ncase 1, 9:\n\treturn io.EOF\ncase 5:\n\treturn errors.New(\"STR\")\ndefault:\n\td.Line = \"STR\"\n\tfmt.Println(\"STR\", d.Line)\n\treturn nil\n}", "gen": "var err error\nvar r int\nvar c int\nr = rand.Intn(10)\nif r == 9 {\n\tc = 0\n\terr = errors.New(\"\")\n} else if r == 9 {\n\tc = 0\n\terr = errors.New(\"\")\n} else if r == 1 {\n\tc = 0\n\terr = errors.New(\"\")\n} else if r == 5 {\n\tc = 0\n\terr = errors.New(\"\")\n}\nif err != nil {\n\tfmt.Println(err)\n}\nvar s string\ns = \"hello\"\nvar s2 string\ns2 = \"world\"\nvar s3 string\ns3 = \"hello\"\nvar s4 string\ns4 = \"world\"\nvar s5 string\ns5 = \"hello\"\nvar s6 string\ns6 = \"world\"\nvar s7 string\ns7 = \"hello\"\nvar s8 string\ns8 = \"world\"\nvar s9 string\ns9 = \"hello\"\nvar s10 string\ns10 = \"world\"\nvar s11 string\ns11 = \"hello\"\nvar s12 string\ns12 = \"world\"\nvar s13 string\ns13 = \"hello\"\nvar s14 string\ns14 = \"world\"\nvar s15 string\ns15 = \"hello\"\nvar s16 string\ns16 = \"world\"\nvar s17 string\ns17 = \"hello\"\nvar s18 string\ns18 = \"world\"\nvar s19 string\ns19 = \"hello\"\nvar s20 string\ns20 = \"world\"\nvar s21 string\ns21 = \"hello\"\nvar s22 string\ns22 = \"world\"\nvar s23 string\ns23 ="}
{"tgt": "fmt.Println(subarrayBitwiseORs([]int{0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))", "gen": "fmt.Println(subarrayBitwiseORs([]int{1, 1, 0}))\nfmt.Println(subarrayBitwiseORs([]int{0, 1}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 1}))\n}\n"}
{"tgt": "dummy := &ListNode{0, head}\nslow, fast := dummy, dummy\nfor fast.Next != nil && fast.Next.Next != nil {\n\tfast = fast.Next.Next\n\tslow = slow.Next\n}\nreturn slow.Next", "gen": "var a *[2]int\nvar b *[2]int\na = new([2]int)\nb = new([2]int)\n*a = [2]int{0, 0}\n*b = [2]int{0, 0}\nfor {\n\tif *a != [2]int{0, 0} {\n\t\tbreak\n\t}\n\t*a = [2]int{*a[1], *a[0]}\n\t*b = [2]int{*b[1], *b[0]}\n}\nreturn *a\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "pairs := [...][2]int{{10, 7}, {1000, 983}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p26(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var a, b int\na = 10\nb = 7\nvar c, d int\nc = 1000\nd = 983\nvar e int\ne = 2\nvar f, g int\nf, g = p26(a, b)\nif f != c || g != d {\n\ttesting.T.Errorf(e, \"f=%d, g=%d, want %d, %d\", f, g, c, d)\n}\n}"}
{"tgt": "n := len(A)\nfor i := n - 2; i >= 0; i-- {\n\tA[i] += A[i+1]\n}\nmem := [101][33]int{}\nvar dp func(int, int) int\ndp = func(i, m int) int {\n\tif i+2*m >= n {\n\t\treturn A[i]\n\t}\n\tif mem[i][m] > 0 {\n\t\treturn mem[i][m]\n\t}\n\tres := 0\n\tfor x := 1; x <= 2*m; x++ {\n\t\tres = max(\n\t\t\tres,\n\t\t\tA[i]-dp(i+x, max(m, x)),\n\t\t)\n\t}\n\tmem[i][m] = res\n\treturn res\n}\nreturn dp(0, 1)", "gen": "var stones []int\nvar i int\nvar j int\nvar sum int\nvar max int\nvar tmp int\nvar tmp2 int\nvar tmp3 int\nvar tmp4 int\nvar tmp5 int\nvar tmp6 int\nvar tmp7 int\nvar tmp8 int\nvar tmp9 int\nvar tmp10 int\nvar tmp11 int\nvar tmp12 int\nvar tmp13 int\nvar tmp14 int\nvar tmp15 int\nvar tmp16 int\nvar tmp17 int\nvar tmp18 int\nvar tmp19 int\nvar tmp20 int\nvar tmp21 int\nvar tmp22 int\nvar tmp23 int\nvar tmp24 int\nvar tmp25 int\nvar tmp26 int\nvar tmp27 int\nvar tmp28 int\nvar tmp29 int\nvar tmp30 int\nvar tmp31 int\nvar tmp32 int\nvar tmp33 int\nvar tmp34 int\nvar tmp35 int\nvar tmp36 int\nvar tmp37 int\nvar tmp38 int\nvar tmp39 int\nvar tmp40 int\nvar tmp41 int\nvar tmp42 int\nvar tmp43 int\nvar tmp44 int\nvar tmp45 int\nvar tmp46 int\nvar tmp47 int\nvar tmp48 int\nvar tmp49 int\nvar tmp50 int\nvar tmp51 int\nvar tmp52 int\nvar tmp53 int\nvar tmp54 int\nvar tmp55 int\nvar tmp56 int\nvar tmp57 int\nvar tmp58 int\nvar tmp59 int\nvar tmp60 int\nvar tmp61 int\nvar tmp62 int\nvar tmp63 int\nvar tmp64 int\nvar tmp65 int\nvar tmp66 int\nvar tmp67 int\nvar tmp68 int\nvar tmp69 int\n"}
{"tgt": "if n == 0 {\n\treturn 0\n}\nreturn n/5 + trailingZeroes(n/5)", "gen": "fmt.Println(trailingZeroes(10))\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0}, 5},\n\t{\"STR\", []int{0, 0, 0, 0, 1}, []int{1, 0, 0, 0, 0}, 4},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums1, c.nums2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums1, c.nums2)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.nums1 = []int{1, 2, 3, 4}\nsolution.nums2 = []int{2, 3, 4}\nsolution.expect = 3\nsolution.name = \"Test1\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{1, 2}\nsolution.nums2 = []int{1, 2}\nsolution.expect = 3\nsolution.name = \"Test2\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{1, 2}\nsolution.nums2 = []int{3}\nsolution.expect = 0\nsolution.name = \"Test3\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{2, 3, 4}\nsolution.nums2 = []int{1, 2}\nsolution.expect = 3\nsolution.name = \"Test4\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{1, 2, 3, 4}\nsolution.nums2 = []int{1, 2, 3, 4}\nsolution.expect = 7\nsolution.name = \"Test5\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{1, 2, 3, 4}\nsolution.nums2 = []int{1, 2, 3, 4}\nsolution.expect = 1\nsolution.name = \"Test6\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{1, 2, 3, 4}\nsolution.nums2 = []int{1, 2, 3, 4}\nsolution.expect = 1\nsolution.name = \"Test7\"\nsolution.TestSolution()\n\n"}
{"tgt": "list.rear = nil", "gen": "var x *int\n*x = 0\n}\n\n// Test that we can handle a function call with a memory arg.\n// This is a bit tricky because the memory arg is not\n// a pointer, but a value.\n\n<ASM>\nmovq %rdi,-8(%rbp)\nmovq -8(%rbp),%rax\nleaq <runtime.writeBarrier>(%rip),%rdx\nmovl (%rdx),%edx\ntestl %edx,%edx\njne .L41\n.LBB49:\nmovq $0,(%rax)\n.LBE49:\njmp .L40\n.L41:\n.LBB50:\nmovl $0,%esi\nmovq %rax,%rdi\ncall <runtime.gcWriteBarrier@PLT>\n.L40:\nleave\nret</ASM>"}
{"tgt": "if len(name) == 0 && len(typed) == 0 {\n\treturn true\n}\nif (len(name) == 0 && len(typed) != 0) || (len(name) != 0 && len(typed) == 0) {\n\treturn false\n}\nj := 0\nfor i := 0; i < len(name); i++ {\n\tif j < len(typed) && name[i] == typed[j] {\n\t\tj++\n\t\tcontinue\n\t} else {\n\t\tif i > 0 && j < len(typed) && name[i-1] == typed[j] {\n\t\t\tj++\n\t\t\ti--\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "var a [2]int\nvar b [2]int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar A int\nvar B int\nvar C int\nvar D int\nvar E int\nvar F int\nvar G int\nvar H int\nvar I int\nvar J int\nvar K int\nvar L int\nvar M int\nvar N int\nvar O int\nvar P int\nvar Q int\nvar R int\nvar S int\nvar T int\nvar U int\nvar V int\nvar W int\nvar X int\nvar Y int\nvar Z int\nvar a1 int\nvar b1 int\nvar c1 int\nvar d1 int\nvar e1 int\nvar f1 int\nvar g1 int\nvar h1 int\nvar i1 int\nvar j1 int\nvar k1 int\nvar l1 int\nvar m1 int\nvar n1 int\nvar o1 int\nvar p1 int\nvar q1 int\nvar r1 int\nvar s1 int\nvar t1 int\nvar u1 int\nvar v1 int\nvar w1 int\nvar x1 int\nvar y1 int\nvar z1 int\nvar A1 int\nvar B1 int\nvar C1 int\nvar D1 int\nvar E1 int\nvar F1 int\nvar G1 int\nvar H1 int\nvar I1 int\nvar J1 int\nvar K1 int\nvar L1 int\nvar M1 int\n"}
{"tgt": "factorial := new(big.Int).MulRange(1, 100)\nbytes := factorial.Append([]byte{}, 10)\nsum := 0\nfor b := range bytes {\n\tsum += int(bytes[b] - '0')\n}\nfmt.Println(\"STR\", sum)", "gen": "var a big.Int\na.MulRange(100, 1)\nvar b *big.Int = new(big.Int)\nb.Append(a.Bytes()...)\nvar c string = fmt.Sprintf(\"%d\", b)\nfmt.Println(c)\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs int\n\texpect int\n}{\n\t{\"STR\", 2, 1},\n\t{\"STR\", 3, 2},\n\t{\"STR\", 4, 3},\n\t{\"STR\", 0, 0},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "sol := Solution{}\nsol.TestSolution([]int{1, 2, 3}, 3)\n}\n"}
{"tgt": "var low, mid, high int = 0, len(sorted) / 2, len(sorted)\nfor low < high {\n\tcurr := sorted[mid]\n\tswitch {\n\tcase curr == target:\n\t\treturn mid\n\tcase inRange(sorted[mid:high], target):\n\t\tlow = mid\n\t\tmid = (low + high) / 2\n\tdefault:\n\t\thigh = mid\n\t\tmid = (low + high) / 2\n\t}\n}\nreturn -1", "gen": "var a []int\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tif i < len(a) {\n\t\tif i >= 0 {\n\t\t\tif i < len(a) {\n\t\t\t\tif i < len(a) {\n\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n"}
{"tgt": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nret := &ListNode{}\nif l1.Val <= l2.Val {\n\tret = l1\n\tret.Next = mergeTwoLists1(l1.Next, l2)\n} else {\n\tret = l2\n\tret.Next = mergeTwoLists1(l1, l2.Next)\n}\nreturn ret", "gen": "a := &ListNode{Val: 1}\nb := &ListNode{Val: 2}\nc := &ListNode{Val: 3}\na.Next = b\nb.Next = c\nd := &ListNode{Val: 4}\ne := &ListNode{Val: 5}\nd.Next = e\nf := &ListNode{Val: 6}\ne.Next = f\ng := &ListNode{Val: 7}\nf.Next = g\nh := &ListNode{Val: 8}\ng.Next = h\ni := &ListNode{Val: 9}\nh.Next = i\nj := &ListNode{Val: 10}\ni.Next = j\nk := &ListNode{Val: 11}\nj.Next = k\nl := &ListNode{Val: 12}\nk.Next = l\nm := &ListNode{Val: 13}\nl.Next = m\nn := &ListNode{Val: 14}\nm.Next = n\no := &ListNode{Val: 15}\nn.Next = o\np := &ListNode{Val: 16}\no.Next = p\nq := &ListNode{Val: 17}\np.Next = q\nr := &ListNode{Val: 18}\nq.Next = r\ns := &ListNode{Val: 19}\nr.Next = s\nt := &ListNode{Val: 20}\ns.Next = t\nu := &ListNode{Val: 21}\nt.Next = u\nv := &ListNode{Val: 22}\nu.Next = v\nw := &ListNode{Val: 23}\nv.Next = w\nx := &ListNode{Val: 24}\nw.Next = x\ny := &ListNode{Val: 25}\nx.Next ="}
{"tgt": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Print(sum, \"STR\")", "gen": "var sum int\nfor i := 0; i < 1000; i++ {\n\tif i%3 == 0 {\n\t\tsum += i\n\t}\n\tif i%5 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "rets := make([][]int, numRows)\nif numRows == 0 {\n\treturn rets\n}\nrets[0] = []int{1}\nfor i := 1; i < numRows; i++ {\n\trets[i] = make([]int, i+1)\n\trets[i][0] = 1\n\trets[i][i] = 1\n\tfor j := 1; j < i; j++ {\n\t\trets[i][j] = rets[i-1][j-1] + rets[i-1][j]\n\t}\n}\nreturn rets", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\tif i == 0 {\n\t\ta = make([]int, 1)\n\t\ta[0] = 1\n\t\ta[1] = 1\n\t\ta[2] = 1\n\t\tcontinue\n\t}\n\tif i > 0 {\n\t\ta = append(a, 1)\n\t\ta = append(a, 1)\n\t\ta[i-1] = 1\n\t}\n}\nreturn a\n}\n"}
{"tgt": "start := -1\nlenMax := 0\ndict := [256]int{}\nfor i := range dict {\n\tdict[i] = -1\n}\nfor i, r := range s {\n\tif v := dict[r]; v > start {\n\t\tstart = v\n\t}\n\tlength := i - start\n\tif length > lenMax {\n\t\tlenMax = length\n\t}\n\tdict[r] = i\n}\nreturn lenMax", "gen": "var s []byte\nvar i int\nvar j int\nvar k int\nfor k = 0; k < len(s); k++ {\n\tif k < len(s) {\n\t\ti = int(s[k])\n\t} else {\n\t\tpanic(k)\n\t}\n\tif k < len(s) {\n\t\tj = int(s[k])\n\t} else {\n\t\tpanic(k)\n\t}\n\tif i < 127 {\n\t\tif j < 127 {\n\t\t\tif k < len(s) {\n\t\t\t\ts[k] = byte(j)\n\t\t\t} else {\n\t\t\t\tpanic(k)\n\t\t\t}\n\t\t} else {\n\t\t\tif k < len(s) {\n\t\t\t\ts[k] = byte(j)\n\t\t\t} else {\n\t\t\t\tpanic(k)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif j < 127 {\n\t\t\tif k < len(s) {\n\t\t\t\ts[k] = byte(j)\n\t\t\t} else {\n\t\t\t\tpanic(k)\n\t\t\t}\n\t\t} else {\n\t\t\tif k < len(s) {\n\t\t\t\ts[k] = byte(j)\n\t\t\t} else {\n\t\t\t\tpanic(k)\n\t\t\t}\n\t\t}\n\t}\n\tif k < len(s) {\n\t\ts[k] = byte(j)\n\t} else {\n\t\tpanic(k)\n\t}\n}\nif k < len(s) {\n\ts[k] = byte(j)\n} else {\n\tpanic(k)\n}\nif k < len(s) {\n\ts"}
{"tgt": "nlen := len(nums)\nfor i := 0; i < nlen-2; i++ {\n\tif i != 0 && nums[i] == nums[i-1] {\n\t\tcontinue\n\t}\n\tleft, right := i+1, nlen-1\n\tfor left < right {\n\t\tsum := nums[i] + nums[left] + nums[right]\n\t\tif sum == target {\n\t\t\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tleft++\n\t\t\tright--\n\t\t} else if sum < target {\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tleft++\n\t\t} else {\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tright--\n\t\t}\n\t}\n}", "gen": "var a [3]int\nvar b [4]int\nvar c [5]int\nvar d [6]int\nvar e [7]int\nvar f [8]int\nvar g [9]int\nvar h [10]int\nvar i [11]int\nvar j [12]int\nvar k [13]int\nvar l [14]int\nvar m [15]int\nvar n [16]int\nvar o [17]int\nvar p [18]int\nvar q [19]int\nvar r [20]int\nvar s [21]int\nvar t [22]int\nvar u [23]int\nvar v [24]int\nvar w [25]int\nvar x [26]int\nvar y [27]int\nvar z [28]int\nvar aa [29]int\nvar ab [30]int\nvar ac [31]int\nvar ad [32]int\nvar ae [33]int\nvar af [34]int\nvar ag [35]int\nvar ah [36]int\nvar ai [37]int\nvar aj [38]int\nvar ak [39]int\nvar al [40]int\nvar am [41]int\nvar an [42]int\nvar ao [43]int\nvar ap [44]int\nvar aq [45]int\nvar ar [46]int\nvar as [47]int\nvar at [48]int\nvar au [49]int\nvar av [50]int\nvar aw [51]int\nvar ax [52]int\nvar ay [53]int\nvar az [54]int\nvar ba [55]int\nvar bb [56]int\nvar bc [57]int\nvar bd [58]"}
{"tgt": "return strings.ReplaceAll(r.element.Name, \"STR\", \"\")", "gen": "s := \"hello\"\ns = strings.ReplaceAll(s, \"l\", \"L\")\nfmt.Println(s)\n}\n\n// \u6c47\u7f16\u4ee3\u7801\n// 1. \u51fd\u6570\u8c03\u7528\n// 2. \u51fd\u6570\u53c2\u6570\u4f20\u9012\n// 3. \u51fd\u6570\u8fd4\u56de\u503c\n// 4. \u51fd\u6570\u8c03\u7528\u6808\n// 5. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 6. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 7. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 8. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 9. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 10. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 11. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 12. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 13. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 14. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 15. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 16. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 17. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 18. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 19. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 20. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 21. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 22. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 23. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 24. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 25. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 26. \u51fd\u6570\u8c03\u7528\u6808"}
{"tgt": "var res byte\nfor i := 0; i < len(s); i++ {\n\tres ^= s[i]\n}\nfor i := 0; i < len(t); i++ {\n\tres ^= t[i]\n}\nreturn res", "gen": "var a [10]byte\nvar b [10]byte\nvar c int\nvar d int\nvar e byte\nfor i := 0; i < len(a); i++ {\n\tif i < len(b) {\n\t\ta[i] = b[i]\n\t} else {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n}\nfor i := 0; i < len(c); i++ {\n\tif i < len(d) {\n\t\tc[i] = d[i]\n\t} else {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n}\ne = a[c]\ne = b[d]\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "m := len(A)\nn := len(A[0])\nans := make([][]int, n)\nfor k := range ans {\n\tans[k] = make([]int, m)\n}\nfor r := 0; r < m; r++ {\n\tfor c := 0; c < n; c++ {\n\t\tans[c][r] = A[r][c]\n\t}\n}\nreturn ans", "gen": "var a []int\nvar b []int\nvar c []int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar A []int\nvar B []int\nvar C []int\nvar D int\nvar E int\nvar F int\nvar G int\nvar H int\nvar I int\nvar J int\nvar K int\nvar L int\nvar M int\nvar N int\nvar O int\nvar P int\nvar Q int\nvar R int\nvar S int\nvar T int\nvar U int\nvar V int\nvar W int\nvar X int\nvar Y int\nvar Z int\nfor i = 0; i < len(a); i++ {\n\tfor j = 0; j < len(b); j++ {\n\t\tfor k = 0; k < len(c); k++ {\n\t\t\tfor l = 0; l < len(d); l++ {\n\t\t\t\tfor m = 0; m < len(e); m++ {\n\t\t\t\t\tfor n = 0; n < len(f); n++ {\n\t\t\t\t\t\tfor o = 0; o < len(g); o++ {\n\t\t\t\t\t\t\tfor p = 0; p < len(h); p++ {\n\t\t\t\t\t\t\t\tfor q = 0; q < len(i); q++ {\n\t\t\t\t\t\t\t\t\tfor r = 0; r < len(j); r++ {\n\t\t\t\t\t\t\t\t\t\tfor s = 0; s <"}
{"tgt": "println(\"STR\", len(a))", "gen": "var a [2]int\nfmt.Println(\"a=\", a)\n}\n\n// Output:\n// a=[0 0]\n"}
{"tgt": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nc, res := []int{}, [][]int{}\nsort.Ints(candidates)\nfindcombinationSum(candidates, target, 0, c, &res)\nreturn res", "gen": "nums := []int{2, 3, 6, 7}\ntarget := 7\ncombinationSum(nums, target)\n}\n"}
{"tgt": "for i := 0; i < len(A)-1; i++ {\n\tif A[i] == i {\n\t\tcontinue\n\t}\n\tif A[i] == i+1 && A[i+1] == i {\n\t\ti++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n"}
{"tgt": "for n := 0; n < 32; n++ {\n\tsquare[n] = gf2MatrixTimes(mat, mat[n])\n}", "gen": "var a [32]uint32\nvar b [32]uint32\nvar c uint32\nfor i := 0; i < 32; i++ {\n\ta[i] = gf2MatrixTimes(b, c)\n}\n}\n"}
{"tgt": "for i := 0; i < n; i++ {\n\tif len(squares) != i {\n\t\tprintln(\"STR\", len(squares), \"STR\", i)\n\t}\n\tsquares[i] = i * i\n\tfor j := 0; j <= i; j++ {\n\t\tif v, ok := squares[j]; !ok || v != j*j {\n\t\t\tif !ok {\n\t\t\t\tprintln(\"STR\", j)\n\t\t\t} else {\n\t\t\t\tprintln(\"STR\", j, v)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "var m map[int][2]int\nfor i := 0; i < 10; i++ {\n\tif _, ok := m[i]; !ok {\n\t\tm[i] = [2]int{i, i}\n\t}\n}\n}\n"}
{"tgt": "for j := 1; j <= 20; j++ {\n\tif num%j != 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a int\nfor i := 0; i < 20; i++ {\n\tif i == 0 {\n\t\ta = 1\n\t} else if i == 1 {\n\t\ta = 0\n\t} else {\n\t\ta = a / i\n\t\tif a == 0 {\n\t\t\ta = 1\n\t\t}\n\t}\n}\nif a == 0 {\n\ta = 1\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(sorted) == 0 {\n\treturn nil\n}\nmid := len(sorted) / 2\nroot := &BST{Value: sorted[mid]}\nroot.Left = SortedSliceToBST(sorted[:mid])\nroot.Right = SortedSliceToBST(sorted[mid+1:])\nreturn root", "gen": "var root *BST\nif len(nums) == 0 {\n\treturn nil\n}\nroot = &BST{nums[0]}\nfor i := 1; i < len(nums); i++ {\n\tif i > 0 && i < len(nums) {\n\t\tif i > 0 && i < len(nums) {\n\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"}
{"tgt": "return x * y", "gen": "var a float32 = 1.0\nvar b float32 = 2.0\nvar c float32 = 3.0\nvar d float32 = 4.0\nvar e float32 = 5.0\nvar f float32 = 6.0\nvar g float32 = 7.0\nvar h float32 = 8.0\nvar i float32 = 9.0\nvar j float32 = 10.0\nvar k float32 = 11.0\nvar l float32 = 12.0\nvar m float32 = 13.0\nvar n float32 = 14.0\nvar o float32 = 15.0\nvar p float32 = 16.0\nvar q float32 = 17.0\nvar r float32 = 18.0\nvar s float32 = 19.0\nvar t float32 = 20.0\nvar u float32 = 21.0\nvar v float32 = 22.0\nvar w float32 = 23.0\nvar x float32 = 24.0\nvar y float32 = 25.0\nvar z float32 = 26.0\nvar a1 float32 = 27.0\nvar b1 float32 = 28.0\nvar c1 float32 = 29.0\nvar d1 float32 = 30.0\nvar e1 float32 = 31.0\nvar f1 float32 = 32.0\nvar g1 float32 = 33.0\nvar h1 float32 = 34.0\nvar i1 float32 = 35.0\nvar j1 float32 = 36.0\nvar k1 float32 = 37.0\nvar l1 float32 = 38.0\nvar m"}
{"tgt": "i1 := 0\ni2 := 0\nval1 := 0\nval2 := 0\nfor i1 < len(version1) || i2 < len(version2) {\n\tval1, i1 = parseSeg(version1, i1)\n\tval2, i2 = parseSeg(version2, i2)\n\tif val1 > val2 {\n\t\treturn 1\n\t}\n\tif val1 < val2 {\n\t\treturn -1\n\t}\n}\nif i1 < len(version1) {\n\treturn 1\n}\nif i2 < len(version2) {\n\treturn -1\n}\nreturn 0", "gen": "a := 1\nb := 2\nc := 3\nd := 4\ne := 5\nf := 6\ng := 7\nh := 8\ni := 9\nj := 10\nk := 11\nl := 12\nm := 13\nn := 14\no := 15\np := 16\nq := 17\nr := 18\ns := 19\nt := 20\nu := 21\nv := 22\nw := 23\nx := 24\ny := 25\nz := 26\nvar a1, b1, c1, d1, e1, f1, g1, h1, i1, j1, k1, l1, m1, n1, o1, p1, q1, r1, s1, t1, u1, v1, w1, x1, y1, z1 int\na1, b1, c1, d1, e1, f1, g1, h1, i1, j1, k1, l1, m1, n1, o1, p1, q1, r1, s1, t1, u1, v1, w1, x1, y1, z1 = parseSeg(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)\nif a1 < b1 {\n\tif a1 < c1 {\n\t\tif a1 < d1 {\n\t\t\tif a1 < e1 {\n\t\t\t\tif a1 < f1 {\n\t\t\t\t\tif a1 < g1 {\n\t\t\t\t\t\tif a1 < h1 {\n\t\t\t\t\t\t\tif a1 < i1 {\n\t\t\t\t\t\t\t\tif a"}
{"tgt": "return this.Val", "gen": "var a [4]int\nvar b int\nb = a[0]\n}\n\n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// "}
{"tgt": "str := \"STR\"\nfmt.Println(longestPalindrome(str))", "gen": "fmt.Println(longestPalindrome(\"babad\"))\n}\n"}
{"tgt": "dat, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\nnamesList := string(dat)\nnamesList = strings.Replace(namesList, \"STR\", \"STR\", -1)\nnames := strings.Split(namesList, \"STR\")\nsort.Strings(names)\nnamesScore := 0\nfor index, name := range names {\n\tnamesScore += nameScore(name) * (index + 1)\n}\nfmt.Println(namesScore)", "gen": "f, err := os.Open(\"names.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer f.Close()\n\nb, err := ioutil.ReadAll(f)\nif err != nil {\n\tlog.Fatal(err)\n}\n\ns := string(b)\n// s := \"Emma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvely"}
{"tgt": "res := 0\nsort.Ints(houses)\nsort.Ints(heaters)\nm, n := len(houses), len(heaters)\nindex := sort.SearchInts(heaters, houses[0])\nfor _, house := range houses {\n\tfor index < n && house > heaters[index] {\n\t\tindex++\n\t}\n\tif index == n {\n\t\treturn max(res, houses[m-1]-heaters[index-1])\n\t}\n\tleft := math.MaxInt32\n\tif index > 0 {\n\t\tleft = house - heaters[index-1]\n\t}\n\tright := heaters[index] - house\n\tres = max(res, min(left, right))\n}\nreturn res", "gen": "a := []int{1, 2, 3, 1}\nb := []int{1, 2, 3, 4}\nc := []int{1, 2, 3, 4}\nsort.Ints(a)\nsort.Ints(b)\nsort.Ints(c)\ni := sort.SearchInts(a, 3)\nj := sort.SearchInts(b, 3)\nk := sort.SearchInts(c, 3)\nfmt.Println(max(i, j, k))\n}"}
{"tgt": "l, r := &maxHeap{}, &minHeap{}\nheap.Init(l)\nheap.Init(r)\nreturn MedianFinder{l, r}", "gen": "var heap1 = &maxHeap{}\nvar heap2 = &minHeap{}\ncontainer.Init(heap1, heap2)\n}\n"}
{"tgt": "l := len(preorder)\nif l == 0 {\n\treturn nil\n}\nfor 1 < l && preorder[0] < preorder[l-1] {\n\tl--\n}\nreturn &TreeNode{\n\tVal:   preorder[0],\n\tLeft:  bstFromPreorder(preorder[1:l]),\n\tRight: bstFromPreorder(preorder[l:]),\n}", "gen": "preorder := []int{8, 5, 1, 7, 10, 12}\nroot := bstFromPreorder(preorder)\nfmt.Println(root)\n}\n"}
{"tgt": "ln, err := net.Listen(\"STR\", \"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"STR\", conn.RemoteAddr())\n\tio.WriteString(conn, fmt.Sprint(time.Now()))\n\tconn.Close()\n}", "gen": "l, err := net.Listen(\"tcp\", \":8080\")\nif err != nil {\n\tpanic(err)\n}\ndefer l.Close()\nfor {\n\tconn, err := l.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tgo func() {\n\t\tdefer conn.Close()\n\t\tio.WriteString(conn, time.Now().Format(time.RFC3339))\n\t}()\n}\n}\n"}
{"tgt": "i, l := 0, len(bits)-1\nfor i < l {\n\ti += bits[i] + 1\n}\nreturn i == l", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i + 1\n}\nif i == len(a) {\n\tpanic(\"index out of range\")\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%s %d %d %d\\n\", \".LC13\", 7, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC14\", 13, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC15\", 12, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC16\", 18, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC17\", 70, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC18\", 37, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC19\", 0, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC20\", 2, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC21\", 2, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC22\", 0, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC23\", 37, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC24\", 0, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC25\", 2, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC26\", 2, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC27\", 0, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC28\", 37, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n"}
{"tgt": "start := 0\nend := len(s) - 1\nfor start < end {\n\ts[start], s[end] = s[end], s[start]\n\tstart++\n\tend--\n}\nreturn s", "gen": "var a [3]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for cur := t.root; cur != nil; {\n\tif cur.Key == key {\n\t\treturn cur\n\t} else if key < cur.Key {\n\t\tcur = cur.left\n\t} else {\n\t\tcur = cur.right\n\t}\n}\nreturn nil", "gen": "var root *binaryTree.BSTElement\nvar element *binaryTree.BSTElement\nvar found bool\nroot = binaryTree.NewBSTElement(10)\nroot.Left = binaryTree.NewBSTElement(5)\nroot.Right = binaryTree.NewBSTElement(15)\nelement = binaryTree.FindElement(root, 10)\nfound = element != nil\nif found {\n\telement = binaryTree.FindElement(root, 10)\n}\nreturn\n}\n"}
{"tgt": "arr := randomSlice(0, 20, 10)\nnodeCnt := 0\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\nrotateNodes := make([]*gbtElement, 0, 0)\ngbt.InOrderWalk(gbt.Root(), func(GBTbinaryTreeIf, node interface{}) bool {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\trotateNodes = append(rotateNodes, node.(*gbtElement))\n\t}\n\treturn false\n})\nfor _, v := range rotateNodes {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\tgbt.LeftRotate(v)\n\t} else {\n\t\tgbt.RightRotate(v)\n\t}\n}\ngbt.InOrderWalk(gbt.Root(), checkGBT(t, &nodeCnt, *debug))\nif nodeCnt != len(arr) {\n\tt.Log(fmt.Sprintf(\"STR\", len(arr), nodeCnt))\n\tt.Fail()\n}", "gen": "gbt := NewGBT()\ngbt.Insert(10)\ngbt.Insert(20)\ngbt.Insert(30)\ngbt.Insert(40)\ngbt.Insert(50)\ngbt.Insert(60)\ngbt.Insert(70)\ngbt.Insert(80)\ngbt.Insert(90)\ngbt.Insert(100)\ngbt.Insert(110)\ngbt.Insert(120)\ngbt.Insert(130)\ngbt.Insert(140)\ngbt.Insert(150)\ngbt.Insert(160)\ngbt.Insert(170)\ngbt.Insert(180)\ngbt.Insert(190)\ngbt.Insert(200)\ngbt.Insert(210)\ngbt.Insert(220)\ngbt.Insert(230)\ngbt.Insert(240)\ngbt.Insert(250)\ngbt.Insert(260)\ngbt.Insert(270)\ngbt.Insert(280)\ngbt.Insert(290)\ngbt.Insert(300)\ngbt.Insert(310)\ngbt.Insert(320)\ngbt.Insert(330)\ngbt.Insert(340)\ngbt.Insert(350)\ngbt.Insert(360)\ngbt.Insert(370)\ngbt.Insert(380)\ngbt.Insert(390)\ngbt.Insert(400)\ngbt.Insert(410)\ngbt.Insert(420)\ngbt.Insert(430)\ngbt.Insert(440)\ngbt.Insert(450)\ngbt.Insert"}
{"tgt": "return WordDictionary{}", "gen": "var a [27]int\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 4\na[4] = 5\na[5] = 6\na[6] = 7\na[7] = 8\na[8] = 9\na[9] = 10\na[10] = 11\na[11] = 12\na[12] = 13\na[13] = 14\na[14] = 15\na[15] = 16\na[16] = 17\na[17] = 18\na[18] = 19\na[19] = 20\na[20] = 21\na[21] = 22\na[22] = 23\na[23] = 24\na[24] = 25\na[25] = 26\na[26] = 27\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return xtime.Unix(int64(jt), 0)", "gen": "var t time.Time\nvar t2 time.Time\nvar t3 time.Time\nt = time.Now()\nt2 = time.Unix(t.Unix(), t.Nanosecond())\nt3 = time.Unix(t.Unix(), t.Nanosecond())\nfmt.Println(t2, t3)\n}\n\n// 1. \u6808\u5e27\u7684\u5927\u5c0f\n// 2. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 3. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 4. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 5. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 6. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 7. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 8. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 9. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 10. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 11. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 12. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 13. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 14. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 15. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 16. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 17. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 18. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 19. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 20. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 21. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 22. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 23. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 24. "}
{"tgt": "return append(ints, added...)", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb := a[1]\nc := a[2]\nd := a[0]\na[1] = c\na[2] = b\na[0] = d\nreturn\n}\n"}
{"tgt": "data, err := base64.StdEncoding.DecodeString(b64)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(data)", "gen": "s := \"1234567890\"\nb, err := base64.StdEncoding.DecodeString(s)\nif err != nil {\n\tpanic(err)\n}\ns = hex.EncodeToString(b)\nfmt.Println(s)\n}\n"}
{"tgt": "h := fnv.New64a()\n_, _ = h.Write([]byte(fmt.Sprintf(\"STR\", key)))\nhashValue := h.Sum64()\nreturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))", "gen": "var z2ffnv hash.z2ffnv\nz2ffnv.New64a()\nfmt.Sprintf(\"%d\", 2)\nvar a = z2ffnv.New64a()\nvar b = z2ffnv.New64a()\nvar c = z2ffnv.New64a()\nvar d = z2ffnv.New64a()\nvar e = z2ffnv.New64a()\nvar f = z2ffnv.New64a()\nvar g = z2ffnv.New64a()\nvar h = z2ffnv.New64a()\nvar i = z2ffnv.New64a()\nvar j = z2ffnv.New64a()\nvar k = z2ffnv.New64a()\nvar l = z2ffnv.New64a()\nvar m = z2ffnv.New64a()\nvar n = z2ffnv.New64a()\nvar o = z2ffnv.New64a()\nvar p = z2ffnv.New64a()\nvar q = z2ffnv.New64a()\nvar r = z2ffnv.New64a()\nvar s = z2ffnv.New64a()\nvar t = z2ffnv.New64a()\nvar u = z2ffnv.New64a()\nvar v = z2ffnv.New64a()\nvar w = z2ffnv.New64a()\nvar x = z2ffnv.New64a()\nvar y = z2ffnv.New64a()\nvar z = z2ffnv.New64a()\nvar aa = z2ffnv.New64a()\nvar bb = z2ffnv.New64a()\nvar cc = z2ffnv.New"}
{"tgt": "return fmt.Sprintf(\"STR\", p.Name, p.Age)", "gen": "var s string\nvar i int\nvar j int\nvar k int\nvar s1 string\nvar i1 int\nvar j1 int\nvar k1 int\nvar s2 string\nvar i2 int\nvar j2 int\nvar k2 int\nvar s3 string\nvar i3 int\nvar j3 int\nvar k3 int\nvar s4 string\nvar i4 int\nvar j4 int\nvar k4 int\nvar s5 string\nvar i5 int\nvar j5 int\nvar k5 int\nvar s6 string\nvar i6 int\nvar j6 int\nvar k6 int\nvar s7 string\nvar i7 int\nvar j7 int\nvar k7 int\nvar s8 string\nvar i8 int\nvar j8 int\nvar k8 int\nvar s9 string\nvar i9 int\nvar j9 int\nvar k9 int\nvar s10 string\nvar i10 int\nvar j10 int\nvar k10 int\nvar s11 string\nvar i11 int\nvar j11 int\nvar k11 int\nvar s12 string\nvar i12 int\nvar j12 int\nvar k12 int\nvar s13 string\nvar i13 int\nvar j13 int\nvar k13 int\nvar s14 string\nvar i14 int\nvar j14 int\nvar k14 int\nvar s15 string\nvar i15 int\nvar j15 int\nvar k15 int\nvar s16 string\nvar i16 int\nvar j16 int\nvar k16 int\nvar s17 string\nvar i17 int\nvar j17 int\nvar k17 int\nvar s18 string\nvar i18 int\nvar j18 int\nvar k18 int\nvar s19 string\nvar i19"}
{"tgt": "parent := this\nfor _, ch := range prefix {\n\tif child, ok := parent.Children[ch]; ok {\n\t\tparent = child\n\t\tcontinue\n\t}\n\treturn false\n}\nreturn true", "gen": "var s = \"leetcode\"\nvar wordDict = []string{\"leet\", \"code\"}\nfmt.Println(wordBreak(s, wordDict))\n}\n"}
{"tgt": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)", "gen": "var i int\nfor i = 0; i < 10000; i++ {\n\tif isL(i) {\n\t\t*(*int)(unsafe.Pointer(&i))++\n\t}\n}\nfmt.Println(i)\n}"}
{"tgt": "close(p.work)\np.wg.Wait()", "gen": "ch := make(chan int)\nvar wg sync.WaitGroup\nwg.Add(1)\ngo func() {\n\tdefer wg.Done()\n\t<-ch\n}()\nclose(ch)\nwg.Wait()\n}\n\n// func main() {\n// \tch := make(chan int)\n// \tvar wg sync.WaitGroup\n// \twg.Add(1)\n// \tgo func() {\n// \t\tdefer wg.Done()\n// \t\t<-ch\n// \t}()\n// \tclose(ch)\n// \twg.Wait()\n// }\n\n// func main() {\n// \tch := make(chan int)\n// \tvar wg sync.WaitGroup\n// \twg.Add(1)\n// \tgo func() {\n// \t\tdefer wg.Done()\n// \t\t<-ch\n// \t}()\n// \tclose(ch)\n// \twg.Wait()\n// }\n\n// func main() {\n// \tch := make(chan int)\n// \tvar wg sync.WaitGroup\n// \twg.Add(1)\n// \tgo func() {\n// \t\tdefer wg.Done()\n// \t\t<-ch\n// \t}()\n// \tclose(ch)\n// \twg.Wait()\n// }\n\n// func main() {\n// \tch := make(chan int)\n// \tvar wg sync.WaitGroup\n// \twg.Add(1)\n// \tgo func() {\n// \t\tdefer wg.Done()\n// \t\t<-ch\n// \t}()\n// \tclose(ch)\n// \twg.Wait()\n// }\n\n// func main() {\n// \tch := make(chan int)\n// \tvar wg sync.WaitGroup\n// \twg.Add(1)\n// \tgo func() {\n// \t\tdefer wg.Done()\n//"}
{"tgt": "m := make(map[int]struct{})\nfor _, num := range nums1 {\n\tm[num] = struct{}{}\n}\nnums := make([]int, 0)\nfor _, num := range nums2 {\n\tif _, ok := m[num]; ok {\n\t\tnums = append(nums, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn nums", "gen": "m := make(map[int]struct{})\nfor i := 0; i < 1000000; i++ {\n\tm[i] = struct{}{}\n}\ns := make([]int, 0, len(m))\nfor k := range m {\n\ts = append(s, k)\n}\nreturn s\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return h.FromHexString(string(b))", "gen": "var hash go.metainfo.Hash\nhash, err = go.metainfo.HashFromHexString(string([]byte{32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif denoms := EgyptianFractions(tc.numerator, tc.denominator); !reflect.DeepEqual(tc.denominators, denoms) {\n\t\tt.Errorf(\"STR\", tc.denominators, denoms)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "log.SetFlags(0)\nvar err error\ntpl := template.New(\"STR\")\ntpl = tpl.Funcs(template.FuncMap{\n\t\"STR\": func(str string) string {\n\t\treturn strings.ToUpper(str)\n\t},\n})\ntpl, err = tpl.ParseFiles(\"STR\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nerr = tpl.ExecuteTemplate(os.Stdout, \"STR\", Page{\n\tTitle: \"STR\",\n\tBody:  \"STR\",\n})\nif err != nil {\n\tlog.Fatalln(err)\n}", "gen": "log.SetFlags(0)\nt := template.New(\"\")\nt = t.Funcs(template.FuncMap{\n\t\"f\": func(s string) string {\n\t\treturn s\n\t},\n})\nt, err := t.ParseFiles(\"./index.html\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nvar p Page\nt = t.Parse(string(p))\nvar buf bytes.Buffer\nerr = t.ExecuteTemplate(&buf, \"p\", p)\nif err != nil {\n\tlog.Fatalln(err)\n}\nfmt.Println(buf.String())\n}\ntype Page struct {\nTitle string\nBody  string\n}"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA `structs:\"STR\"`\n\tC  int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif ok {\n\tt.Error(\"STR\")\n}", "gen": "var a TestHasZero_OmitNested\na.B.i1.d = 123\nif !reflect.DeepEqual(a, TestHasZero_OmitNested{}) {\n\tt.Error(\"a should be zero\")\n}\n}\n\n// TestHasZero_OmitNested_B_i1_d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d"}
{"tgt": "digits := convert(N + 1)\nbits := len(digits)\nnoRepeat := 0\nfor b := 1; b < bits; b++ {\n\tnoRepeat += 9 * count(9, b-1)\n}\nhasSeen := make(map[int]bool, 10)\nfor b := 0; b < bits; b++ {\n\td := 0\n\tif b == 0 {\n\t\td = 1\n\t}\n\tfor ; d < digits[b]; d++ {\n\t\tif !hasSeen[d] {\n\t\t\tnoRepeat += count(9-b, bits-b-1)\n\t\t}\n\t}\n\tif hasSeen[digits[b]] {\n\t\tbreak\n\t}\n\thasSeen[digits[b]] = true\n}\nreturn N - noRepeat", "gen": "var n int\nfmt.Scan(&n)\nvar a []int\nfor i := 0; i < n; i++ {\n\tvar tmp int\n\tfmt.Scan(&tmp)\n\ta = append(a, tmp)\n}\nvar ans int\nfor i := 0; i < n; i++ {\n\tif i == 0 {\n\t\tans = count(a[i], 9)\n\t} else {\n\t\tans += count(a[i], 9)\n\t}\n}\nfmt.Println(ans)\n}"}
{"tgt": "return me[0] == \"STR\"", "gen": "if len(a) < 1 {\n\tpanic(\"index out of range\")\n}\nif len(a) == 1 {\n\tif a[0] == 1 {\n\t\treturn 1\n\t}\n}\nreturn 0\n}\n"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil {\n\t\t\tmax = max.Right\n\t\t}\n\t\tmax.Right = root\n\t\troot, root.Left = root.Left, nil\n\t}\n}\nreturn res", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\ta = append(a, i)\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   0x5555,\n\t\twant: 8,\n\t},\n}\nfor _, tt := range tests {\n\tgot := hammingWeight(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var a [4]int\na[0] = 3\na[1] = 2\na[2] = 7\na[3] = 8\nvar b [4]int\nb[0] = 1\nb[1] = 2\nb[2] = 21845\nb[3] = 8\nvar c [4]int\nc[0] = 4\nfor i := 0; i < len(a); i++ {\n\tif i == 3 {\n\t\tcontinue\n\t}\n\tif i > 3 {\n\t\tpanic(i)\n\t}\n\tif a[i] == b[i] {\n\t\tc[i] = a[i]\n\t}\n}\nif c[0] == 3 && c[1] == 2 && c[2] == 7 && c[3] == 8 {\n\tfmt.Println(\"pass\")\n} else {\n\ttesting.T.Fatalf(0, \"fail\")\n}\n}"}
{"tgt": "if a == nil && b == nil {\n\treturn true\n}\nif len(a) != len(b) {\n\treturn false\n}\nfor i := range a {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [4]int\nvar b [4]int\nvar c int\nif len(a) == len(b) {\n\tfor i := 0; i < len(a); i++ {\n\t\tif a[i] == b[i] {\n\t\t\tc = 1\n\t\t\tbreak\n\t\t}\n\t}\n} else {\n\tc = 0\n}\nif c == 0 {\n\tif a[0] == b[0] {\n\t\tc = 1\n\t}\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return xtime.Unix(int64(jt), 0), nil", "gen": "var t time.Time\nt = time.Unix(t.Unix(), 0)\nfmt.Println(t)\n}\n"}
{"tgt": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 0},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 11},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 19},\n\t\tans1208{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s, p.t, p.maxCost))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%s %d %d %d\\n\", \".LC18\", 4, 4, 4)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC19\", 4, 4, 4)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC20\", 3, 3, 1)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC18\", 4, 4, 4)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC21\", 4, 4, 4)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC18\", 4, 4, 4)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC22\", 3, 1, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC18\", 4, 4, 4)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC23\", 9, 9, 11)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC24\", 5, 5, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC25\", 5, 5, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC26\", 70, 0, 0)\nfor i := 0; i < 5; i++ {\n\tfor j := 0; j < 5; j++ {\n\t\tif i == 0 && j == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif i == 0 {\n\t\t\tfmt.Printf(\"%s %d %d %d\\n\", \".LC27\", 70, 0, 0)\n\t\t\tcontinue\n\t\t}\n\t\tif j == 0 {\n"}
{"tgt": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{}\n} else if n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{intervals[0]}\nfor _, cur := range intervals[1:] {\n\tprevious := res[len(res)-1]\n\tif cur.Start <= previous.End {\n\t\tend := previous.End\n\t\tif cur.End > end {\n\t\t\tend = cur.End\n\t\t}\n\t\tres = append(res[:len(res)-1], Interval{Start: previous.Start, End: end})\n\t} else {\n\t\tres = append(res, cur)\n\t}\n}\nreturn res", "gen": "intervals := [][]int{{1, 3}, {2, 6}, {8, 10}, {15, 18}}\nmerge(intervals)\n}\n"}
{"tgt": "result := make([]int, 0, len(left)+len(right))\nfor len(left) > 0 || len(right) > 0 {\n\tif len(left) == 0 {\n\t\treturn append(result, right...)\n\t}\n\tif len(right) == 0 {\n\t\treturn append(result, left...)\n\t}\n\tif left[0] <= right[0] {\n\t\tresult = append(result, left[0])\n\t\tleft = left[1:]\n\t} else {\n\t\tresult = append(result, right[0])\n\t\tright = right[1:]\n\t}\n}\nreturn result", "gen": "var a []int\nvar b []int\nvar c []int\nvar d []int\nvar e []int\nvar f []int\nvar g []int\nvar h []int\nvar i []int\nvar j []int\nvar k []int\nvar l []int\nvar m []int\nvar n []int\nvar o []int\nvar p []int\nvar q []int\nvar r []int\nvar s []int\nvar t []int\nvar u []int\nvar v []int\nvar w []int\nvar x []int\nvar y []int\nvar z []int\nvar aa []int\nvar bb []int\nvar cc []int\nvar dd []int\nvar ee []int\nvar ff []int\nvar gg []int\nvar hh []int\nvar ii []int\nvar jj []int\nvar kk []int\nvar ll []int\nvar mm []int\nvar nn []int\nvar oo []int\nvar pp []int\nvar qq []int\nvar rr []int\nvar ss []int\nvar tt []int\nvar uu []int\nvar vv []int\nvar ww []int\nvar xx []int\nvar yy []int\nvar zz []int\nvar aaa []int\nvar bbb []int\nvar ccc []int\nvar ddd []int\nvar eee []int\nvar fff []int\nvar ggg []int\nvar hhh []int\nvar iii []int\nvar jjj []int\nvar kkk []int\nvar lll []int\nvar mmm []int\nvar nnn []int\nvar ooo []int\nvar ppp []int\nvar qqq []int\nvar rrr []int\nvar sss []int\nvar ttt []int\nvar uuu []int\nvar vvv []int\nvar www []int\nvar xxx []int\nvar yyy"}
{"tgt": "t.Parallel()\nd := NewTimeMap()\nd.Set(1, 1, 0)\nd.Set(1, 2, 2)\nif result := d.Get(1, 1); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 3); result != 2 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 5)\nif result := d.Get(1, 0); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 10); result != 1 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 0)\nd.Set(1, 2, 0)\nif result := d.Get(1, 0); result != 2 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(2, 0); result != nil {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, -1); result != nil {\n\tt.Errorf(\"STR\")\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{2},\n\t\t\t{3, 4},\n\t\t\t{6, 5, 7},\n\t\t\t{4, 1, 8, 3},\n\t\t},\n\t\t11},\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{1},\n\t\t\t{2, 3},\n\t\t},\n\t\t3},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := minimumTotal(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.TestSolution()\n}\n"}
{"tgt": "pairs := [...][2]int{{15, 26}, {1000, 1366}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p16(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var a [2]int\nvar b [2]int\nvar c [2]int\nvar d [2]int\nvar e [2]int\nvar f [2]int\nvar g [2]int\nvar h [2]int\nvar i [2]int\nvar j [2]int\nvar k [2]int\nvar l [2]int\nvar m [2]int\nvar n [2]int\nvar o [2]int\nvar p [2]int\nvar q [2]int\nvar r [2]int\nvar s [2]int\nvar t [2]int\nvar u [2]int\nvar v [2]int\nvar w [2]int\nvar x [2]int\nvar y [2]int\nvar z [2]int\nvar aa [2]int\nvar ab [2]int\nvar ac [2]int\nvar ad [2]int\nvar ae [2]int\nvar af [2]int\nvar ag [2]int\nvar ah [2]int\nvar ai [2]int\nvar aj [2]int\nvar ak [2]int\nvar al [2]int\nvar am [2]int\nvar an [2]int\nvar ao [2]int\nvar ap [2]int\nvar aq [2]int\nvar ar [2]int\nvar as [2]int\nvar at [2]int\nvar au [2]int\nvar av [2]int\nvar aw [2]int\nvar ax [2]int\nvar ay [2]int\nvar az [2]int\nvar aaa [2]int\nvar aab [2]int\nvar aac [2]int\nvar aad [2]int\nvar aae [2]int\nvar aaf [2]int\nvar aag [2]int\nvar aah [2]int\nvar aai [2]int\n"}
{"tgt": "m := [26]int{}\nfor _, b := range B {\n\tcount := counter(b)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tm[i] = count[i]\n\t\t}\n\t}\n}\nres := []string{}\nfor _, a := range A {\n\tcount := counter(a)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tcontinueL\n\t\t}\n\t}\n\tres = append(res, a)\n}\nreturn res", "gen": "var a []string\nfor i := 0; i < 26; i++ {\n\ta = append(a, strconv.Itoa(i))\n}\nvar b []string\nfor i := 0; i < 26; i++ {\n\tb = append(b, strconv.Itoa(i))\n}\nvar c []string\nfor i := 0; i < 26; i++ {\n\tc = append(c, strconv.Itoa(i))\n}\nvar d []string\nfor i := 0; i < 26; i++ {\n\td = append(d, strconv.Itoa(i))\n}\nvar e []string\nfor i := 0; i < 26; i++ {\n\te = append(e, strconv.Itoa(i))\n}\nvar f []string\nfor i := 0; i < 26; i++ {\n\tf = append(f, strconv.Itoa(i))\n}\nvar g []string\nfor i := 0; i < 26; i++ {\n\tg = append(g, strconv.Itoa(i))\n}\nvar h []string\nfor i := 0; i < 26; i++ {\n\th = append(h, strconv.Itoa(i))\n}\nvar i []string\nfor i := 0; i < 26; i++ {\n\ti = append(i, strconv.Itoa(i))\n}\nvar j []string\nfor i := 0; i < 26; i++ {\n\tj = append(j, strconv.Itoa(i))\n}\nvar k []string\nfor i := 0; i < 26; i++ {\n\tk = append(k, strconv.Itoa(i))\n}\nvar l []string\nfor i := 0; i < "}
{"tgt": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\ntmp := nums[0]\nmax := tmp\nfor i := 1; i < n; i++ {\n\tif tmp < 0 {\n\t\ttmp = nums[i]\n\t} else {\n\t\ttmp += nums[i]\n\t}\n\tif max < tmp {\n\t\tmax = tmp\n\t}\n}\nreturn max", "gen": "var a [2]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif i == 0 {\n\t\ta[i] = 0\n\t} else {\n\t\ta[i] = a[i-1] + 1\n\t}\n}\nreturn a[len(a)-1]\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "hash := uint32(0)\nfor i := len(sep) - 1; i >= 0; i-- {\n\thash = hash*PrimeRK + uint32(sep[i])\n}\nvar pow, sq uint32 = 1, PrimeRK\nfor i := len(sep); i > 0; i >>= 1 {\n\tif i&1 != 0 {\n\t\tpow *= sq\n\t}\n\tsq *= sq\n}\nreturn hash, pow", "gen": "var a [10]int\nvar b int\nvar c int\nfor i := range a {\n\tb += a[i]\n\tc *= i\n}\nreturn b * c\n}\n\nTEXT main.main(SB) /Users/mdempsky/go/src/main/main.go\nMOVQ $0, AX\nMOVQ $0, CX\nMOVQ $0, DX\nMOVQ $0, R8\nMOVQ $0, R9\nMOVQ $0, R10\nMOVQ $0, R11\nMOVQ $0, R12\nMOVQ $0, R13\nMOVQ $0, R14\nMOVQ $0, R15\nMOVQ $0, RBP\nMOVQ $0, RSP\nMOVQ $0, RSI\nMOVQ $0, RDI\nMOVQ $0, RBX\nMOVQ $0, RDX\nMOVQ $0, RAX\nMOVQ $0, RCX\nMOVQ $0, R8\nMOVQ $0, R9\nMOVQ $0, R10\nMOVQ $0, R11\nMOVQ $0, R12\nMOVQ $0, R13\nMOVQ $0, R14\nMOVQ $0, R15\nMOVQ $0, RBP\nMOVQ $0, RSP\nMOVQ $0, RSI\nMOVQ $0, RDI\nMOVQ $0, RBX\nMOVQ $0, RDX\nMOVQ $0, RAX\nMOVQ $0, RCX\nMOVQ $0, R8\nMOVQ $0, R9\nMOVQ $0, R10\nMOVQ $0, R11\nMOVQ $0, R12"}
{"tgt": "b, _ := ioutil.ReadFile(\"STR\")\ns := strings.Replace(string(b), \"STR\", \"STR\", -1)\nnumData := strings.Split(s, \"STR\")\nfor _, n := range numData {\n\tnumber, err := strconv.Atoi(n)\n\tif err == nil {\n\t\tdata = append(data, number)\n\t}\n}", "gen": "data := []int{1, 2, 3}\ndata = append(data, 4)\nfmt.Println(data)\n}\n"}
{"tgt": "if len(A) == len(A[0]) {\n\tfor i := 0; i < len(A); i++ {\n\t\tfor j := 0; j < len(A); j++ {\n\t\t\tif i == j {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]\n\t\t}\n\t}\n\treturn A\n}\nres := make([][]int, len(A[0]))\nfor i := 0; i < len(res); i++ {\n\tres[i] = make([]int, len(A))\n\tfor j := 0; j < len(A); j++ {\n\t\tres[i][j] = A[j][i]\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := SumRevLLNum(tc.first, tc.second); !equal(result, tc.sum) {\n\t\tt.Errorf(\"STR\",\n\t\t\ttcid, String(result), String(tc.sum))\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tm: 3,\n\t\tn: 3,\n\t\tops: [][]int{\n\t\t\t{2, 2},\n\t\t\t{3, 3},\n\t\t},\n\t\twant: 4,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxCount(tt.m, tt.n, tt.ops)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.m, got, tt.want)\n\t}\n}", "gen": "var a [5]int\na[0] = 2\na[1] = 2\na[2] = 3\na[3] = 3\na[4] = 2\nvar b [5]int\nb[0] = 2\nb[1] = 2\nb[2] = 3\nb[3] = 3\nb[4] = 2\nvar c [5]int\nc[0] = 2\nc[1] = 2\nc[2] = 3\nc[3] = 3\nc[4] = 2\nvar d [5]int\nd[0] = 2\nd[1] = 2\nd[2] = 3\nd[3] = 3\nd[4] = 2\nvar e [5]int\ne[0] = 2\ne[1] = 2\ne[2] = 3\ne[3] = 3\ne[4] = 2\nvar f [5]int\nf[0] = 2\nf[1] = 2\nf[2] = 3\nf[3] = 3\nf[4] = 2\nvar g [5]int\ng[0] = 2\ng[1] = 2\ng[2] = 3\ng[3] = 3\ng[4] = 2\nvar h [5]int\nh[0] = 2\nh[1] = 2\nh[2] = 3\nh[3] = 3\nh[4] = 2\nvar i [5]int\ni[0] = 2\ni[1] = 2\ni[2] = 3\ni[3] = 3\ni[4] = 2\nvar j [5]int\nj[0] = 2\nj[1] ="}
{"tgt": "n := len(quality)\nworkers := make([][2]float64, n)\nfor i := 0; i < n; i++ {\n\tw, q := float64(wage[i]), float64(quality[i])\n\tworkers[i][0], workers[i][1] = w/q, q\n}\nsort.Slice(workers, func(i, j int) bool {\n\treturn workers[i][0] < workers[j][0]\n})\nres := math.MaxFloat64\nsum := 0.\nh := floatHeap{}\nfor _, w := range workers {\n\tsum += w[1]\n\theap.Push(&h, w[1])\n\tif len(h) > K {\n\t\tsum -= heap.Pop(&h).(float64)\n\t}\n\tif len(h) == K {\n\t\tres = min(res, sum*w[0])\n\t}\n}\nreturn res", "gen": "fmt.Println(mincostToHireWorkers(10, []int{10, 20, 20}, []int{1, 1, 1}))\n}\n"}
{"tgt": "flag.Parse()\nroots := flag.Args()\nif len(roots) == 0 {\n\troots = []string{\"STR\"}\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, root := range roots {\n\t\twalkDir(root, fileSizes)\n\t}\n\tclose(fileSizes)\n}()\nvar nfiles, nbytes int64\nfor size := range fileSizes {\n\tnfiles++\n\tnbytes += size\n}\nprintDiskUsage(nfiles, nbytes)", "gen": "flag.Parse()\nargs := flag.Args()\nif len(args) != 2 {\n\tpanic(\"expected two arguments\")\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, arg := range args {\n\t\tfileSizes <- getFileSize(arg)\n\t}\n\tclose(fileSizes)\n}()\ntotal := int64(0)\nfor size := range fileSizes {\n\ttotal += size\n}\nprintDiskUsage(total)\n}"}
{"tgt": "var min int\ntotalPeople := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\ttotalPeople++\n\t}\n}\nif totalPeople < 2 {\n\treturn 0\n}\nmiddle := (totalPeople / 2) + (totalPeople % 2)\nindex := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\tmiddle--\n\t}\n\tif middle == 0 {\n\t\tindex = i\n\t\tbreak\n\t}\n}\nleftZero := 0\nleftZeroFound := false\nfor j := index - 1; j >= 0; j-- {\n\tif !leftZeroFound && seating[j] == 0 {\n\t\tleftZero = j\n\t\tleftZeroFound = true\n\t} else if seating[j] == 1 && j < leftZero {\n\t\tmin += abs(j - leftZero)\n\t\tleftZero--\n\t}\n}\nrightZero := 0\nrightZeroFound := false\nfor j := index + 1; j < len(seating); j++ {\n\tif !rightZeroFound && seating[j] == 0 {\n\t\trightZero = j\n\t\trightZeroFound = true\n\t} else if seating[j] == 1 && j > rightZero {\n\t\tmin += abs(j - rightZero)\n\t\trightZero++\n\t}\n}\nreturn min", "gen": "var a, b, c int\na = 0\nb = 0\nc = 0\nfor i := 0; i < len(arr); i++ {\n\tif arr[i] == 1 {\n\t\ta++\n\t} else {\n\t\tb++\n\t}\n}\nfor i := 0; i < len(arr); i++ {\n\tif arr[i] == 1 {\n\t\tb--\n\t} else {\n\t\ta--\n\t}\n\tif a < b {\n\t\tc++\n\t}\n}\nfor i := 0; i < len(arr); i++ {\n\tif arr[i] == 1 {\n\t\tb++\n\t} else {\n\t\ta++\n\t}\n\tif a > b {\n\t\tc--\n\t}\n}\nreturn c\n}\n"}
{"tgt": "sum := 0\nprev := 1\ncurr := 1\nfor curr <= 4e6 {\n\tprev, curr = curr, prev+curr\n\tif curr%2 == 0 {\n\t\tsum += curr\n\t}\n}\nfmt.Println(sum)", "gen": "var a, b int\na = 1\nb = 1\nfor i := 1; i < 4000000; i++ {\n\tif i%2 == 0 {\n\t\ta += b\n\t} else {\n\t\ta = a + b\n\t}\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "stack := make([]int, 0)\nresult := make([]int, len(T))\nfor i, t := range T {\n\tfor len(stack) > 0 && T[stack[len(stack)-1]] < t {\n\t\tresult[stack[len(stack)-1]] = i - stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t}\n\tstack = append(stack, i)\n}\nfor _, i := range stack {\n\tresult[i] = 0\n}\nreturn result", "gen": "var a []int\nvar b []int\nvar c []int\nfor i := 0; i < len(a); i++ {\n\tif i < len(b) {\n\t\tc[i] = a[i]\n\t} else {\n\t\tpanic(errors.New(\"\"))\n\t}\n}\n}\n"}
{"tgt": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 2}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(isBoomerang([]int{1, 1, 1}, []int{2, 2, 2}, []int{3, 3, 3}))\nfmt.Println(isBoomerang([]int{1, 2, 3}, []int{2, 3, 1}, []int{1, 1, 2}))\nfmt.Println(isBoomerang([]int{1, 1, 2}, []int{2, 1, 1}, []int{1, 2, 1}))\nfmt.Println(isBoomerang([]int{1, 2, 3}, []int{2, 1, 1}, []int{1, 1, 2}))\nfmt.Println(isBoomerang([]int{1, 1, 1}, []int{1, 1, 1}, []int{1, 1, 1}))\nfmt.Println(isBoomerang([]int{1, 1, 1}, []int{2, 2, 2}, []int{3, 3, 3}))\nfmt.Println(isBoomerang([]int{1, 1, 1}, []int{2, 2, 2}, []int{3, 3, 3}))\nfmt.Println(isBoomerang([]int{1, 1, 1}, []int{2, 2, 2}, []int{3, 3, 3}))\nfmt.Println(isBoomerang([]int{1, 1, 1}, []int{2, 2, 2}, []int{3, 3, 3}))\nfmt.Println(isBoomerang([]int{1, 1, 1}, []int{2, 2, 2}, []int{3, 3, 3}))\nfmt.Println(isBoomerang([]int{1, 1, 1}, []int{2, 2, 2}, []int{3, 3, 3}))\nfmt.Println"}
{"tgt": "out := 100\nif x := p33(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "p33 := 100\nif p33 != 100 {\n\tvar p34 interface{}\n\tp34 = p33\n\tvar p35 interface{}\n\tp35 = p34\n\tvar p36 interface{}\n\tp36 = p35\n\ttesting.T.Errorf(0, 24, \"p33 != 100\", p36)\n}\n}\n"}
