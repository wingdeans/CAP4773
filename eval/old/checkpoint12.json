{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif sum := SumBSTRange(tc.root, tc.a, tc.b); sum != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, sum)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SumBSTRange(tc.root, tc.min, tc.max); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "return &linkLoop{\n\tHead: &linkLoopNode{},\n}", "gen": "return &linkLoop{\n\thead: &linkLoopNode{},\n}\n}"}
{"tgt": "return bindataRead(\n\t_assetsHomeCatJpg,\n\t\"STR\",\n)", "gen": "return bindataRead(STR, _assetsHomeCatJpg)\n}"}
{"tgt": "max := 1000\nsum := 0\nfor i := 1; i < max; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)", "gen": "max := 1000\nsum := 0\nfor i := 1; i <= max; i++ {\n\tif i%3 == 0 || i%5 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.locs); !reflect.DeepEqual(bonuses, tc.bonuses) {\n\t\tt.Errorf(\"STR\", tc.bonuses, bonuses)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.input); !reflect.DeepEqual(bonuses, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, bonuses)\n\t}\n}\n}"}
{"tgt": "max := 9999\nbiggestPandigital := 0\nvar numberMultiplied int\nfor i := max; i > 0; i-- {\n\tnumberMultiplied = i\n\tfor j := 1; len(digits(numberMultiplied)) <= 9; j++ {\n\t\tnumberMultiplied = concatenMultiplication(i, j)\n\t\tif IsPandigital(numberMultiplied) && numberMultiplied > biggestPandigital {\n\t\t\tfmt.Println(numberMultiplied)\n\t\t\tbiggestPandigital = numberMultiplied\n\t\t}\n\t}\n}", "gen": "n := 9999\nfor i := 999; i > 0; i-- {\n\tp := concatenMultiplication(i, n)\n\tif IsPandigital(p) {\n\t\tfmt.Println(p)\n\t\tn = p\n\t\tbreak\n\t}\n}\n}"}
{"tgt": "for {\n\tswitch r := l.next(); {\n\tcase unicode.IsNumber(r):\n\tcase r == \"STR\":\n\t\tl.backup()\n\t\tl.emit(itemEnd)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase r == eof:\n\t\tl.emit(itemEnd)\n\t\treturn byteRangeSet\n\tdefault:\n\t\treturn l.error(\"STR\")\n\t}\n}", "gen": "for {\n\tswitch l.next() {\n\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\tl.backup()\n\t\tl.emit(byteRangeSet)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase ',':\n\t\tl.emit(byteRangeSet)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tdefault:\n\t\tl.error(fmt.Sprintf(\"unexpected character %q\", l.peek()))\n\t\treturn byteRangeSet\n\t}\n}\n}"}
{"tgt": "return func(treebinaryTreeIf, node interface{}) bool {\n\tn := node.(*gbtElement)\n\tif !tree.IsNil(n.Left) && n.Left.Key >= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Left, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif !tree.IsNil(n.Right) && n.Right.Key <= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Right, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif debug {\n\t\tfmt.Println(n)\n\t}\n\t*nodeCnt++\n\treturn false\n}", "gen": "t := t1{\n\tt: t,\n}\nt.nodeCnt = 0\nt.debug2 = debug\nreturn t, t.nodeCnt, t.debug2\n}"}
{"tgt": "iterator := func() <-chan VertexId {\n\tch := make(chan VertexId)\n\tgo func() {\n\t\tif connected, ok := g.edges[vertex]; ok {\n\t\t\tfor VertexId, _ := range connected {\n\t\t\t\tif g.IsEdge(vertex, VertexId) {\n\t\t\t\t\tch <- VertexId\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\nreturn VerticesIterable(&vertexIterableHelper{iterFunc: iterator})", "gen": "g := &graph{\n\tvertices: vertices,\n}\nid := VertexId(id)\nreturn &vertexIterableHelper{\n\tVerticesIter: func(c chan<- VertexId) {\n\t\tg.GetSuccessors(id, c)\n\t},\n}\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 2, 1}, []int{0, 4, 1, 3, 2}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1}, []int{0}, []int{1}},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums, c.index)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums, c.index)\n\t\t}\n\t})\n}", "gen": "var s = Solution{\n\tname: \"STR\",\n\tnums: []int{0, 1, 2, 3, 4},\n\tindex: []int{0, 1, 2, 2, 1},\n\texpect: []int{1, 2, 3, 4, 0},\n}\nfor i := 0; i < 5; i++ {\n\ttestStr := \"STR\" + strconv.Itoa(i)\n\tt.Run(testStr, func(t *testing.T) {\n\t\ttestSolution(t, s)\n\t})\n}\n}"}
{"tgt": "c.bw.WriteString(\"STR\")\nc.bw.WriteByte(space)\nc.bw.WriteString(key)\nc.bw.WriteByte(space)\nc.bw.Write(strconv.AppendInt(c.numScratch[:0], int64(timeout), 10))\n_, err = c.bw.Write(crlf)\nreturn", "gen": "w.WriteString(\"VALUE \")\nw.WriteString(key)\nw.WriteByte(' ')\nw.WriteString(strconv.Itoa(int(flags)))\nw.WriteString(\" \" + strconv.Itoa(len(value)))\nw.WriteString(crlf)\nw.WriteString(value)\nw.WriteString(crlf)\nreturn w.Flush()\n}"}
{"tgt": "for V > 0 {\n\tV--\n\tif !isDroppedLeft(heights, K) && !isDroppedRight(heights, K) {\n\t\theights[K]++\n\t}\n}\nreturn heights", "gen": "for i := len(heights) - 1; i >= 0; i-- {\n\tif isDroppedLeft(heights, i) {\n\t\tif isDroppedRight(heights, i) {\n\t\t\theights[i]++\n\t\t}\n\t}\n}\nreturn heights\n}"}
{"tgt": "h := &IntMaxHeap{}\nheap.Init(h)\nheap.Push(h, 7)\nheap.Push(h, 3)\nheap.Push(h, 2)\nheap.Push(h, 1)\nheap.Push(h, 5)\nheap.Push(h, 5)\nheap.Push(h, 6)\nheap.Push(h, 7)\nfmt.Printf(\"STR\", (*h))\nfor h.Len() > 0 {\n\tfmt.Printf(\"STR\", heap.Pop(h))\n}", "gen": "h := IntMaxHeap{}\nh.Init(IntMaxHeap)\nh.Push(IntMaxHeap, 1)\nh.Push(IntMaxHeap, 2)\nh.Push(IntMaxHeap, 3)\nh.Push(IntMaxHeap, 4)\nh.Push(IntMaxHeap, 5)\nh.Push(IntMaxHeap, 6)\nh.Push(IntMaxHeap, 7)\nh.Push(IntMaxHeap, 8)\nh.Push(IntMaxHeap, 9)\nh.Push(IntMaxHeap, 10)\nh.Push(IntMaxHeap, 11)\nh.Push(IntMaxHeap, 12)\nh.Push(IntMaxHeap, 13)\nh.Push(IntMaxHeap, 14)\nh.Push(IntMaxHeap, 15)\nh.Push(IntMaxHeap, 16)\nh.Push(IntMaxHeap, 17)\nh.Push(IntMaxHeap, 18)\nh.Push(IntMaxHeap, 19)\nh.Push(IntMaxHeap, 20)\nh.Push(IntMaxHeap, 21)\nh.Push(IntMaxHeap, 22)\nh.Push(IntMaxHeap, 23)\nh.Push(IntMaxHeap, 24)\nh.Push(IntMaxHeap, 25)\nh.Push(IntMaxHeap, 26)\nh.Push(IntMaxHeap, 27)\nh.Push(IntMaxHeap, 28)\nh.Push(IntMaxHeap, 29)\nh.Push(IntMaxHeap, 30)\nh.Push(IntMaxHeap, 31)\nh.Push(IntMaxHeap, 32)\nh.Push(IntMaxHeap"}
{"tgt": "sLen, pLen := len(s), len(p)\ndp := make([][]bool, sLen+1)\nfor i := range dp {\n\tdp[i] = make([]bool, pLen+1)\n}\ndp[sLen][pLen] = true\nfor i := sLen; i > -1; i-- {\n\tfor j := pLen - 1; j > -1; j-- {\n\t\tfirstMatch := i < sLen && (p[j] == s[i] || p[j] == '.')\n\t\tif j+1 < pLen && p[j+1] == '*' {\n\t\t\tdp[i][j] = dp[i][j+2] || firstMatch && dp[i+1][j]\n\t\t} else {\n\t\t\tdp[i][j] = firstMatch && dp[i+1][j+1]\n\t\t}\n\t}\n}\nreturn dp[0][0]", "gen": "var (\n\tres = make([][]bool, len(s)+1)\n\ti   = 0\n)\nfor i < len(s) {\n\tres[i+1] = make([]bool, len(s))\n\tfor j := 0; j < len(s); j++ {\n\t\tif s[i] == s[j] && (i == 0 || res[i][j] == false) {\n\t\t\tres[i+1][j] = true\n\t\t}\n\t}\n\ti++\n}\nreturn res[len(s)][0]\n}"}
{"tgt": "l1 := len(board)\nif l1 == 0 {\n\treturn\n}\nl2 := len(board[0])\nif l2 == 0 {\n\treturn\n}\nvisit := make([][]bool, l1)\nfor i := 0; i < l1; i++ {\n\tvisit[i] = make([]bool, l2)\n}\nfor i := 0; i < l1; i++ {\n\tfor j := 0; j < l2; j++ {\n\t\tif !visit[i][j] {\n\t\t\thelper(board, visit, i, j)\n\t\t}\n\t}\n}", "gen": "n := len(A)\nif n == 0 {\n\treturn nil\n}\nres := make([]bool, n)\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tif helper(A[i], A[j]) {\n\t\t\tres[i] = true\n\t\t\tbreak\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.nums); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.left, tc.right); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.left, tc.right, tc.expected, result)\n\t}\n}\n}"}
{"tgt": "sum := 100 * 101 / 2\nsqSum := sum * sum\nsumSq := 0\nfor i := 1; i <= 100; i++ {\n\tsumSq += i * i\n}\nfmt.Println(sqSum - sumSq)", "gen": "sum := 5050 * 5050\ntotal := 0\nfor i := 1; i <= 100; i++ {\n\ttotal += i * i\n}\nfmt.Println(sum - total)\n}"}
{"tgt": "return x != y", "gen": "return a == b\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 1, 3}},\n\t\tans1051{3},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 2, 3, 4}},\n\t\tans1051{5},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{0},\n\t},\n\t{\n\t\tpara1051{[]int{5, 4, 3, 2, 1}},\n\t\tans1051{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 3}},\n\t\tans1051{true},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 4, 2, 3}},\n\t\tans1051{false},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"STR\", got, tt.want)\n\t\t}\n\t})\n}", "gen": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"largestOverlap() = %v, want %v\", got, tt.want)\n\t\t}\n\t})\n}\n}"}
{"tgt": "if m == 0 {\n\treturn 1\n}\nswitch n {\ncase 1:\n\treturn 2\ncase 2:\n\tif m == 1 {\n\t\treturn 3\n\t}\n\treturn 4\ndefault:\n\tswitch m {\n\tcase 1:\n\t\treturn 4\n\tcase 2:\n\t\treturn 7\n\tdefault:\n\t\treturn 8\n\t}\n}", "gen": "if n == 0 {\n\treturn 1\n}\nif n == 1 {\n\treturn 2\n}\nif n == 2 {\n\treturn 3\n}\nif n == 3 {\n\treturn 4\n}\nif n == 4 {\n\treturn 7\n}\nif n == 5 {\n\treturn 8\n}\nreturn 9\n}"}
{"tgt": "sort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].End < intervals[j].End\n})\ncount := 0\ncurrent := -int(^uint(0)>>1) - 1\nfor _, interval := range intervals {\n\tif interval.Start >= current {\n\t\tcount++\n\t\tcurrent = interval.End\n\t}\n}\nreturn len(intervals) - count", "gen": "var res []Interval\nvar f func(Interval)\nf = func(i Interval) {\n\tres = append(res, i)\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nvar max int\nfor _, i := range intervals {\n\tif i.Start < max {\n\t\tcontinue\n\t}\n\tmax = i.End\n\tf(i)\n}\nreturn res\n}"}
{"tgt": "switch rand.Intn(10) {\ncase 1, 9:\n\treturn io.EOF\ncase 5:\n\treturn errors.New(\"STR\")\ndefault:\n\td.Line = \"STR\"\n\tfmt.Println(\"STR\", d.Line)\n\treturn nil\n}", "gen": "rand.Seed(time.Now().UnixNano())\nswitch rand.Intn(10) {\ncase 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:\n\tfmt.Println(\"STR\")\ndefault:\n\treturn errors.New(\"STR\")\n}\n}"}
{"tgt": "fmt.Println(subarrayBitwiseORs([]int{0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))", "gen": "fmt.Println(subarrayBitwiseORs([]int{0, 1, 0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1,"}
{"tgt": "dummy := &ListNode{0, head}\nslow, fast := dummy, dummy\nfor fast.Next != nil && fast.Next.Next != nil {\n\tfast = fast.Next.Next\n\tslow = slow.Next\n}\nreturn slow.Next", "gen": "var head *ListNode\nfor head != nil && head.Next != nil && head.Next.Next != nil {\n\thead = head.Next.Next\n}\nreturn head\n}"}
{"tgt": "pairs := [...][2]int{{10, 7}, {1000, 983}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p26(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "for _, v := range []int{10, 7, 1000, 983} {\n\tif p26(v) != v {\n\t\tt.Errorf(\"STR\", v)\n\t}\n}\n}"}
{"tgt": "n := len(A)\nfor i := n - 2; i >= 0; i-- {\n\tA[i] += A[i+1]\n}\nmem := [101][33]int{}\nvar dp func(int, int) int\ndp = func(i, m int) int {\n\tif i+2*m >= n {\n\t\treturn A[i]\n\t}\n\tif mem[i][m] > 0 {\n\t\treturn mem[i][m]\n\t}\n\tres := 0\n\tfor x := 1; x <= 2*m; x++ {\n\t\tres = max(\n\t\t\tres,\n\t\t\tA[i]-dp(i+x, max(m, x)),\n\t\t)\n\t}\n\tmem[i][m] = res\n\treturn res\n}\nreturn dp(0, 1)", "gen": "n := len(stones)\ndp := make([]int, n+1)\nfor i := n - 2; i >= 0; i-- {\n\tdp[i+1] = dp[i+2] + stones[i]\n}\nvar dfs func(i int) int\ndfs = func(i int) int {\n\tif i == n {\n\t\treturn 0\n\t}\n\tif dp[i] != 0 {\n\t\treturn dp[i]\n\t}\n\tdp[i] = -1\n\treturn dp[i]\n}\nreturn dfs(0)\n}"}
{"tgt": "if n == 0 {\n\treturn 0\n}\nreturn n/5 + trailingZeroes(n/5)", "gen": "if n == 0 {\n\treturn 0\n}\nreturn trailingZeroes(n) + trailingZeroes(n/5)\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0}, 5},\n\t{\"STR\", []int{0, 0, 0, 0, 1}, []int{1, 0, 0, 0, 0}, 4},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums1, c.nums2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums1, c.nums2)\n\t\t}\n\t})\n}", "gen": "var tests = []struct {\n\tname  string\n\tnums1 []int\n\tnums2 []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3}, []int{2, 1}, 1},\n\t{\"STR\", []int{3, 2, 1}, []int{1, 2}, 3},\n\t{\"STR\", []int{0, 0, 0}, []int{1, 2, 3}, 0},\n}\nfor i, tt := range tests {\n\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := findMedianSortedArrays(tt.nums1, tt.nums2)\n\t\tif got != tt.expect {\n\t\t\tt.Errorf(\"STR\", tt.name, tt.nums1, tt.nums2, tt.expect, got)\n\t\t}\n\t})\n}\n}"}
{"tgt": "list.rear = nil", "gen": "p.head = nil\n}"}
{"tgt": "if len(name) == 0 && len(typed) == 0 {\n\treturn true\n}\nif (len(name) == 0 && len(typed) != 0) || (len(name) != 0 && len(typed) == 0) {\n\treturn false\n}\nj := 0\nfor i := 0; i < len(name); i++ {\n\tif j < len(typed) && name[i] == typed[j] {\n\t\tj++\n\t\tcontinue\n\t} else {\n\t\tif i > 0 && j < len(typed) && name[i-1] == typed[j] {\n\t\t\tj++\n\t\t\ti--\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "if len(s) == 0 || len(t) == 0 {\n\treturn false\n}\nif len(s) != len(t) {\n\treturn false\n}\nif len(s) == len(t) {\n\treturn true\n}\nfor i := 0; i < len(s); i++ {\n\tfor j := 0; j < len(s); j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == t[j] {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true\n}"}
{"tgt": "factorial := new(big.Int).MulRange(1, 100)\nbytes := factorial.Append([]byte{}, 10)\nsum := 0\nfor b := range bytes {\n\tsum += int(bytes[b] - '0')\n}\nfmt.Println(\"STR\", sum)", "gen": "n := big.NewInt()\nn.MulRange(100, 999)\nvar s string\nfor _, c := range n.Append(nil, 10) {\n\ts += string(c)\n}\nfmt.Println(s)\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs int\n\texpect int\n}{\n\t{\"STR\", 2, 1},\n\t{\"STR\", 3, 2},\n\t{\"STR\", 4, 3},\n\t{\"STR\", 0, 0},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "var tests = []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{2, 3}, 1},\n\t{\"STR\", []int{2, 3}, 1},\n\t{\"STR\", []int{2, 3}, 1},\n}\nfor _, tt := range tests {\n\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(tt.inputs)\n\t\tif !reflect.DeepEqual(got, tt.expect) {\n\t\t\tt.Errorf(\"STR\", tt.expect, got)\n\t\t}\n\t})\n}\n}"}
{"tgt": "var low, mid, high int = 0, len(sorted) / 2, len(sorted)\nfor low < high {\n\tcurr := sorted[mid]\n\tswitch {\n\tcase curr == target:\n\t\treturn mid\n\tcase inRange(sorted[mid:high], target):\n\t\tlow = mid\n\t\tmid = (low + high) / 2\n\tdefault:\n\t\thigh = mid\n\t\tmid = (low + high) / 2\n\t}\n}\nreturn -1", "gen": "low, high := 0, len(nums)-1\nfor low <= high {\n\tmid := (low + high) / 2\n\tif nums[mid] == target {\n\t\treturn mid\n\t} else if nums[mid] < target {\n\t\tlow = mid + 1\n\t} else {\n\t\thigh = mid - 1\n\t}\n}\nreturn -1\n}"}
{"tgt": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nret := &ListNode{}\nif l1.Val <= l2.Val {\n\tret = l1\n\tret.Next = mergeTwoLists1(l1.Next, l2)\n} else {\n\tret = l2\n\tret.Next = mergeTwoLists1(l1, l2.Next)\n}\nreturn ret", "gen": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nif l1.Val < l2.Val {\n\tl1.Next = mergeTwoLists1(l1.Next, l2)\n\treturn l1\n}\nl2.Next = mergeTwoLists1(l1, l2.Next)\nreturn l2\n}"}
{"tgt": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Print(sum, \"STR\")", "gen": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif i%3 == 0 || i%5 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "rets := make([][]int, numRows)\nif numRows == 0 {\n\treturn rets\n}\nrets[0] = []int{1}\nfor i := 1; i < numRows; i++ {\n\trets[i] = make([]int, i+1)\n\trets[i][0] = 1\n\trets[i][i] = 1\n\tfor j := 1; j < i; j++ {\n\t\trets[i][j] = rets[i-1][j-1] + rets[i-1][j]\n\t}\n}\nreturn rets", "gen": "if len(nums) == 0 {\n\treturn []int{1}\n}\nres := make([]int, len(nums)+1)\nres[0] = 1\nfor i := 1; i <= len(nums); i++ {\n\tfor j := 0; j < i; j++ {\n\t\tres[i] += res[j] * res[i-j-1]\n\t}\n}\nreturn res\n}"}
{"tgt": "start := -1\nlenMax := 0\ndict := [256]int{}\nfor i := range dict {\n\tdict[i] = -1\n}\nfor i, r := range s {\n\tif v := dict[r]; v > start {\n\t\tstart = v\n\t}\n\tlength := i - start\n\tif length > lenMax {\n\t\tlenMax = length\n\t}\n\tdict[r] = i\n}\nreturn lenMax", "gen": "var max, count int\nfor i := 0; i < 256; i++ {\n\tcount = 0\n\tfor _, c := range s {\n\t\tif c == byte(i) {\n\t\t\tcount++\n\t\t}\n\t}\n\tif count > max {\n\t\tmax = count\n\t}\n}\nreturn max\n}"}
{"tgt": "nlen := len(nums)\nfor i := 0; i < nlen-2; i++ {\n\tif i != 0 && nums[i] == nums[i-1] {\n\t\tcontinue\n\t}\n\tleft, right := i+1, nlen-1\n\tfor left < right {\n\t\tsum := nums[i] + nums[left] + nums[right]\n\t\tif sum == target {\n\t\t\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tleft++\n\t\t\tright--\n\t\t} else if sum < target {\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tleft++\n\t\t} else {\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tright--\n\t\t}\n\t}\n}", "gen": "for i := 0; i < len(nums); i++ {\n\tfor j := i + 1; j < len(nums); j++ {\n\t\tif nums[i]+nums[j] == target {\n\t\t\treturn []int{i, j}\n\t\t}\n\t}\n\tfor j := len(nums) - 1; j > i; j-- {\n\t\tif nums[i]+nums[j] == target {\n\t\t\treturn []int{i, j}\n\t\t}\n\t}\n}\nreturn nil\n}"}
{"tgt": "return strings.ReplaceAll(r.element.Name, \"STR\", \"\")", "gen": "return strings.ReplaceAll(s, \"STR\", \"STRSTR\")\n}"}
{"tgt": "var res byte\nfor i := 0; i < len(s); i++ {\n\tres ^= s[i]\n}\nfor i := 0; i < len(t); i++ {\n\tres ^= t[i]\n}\nreturn res", "gen": "var res bool\nfor i := 0; i < len(s1); i++ {\n\tres = res ^ (s1[i] == s2[i])\n}\nfor i := 0; i < len(s2); i++ {\n\tres = res ^ (s1[i] == s2[i])\n}\nreturn res\n}"}
{"tgt": "m := len(A)\nn := len(A[0])\nans := make([][]int, n)\nfor k := range ans {\n\tans[k] = make([]int, m)\n}\nfor r := 0; r < m; r++ {\n\tfor c := 0; c < n; c++ {\n\t\tans[c][r] = A[r][c]\n\t}\n}\nreturn ans", "gen": "n := len(nums)\nres := make([][]int, n)\nfor i := 0; i < n; i++ {\n\tres[i] = make([]int, n)\n\tfor j := 0; j < n; j++ {\n\t\tres[i][j] = nums[i]\n\t}\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tres[i][j] = nums[i]\n\t}\n}\nreturn res\n}"}
{"tgt": "println(\"STR\", len(a))", "gen": "println(\"STR\", len(s))\n}"}
{"tgt": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nc, res := []int{}, [][]int{}\nsort.Ints(candidates)\nfindcombinationSum(candidates, target, 0, c, &res)\nreturn res", "gen": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nsort.Ints(candidates)\nreturn findcombinationSum(candidates, target, []int{}, []int{})\n}"}
{"tgt": "for i := 0; i < len(A)-1; i++ {\n\tif A[i] == i {\n\t\tcontinue\n\t}\n\tif A[i] == i+1 && A[i+1] == i {\n\t\ti++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var i int\nfor i = 0; i < len(nums)-1; i++ {\n\tif nums[i] == nums[i+1] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "for n := 0; n < 32; n++ {\n\tsquare[n] = gf2MatrixTimes(mat, mat[n])\n}", "gen": "for i := 0; i < 32; i++ {\n\tcrc[i] = gf2MatrixTimes(crc, crc[i])\n\tcrc[i] = crc[i] ^ crc[i]\n}\n}"}
{"tgt": "for i := 0; i < n; i++ {\n\tif len(squares) != i {\n\t\tprintln(\"STR\", len(squares), \"STR\", i)\n\t}\n\tsquares[i] = i * i\n\tfor j := 0; j <= i; j++ {\n\t\tif v, ok := squares[j]; !ok || v != j*j {\n\t\t\tif !ok {\n\t\t\t\tprintln(\"STR\", j)\n\t\t\t} else {\n\t\t\t\tprintln(\"STR\", j, v)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "for i := 0; i < n; i++ {\n\tif i == 0 {\n\t\tm[i] = 1\n\t} else {\n\t\tm[i] = i * m[i-1]\n\t}\n\tfor j := 0; j < i; j++ {\n\t\tif j == 0 {\n\t\t\tif i%2 == 0 {\n\t\t\t\tfmt.Println(\"STR\", i, \"STR\", j)\n\t\t\t}\n\t\t} else {\n\t\t\tif i%2 == 0 {\n\t\t\t\tfmt.Println(\"STR\", i, \"STR\", j)\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"STR\", i, \"STR\", j)\n\t\t\t}\n\t\t}\n\t}\n}\n}"}
{"tgt": "for j := 1; j <= 20; j++ {\n\tif num%j != 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "for i := 1; i <= 20; i++ {\n\tif n%i == 0 {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "if len(sorted) == 0 {\n\treturn nil\n}\nmid := len(sorted) / 2\nroot := &BST{Value: sorted[mid]}\nroot.Left = SortedSliceToBST(sorted[:mid])\nroot.Right = SortedSliceToBST(sorted[mid+1:])\nreturn root", "gen": "if len(nums) == 0 {\n\treturn nil\n}\nmid := len(nums) / 2\nleft := SortedSliceToBST(nums[:mid])\nright := SortedSliceToBST(nums[mid:])\nreturn &BST{\n\tVal:   nums[mid],\n\tLeft:  left,\n\tRight: right,\n}\n}"}
{"tgt": "return x * y", "gen": "return (x.R * y.R) + (x.G * y.G) + (x.B * y.B)\n}"}
{"tgt": "i1 := 0\ni2 := 0\nval1 := 0\nval2 := 0\nfor i1 < len(version1) || i2 < len(version2) {\n\tval1, i1 = parseSeg(version1, i1)\n\tval2, i2 = parseSeg(version2, i2)\n\tif val1 > val2 {\n\t\treturn 1\n\t}\n\tif val1 < val2 {\n\t\treturn -1\n\t}\n}\nif i1 < len(version1) {\n\treturn 1\n}\nif i2 < len(version2) {\n\treturn -1\n}\nreturn 0", "gen": "var (\n\tstart, end int\n\terr        error\n)\nfor i := 0; i < len(s); i++ {\n\tstart, end, err = parseSeg(s[i])\n\tif err != nil {\n\t\treturn 1\n\t}\n\tif start > end {\n\t\treturn 1\n\t}\n\tif start < end && start > endTime {\n\t\treturn 1\n\t}\n\tif start < end && end < startTime {\n\t\treturn 1\n\t}\n}\nif startTime < endTime {\n\treturn -1\n}\nreturn 0\n}"}
{"tgt": "return this.Val", "gen": "return self.head\n}"}
{"tgt": "str := \"STR\"\nfmt.Println(longestPalindrome(str))", "gen": "fmt.Println(longestPalindrome(\"STR\"))\n}"}
{"tgt": "dat, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\nnamesList := string(dat)\nnamesList = strings.Replace(namesList, \"STR\", \"STR\", -1)\nnames := strings.Split(namesList, \"STR\")\nsort.Strings(names)\nnamesScore := 0\nfor index, name := range names {\n\tnamesScore += nameScore(name) * (index + 1)\n}\nfmt.Println(namesScore)", "gen": "b, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\ns := string(b)\ns = strings.Replace(s, \"STR\", \"STR\", -1)\ns = strings.Split(s, \"STR\")\nsort.Strings(s)\nvar sum int\nfor _, v := range s {\n\tsum += nameScore(v)\n}\nfmt.Println(sum)\n}"}
{"tgt": "res := 0\nsort.Ints(houses)\nsort.Ints(heaters)\nm, n := len(houses), len(heaters)\nindex := sort.SearchInts(heaters, houses[0])\nfor _, house := range houses {\n\tfor index < n && house > heaters[index] {\n\t\tindex++\n\t}\n\tif index == n {\n\t\treturn max(res, houses[m-1]-heaters[index-1])\n\t}\n\tleft := math.MaxInt32\n\tif index > 0 {\n\t\tleft = house - heaters[index-1]\n\t}\n\tright := heaters[index] - house\n\tres = max(res, min(left, right))\n}\nreturn res", "gen": "sort.Ints(A)\nsort.Ints(B)\ni := sort.SearchInts(B, A[0])\nmax := A[0]\nfor i < len(B) && A[0] == B[i] {\n\tmax = max(max, A[0]-B[i])\n\ti++\n}\nif i < len(B) {\n\tmax = min(max, A[0]-B[i-1])\n}\nfor i := 1; i < len(A); i++ {\n\tfor j := 0; j < len(B); j++ {\n\t\tif A[i] == B[j] {\n\t\t\tmax = max(max, A[i]-B[j])\n\t\t}\n\t}\n}\nreturn max\n}"}
{"tgt": "l, r := &maxHeap{}, &minHeap{}\nheap.Init(l)\nheap.Init(r)\nreturn MedianFinder{l, r}", "gen": "maxHeap := &maxHeap{}\nminHeap := &minHeap{}\nreturn &MedianFinder{\n\tmaxHeap: maxHeap,\n\tminHeap: minHeap,\n}\n}"}
{"tgt": "l := len(preorder)\nif l == 0 {\n\treturn nil\n}\nfor 1 < l && preorder[0] < preorder[l-1] {\n\tl--\n}\nreturn &TreeNode{\n\tVal:   preorder[0],\n\tLeft:  bstFromPreorder(preorder[1:l]),\n\tRight: bstFromPreorder(preorder[l:]),\n}", "gen": "if len(preorder) == 0 {\n\treturn nil\n}\nif len(preorder) == 1 {\n\treturn &TreeNode{Val: preorder[0]}\n}\nroot := &TreeNode{Val: preorder[0]}\nleft := bstFromPreorder(preorder[1:len(preorder)-1])\nright := bstFromPreorder(preorder[len(preorder)-1:])\nroot.Left = left\nroot.Right = right\nreturn root\n}"}
{"tgt": "ln, err := net.Listen(\"STR\", \"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"STR\", conn.RemoteAddr())\n\tio.WriteString(conn, fmt.Sprint(time.Now()))\n\tconn.Close()\n}", "gen": "ln, err := net.Listen(\"tcp\", \"localhost:0\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfmt.Println(\"STR\")\ntime.Sleep(time.Second)\nfmt.Println(time.Now())\nln.WriteString(\"STR\")\n}"}
{"tgt": "i, l := 0, len(bits)-1\nfor i < l {\n\ti += bits[i] + 1\n}\nreturn i == l", "gen": "var sum int\nfor i := 0; i < len(nums)-1; i++ {\n\tsum += nums[i] + 1\n}\nreturn sum == len(nums)\n}"}
{"tgt": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\", \"STR\"},\n\t\tans1108{\"STR\", \"STR\"},\n\t},\n}\nfmt.Printf(\"STR\", \"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", \"STR\")\n}\n}"}
{"tgt": "start := 0\nend := len(s) - 1\nfor start < end {\n\ts[start], s[end] = s[end], s[start]\n\tstart++\n\tend--\n}\nreturn s", "gen": "for i := 0; i < len(nums)-1; i++ {\n\tfor j := len(nums) - 1; j > i; j-- {\n\t\tif nums[i] == nums[j] {\n\t\t\tnums = append(nums[:i], nums[i+1:]...)\n\t\t\tj--\n\t\t}\n\t}\n}\nreturn nums\n}"}
{"tgt": "for cur := t.root; cur != nil; {\n\tif cur.Key == key {\n\t\treturn cur\n\t} else if key < cur.Key {\n\t\tcur = cur.left\n\t} else {\n\t\tcur = cur.right\n\t}\n}\nreturn nil", "gen": "if root == nil {\n\treturn nil, nil\n}\nfor root != nil {\n\tif root.value == value {\n\t\treturn root, root\n\t} else if root.value < value {\n\t\troot = root.right\n\t} else {\n\t\troot = root.left\n\t}\n}\nreturn nil, nil\n}"}
{"tgt": "arr := randomSlice(0, 20, 10)\nnodeCnt := 0\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\nrotateNodes := make([]*gbtElement, 0, 0)\ngbt.InOrderWalk(gbt.Root(), func(GBTbinaryTreeIf, node interface{}) bool {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\trotateNodes = append(rotateNodes, node.(*gbtElement))\n\t}\n\treturn false\n})\nfor _, v := range rotateNodes {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\tgbt.LeftRotate(v)\n\t} else {\n\t\tgbt.RightRotate(v)\n\t}\n}\ngbt.InOrderWalk(gbt.Root(), checkGBT(t, &nodeCnt, *debug))\nif nodeCnt != len(arr) {\n\tt.Log(fmt.Sprintf(\"STR\", len(arr), nodeCnt))\n\tt.Fail()\n}", "gen": "slice := randomSlice(10, 20, 0)\ntree := newGBT()\nfor _, v := range slice {\n\ttree.Insert(v)\n}\nfor _, v := range slice {\n\ttree.Rotate(v)\n}\nif !checkGBT(tree, slice) {\n\tt.Log(\"STR\", \"STRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTR"}
{"tgt": "return WordDictionary{}", "gen": "return &Stack{\n\tdata: make([]interface{}, 0, 27),\n}\n}"}
{"tgt": "return xtime.Unix(int64(jt), 0)", "gen": "t := time.Unix(0, t.UnixNano())\nreturn Time{t}\n}"}
{"tgt": "return append(ints, added...)", "gen": "return append(s, s...)\n}"}
{"tgt": "data, err := base64.StdEncoding.DecodeString(b64)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(data)", "gen": "decoded, err := StdEncoding.DecodeString(str)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(decoded)\n}"}
{"tgt": "h := fnv.New64a()\n_, _ = h.Write([]byte(fmt.Sprintf(\"STR\", key)))\nhashValue := h.Sum64()\nreturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))", "gen": "hasher := fnv.New64a()\nhasher.Write([]byte(fmt.Sprintf(\".LC52\", 2)))\nreturn hasher.Sum64() ^ uint64(hasher.Sum64())\n}"}
{"tgt": "return fmt.Sprintf(\"STR\", p.Name, p.Age)", "gen": "return fmt.Sprintf(\"STR\", s.ID)\n}"}
{"tgt": "parent := this\nfor _, ch := range prefix {\n\tif child, ok := parent.Children[ch]; ok {\n\t\tparent = child\n\t\tcontinue\n\t}\n\treturn false\n}\nreturn true", "gen": "s := []byte(str)\nfor _, c := range s {\n\tif c > 127 {\n\t\t_, _ = decoderune(s, i)\n\t\tc = s[i]\n\t}\n\tif _, ok := m[c]; ok {\n\t\treturn false\n\t}\n\tm[c] = 0\n}\nreturn true\n}"}
{"tgt": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)", "gen": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)\n}"}
{"tgt": "close(p.work)\np.wg.Wait()", "gen": "close(c)\nwg.Wait()\n}"}
{"tgt": "m := make(map[int]struct{})\nfor _, num := range nums1 {\n\tm[num] = struct{}{}\n}\nnums := make([]int, 0)\nfor _, num := range nums2 {\n\tif _, ok := m[num]; ok {\n\t\tnums = append(nums, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn nums", "gen": "m := make(map[int]struct{})\nfor _, num := range nums {\n\tm[num] = struct{}{}\n}\nres := make([]int, 0)\nfor _, num := range nums {\n\tif _, ok := m[num]; !ok {\n\t\tres = append(res, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn res\n}"}
{"tgt": "return h.FromHexString(string(b))", "gen": "return Hash{}.FromHexString(string(b))\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif denoms := EgyptianFractions(tc.numerator, tc.denominator); !reflect.DeepEqual(tc.denominators, denoms) {\n\t\tt.Errorf(\"STR\", tc.denominators, denoms)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := EgyptianFractions(tc.n); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "log.SetFlags(0)\nvar err error\ntpl := template.New(\"STR\")\ntpl = tpl.Funcs(template.FuncMap{\n\t\"STR\": func(str string) string {\n\t\treturn strings.ToUpper(str)\n\t},\n})\ntpl, err = tpl.ParseFiles(\"STR\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nerr = tpl.ExecuteTemplate(os.Stdout, \"STR\", Page{\n\tTitle: \"STR\",\n\tBody:  \"STR\",\n})\nif err != nil {\n\tlog.Fatalln(err)\n}", "gen": "log.SetFlags(log.Lshortfile)\nt := template.New(\"\").Funcs(map[string]interface{}{\n\t\"STR\": STR,\n})\nt, err = t.ParseFiles(\"template.html\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nerr = t.ExecuteTemplate(os.Stdout, \"template.html\", Page{STR: \"STR\"})\nif err != nil {\n\tlog.Fatalln(err)\n}\n}"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA `structs:\"STR\"`\n\tC  int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif ok {\n\tt.Error(\"STR\")\n}", "gen": "t.Error(\"STR\")\nif HasZero(STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR"}
{"tgt": "digits := convert(N + 1)\nbits := len(digits)\nnoRepeat := 0\nfor b := 1; b < bits; b++ {\n\tnoRepeat += 9 * count(9, b-1)\n}\nhasSeen := make(map[int]bool, 10)\nfor b := 0; b < bits; b++ {\n\td := 0\n\tif b == 0 {\n\t\td = 1\n\t}\n\tfor ; d < digits[b]; d++ {\n\t\tif !hasSeen[d] {\n\t\t\tnoRepeat += count(9-b, bits-b-1)\n\t\t}\n\t}\n\tif hasSeen[digits[b]] {\n\t\tbreak\n\t}\n\thasSeen[digits[b]] = true\n}\nreturn N - noRepeat", "gen": "res := convert(1 + n)\ncount := 0\nfor i := 1; i <= n; i++ {\n\tcount += count(i, 9)\n\tfor j := 1; j < i; j++ {\n\t\tif res[i] != res[j] {\n\t\t\tcount += count(i-j, 9)\n\t\t}\n\t}\n}\nm := make(map[int]bool)\nfor i := 0; i < n; i++ {\n\tif m[res[i]] {\n\t\tcontinue\n\t}\n\tm[res[i]] = true\n\tfor j := 1; j < i; j++ {\n\t\tif res[i] != res[j] {\n\t\t\tcount += count(i-j, 9)\n\t\t}\n\t}\n}\nreturn n - count\n}"}
{"tgt": "return me[0] == \"STR\"", "gen": "return len(s) == 1 && s[0] == 'a'\n}"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil {\n\t\t\tmax = max.Right\n\t\t}\n\t\tmax.Right = root\n\t\troot, root.Left = root.Left, nil\n\t}\n}\nreturn res", "gen": "var res []*TreeNode\ncur := root\nfor cur != nil {\n\tif cur.Left == nil {\n\t\tres = append(res, cur)\n\t\tcur = cur.Right\n\t} else {\n\t\tcur = cur.Left\n\t}\n}\nfor cur = root; cur != nil; cur = cur.Right {\n\tcur.Left = nil\n\tcur.Right = root\n}\nreturn res\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   0x5555,\n\t\twant: 8,\n\t},\n}\nfor _, tt := range tests {\n\tgot := hammingWeight(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "for _, num := range []int{3, 2, 7, 3, 8, 1, 21845, 8, 2} {\n\tif got := hammingWeight(num); got != num {\n\t\tt.Fatalf(\"STR\", num, got)\n\t}\n}\n}"}
{"tgt": "if a == nil && b == nil {\n\treturn true\n}\nif len(a) != len(b) {\n\treturn false\n}\nfor i := range a {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "if len(s) == 0 || len(s) == len(t) {\n\treturn false\n}\nif len(s) == len(t) {\n\treturn true\n}\nfor i := 0; i < len(s); i++ {\n\tif s[i] != t[i] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "return xtime.Unix(int64(jt), 0), nil", "gen": "return Time{time.Unix(t, 0)}\n}"}
{"tgt": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 0},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 11},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 19},\n\t\tans1208{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s, p.t, p.maxCost))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\"},\n\t\ttrue,\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\"},\n\t\ttrue,\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\"},\n\t\ttrue,\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans, q.para\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s1, p.s2))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{}\n} else if n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{intervals[0]}\nfor _, cur := range intervals[1:] {\n\tprevious := res[len(res)-1]\n\tif cur.Start <= previous.End {\n\t\tend := previous.End\n\t\tif cur.End > end {\n\t\t\tend = cur.End\n\t\t}\n\t\tres = append(res[:len(res)-1], Interval{Start: previous.Start, End: end})\n\t} else {\n\t\tres = append(res, cur)\n\t}\n}\nreturn res", "gen": "if len(intervals) == 0 {\n\treturn []Interval{{}}\n}\nif len(intervals) == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{{intervals[0]}}\nfor i := 1; i < len(intervals); i++ {\n\tif res[len(res)-1].End >= intervals[i].Start {\n\t\tres[len(res)-1].End = intervals[i].End\n\t} else {\n\t\tres = append(res, intervals[i])\n\t}\n}\nreturn res\n}"}
{"tgt": "result := make([]int, 0, len(left)+len(right))\nfor len(left) > 0 || len(right) > 0 {\n\tif len(left) == 0 {\n\t\treturn append(result, right...)\n\t}\n\tif len(right) == 0 {\n\t\treturn append(result, left...)\n\t}\n\tif left[0] <= right[0] {\n\t\tresult = append(result, left[0])\n\t\tleft = left[1:]\n\t} else {\n\t\tresult = append(result, right[0])\n\t\tright = right[1:]\n\t}\n}\nreturn result", "gen": "res := make([]int, 0, len(nums))\nfor i := 0; i < len(nums); i++ {\n\tif i == 0 || nums[i] > nums[i-1] {\n\t\tres = append(res, nums[i])\n\t\tif i < len(nums)-1 && nums[i] > nums[i+1] {\n\t\t\treturn res\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "t.Parallel()\nd := NewTimeMap()\nd.Set(1, 1, 0)\nd.Set(1, 2, 2)\nif result := d.Get(1, 1); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 3); result != 2 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 5)\nif result := d.Get(1, 0); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 10); result != 1 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 0)\nd.Set(1, 2, 0)\nif result := d.Get(1, 0); result != 2 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(2, 0); result != nil {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, -1); result != nil {\n\tt.Errorf(\"STR\")\n}", "gen": "t.Parallel()\ntm := NewTimeMap()\ntm.Set(0, 0)\ntm.Set(2, 2)\nif tm.Get(0) != 0 {\n\tt.Errorf(\"STR\", 0, 0, tm.Get(0))\n}\nif tm.Get(2) != 2 {\n\tt.Errorf(\"STR\", 2, 2, tm.Get(2))\n}\ntm.Set(1, 1)\nif tm.Get(1) != 1 {\n\tt.Errorf(\"STR\", 1, 1, tm.Get(1))\n}\ntm.Set(3, 3)\nif tm.Get(3) != 3 {\n\tt.Errorf(\"STR\", 3, 3, tm.Get(3))\n}\ntm.Set(5, 5)\nif tm.Get(5) != 5 {\n\tt.Errorf(\"STR\", 5, 5, tm.Get(5))\n}\ntm.Set(10, 10)\nif tm.Get(10) != 10 {\n\tt.Errorf(\"STR\", 10, 10, tm.Get(10))\n}\ntm.Set(0, 1)\nif tm.Get(0) != 1 {\n\tt.Errorf(\"STR\", 0, 1, tm.Get(0))\n}\ntm.Set(10, 2)\nif tm.Get(10) != 2 {\n\tt.Errorf(\"STR\", 10, 2, tm.Get(10))\n}\ntm.Set(0, 2)\nif tm.Get(0) != 2 {\n\tt.Errorf(\"STR\", 0, 2, tm.Get(0))\n}\ntm.Set(10, 1)\nif tm.Get(10) != 1 {\n\tt.Errorf(\""}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{2},\n\t\t\t{3, 4},\n\t\t\t{6, 5, 7},\n\t\t\t{4, 1, 8, 3},\n\t\t},\n\t\t11},\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{1},\n\t\t\t{2, 3},\n\t\t},\n\t\t3},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := minimumTotal(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "var s = Solution{\n\tname: \"STR\",\n\tinputs: [][]int{\n\t\t{2, 3, 4},\n\t\t{1, 2, 3, 4},\n\t\t{6, 5, 7},\n\t},\n\texpect: 11,\n}\nfor i, c := range []struct {\n\ttestName string\n\tinputs   [][]int\n\texpect   int\n}{\n\t{\"STR\", s.inputs, s.expect},\n\t{\"STR\", s.inputs, s.expect},\n} {\n\tt.Run(c.testName, func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Errorf(\"STR\", c.expect, got)\n\t\t}\n\t})\n}\n}"}
{"tgt": "pairs := [...][2]int{{15, 26}, {1000, 1366}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p16(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "for _, v := range []int{15, 26, 1000, 1366} {\n\tif p16(v) != v {\n\t\tt.Errorf(\"STR\", v)\n\t}\n}\n}"}
{"tgt": "m := [26]int{}\nfor _, b := range B {\n\tcount := counter(b)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tm[i] = count[i]\n\t\t}\n\t}\n}\nres := []string{}\nfor _, a := range A {\n\tcount := counter(a)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tcontinueL\n\t\t}\n\t}\n\tres = append(res, a)\n}\nreturn res", "gen": "var res []string\nfor _, s := range strs {\n\tres = counter(s, res)\n}\nreturn res\n}"}
{"tgt": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\ntmp := nums[0]\nmax := tmp\nfor i := 1; i < n; i++ {\n\tif tmp < 0 {\n\t\ttmp = nums[i]\n\t} else {\n\t\ttmp += nums[i]\n\t}\n\tif max < tmp {\n\t\tmax = tmp\n\t}\n}\nreturn max", "gen": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\nres := nums[0]\nmax := nums[0]\nfor i := 1; i < n; i++ {\n\tif i < n-1 && nums[i] < nums[i+1] {\n\t\tres += nums[i]\n\t} else {\n\t\tres += nums[i]\n\t\tmax = nums[i]\n\t}\n}\nreturn res\n}"}
{"tgt": "hash := uint32(0)\nfor i := len(sep) - 1; i >= 0; i-- {\n\thash = hash*PrimeRK + uint32(sep[i])\n}\nvar pow, sq uint32 = 1, PrimeRK\nfor i := len(sep); i > 0; i >>= 1 {\n\tif i&1 != 0 {\n\t\tpow *= sq\n\t}\n\tsq *= sq\n}\nreturn hash, pow", "gen": "sum := 0\nfor i := len(nums) - 1; i >= 0; i-- {\n\tsum = (sum * 16777619) + uint32(nums[i])\n}\nres := 1\nfor i := len(nums) * 32; i > 0; i >>= 1 {\n\tif i&1 == 1 {\n\t\tres *= 16777619\n\t}\n\tres *= res\n}\nreturn uint64(sum) * res\n}"}
{"tgt": "b, _ := ioutil.ReadFile(\"STR\")\ns := strings.Replace(string(b), \"STR\", \"STR\", -1)\nnumData := strings.Split(s, \"STR\")\nfor _, n := range numData {\n\tnumber, err := strconv.Atoi(n)\n\tif err == nil {\n\t\tdata = append(data, number)\n\t}\n}", "gen": "data, err := ioutil.ReadFile(\"STR\")\nSTR = strings.Replace(STR, \"STR\", \"STR\", -1)\nSTR = strings.Split(STR, \"STR\")\nfor _, v := range STR {\n\tSTR, err = STR, STR.Atoi()\n\tSTR = STR\n}\nSTR = STR\n}"}
{"tgt": "if len(A) == len(A[0]) {\n\tfor i := 0; i < len(A); i++ {\n\t\tfor j := 0; j < len(A); j++ {\n\t\t\tif i == j {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]\n\t\t}\n\t}\n\treturn A\n}\nres := make([][]int, len(A[0]))\nfor i := 0; i < len(res); i++ {\n\tres[i] = make([]int, len(A))\n\tfor j := 0; j < len(A); j++ {\n\t\tres[i][j] = A[j][i]\n\t}\n}\nreturn res", "gen": "if len(matrix) == 0 {\n\treturn [][]int{}\n}\nif len(matrix[0]) == len(matrix) {\n\treturn matrix\n}\nres := make([][]int, len(matrix[0]))\nfor i := 0; i < len(matrix[0]); i++ {\n\tfor j := 0; j < len(matrix); j++ {\n\t\tres[i] = append(res[i], matrix[j][i])\n\t}\n}\nreturn res\n}"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := SumRevLLNum(tc.first, tc.second); !equal(result, tc.sum) {\n\t\tt.Errorf(\"STR\",\n\t\t\ttcid, String(result), String(tc.sum))\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := SumRevLLNum(tc.num); !equal(res, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.num, res, tc.expected)\n\t}\n}\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tm: 3,\n\t\tn: 3,\n\t\tops: [][]int{\n\t\t\t{2, 2},\n\t\t\t{3, 3},\n\t\t},\n\t\twant: 4,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxCount(tt.m, tt.n, tt.ops)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.m, got, tt.want)\n\t}\n}", "gen": "qs := []question598{\n\t{\n\t\tpara1: []int{2, 2, 3, 3},\n\t\tpara2: 2,\n\t\tans:   2,\n\t},\n\t{\n\t\tpara1: []int{2, 2, 3, 3},\n\t\tpara2: 3,\n\t\tans:   3,\n\t},\n\t{\n\t\tpara1: []int{2, 2, 3, 3},\n\t\tpara2: 4,\n\t\tans:   2,\n\t},\n}\nfmt.Printf(\"STR\" + strconv.Itoa(i))\nfor _, q := range qs {\n\tvar ret int\n\tret = maxCount(q.para1, q.para2)\n\tif ret != q.ans {\n\t\tt.Fatalf(\"STR\", q.para1, q.para2, q.ans, ret)\n\t}\n}\n}"}
{"tgt": "n := len(quality)\nworkers := make([][2]float64, n)\nfor i := 0; i < n; i++ {\n\tw, q := float64(wage[i]), float64(quality[i])\n\tworkers[i][0], workers[i][1] = w/q, q\n}\nsort.Slice(workers, func(i, j int) bool {\n\treturn workers[i][0] < workers[j][0]\n})\nres := math.MaxFloat64\nsum := 0.\nh := floatHeap{}\nfor _, w := range workers {\n\tsum += w[1]\n\theap.Push(&h, w[1])\n\tif len(h) > K {\n\t\tsum -= heap.Pop(&h).(float64)\n\t}\n\tif len(h) == K {\n\t\tres = min(res, sum*w[0])\n\t}\n}\nreturn res", "gen": "n := len(cost)\ndp := make([]float64, n)\nfor i := 0; i < n; i++ {\n\tdp[i] = float64(cost[i]) / float64(cost[n-1])\n}\nsort.Slice(dp, func(i, j int) bool {\n\treturn dp[i] < dp[j]\n})\nmin := math.Inf(1)\nh := &floatHeap{\n\tdata: dp,\n}\nheap.Init(h)\nfor i := 0; i < n; i++ {\n\tif i < h.Len() && h.Len() < k {\n\t\theap.Pop(h)\n\t}\n\tif i < h.Len() {\n\t\tmin = min(min, float64(h.Len())*dp[h.Len()])\n\t}\n\theap.Push(h, dp[i])\n}\nreturn min\n}"}
{"tgt": "flag.Parse()\nroots := flag.Args()\nif len(roots) == 0 {\n\troots = []string{\"STR\"}\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, root := range roots {\n\t\twalkDir(root, fileSizes)\n\t}\n\tclose(fileSizes)\n}()\nvar nfiles, nbytes int64\nfor size := range fileSizes {\n\tnfiles++\n\tnbytes += size\n}\nprintDiskUsage(nfiles, nbytes)", "gen": "flag.Parse()\nargs := flag.Args()\nif len(args) == 0 {\n\targs = []string{\"./\"}\n}\nch := make(chan int64)\ngo main.roots(args, ch)\nvar total int64\nfor {\n\tsize, ok := <-ch\n\tif !ok {\n\t\tbreak\n\t}\n\ttotal += size\n}\nprintDiskUsage(total, len(args))\n}"}
{"tgt": "var min int\ntotalPeople := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\ttotalPeople++\n\t}\n}\nif totalPeople < 2 {\n\treturn 0\n}\nmiddle := (totalPeople / 2) + (totalPeople % 2)\nindex := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\tmiddle--\n\t}\n\tif middle == 0 {\n\t\tindex = i\n\t\tbreak\n\t}\n}\nleftZero := 0\nleftZeroFound := false\nfor j := index - 1; j >= 0; j-- {\n\tif !leftZeroFound && seating[j] == 0 {\n\t\tleftZero = j\n\t\tleftZeroFound = true\n\t} else if seating[j] == 1 && j < leftZero {\n\t\tmin += abs(j - leftZero)\n\t\tleftZero--\n\t}\n}\nrightZero := 0\nrightZeroFound := false\nfor j := index + 1; j < len(seating); j++ {\n\tif !rightZeroFound && seating[j] == 0 {\n\t\trightZero = j\n\t\trightZeroFound = true\n\t} else if seating[j] == 1 && j > rightZero {\n\t\tmin += abs(j - rightZero)\n\t\trightZero++\n\t}\n}\nreturn min", "gen": "var sum, count int\nfor _, n := range nums {\n\tif n == 1 {\n\t\tcount++\n\t}\n}\nvar i, j int\nfor i = 0; i < count; i++ {\n\tfor j = 0; j < len(nums); j++ {\n\t\tif nums[j] == 1 {\n\t\t\tsum++\n\t\t}\n\t}\n\tfor j = 0; j < len(nums); j++ {\n\t\tif nums[j] == 1 {\n\t\t\tsum--\n\t\t}\n\t}\n}\nfor i = 0; i < len(nums); i++ {\n\tif nums[i] == 1 {\n\t\tsum++\n\t}\n}\nreturn sum\n}"}
{"tgt": "sum := 0\nprev := 1\ncurr := 1\nfor curr <= 4e6 {\n\tprev, curr = curr, prev+curr\n\tif curr%2 == 0 {\n\t\tsum += curr\n\t}\n}\nfmt.Println(sum)", "gen": "sum := 0\nfor i := 1; i <= 4000000; i++ {\n\tif i%2 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "stack := make([]int, 0)\nresult := make([]int, len(T))\nfor i, t := range T {\n\tfor len(stack) > 0 && T[stack[len(stack)-1]] < t {\n\t\tresult[stack[len(stack)-1]] = i - stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t}\n\tstack = append(stack, i)\n}\nfor _, i := range stack {\n\tresult[i] = 0\n}\nreturn result", "gen": "res := make([]int, 0)\nfor _, num := range nums {\n\tif len(res) == 0 || res[len(res)-1] < num {\n\t\tres = append(res, num)\n\t} else {\n\t\tres[len(res)-1] = num\n\t}\n}\nfor i := 0; i < len(res); i++ {\n\tres[i] = 0\n\tfor j := 0; j < len(res); j++ {\n\t\tif res[i] < res[j] {\n\t\t\tres[i] = res[j]\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 2}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 4}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 4}}},\n\t\tans1037{false},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}, {4, 4}}},\n\t\tans1037{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, p.points, p.points[0], p.points[1], p.points[2], isBoomerang(p.points))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "out := 100\nif x := p33(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "if p33(100) != 100 {\n\tt.Errorf(\"STR\", 100, 100)\n}\n}"}
