{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif sum := SumBSTRange(tc.root, tc.a, tc.b); sum != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, sum)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\troot := kit.Ints2Tree(tc.preorder, tc.inorder)\n\tgot := SumBSTRange(root, tc.low, tc.high)\n\tif got != tc.want {\n\t\tt.Errorf(\"case %v: got %v, want %v\", tc, got, tc.want)\n\t}\n}\n}"}
{"tgt": "return &linkLoop{\n\tHead: &linkLoopNode{},\n}", "gen": "return &linkLoop{\n\tloop: &linkLoopNode{\n\t\tval:  val,\n\t\tnext: nil,\n\t},\n}\n}"}
{"tgt": "return bindataRead(\n\t_assetsHomeCatJpg,\n\t\"STR\",\n)", "gen": "return &assetsHomeCatJpg\n}"}
{"tgt": "max := 1000\nsum := 0\nfor i := 1; i < max; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)", "gen": "n := 1000\nvar sum int\nfor i := 1; i <= n; i++ {\n\tif i%3 == 0 || i%5 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.locs); !reflect.DeepEqual(bonuses, tc.bonuses) {\n\t\tt.Errorf(\"STR\", tc.bonuses, bonuses)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif actual := Bonuses(tc.input); !reflect.DeepEqual(actual, tc.expected) {\n\t\tt.Errorf(\"Bonuses(%v) = %v, want %v\", tc.input, actual, tc.expected)\n\t}\n}\n}"}
{"tgt": "max := 9999\nbiggestPandigital := 0\nvar numberMultiplied int\nfor i := max; i > 0; i-- {\n\tnumberMultiplied = i\n\tfor j := 1; len(digits(numberMultiplied)) <= 9; j++ {\n\t\tnumberMultiplied = concatenMultiplication(i, j)\n\t\tif IsPandigital(numberMultiplied) && numberMultiplied > biggestPandigital {\n\t\t\tfmt.Println(numberMultiplied)\n\t\t\tbiggestPandigital = numberMultiplied\n\t\t}\n\t}\n}", "gen": "for i := 9999; i > 0; i-- {\n\tif concatenMultiplication(i, i) == IsPandigital(i) {\n\t\tfmt.Println(i)\n\t\treturn\n\t}\n}\n}"}
{"tgt": "for {\n\tswitch r := l.next(); {\n\tcase unicode.IsNumber(r):\n\tcase r == \"STR\":\n\t\tl.backup()\n\t\tl.emit(itemEnd)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase r == eof:\n\t\tl.emit(itemEnd)\n\t\treturn byteRangeSet\n\tdefault:\n\t\treturn l.error(\"STR\")\n\t}\n}", "gen": "for {\n\ttok := l.next()\n\tif tok == 0 {\n\t\tbreak\n\t}\n\tif unicode.IsNumber(rune(tok)) {\n\t\tl.backup()\n\t\tl.emit(4)\n\t\tl.chomp()\n\t} else if tok == 44 {\n\t\tl.emit(4)\n\t\tl.chomp()\n\t} else {\n\t\tl.error(fmt.Sprintf(\"expected number or comma, got %q\", tok))\n\t}\n}\nreturn byteRangeSet\n}"}
{"tgt": "return func(treebinaryTreeIf, node interface{}) bool {\n\tn := node.(*gbtElement)\n\tif !tree.IsNil(n.Left) && n.Left.Key >= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Left, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif !tree.IsNil(n.Right) && n.Right.Key <= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Right, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif debug {\n\t\tfmt.Println(n)\n\t}\n\t*nodeCnt++\n\treturn false\n}", "gen": "t1 := New(10)\nt1.Insert(10)\nt1.Insert(11)\nt1.Insert(12)\nt1.Insert(13)\nt1.Insert(14)\nt1.Insert(15)\nt1.Insert(16)\nt1.Insert(17)\nt1.Insert(18)\nt1.Insert(19)\nt1.Insert(20)\nt1.Insert(21)\nt1.Insert(22)\nt1.Insert(23)\nt1.Insert(24)\nt1.Insert(25)\nt1.Insert(26)\nt1.Insert(27)\nt1.Insert(28)\nt1.Insert(29)\nt1.Insert(30)\nt1.Insert(31)\nt1.Insert(32)\nt1.Insert(33)\nt1.Insert(34)\nt1.Insert(35)\nt1.Insert(36)\nt1.Insert(37)\nt1.Insert(38)\nt1.Insert(39)\nt1.Insert(40)\nt1.Insert(41)\nt1.Insert(42)\nt1.Insert(43)\nt1.Insert(44)\nt1.Insert(45)\nt1.Insert(46)\nt1.Insert(47)\nt1.Insert(48)\nt1.Insert(49)\nt1.Insert(50)\nt1.Insert(51)\nt1.Insert(52)\nt1.Insert(53)\nt1.Insert(54)\nt1.Insert(55)\nt1.Insert(56)\nt1.Insert(57)\nt1.Insert(58)\n"}
{"tgt": "iterator := func() <-chan VertexId {\n\tch := make(chan VertexId)\n\tgo func() {\n\t\tif connected, ok := g.edges[vertex]; ok {\n\t\t\tfor VertexId, _ := range connected {\n\t\t\t\tif g.IsEdge(vertex, VertexId) {\n\t\t\t\t\tch <- VertexId\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\nreturn VerticesIterable(&vertexIterableHelper{iterFunc: iterator})", "gen": "g := &graph.Graph{\n\tVertices: []VertexId{v},\n}\nreturn &graph.vertexIterableHelper{\n\tg,\n}\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 2, 1}, []int{0, 4, 1, 3, 2}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1}, []int{0}, []int{1}},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums, c.index)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums, c.index)\n\t\t}\n\t})\n}", "gen": "t := &testing.T{}\nfor i := 0; i < 5; i++ {\n\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\ts := Solution{\n\t\t\tname:    \"c1\",\n\t\t\tnums:    []int{0, 1, 2, 3, 4},\n\t\t\tindex:   []int{0, 1, 2, 3, 4},\n\t\t\texpect:  []int{1, 2, 3, 4, 0},\n\t\t}\n\t\trotate(s.nums, s.index, s.expect)\n\t\tfor i := 0; i < len(s.nums); i++ {\n\t\t\tif s.nums[i] != s.expect[i] {\n\t\t\t\tt.Errorf(\"got %v, want %v\", s.nums, s.expect)\n\t\t\t}\n\t\t}\n\t})\n}\nfor i := 0; i < 5; i++ {\n\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\ts := Solution{\n\t\t\tname:    \"c2\",\n\t\t\tnums:    []int{0, 1, 2, 3, 4},\n\t\t\tindex:   []int{0, 1, 2, 3, 4},\n\t\t\texpect:  []int{1, 2, 3, 4, 0},\n\t\t}\n\t\trotate(s.nums, s.index, s.expect)\n\t\tfor i := 0; i < len(s.nums); i++ {\n\t\t\tif s.nums[i] != s.expect[i] {\n\t\t\t\tt.Errorf(\"got %v, want %v\", s.nums, s.expect)\n\t\t\t}\n\t\t"}
{"tgt": "c.bw.WriteString(\"STR\")\nc.bw.WriteByte(space)\nc.bw.WriteString(key)\nc.bw.WriteByte(space)\nc.bw.Write(strconv.AppendInt(c.numScratch[:0], int64(timeout), 10))\n_, err = c.bw.Write(crlf)\nreturn", "gen": "buf.WriteString(space)\nbuf.WriteByte(space)\nbuf.WriteString(key)\nbuf.WriteByte(space)\nbuf.WriteString(value)\nbuf.Write(crlf)\n}"}
{"tgt": "for V > 0 {\n\tV--\n\tif !isDroppedLeft(heights, K) && !isDroppedRight(heights, K) {\n\t\theights[K]++\n\t}\n}\nreturn heights", "gen": "for i := len(heights) - 1; i >= 0; i-- {\n\tif isDroppedLeft(heights, i) {\n\t\tif isDroppedRight(heights, i) {\n\t\t\theights[i] = 1\n\t\t}\n\t}\n}\nreturn heights\n}"}
{"tgt": "h := &IntMaxHeap{}\nheap.Init(h)\nheap.Push(h, 7)\nheap.Push(h, 3)\nheap.Push(h, 2)\nheap.Push(h, 1)\nheap.Push(h, 5)\nheap.Push(h, 5)\nheap.Push(h, 6)\nheap.Push(h, 7)\nfmt.Printf(\"STR\", (*h))\nfor h.Len() > 0 {\n\tfmt.Printf(\"STR\", heap.Pop(h))\n}", "gen": "h := &IntMaxHeap{}\nh.Init(func"}
{"tgt": "sLen, pLen := len(s), len(p)\ndp := make([][]bool, sLen+1)\nfor i := range dp {\n\tdp[i] = make([]bool, pLen+1)\n}\ndp[sLen][pLen] = true\nfor i := sLen; i > -1; i-- {\n\tfor j := pLen - 1; j > -1; j-- {\n\t\tfirstMatch := i < sLen && (p[j] == s[i] || p[j] == '.')\n\t\tif j+1 < pLen && p[j+1] == '*' {\n\t\t\tdp[i][j] = dp[i][j+2] || firstMatch && dp[i+1][j]\n\t\t} else {\n\t\t\tdp[i][j] = firstMatch && dp[i+1][j+1]\n\t\t}\n\t}\n}\nreturn dp[0][0]", "gen": "var res []bool\nfor i := 0; i < len(s); i++ {\n\tres = append(res, false)\n}\nfor i := 0; i < len(s); i++ {\n\tfor j := 0; j < len(s); j++ {\n\t\tif s[i] == s[j] && !res[j] {\n\t\t\tres[j] = true\n\t\t\tfor k := 0; k < len(s); k++ {\n\t\t\t\tif s[i] == s[k] && !res[k] {\n\t\t\t\t\tres[k] = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nfor i := 0; i < len(s); i++ {\n\tif s[i] == '(' {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "l1 := len(board)\nif l1 == 0 {\n\treturn\n}\nl2 := len(board[0])\nif l2 == 0 {\n\treturn\n}\nvisit := make([][]bool, l1)\nfor i := 0; i < l1; i++ {\n\tvisit[i] = make([]bool, l2)\n}\nfor i := 0; i < l1; i++ {\n\tfor j := 0; j < l2; j++ {\n\t\tif !visit[i][j] {\n\t\t\thelper(board, visit, i, j)\n\t\t}\n\t}\n}", "gen": "if len(nums) == 0 {\n\treturn 0\n}\nif len(nums) == 1 {\n\treturn 0\n}\nif len(nums) == 2 {\n\treturn 0\n}\nvar res int\nfor i := 0; i < len(nums); i++ {\n\tfor j := 0; j < len(nums); j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tif nums[i] == nums[j] {\n\t\t\tres++\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.nums); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif actual := SmallerRightCount(tc.left, tc.right); actual != tc.expected {\n\t\tt.Errorf(\"STR\", tc.left, tc.right, tc.expected, actual)\n\t}\n}\n}"}
{"tgt": "sum := 100 * 101 / 2\nsqSum := sum * sum\nsumSq := 0\nfor i := 1; i <= 100; i++ {\n\tsumSq += i * i\n}\nfmt.Println(sqSum - sumSq)", "gen": "sum := 0\nfor i := 1; i <= 100; i++ {\n\tsum += i * i\n}\nfmt.Println(sum)\n}"}
{"tgt": "return x != y", "gen": "if a == b {\n\treturn true\n}\nreturn false\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif actual := MinimizeQux(tc.qux); !reflect.DeepEqual(actual, tc.expected) {\n\t\tt.Errorf(\"MinimizeQux(%v) = %v; expected %v\", tc.qux, actual, tc.expected)\n\t}\n}\n}"}
{"tgt": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 1, 3}},\n\t\tans1051{3},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 2, 3, 4}},\n\t\tans1051{5},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{0},\n\t},\n\t{\n\t\tpara1051{[]int{5, 4, 3, 2, 1}},\n\t\tans1051{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"[%d, %d, %d]\", 1, 1, 4)\nfmt.Printf(\"[%d, %d, %d]\", 2, 1, 3)\nfmt.Printf(\"[%d, %d, %d]\", 4, 1, 5)\nfmt.Printf(\"[%d, %d, %d]\", 5, 1, 2)\nfmt.Printf(\"[%d, %d, %d]\", 3, 1, 5)\nfmt.Printf(\"[%d, %d, %d]\", 5, 1, 4)\nfmt.Printf(\"[%d, %d, %d]\", 5, 1, 5)\nfmt.Printf(\"[%d, %d, %d]\", 5, 1, 5)\nfmt.Printf(\"[%d, %d, %d]\", 5, 1, 5)\nfmt.Printf(\"[%d, %d, %d]\", 5, 1, 5)\nfmt.Printf(\"[%d, %d, %d]\", 5, 1, 5)\nfmt.Printf(\"[%d, %d, %d]\", 5, 1, 5)\nfmt.Printf(\"[%d, %d, %d]\", 5, 1, 5)\nfmt.Printf(\"[%d, %d, %d]\", 5, 1, 5)\nfmt.Printf(\"[%d, %d, %d]\", 5, 1, 5)\nfmt.Printf(\"[%d, %d, %d]\", 5, 1, 5)\nfmt.Printf(\"[%d, %d, %d]\", 5, 1, 5)\nfmt.Printf(\"[%d, %d, %d]\", 5, 1, 5)\nfmt.Printf(\"[%d, %d, %"}
{"tgt": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"STR\", got, tt.want)\n\t\t}\n\t})\n}", "gen": "tests := []struct {\n\tname string\n\targs args\n\twant int\n}{\n\t{\n\t\tname: \"case1\",\n\t\targs: args{\n\t\t\tA: [][]int{\n\t\t\t\t{1, 2, 3},\n\t\t\t\t{1, 2, 3},\n\t\t\t\t{1, 2, 3},\n\t\t\t},\n\t\t\tB: [][]int{\n\t\t\t\t{1, 2, 3},\n\t\t\t\t{1, 2, 3},\n\t\t\t\t{1, 2, 3},\n\t\t\t},\n\t\t},\n\t\twant: 9,\n\t},\n}\nfor _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tgot := largestOverlap(tt.args.A, tt.args.B)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"largestOverlap() = %v, want %v\", got, tt.want)\n\t\t}\n\t})\n}\n}"}
{"tgt": "if m == 0 {\n\treturn 1\n}\nswitch n {\ncase 1:\n\treturn 2\ncase 2:\n\tif m == 1 {\n\t\treturn 3\n\t}\n\treturn 4\ndefault:\n\tswitch m {\n\tcase 1:\n\t\treturn 4\n\tcase 2:\n\t\treturn 7\n\tdefault:\n\t\treturn 8\n\t}\n}", "gen": "if n == 0 {\n\treturn 1\n}\nif n == 1 {\n\treturn 2\n}\nif n == 2 {\n\treturn 3\n}\nif n == 3 {\n\treturn 4\n}\nif n == 4 {\n\treturn 7\n}\nif n == 5 {\n\treturn 8\n}\nreturn 0\n}"}
{"tgt": "sort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].End < intervals[j].End\n})\ncount := 0\ncurrent := -int(^uint(0)>>1) - 1\nfor _, interval := range intervals {\n\tif interval.Start >= current {\n\t\tcount++\n\t\tcurrent = interval.End\n\t}\n}\nreturn len(intervals) - count", "gen": "intervals := []Interval{{1, 2}, {2, 3}, {3, 4}, {1, 3}}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nvar max int64\nfor i := 0; i < len(intervals); i++ {\n\tif intervals[i].Start > max {\n\t\tmax = intervals[i].Start\n\t}\n}\nreturn max\n}"}
{"tgt": "switch rand.Intn(10) {\ncase 1, 9:\n\treturn io.EOF\ncase 5:\n\treturn errors.New(\"STR\")\ndefault:\n\td.Line = \"STR\"\n\tfmt.Println(\"STR\", d.Line)\n\treturn nil\n}", "gen": "rand.Seed(time.Now().UnixNano())\nn := rand.Intn(10)\nif n == 0 {\n\treturn io.EOF\n}\nif n == 9 {\n\treturn io.EOF\n}\nif n == 1 {\n\treturn io.EOF\n}\nif n == 5 {\n\treturn io.EOF\n}\nreturn nil\n}"}
{"tgt": "fmt.Println(subarrayBitwiseORs([]int{0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))", "gen": "fmt.Println(subarrayBitwiseORs([]int{1, 1, 1}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 1, 1}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 1, 1, 1}))\n}"}
{"tgt": "dummy := &ListNode{0, head}\nslow, fast := dummy, dummy\nfor fast.Next != nil && fast.Next.Next != nil {\n\tfast = fast.Next.Next\n\tslow = slow.Next\n}\nreturn slow.Next", "gen": "for head != nil && head.Next != nil {\n\thead = head.Next.Next\n}\nreturn head.Val\n}"}
{"tgt": "pairs := [...][2]int{{10, 7}, {1000, 983}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p26(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "for i := 0; i < 2; i++ {\n\tif p26(i) != i {\n\t\tt.Errorf(\"p26(%d) = %d, want %d\", i, p26(i), i)\n\t}\n}\nfor i := 10; i < 1000; i++ {\n\tif p26(i) != i {\n\t\tt.Errorf(\"p26(%d) = %d, want %d\", i, p26(i), i)\n\t}\n}\nfor i := 983; i < 1000; i++ {\n\tif p26(i) != i {\n\t\tt.Errorf(\"p26(%d) = %d, want %d\", i, p26(i), i)\n\t}\n}\n}"}
{"tgt": "n := len(A)\nfor i := n - 2; i >= 0; i-- {\n\tA[i] += A[i+1]\n}\nmem := [101][33]int{}\nvar dp func(int, int) int\ndp = func(i, m int) int {\n\tif i+2*m >= n {\n\t\treturn A[i]\n\t}\n\tif mem[i][m] > 0 {\n\t\treturn mem[i][m]\n\t}\n\tres := 0\n\tfor x := 1; x <= 2*m; x++ {\n\t\tres = max(\n\t\t\tres,\n\t\t\tA[i]-dp(i+x, max(m, x)),\n\t\t)\n\t}\n\tmem[i][m] = res\n\treturn res\n}\nreturn dp(0, 1)", "gen": "n := len(stones)\ndp := make([][]int, n+1)\nfor i := 0; i <= n; i++ {\n\tdp[i] = make([]int, 2)\n}\ndp[0][0] = 0\ndp[0][1] = 0\nfor i := 1; i <= n; i++ {\n\tdp[i][0] = dp[i-1][1] + stones[i-1]\n\tdp[i][1] = dp[i-1][0] - stones[i-1]\n}\nreturn dp[n][0]\n}"}
{"tgt": "if n == 0 {\n\treturn 0\n}\nreturn n/5 + trailingZeroes(n/5)", "gen": "if n == 0 {\n\treturn 0\n}\nreturn trailingZeroes(n) + n/5\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0}, 5},\n\t{\"STR\", []int{0, 0, 0, 0, 1}, []int{1, 0, 0, 0, 0}, 4},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums1, c.nums2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums1, c.nums2)\n\t\t}\n\t})\n}", "gen": "testCases := []struct {\n\tname         string\n\tnums1        []int\n\tnums2        []int\n\texpect       int\n}{\n\t{\n\t\tname:         \"test1\",\n\t\tnums1:        []int{1, 2, 3},\n\t\tnums2:        []int{2, 1},\n\t\texpect:       1,\n\t},\n\t{\n\t\tname:         \"test2\",\n\t\tnums1:        []int{1, 2, 3},\n\t\tnums2:        []int{2, 3},\n\t\texpect:       2,\n\t},\n\t{\n\t\tname:         \"test3\",\n\t\tnums1:        []int{1, 2, 3},\n\t\tnums2:        []int{1, 2},\n\t\texpect:       3,\n\t},\n\t{\n\t\tname:         \"test4\",\n\t\tnums1:        []int{1, 2, 3},\n\t\tnums2:        []int{1, 2, 3},\n\t\texpect:       6,\n\t},\n\t{\n\t\tname:         \"test5\",\n\t\tnums1:        []int{1, 2, 3},\n\t\tnums2:        []int{1, 2, 3, 4, 7},\n\t\texpect:       10,\n\t},\n\t{\n\t\tname:         \"test6\",\n\t\tnums1:        []int{1, 2, 3},\n\t\tnums2:        []int{1, 2, 3, 4, 7, 8},\n\t\texpect:       10,\n\t},\n\t{\n\t\tname:         \"test7\",\n\t\tnums1:        []int{1, 2, 3},\n\t\tnums2:"}
{"tgt": "list.rear = nil", "gen": "runtime.writeBarrier = nil\nruntime.writeBarrier = nil\n}"}
{"tgt": "if len(name) == 0 && len(typed) == 0 {\n\treturn true\n}\nif (len(name) == 0 && len(typed) != 0) || (len(name) != 0 && len(typed) == 0) {\n\treturn false\n}\nj := 0\nfor i := 0; i < len(name); i++ {\n\tif j < len(typed) && name[i] == typed[j] {\n\t\tj++\n\t\tcontinue\n\t} else {\n\t\tif i > 0 && j < len(typed) && name[i-1] == typed[j] {\n\t\t\tj++\n\t\t\ti--\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "if len(a) == 0 || len(b) == 0 {\n\treturn false\n}\nif len(a) != len(b) {\n\treturn false\n}\nif len(a) == len(b) {\n\tfor i := 0; i < len(a); i++ {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\nreturn false\n}"}
{"tgt": "factorial := new(big.Int).MulRange(1, 100)\nbytes := factorial.Append([]byte{}, 10)\nsum := 0\nfor b := range bytes {\n\tsum += int(bytes[b] - '0')\n}\nfmt.Println(\"STR\", sum)", "gen": "var s big.Int\ns.MulRange(100, 100)\nvar res []byte\nfor _, b := range s.Bytes() {\n\tres = append(res, b-48)\n}\nfmt.Println(string(res))\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs int\n\texpect int\n}{\n\t{\"STR\", 2, 1},\n\t{\"STR\", 3, 2},\n\t{\"STR\", 4, 3},\n\t{\"STR\", 0, 0},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "solution := Solution{\n\tname: \"TestSolution\",\n\tc1: func(t *testing.T, s Solution) {\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\ttestSolution(t, s)\n\t\t})\n\t},\n}\nfor i := 0; i < 4; i++ {\n\tsolution.inputs = []int{2, 3}\n\tsolution.expect = 1\n\tsolution.c1(t, solution)\n}\n}"}
{"tgt": "var low, mid, high int = 0, len(sorted) / 2, len(sorted)\nfor low < high {\n\tcurr := sorted[mid]\n\tswitch {\n\tcase curr == target:\n\t\treturn mid\n\tcase inRange(sorted[mid:high], target):\n\t\tlow = mid\n\t\tmid = (low + high) / 2\n\tdefault:\n\t\thigh = mid\n\t\tmid = (low + high) / 2\n\t}\n}\nreturn -1", "gen": "start, end := 0, len(nums)-1\nfor start <= end {\n\tmid := (start + end) / 2\n\tif nums[mid] == target {\n\t\treturn mid\n\t} else if nums[mid] < target {\n\t\tstart = mid + 1\n\t} else {\n\t\tend = mid - 1\n\t}\n}\nreturn -1\n}"}
{"tgt": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nret := &ListNode{}\nif l1.Val <= l2.Val {\n\tret = l1\n\tret.Next = mergeTwoLists1(l1.Next, l2)\n} else {\n\tret = l2\n\tret.Next = mergeTwoLists1(l1, l2.Next)\n}\nreturn ret", "gen": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nif l1.Val < l2.Val {\n\treturn mergeTwoLists1(l1, l2)\n}\nreturn mergeTwoLists1(l2, l1)\n}"}
{"tgt": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Print(sum, \"STR\")", "gen": "var sum int\nfor i := 0; i < 1000; i++ {\n\tif i%3 == 0 || i%5 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "rets := make([][]int, numRows)\nif numRows == 0 {\n\treturn rets\n}\nrets[0] = []int{1}\nfor i := 1; i < numRows; i++ {\n\trets[i] = make([]int, i+1)\n\trets[i][0] = 1\n\trets[i][i] = 1\n\tfor j := 1; j < i; j++ {\n\t\trets[i][j] = rets[i-1][j-1] + rets[i-1][j]\n\t}\n}\nreturn rets", "gen": "res := make([][]int, len(nums))\nfor i := 0; i < len(nums); i++ {\n\tif i == 0 {\n\t\tres[i] = []int{1, nums[i]}\n\t\tcontinue\n\t}\n\tfor j := 0; j < i; j++ {\n\t\tif nums[i] > nums[j] {\n\t\t\tres[i] = append(res[i], res[j][len(res[j])-1]+1)\n\t\t} else {\n\t\t\tres[i] = append(res[i], 1)\n\t\t}\n\t}\n\tres[i] = append(res[i], 1)\n}\nreturn res\n}"}
{"tgt": "start := -1\nlenMax := 0\ndict := [256]int{}\nfor i := range dict {\n\tdict[i] = -1\n}\nfor i, r := range s {\n\tif v := dict[r]; v > start {\n\t\tstart = v\n\t}\n\tlength := i - start\n\tif length > lenMax {\n\t\tlenMax = length\n\t}\n\tdict[r] = i\n}\nreturn lenMax", "gen": "var max int\nfor i := 0; i < 256; i++ {\n\tfor j := 0; j < 256; j++ {\n\t\tif s[i] == s[j] {\n\t\t\tif j > max {\n\t\t\t\tmax = j\n\t\t\t}\n\t\t}\n\t}\n}\nreturn max\n}"}
{"tgt": "nlen := len(nums)\nfor i := 0; i < nlen-2; i++ {\n\tif i != 0 && nums[i] == nums[i-1] {\n\t\tcontinue\n\t}\n\tleft, right := i+1, nlen-1\n\tfor left < right {\n\t\tsum := nums[i] + nums[left] + nums[right]\n\t\tif sum == target {\n\t\t\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tleft++\n\t\t\tright--\n\t\t} else if sum < target {\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tleft++\n\t\t} else {\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tright--\n\t\t}\n\t}\n}", "gen": "for i := 0; i < len(nums); i++ {\n\tfor j := i + 1; j < len(nums); j++ {\n\t\tif nums[i] == nums[j] {\n\t\t\treturn true\n\t\t}\n\t}\n}\nreturn false\n}"}
{"tgt": "return strings.ReplaceAll(r.element.Name, \"STR\", \"\")", "gen": "return strings.ReplaceAll(s, \"&\", \"&amp;\")\n}"}
{"tgt": "var res byte\nfor i := 0; i < len(s); i++ {\n\tres ^= s[i]\n}\nfor i := 0; i < len(t); i++ {\n\tres ^= t[i]\n}\nreturn res", "gen": "var res byte\nfor i := 0; i < len(s1); i++ {\n\tres ^= s1[i]\n}\nfor i := 0; i < len(s2); i++ {\n\tres ^= s2[i]\n}\nreturn res\n}"}
{"tgt": "m := len(A)\nn := len(A[0])\nans := make([][]int, n)\nfor k := range ans {\n\tans[k] = make([]int, m)\n}\nfor r := 0; r < m; r++ {\n\tfor c := 0; c < n; c++ {\n\t\tans[c][r] = A[r][c]\n\t}\n}\nreturn ans", "gen": "res := make([][]int, len(nums))\nfor i := 0; i < len(nums); i++ {\n\tres[i] = make([]int, len(nums))\n\tfor j := 0; j < len(nums); j++ {\n\t\tres[i][j] = nums[i] * nums[j]\n\t}\n}\nreturn res\n}"}
{"tgt": "println(\"STR\", len(a))", "gen": "fmt.Println(\"Hello\", 4)\n}"}
{"tgt": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nc, res := []int{}, [][]int{}\nsort.Ints(candidates)\nfindcombinationSum(candidates, target, 0, c, &res)\nreturn res", "gen": "if len(nums) == 0 {\n\treturn []int{}\n}\nreturn findCombinationSum(nums, target)\n}"}
{"tgt": "for i := 0; i < len(A)-1; i++ {\n\tif A[i] == i {\n\t\tcontinue\n\t}\n\tif A[i] == i+1 && A[i+1] == i {\n\t\ti++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "for i := 0; i < len(nums)-1; i++ {\n\tif nums[i] > nums[i+1] {\n\t\treturn false\n\t}\n\tif nums[i] == nums[i+1] {\n\t\treturn true\n\t}\n}\nreturn true\n}"}
{"tgt": "for n := 0; n < 32; n++ {\n\tsquare[n] = gf2MatrixTimes(mat, mat[n])\n}", "gen": "for i := 0; i < 32; i++ {\n\tmatrix[i] = gf2MatrixTimes(matrix[i], matrix[i])\n\tmatrix[i+32] = gf2MatrixTimes(matrix[i+32], matrix[i])\n}\n}"}
{"tgt": "for i := 0; i < n; i++ {\n\tif len(squares) != i {\n\t\tprintln(\"STR\", len(squares), \"STR\", i)\n\t}\n\tsquares[i] = i * i\n\tfor j := 0; j <= i; j++ {\n\t\tif v, ok := squares[j]; !ok || v != j*j {\n\t\t\tif !ok {\n\t\t\t\tprintln(\"STR\", j)\n\t\t\t} else {\n\t\t\t\tprintln(\"STR\", j, v)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "var sum int\nfor i := 0; i < n; i++ {\n\tif m[i] == 0 {\n\t\tcontinue\n\t}\n\tif m[i] == 1 {\n\t\tsum += i\n\t\tcontinue\n\t}\n\tif m[i] == 2 {\n\t\tfmt.Println(\"i\", i, \"sum\", sum)\n\t\tfmt.Println(\"i\", i, \"sum\", sum)\n\t\tcontinue\n\t}\n}\nfor i := 0; i < n; i++ {\n\tif m[i] == 0 {\n\t\tcontinue\n\t}\n\tif m[i] == 1 {\n\t\tsum += i\n\t\tcontinue\n\t}\n\tif m[i] == 2 {\n\t\tfmt.Println(\"i\", i, \"sum\", sum)\n\t\tfmt.Println(\"i\", i, \"sum\", sum)\n\t\tcontinue\n\t}\n}\nfor i := 0; i < n; i++ {\n\tif m[i] == 0 {\n\t\tcontinue\n\t}\n\tif m[i] == 1 {\n\t\tsum += i\n\t\tcontinue\n\t}\n\tif m[i] == 2 {\n\t\tfmt.Println(\"i\", i, \"sum\", sum)\n\t\tfmt.Println(\"i\", i, \"sum\", sum)\n\t\tcontinue\n\t}\n}\nfor i := 0; i < n; i++ {\n\tif m[i] == 0 {\n\t\tcontinue\n\t}\n\tif m[i] == 1 {\n\t\tsum += i\n\t\tcontinue\n\t}\n\tif m[i] == 2 {\n\t\tfmt.Println(\"i\", i, \"sum\", sum)\n\t\tfmt.Println(\"i\", i, \"sum\", sum)\n\t\tcontinue\n\t}\n}"}
{"tgt": "for j := 1; j <= 20; j++ {\n\tif num%j != 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "for i := 1; i <= 20; i++ {\n\tif n%i == 0 {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "if len(sorted) == 0 {\n\treturn nil\n}\nmid := len(sorted) / 2\nroot := &BST{Value: sorted[mid]}\nroot.Left = SortedSliceToBST(sorted[:mid])\nroot.Right = SortedSliceToBST(sorted[mid+1:])\nreturn root", "gen": "if len(nums) == 0 {\n\treturn nil\n}\nroot := &BST{}\nif len(nums) == 1 {\n\troot.Val = nums[0]\n\treturn root\n}\nroot.Val = nums[0]\nleft := SortedSliceToBST(nums[1:len(nums)/2+1])\nroot.Left = left\nright := SortedSliceToBST(nums[len(nums)/2+1:])\nroot.Right = right\nreturn root\n}"}
{"tgt": "return x * y", "gen": "return float32(a.X*b.X + a.Y*b.Y + a.Z*b.Z)\n}"}
{"tgt": "i1 := 0\ni2 := 0\nval1 := 0\nval2 := 0\nfor i1 < len(version1) || i2 < len(version2) {\n\tval1, i1 = parseSeg(version1, i1)\n\tval2, i2 = parseSeg(version2, i2)\n\tif val1 > val2 {\n\t\treturn 1\n\t}\n\tif val1 < val2 {\n\t\treturn -1\n\t}\n}\nif i1 < len(version1) {\n\treturn 1\n}\nif i2 < len(version2) {\n\treturn -1\n}\nreturn 0", "gen": "var start, end int\nfor _, s := range intervals {\n\tstart, end = parseSeg(s)\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n\t}\n\tif start > end {\n\t\treturn -1\n"}
{"tgt": "return this.Val", "gen": "return s.head\n}"}
{"tgt": "str := \"STR\"\nfmt.Println(longestPalindrome(str))", "gen": "fmt.Println(longestPalindrome(s))\n}"}
{"tgt": "dat, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\nnamesList := string(dat)\nnamesList = strings.Replace(namesList, \"STR\", \"STR\", -1)\nnames := strings.Split(namesList, \"STR\")\nsort.Strings(names)\nnamesScore := 0\nfor index, name := range names {\n\tnamesScore += nameScore(name) * (index + 1)\n}\nfmt.Println(namesScore)", "gen": "file, err := ioutil.ReadFile(\"names.txt\")\nif err != nil {\n\tpanic(err)\n}\nnames := strings.Split(strings.Replace(string(file), \"\\n\", \"\", -1), \",\")\nsort.Strings(names)\nvar score int\nfor i, name := range names {\n\tscore += nameScore(name) * (i + 1)\n}\nfmt.Println(score)\n}"}
{"tgt": "res := 0\nsort.Ints(houses)\nsort.Ints(heaters)\nm, n := len(houses), len(heaters)\nindex := sort.SearchInts(heaters, houses[0])\nfor _, house := range houses {\n\tfor index < n && house > heaters[index] {\n\t\tindex++\n\t}\n\tif index == n {\n\t\treturn max(res, houses[m-1]-heaters[index-1])\n\t}\n\tleft := math.MaxInt32\n\tif index > 0 {\n\t\tleft = house - heaters[index-1]\n\t}\n\tright := heaters[index] - house\n\tres = max(res, min(left, right))\n}\nreturn res", "gen": "sort.Ints(A)\nsort.Ints(B)\ni := sort.SearchInts(A, B[0])\nj := sort.SearchInts(B, A[len(A)-1])\nreturn max(A[i-1]+B[j], A[i]+B[j-1])\n}"}
{"tgt": "l, r := &maxHeap{}, &minHeap{}\nheap.Init(l)\nheap.Init(r)\nreturn MedianFinder{l, r}", "gen": "return &maxHeap{}, &minHeap{}\n}"}
{"tgt": "l := len(preorder)\nif l == 0 {\n\treturn nil\n}\nfor 1 < l && preorder[0] < preorder[l-1] {\n\tl--\n}\nreturn &TreeNode{\n\tVal:   preorder[0],\n\tLeft:  bstFromPreorder(preorder[1:l]),\n\tRight: bstFromPreorder(preorder[l:]),\n}", "gen": "if len(preorder) == 0 {\n\treturn nil\n}\nif preorder[0] == -1 {\n\treturn bstFromPreorder(preorder[1:])\n}\nroot := &TreeNode{Val: preorder[0]}\nif len(preorder) == 1 {\n\treturn root\n}\nroot.Left = bstFromPreorder(preorder[1 : len(preorder)-1])\nroot.Right = bstFromPreorder(preorder[len(preorder)-1:])\nreturn root\n}"}
{"tgt": "ln, err := net.Listen(\"STR\", \"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"STR\", conn.RemoteAddr())\n\tio.WriteString(conn, fmt.Sprint(time.Now()))\n\tconn.Close()\n}", "gen": "l, err := net.Listen(\"tcp\", \"localhost:0\")\nif err != nil {\n\treturn\n}\ndefer l.Close()\ngo func() {\n\tfmt.Println(l.Addr())\n\tio.WriteString(l, \"hello\")\n}()\ntime.Sleep(time.Second)\nreturn l.Addr().String()\n}"}
{"tgt": "i, l := 0, len(bits)-1\nfor i < l {\n\ti += bits[i] + 1\n}\nreturn i == l", "gen": "n := len(nums) - 1\nfor i := 0; i < n; i++ {\n\tif nums[i] == nums[n] {\n\t\treturn true\n\t}\n\tif i < n-1 && nums[i] > nums[i+1] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"STR: %s\", STR)\nSTR = defangIPaddr(STR)\nfmt.Printf(\"STR: %s\", STR)\n}"}
{"tgt": "start := 0\nend := len(s) - 1\nfor start < end {\n\ts[start], s[end] = s[end], s[start]\n\tstart++\n\tend--\n}\nreturn s", "gen": "for i := 0; i < len(nums)-1; i++ {\n\tfor j := i + 1; j < len(nums); j++ {\n\t\tif nums[i]+nums[j] == 0 {\n\t\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\t}\n\t}\n}\n}"}
{"tgt": "for cur := t.root; cur != nil; {\n\tif cur.Key == key {\n\t\treturn cur\n\t} else if key < cur.Key {\n\t\tcur = cur.left\n\t} else {\n\t\tcur = cur.right\n\t}\n}\nreturn nil", "gen": "if root == nil {\n\treturn nil, nil\n}\nfor root.Val != val {\n\tif root.Val > val {\n\t\troot = root.Left\n\t} else {\n\t\troot = root.Right\n\t}\n}\nreturn root, root.Parent\n}"}
{"tgt": "arr := randomSlice(0, 20, 10)\nnodeCnt := 0\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\nrotateNodes := make([]*gbtElement, 0, 0)\ngbt.InOrderWalk(gbt.Root(), func(GBTbinaryTreeIf, node interface{}) bool {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\trotateNodes = append(rotateNodes, node.(*gbtElement))\n\t}\n\treturn false\n})\nfor _, v := range rotateNodes {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\tgbt.LeftRotate(v)\n\t} else {\n\t\tgbt.RightRotate(v)\n\t}\n}\ngbt.InOrderWalk(gbt.Root(), checkGBT(t, &nodeCnt, *debug))\nif nodeCnt != len(arr) {\n\tt.Log(fmt.Sprintf(\"STR\", len(arr), nodeCnt))\n\tt.Fail()\n}", "gen": "slice := randomSlice(10, 20)\ntree := NewGBT()\nfor _, v := range slice {\n\ttree.Insert(v)\n}\nfor i := 0; i < len(slice); i++ {\n\ttree.RotateNodes(i)\n\tif tree.debug.checkGBT(tree) != nil {\n\t\tt.Log(fmt.Sprintf(\"RotateNodes %d\", i))\n\t\tt.Fail()\n\t}\n}\n}"}
{"tgt": "return WordDictionary{}", "gen": "return []*Node{\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{},\n\t{"}
{"tgt": "return xtime.Unix(int64(jt), 0)", "gen": "t := time.Unix(0, t.UnixNano())\nreturn t\n}"}
{"tgt": "return append(ints, added...)", "gen": "if len(s) > len(t) {\n\ts, t = t, s\n}\nreturn s[:len(t)] == t\n}"}
{"tgt": "data, err := base64.StdEncoding.DecodeString(b64)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(data)", "gen": "decoded, err := base64.StdEncoding.DecodeString(s)\nif err != nil {\n\tpanic(err)\n}\nreturn hex.EncodeToString(decoded)\n}"}
{"tgt": "h := fnv.New64a()\n_, _ = h.Write([]byte(fmt.Sprintf(\"STR\", key)))\nhashValue := h.Sum64()\nreturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))", "gen": "hash := z2fnv.New64a()\nhash.Write([]byte(fmt.Sprintf(\"%d\", 1)))\nreturn hash.Sum64() & 1\n}"}
{"tgt": "return fmt.Sprintf(\"STR\", p.Name, p.Age)", "gen": "return fmt.Sprintf(\"%s%d\", s, s.Len())\n}"}
{"tgt": "parent := this\nfor _, ch := range prefix {\n\tif child, ok := parent.Children[ch]; ok {\n\t\tparent = child\n\t\tcontinue\n\t}\n\treturn false\n}\nreturn true", "gen": "for _, c := range s {\n\tif c > 127 {\n\t\tcontinue\n\t}\n\tif _, ok := m[c]; ok {\n\t\ts = s[m[c]:]\n\t\tcontinue\n\t}\n\tif s[0] == c {\n\t\treturn true\n\t}\n}\nreturn false\n}"}
{"tgt": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)", "gen": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)\n}"}
{"tgt": "close(p.work)\np.wg.Wait()", "gen": "close(ch)\nwg.Wait()\n}"}
{"tgt": "m := make(map[int]struct{})\nfor _, num := range nums1 {\n\tm[num] = struct{}{}\n}\nnums := make([]int, 0)\nfor _, num := range nums2 {\n\tif _, ok := m[num]; ok {\n\t\tnums = append(nums, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn nums", "gen": "m := make(map[int]struct{})\nfor _, v := range nums {\n\tm[v] = struct{}{}\n}\nres := make([]int, 0)\nfor _, v := range nums {\n\tif _, ok := m[v]; !ok {\n\t\tres = append(res, v)\n\t\tdelete(m, v)\n\t}\n}\nreturn res\n}"}
{"tgt": "return h.FromHexString(string(b))", "gen": "return HashFromHexString(string(b[:32]), string(b[32:]))\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif denoms := EgyptianFractions(tc.numerator, tc.denominator); !reflect.DeepEqual(tc.denominators, denoms) {\n\t\tt.Errorf(\"STR\", tc.denominators, denoms)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tgot := EgyptianFractions(tc.n)\n\tif !reflect.DeepEqual(got, tc.want) {\n\t\tt.Errorf(\"EgyptianFractions(%d) = %v, want %v\", tc.n, got, tc.want)\n\t}\n}\n}"}
{"tgt": "log.SetFlags(0)\nvar err error\ntpl := template.New(\"STR\")\ntpl = tpl.Funcs(template.FuncMap{\n\t\"STR\": func(str string) string {\n\t\treturn strings.ToUpper(str)\n\t},\n})\ntpl, err = tpl.ParseFiles(\"STR\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nerr = tpl.ExecuteTemplate(os.Stdout, \"STR\", Page{\n\tTitle: \"STR\",\n\tBody:  \"STR\",\n})\nif err != nil {\n\tlog.Fatalln(err)\n}", "gen": "log.SetFlags(10)\nt := template.New(\"\")\nt.Funcs(map[string]interface{}{\n\t\"Write\": func(w io.Writer, s string, n int) (int, error) {\n\t\treturn w.Write([]byte(s))\n\t},\n})\nt, err := t.ParseFiles(\"index.html\")\nif err != nil {\n\tlog.Fatalln(\"template parse error:\", err)\n}\nt.ExecuteTemplate(os.Stdout, \"index.html\", Page{\n\tTitle: \"Hello, World!\",\n})\n}"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA `structs:\"STR\"`\n\tC  int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif ok {\n\tt.Error(\"STR\")\n}", "gen": "t := &B{\n\ti1: 123,\n}\nif !HasZero(t) {\n\tt.Error(\"HasZero\", t)\n}\n}"}
{"tgt": "digits := convert(N + 1)\nbits := len(digits)\nnoRepeat := 0\nfor b := 1; b < bits; b++ {\n\tnoRepeat += 9 * count(9, b-1)\n}\nhasSeen := make(map[int]bool, 10)\nfor b := 0; b < bits; b++ {\n\td := 0\n\tif b == 0 {\n\t\td = 1\n\t}\n\tfor ; d < digits[b]; d++ {\n\t\tif !hasSeen[d] {\n\t\t\tnoRepeat += count(9-b, bits-b-1)\n\t\t}\n\t}\n\tif hasSeen[digits[b]] {\n\t\tbreak\n\t}\n\thasSeen[digits[b]] = true\n}\nreturn N - noRepeat", "gen": "res := convert(1, n)\ndp := make(map[int]bool)\ndp[0] = true\nfor i := 1; i <= n; i++ {\n\tfor j := 1; j <= 9; j++ {\n\t\tif i-j < 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif dp[i-j] {\n\t\t\tdp[i] = true\n\t\t\tbreak\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "return me[0] == \"STR\"", "gen": "if len(s) == 0 {\n\treturn false\n}\nreturn s[0] == '1' || s[0] == '2'\n}"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil {\n\t\t\tmax = max.Right\n\t\t}\n\t\tmax.Right = root\n\t\troot, root.Left = root.Left, nil\n\t}\n}\nreturn res", "gen": "var res []int\nfor head != nil {\n\tres = append(res, head.Val)\n\thead = head.Next\n}\nreturn res\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   0x5555,\n\t\twant: 8,\n\t},\n}\nfor _, tt := range tests {\n\tgot := hammingWeight(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "for i := 0; i < 4; i++ {\n\tif hammingWeight(uint32(i)) != i {\n\t\tt.Fatalf(\"hammingWeight(%d) = %d, want %d\", i, hammingWeight(uint32(i)), i)\n\t}\n}\n}"}
{"tgt": "if a == nil && b == nil {\n\treturn true\n}\nif len(a) != len(b) {\n\treturn false\n}\nfor i := range a {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "if len(a) == 0 || len(b) == 0 {\n\treturn false\n}\nif len(a) == len(b) {\n\treturn true\n}\nfor i := 0; i < len(a); i++ {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "return xtime.Unix(int64(jt), 0), nil", "gen": "return time.Unix(t, 0)\n}"}
{"tgt": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 0},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 11},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 19},\n\t\tans1208{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s, p.t, p.maxCost))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"STR: %s\", s)\nfor i := 0; i < len(s); i++ {\n\tfor j := i + 1; j < len(s); j++ {\n\t\tif equalSubstring(s[i], s[j]) {\n\t\t\tfmt.Printf(\"STR: %s\", s)\n\t\t}\n\t}\n}\n}"}
{"tgt": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{}\n} else if n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{intervals[0]}\nfor _, cur := range intervals[1:] {\n\tprevious := res[len(res)-1]\n\tif cur.Start <= previous.End {\n\t\tend := previous.End\n\t\tif cur.End > end {\n\t\t\tend = cur.End\n\t\t}\n\t\tres = append(res[:len(res)-1], Interval{Start: previous.Start, End: end})\n\t} else {\n\t\tres = append(res, cur)\n\t}\n}\nreturn res", "gen": "if len(intervals) == 0 {\n\treturn []Interval{}\n}\nif len(intervals) == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := make([]Interval, 0)\nres = append(res, intervals[0])\nfor i := 1; i < len(intervals); i++ {\n\tif intervals[i].Start <= res[len(res)-1].End {\n\t\tres[len(res)-1].End = max(res[len(res)-1].End, intervals[i].End)\n\t} else {\n\t\tres = append(res, intervals[i])\n\t}\n}\nreturn res\n}"}
{"tgt": "result := make([]int, 0, len(left)+len(right))\nfor len(left) > 0 || len(right) > 0 {\n\tif len(left) == 0 {\n\t\treturn append(result, right...)\n\t}\n\tif len(right) == 0 {\n\t\treturn append(result, left...)\n\t}\n\tif left[0] <= right[0] {\n\t\tresult = append(result, left[0])\n\t\tleft = left[1:]\n\t} else {\n\t\tresult = append(result, right[0])\n\t\tright = right[1:]\n\t}\n}\nreturn result", "gen": "res := make([]int, 0, len(nums))\nfor _, num := range nums {\n\tif len(res) == 0 || res[len(res)-1] != num {\n\t\tres = append(res, num)\n\t} else {\n\t\tres = res[:len(res)-1]\n\t}\n}\nreturn res\n}"}
{"tgt": "t.Parallel()\nd := NewTimeMap()\nd.Set(1, 1, 0)\nd.Set(1, 2, 2)\nif result := d.Get(1, 1); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 3); result != 2 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 5)\nif result := d.Get(1, 0); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 10); result != 1 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 0)\nd.Set(1, 2, 0)\nif result := d.Get(1, 0); result != 2 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(2, 0); result != nil {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, -1); result != nil {\n\tt.Errorf(\"STR\")\n}", "gen": "t := NewTimeMap()\nt.Set(0, 0)\nt.Set(2, 2)\nt.Set(1, 1)\nt.Set(5, 5)\nt.Set(3, 3)\nt.Set(10, 10)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0, 0)\nt.Set(0"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{2},\n\t\t\t{3, 4},\n\t\t\t{6, 5, 7},\n\t\t\t{4, 1, 8, 3},\n\t\t},\n\t\t11},\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{1},\n\t\t\t{2, 3},\n\t\t},\n\t\t3},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := minimumTotal(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "s := Solution{\n\tname: \"TestSolution\",\n\tinputs: [][]int{\n\t\t{2, 3, 4},\n\t\t{1, 2, 3, 4},\n\t\t{6, 5, 4, 3, 2, 1},\n\t},\n\texpect: []int{2, 1, 3},\n}\ns.TestSolution(t)\n}"}
{"tgt": "pairs := [...][2]int{{15, 26}, {1000, 1366}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p16(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "for i := 0; i < 2; i++ {\n\tfor _, v := range []int{15, 26, 1000, 1366} {\n\t\tif p16(v) != v {\n\t\t\tt.Errorf(\"p16(%d) = %d\", v, p16(v))\n\t\t}\n\t}\n}\n}"}
{"tgt": "m := [26]int{}\nfor _, b := range B {\n\tcount := counter(b)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tm[i] = count[i]\n\t\t}\n\t}\n}\nres := []string{}\nfor _, a := range A {\n\tcount := counter(a)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tcontinueL\n\t\t}\n\t}\n\tres = append(res, a)\n}\nreturn res", "gen": "counter := make([]string, 26)\nfor _, c := range s {\n\tcounter[c-'a'] = counter[c-'a'] + 1\n}\nres := make([]string, 0)\nfor i := 0; i < 26; i++ {\n\tif counter[i] == 0 {\n\t\tcontinue\n\t}\n\tres = append(res, counter[i])\n}\nreturn res\n}"}
{"tgt": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\ntmp := nums[0]\nmax := tmp\nfor i := 1; i < n; i++ {\n\tif tmp < 0 {\n\t\ttmp = nums[i]\n\t} else {\n\t\ttmp += nums[i]\n\t}\n\tif max < tmp {\n\t\tmax = tmp\n\t}\n}\nreturn max", "gen": "if len(nums) == 0 {\n\treturn 0\n}\nif len(nums) == 1 {\n\treturn nums[0]\n}\nvar max, sum int\nfor i := 0; i < len(nums); i++ {\n\tsum += nums[i]\n\tif sum > max {\n\t\tmax = sum\n\t}\n}\nreturn max\n}"}
{"tgt": "hash := uint32(0)\nfor i := len(sep) - 1; i >= 0; i-- {\n\thash = hash*PrimeRK + uint32(sep[i])\n}\nvar pow, sq uint32 = 1, PrimeRK\nfor i := len(sep); i > 0; i >>= 1 {\n\tif i&1 != 0 {\n\t\tpow *= sq\n\t}\n\tsq *= sq\n}\nreturn hash, pow", "gen": "res := 0\nfor i := len(nums) - 1; i >= 0; i-- {\n\tres = (res * 16777619) + uint32(nums[i])\n}\nreturn res\n}"}
{"tgt": "b, _ := ioutil.ReadFile(\"STR\")\ns := strings.Replace(string(b), \"STR\", \"STR\", -1)\nnumData := strings.Split(s, \"STR\")\nfor _, n := range numData {\n\tnumber, err := strconv.Atoi(n)\n\tif err == nil {\n\t\tdata = append(data, number)\n\t}\n}", "gen": "data, err := ioutil.ReadFile(\"input.txt\")\nif err != nil {\n\tpanic(err)\n}\ndata = strings.Replace(string(data), \"\\n\", \"\", -1)\ndata = strings.Split(data, \",\")\nfor _, v := range data {\n\ti, _ := strconv.Atoi(v)\n\tdata[i] = \"X\"\n}\nreturn data\n}"}
{"tgt": "if len(A) == len(A[0]) {\n\tfor i := 0; i < len(A); i++ {\n\t\tfor j := 0; j < len(A); j++ {\n\t\t\tif i == j {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]\n\t\t}\n\t}\n\treturn A\n}\nres := make([][]int, len(A[0]))\nfor i := 0; i < len(res); i++ {\n\tres[i] = make([]int, len(A))\n\tfor j := 0; j < len(A); j++ {\n\t\tres[i][j] = A[j][i]\n\t}\n}\nreturn res", "gen": "for i := 0; i < len(nums); i++ {\n\tfor j := 0; j < len(nums); j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tif nums[i]+nums[j] == 0 {\n\t\t\treturn []int{i, j}\n\t\t}\n\t}\n}\nreturn nil\n}"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := SumRevLLNum(tc.first, tc.second); !equal(result, tc.sum) {\n\t\tt.Errorf(\"STR\",\n\t\t\ttcid, String(result), String(tc.sum))\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif got := SumRevLLNum(tc.num); !equal(got, tc.want) {\n\t\tt.Errorf(\"SumRevLLNum(%v) = %v, want %v\", tc.num, got, tc.want)\n\t}\n}\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tm: 3,\n\t\tn: 3,\n\t\tops: [][]int{\n\t\t\t{2, 2},\n\t\t\t{3, 3},\n\t\t},\n\t\twant: 4,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxCount(tt.m, tt.n, tt.ops)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.m, got, tt.want)\n\t}\n}", "gen": "var res int\nfor _, test := range tests {\n\tif test.a == test.b {\n\t\tcontinue\n\t}\n\tres = max(res, maxCount(test.a, test.b))\n}\nreturn res\n}"}
{"tgt": "n := len(quality)\nworkers := make([][2]float64, n)\nfor i := 0; i < n; i++ {\n\tw, q := float64(wage[i]), float64(quality[i])\n\tworkers[i][0], workers[i][1] = w/q, q\n}\nsort.Slice(workers, func(i, j int) bool {\n\treturn workers[i][0] < workers[j][0]\n})\nres := math.MaxFloat64\nsum := 0.\nh := floatHeap{}\nfor _, w := range workers {\n\tsum += w[1]\n\theap.Push(&h, w[1])\n\tif len(h) > K {\n\t\tsum -= heap.Pop(&h).(float64)\n\t}\n\tif len(h) == K {\n\t\tres = min(res, sum*w[0])\n\t}\n}\nreturn res", "gen": "return min("}
{"tgt": "flag.Parse()\nroots := flag.Args()\nif len(roots) == 0 {\n\troots = []string{\"STR\"}\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, root := range roots {\n\t\twalkDir(root, fileSizes)\n\t}\n\tclose(fileSizes)\n}()\nvar nfiles, nbytes int64\nfor size := range fileSizes {\n\tnfiles++\n\tnbytes += size\n}\nprintDiskUsage(nfiles, nbytes)", "gen": "if len(os.Args) != 2 {\n\tpanic(\"expected exactly one argument\")\n}\nfileSizes, _ := fileSize(os.Args[1])\nroots := make(chan string)\ngo walkDir(os.Args[1], roots, fileSizes)\ntotal := 0\nfor i := 0; i < len(fileSizes); i++ {\n\ttotal += <-roots\n}\nprintDiskUsage(total, len(fileSizes))\n}"}
{"tgt": "var min int\ntotalPeople := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\ttotalPeople++\n\t}\n}\nif totalPeople < 2 {\n\treturn 0\n}\nmiddle := (totalPeople / 2) + (totalPeople % 2)\nindex := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\tmiddle--\n\t}\n\tif middle == 0 {\n\t\tindex = i\n\t\tbreak\n\t}\n}\nleftZero := 0\nleftZeroFound := false\nfor j := index - 1; j >= 0; j-- {\n\tif !leftZeroFound && seating[j] == 0 {\n\t\tleftZero = j\n\t\tleftZeroFound = true\n\t} else if seating[j] == 1 && j < leftZero {\n\t\tmin += abs(j - leftZero)\n\t\tleftZero--\n\t}\n}\nrightZero := 0\nrightZeroFound := false\nfor j := index + 1; j < len(seating); j++ {\n\tif !rightZeroFound && seating[j] == 0 {\n\t\trightZero = j\n\t\trightZeroFound = true\n\t} else if seating[j] == 1 && j > rightZero {\n\t\tmin += abs(j - rightZero)\n\t\trightZero++\n\t}\n}\nreturn min", "gen": "var ans int\nvar cnt, sum int\nfor _, v := range A {\n\tif v == 1 {\n\t\tsum++\n\t} else {\n\t\tsum--\n\t}\n\tif sum < 0 {\n\t\tcnt++\n\t\tsum = 0\n\t}\n}\nans = cnt\nfor _, v := range B {\n\tif v == 1 {\n\t\tsum++\n\t} else {\n\t\tsum--\n\t}\n\tif sum < 0 {\n\t\tcnt++\n\t\tsum = 0\n\t}\n\tif sum == 0 {\n\t\tans = min(ans, cnt)\n\t}\n}\nreturn ans\n}"}
{"tgt": "sum := 0\nprev := 1\ncurr := 1\nfor curr <= 4e6 {\n\tprev, curr = curr, prev+curr\n\tif curr%2 == 0 {\n\t\tsum += curr\n\t}\n}\nfmt.Println(sum)", "gen": "var sum int\nfor i := 1; i <= 4000000; i++ {\n\tif i%2 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "stack := make([]int, 0)\nresult := make([]int, len(T))\nfor i, t := range T {\n\tfor len(stack) > 0 && T[stack[len(stack)-1]] < t {\n\t\tresult[stack[len(stack)-1]] = i - stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t}\n\tstack = append(stack, i)\n}\nfor _, i := range stack {\n\tresult[i] = 0\n}\nreturn result", "gen": "res := make([]int, 0)\nfor _, num := range nums {\n\tif len(res) == 0 || res[len(res)-1] != num {\n\t\tres = append(res, num)\n\t} else {\n\t\tres[len(res)-1] = num\n\t}\n}\nreturn res\n}"}
{"tgt": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 2}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "p1 := [][]int{{1, 2}, {2, 3}, {3, 4}}\np2 := [][]int{{1, 1}, {1, 2}, {1, 3}}\np3 := [][]int{{1, 1}, {1, 2}, {1, 3}, {1, 4}}\nfmt.Printf(\"p1: %v, p2: %v, p3: %v\\n\", p1, p2, p3)\nfor i := 0; i < len(p1); i++ {\n\tfor j := 0; j < len(p1[i]); j++ {\n\t\tfor k := 0; k < len(p1[i][j]); k++ {\n\t\t\tfmt.Printf(\"p1[%d][%d][%d] = %d\\n\", i, j, k, p1[i][j][k])\n\t\t}\n\t}\n}\nfor i := 0; i < len(p2); i++ {\n\tfor j := 0; j < len(p2[i]); j++ {\n\t\tfor k := 0; k < len(p2[i][j]); k++ {\n\t\t\tfmt.Printf(\"p2[%d][%d][%d] = %d\\n\", i, j, k, p2[i][j][k])\n\t\t}\n\t}\n}\nfor i := 0; i < len(p3); i++ {\n\tfor j := 0; j < len(p3[i]); j++ {\n\t\tfor k := 0; k < len(p3[i][j]); k++ {\n\t\t\tfmt.Printf(\"p3[%d][%d][%d] = %d\\n\", i, j, k, p3[i][j][k])\n\t\t}\n\t}\n}\nfor i := 0; i < len(p1); i++ {\n\tfor j := 0;"}
{"tgt": "out := 100\nif x := p33(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "t.Errorf(\"p33() = %v, want %v\", p33(), 100)\n}"}
