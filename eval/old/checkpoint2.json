{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif sum := SumBSTRange(tc.root, tc.a, tc.b); sum != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, sum)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "return &linkLoop{\n\tHead: &linkLoopNode{},\n}", "gen": "var d *linkLoopNode\nd = new(linkLoopNode)\nd.linkLoop = new(linkLoop)\nd.linkLoop.linkLoopNode = d\n}\n\n<ASM>\n.LFB1:\ncmpq %fs:112,%rsp\njnb .L1\nmovl $88,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L1:\npushq %rbp\nmovq %rsp,%rbp\npushq %rbx\nsubq $72,%rsp\nmovq $0,-24(%rbp)\n.LBB8:\n.LBB9:\nleaq <main..main.linkLoopNode..d>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-72(%rbp)\nmovq $0,-64(%rbp)\nmovq $0,-56(%rbp)\nmovq $0,-48(%rbp)\nleaq <runtime.writeBarrier>(%rip),%rax\nmovl (%rax),%eax\ntestl %eax,%eax\njne .L6\n.LBB10:\nmovq -72(%rbp),%rcx\nmovq -64(%rbp),%rax\nmovq -56(%rbp),%rdx\nmovq %rax,(%rcx)\nmovq %rdx,<8>(%rcx)\nmovq -48(%rbp),%rax\nmovq %rax,<16>(%rcx)\n.LBE10:\njmp .L7\n.L6:\n.LBB11:\nmovq -72(%rbp),%rax\nleaq -64(%rbp),%rdx\nmovq %rax,%rsi\nleaq <main..main.linkLoopNode..d>(%rip),%rdi\ncall <runtime.typedmemmove@PLT>\n.L7:\n.LBE11:\nmovq -"}
{"tgt": "return bindataRead(\n\t_assetsHomeCatJpg,\n\t\"STR\",\n)", "gen": "var homeCatJpg []byte\nvar homeCatJpg2 []byte\nvar homeCatJpg3 []byte\nvar homeCatJpg4 []byte\nvar homeCatJpg5 []byte\nvar homeCatJpg6 []byte\nvar homeCatJpg7 []byte\nvar homeCatJpg8 []byte\nvar homeCatJpg9 []byte\nvar homeCatJpg10 []byte\nvar homeCatJpg11 []byte\nvar homeCatJpg12 []byte\nvar homeCatJpg13 []byte\nvar homeCatJpg14 []byte\nvar homeCatJpg15 []byte\nvar homeCatJpg16 []byte\nvar homeCatJpg17 []byte\nvar homeCatJpg18 []byte\nvar homeCatJpg19 []byte\nvar homeCatJpg20 []byte\nvar homeCatJpg21 []byte\nvar homeCatJpg22 []byte\nvar homeCatJpg23 []byte\nvar homeCatJpg24 []byte\nvar homeCatJpg25 []byte\nvar homeCatJpg26 []byte\nvar homeCatJpg27 []byte\nvar homeCatJpg28 []byte\nvar homeCatJpg29 []byte\nvar homeCatJpg30 []byte\nvar homeCatJpg31 []byte\nvar homeCatJpg32 []byte\nvar homeCatJpg33 []byte\nvar homeCatJpg34 []byte\nvar homeCatJpg35 []byte\nvar homeCatJpg36 []byte\nvar homeCatJpg37 []byte\nvar homeCatJpg38 []byte\nvar homeCatJpg39 []byte\nvar homeCatJpg40 []byte\nvar homeCatJpg41 []byte\nvar homeCatJpg42 []byte\nvar homeCatJpg43 []byte\nvar homeCatJpg44 []byte\nvar homeCatJpg45 []byte\nvar homeCatJpg46 []byte\nvar homeCat"}
{"tgt": "max := 1000\nsum := 0\nfor i := 1; i < max; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)", "gen": "var a int\nvar b int\nvar c int\na = 1\nb = 1\nfor i := 0; i < 1000; i++ {\n\tif i%2 == 0 {\n\t\tc = a + b\n\t\ta = b\n\t\tb = c\n\t} else {\n\t\tc = a - b\n\t\ta = b\n\t\tb = c\n\t}\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.locs); !reflect.DeepEqual(bonuses, tc.bonuses) {\n\t\tt.Errorf(\"STR\", tc.bonuses, bonuses)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "max := 9999\nbiggestPandigital := 0\nvar numberMultiplied int\nfor i := max; i > 0; i-- {\n\tnumberMultiplied = i\n\tfor j := 1; len(digits(numberMultiplied)) <= 9; j++ {\n\t\tnumberMultiplied = concatenMultiplication(i, j)\n\t\tif IsPandigital(numberMultiplied) && numberMultiplied > biggestPandigital {\n\t\t\tfmt.Println(numberMultiplied)\n\t\t\tbiggestPandigital = numberMultiplied\n\t\t}\n\t}\n}", "gen": "var pandigital []int\nfor i := 1; i < 10000; i++ {\n\tif IsPandigital(i) {\n\t\tpandigital = append(pandigital, i)\n\t}\n}\nfor _, i := range pandigital {\n\tfor _, j := range pandigital {\n\t\tif i != j {\n\t\t\tif concatenMultiplication(i, j) == i*j {\n\t\t\t\tfmt.Println(i, j, i*j)\n\t\t\t}\n\t\t}\n\t}\n}\n}\n"}
{"tgt": "for {\n\tswitch r := l.next(); {\n\tcase unicode.IsNumber(r):\n\tcase r == \"STR\":\n\t\tl.backup()\n\t\tl.emit(itemEnd)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase r == eof:\n\t\tl.emit(itemEnd)\n\t\treturn byteRangeSet\n\tdefault:\n\t\treturn l.error(\"STR\")\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "return func(treebinaryTreeIf, node interface{}) bool {\n\tn := node.(*gbtElement)\n\tif !tree.IsNil(n.Left) && n.Left.Key >= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Left, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif !tree.IsNil(n.Right) && n.Right.Key <= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Right, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif debug {\n\t\tfmt.Println(n)\n\t}\n\t*nodeCnt++\n\treturn false\n}", "gen": "var t1 testing.T\nvar bt binaryTree\nbt.checkGBT(&t1, true, 1)\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname __morestack runtime.morestack"}
{"tgt": "iterator := func() <-chan VertexId {\n\tch := make(chan VertexId)\n\tgo func() {\n\t\tif connected, ok := g.edges[vertex]; ok {\n\t\t\tfor VertexId, _ := range connected {\n\t\t\t\tif g.IsEdge(vertex, VertexId) {\n\t\t\t\t\tch <- VertexId\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\nreturn VerticesIterable(&vertexIterableHelper{iterFunc: iterator})", "gen": "g := NewGraph()\nv1 := g.AddVertex(\"1\")\nv2 := g.AddVertex(\"2\")\ng.AddEdge(v1, v2)\nfmt.Println(g)\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 2, 1}, []int{0, 4, 1, 3, 2}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1}, []int{0}, []int{1}},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums, c.index)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums, c.index)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "c.bw.WriteString(\"STR\")\nc.bw.WriteByte(space)\nc.bw.WriteString(key)\nc.bw.WriteByte(space)\nc.bw.Write(strconv.AppendInt(c.numScratch[:0], int64(timeout), 10))\n_, err = c.bw.Write(crlf)\nreturn", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "for V > 0 {\n\tV--\n\tif !isDroppedLeft(heights, K) && !isDroppedRight(heights, K) {\n\t\theights[K]++\n\t}\n}\nreturn heights", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\na[0], a[1], a[2] = a[2], a[0], a[1]\nfmt.Println(a[0], a[1], a[2])\n}\n"}
{"tgt": "h := &IntMaxHeap{}\nheap.Init(h)\nheap.Push(h, 7)\nheap.Push(h, 3)\nheap.Push(h, 2)\nheap.Push(h, 1)\nheap.Push(h, 5)\nheap.Push(h, 5)\nheap.Push(h, 6)\nheap.Push(h, 7)\nfmt.Printf(\"STR\", (*h))\nfor h.Len() > 0 {\n\tfmt.Printf(\"STR\", heap.Pop(h))\n}", "gen": "var a = Solution{[]int{3, 2, 1}}\na.Init()\na.Push(4)\na.Push(5)\na.Push(6)\nfmt.Println(a.Len())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\nfmt.Println(a.Pop())\n"}
{"tgt": "sLen, pLen := len(s), len(p)\ndp := make([][]bool, sLen+1)\nfor i := range dp {\n\tdp[i] = make([]bool, pLen+1)\n}\ndp[sLen][pLen] = true\nfor i := sLen; i > -1; i-- {\n\tfor j := pLen - 1; j > -1; j-- {\n\t\tfirstMatch := i < sLen && (p[j] == s[i] || p[j] == '.')\n\t\tif j+1 < pLen && p[j+1] == '*' {\n\t\t\tdp[i][j] = dp[i][j+2] || firstMatch && dp[i+1][j]\n\t\t} else {\n\t\t\tdp[i][j] = firstMatch && dp[i+1][j+1]\n\t\t}\n\t}\n}\nreturn dp[0][0]", "gen": "var a [3]bool\nvar b [3]bool\nvar c [3]bool\nvar d [3]bool\nvar e [3]bool\nvar f [3]bool\nvar g [3]bool\nvar h [3]bool\nvar i [3]bool\nvar j [3]bool\nvar k [3]bool\nvar l [3]bool\nvar m [3]bool\nvar n [3]bool\nvar o [3]bool\nvar p [3]bool\nvar q [3]bool\nvar r [3]bool\nvar s [3]bool\nvar t [3]bool\nvar u [3]bool\nvar v [3]bool\nvar w [3]bool\nvar x [3]bool\nvar y [3]bool\nvar z [3]bool\nvar aa [3]bool\nvar bb [3]bool\nvar cc [3]bool\nvar dd [3]bool\nvar ee [3]bool\nvar ff [3]bool\nvar gg [3]bool\nvar hh [3]bool\nvar ii [3]bool\nvar jj [3]bool\nvar kk [3]bool\nvar ll [3]bool\nvar mm [3]bool\nvar nn [3]bool\nvar oo [3]bool\nvar pp [3]bool\nvar qq [3]bool\nvar rr [3]bool\nvar ss [3]bool\nvar tt [3]bool\nvar uu [3]bool\nvar vv [3]bool\nvar ww [3]bool\nvar xx [3]bool\nvar yy [3]bool\nvar zz [3]bool\nvar aaa [3]bool\nvar bbb [3]bool\nvar ccc [3]bool\nvar ddd [3]bool\nvar eee [3]bool\nvar fff [3]bool\nvar ggg [3]bool\nvar hhh [3]"}
{"tgt": "l1 := len(board)\nif l1 == 0 {\n\treturn\n}\nl2 := len(board[0])\nif l2 == 0 {\n\treturn\n}\nvisit := make([][]bool, l1)\nfor i := 0; i < l1; i++ {\n\tvisit[i] = make([]bool, l2)\n}\nfor i := 0; i < l1; i++ {\n\tfor j := 0; j < l2; j++ {\n\t\tif !visit[i][j] {\n\t\t\thelper(board, visit, i, j)\n\t\t}\n\t}\n}", "gen": "var a [2]bool\nvar b [2]bool\nvar c [2]bool\nvar d [2]bool\nvar e [2]bool\nvar f [2]bool\nvar g [2]bool\nvar h [2]bool\nvar i [2]bool\nvar j [2]bool\nvar k [2]bool\nvar l [2]bool\nvar m [2]bool\nvar n [2]bool\nvar o [2]bool\nvar p [2]bool\nvar q [2]bool\nvar r [2]bool\nvar s [2]bool\nvar t [2]bool\nvar u [2]bool\nvar v [2]bool\nvar w [2]bool\nvar x [2]bool\nvar y [2]bool\nvar z [2]bool\nvar aa [2]bool\nvar ab [2]bool\nvar ac [2]bool\nvar ad [2]bool\nvar ae [2]bool\nvar af [2]bool\nvar ag [2]bool\nvar ah [2]bool\nvar ai [2]bool\nvar aj [2]bool\nvar ak [2]bool\nvar al [2]bool\nvar am [2]bool\nvar an [2]bool\nvar ao [2]bool\nvar ap [2]bool\nvar aq [2]bool\nvar ar [2]bool\nvar as [2]bool\nvar at [2]bool\nvar au [2]bool\nvar av [2]bool\nvar aw [2]bool\nvar ax [2]bool\nvar ay [2]bool\nvar az [2]bool\nvar ba [2]bool\nvar bb [2]bool\nvar bc [2]bool\nvar bd [2]bool\nvar be [2]bool\nvar bf [2]bool\nvar bg [2]bool\nvar bh [2]bool\nvar bi [2]bool\nvar bj ["}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.nums); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "sum := 100 * 101 / 2\nsqSum := sum * sum\nsumSq := 0\nfor i := 1; i <= 100; i++ {\n\tsumSq += i * i\n}\nfmt.Println(sqSum - sumSq)", "gen": "var a int\nfor i := 1; i <= 100; i++ {\n\ta += i\n}\nfmt.Println(a)\n}\n\n<ASM>\n.LFB0:\ncmpq %fs:112,%rsp\njnb .L7\nmovl $168,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L7:\npushq %rbp\nmovq %rsp,%rbp\npushq %r13\npushq %r12\nsubq $144,%rsp\nmovq $5050,-40(%rbp)\nmovq -40(%rbp),%rax\nimulq %rax,%rax\nmovq %rax,-48(%rbp)\nmovq $0,-24(%rbp)\n.LBB2:\nmovq $1,-32(%rbp)\n.LBB3:\njmp .L2\n.L6:\n.LBB4:\nnop\n.LBE4:\n.LBB5:\nmovq -32(%rbp),%rax\nimulq %rax,%rax\naddq %rax,-24(%rbp)\n.LBE5:\n.LBB6:\naddq $1,-32(%rbp)\n.L2:\n.LBE6:\ncmpq $100,-32(%rbp)\njle .L6\n.LBE3:\n.LBE2:\nleaq <int..d>(%rip),%r12\nleaq <int..d>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-136(%rbp)\nmovq -136(%rbp),%rax\nmovq -48(%rbp),%rdx\nsubq -24(%rbp),%rdx\nmovq %rdx,(%rax)\nmovq -136(%rbp),%rax\nmovq %"}
{"tgt": "return x != y", "gen": "var a, b float32\nfmt.Scan(&a, &b)\nif a > b {\n\tfmt.Println(\"a > b\")\n} else if a < b {\n\tfmt.Println(\"a < b\")\n} else {\n\tfmt.Println(\"a == b\")\n}\n}\n\n// Output:\n// a < b\n\n// 1. \u6c47\u7f16\u4ee3\u7801\n// 2. \u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\n// 3. \u6c47\u7f16\u4ee3\u7801\u7684\u7f16\u8bd1\n// 4. \u6c47\u7f16\u4ee3\u7801\u7684\u6267\u884c\n// 5. \u6c47\u7f16\u4ee3\u7801\u7684\u4f18\u5316\n// 6. \u6c47\u7f16\u4ee3\u7801\u7684\u8c03\u8bd5\n// 7. \u6c47\u7f16\u4ee3\u7801\u7684\u5206\u6790\n// 8. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 9. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 10. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 11. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 12. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 13. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 14. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 15. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 16. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 17. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 18. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 19. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 20. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 21. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 22. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 23. \u6c47\u7f16\u4ee3\u7801\u7684\u6269\u5c55\n// 24. \u6c47\u7f16\u4ee3"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 1, 3}},\n\t\tans1051{3},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 2, 3, 4}},\n\t\tans1051{5},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{0},\n\t},\n\t{\n\t\tpara1051{[]int{5, 4, 3, 2, 1}},\n\t\tans1051{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"STR\", got, tt.want)\n\t\t}\n\t})\n}", "gen": "tests := []struct {\n\tname string\n\targs []string\n\twant int\n}{\n\t{\"test1\", []string{\"abcde\", \"cdefg\"}, 2},\n\t{\"test2\", []string{\"abcd\", \"cdab\"}, 4},\n\t{\"test3\", []string{\"abcde\", \"fghij\"}, 0},\n\t{\"test4\", []string{\"abcde\", \"abcde\"}, 4},\n\t{\"test5\", []string{\"abcde\", \"abcdefg\"}, 4},\n\t{\"test6\", []string{\"abcde\", \"abcdefgh\"}, 4},\n\t{\"test7\", []string{\"abcde\", \"abcdefghi\"}, 4},\n\t{\"test8\", []string{\"abcde\", \"abcdefghij\"}, 4},\n\t{\"test9\", []string{\"abcde\", \"abcdefghijk\"}, 4},\n\t{\"test10\", []string{\"abcde\", \"abcdefghijkl\"}, 4},\n\t{\"test11\", []string{\"abcde\", \"abcdefghijklm\"}, 4},\n\t{\"test12\", []string{\"abcde\", \"abcdefghijklmn\"}, 4},\n\t{\"test13\", []string{\"abcde\", \"abcdefghijklmno\"}, 4},\n\t{\"test14\", []string{\"abcde\", \"abcdefghijklmnop\"}, 4},\n\t{\"test15\", []string{\"abcde\", \"abcdefghijklmnopq\"}, 4},\n\t{\"test16\", []string{\"abcde\", \"abcdefghijklmnopqr\"}, 4},\n\t{\"test17\", []string{\"abcde\", \"abcdefghijklmnopqrs\"}, 4},\n\t{\"test18\", []string{\"abcde\", \"abcdefghijklmnopqrst\"}, 4},\n\t{\"test19\", []string{\"abcde\", \"abcdefghijklmnopqrstu\"}, 4},\n\t{\"test20\", []string{\"abcde\", \"abc"}
{"tgt": "if m == 0 {\n\treturn 1\n}\nswitch n {\ncase 1:\n\treturn 2\ncase 2:\n\tif m == 1 {\n\t\treturn 3\n\t}\n\treturn 4\ndefault:\n\tswitch m {\n\tcase 1:\n\t\treturn 4\n\tcase 2:\n\t\treturn 7\n\tdefault:\n\t\treturn 8\n\t}\n}", "gen": "var a, b int\na = 1\nb = 2\nvar c int\nc = max(a, b)\nfmt.Println(c)\n}\n"}
{"tgt": "sort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].End < intervals[j].End\n})\ncount := 0\ncurrent := -int(^uint(0)>>1) - 1\nfor _, interval := range intervals {\n\tif interval.Start >= current {\n\t\tcount++\n\t\tcurrent = interval.End\n\t}\n}\nreturn len(intervals) - count", "gen": "fmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 3}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 4}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 5}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 6}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 7}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 8}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 9}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 10}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 11}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 12}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 13}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 14}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{"}
{"tgt": "switch rand.Intn(10) {\ncase 1, 9:\n\treturn io.EOF\ncase 5:\n\treturn errors.New(\"STR\")\ndefault:\n\td.Line = \"STR\"\n\tfmt.Println(\"STR\", d.Line)\n\treturn nil\n}", "gen": "var s string\nfmt.Scan(&s)\nfmt.Println(s)\n}\n"}
{"tgt": "fmt.Println(subarrayBitwiseORs([]int{0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))", "gen": "var a = []int{1, 2, 3}\nvar b = []int{1, 2, 3}\nvar c = []int{1, 2, 3}\nvar d = []int{1, 2, 3}\nvar e = []int{1, 2, 3}\nvar f = []int{1, 2, 3}\nvar g = []int{1, 2, 3}\nvar h = []int{1, 2, 3}\nvar i = []int{1, 2, 3}\nvar j = []int{1, 2, 3}\nvar k = []int{1, 2, 3}\nvar l = []int{1, 2, 3}\nvar m = []int{1, 2, 3}\nvar n = []int{1, 2, 3}\nvar o = []int{1, 2, 3}\nvar p = []int{1, 2, 3}\nvar q = []int{1, 2, 3}\nvar r = []int{1, 2, 3}\nvar s = []int{1, 2, 3}\nvar t = []int{1, 2, 3}\nvar u = []int{1, 2, 3}\nvar v = []int{1, 2, 3}\nvar w = []int{1, 2, 3}\nvar x = []int{1, 2, 3}\nvar y = []int{1, 2, 3}\nvar z = []int{1, 2, 3}\nvar aa = []int{1, 2, 3}\nvar bb = []int{1, 2, 3}\nvar cc = []int{1, 2, 3}\nvar dd = []int{1, 2, 3}\nvar ee = []int{1, 2, 3}\nvar"}
{"tgt": "dummy := &ListNode{0, head}\nslow, fast := dummy, dummy\nfor fast.Next != nil && fast.Next.Next != nil {\n\tfast = fast.Next.Next\n\tslow = slow.Next\n}\nreturn slow.Next", "gen": "var a [2]int\nvar b [2]int\na[0] = 1\na[1] = 2\nb[0] = 3\nb[1] = 4\nvar c [2]int\nc[0] = a[0] + b[0]\nc[1] = a[1] + b[1]\nfmt.Println(c[0], c[1])\n}\n\n<ASM>\n.LFB228:\npushq %rbp\nmovq %rsp,%rbp\nmovq %rdi,-8(%rbp)\nmovq %rsi,-16(%rbp)\nmovq %rdx,-24(%rbp)\nmovq -8(%rbp),%rax\nmovq %rax,-32(%rbp)\nmovq -16(%rbp),%rax\nmovq %rax,-40(%rbp)\nmovq -24(%rbp),%rax\nmovq %rax,-48(%rbp)\nmovq -32(%rbp),%rax\nmovq %rax,-56(%rbp)\nmovq -40(%rbp),%rax\nmovq %rax,-64(%rbp)\nmovq -48(%rbp),%rax\nmovq %rax,-72(%rbp)\nmovq -56(%rbp),%rax\nmovq %rax,-80(%rbp)\nmovq -64(%rbp),%rax\nmovq %rax,-88(%rbp)\nmovq -72(%rbp),%rax\nmovq %rax,-96(%rbp)\nmovq -80(%rbp),%rax\nmovq %rax,-104(%rbp)\nmovq -88(%rbp),%rax\nmovq %rax,-112(%rbp)\nmovq -96(%rbp),%rax\nmovq %rax,-120(%rbp)\nmovq -104(%rbp),"}
{"tgt": "pairs := [...][2]int{{10, 7}, {1000, 983}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p26(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var a [2]int\nvar b [2]int\nvar c [2]int\nvar d [2]int\nvar e [2]int\nvar f [2]int\nvar g [2]int\nvar h [2]int\nvar i [2]int\nvar j [2]int\nvar k [2]int\nvar l [2]int\nvar m [2]int\nvar n [2]int\nvar o [2]int\nvar p [2]int\nvar q [2]int\nvar r [2]int\nvar s [2]int\nvar t [2]int\nvar u [2]int\nvar v [2]int\nvar w [2]int\nvar x [2]int\nvar y [2]int\nvar z [2]int\nvar aa [2]int\nvar ab [2]int\nvar ac [2]int\nvar ad [2]int\nvar ae [2]int\nvar af [2]int\nvar ag [2]int\nvar ah [2]int\nvar ai [2]int\nvar aj [2]int\nvar ak [2]int\nvar al [2]int\nvar am [2]int\nvar an [2]int\nvar ao [2]int\nvar ap [2]int\nvar aq [2]int\nvar ar [2]int\nvar as [2]int\nvar at [2]int\nvar au [2]int\nvar av [2]int\nvar aw [2]int\nvar ax [2]int\nvar ay [2]int\nvar az [2]int\nvar aaa [2]int\nvar aab [2]int\nvar aac [2]int\nvar aad [2]int\nvar aae [2]int\nvar aaf [2]int\nvar aag [2]int\nvar aah [2]int\nvar aai [2]int\n"}
{"tgt": "n := len(A)\nfor i := n - 2; i >= 0; i-- {\n\tA[i] += A[i+1]\n}\nmem := [101][33]int{}\nvar dp func(int, int) int\ndp = func(i, m int) int {\n\tif i+2*m >= n {\n\t\treturn A[i]\n\t}\n\tif mem[i][m] > 0 {\n\t\treturn mem[i][m]\n\t}\n\tres := 0\n\tfor x := 1; x <= 2*m; x++ {\n\t\tres = max(\n\t\t\tres,\n\t\t\tA[i]-dp(i+x, max(m, x)),\n\t\t)\n\t}\n\tmem[i][m] = res\n\treturn res\n}\nreturn dp(0, 1)", "gen": "var stones []int\nvar A, B int\nfmt.Scan(&A, &B)\nstones = make([]int, A+B)\nfor i := 0; i < A; i++ {\n\tfmt.Scan(&stones[i])\n}\nfor i := A; i < A+B; i++ {\n\tfmt.Scan(&stones[i])\n}\nfmt.Println(stoneGameII(stones))\n}\n"}
{"tgt": "if n == 0 {\n\treturn 0\n}\nreturn n/5 + trailingZeroes(n/5)", "gen": "fmt.Println(trailingZeroes(10))\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0}, 5},\n\t{\"STR\", []int{0, 0, 0, 0, 1}, []int{1, 0, 0, 0, 0}, 4},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums1, c.nums2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums1, c.nums2)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "list.rear = nil", "gen": "var x int\nx = 1\nx = 2\nx = 3\nx = 4\nx = 5\nx = 6\nx = 7\nx = 8\nx = 9\nx = 10\nx = 11\nx = 12\nx = 13\nx = 14\nx = 15\nx = 16\nx = 17\nx = 18\nx = 19\nx = 20\nx = 21\nx = 22\nx = 23\nx = 24\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(name) == 0 && len(typed) == 0 {\n\treturn true\n}\nif (len(name) == 0 && len(typed) != 0) || (len(name) != 0 && len(typed) == 0) {\n\treturn false\n}\nj := 0\nfor i := 0; i < len(name); i++ {\n\tif j < len(typed) && name[i] == typed[j] {\n\t\tj++\n\t\tcontinue\n\t} else {\n\t\tif i > 0 && j < len(typed) && name[i-1] == typed[j] {\n\t\t\tj++\n\t\t\ti--\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "var a [10]byte\nvar b [10]byte\nvar c [10]byte\nvar d [10]byte\nvar e [10]byte\nvar f [10]byte\nvar g [10]byte\nvar h [10]byte\nvar i [10]byte\nvar j [10]byte\nvar k [10]byte\nvar l [10]byte\nvar m [10]byte\nvar n [10]byte\nvar o [10]byte\nvar p [10]byte\nvar q [10]byte\nvar r [10]byte\nvar s [10]byte\nvar t [10]byte\nvar u [10]byte\nvar v [10]byte\nvar w [10]byte\nvar x [10]byte\nvar y [10]byte\nvar z [10]byte\nvar aa [10]byte\nvar bb [10]byte\nvar cc [10]byte\nvar dd [10]byte\nvar ee [10]byte\nvar ff [10]byte\nvar gg [10]byte\nvar hh [10]byte\nvar ii [10]byte\nvar jj [10]byte\nvar kk [10]byte\nvar ll [10]byte\nvar mm [10]byte\nvar nn [10]byte\nvar oo [10]byte\nvar pp [10]byte\nvar qq [10]byte\nvar rr [10]byte\nvar ss [10]byte\nvar tt [10]byte\nvar uu [10]byte\nvar vv [10]byte\nvar ww [10]byte\nvar xx [10]byte\nvar yy [10]byte\nvar zz [10]byte\nvar aaa [10]byte\nvar bbb [10]"}
{"tgt": "factorial := new(big.Int).MulRange(1, 100)\nbytes := factorial.Append([]byte{}, 10)\nsum := 0\nfor b := range bytes {\n\tsum += int(bytes[b] - '0')\n}\nfmt.Println(\"STR\", sum)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nfmt.Scan(&a, &b, &c, &d)\nvar e int\nvar f int\nvar g int\nvar h int\ne = a * 10 + b\nf = c * 10 + d\ng = e * f\nh = g / 100\nfmt.Println(h)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs int\n\texpect int\n}{\n\t{\"STR\", 2, 1},\n\t{\"STR\", 3, 2},\n\t{\"STR\", 4, 3},\n\t{\"STR\", 0, 0},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "var low, mid, high int = 0, len(sorted) / 2, len(sorted)\nfor low < high {\n\tcurr := sorted[mid]\n\tswitch {\n\tcase curr == target:\n\t\treturn mid\n\tcase inRange(sorted[mid:high], target):\n\t\tlow = mid\n\t\tmid = (low + high) / 2\n\tdefault:\n\t\thigh = mid\n\t\tmid = (low + high) / 2\n\t}\n}\nreturn -1", "gen": "var a [10]int\nvar b []int\nvar c int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nb = a[2:5]\nc = b[2]\nfmt.Println(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nret := &ListNode{}\nif l1.Val <= l2.Val {\n\tret = l1\n\tret.Next = mergeTwoLists1(l1.Next, l2)\n} else {\n\tret = l2\n\tret.Next = mergeTwoLists1(l1, l2.Next)\n}\nreturn ret", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Print(sum, \"STR\")", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aaa int\nvar bbb int\nvar ccc int\nvar ddd int\nvar eee int\nvar fff int\nvar ggg int\nvar hhh int\nvar iii int\nvar jjj int\nvar kkk int\nvar lll int\nvar mmm int\nvar nnn int\nvar ooo int\nvar ppp int\nvar qqq int\nvar rrr int\nvar sss int\nvar ttt int\nvar uuu int\nvar vvv int\nvar www int\nvar xxx int\nvar yyy int\nvar zzz int\nvar aaaa int\nvar bbbb int\nvar cccc int\nvar dddd int\nvar eeee int\nvar ffff int\nvar gggg int\nvar hhhh int\nvar iiii int\nvar jjjj int\n"}
{"tgt": "rets := make([][]int, numRows)\nif numRows == 0 {\n\treturn rets\n}\nrets[0] = []int{1}\nfor i := 1; i < numRows; i++ {\n\trets[i] = make([]int, i+1)\n\trets[i][0] = 1\n\trets[i][i] = 1\n\tfor j := 1; j < i; j++ {\n\t\trets[i][j] = rets[i-1][j-1] + rets[i-1][j]\n\t}\n}\nreturn rets", "gen": "var a [3]int\nvar b [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 4\nb[1] = 5\nb[2] = 6\nc := append(a, b...)\nfmt.Println(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "start := -1\nlenMax := 0\ndict := [256]int{}\nfor i := range dict {\n\tdict[i] = -1\n}\nfor i, r := range s {\n\tif v := dict[r]; v > start {\n\t\tstart = v\n\t}\n\tlength := i - start\n\tif length > lenMax {\n\t\tlenMax = length\n\t}\n\tdict[r] = i\n}\nreturn lenMax", "gen": "var s []byte\ns = append(s, 1)\ns = append(s, 2)\ns = append(s, 3)\ns = append(s, 4)\ns = append(s, 5)\ns = append(s, 6)\ns = append(s, 7)\ns = append(s, 8)\ns = append(s, 9)\ns = append(s, 10)\ns = append(s, 11)\ns = append(s, 12)\ns = append(s, 13)\ns = append(s, 14)\ns = append(s, 15)\ns = append(s, 16)\ns = append(s, 17)\ns = append(s, 18)\ns = append(s, 19)\ns = append(s, 20)\ns = append(s, 21)\ns = append(s, 22)\ns = append(s, 23)\ns = append(s, 24)\ns = append(s, 25)\ns = append(s, 26)\ns = append(s, 27)\ns = append(s, 28)\ns = append(s, 29)\ns = append(s, 30)\ns = append(s, 31)\ns = append(s, 32)\ns = append(s, 33)\ns = append(s, 34)\ns = append(s, 35)\ns = append(s, 36)\ns = append(s, 37)\ns = append(s, 38)\ns = append(s, 39)\ns = append(s, 40)\ns = append(s, 41)\ns = append(s, 42)"}
{"tgt": "nlen := len(nums)\nfor i := 0; i < nlen-2; i++ {\n\tif i != 0 && nums[i] == nums[i-1] {\n\t\tcontinue\n\t}\n\tleft, right := i+1, nlen-1\n\tfor left < right {\n\t\tsum := nums[i] + nums[left] + nums[right]\n\t\tif sum == target {\n\t\t\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tleft++\n\t\t\tright--\n\t\t} else if sum < target {\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tleft++\n\t\t} else {\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tright--\n\t\t}\n\t}\n}", "gen": "var a [4]int\nvar b [4]int\nvar c [4]int\nvar d [4]int\nvar e [4]int\nvar f [4]int\nvar g [4]int\nvar h [4]int\nvar i [4]int\nvar j [4]int\nvar k [4]int\nvar l [4]int\nvar m [4]int\nvar n [4]int\nvar o [4]int\nvar p [4]int\nvar q [4]int\nvar r [4]int\nvar s [4]int\nvar t [4]int\nvar u [4]int\nvar v [4]int\nvar w [4]int\nvar x [4]int\nvar y [4]int\nvar z [4]int\nvar aa [4]int\nvar ab [4]int\nvar ac [4]int\nvar ad [4]int\nvar ae [4]int\nvar af [4]int\nvar ag [4]int\nvar ah [4]int\nvar ai [4]int\nvar aj [4]int\nvar ak [4]int\nvar al [4]int\nvar am [4]int\nvar an [4]int\nvar ao [4]int\nvar ap [4]int\nvar aq [4]int\nvar ar [4]int\nvar as [4]int\nvar at [4]int\nvar au [4]int\nvar av [4]int\nvar aw [4]int\nvar ax [4]int\nvar ay [4]int\nvar az [4]int\nvar ba [4]int\nvar bb [4]int\nvar bc [4]int\nvar bd [4]int\nvar be [4]int\nvar bf [4]int\nvar bg [4]int\nvar bh [4]int\nvar bi [4]int\nvar bj ["}
{"tgt": "return strings.ReplaceAll(r.element.Name, \"STR\", \"\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "var res byte\nfor i := 0; i < len(s); i++ {\n\tres ^= s[i]\n}\nfor i := 0; i < len(t); i++ {\n\tres ^= t[i]\n}\nreturn res", "gen": "var a [10]byte\nvar b [10]byte\nvar c [10]byte\nvar d [10]byte\nvar e [10]byte\nvar f [10]byte\nvar g [10]byte\nvar h [10]byte\nvar i [10]byte\nvar j [10]byte\nvar k [10]byte\nvar l [10]byte\nvar m [10]byte\nvar n [10]byte\nvar o [10]byte\nvar p [10]byte\nvar q [10]byte\nvar r [10]byte\nvar s [10]byte\nvar t [10]byte\nvar u [10]byte\nvar v [10]byte\nvar w [10]byte\nvar x [10]byte\nvar y [10]byte\nvar z [10]byte\nvar aa [10]byte\nvar bb [10]byte\nvar cc [10]byte\nvar dd [10]byte\nvar ee [10]byte\nvar ff [10]byte\nvar gg [10]byte\nvar hh [10]byte\nvar ii [10]byte\nvar jj [10]byte\nvar kk [10]byte\nvar ll [10]byte\nvar mm [10]byte\nvar nn [10]byte\nvar oo [10]byte\nvar pp [10]byte\nvar qq [10]byte\nvar rr [10]byte\nvar ss [10]byte\nvar tt [10]byte\nvar uu [10]byte\nvar vv [10]byte\nvar ww [10]byte\nvar xx [10]byte\nvar yy [10]byte\nvar zz [10]byte\nvar aaa [10]byte\nvar bbb [10]"}
{"tgt": "m := len(A)\nn := len(A[0])\nans := make([][]int, n)\nfor k := range ans {\n\tans[k] = make([]int, m)\n}\nfor r := 0; r < m; r++ {\n\tfor c := 0; c < n; c++ {\n\t\tans[c][r] = A[r][c]\n\t}\n}\nreturn ans", "gen": "var a [3]int\nvar b [4]int\na[2] = 1\nb[3] = 1\nfmt.Println(a, b)\n}\n\n// Output:\n// [0 0 1] [0 0 0 1]\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n<ASM>\n.LFB0:\nleaq -280(%rsp),%r11\ncmpq %fs:112,%r11\njnb .L34\nmovl $280,%r10d\nmovl $24,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L34:\npushq %rbp\nmovq %rsp,%rbp\npushq %r13\npushq %r12\npushq %rbx\nsubq $248,%rsp\nmovq %rdi,-264(%rbp)\nmovq $0,-224(%rbp)\nmovq $0,-216(%rbp)\nmovq $0,-208(%rbp)\n.LBB2:\nmovq <24>(%rbp),%rax\nmovq %rax,-56(%rbp)\nmovq <24>(%rbp),%rax\ntestq %rax,%rax\njg .L2\nmovq %rax,%rsi\nmovl $0,%edi\ncall <runtime.goPanicIndex@PLT>\n.L2:\nmovq <16>(%rbp),%rax\nmovq <8>(%rax),%rax\nmovq %rax,-64(%rbp)\nmovq -64(%rbp),%rbx\nmovq %rbx,%rdx\nmovq %rbx,%rsi\nleaq <type...6.7int>(%rip),%rdi\ncall <runtime.makeslice@PLT>\nmovq %rax,-256(%rbp)\nmovq %rbx,-248(%"}
{"tgt": "println(\"STR\", len(a))", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\tprint(a[i])\n\tprint(\" \")\n}\nprint(\"\\n\")\nfor i = 0; i < 10; i++ {\n\tprint(a[i])\n\tprint(\" \")\n}\nprint(\"\\n\")\nfor i = 0; i < 10; i++ {\n\tprint(a[i])\n\tprint(\" \")\n}\nprint(\"\\n\")\nfor i = 0; i < 10; i++ {\n\tprint(a[i])\n\tprint(\" \")\n}\nprint(\"\\n\")\nfor i = 0; i < 10; i++ {\n\tprint(a[i])\n\tprint(\" \")\n}\nprint(\"\\n\")\nfor i = 0; i < 10; i++ {\n\tprint(a[i])\n\tprint(\" \")\n}\nprint(\"\\n\")\nfor i = 0; i < 10; i++ {\n\tprint(a[i])\n\tprint(\" \")\n}\nprint(\"\\n\")\nfor i = 0; i < 10; i++ {\n\tprint(a[i])\n\tprint(\" \")\n}\nprint(\"\\n\")\nfor i = 0; i < 10; i++ {\n\tprint(a[i])\n\tprint(\" \")\n}\nprint(\"\\n\")\nfor i = 0; i < 10; i++ {\n\tprint(a[i])\n\tprint(\" \")\n}\nprint(\"\\n\")\nfor i = 0; i < 10; i++ {\n\tprint(a[i])\n\tprint(\" \")\n}\nprint(\"\\n\")\nfor i = 0"}
{"tgt": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nc, res := []int{}, [][]int{}\nsort.Ints(candidates)\nfindcombinationSum(candidates, target, 0, c, &res)\nreturn res", "gen": "fmt.Println(findCombinationSum([]int{2, 3, 6, 7}, 7))\n}\n"}
{"tgt": "for i := 0; i < len(A)-1; i++ {\n\tif A[i] == i {\n\t\tcontinue\n\t}\n\tif A[i] == i+1 && A[i+1] == i {\n\t\ti++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0;"}
{"tgt": "for n := 0; n < 32; n++ {\n\tsquare[n] = gf2MatrixTimes(mat, mat[n])\n}", "gen": "var a [32]byte\nvar b [32]byte\nvar c [32]byte\nvar d [32]byte\nvar e [32]byte\nvar f [32]byte\nvar g [32]byte\nvar h [32]byte\nvar i [32]byte\nvar j [32]byte\nvar k [32]byte\nvar l [32]byte\nvar m [32]byte\nvar n [32]byte\nvar o [32]byte\nvar p [32]byte\nvar q [32]byte\nvar r [32]byte\nvar s [32]byte\nvar t [32]byte\nvar u [32]byte\nvar v [32]byte\nvar w [32]byte\nvar x [32]byte\nvar y [32]byte\nvar z [32]byte\nvar aa [32]byte\nvar ab [32]byte\nvar ac [32]byte\nvar ad [32]byte\nvar ae [32]byte\nvar af [32]byte\nvar ag [32]byte\nvar ah [32]byte\nvar ai [32]byte\nvar aj [32]byte\nvar ak [32]byte\nvar al [32]byte\nvar am [32]byte\nvar an [32]byte\nvar ao [32]byte\nvar ap [32]byte\nvar aq [32]byte\nvar ar [32]byte\nvar as [32]byte\nvar at [32]byte\nvar au [32]byte\nvar av [32]byte\nvar aw [32]byte\nvar ax [32]byte\nvar ay [32]byte\nvar az [32]byte\nvar ba [32]byte\nvar bb [32]byte\nvar bc [32]byte\n"}
{"tgt": "for i := 0; i < n; i++ {\n\tif len(squares) != i {\n\t\tprintln(\"STR\", len(squares), \"STR\", i)\n\t}\n\tsquares[i] = i * i\n\tfor j := 0; j <= i; j++ {\n\t\tif v, ok := squares[j]; !ok || v != j*j {\n\t\t\tif !ok {\n\t\t\t\tprintln(\"STR\", j)\n\t\t\t} else {\n\t\t\t\tprintln(\"STR\", j, v)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "var m map[int][2]int\nfor i := 0; i < 10; i++ {\n\tm[i] = [2]int{i, i}\n}\nfor k, v := range m {\n\tfmt.Printf(\"k=%d, v=%d\\n\", k, v[0])\n}\n}\n\n// Output:\n// k=0, v=0\n// k=1, v=1\n// k=2, v=2\n// k=3, v=3\n// k=4, v=4\n// k=5, v=5\n// k=6, v=6\n// k=7, v=7\n// k=8, v=8\n// k=9, v=9\n\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```\n<ASM>\ncmpq %fs:112,%rsp\njnb .L55\nmovl $152,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL3:\nret\n.L55:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $104,%rsp\nmovq %rdi,-104(%rbp)\nmovq %rsi,-112(%rbp)\n.LBB39:\nmovq $0,-56(%rbp)\n.LBB40:\njmp .L36\n.L54:\n.LBB41:\nnop\n.LBE41:\n.LBB42:\n.LBB43:\ncmpq $0,-104(%rbp)\nje .L37\nmovq -104(%rbp),%rax\nmovq (%rax),%rax\njmp .L38\n.L37:\nmovl $0,%eax\n.L38:\ncmpq -5"}
{"tgt": "for j := 1; j <= 20; j++ {\n\tif num%j != 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a int\nfor i := 0; i < 20; i++ {\n\ta = a / i\n}\nprintln(a)\n}\n\n// Output:\n// 0\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n.LFB0:\ncmpq %fs:112,%rsp\njnb .L12\nmovl $40,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L12:\npushq %rbp\nmovq %rsp,%rbp\nsubq $32,%rsp\nmovq %rdi,-24(%rbp)\nmovb $0,-9(%rbp)\n.LBB2:\n.LBB3:\nmovq $1,-8(%rbp)\n.LBB4:\njmp .L2\n.L11:\n.LBB5:\nnop\n.LBE5:\n.LBB6:\n.LBB7:\ncmpq $-1,-8(%rbp)\nje .L3\ncmpq $0,-8(%rbp)\njne .L4\ncall <runtime.panicdivide@PLT>\n.L4:\nmovq -24(%rbp),%rax\ncqto\nidivq -8(%rbp)\nmovq %rdx,%rax\ntestq %rax,%rax\nsetne %al\njmp .L5\n.L3:\nmovl $0,%eax\n.L5:\ntestb %al,%al\nje .L6\n.LBB8:\n.LBB9:\nmovb $0,-9(%rbp)\nmovzbl -9(%rbp),%eax\njmp .L7\n.L6:\n.LBE9:\n.LBE8:\n.LBE7:\n.LBE6:\n.LBB10:\naddq $1,-8(%rbp)\n.L2:\n.LBE10:\ncmpq $20,-8"}
{"tgt": "if len(sorted) == 0 {\n\treturn nil\n}\nmid := len(sorted) / 2\nroot := &BST{Value: sorted[mid]}\nroot.Left = SortedSliceToBST(sorted[:mid])\nroot.Right = SortedSliceToBST(sorted[mid+1:])\nreturn root", "gen": "var a []int\na = append(a, 1)\na = append(a, 2)\na = append(a, 3)\na = append(a, 4)\na = append(a, 5)\na = append(a, 6)\na = append(a, 7)\na = append(a, 8)\na = append(a, 9)\na = append(a, 10)\na = append(a, 11)\na = append(a, 12)\na = append(a, 13)\na = append(a, 14)\na = append(a, 15)\na = append(a, 16)\na = append(a, 17)\na = append(a, 18)\na = append(a, 19)\na = append(a, 20)\na = append(a, 21)\na = append(a, 22)\na = append(a, 23)\na = append(a, 24)\na = append(a, 25)\na = append(a, 26)\na = append(a, 27)\na = append(a, 28)\na = append(a, 29)\na = append(a, 30)\na = append(a, 31)\na = append(a, 32)\na = append(a, 33)\na = append(a, 34)\na = append(a, 35)\na = append(a, 36)\na = append(a, 37)\na = append(a, 38)\na = append(a, 39)\na = append(a, 40)\na = append(a, 41)\na = append(a, 42)"}
{"tgt": "return x * y", "gen": "var a float32 = 1.0\nvar b float32 = 2.0\nvar c float32 = 3.0\nvar d float32 = 4.0\nvar e float32 = 5.0\nvar f float32 = 6.0\nvar g float32 = 7.0\nvar h float32 = 8.0\nvar i float32 = 9.0\nvar j float32 = 10.0\nvar k float32 = 11.0\nvar l float32 = 12.0\nvar m float32 = 13.0\nvar n float32 = 14.0\nvar o float32 = 15.0\nvar p float32 = 16.0\nvar q float32 = 17.0\nvar r float32 = 18.0\nvar s float32 = 19.0\nvar t float32 = 20.0\nvar u float32 = 21.0\nvar v float32 = 22.0\nvar w float32 = 23.0\nvar x float32 = 24.0\nvar y float32 = 25.0\nvar z float32 = 26.0\nvar aa float32 = 27.0\nvar bb float32 = 28.0\nvar cc float32 = 29.0\nvar dd float32 = 30.0\nvar ee float32 = 31.0\nvar ff float32 = 32.0\nvar gg float32 = 33.0\nvar hh float32 = 34.0\nvar ii float32 = 35.0\nvar jj float32 = 36.0\nvar kk float32 = 37.0\nvar ll float32 = 38.0\nvar mm float32 = 39"}
{"tgt": "i1 := 0\ni2 := 0\nval1 := 0\nval2 := 0\nfor i1 < len(version1) || i2 < len(version2) {\n\tval1, i1 = parseSeg(version1, i1)\n\tval2, i2 = parseSeg(version2, i2)\n\tif val1 > val2 {\n\t\treturn 1\n\t}\n\tif val1 < val2 {\n\t\treturn -1\n\t}\n}\nif i1 < len(version1) {\n\treturn 1\n}\nif i2 < len(version2) {\n\treturn -1\n}\nreturn 0", "gen": "fmt.Println(parseInt(\"42\", 10))\nfmt.Println(parseInt(\"-42\", 10))\nfmt.Println(parseInt(\"4193 with words\", 10))\nfmt.Println(parseInt(\"words and 987\", 10))\nfmt.Println(parseInt(\"-91283472332\", 10))\nfmt.Println(parseInt(\"12345678901234567890\", 10))\nfmt.Println(parseInt(\"123456789012345678901234567890\", 10))\nfmt.Println(parseInt(\"1234567890123456789012345678901234567890\", 10))\nfmt.Println(parseInt(\"12345678901234567890123456789012345678901234567890\", 10))\nfmt.Println(parseInt(\"123456789012345678901234567890123456789012345678901234567890\", 10))\nfmt.Println(parseInt(\"1234567890123456789012345678901234567890123456789012345678901234567890\", 10))\nfmt.Println(parseInt(\"12345678901234567890123456789012345678"}
{"tgt": "return this.Val", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "str := \"STR\"\nfmt.Println(longestPalindrome(str))", "gen": "fmt.Println(longestPalindrome(\"abba\"))\nfmt.Println(longestPalindrome(\"abcd\"))\nfmt.Println(longestPalindrome(\"abcba\"))\nfmt.Println(longestPalindrome(\"abcdcba\"))\nfmt.Println(longestPalindrome(\"abcdcbaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPal"}
{"tgt": "dat, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\nnamesList := string(dat)\nnamesList = strings.Replace(namesList, \"STR\", \"STR\", -1)\nnames := strings.Split(namesList, \"STR\")\nsort.Strings(names)\nnamesScore := 0\nfor index, name := range names {\n\tnamesScore += nameScore(name) * (index + 1)\n}\nfmt.Println(namesScore)", "gen": "var s string\nfmt.Scan(&s)\nfmt.Println(s)\n}\n"}
{"tgt": "res := 0\nsort.Ints(houses)\nsort.Ints(heaters)\nm, n := len(houses), len(heaters)\nindex := sort.SearchInts(heaters, houses[0])\nfor _, house := range houses {\n\tfor index < n && house > heaters[index] {\n\t\tindex++\n\t}\n\tif index == n {\n\t\treturn max(res, houses[m-1]-heaters[index-1])\n\t}\n\tleft := math.MaxInt32\n\tif index > 0 {\n\t\tleft = house - heaters[index-1]\n\t}\n\tright := heaters[index] - house\n\tres = max(res, min(left, right))\n}\nreturn res", "gen": "fmt.Println(maxProfit([]int{7, 1, 5, 3, 6, 4}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5}))\nfmt.Println(maxProfit([]int{7, 6, 4, 3, 1}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}))\nfmt.Println(maxProfit([]"}
{"tgt": "l, r := &maxHeap{}, &minHeap{}\nheap.Init(l)\nheap.Init(r)\nreturn MedianFinder{l, r}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "l := len(preorder)\nif l == 0 {\n\treturn nil\n}\nfor 1 < l && preorder[0] < preorder[l-1] {\n\tl--\n}\nreturn &TreeNode{\n\tVal:   preorder[0],\n\tLeft:  bstFromPreorder(preorder[1:l]),\n\tRight: bstFromPreorder(preorder[l:]),\n}", "gen": "preorder := []int{3, 9, 20, 15, 7}\nroot := bstFromPreorder(preorder)\nfmt.Println(root)\n}\n"}
{"tgt": "ln, err := net.Listen(\"STR\", \"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"STR\", conn.RemoteAddr())\n\tio.WriteString(conn, fmt.Sprint(time.Now()))\n\tconn.Close()\n}", "gen": "fmt.Println(\"Hello, playground\")\nl, err := net.Listen(\"tcp\", \":8080\")\nif err != nil {\n\tpanic(err)\n}\ndefer l.Close()\nfor {\n\tconn, err := l.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tgo handleConn(conn)\n}\n}\n"}
{"tgt": "i, l := 0, len(bits)-1\nfor i < l {\n\ti += bits[i] + 1\n}\nreturn i == l", "gen": "var a [10]int\na[10] = 1\n}\n\n// Output:\n// 10: runtime error: index out of range\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n<ASM>\n.LFB1:\ncmpq %fs:112,%rsp\njnb .L25\nmovl $40,%r10d\nmovl $24,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L25:\npushq %rbp\nmovq %rsp,%rbp\nsubq $32,%rsp\nmovb $0,-9(%rbp)\n.LBB21:\nmovq $0,-8(%rbp)\nmovq <24>(%rbp),%rax\nsubq $1,%rax\nmovq %rax,-24(%rbp)\n.LBB22:\n.LBB23:\njmp .L16\n.L24:\n.LBB24:\nnop\n.LBE24:\n.LBB25:\nmovq <24>(%rbp),%rax\ncmpq $0,-8(%rbp)\njs .L17\ncmpq %rax,-8(%rbp)\njl .L22\n.L17:\nmovq -8(%rbp),%rdx\nmovq %rax,%rsi\nmovq %rdx,%rdi\ncall <runtime.goPanicIndex@PLT>\n.L22:\nmovq <16>(%rbp),%rdx\nmovq -8(%rbp),%rax\nsalq $3,%rax\naddq %rdx,%rax\nmovq (%rax),%rdx\nmovq -8(%rbp),%rax\naddq %rdx,%rax\naddq $1,%rax\nmovq %rax,-8(%rbp)\n.L16:\n.LBE25:\nmovq -8(%rbp),%rax\ncmpq -"}
{"tgt": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "start := 0\nend := len(s) - 1\nfor start < end {\n\ts[start], s[end] = s[end], s[start]\n\tstart++\n\tend--\n}\nreturn s", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "for cur := t.root; cur != nil; {\n\tif cur.Key == key {\n\t\treturn cur\n\t} else if key < cur.Key {\n\t\tcur = cur.left\n\t} else {\n\t\tcur = cur.right\n\t}\n}\nreturn nil", "gen": "var bst *binaryTree.BST\nbst = binaryTree.NewBST()\nbst.Insert(10)\nbst.Insert(20)\nbst.Insert(30)\nbst.Insert(40)\nbst.Insert(50)\nbst.Insert(60)\nbst.Insert(70)\nbst.Insert(80)\nbst.Insert(90)\nbst.Insert(100)\nbst.Insert(110)\nbst.Insert(120)\nbst.Insert(130)\nbst.Insert(140)\nbst.Insert(150)\nbst.Insert(160)\nbst.Insert(170)\nbst.Insert(180)\nbst.Insert(190)\nbst.Insert(200)\nbst.Insert(210)\nbst.Insert(220)\nbst.Insert(230)\nbst.Insert(240)\nbst.Insert(250)\nbst.Insert(260)\nbst.Insert(270)\nbst.Insert(280)\nbst.Insert(290)\nbst.Insert(300)\nbst.Insert(310)\nbst.Insert(320)\nbst.Insert(330)\nbst.Insert(340)\nbst.Insert(350)\nbst.Insert(360)\nbst.Insert(370)\nbst.Insert(380)\nbst.Insert(390)\nbst.Insert(400)\nbst.Insert(410)\nbst.Insert(420)\nbst.Insert(430)\nbst.Insert(440)\nbst.Insert(450)\nbst.Insert(460)\nbst.Insert(470)\nbst.Insert(480)\nbst.Insert(49"}
{"tgt": "arr := randomSlice(0, 20, 10)\nnodeCnt := 0\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\nrotateNodes := make([]*gbtElement, 0, 0)\ngbt.InOrderWalk(gbt.Root(), func(GBTbinaryTreeIf, node interface{}) bool {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\trotateNodes = append(rotateNodes, node.(*gbtElement))\n\t}\n\treturn false\n})\nfor _, v := range rotateNodes {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\tgbt.LeftRotate(v)\n\t} else {\n\t\tgbt.RightRotate(v)\n\t}\n}\ngbt.InOrderWalk(gbt.Root(), checkGBT(t, &nodeCnt, *debug))\nif nodeCnt != len(arr) {\n\tt.Log(fmt.Sprintf(\"STR\", len(arr), nodeCnt))\n\tt.Fail()\n}", "gen": "runtime.RunOnGoExit(func"}
{"tgt": "return WordDictionary{}", "gen": "var a [27]int\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 4\na[4] = 5\na[5] = 6\na[6] = 7\na[7] = 8\na[8] = 9\na[9] = 10\na[10] = 11\na[11] = 12\na[12] = 13\na[13] = 14\na[14] = 15\na[15] = 16\na[16] = 17\na[17] = 18\na[18] = 19\na[19] = 20\na[20] = 21\na[21] = 22\na[22] = 23\na[23] = 24\na[24] = 25\na[25] = 26\na[26] = 27\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return xtime.Unix(int64(jt), 0)", "gen": "var t time.Time\nt.Unix(0, 0)\n}\n\n<ASM>\nmovq %fs:112,%rsp\njnb .L23\nmovl $88,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL3:\nret\n.L23:\npushq %rbp\nmovq %rsp,%rbp\nsubq $80,%rsp\nmovq %rdi,-72(%rbp)\nmovq %rsi,-80(%rbp)\ncmpq $0,-80(%rbp)\njne .L21\ncall <runtime.panicmem@PLT>\n.L21:\nmovq -80(%rbp),%rax\nmovq (%rax),%rax\nmovq %rax,-8(%rbp)\nmovq $0,-64(%rbp)\nmovq $0,-56(%rbp)\nmovq $0,-48(%rbp)\n.LBB17:\n.LBB18:\nleaq -32(%rbp),%rax\nmovq -8(%rbp),%rcx\nmovl $0,%edx\nmovq %rcx,%rsi\nmovq %rax,%rdi\ncall <time.Unix@PLT>\nmovq -32(%rbp),%rax\nmovq -24(%rbp),%rdx\nmovq %rax,-64(%rbp)\nmovq %rdx,-56(%rbp)\nmovq -16(%rbp),%rax\nmovq %rax,-48(%rbp)\nmovq -72(%rbp),%rcx\nmovq -64(%rbp),%rax\nmovq -56(%rbp),%rdx\nmovq %rax,(%rcx)\nmovq %rdx,<8>(%rcx)\nmovq -48(%rbp),%rax\nmovq %rax,<16>(%rcx)\n.LBE18"}
{"tgt": "return append(ints, added...)", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 4\nb[1] = 5\nb[2] = 6\nc[0] = 7\nc[1] = 8\nc[2] = 9\ncopy(a[:], b[:])\ncopy(b[:], c[:])\ncopy(c[:], a[:])\nfmt.Println(a[0], a[1], a[2])\nfmt.Println(b[0], b[1], b[2])\nfmt.Println(c[0], c[1], c[2])\n}\n\n// Output:\n// 4 5 6\n// 7 8 9\n// 1 2 3\n```\n\n### \u603b\u7ed3\n\n- \u5728 Go \u8bed\u8a00\u4e2d\uff0c`copy` \u51fd\u6570\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u5207\u7247\uff0c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u5207\u7247\u6216\u8005\u4e00\u4e2a\u6307\u9488\u3002\n- \u5982\u679c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u6307\u9488\uff0c\u90a3\u4e48\u7b2c\u4e00\u4e2a\u53c2\u6570\u5fc5\u987b\u662f\u4e00\u4e2a\u5207\u7247\u3002\n- \u5982\u679c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u5207\u7247\uff0c\u90a3\u4e48\u7b2c\u4e00\u4e2a\u53c2\u6570\u53ef\u4ee5\u662f\u4e00\u4e2a\u5207\u7247\u6216\u8005\u4e00\u4e2a\u6307\u9488\u3002\n- \u5982\u679c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u5207\u7247\uff0c\u90a3\u4e48\u7b2c\u4e00\u4e2a\u53c2\u6570\u7684\u957f\u5ea6\u5fc5\u987b\u5927\u4e8e\u7b49\u4e8e\u7b2c\u4e8c\u4e2a\u53c2\u6570\u7684\u957f\u5ea6\u3002\n- \u5982\u679c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u5207\u7247\uff0c\u90a3\u4e48\u7b2c\u4e00\u4e2a\u53c2\u6570\u7684\u957f\u5ea6\u5fc5\u987b\u5927\u4e8e\u7b49\u4e8e\u7b2c\u4e8c\u4e2a\u53c2\u6570\u7684\u957f\u5ea6\u3002\n- \u5982\u679c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u5207\u7247\uff0c\u90a3\u4e48\u7b2c\u4e00\u4e2a\u53c2\u6570\u7684\u957f\u5ea6\u5fc5\u987b\u5927\u4e8e\u7b49\u4e8e\u7b2c\u4e8c\u4e2a\u53c2\u6570\u7684\u957f\u5ea6\u3002\n- \u5982\u679c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u5207\u7247\uff0c"}
{"tgt": "data, err := base64.StdEncoding.DecodeString(b64)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(data)", "gen": "var s = \"1234567890\"\nvar b []byte\nb = []byte(s)\nvar s1 = \"1234567890\"\nvar b1 []byte\nb1 = []byte(s1)\nvar s2 = \"1234567890\"\nvar b2 []byte\nb2 = []byte(s2)\nvar s3 = \"1234567890\"\nvar b3 []byte\nb3 = []byte(s3)\nvar s4 = \"1234567890\"\nvar b4 []byte\nb4 = []byte(s4)\nvar s5 = \"1234567890\"\nvar b5 []byte\nb5 = []byte(s5)\nvar s6 = \"1234567890\"\nvar b6 []byte\nb6 = []byte(s6)\nvar s7 = \"1234567890\"\nvar b7 []byte\nb7 = []byte(s7)\nvar s8 = \"1234567890\"\nvar b8 []byte\nb8 = []byte(s8)\nvar s9 = \"1234567890\"\nvar b9 []byte\nb9 = []byte(s9)\nvar s10 = \"1234567890\"\nvar b10 []byte\nb10 = []byte(s10)\nvar s11 = \"1234567890\"\nvar b11 []byte\nb11 = []byte(s11)\nvar s12 = \"1234567890\"\nvar b12 []byte\nb12 = []byte(s12)\nvar s13 = \"1234567890\"\nvar b13"}
{"tgt": "h := fnv.New64a()\n_, _ = h.Write([]byte(fmt.Sprintf(\"STR\", key)))\nhashValue := h.Sum64()\nreturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))", "gen": "var a, b int\nfmt.Scan(&a, &b)\nfmt.Println(a + b)\n}\n"}
{"tgt": "return fmt.Sprintf(\"STR\", p.Name, p.Age)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\n"}
{"tgt": "parent := this\nfor _, ch := range prefix {\n\tif child, ok := parent.Children[ch]; ok {\n\t\tparent = child\n\t\tcontinue\n\t}\n\treturn false\n}\nreturn true", "gen": "fmt.Println(Solution([]string{\"hello\", \"world\", \"leetcode\"}))\n}\n"}
{"tgt": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)", "gen": "var a int\nvar b int\nvar c int\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\ta++\n\t}\n\tb++\n}\nc = a + b\nfmt.Println(c)\n}"}
{"tgt": "close(p.work)\np.wg.Wait()", "gen": "var wg sync.WaitGroup\nch := make(chan int)\nwg.Add(1)\ngo func() {\n\tdefer wg.Done()\n\t<-ch\n}()\nwg.Wait()\n}\n\n// 1. \u6808\u6ea2\u51fa\n// 2. \u5806\u6808\u6ea2\u51fa\n// 3. \u5806\u6808\u6ea2\u51fa\n// 4. \u5806\u6808\u6ea2\u51fa\n// 5. \u5806\u6808\u6ea2\u51fa\n// 6. \u5806\u6808\u6ea2\u51fa\n// 7. \u5806\u6808\u6ea2\u51fa\n// 8. \u5806\u6808\u6ea2\u51fa\n// 9. \u5806\u6808\u6ea2\u51fa\n// 10. \u5806\u6808\u6ea2\u51fa\n// 11. \u5806\u6808\u6ea2\u51fa\n// 12. \u5806\u6808\u6ea2\u51fa\n// 13. \u5806\u6808\u6ea2\u51fa\n// 14. \u5806\u6808\u6ea2\u51fa\n// 15. \u5806\u6808\u6ea2\u51fa\n// 16. \u5806\u6808\u6ea2\u51fa\n// 17. \u5806\u6808\u6ea2\u51fa\n// 18. \u5806\u6808\u6ea2\u51fa\n// 19. \u5806\u6808\u6ea2\u51fa\n// 20. \u5806\u6808\u6ea2\u51fa\n// 21. \u5806\u6808\u6ea2\u51fa\n// 22. \u5806\u6808\u6ea2\u51fa\n// 23. \u5806\u6808\u6ea2\u51fa\n// 24. \u5806\u6808\u6ea2\u51fa\n// 25. \u5806\u6808\u6ea2\u51fa\n// 26. \u5806\u6808\u6ea2\u51fa\n// 27. \ufffd\ufffd"}
{"tgt": "m := make(map[int]struct{})\nfor _, num := range nums1 {\n\tm[num] = struct{}{}\n}\nnums := make([]int, 0)\nfor _, num := range nums2 {\n\tif _, ok := m[num]; ok {\n\t\tnums = append(nums, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn nums", "gen": "var m map[int]struct {\n\ta, b, c int\n}\nm = make(map[int]struct {\n\ta, b, c int\n})\nfor i := 0; i < 1000000; i++ {\n\tm[i] = struct {\n\t\ta, b, c int\n\t}{i, i, i}\n}\nvar s []int\nfor i := 0; i < 1000000; i++ {\n\ts = append(s, i)\n}\nfor i := 0; i < 1000000; i++ {\n\ts[i] = i\n}\nfor i := 0; i < 1000000; i++ {\n\ts[i] = i\n}\nfor i := 0; i < 1000000; i++ {\n\ts[i] = i\n}\nfor i := 0; i < 1000000; i++ {\n\ts[i] = i\n}\nfor i := 0; i < 1000000; i++ {\n\ts[i] = i\n}\nfor i := 0; i < 1000000; i++ {\n\ts[i] = i\n}\nfor i := 0; i < 1000000; i++ {\n\ts[i] = i\n}\nfor i := 0; i < 1000000; i++ {\n\ts[i] = i\n}\nfor i := 0; i < 1000000; i++ {\n\ts[i] = i\n}\nfor i := 0; i < 1000000; i++ {\n\ts[i] = i\n}\nfor i := 0; i < 1000000"}
{"tgt": "return h.FromHexString(string(b))", "gen": "var hash go.metainfo.Hash\nhash.FromHexString(\"1234567890123456789012345678901234567890\")\nfmt.Println(hash)\n}\n\n// Output:\n// 1234567890123456789012345678901234567890\n```\n\n### 2.2.2. \u6c47\u7f16\u4ee3\u7801\n\n```asm\n// \u6c47\u7f16\u4ee3\u7801\n.LVL7:\nret\n.L32:\npushq %rbp\nmovq %rsp,%rbp\npushq %rbx\nsubq $72,%rsp\nmovq %rdi,-72(%rbp)\nmovq $0,-64(%rbp)\nmovq $0,-56(%rbp)\n.LBB20:\n.LBB21:\nleaq -48(%rbp),%rax\nsubq $8,%rsp\npushq <32>(%rbp)\npushq <24>(%rbp)\npushq <16>(%rbp)\nmovq %rax,%rdi\ncall <runtime.slicebytetostring@PLT>\naddq $32,%rsp\nmovq %rax,%rcx\nmovq %rdx,%rbx\nmovq -72(%rbp),%rax\nmovq %rcx,%rsi\nmovq %rax,%rdi\ncall <go.metainfo.Hash.FromHexString>\nmovq %rax,-64(%rbp)\nmovq %rdx,-56(%rbp)\nmovq -64(%rbp),%rax\nmovq -56(%rbp),%rdx\n.LBE21:\n.LBE20:\nmovq -8(%rbp),%rbx\nleave\nret\n```\n\n### 2.2.3. \ufffd\ufffd"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif denoms := EgyptianFractions(tc.numerator, tc.denominator); !reflect.DeepEqual(tc.denominators, denoms) {\n\t\tt.Errorf(\"STR\", tc.denominators, denoms)\n\t}\n}", "gen": "fmt.Println(\"Day 252\")\nfmt.Println(\"Part 1:\", part1())\nfmt.Println(\"Part 2:\", part2())\n}\n"}
{"tgt": "log.SetFlags(0)\nvar err error\ntpl := template.New(\"STR\")\ntpl = tpl.Funcs(template.FuncMap{\n\t\"STR\": func(str string) string {\n\t\treturn strings.ToUpper(str)\n\t},\n})\ntpl, err = tpl.ParseFiles(\"STR\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nerr = tpl.ExecuteTemplate(os.Stdout, \"STR\", Page{\n\tTitle: \"STR\",\n\tBody:  \"STR\",\n})\nif err != nil {\n\tlog.Fatalln(err)\n}", "gen": "log.SetFlags(0)\nt := template.New(\"\")\nt = t.Funcs(template.FuncMap{\n\t\"f\": func(s string) string {\n\t\treturn strings.ToUpper(s)\n\t},\n})\nt, err := t.ParseFiles(\"index.html\")\nif err != nil {\n\tlog.Fatalln(err)\n}\np := Page{Title: \"Hello, World\"}\nerr = t.ExecuteTemplate(os.Stdout, \"index.html\", p)\nif err != nil {\n\tlog.Fatalln(err)\n}\n}\n\n// Output:\n// <HTML><HEAD><TITLE>HELLO, WORLD</TITLE></HEAD><BODY>HELLO, WORLD</BODY></HTML>\n\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```\n<ASM>\n.LFB0:\nleaq -488(%rsp),%r11\ncmpq %fs:112,%r11\njnb .L10\nmovl $488,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L10:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $440,%rsp\nmovl $0,%edi\ncall <log.SetFlags@PLT>\nmovq $0,-352(%rbp)\nmovq $0,-344(%rbp)\nleaq <.LC24>(%rip),%r12\nmovl $10,%r13d\nmovq %r12,%rcx\nmovq %r13,%rbx\nmovq %r12,%rax\nmovq %r13,%rdx\nmovq %rdx,%rax\nmovq %rcx"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA `structs:\"STR\"`\n\tC  int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif ok {\n\tt.Error(\"STR\")\n}", "gen": "var t TestHasZero_OmitNested\nt.B.i1.d = 123\nt.B.i2.d = 123\nt.B.i3.d = 123\nt.B.i4.d = 123\nt.B.i5.d = 123\nt.B.i6.d = 123\nt.B.i7.d = 123\nt.B.i8.d = 123\nt.B.i9.d = 123\nt.B.i10.d = 123\nt.B.i11.d = 123\nt.B.i12.d = 123\nt.B.i13.d = 123\nt.B.i14.d = 123\nt.B.i15.d = 123\nt.B.i16.d = 123\nt.B.i17.d = 123\nt.B.i18.d = 123\nt.B.i19.d = 123\nt.B.i20.d = 123\nt.B.i21.d = 123\nt.B.i22.d = 123\nt.B.i23.d = 123\nt.B.i24.d = 123\nt.B.i25.d = 123\nt.B.i26.d = 123\nt.B.i27.d = 123\nt.B.i28.d = 123\nt.B.i29.d = 123\nt.B.i30.d = 123\nt.B.i31.d = 123\n"}
{"tgt": "digits := convert(N + 1)\nbits := len(digits)\nnoRepeat := 0\nfor b := 1; b < bits; b++ {\n\tnoRepeat += 9 * count(9, b-1)\n}\nhasSeen := make(map[int]bool, 10)\nfor b := 0; b < bits; b++ {\n\td := 0\n\tif b == 0 {\n\t\td = 1\n\t}\n\tfor ; d < digits[b]; d++ {\n\t\tif !hasSeen[d] {\n\t\t\tnoRepeat += count(9-b, bits-b-1)\n\t\t}\n\t}\n\tif hasSeen[digits[b]] {\n\t\tbreak\n\t}\n\thasSeen[digits[b]] = true\n}\nreturn N - noRepeat", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar b = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar c = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar d = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar e = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar f = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar g = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar h = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar i = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar j = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar k = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar m = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar n = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar o = []int{1, 2, 3, 4, 5, 6,"}
{"tgt": "return me[0] == \"STR\"", "gen": "var a [3]int\na[1] = 1\nif a[1] != 1 {\n\tpanic(\"a[1] != 1\")\n}\nif a[2] != 0 {\n\tpanic(\"a[2] != 0\")\n}\nif a[3] != 0 {\n\tpanic(\"a[3] != 0\")\n}\nif a[4] != 0 {\n\tpanic(\"a[4] != 0\")\n}\nif a[5] != 0 {\n\tpanic(\"a[5] != 0\")\n}\nif a[6] != 0 {\n\tpanic(\"a[6] != 0\")\n}\nif a[7] != 0 {\n\tpanic(\"a[7] != 0\")\n}\nif a[8] != 0 {\n\tpanic(\"a[8] != 0\")\n}\nif a[9] != 0 {\n\tpanic(\"a[9] != 0\")\n}\nif a[10] != 0 {\n\tpanic(\"a[10] != 0\")\n}\nif a[11] != 0 {\n\tpanic(\"a[11] != 0\")\n}\nif a[12] != 0 {\n\tpanic(\"a[12] != 0\")\n}\nif a[13] != 0 {\n\tpanic(\"a[13] != 0\")\n}\nif a[14] != 0 {\n\tpanic(\"a[14] != 0\")\n}\nif a[15] != 0 {\n\tpanic(\"a[15] != 0\")\n}\nif a[16] != 0 {\n\tpanic(\"a[16] != 0\")\n}\nif a[17] != 0 {\n\tpanic(\"a[17"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil {\n\t\t\tmax = max.Right\n\t\t}\n\t\tmax.Right = root\n\t\troot, root.Left = root.Left, nil\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   0x5555,\n\t\twant: 8,\n\t},\n}\nfor _, tt := range tests {\n\tgot := hammingWeight(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z int\na = 1\nb = 2\nc = 3\nd = 4\ne = 5\nf = 6\ng = 7\nh = 8\ni = 9\nj = 10\nk = 11\nl = 12\nm = 13\nn = 14\no = 15\np = 16\nq = 17\nr = 18\ns = 19\nt = 20\nu = 21\nv = 22\nw = 23\nx = 24\ny = 25\nz = 26\nfmt.Println(hammingWeight(a))\nfmt.Println(hammingWeight(b))\nfmt.Println(hammingWeight(c))\nfmt.Println(hammingWeight(d))\nfmt.Println(hammingWeight(e))\nfmt.Println(hammingWeight(f))\nfmt.Println(hammingWeight(g))\nfmt.Println(hammingWeight(h))\nfmt.Println(hammingWeight(i))\nfmt.Println(hammingWeight(j))\nfmt.Println(hammingWeight(k))\nfmt.Println(hammingWeight(l))\nfmt.Println(hammingWeight(m))\nfmt.Println(hammingWeight(n))\nfmt.Println(hammingWeight(o))\nfmt.Println(hammingWeight(p))\nfmt.Println(hammingWeight(q))\nfmt.Println(hammingWeight(r))\nfmt.Println(hammingWeight(s))\nfmt.Println(hammingWeight(t))\nfmt.Println(hammingWeight(u))"}
{"tgt": "if a == nil && b == nil {\n\treturn true\n}\nif len(a) != len(b) {\n\treturn false\n}\nfor i := range a {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar ba [10]int\nvar bb [10]int\nvar bc [10]int\n"}
{"tgt": "return xtime.Unix(int64(jt), 0), nil", "gen": "var t time.Time\nt = time.Now()\nfmt.Println(t)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 0},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 11},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 19},\n\t\tans1208{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s, p.t, p.maxCost))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{}\n} else if n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{intervals[0]}\nfor _, cur := range intervals[1:] {\n\tprevious := res[len(res)-1]\n\tif cur.Start <= previous.End {\n\t\tend := previous.End\n\t\tif cur.End > end {\n\t\t\tend = cur.End\n\t\t}\n\t\tres = append(res[:len(res)-1], Interval{Start: previous.Start, End: end})\n\t} else {\n\t\tres = append(res, cur)\n\t}\n}\nreturn res", "gen": "fmt.Println(merge([]Interval{{1, 3}, {2, 6}, {8, 10}, {15, 18}}))\n}\n"}
{"tgt": "result := make([]int, 0, len(left)+len(right))\nfor len(left) > 0 || len(right) > 0 {\n\tif len(left) == 0 {\n\t\treturn append(result, right...)\n\t}\n\tif len(right) == 0 {\n\t\treturn append(result, left...)\n\t}\n\tif left[0] <= right[0] {\n\t\tresult = append(result, left[0])\n\t\tleft = left[1:]\n\t} else {\n\t\tresult = append(result, right[0])\n\t\tright = right[1:]\n\t}\n}\nreturn result", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 4\nb[1] = 5\nb[2] = 6\nc[0] = 7\nc[1] = 8\nc[2] = 9\na[1], a[2] = b[0], b[1]\na[0], a[1] = c[0], c[1]\na[2], a[0] = c[2], c[0]\nfmt.Println(a[0], a[1], a[2])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "t.Parallel()\nd := NewTimeMap()\nd.Set(1, 1, 0)\nd.Set(1, 2, 2)\nif result := d.Get(1, 1); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 3); result != 2 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 5)\nif result := d.Get(1, 0); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 10); result != 1 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 0)\nd.Set(1, 2, 0)\nif result := d.Get(1, 0); result != 2 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(2, 0); result != nil {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, -1); result != nil {\n\tt.Errorf(\"STR\")\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{2},\n\t\t\t{3, 4},\n\t\t\t{6, 5, 7},\n\t\t\t{4, 1, 8, 3},\n\t\t},\n\t\t11},\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{1},\n\t\t\t{2, 3},\n\t\t},\n\t\t3},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := minimumTotal(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "pairs := [...][2]int{{15, 26}, {1000, 1366}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p16(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var p16 [2]int\np16[0] = 15\np16[1] = 26\nvar p1000 [2]int\np1000[0] = 1366\np1000[1] = 1000\nvar p1 [2]int\np1[0] = 15\np1[1] = 26\nvar p2 [2]int\np2[0] = 1366\np2[1] = 1000\nvar p3 [2]int\np3[0] = 15\np3[1] = 26\nvar p4 [2]int\np4[0] = 1366\np4[1] = 1000\nvar p5 [2]int\np5[0] = 15\np5[1] = 26\nvar p6 [2]int\np6[0] = 1366\np6[1] = 1000\nvar p7 [2]int\np7[0] = 15\np7[1] = 26\nvar p8 [2]int\np8[0] = 1366\np8[1] = 1000\nvar p9 [2]int\np9[0] = 15\np9[1] = 26\nvar p10 [2]int\np10[0] = 1366\np10[1] = 1000\nvar p11 [2]int\np11[0] = 15\np11[1] = 26\nvar p12 [2]int\np12[0] = 1366\np12[1] = 1000\nvar p13 [2]int\np13[0]"}
{"tgt": "m := [26]int{}\nfor _, b := range B {\n\tcount := counter(b)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tm[i] = count[i]\n\t\t}\n\t}\n}\nres := []string{}\nfor _, a := range A {\n\tcount := counter(a)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tcontinueL\n\t\t}\n\t}\n\tres = append(res, a)\n}\nreturn res", "gen": "var a [26]string\nfor i := 0; i < 26; i++ {\n\ta[i] = \"a\"\n}\nfor i := 0; i < 26; i++ {\n\ta[i] = \"b\"\n}\nfor i := 0; i < 26; i++ {\n\ta[i] = \"c\"\n}\nfor i := 0; i < 26; i++ {\n\ta[i] = \"d\"\n}\nfor i := 0; i < 26; i++ {\n\ta[i] = \"e\"\n}\nfor i := 0; i < 26; i++ {\n\ta[i] = \"f\"\n}\nfor i := 0; i < 26; i++ {\n\ta[i] = \"g\"\n}\nfor i := 0; i < 26; i++ {\n\ta[i] = \"h\"\n}\nfor i := 0; i < 26; i++ {\n\ta[i] = \"i\"\n}\nfor i := 0; i < 26; i++ {\n\ta[i] = \"j\"\n}\nfor i := 0; i < 26; i++ {\n\ta[i] = \"k\"\n}\nfor i := 0; i < 26; i++ {\n\ta[i] = \"l\"\n}\nfor i := 0; i < 26; i++ {\n\ta[i] = \"m\"\n}\nfor i := 0; i < 26; i++ {\n\ta[i] = \"n\"\n}\nfor i := 0; i < 26; i++ {\n\ta[i] = \"o\"\n}\nfor i := 0; i < 26; i++ {\n\ta[i] = \"p"}
{"tgt": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\ntmp := nums[0]\nmax := tmp\nfor i := 1; i < n; i++ {\n\tif tmp < 0 {\n\t\ttmp = nums[i]\n\t} else {\n\t\ttmp += nums[i]\n\t}\n\tif max < tmp {\n\t\tmax = tmp\n\t}\n}\nreturn max", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\tprintln(a[i])\n}\n}\n\n// Output:\n// 0\n// 1\n// 2\n// 3\n// 4\n// 5\n// 6\n// 7\n// 8\n// 9\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n.LFB0:\ncmpq %fs:112,%rsp\njnb .L21\nmovl $56,%r10d\nmovl $24,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L21:\npushq %rbp\nmovq %rsp,%rbp\nsubq $48,%rsp\nmovq $0,-32(%rbp)\n.LBB2:\nmovq <24>(%rbp),%rax\nmovq %rax,-40(%rbp)\n.LBB3:\ncmpq $0,-40(%rbp)\njne .L2\n.LBB4:\n.LBB5:\nmovq $0,-32(%rbp)\nmovq -32(%rbp),%rax\njmp .L3\n.L2:\n.LBE5:\n.LBE4:\n.LBE3:\n.LBB6:\ncmpq $1,-40(%rbp)\njne .L4\n.LBB7:\n.LBB8:\nmovq <24>(%rbp),%rax\ntestq %rax,%rax\njg .L5\nmovq %rax,%rsi\nmovl $0,%edi\ncall <runtime.goPanicIndex@PLT>\n.L5:\nmovq <16>(%rbp),%rax\nmovq %rax,-32(%rbp)\nmovq -32(%"}
{"tgt": "hash := uint32(0)\nfor i := len(sep) - 1; i >= 0; i-- {\n\thash = hash*PrimeRK + uint32(sep[i])\n}\nvar pow, sq uint32 = 1, PrimeRK\nfor i := len(sep); i > 0; i >>= 1 {\n\tif i&1 != 0 {\n\t\tpow *= sq\n\t}\n\tsq *= sq\n}\nreturn hash, pow", "gen": "var a [10]int\nvar b int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tb += a[i]\n}\nprintln(b)\n}\n\n// Output:\n// 45\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n<ASM>\n.LVL11:\nret\n.L179:\npushq %rbp\nmovq %rsp,%rbp\nsubq $48,%rsp\nmovl $0,-36(%rbp)\nmovl $0,-40(%rbp)\n.LBB154:\nmovl $0,-4(%rbp)\n.LBB155:\nmovq <24>(%rbp),%rax\nsubq $1,%rax\nmovq %rax,-24(%rbp)\n.LBB156:\njmp .L164\n.L177:\n.LBB157:\nnop\n.LBE157:\n.LBB158:\nmovq <24>(%rbp),%rax\ncmpq $0,-24(%rbp)\njs .L165\ncmpq %rax,-24(%rbp)\njl .L174\n.L165:\nmovq -24(%rbp),%rdx\nmovq %rax,%rsi\nmovq %rdx,%rdi\ncall <runtime.goPanicIndex@PLT>\n.L174:\nmovl -4(%rbp),%eax\nimull $16777619,%eax,%ecx\nmovq <16>(%rbp),%rsi\nmovq -24(%rbp),%rax\naddq %rsi,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\naddl %ecx,%eax\nmov"}
{"tgt": "b, _ := ioutil.ReadFile(\"STR\")\ns := strings.Replace(string(b), \"STR\", \"STR\", -1)\nnumData := strings.Split(s, \"STR\")\nfor _, n := range numData {\n\tnumber, err := strconv.Atoi(n)\n\tif err == nil {\n\t\tdata = append(data, number)\n\t}\n}", "gen": "var data [3]int\nvar line string\nvar err error\nif line, err = ioutil.ReadFile(\"input.txt\"); err != nil {\n\tpanic(err)\n}\nvar lines []string\nif lines = strings.Split(strings.Replace(line, \"\\r\\n\", \"\\n\", -1), \"\\n\"); err != nil {\n\tpanic(err)\n}\nfor _, line := range lines {\n\tvar nums [3]int\n\tvar err error\n\tif nums, err = strconv.Atoi(line); err != nil {\n\t\tpanic(err)\n\t}\n\tdata[0] += nums[0]\n\tdata[1] += nums[1]\n\tdata[2] += nums[2]\n}\nfmt.Println(data[0], data[1], data[2])\n}\n"}
{"tgt": "if len(A) == len(A[0]) {\n\tfor i := 0; i < len(A); i++ {\n\t\tfor j := 0; j < len(A); j++ {\n\t\t\tif i == j {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]\n\t\t}\n\t}\n\treturn A\n}\nres := make([][]int, len(A[0]))\nfor i := 0; i < len(res); i++ {\n\tres[i] = make([]int, len(A))\n\tfor j := 0; j < len(A); j++ {\n\t\tres[i][j] = A[j][i]\n\t}\n}\nreturn res", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := SumRevLLNum(tc.first, tc.second); !equal(result, tc.sum) {\n\t\tt.Errorf(\"STR\",\n\t\t\ttcid, String(result), String(tc.sum))\n\t}\n}", "gen": "fmt.Println(\"Day 452\")\nfmt.Println(\"Part 1:\", part1())\nfmt.Println(\"Part 2:\", part2())\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tm: 3,\n\t\tn: 3,\n\t\tops: [][]int{\n\t\t\t{2, 2},\n\t\t\t{3, 3},\n\t\t},\n\t\twant: 4,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxCount(tt.m, tt.n, tt.ops)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.m, got, tt.want)\n\t}\n}", "gen": "fmt.Println(problem598.MaxCount([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\n}\n"}
{"tgt": "n := len(quality)\nworkers := make([][2]float64, n)\nfor i := 0; i < n; i++ {\n\tw, q := float64(wage[i]), float64(quality[i])\n\tworkers[i][0], workers[i][1] = w/q, q\n}\nsort.Slice(workers, func(i, j int) bool {\n\treturn workers[i][0] < workers[j][0]\n})\nres := math.MaxFloat64\nsum := 0.\nh := floatHeap{}\nfor _, w := range workers {\n\tsum += w[1]\n\theap.Push(&h, w[1])\n\tif len(h) > K {\n\t\tsum -= heap.Pop(&h).(float64)\n\t}\n\tif len(h) == K {\n\t\tres = min(res, sum*w[0])\n\t}\n}\nreturn res", "gen": "fmt.Println(mincostToHireWorkers([]int{10, 20, 5}, []int{7, 15, 20}))\n}\n"}
{"tgt": "flag.Parse()\nroots := flag.Args()\nif len(roots) == 0 {\n\troots = []string{\"STR\"}\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, root := range roots {\n\t\twalkDir(root, fileSizes)\n\t}\n\tclose(fileSizes)\n}()\nvar nfiles, nbytes int64\nfor size := range fileSizes {\n\tnfiles++\n\tnbytes += size\n}\nprintDiskUsage(nfiles, nbytes)", "gen": "flag.Parse()\nargs := flag.Args()\nif len(args) != 2 {\n\tfmt.Println(\"Usage:\", os.Args[0], \"source destination\")\n\tos.Exit(1)\n}\nsrc, dst := args[0], args[1]\nfileSizes := make(chan int64)\ngo func() {\n\tfor i := 0; i < 100; i++ {\n\t\tfileSizes <- calculateSize(src)\n\t}\n\tclose(fileSizes)\n}()\nroots := make(chan string)\ngo func() {\n\tfor dir := range roots {\n\t\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !info.IsDir() {\n\t\t\t\troots <- path\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t}\n\tclose(roots)\n}()\ngo func() {\n\tfor dir := range roots {\n\t\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !info.IsDir() {\n\t\t\t\tfileSizes <- calculateSize(path)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t}\n\tclose(fileSizes)\n}()\ntotal := int64(0)\nfor size := range fileSizes {\n\ttotal += size\n}\nprintDiskUsage(src, dst, total)\n}"}
{"tgt": "var min int\ntotalPeople := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\ttotalPeople++\n\t}\n}\nif totalPeople < 2 {\n\treturn 0\n}\nmiddle := (totalPeople / 2) + (totalPeople % 2)\nindex := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\tmiddle--\n\t}\n\tif middle == 0 {\n\t\tindex = i\n\t\tbreak\n\t}\n}\nleftZero := 0\nleftZeroFound := false\nfor j := index - 1; j >= 0; j-- {\n\tif !leftZeroFound && seating[j] == 0 {\n\t\tleftZero = j\n\t\tleftZeroFound = true\n\t} else if seating[j] == 1 && j < leftZero {\n\t\tmin += abs(j - leftZero)\n\t\tleftZero--\n\t}\n}\nrightZero := 0\nrightZeroFound := false\nfor j := index + 1; j < len(seating); j++ {\n\tif !rightZeroFound && seating[j] == 0 {\n\t\trightZero = j\n\t\trightZeroFound = true\n\t} else if seating[j] == 1 && j > rightZero {\n\t\tmin += abs(j - rightZero)\n\t\trightZero++\n\t}\n}\nreturn min", "gen": "var a [3]int\nvar b [3]int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar ba int\nvar bb int\nvar bc int\nvar bd int\nvar be int\nvar bf int\nvar bg int\nvar bh int\nvar bi int\nvar bj int\nvar bk int\nvar bl int\nvar bm int\nvar bn int\nvar bo int\nvar bp int\nvar bq int\nvar br int\nvar bs int\nvar bt int\nvar bu int\nvar bv int\nvar bw int\nvar bx int\nvar by int\nvar bz int\nvar ca int\nvar cb int\nvar cc int\nvar cd int\nvar ce int\nvar cf int\nvar cg int\nvar ch int\nvar ci int\nvar cj int\nvar ck int\nvar cl int\nvar cm int\nvar cn int\nvar co int\nvar cp int\n"}
{"tgt": "sum := 0\nprev := 1\ncurr := 1\nfor curr <= 4e6 {\n\tprev, curr = curr, prev+curr\n\tif curr%2 == 0 {\n\t\tsum += curr\n\t}\n}\nfmt.Println(sum)", "gen": "var a int\nvar b int\na = 1\nb = 1\nfor i := 0; i < 4000000; i++ {\n\ta, b = b, a+b\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "stack := make([]int, 0)\nresult := make([]int, len(T))\nfor i, t := range T {\n\tfor len(stack) > 0 && T[stack[len(stack)-1]] < t {\n\t\tresult[stack[len(stack)-1]] = i - stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t}\n\tstack = append(stack, i)\n}\nfor _, i := range stack {\n\tresult[i] = 0\n}\nreturn result", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 2}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "out := 100\nif x := p33(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "p33 := 100\np34 := 100\np35 := 100\np36 := 100\np37 := 100\np38 := 100\np39 := 100\np40 := 100\np41 := 100\np42 := 100\np43 := 100\np44 := 100\np45 := 100\np46 := 100\np47 := 100\np48 := 100\np49 := 100\np50 := 100\np51 := 100\np52 := 100\np53 := 100\np54 := 100\np55 := 100\np56 := 100\np57 := 100\np58 := 100\np59 := 100\np60 := 100\np61 := 100\np62 := 100\np63 := 100\np64 := 100\np65 := 100\np66 := 100\np67 := 100\np68 := 100\np69 := 100\np70 := 100\np71 := 100\np72 := 100\np73 := 100\np74 := 100\np75 := 100\np76 := 100\np77 := 100\np78 := 100\np79 := 100\np80 := 100\np81 := 100\np82 := 100\n"}
