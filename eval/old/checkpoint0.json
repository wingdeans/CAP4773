{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif sum := SumBSTRange(tc.root, tc.a, tc.b); sum != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, sum)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "return &linkLoop{\n\tHead: &linkLoopNode{},\n}", "gen": "var d *linkLoopNode\nd = new(linkLoopNode)\nd.linkLoop = new(linkLoop)\nd.linkLoop.linkLoopNode = d\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname __morestack runtime.morestack"}
{"tgt": "return bindataRead(\n\t_assetsHomeCatJpg,\n\t\"STR\",\n)", "gen": "var a [4]int\nvar b [4]int\nvar c [4]int\nvar d [4]int\nvar e [4]int\nvar f [4]int\nvar g [4]int\nvar h [4]int\nvar i [4]int\nvar j [4]int\nvar k [4]int\nvar l [4]int\nvar m [4]int\nvar n [4]int\nvar o [4]int\nvar p [4]int\nvar q [4]int\nvar r [4]int\nvar s [4]int\nvar t [4]int\nvar u [4]int\nvar v [4]int\nvar w [4]int\nvar x [4]int\nvar y [4]int\nvar z [4]int\nvar aa [4]int\nvar ab [4]int\nvar ac [4]int\nvar ad [4]int\nvar ae [4]int\nvar af [4]int\nvar ag [4]int\nvar ah [4]int\nvar ai [4]int\nvar aj [4]int\nvar ak [4]int\nvar al [4]int\nvar am [4]int\nvar an [4]int\nvar ao [4]int\nvar ap [4]int\nvar aq [4]int\nvar ar [4]int\nvar as [4]int\nvar at [4]int\nvar au [4]int\nvar av [4]int\nvar aw [4]int\nvar ax [4]int\nvar ay [4]int\nvar az [4]int\nvar aaa [4]int\nvar aab [4]int\nvar aac [4]int\nvar aad [4]int\nvar aae [4]int\nvar aaf [4]int\nvar aag [4]int\nvar aah [4]int\nvar aai [4]int\n"}
{"tgt": "max := 1000\nsum := 0\nfor i := 1; i < max; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)", "gen": "var a int\nvar b int\nvar c int\nvar d int\na = 1\nb = 1\nfor i := 0; i < 1000; i++ {\n\tif i%2 == 0 {\n\t\tc = a * b\n\t\td = a + b\n\t\ta = d\n\t\tb = c\n\t} else {\n\t\tc = a - b\n\t\td = a + b\n\t\ta = d\n\t\tb = c\n\t}\n}\nfmt.Println(a, b, c, d)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.locs); !reflect.DeepEqual(bonuses, tc.bonuses) {\n\t\tt.Errorf(\"STR\", tc.bonuses, bonuses)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "max := 9999\nbiggestPandigital := 0\nvar numberMultiplied int\nfor i := max; i > 0; i-- {\n\tnumberMultiplied = i\n\tfor j := 1; len(digits(numberMultiplied)) <= 9; j++ {\n\t\tnumberMultiplied = concatenMultiplication(i, j)\n\t\tif IsPandigital(numberMultiplied) && numberMultiplied > biggestPandigital {\n\t\t\tfmt.Println(numberMultiplied)\n\t\t\tbiggestPandigital = numberMultiplied\n\t\t}\n\t}\n}", "gen": "var a, b int\nfmt.Scan(&a, &b)\nfmt.Println(a * b)\n}\n"}
{"tgt": "for {\n\tswitch r := l.next(); {\n\tcase unicode.IsNumber(r):\n\tcase r == \"STR\":\n\t\tl.backup()\n\t\tl.emit(itemEnd)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase r == eof:\n\t\tl.emit(itemEnd)\n\t\treturn byteRangeSet\n\tdefault:\n\t\treturn l.error(\"STR\")\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "return func(treebinaryTreeIf, node interface{}) bool {\n\tn := node.(*gbtElement)\n\tif !tree.IsNil(n.Left) && n.Left.Key >= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Left, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif !tree.IsNil(n.Right) && n.Right.Key <= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Right, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif debug {\n\t\tfmt.Println(n)\n\t}\n\t*nodeCnt++\n\treturn false\n}", "gen": "var t1 testing.T\nvar bt binaryTree\nbt.checkGBT(&t1, true, 10)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "iterator := func() <-chan VertexId {\n\tch := make(chan VertexId)\n\tgo func() {\n\t\tif connected, ok := g.edges[vertex]; ok {\n\t\t\tfor VertexId, _ := range connected {\n\t\t\t\tif g.IsEdge(vertex, VertexId) {\n\t\t\t\t\tch <- VertexId\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\nreturn VerticesIterable(&vertexIterableHelper{iterFunc: iterator})", "gen": "g := NewGraph()\nv1 := g.NewVertex(1)\nv2 := g.NewVertex(2)\ng.AddEdge(v1, v2)\nfmt.Println(g.GetSuccessors(v1))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 2, 1}, []int{0, 4, 1, 3, 2}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1}, []int{0}, []int{1}},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums, c.index)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums, c.index)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "c.bw.WriteString(\"STR\")\nc.bw.WriteByte(space)\nc.bw.WriteString(key)\nc.bw.WriteByte(space)\nc.bw.Write(strconv.AppendInt(c.numScratch[:0], int64(timeout), 10))\n_, err = c.bw.Write(crlf)\nreturn", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```\n.file\t\"main.go\"\n.text\n.globl\tmain\n.type\tmain, @function\nmain:\n.LFB254:\n.cfi_startproc\npushq\t%rbp\n.cfi_def_cfa_offset 16\n.cfi_offset 6, -16\nmovq\t%rsp, %rbp\n.cfi_def_cfa_register 6\nsubq\t$368, %rsp\nmovq\t%rdi, -344(%rbp)\nmovq\t%rsi, -368(%rbp)\nmovq\t%rdx, -360(%rbp)\nmovl\t%ecx, -348(%rbp)\nmovq\t$0, -336(%rbp)\nmovq\t$0, -328(%rbp)\n.L289:\nleaq\t.LC195(%rip), %r8\nmovl\t$5, %r9d\nmovq\t-344(%rbp), %rax\nmovq\t64(%rax), %rsi\nleaq\t-160(%rbp), %rax\nmovq\t%r8, %rdx\nmovq\t%r9, %rcx\nmovq\t%rax, %rdi\ncall\tbufio.Writer.WriteString@PLT\nmovq\t-160(%rbp), %rax\nmovq\t-152(%rbp), %rdx\nmovq\t%rax, -320(%rbp)\nmovq\t%rdx, -312(%rbp)\nmovq\t-144(%rbp), %rax\nmovq\t%rax, -304(%rbp)\nmovzbl\tgo.memcache.space(%rip), %edx\n"}
{"tgt": "for V > 0 {\n\tV--\n\tif !isDroppedLeft(heights, K) && !isDroppedRight(heights, K) {\n\t\theights[K]++\n\t}\n}\nreturn heights", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\na[0], a[1], a[2] = a[2], a[0], a[1]\nfmt.Println(a[0], a[1], a[2])\n}\n"}
{"tgt": "h := &IntMaxHeap{}\nheap.Init(h)\nheap.Push(h, 7)\nheap.Push(h, 3)\nheap.Push(h, 2)\nheap.Push(h, 1)\nheap.Push(h, 5)\nheap.Push(h, 5)\nheap.Push(h, 6)\nheap.Push(h, 7)\nfmt.Printf(\"STR\", (*h))\nfor h.Len() > 0 {\n\tfmt.Printf(\"STR\", heap.Pop(h))\n}", "gen": "var s Solution\ns.Solution()\n}\n"}
{"tgt": "sLen, pLen := len(s), len(p)\ndp := make([][]bool, sLen+1)\nfor i := range dp {\n\tdp[i] = make([]bool, pLen+1)\n}\ndp[sLen][pLen] = true\nfor i := sLen; i > -1; i-- {\n\tfor j := pLen - 1; j > -1; j-- {\n\t\tfirstMatch := i < sLen && (p[j] == s[i] || p[j] == '.')\n\t\tif j+1 < pLen && p[j+1] == '*' {\n\t\t\tdp[i][j] = dp[i][j+2] || firstMatch && dp[i+1][j]\n\t\t} else {\n\t\t\tdp[i][j] = firstMatch && dp[i+1][j+1]\n\t\t}\n\t}\n}\nreturn dp[0][0]", "gen": "var a [10]bool\nvar b [10]bool\nvar c [10]bool\nvar d [10]bool\nvar e [10]bool\nvar f [10]bool\nvar g [10]bool\nvar h [10]bool\nvar i [10]bool\nvar j [10]bool\nvar k [10]bool\nvar l [10]bool\nvar m [10]bool\nvar n [10]bool\nvar o [10]bool\nvar p [10]bool\nvar q [10]bool\nvar r [10]bool\nvar s [10]bool\nvar t [10]bool\nvar u [10]bool\nvar v [10]bool\nvar w [10]bool\nvar x [10]bool\nvar y [10]bool\nvar z [10]bool\nvar aa [10]bool\nvar bb [10]bool\nvar cc [10]bool\nvar dd [10]bool\nvar ee [10]bool\nvar ff [10]bool\nvar gg [10]bool\nvar hh [10]bool\nvar ii [10]bool\nvar jj [10]bool\nvar kk [10]bool\nvar ll [10]bool\nvar mm [10]bool\nvar nn [10]bool\nvar oo [10]bool\nvar pp [10]bool\nvar qq [10]bool\nvar rr [10]bool\nvar ss [10]bool\nvar tt [10]bool\nvar uu [10]bool\nvar vv [10]bool\nvar ww [10]bool\nvar xx [10]bool\nvar yy [10]bool\nvar zz [10]bool\nvar aaa [10]bool\nvar bbb [10]"}
{"tgt": "l1 := len(board)\nif l1 == 0 {\n\treturn\n}\nl2 := len(board[0])\nif l2 == 0 {\n\treturn\n}\nvisit := make([][]bool, l1)\nfor i := 0; i < l1; i++ {\n\tvisit[i] = make([]bool, l2)\n}\nfor i := 0; i < l1; i++ {\n\tfor j := 0; j < l2; j++ {\n\t\tif !visit[i][j] {\n\t\t\thelper(board, visit, i, j)\n\t\t}\n\t}\n}", "gen": "var a [10]bool\nvar b [10]bool\nvar c [10]bool\nvar d [10]bool\nvar e [10]bool\nvar f [10]bool\nvar g [10]bool\nvar h [10]bool\nvar i [10]bool\nvar j [10]bool\nvar k [10]bool\nvar l [10]bool\nvar m [10]bool\nvar n [10]bool\nvar o [10]bool\nvar p [10]bool\nvar q [10]bool\nvar r [10]bool\nvar s [10]bool\nvar t [10]bool\nvar u [10]bool\nvar v [10]bool\nvar w [10]bool\nvar x [10]bool\nvar y [10]bool\nvar z [10]bool\nvar aa [10]bool\nvar ab [10]bool\nvar ac [10]bool\nvar ad [10]bool\nvar ae [10]bool\nvar af [10]bool\nvar ag [10]bool\nvar ah [10]bool\nvar ai [10]bool\nvar aj [10]bool\nvar ak [10]bool\nvar al [10]bool\nvar am [10]bool\nvar an [10]bool\nvar ao [10]bool\nvar ap [10]bool\nvar aq [10]bool\nvar ar [10]bool\nvar as [10]bool\nvar at [10]bool\nvar au [10]bool\nvar av [10]bool\nvar aw [10]bool\nvar ax [10]bool\nvar ay [10]bool\nvar az [10]bool\nvar ba [10]bool\nvar bb [10]bool\nvar bc [10]bool\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.nums); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "sum := 100 * 101 / 2\nsqSum := sum * sum\nsumSq := 0\nfor i := 1; i <= 100; i++ {\n\tsumSq += i * i\n}\nfmt.Println(sqSum - sumSq)", "gen": "var a int\nvar b int\nvar c int\nvar d int\na = 1\nb = 1\nfor i := 1; i <= 100; i++ {\n\tc = a + b\n\ta = b\n\tb = c\n}\nd = a\nfmt.Println(d)\n}\n\n<ASM>\n.LFB0:\ncmpq %fs:112,%rsp\njnb .L7\nmovl $168,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L7:\npushq %rbp\nmovq %rsp,%rbp\npushq %r13\npushq %r12\nsubq $144,%rsp\nmovq $5050,-40(%rbp)\nmovq -40(%rbp),%rax\nimulq %rax,%rax\nmovq %rax,-48(%rbp)\nmovq $0,-24(%rbp)\n.LBB2:\nmovq $1,-32(%rbp)\n.LBB3:\njmp .L2\n.L6:\n.LBB4:\nnop\n.LBE4:\n.LBB5:\nmovq -32(%rbp),%rax\nimulq %rax,%rax\naddq %rax,-24(%rbp)\n.LBE5:\n.LBB6:\naddq $1,-32(%rbp)\n.L2:\n.LBE6:\ncmpq $100,-32(%rbp)\njle .L6\n.LBE3:\n.LBE2:\nleaq <int..d>(%rip),%r12\nleaq <int..d>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-136(%rbp)\nmovq -136(%rbp),%rax\nmovq -48(%rbp"}
{"tgt": "return x != y", "gen": "var a, b float32\na = 1.0\nb = 2.0\nif a < b {\n\tprintln(\"a < b\")\n} else if a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a > b\")\n}\n}\n\n// 0000000000000000 <main>:\n// 0:\t55                   \tpush   %rbp\n// 1:\t48 89 e5             \tmov    %rsp,%rbp\n// 4:\t48 8d 3d 00 00 00 00 \tlea    0x0(%rip),%rdi        # 10 <main+0x10>\n// 10:\te8 00 00 00 00       \tcallq  15 <main+0x15>\n// 15:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// 19:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// 1d:\t48 89 7d f0          \tmov    %rdx,-0x10(%rbp)\n// 21:\t48 89 75 e8          \tmov    %rsi,-0x18(%rbp)\n// 25:\t48 89 7d e8          \tmov    %rdx,-0x18(%rbp)\n// 29:\t48 89 75 e0          \tmov    %rsi,-0x20(%rbp)\n// 2d:\t48 89 7d e0          \tmov    %rdx,-0x20(%rbp)\n// 31:\t48 89 75 d8          \tmov    %rsi,-0x28(%rbp)\n// 35:\t48 "}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 1, 3}},\n\t\tans1051{3},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 2, 3, 4}},\n\t\tans1051{5},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{0},\n\t},\n\t{\n\t\tpara1051{[]int{5, 4, 3, 2, 1}},\n\t\tans1051{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"STR\", got, tt.want)\n\t\t}\n\t})\n}", "gen": "tests := []struct {\n\tname string\n\targs []string\n\twant int\n}{\n\t{\"test1\", []string{\"abcde\", \"cdefg\"}, 2},\n\t{\"test2\", []string{\"abcd\", \"cdab\"}, 4},\n\t{\"test3\", []string{\"abcde\", \"fghij\"}, 0},\n\t{\"test4\", []string{\"abcde\", \"abcde\"}, 4},\n\t{\"test5\", []string{\"abcde\", \"abcdefg\"}, 4},\n\t{\"test6\", []string{\"abcde\", \"abcdefgh\"}, 4},\n\t{\"test7\", []string{\"abcde\", \"abcdefghi\"}, 4},\n\t{\"test8\", []string{\"abcde\", \"abcdefghij\"}, 4},\n\t{\"test9\", []string{\"abcde\", \"abcdefghijk\"}, 4},\n\t{\"test10\", []string{\"abcde\", \"abcdefghijkl\"}, 4},\n\t{\"test11\", []string{\"abcde\", \"abcdefghijklm\"}, 4},\n\t{\"test12\", []string{\"abcde\", \"abcdefghijklmn\"}, 4},\n\t{\"test13\", []string{\"abcde\", \"abcdefghijklmno\"}, 4},\n\t{\"test14\", []string{\"abcde\", \"abcdefghijklmnop\"}, 4},\n\t{\"test15\", []string{\"abcde\", \"abcdefghijklmnopq\"}, 4},\n\t{\"test16\", []string{\"abcde\", \"abcdefghijklmnopqr\"}, 4},\n\t{\"test17\", []string{\"abcde\", \"abcdefghijklmnopqrs\"}, 4},\n\t{\"test18\", []string{\"abcde\", \"abcdefghijklmnopqrst\"}, 4},\n\t{\"test19\", []string{\"abcde\", \"abcdefghijklmnopqrstu\"}, 4},\n\t{\"test20\", []string{\"abcde\", \"abc"}
{"tgt": "if m == 0 {\n\treturn 1\n}\nswitch n {\ncase 1:\n\treturn 2\ncase 2:\n\tif m == 1 {\n\t\treturn 3\n\t}\n\treturn 4\ndefault:\n\tswitch m {\n\tcase 1:\n\t\treturn 4\n\tcase 2:\n\t\treturn 7\n\tdefault:\n\t\treturn 8\n\t}\n}", "gen": "var a, b int\na = 1\nb = 2\nvar c int\nc = 0\nswitch {\ncase a == 1:\n\tc = 1\ncase b == 2:\n\tc = 2\ncase a == 1 && b == 2:\n\tc = 3\ncase a == 1 || b == 2:\n\tc = 4\ncase a == 1 && b == 2 && c == 3:\n\tc = 7\ncase a == 1 || b == 2 && c == 3:\n\tc = 8\n}\nif c != 8 {\n\tpanic(\"bad\")\n}\n}\n\n// func main() {\n// \tvar a, b int\n// \ta = 1\n// \tb = 2\n// \tvar c int\n// \tc = 0\n// \tswitch {\n// \tcase a == 1:\n// \t\tc = 1\n// \tcase b == 2:\n// \t\tc = 2\n// \tcase a == 1 && b == 2:\n// \t\tc = 3\n// \tcase a == 1 || b == 2:\n// \t\tc = 4\n// \tcase a == 1 && b == 2 && c == 3:\n// \t\tc = 7\n// \tcase a == 1 || b == 2 && c == 3:\n// \t\tc = 8\n// \t}\n// \tif c != 8 {\n// \t\tpanic(\"bad\")\n// \t}\n// }\n\n// func main() {\n// \tvar a, b int\n// \ta = 1\n// \tb = 2\n// \tvar c int\n// \tc = 0\n// \tswitch {\n// \tcase a == 1:\n// \t\tc = 1\n// \tcase b == 2:\n// \t\tc = 2\n//"}
{"tgt": "sort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].End < intervals[j].End\n})\ncount := 0\ncurrent := -int(^uint(0)>>1) - 1\nfor _, interval := range intervals {\n\tif interval.Start >= current {\n\t\tcount++\n\t\tcurrent = interval.End\n\t}\n}\nreturn len(intervals) - count", "gen": "fmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 3}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {1, 2}, {1, 2}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 4}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {1, 2}, {2, 3}, {3, 4}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 4}, {4, 5}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 5}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 5}, {5, 6}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 5}, {5, 6}, {6, 7}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 5}, {5, 6}, {6, 7}, {7, 8}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 5}, {5, 6}, {6, 7}, {7, 8}, {8, 9}}))\nfmt.Println(MinRemoveNoOverlap("}
{"tgt": "switch rand.Intn(10) {\ncase 1, 9:\n\treturn io.EOF\ncase 5:\n\treturn errors.New(\"STR\")\ndefault:\n\td.Line = \"STR\"\n\tfmt.Println(\"STR\", d.Line)\n\treturn nil\n}", "gen": "var s string\nfmt.Scan(&s)\nfmt.Println(s)\n}\n"}
{"tgt": "fmt.Println(subarrayBitwiseORs([]int{0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))", "gen": "var a [3]int\na[0] = 1\na[1] = 1\na[2] = 2\nfmt.Println(subarrayBitwiseORs(a))\nvar b [3]int\nb[0] = 1\nb[1] = 3\nb[2] = 3\nfmt.Println(subarrayBitwiseORs(b))\nvar c [3]int\nc[0] = 1\nc[1] = 1\nc[2] = 4\nfmt.Println(subarrayBitwiseORs(c))\n}\n"}
{"tgt": "dummy := &ListNode{0, head}\nslow, fast := dummy, dummy\nfor fast.Next != nil && fast.Next.Next != nil {\n\tfast = fast.Next.Next\n\tslow = slow.Next\n}\nreturn slow.Next", "gen": "var a [2]int\nvar b [2]int\na[0] = 1\na[1] = 2\nb[0] = 3\nb[1] = 4\nvar c [2]int\nc[0] = a[0] + b[0]\nc[1] = a[1] + b[1]\nprintln(c[0], c[1])\n}\n\n// 0 6\n\n<ASM>\n.LFB23:\nmovq %rdi,-8(%rbp)\nmovq %rsi,-16(%rbp)\nmovq %rdx,-24(%rbp)\nmovq %rcx,-32(%rbp)\nmovq %r8,-40(%rbp)\nmovq %r9,-48(%rbp)\nmovq -8(%rbp),%rax\nmovq %rax,-8(%rbp)\nmovq -16(%rbp),%rax\nmovq %rax,-16(%rbp)\nmovq -24(%rbp),%rax\nmovq %rax,-24(%rbp)\nmovq -32(%rbp),%rax\nmovq %rax,-32(%rbp)\nmovq -40(%rbp),%rax\nmovq %rax,-40(%rbp)\nmovq -48(%rbp),%rax\nmovq %rax,-48(%rbp)\nmovq -8(%rbp),%rax\nmovq -16(%rbp),%rdx\nmovq %rdx,-16(%rbp)\nmovq -24(%rbp),%rdx\nmovq %rdx,-24(%rbp)\nmovq -32(%rbp),%rdx\nmovq %rdx,-32(%rbp)\nmovq -40(%rbp),%rdx\nmovq %rdx,-40(%rbp)\nmovq -48(%rbp),%rdx\nmovq %rdx,-48(%rbp)\nmov"}
{"tgt": "pairs := [...][2]int{{10, 7}, {1000, 983}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p26(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var p26 *int\nvar p27 *int\nvar p28 *int\nvar p29 *int\nvar p30 *int\nvar p31 *int\nvar p32 *int\nvar p33 *int\nvar p34 *int\nvar p35 *int\nvar p36 *int\nvar p37 *int\nvar p38 *int\nvar p39 *int\nvar p40 *int\nvar p41 *int\nvar p42 *int\nvar p43 *int\nvar p44 *int\nvar p45 *int\nvar p46 *int\nvar p47 *int\nvar p48 *int\nvar p49 *int\nvar p50 *int\nvar p51 *int\nvar p52 *int\nvar p53 *int\nvar p54 *int\nvar p55 *int\nvar p56 *int\nvar p57 *int\nvar p58 *int\nvar p59 *int\nvar p60 *int\nvar p61 *int\nvar p62 *int\nvar p63 *int\nvar p64 *int\nvar p65 *int\nvar p66 *int\nvar p67 *int\nvar p68 *int\nvar p69 *int\nvar p70 *int\nvar p71 *int\nvar p72 *int\nvar p73 *int\nvar p74 *int\nvar p75 *int\nvar p76 *int\nvar p77 *int\nvar p78 *int\nvar p79 *int\nvar p80 *int\nvar p81 *int\nvar p82 *int\nvar p83 *int\nvar p84 *int\nvar p85 *int\nvar p86 *int\nvar p87 *int\nvar p8"}
{"tgt": "n := len(A)\nfor i := n - 2; i >= 0; i-- {\n\tA[i] += A[i+1]\n}\nmem := [101][33]int{}\nvar dp func(int, int) int\ndp = func(i, m int) int {\n\tif i+2*m >= n {\n\t\treturn A[i]\n\t}\n\tif mem[i][m] > 0 {\n\t\treturn mem[i][m]\n\t}\n\tres := 0\n\tfor x := 1; x <= 2*m; x++ {\n\t\tres = max(\n\t\t\tres,\n\t\t\tA[i]-dp(i+x, max(m, x)),\n\t\t)\n\t}\n\tmem[i][m] = res\n\treturn res\n}\nreturn dp(0, 1)", "gen": "stoneGameII([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n}\n"}
{"tgt": "if n == 0 {\n\treturn 0\n}\nreturn n/5 + trailingZeroes(n/5)", "gen": "fmt.Println(trailingZeroes(10))\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0}, 5},\n\t{\"STR\", []int{0, 0, 0, 0, 1}, []int{1, 0, 0, 0, 0}, 4},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums1, c.nums2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums1, c.nums2)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "list.rear = nil", "gen": "var x int\nvar y int\nx = 1\ny = 2\nx = x + y\nprintln(x)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(name) == 0 && len(typed) == 0 {\n\treturn true\n}\nif (len(name) == 0 && len(typed) != 0) || (len(name) != 0 && len(typed) == 0) {\n\treturn false\n}\nj := 0\nfor i := 0; i < len(name); i++ {\n\tif j < len(typed) && name[i] == typed[j] {\n\t\tj++\n\t\tcontinue\n\t} else {\n\t\tif i > 0 && j < len(typed) && name[i-1] == typed[j] {\n\t\t\tj++\n\t\t\ti--\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "var a [10]byte\nvar b [10]byte\nvar c [10]byte\nvar d [10]byte\nvar e [10]byte\nvar f [10]byte\nvar g [10]byte\nvar h [10]byte\nvar i [10]byte\nvar j [10]byte\nvar k [10]byte\nvar l [10]byte\nvar m [10]byte\nvar n [10]byte\nvar o [10]byte\nvar p [10]byte\nvar q [10]byte\nvar r [10]byte\nvar s [10]byte\nvar t [10]byte\nvar u [10]byte\nvar v [10]byte\nvar w [10]byte\nvar x [10]byte\nvar y [10]byte\nvar z [10]byte\nvar aa [10]byte\nvar ab [10]byte\nvar ac [10]byte\nvar ad [10]byte\nvar ae [10]byte\nvar af [10]byte\nvar ag [10]byte\nvar ah [10]byte\nvar ai [10]byte\nvar aj [10]byte\nvar ak [10]byte\nvar al [10]byte\nvar am [10]byte\nvar an [10]byte\nvar ao [10]byte\nvar ap [10]byte\nvar aq [10]byte\nvar ar [10]byte\nvar as [10]byte\nvar at [10]byte\nvar au [10]byte\nvar av [10]byte\nvar aw [10]byte\nvar ax [10]byte\nvar ay [10]byte\nvar az [10]byte\nvar aaa [10]byte\nvar aab [10]byte\nvar aac [10]byte\n"}
{"tgt": "factorial := new(big.Int).MulRange(1, 100)\nbytes := factorial.Append([]byte{}, 10)\nsum := 0\nfor b := range bytes {\n\tsum += int(bytes[b] - '0')\n}\nfmt.Println(\"STR\", sum)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aaa int\nvar bbb int\nvar ccc int\nvar ddd int\nvar eee int\nvar fff int\nvar ggg int\nvar hhh int\nvar iii int\nvar jjj int\nvar kkk int\nvar lll int\nvar mmm int\nvar nnn int\nvar ooo int\nvar ppp int\nvar qqq int\nvar rrr int\nvar sss int\nvar ttt int\nvar uuu int\nvar vvv int\nvar www int\nvar xxx int\nvar yyy int\nvar zzz int\nvar aaaa int\nvar bbbb int\nvar cccc int\nvar dddd int\nvar eeee int\nvar ffff int\nvar gggg int\nvar hhhh int\nvar iiii int\nvar jjjj int\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs int\n\texpect int\n}{\n\t{\"STR\", 2, 1},\n\t{\"STR\", 3, 2},\n\t{\"STR\", 4, 3},\n\t{\"STR\", 0, 0},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "var low, mid, high int = 0, len(sorted) / 2, len(sorted)\nfor low < high {\n\tcurr := sorted[mid]\n\tswitch {\n\tcase curr == target:\n\t\treturn mid\n\tcase inRange(sorted[mid:high], target):\n\t\tlow = mid\n\t\tmid = (low + high) / 2\n\tdefault:\n\t\thigh = mid\n\t\tmid = (low + high) / 2\n\t}\n}\nreturn -1", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nret := &ListNode{}\nif l1.Val <= l2.Val {\n\tret = l1\n\tret.Next = mergeTwoLists1(l1.Next, l2)\n} else {\n\tret = l2\n\tret.Next = mergeTwoLists1(l1, l2.Next)\n}\nreturn ret", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Print(sum, \"STR\")", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aaa int\nvar bbb int\nvar ccc int\nvar ddd int\nvar eee int\nvar fff int\nvar ggg int\nvar hhh int\nvar iii int\nvar jjj int\nvar kkk int\nvar lll int\nvar mmm int\nvar nnn int\nvar ooo int\nvar ppp int\nvar qqq int\nvar rrr int\nvar sss int\nvar ttt int\nvar uuu int\nvar vvv int\nvar www int\nvar xxx int\nvar yyy int\nvar zzz int\nvar aaaa int\nvar bbbb int\nvar cccc int\nvar dddd int\nvar eeee int\nvar ffff int\nvar gggg int\nvar hhhh int\nvar iiii int\nvar jjjj int\n"}
{"tgt": "rets := make([][]int, numRows)\nif numRows == 0 {\n\treturn rets\n}\nrets[0] = []int{1}\nfor i := 1; i < numRows; i++ {\n\trets[i] = make([]int, i+1)\n\trets[i][0] = 1\n\trets[i][i] = 1\n\tfor j := 1; j < i; j++ {\n\t\trets[i][j] = rets[i-1][j-1] + rets[i-1][j]\n\t}\n}\nreturn rets", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb := a[0:2]\nb[0] = 10\nb[1] = 20\na[0] = 100\nfmt.Println(a[0], a[1], a[2])\n}\n\n// Output:\n// 100 20 3\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n.LBB0:\nleaq -344(%rsp),%r11\ncmpq %fs:112,%r11\njnb .L49\nmovl $344,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L49:\npushq %rbp\nmovq %rsp,%rbp\npushq %rbx\nsubq $328,%rsp\nmovq %rdi,-328(%rbp)\nmovq %rsi,-336(%rbp)\nmovq $0,-288(%rbp)\nmovq $0,-280(%rbp)\nmovq $0,-272(%rbp)\n.LBB2:\nmovq -336(%rbp),%rbx\nmovq %rbx,%rdx\nmovq %rbx,%rsi\nleaq <type...6.7int>(%rip),%rdi\ncall <runtime.makeslice@PLT>\nmovq %rax,-320(%rbp)\nmovq %rbx,-312(%rbp)\nmovq %rbx,-304(%rbp)\n.LBB3:\ncmpq $0,-336(%rbp)\njne .L2\n.LBB4:\n.LBB5:\nmovq -320(%rbp),%rax\nmovq -312(%rbp),%rdx\nmovq %rax,-288"}
{"tgt": "start := -1\nlenMax := 0\ndict := [256]int{}\nfor i := range dict {\n\tdict[i] = -1\n}\nfor i, r := range s {\n\tif v := dict[r]; v > start {\n\t\tstart = v\n\t}\n\tlength := i - start\n\tif length > lenMax {\n\t\tlenMax = length\n\t}\n\tdict[r] = i\n}\nreturn lenMax", "gen": "var s []byte\ns = append(s, 1)\ns = append(s, 2)\ns = append(s, 3)\ns = append(s, 4)\ns = append(s, 5)\ns = append(s, 6)\ns = append(s, 7)\ns = append(s, 8)\ns = append(s, 9)\ns = append(s, 10)\ns = append(s, 11)\ns = append(s, 12)\ns = append(s, 13)\ns = append(s, 14)\ns = append(s, 15)\ns = append(s, 16)\ns = append(s, 17)\ns = append(s, 18)\ns = append(s, 19)\ns = append(s, 20)\ns = append(s, 21)\ns = append(s, 22)\ns = append(s, 23)\ns = append(s, 24)\ns = append(s, 25)\ns = append(s, 26)\ns = append(s, 27)\ns = append(s, 28)\ns = append(s, 29)\ns = append(s, 30)\ns = append(s, 31)\ns = append(s, 32)\ns = append(s, 33)\ns = append(s, 34)\ns = append(s, 35)\ns = append(s, 36)\ns = append(s, 37)\ns = append(s, 38)\ns = append(s, 39)\ns = append(s, 40)\ns = append(s, 41)\ns = append(s, 42)"}
{"tgt": "nlen := len(nums)\nfor i := 0; i < nlen-2; i++ {\n\tif i != 0 && nums[i] == nums[i-1] {\n\t\tcontinue\n\t}\n\tleft, right := i+1, nlen-1\n\tfor left < right {\n\t\tsum := nums[i] + nums[left] + nums[right]\n\t\tif sum == target {\n\t\t\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tleft++\n\t\t\tright--\n\t\t} else if sum < target {\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tleft++\n\t\t} else {\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tright--\n\t\t}\n\t}\n}", "gen": "var a [4]int\nvar b [4]int\nvar c [4]int\nvar d [4]int\nvar e [4]int\nvar f [4]int\nvar g [4]int\nvar h [4]int\nvar i [4]int\nvar j [4]int\nvar k [4]int\nvar l [4]int\nvar m [4]int\nvar n [4]int\nvar o [4]int\nvar p [4]int\nvar q [4]int\nvar r [4]int\nvar s [4]int\nvar t [4]int\nvar u [4]int\nvar v [4]int\nvar w [4]int\nvar x [4]int\nvar y [4]int\nvar z [4]int\nvar aa [4]int\nvar ab [4]int\nvar ac [4]int\nvar ad [4]int\nvar ae [4]int\nvar af [4]int\nvar ag [4]int\nvar ah [4]int\nvar ai [4]int\nvar aj [4]int\nvar ak [4]int\nvar al [4]int\nvar am [4]int\nvar an [4]int\nvar ao [4]int\nvar ap [4]int\nvar aq [4]int\nvar ar [4]int\nvar as [4]int\nvar at [4]int\nvar au [4]int\nvar av [4]int\nvar aw [4]int\nvar ax [4]int\nvar ay [4]int\nvar az [4]int\nvar ba [4]int\nvar bb [4]int\nvar bc [4]int\nvar bd [4]int\nvar be [4]int\nvar bf [4]int\nvar bg [4]int\nvar bh [4]int\nvar bi [4]int\nvar bj ["}
{"tgt": "return strings.ReplaceAll(r.element.Name, \"STR\", \"\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n\n// Output:\n// Hello, playground\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n// \u6c47\u7f16\u4ee3\u7801\n.text\n.globl main\nmain:\npushq %rbp\nmovq %rsp, %rbp\nsubq $16, %rsp\nmovq $0, %rax\nmovq $0, %rdx\nmovq $0, %rcx\nmovq $0, %r8\nmovq $0, %r9\nmovq $0, %r10\nmovq $0, %r11\nmovq $0, %r12\nmovq $0, %r13\nmovq $0, %r14\nmovq $0, %r15\nmovq $0, %rdi\nmovq $0, %rsi\nmovq $0, %rbx\nmovq $0, %r11\nmovq $0, %r12\nmovq $0, %r13\nmovq $0, %r14\nmovq $0, %r15\nmovq $0, %rdi\nmovq $0, %rsi\nmovq $0, %rbx\nmovq $0, %r11\nmovq $0, %r12\nmovq $0, %r13\nmovq $0, %r14\nmovq $0, %r15\nmovq $0, %rdi\nmovq $0, %rsi\nmovq $0, %rbx\nmovq $0, %r11\nmovq $0, %r12\nmovq $0, %r13\nmovq $0, %r14\nmovq $0, %r15\nmovq $0, %rdi\nmovq $0, %rsi\nmovq $0, %rbx\nmovq $0"}
{"tgt": "var res byte\nfor i := 0; i < len(s); i++ {\n\tres ^= s[i]\n}\nfor i := 0; i < len(t); i++ {\n\tres ^= t[i]\n}\nreturn res", "gen": "var a [10]byte\nvar b [10]byte\nvar c [10]byte\nvar d [10]byte\nvar e [10]byte\nvar f [10]byte\nvar g [10]byte\nvar h [10]byte\nvar i [10]byte\nvar j [10]byte\nvar k [10]byte\nvar l [10]byte\nvar m [10]byte\nvar n [10]byte\nvar o [10]byte\nvar p [10]byte\nvar q [10]byte\nvar r [10]byte\nvar s [10]byte\nvar t [10]byte\nvar u [10]byte\nvar v [10]byte\nvar w [10]byte\nvar x [10]byte\nvar y [10]byte\nvar z [10]byte\nvar aa [10]byte\nvar ab [10]byte\nvar ac [10]byte\nvar ad [10]byte\nvar ae [10]byte\nvar af [10]byte\nvar ag [10]byte\nvar ah [10]byte\nvar ai [10]byte\nvar aj [10]byte\nvar ak [10]byte\nvar al [10]byte\nvar am [10]byte\nvar an [10]byte\nvar ao [10]byte\nvar ap [10]byte\nvar aq [10]byte\nvar ar [10]byte\nvar as [10]byte\nvar at [10]byte\nvar au [10]byte\nvar av [10]byte\nvar aw [10]byte\nvar ax [10]byte\nvar ay [10]byte\nvar az [10]byte\nvar ba [10]byte\nvar bb [10]byte\nvar bc [10]byte\n"}
{"tgt": "m := len(A)\nn := len(A[0])\nans := make([][]int, n)\nfor k := range ans {\n\tans[k] = make([]int, m)\n}\nfor r := 0; r < m; r++ {\n\tfor c := 0; c < n; c++ {\n\t\tans[c][r] = A[r][c]\n\t}\n}\nreturn ans", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "println(\"STR\", len(a))", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\tprintln(a[i])\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nc, res := []int{}, [][]int{}\nsort.Ints(candidates)\nfindcombinationSum(candidates, target, 0, c, &res)\nreturn res", "gen": "fmt.Println(findCombinationSum([]int{2, 3, 6, 7}, 7))\n}\n"}
{"tgt": "for i := 0; i < len(A)-1; i++ {\n\tif A[i] == i {\n\t\tcontinue\n\t}\n\tif A[i] == i+1 && A[i+1] == i {\n\t\ti++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"bad\")\n\t}\n}\n}\n\n// 0000000000000000 <main>:\n// 0:\t55                   \tpush   %rbp\n// 1:\t48 89 e5             \tmov    %rsp,%rbp\n// 4:\t48 83 ec 10          \tsub    $0x10,%rsp\n// 8:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// c:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// f:\t48 89 7d f0          \tmov    %rdx,-0x10(%rbp)\n// 13:\t48 89 75 e8          \tmov    %rsi,-0x18(%rbp)\n// 17:\t48 89 7d e0          \tmov    %rdx,-0x20(%rbp)\n// 1b:\t48 89 75 d8          \tmov    %rsi,-0x28(%rbp)\n// 1f:\t48 89 7d d0          \tmov    %rdx,-0x30(%rbp)\n// 23:\t48 89 75 c8          \tmov    %rsi,-0x38(%rbp)\n// 27:\t48 89 7d c0          \tmov    %rdx,-0x40(%rbp)\n// 2b:\t48 89 75 b8          \tmov    %rsi,-0x48(%rbp)\n// 2"}
{"tgt": "for n := 0; n < 32; n++ {\n\tsquare[n] = gf2MatrixTimes(mat, mat[n])\n}", "gen": "var a [32]byte\nvar b [32]byte\nvar c [32]byte\nvar d [32]byte\nvar e [32]byte\nvar f [32]byte\nvar g [32]byte\nvar h [32]byte\nvar i [32]byte\nvar j [32]byte\nvar k [32]byte\nvar l [32]byte\nvar m [32]byte\nvar n [32]byte\nvar o [32]byte\nvar p [32]byte\nvar q [32]byte\nvar r [32]byte\nvar s [32]byte\nvar t [32]byte\nvar u [32]byte\nvar v [32]byte\nvar w [32]byte\nvar x [32]byte\nvar y [32]byte\nvar z [32]byte\nvar aa [32]byte\nvar ab [32]byte\nvar ac [32]byte\nvar ad [32]byte\nvar ae [32]byte\nvar af [32]byte\nvar ag [32]byte\nvar ah [32]byte\nvar ai [32]byte\nvar aj [32]byte\nvar ak [32]byte\nvar al [32]byte\nvar am [32]byte\nvar an [32]byte\nvar ao [32]byte\nvar ap [32]byte\nvar aq [32]byte\nvar ar [32]byte\nvar as [32]byte\nvar at [32]byte\nvar au [32]byte\nvar av [32]byte\nvar aw [32]byte\nvar ax [32]byte\nvar ay [32]byte\nvar az [32]byte\nvar ba [32]byte\nvar bb [32]byte\nvar bc [32]byte\n"}
{"tgt": "for i := 0; i < n; i++ {\n\tif len(squares) != i {\n\t\tprintln(\"STR\", len(squares), \"STR\", i)\n\t}\n\tsquares[i] = i * i\n\tfor j := 0; j <= i; j++ {\n\t\tif v, ok := squares[j]; !ok || v != j*j {\n\t\t\tif !ok {\n\t\t\t\tprintln(\"STR\", j)\n\t\t\t} else {\n\t\t\t\tprintln(\"STR\", j, v)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "var m map[int][2]int\nfor i := 0; i < 10; i++ {\n\tm[i] = [2]int{i, i}\n}\nfor i := 0; i < 10; i++ {\n\tfmt.Printf(\"%d %d\\n\", i, m[i][0])\n}\n}\n\n// Output:\n// 0 0\n// 1 1\n// 2 2\n// 3 3\n// 4 4\n// 5 5\n// 6 6\n// 7 7\n// 8 8\n// 9 9\n\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```\n<ASM>\ncmpq %fs:112,%rsp\njnb .L55\nmovl $152,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL3:\nret\n.L55:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $104,%rsp\nmovq %rdi,-104(%rbp)\nmovq %rsi,-112(%rbp)\n.LBB39:\nmovq $0,-56(%rbp)\n.LBB40:\njmp .L36\n.L54:\n.LBB41:\nnop\n.LBE41:\n.LBB42:\n.LBB43:\ncmpq $0,-104(%rbp)\nje .L37\nmovq -104(%rbp),%rax\nmovq (%rax),%rax\njmp .L38\n.L37:\nmovl $0,%eax\n.L38:\ncmpq -56(%rbp),%rax\nje .L39\n.LBB44:\ncmpq $"}
{"tgt": "for j := 1; j <= 20; j++ {\n\tif num%j != 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a int\nvar b int\na = 10\nb = 2\nc := a / b\nfmt.Println(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(sorted) == 0 {\n\treturn nil\n}\nmid := len(sorted) / 2\nroot := &BST{Value: sorted[mid]}\nroot.Left = SortedSliceToBST(sorted[:mid])\nroot.Right = SortedSliceToBST(sorted[mid+1:])\nreturn root", "gen": "var a [10]int\nvar b *BST\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nb = SortedSliceToBST(a[:], 0, 9)\nfmt.Println(b.data)\n}\n"}
{"tgt": "return x * y", "gen": "var a float32 = 1.0\nvar b float32 = 2.0\nvar c float32 = 3.0\nvar d float32 = 4.0\nvar e float32 = 5.0\nvar f float32 = 6.0\nvar g float32 = 7.0\nvar h float32 = 8.0\nvar i float32 = 9.0\nvar j float32 = 10.0\nvar k float32 = 11.0\nvar l float32 = 12.0\nvar m float32 = 13.0\nvar n float32 = 14.0\nvar o float32 = 15.0\nvar p float32 = 16.0\nvar q float32 = 17.0\nvar r float32 = 18.0\nvar s float32 = 19.0\nvar t float32 = 20.0\nvar u float32 = 21.0\nvar v float32 = 22.0\nvar w float32 = 23.0\nvar x float32 = 24.0\nvar y float32 = 25.0\nvar z float32 = 26.0\nvar aa float32 = 27.0\nvar bb float32 = 28.0\nvar cc float32 = 29.0\nvar dd float32 = 30.0\nvar ee float32 = 31.0\nvar ff float32 = 32.0\nvar gg float32 = 33.0\nvar hh float32 = 34.0\nvar ii float32 = 35.0\nvar jj float32 = 36.0\nvar kk float32 = 37.0\nvar ll float32 = 38.0\nvar mm float32 = 39"}
{"tgt": "i1 := 0\ni2 := 0\nval1 := 0\nval2 := 0\nfor i1 < len(version1) || i2 < len(version2) {\n\tval1, i1 = parseSeg(version1, i1)\n\tval2, i2 = parseSeg(version2, i2)\n\tif val1 > val2 {\n\t\treturn 1\n\t}\n\tif val1 < val2 {\n\t\treturn -1\n\t}\n}\nif i1 < len(version1) {\n\treturn 1\n}\nif i2 < len(version2) {\n\treturn -1\n}\nreturn 0", "gen": "fmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\n"}
{"tgt": "return this.Val", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "str := \"STR\"\nfmt.Println(longestPalindrome(str))", "gen": "fmt.Println(longestPalindrome(\"abba\"))\nfmt.Println(longestPalindrome(\"abcd\"))\nfmt.Println(longestPalindrome(\"abcba\"))\nfmt.Println(longestPalindrome(\"abcdcba\"))\nfmt.Println(longestPalindrome(\"abcdcbaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPal"}
{"tgt": "dat, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\nnamesList := string(dat)\nnamesList = strings.Replace(namesList, \"STR\", \"STR\", -1)\nnames := strings.Split(namesList, \"STR\")\nsort.Strings(names)\nnamesScore := 0\nfor index, name := range names {\n\tnamesScore += nameScore(name) * (index + 1)\n}\nfmt.Println(namesScore)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\n"}
{"tgt": "res := 0\nsort.Ints(houses)\nsort.Ints(heaters)\nm, n := len(houses), len(heaters)\nindex := sort.SearchInts(heaters, houses[0])\nfor _, house := range houses {\n\tfor index < n && house > heaters[index] {\n\t\tindex++\n\t}\n\tif index == n {\n\t\treturn max(res, houses[m-1]-heaters[index-1])\n\t}\n\tleft := math.MaxInt32\n\tif index > 0 {\n\t\tleft = house - heaters[index-1]\n\t}\n\tright := heaters[index] - house\n\tres = max(res, min(left, right))\n}\nreturn res", "gen": "fmt.Println(maxProfit([]int{7, 1, 5, 3, 6, 4}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5}))\nfmt.Println(maxProfit([]int{7, 6, 4, 3, 1}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}))\nfmt.Println(maxProfit([]"}
{"tgt": "l, r := &maxHeap{}, &minHeap{}\nheap.Init(l)\nheap.Init(r)\nreturn MedianFinder{l, r}", "gen": "fmt.Println(maxHeap.Len())\nfmt.Println(minHeap.Len())\nmaxHeap.Push(1)\nmaxHeap.Push(2)\nmaxHeap.Push(3)\nmaxHeap.Push(4)\nmaxHeap.Push(5)\nmaxHeap.Push(6)\nmaxHeap.Push(7)\nmaxHeap.Push(8)\nmaxHeap.Push(9)\nmaxHeap.Push(10)\nmaxHeap.Push(11)\nmaxHeap.Push(12)\nmaxHeap.Push(13)\nmaxHeap.Push(14)\nmaxHeap.Push(15)\nmaxHeap.Push(16)\nmaxHeap.Push(17)\nmaxHeap.Push(18)\nmaxHeap.Push(19)\nmaxHeap.Push(20)\nmaxHeap.Push(21)\nmaxHeap.Push(22)\nmaxHeap.Push(23)\nmaxHeap.Push(24)\nmaxHeap.Push(25)\nmaxHeap.Push(26)\nmaxHeap.Push(27)\nmaxHeap.Push(28)\nmaxHeap.Push(29)\nmaxHeap.Push(30)\nmaxHeap.Push(31)\nmaxHeap.Push(32)\nmaxHeap.Push(33)\nmaxHeap.Push(34)\nmaxHeap.Push(35)\nmaxHeap.Push(36)\nmaxHeap.Push(37)\nmaxHeap.Push(38)\nmaxHeap.Push(39)\nmaxHeap.Push(40)\nmaxHeap.Push(41)\nmaxHeap.Push(42)\nmaxHeap.Push(43)\nmaxHeap.Push(44)"}
{"tgt": "l := len(preorder)\nif l == 0 {\n\treturn nil\n}\nfor 1 < l && preorder[0] < preorder[l-1] {\n\tl--\n}\nreturn &TreeNode{\n\tVal:   preorder[0],\n\tLeft:  bstFromPreorder(preorder[1:l]),\n\tRight: bstFromPreorder(preorder[l:]),\n}", "gen": "var preorder = []int{3, 9, 20, 15, 7}\nvar inorder = []int{9, 3, 15, 20, 7}\nroot := bstFromPreorder(preorder, inorder)\nfmt.Println(root)\n}\n"}
{"tgt": "ln, err := net.Listen(\"STR\", \"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"STR\", conn.RemoteAddr())\n\tio.WriteString(conn, fmt.Sprint(time.Now()))\n\tconn.Close()\n}", "gen": "var l net.Listener\nl, err := net.Listen(\"tcp\", \"127.0.0.1:8080\")\nif err != nil {\n\tpanic(err)\n}\ndefer l.Close()\nfor {\n\tconn, err := l.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tgo handleConn(conn)\n}\n}"}
{"tgt": "i, l := 0, len(bits)-1\nfor i < l {\n\ti += bits[i] + 1\n}\nreturn i == l", "gen": "var a [10]int\na[10] = 1\n}\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n// 0000000000000000 <main>:\n// \t.globl\tmain\n// \t.type\tmain,@function\n// main:                                   # @main\n// \t.cfi_startproc\n// \t.cfi_personality 0x3,__gxx_personality_v0\n// \t.cfi_lsda 0x3,.LLSDA0\n// \t.cfi_loc 1 1 0\n// \t.cfi_adjust_cfa_offset 32\n// \t.cfi_offset 11, -32\n// \t.cfi_offset 12, -24\n// \t.cfi_offset 13, -16\n// \t.cfi_offset 14, -8\n// \t.cfi_offset 15, -16\n// \t.cfi_offset 16, -24\n// \t.cfi_offset 17, -32\n// \t.cfi_offset 18, -40\n// \t.cfi_offset 19, -48\n// \t.cfi_offset 20, -56\n// \t.cfi_offset 21, -64\n// \t.cfi_offset 22, -72\n// \t.cfi_offset 23, -80\n// \t.cfi_offset 24, -88\n// \t.cfi_offset 25, -96\n// \t.cfi_offset 26, -104\n// \t.cfi_offset 27, -112\n// \t.cfi_offset 28, -120\n// \t.cfi_offset 29, -128\n//"}
{"tgt": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "start := 0\nend := len(s) - 1\nfor start < end {\n\ts[start], s[end] = s[end], s[start]\n\tstart++\n\tend--\n}\nreturn s", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "for cur := t.root; cur != nil; {\n\tif cur.Key == key {\n\t\treturn cur\n\t} else if key < cur.Key {\n\t\tcur = cur.left\n\t} else {\n\t\tcur = cur.right\n\t}\n}\nreturn nil", "gen": "var bst *binaryTree.BST\nbst = binaryTree.NewBST()\nbst.Insert(10)\nbst.Insert(20)\nbst.Insert(30)\nbst.Insert(40)\nbst.Insert(50)\nbst.Insert(60)\nbst.Insert(70)\nbst.Insert(80)\nbst.Insert(90)\nbst.Insert(100)\nbst.Insert(110)\nbst.Insert(120)\nbst.Insert(130)\nbst.Insert(140)\nbst.Insert(150)\nbst.Insert(160)\nbst.Insert(170)\nbst.Insert(180)\nbst.Insert(190)\nbst.Insert(200)\nbst.Insert(210)\nbst.Insert(220)\nbst.Insert(230)\nbst.Insert(240)\nbst.Insert(250)\nbst.Insert(260)\nbst.Insert(270)\nbst.Insert(280)\nbst.Insert(290)\nbst.Insert(300)\nbst.Insert(310)\nbst.Insert(320)\nbst.Insert(330)\nbst.Insert(340)\nbst.Insert(350)\nbst.Insert(360)\nbst.Insert(370)\nbst.Insert(380)\nbst.Insert(390)\nbst.Insert(400)\nbst.Insert(410)\nbst.Insert(420)\nbst.Insert(430)\nbst.Insert(440)\nbst.Insert(450)\nbst.Insert(460)\nbst.Insert(470)\nbst.Insert(480)\nbst.Insert(49"}
{"tgt": "arr := randomSlice(0, 20, 10)\nnodeCnt := 0\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\nrotateNodes := make([]*gbtElement, 0, 0)\ngbt.InOrderWalk(gbt.Root(), func(GBTbinaryTreeIf, node interface{}) bool {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\trotateNodes = append(rotateNodes, node.(*gbtElement))\n\t}\n\treturn false\n})\nfor _, v := range rotateNodes {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\tgbt.LeftRotate(v)\n\t} else {\n\t\tgbt.RightRotate(v)\n\t}\n}\ngbt.InOrderWalk(gbt.Root(), checkGBT(t, &nodeCnt, *debug))\nif nodeCnt != len(arr) {\n\tt.Log(fmt.Sprintf(\"STR\", len(arr), nodeCnt))\n\tt.Fail()\n}", "gen": "var t testing.T\nt.Log(\"Testing GBT\")\nvar bt *binaryTree.GBT\nbt = binaryTree.NewGBT()\nbt.Insert(10)\nbt.Insert(20)\nbt.Insert(30)\nbt.Insert(40)\nbt.Insert(50)\nbt.Insert(60)\nbt.Insert(70)\nbt.Insert(80)\nbt.Insert(90)\nbt.Insert(100)\nbt.Insert(110)\nbt.Insert(120)\nbt.Insert(130)\nbt.Insert(140)\nbt.Insert(150)\nbt.Insert(160)\nbt.Insert(170)\nbt.Insert(180)\nbt.Insert(190)\nbt.Insert(200)\nbt.Insert(210)\nbt.Insert(220)\nbt.Insert(230)\nbt.Insert(240)\nbt.Insert(250)\nbt.Insert(260)\nbt.Insert(270)\nbt.Insert(280)\nbt.Insert(290)\nbt.Insert(300)\nbt.Insert(310)\nbt.Insert(320)\nbt.Insert(330)\nbt.Insert(340)\nbt.Insert(350)\nbt.Insert(360)\nbt.Insert(370)\nbt.Insert(380)\nbt.Insert(390)\nbt.Insert(400)\nbt.Insert(410)\nbt.Insert(420)\nbt.Insert(430)\nbt.Insert(440)\nbt.Insert(450)\nbt.Insert(460)\nbt.Insert(470)"}
{"tgt": "return WordDictionary{}", "gen": "var a [20]int\na[19] = 1\na[18] = 2\na[17] = 3\na[16] = 4\na[15] = 5\na[14] = 6\na[13] = 7\na[12] = 8\na[11] = 9\na[10] = 10\na[9] = 11\na[8] = 12\na[7] = 13\na[6] = 14\na[5] = 15\na[4] = 16\na[3] = 17\na[2] = 18\na[1] = 19\na[0] = 20\nfmt.Println(a)\n}\n"}
{"tgt": "return xtime.Unix(int64(jt), 0)", "gen": "var t time.Time\nt.Unix()\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return append(ints, added...)", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "data, err := base64.StdEncoding.DecodeString(b64)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(data)", "gen": "var s = \"1234567890\"\nvar b []byte\nb = []byte(s)\nvar s2 = \"1234567890\"\nvar b2 []byte\nb2 = []byte(s2)\nvar s3 = \"1234567890\"\nvar b3 []byte\nb3 = []byte(s3)\nvar s4 = \"1234567890\"\nvar b4 []byte\nb4 = []byte(s4)\nvar s5 = \"1234567890\"\nvar b5 []byte\nb5 = []byte(s5)\nvar s6 = \"1234567890\"\nvar b6 []byte\nb6 = []byte(s6)\nvar s7 = \"1234567890\"\nvar b7 []byte\nb7 = []byte(s7)\nvar s8 = \"1234567890\"\nvar b8 []byte\nb8 = []byte(s8)\nvar s9 = \"1234567890\"\nvar b9 []byte\nb9 = []byte(s9)\nvar s10 = \"1234567890\"\nvar b10 []byte\nb10 = []byte(s10)\nvar s11 = \"1234567890\"\nvar b11 []byte\nb11 = []byte(s11)\nvar s12 = \"1234567890\"\nvar b12 []byte\nb12 = []byte(s12)\nvar s13 = \"1234567890\"\nvar b13 []byte\nb13 = []byte(s13)\nvar s14 = \"1234567890\"\n"}
{"tgt": "h := fnv.New64a()\n_, _ = h.Write([]byte(fmt.Sprintf(\"STR\", key)))\nhashValue := h.Sum64()\nreturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))", "gen": "var a, b int\nfmt.Scan(&a, &b)\nfmt.Println(a + b)\n}\n"}
{"tgt": "return fmt.Sprintf(\"STR\", p.Name, p.Age)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aaa int\nvar bbb int\nvar ccc int\nvar ddd int\nvar eee int\nvar fff int\nvar ggg int\nvar hhh int\nvar iii int\nvar jjj int\nvar kkk int\nvar lll int\nvar mmm int\nvar nnn int\nvar ooo int\nvar ppp int\nvar qqq int\nvar rrr int\nvar sss int\nvar ttt int\nvar uuu int\nvar vvv int\nvar www int\nvar xxx int\nvar yyy int\nvar zzz int\nvar aaaa int\nvar bbbb int\nvar cccc int\nvar dddd int\nvar eeee int\nvar ffff int\nvar gggg int\nvar hhhh int\nvar iiii int\nvar jjjj int\n"}
{"tgt": "parent := this\nfor _, ch := range prefix {\n\tif child, ok := parent.Children[ch]; ok {\n\t\tparent = child\n\t\tcontinue\n\t}\n\treturn false\n}\nreturn true", "gen": "var s Solution\ns.Trie = make(map[int]map[int]int)\ns.Insert(\"apple\")\ns.Insert(\"app\")\ns.Insert(\"ap\")\ns.Insert(\"a\")\ns.Insert(\"banana\")\ns.Insert(\"ban\")\ns.Insert(\"ba\")\ns.Insert(\"b\")\ns.Insert(\"ab\")\ns.Insert(\"aa\")\ns.Insert(\"aab\")\ns.Insert(\"aabac\")\ns.Insert(\"aabacd\")\ns.Insert(\"aabacdab\")\ns.Insert(\"aabacdabcd\")\ns.Insert(\"aabacdabcdab\")\ns.Insert(\"aabacdabcdabcd\")\ns.Insert(\"aabacdabcdabcdab\")\ns.Insert(\"aabacdabcdabcdabcd\")\ns.Insert(\"aabacdabcdabcdabcdab\")\ns.Insert(\"aabacdabcdabcdabcdabcd\")\ns.Insert(\"aabacdabcdabcdabcdabcdab\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcd\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdab\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdabcd\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdabcdab\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdabcdabcd\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdabcdabcdab\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdabcdabcdabcd\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdabcdabcdabcdab\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdabcdabcdabcd"}
{"tgt": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aaa int\nvar bbb int\nvar ccc int\nvar ddd int\nvar eee int\nvar fff int\nvar ggg int\nvar hhh int\nvar iii int\nvar jjj int\nvar kkk int\nvar lll int\nvar mmm int\nvar nnn int\nvar ooo int\nvar ppp int\nvar qqq int\nvar rrr int\nvar sss int\nvar ttt int\nvar uuu int\nvar vvv int\nvar www int\nvar xxx int\nvar yyy int\nvar zzz int\nvar aaaa int\nvar bbbb int\nvar cccc int\nvar dddd int\nvar eeee int\nvar ffff int\nvar gggg int\nvar hhhh int\nvar iiii int\nvar jjjj int\n"}
{"tgt": "close(p.work)\np.wg.Wait()", "gen": "var wg sync.WaitGroup\nch := make(chan int)\nwg.Add(1)\ngo func() {\n\tdefer wg.Done()\n\t<-ch\n}()\nwg.Wait()\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "m := make(map[int]struct{})\nfor _, num := range nums1 {\n\tm[num] = struct{}{}\n}\nnums := make([]int, 0)\nfor _, num := range nums2 {\n\tif _, ok := m[num]; ok {\n\t\tnums = append(nums, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn nums", "gen": "var m map[int]struct {\n\ta, b, c int\n}\nm = make(map[int]struct {\n\ta, b, c int\n})\nfor i := 0; i < 1000000; i++ {\n\tm[i] = struct {\n\t\ta, b, c int\n\t}{i, i, i}\n}\nfor i := 0; i < 1000000; i++ {\n\tif m[i].a != i {\n\t\tpanic(\"bad\")\n\t}\n}\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname __morestack runtime.morestack"}
{"tgt": "return h.FromHexString(string(b))", "gen": "var hash go.metainfo.Hash\nhash.FromHexString(\"1234567890123456789012345678901234567890\")\nfmt.Println(hash)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif denoms := EgyptianFractions(tc.numerator, tc.denominator); !reflect.DeepEqual(tc.denominators, denoms) {\n\t\tt.Errorf(\"STR\", tc.denominators, denoms)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "log.SetFlags(0)\nvar err error\ntpl := template.New(\"STR\")\ntpl = tpl.Funcs(template.FuncMap{\n\t\"STR\": func(str string) string {\n\t\treturn strings.ToUpper(str)\n\t},\n})\ntpl, err = tpl.ParseFiles(\"STR\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nerr = tpl.ExecuteTemplate(os.Stdout, \"STR\", Page{\n\tTitle: \"STR\",\n\tBody:  \"STR\",\n})\nif err != nil {\n\tlog.Fatalln(err)\n}", "gen": "log.SetFlags(0)\nt := template.New(\"\")\nt = t.Funcs(template.FuncMap{\n\t\"f\": func(s string) string {\n\t\treturn strings.ToUpper(s)\n\t},\n})\nt, _ = t.ParseFiles(\"test.html\")\np := Page{Title: \"Test Page\", Body: \"This is a test page.\"}\nt.ExecuteTemplate(os.Stdout, \"test.html\", p)\n}\n"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA `structs:\"STR\"`\n\tC  int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif ok {\n\tt.Error(\"STR\")\n}", "gen": "var t TestHasZero_OmitNested\nt.A = 1\nt.B.i1 = 2\nt.B.i2 = 3\nt.B.d = 4\nt.B.i3 = 5\nt.B.i4 = 6\nt.B.i5 = 7\nt.B.i6 = 8\nt.B.i7 = 9\nt.B.i8 = 10\nt.B.i9 = 11\nt.B.i10 = 12\nt.B.i11 = 13\nt.B.i12 = 14\nt.B.i13 = 15\nt.B.i14 = 16\nt.B.i15 = 17\nt.B.i16 = 18\nt.B.i17 = 19\nt.B.i18 = 20\nt.B.i19 = 21\nt.B.i20 = 22\nt.B.i21 = 23\nt.B.i22 = 24\nt.B.i23 = 25\nt.B.i24 = 26\nt.B.i25 = 27\nt.B.i26 = 28\nt.B.i27 = 29\nt.B.i28 = 30\nt.B.i29 = 31\nt.B.i30 = 32\nt.B.i31 = 33\nt.B.i32 = 34\nt.B.i33 = 35\nt.B.i34 = 36\nt.B.i35 = 37\nt.B.i36 = 38\nt.B.i37 = 39\nt.B."}
{"tgt": "digits := convert(N + 1)\nbits := len(digits)\nnoRepeat := 0\nfor b := 1; b < bits; b++ {\n\tnoRepeat += 9 * count(9, b-1)\n}\nhasSeen := make(map[int]bool, 10)\nfor b := 0; b < bits; b++ {\n\td := 0\n\tif b == 0 {\n\t\td = 1\n\t}\n\tfor ; d < digits[b]; d++ {\n\t\tif !hasSeen[d] {\n\t\t\tnoRepeat += count(9-b, bits-b-1)\n\t\t}\n\t}\n\tif hasSeen[digits[b]] {\n\t\tbreak\n\t}\n\thasSeen[digits[b]] = true\n}\nreturn N - noRepeat", "gen": "var a [10]int\nvar b [10]bool\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar ba [10]int\nvar bb [10]int\nvar bc [10]int\n"}
{"tgt": "return me[0] == \"STR\"", "gen": "var a [10]int\na[1] = 1\na[2] = 2\na[3] = 3\na[4] = 4\na[5] = 5\na[6] = 6\na[7] = 7\na[8] = 8\na[9] = 9\na[10] = 10\na[11] = 11\na[12] = 12\na[13] = 13\na[14] = 14\na[15] = 15\na[16] = 16\na[17] = 17\na[18] = 18\na[19] = 19\na[20] = 20\na[21] = 21\na[22] = 22\na[23] = 23\na[24] = 24\na[25] = 25\na[26] = 26\na[27] = 27\na[28] = 28\na[29] = 29\na[30] = 30\na[31] = 31\na[32] = 32\na[33] = 33\na[34] = 34\na[35] = 35\na[36] = 36\na[37] = 37\na[38] = 38\na[39] = 39\na[40] = 40\na[41] = 41\na[42] = 42\na[43] = 43\na[44] = 44\na[45] = 45\na[46] = 46\na["}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil {\n\t\t\tmax = max.Right\n\t\t}\n\t\tmax.Right = root\n\t\troot, root.Left = root.Left, nil\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aaa [3]int\nvar aab [3]int\nvar aac [3]int\nvar aad [3]int\nvar aae [3]int\nvar aaf [3]int\nvar aag [3]int\nvar aah [3]int\nvar aai [3]int\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   0x5555,\n\t\twant: 8,\n\t},\n}\nfor _, tt := range tests {\n\tgot := hammingWeight(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var a uint32 = 0x00000000\nvar b uint32 = 0x00000001\nvar c uint32 = 0x00000002\nvar d uint32 = 0x00000003\nvar e uint32 = 0x00000004\nvar f uint32 = 0x00000005\nvar g uint32 = 0x00000006\nvar h uint32 = 0x00000007\nvar i uint32 = 0x00000008\nvar j uint32 = 0x00000009\nvar k uint32 = 0x0000000a\nvar l uint32 = 0x0000000b\nvar m uint32 = 0x0000000c\nvar n uint32 = 0x0000000d\nvar o uint32 = 0x0000000e\nvar p uint32 = 0x0000000f\nvar q uint32 = 0x00000010\nvar r uint32 = 0x00000011\nvar s uint32 = 0x00000012\nvar t uint32 = 0x00000013\nvar u uint32 = 0x00000014\nvar v uint32 = 0x00000015\nvar w uint32 = 0x00000016\nvar x uint32 = 0x00000017\nvar y uint32 = 0x00000018\nvar z uint32 = 0x00000019\nvar aa uint32"}
{"tgt": "if a == nil && b == nil {\n\treturn true\n}\nif len(a) != len(b) {\n\treturn false\n}\nfor i := range a {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "return xtime.Unix(int64(jt), 0), nil", "gen": "var t time.Time\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\n"}
{"tgt": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 0},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 11},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 19},\n\t\tans1208{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s, p.t, p.maxCost))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{}\n} else if n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{intervals[0]}\nfor _, cur := range intervals[1:] {\n\tprevious := res[len(res)-1]\n\tif cur.Start <= previous.End {\n\t\tend := previous.End\n\t\tif cur.End > end {\n\t\t\tend = cur.End\n\t\t}\n\t\tres = append(res[:len(res)-1], Interval{Start: previous.Start, End: end})\n\t} else {\n\t\tres = append(res, cur)\n\t}\n}\nreturn res", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "result := make([]int, 0, len(left)+len(right))\nfor len(left) > 0 || len(right) > 0 {\n\tif len(left) == 0 {\n\t\treturn append(result, right...)\n\t}\n\tif len(right) == 0 {\n\t\treturn append(result, left...)\n\t}\n\tif left[0] <= right[0] {\n\t\tresult = append(result, left[0])\n\t\tleft = left[1:]\n\t} else {\n\t\tresult = append(result, right[0])\n\t\tright = right[1:]\n\t}\n}\nreturn result", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "t.Parallel()\nd := NewTimeMap()\nd.Set(1, 1, 0)\nd.Set(1, 2, 2)\nif result := d.Get(1, 1); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 3); result != 2 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 5)\nif result := d.Get(1, 0); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 10); result != 1 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 0)\nd.Set(1, 2, 0)\nif result := d.Get(1, 0); result != 2 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(2, 0); result != nil {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, -1); result != nil {\n\tt.Errorf(\"STR\")\n}", "gen": "testing.M()\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname __morestack runtime.morestack"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{2},\n\t\t\t{3, 4},\n\t\t\t{6, 5, 7},\n\t\t\t{4, 1, 8, 3},\n\t\t},\n\t\t11},\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{1},\n\t\t\t{2, 3},\n\t\t},\n\t\t3},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := minimumTotal(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "pairs := [...][2]int{{15, 26}, {1000, 1366}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p16(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var p16 [2]int\np16[0] = 15\np16[1] = 26\nvar p1000 [2]int\np1000[0] = 1366\np1000[1] = 1000\nvar p1 [2]int\np1[0] = 15\np1[1] = 26\nvar p2 [2]int\np2[0] = 1366\np2[1] = 1000\nvar p3 [2]int\np3[0] = 15\np3[1] = 26\nvar p4 [2]int\np4[0] = 1366\np4[1] = 1000\nvar p5 [2]int\np5[0] = 15\np5[1] = 26\nvar p6 [2]int\np6[0] = 1366\np6[1] = 1000\nvar p7 [2]int\np7[0] = 15\np7[1] = 26\nvar p8 [2]int\np8[0] = 1366\np8[1] = 1000\nvar p9 [2]int\np9[0] = 15\np9[1] = 26\nvar p10 [2]int\np10[0] = 1366\np10[1] = 1000\nvar p11 [2]int\np11[0] = 15\np11[1] = 26\nvar p12 [2]int\np12[0] = 1366\np12[1] = 1000\nvar p13 [2]int\np13[0]"}
{"tgt": "m := [26]int{}\nfor _, b := range B {\n\tcount := counter(b)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tm[i] = count[i]\n\t\t}\n\t}\n}\nres := []string{}\nfor _, a := range A {\n\tcount := counter(a)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tcontinueL\n\t\t}\n\t}\n\tres = append(res, a)\n}\nreturn res", "gen": "var a [26]string\nvar b [26]string\nvar c [26]string\nvar d [26]string\nvar e [26]string\nvar f [26]string\nvar g [26]string\nvar h [26]string\nvar i [26]string\nvar j [26]string\nvar k [26]string\nvar l [26]string\nvar m [26]string\nvar n [26]string\nvar o [26]string\nvar p [26]string\nvar q [26]string\nvar r [26]string\nvar s [26]string\nvar t [26]string\nvar u [26]string\nvar v [26]string\nvar w [26]string\nvar x [26]string\nvar y [26]string\nvar z [26]string\nvar aa [26]string\nvar bb [26]string\nvar cc [26]string\nvar dd [26]string\nvar ee [26]string\nvar ff [26]string\nvar gg [26]string\nvar hh [26]string\nvar ii [26]string\nvar jj [26]string\nvar kk [26]string\nvar ll [26]string\nvar mm [26]string\nvar nn [26]string\nvar oo [26]string\nvar pp [26]string\nvar qq [26]string\nvar rr [26]string\nvar ss [26]string\nvar tt [26]string\nvar uu [26]string\nvar vv [26]string\nvar ww [26]string\nvar xx [26]string\nvar yy [26]string\nvar zz [26]string\nvar aaa [26]string\nvar bbb [26]"}
{"tgt": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\ntmp := nums[0]\nmax := tmp\nfor i := 1; i < n; i++ {\n\tif tmp < 0 {\n\t\ttmp = nums[i]\n\t} else {\n\t\ttmp += nums[i]\n\t}\n\tif max < tmp {\n\t\tmax = tmp\n\t}\n}\nreturn max", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor"}
{"tgt": "hash := uint32(0)\nfor i := len(sep) - 1; i >= 0; i-- {\n\thash = hash*PrimeRK + uint32(sep[i])\n}\nvar pow, sq uint32 = 1, PrimeRK\nfor i := len(sep); i > 0; i >>= 1 {\n\tif i&1 != 0 {\n\t\tpow *= sq\n\t}\n\tsq *= sq\n}\nreturn hash, pow", "gen": "var a [10]int\nvar b [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < 10; i++ {\n\ta[i] += b[i]\n}\nfmt.Println(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "b, _ := ioutil.ReadFile(\"STR\")\ns := strings.Replace(string(b), \"STR\", \"STR\", -1)\nnumData := strings.Split(s, \"STR\")\nfor _, n := range numData {\n\tnumber, err := strconv.Atoi(n)\n\tif err == nil {\n\t\tdata = append(data, number)\n\t}\n}", "gen": "var data [3]int\nvar line string\nvar err error\nif line, err = io.ReadFile(\"input.txt\"); err != nil {\n\tpanic(err)\n}\nvar lines []string\nif lines = strings.Split(line, \"\\n\"); err != nil {\n\tpanic(err)\n}\nfor i, line := range lines {\n\tvar nums []int\n\tif nums, err = strconv.Atoi(strings.Replace(line, \",\", \"\", -1)); err != nil {\n\t\tpanic(err)\n\t}\n\tdata[i] = nums[0]\n}\nfmt.Println(data)\n}\n"}
{"tgt": "if len(A) == len(A[0]) {\n\tfor i := 0; i < len(A); i++ {\n\t\tfor j := 0; j < len(A); j++ {\n\t\t\tif i == j {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]\n\t\t}\n\t}\n\treturn A\n}\nres := make([][]int, len(A[0]))\nfor i := 0; i < len(res); i++ {\n\tres[i] = make([]int, len(A))\n\tfor j := 0; j < len(A); j++ {\n\t\tres[i][j] = A[j][i]\n\t}\n}\nreturn res", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := SumRevLLNum(tc.first, tc.second); !equal(result, tc.sum) {\n\t\tt.Errorf(\"STR\",\n\t\t\ttcid, String(result), String(tc.sum))\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tm: 3,\n\t\tn: 3,\n\t\tops: [][]int{\n\t\t\t{2, 2},\n\t\t\t{3, 3},\n\t\t},\n\t\twant: 4,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxCount(tt.m, tt.n, tt.ops)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.m, got, tt.want)\n\t}\n}", "gen": "var a [5]int\nvar b [5]int\nvar c [5]int\nvar d [5]int\nvar e [5]int\nvar f [5]int\nvar g [5]int\nvar h [5]int\nvar i [5]int\nvar j [5]int\nvar k [5]int\nvar l [5]int\nvar m [5]int\nvar n [5]int\nvar o [5]int\nvar p [5]int\nvar q [5]int\nvar r [5]int\nvar s [5]int\nvar t [5]int\nvar u [5]int\nvar v [5]int\nvar w [5]int\nvar x [5]int\nvar y [5]int\nvar z [5]int\nvar aa [5]int\nvar ab [5]int\nvar ac [5]int\nvar ad [5]int\nvar ae [5]int\nvar af [5]int\nvar ag [5]int\nvar ah [5]int\nvar ai [5]int\nvar aj [5]int\nvar ak [5]int\nvar al [5]int\nvar am [5]int\nvar an [5]int\nvar ao [5]int\nvar ap [5]int\nvar aq [5]int\nvar ar [5]int\nvar as [5]int\nvar at [5]int\nvar au [5]int\nvar av [5]int\nvar aw [5]int\nvar ax [5]int\nvar ay [5]int\nvar az [5]int\nvar aaa [5]int\nvar aab [5]int\nvar aac [5]int\nvar aad [5]int\nvar aae [5]int\nvar aaf [5]int\nvar aag [5]int\nvar aah [5]int\nvar aai [5]int\n"}
{"tgt": "n := len(quality)\nworkers := make([][2]float64, n)\nfor i := 0; i < n; i++ {\n\tw, q := float64(wage[i]), float64(quality[i])\n\tworkers[i][0], workers[i][1] = w/q, q\n}\nsort.Slice(workers, func(i, j int) bool {\n\treturn workers[i][0] < workers[j][0]\n})\nres := math.MaxFloat64\nsum := 0.\nh := floatHeap{}\nfor _, w := range workers {\n\tsum += w[1]\n\theap.Push(&h, w[1])\n\tif len(h) > K {\n\t\tsum -= heap.Pop(&h).(float64)\n\t}\n\tif len(h) == K {\n\t\tres = min(res, sum*w[0])\n\t}\n}\nreturn res", "gen": "var a = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar b = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar c = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar d = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar e = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar f = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar g = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar h = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar i = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar j = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar k = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar l = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar m = []float64{1, 2, 3, 4,"}
{"tgt": "flag.Parse()\nroots := flag.Args()\nif len(roots) == 0 {\n\troots = []string{\"STR\"}\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, root := range roots {\n\t\twalkDir(root, fileSizes)\n\t}\n\tclose(fileSizes)\n}()\nvar nfiles, nbytes int64\nfor size := range fileSizes {\n\tnfiles++\n\tnbytes += size\n}\nprintDiskUsage(nfiles, nbytes)", "gen": "flag.Parse()\nargs := flag.Args()\nif len(args) != 2 {\n\tfmt.Println(\"Usage:\", os.Args[0], \"source_file dest_file\")\n\tos.Exit(1)\n}\nsource := args[0]\ndest := args[1]\nfileSizes := make(chan int64)\ngo func() {\n\tfileSizes <- getFileSize(source)\n}()\ngo func() {\n\tfileSizes <- getFileSize(dest)\n}()\nroots := make(chan string)\ngo func() {\n\troots <- source\n\troots <- dest\n\tclose(roots)\n}()\nvar total int64\nfor path := range roots {\n\tfileSizes <- walk(path, fileSizes)\n}\nfor size := range fileSizes {\n\ttotal += size\n}\nprintDiskUsage(total)\n}"}
{"tgt": "var min int\ntotalPeople := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\ttotalPeople++\n\t}\n}\nif totalPeople < 2 {\n\treturn 0\n}\nmiddle := (totalPeople / 2) + (totalPeople % 2)\nindex := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\tmiddle--\n\t}\n\tif middle == 0 {\n\t\tindex = i\n\t\tbreak\n\t}\n}\nleftZero := 0\nleftZeroFound := false\nfor j := index - 1; j >= 0; j-- {\n\tif !leftZeroFound && seating[j] == 0 {\n\t\tleftZero = j\n\t\tleftZeroFound = true\n\t} else if seating[j] == 1 && j < leftZero {\n\t\tmin += abs(j - leftZero)\n\t\tleftZero--\n\t}\n}\nrightZero := 0\nrightZeroFound := false\nfor j := index + 1; j < len(seating); j++ {\n\tif !rightZeroFound && seating[j] == 0 {\n\t\trightZero = j\n\t\trightZeroFound = true\n\t} else if seating[j] == 1 && j > rightZero {\n\t\tmin += abs(j - rightZero)\n\t\trightZero++\n\t}\n}\nreturn min", "gen": "var a [3]int\nvar b [3]int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar ba int\nvar bb int\nvar bc int\nvar bd int\nvar be int\nvar bf int\nvar bg int\nvar bh int\nvar bi int\nvar bj int\nvar bk int\nvar bl int\nvar bm int\nvar bn int\nvar bo int\nvar bp int\nvar bq int\nvar br int\nvar bs int\nvar bt int\nvar bu int\nvar bv int\nvar bw int\nvar bx int\nvar by int\nvar bz int\nvar ca int\nvar cb int\nvar cc int\nvar cd int\nvar ce int\nvar cf int\nvar cg int\nvar ch int\nvar ci int\nvar cj int\nvar ck int\nvar cl int\nvar cm int\nvar cn int\nvar co int\nvar cp int\n"}
{"tgt": "sum := 0\nprev := 1\ncurr := 1\nfor curr <= 4e6 {\n\tprev, curr = curr, prev+curr\n\tif curr%2 == 0 {\n\t\tsum += curr\n\t}\n}\nfmt.Println(sum)", "gen": "var a int\nvar b int\nvar c int\na = 1\nb = 1\nc = 1\nfor i := 0; i < 4000000; i++ {\n\ta = a + b\n\tb = a + c\n\tc = b + a\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "stack := make([]int, 0)\nresult := make([]int, len(T))\nfor i, t := range T {\n\tfor len(stack) > 0 && T[stack[len(stack)-1]] < t {\n\t\tresult[stack[len(stack)-1]] = i - stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t}\n\tstack = append(stack, i)\n}\nfor _, i := range stack {\n\tresult[i] = 0\n}\nreturn result", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 2}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello, world\")\n}\n"}
{"tgt": "out := 100\nif x := p33(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "var p33 *int\nvar p34 *int\nvar p35 *int\nvar p36 *int\nvar p37 *int\nvar p38 *int\nvar p39 *int\nvar p40 *int\nvar p41 *int\nvar p42 *int\nvar p43 *int\nvar p44 *int\nvar p45 *int\nvar p46 *int\nvar p47 *int\nvar p48 *int\nvar p49 *int\nvar p50 *int\nvar p51 *int\nvar p52 *int\nvar p53 *int\nvar p54 *int\nvar p55 *int\nvar p56 *int\nvar p57 *int\nvar p58 *int\nvar p59 *int\nvar p60 *int\nvar p61 *int\nvar p62 *int\nvar p63 *int\nvar p64 *int\nvar p65 *int\nvar p66 *int\nvar p67 *int\nvar p68 *int\nvar p69 *int\nvar p70 *int\nvar p71 *int\nvar p72 *int\nvar p73 *int\nvar p74 *int\nvar p75 *int\nvar p76 *int\nvar p77 *int\nvar p78 *int\nvar p79 *int\nvar p80 *int\nvar p81 *int\nvar p82 *int\nvar p83 *int\nvar p84 *int\nvar p85 *int\nvar p86 *int\nvar p87 *int\nvar p88 *int\nvar p89 *int\nvar p90 *int\nvar p91 *int\nvar p92 *int\nvar p93 *int\nvar p94 *int\nvar p9"}
