{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif sum := SumBSTRange(tc.root, tc.a, tc.b); sum != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, sum)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "return &linkLoop{\n\tHead: &linkLoopNode{},\n}", "gen": "var linkLoop *linkLoopNode\nlinkLoop = new(linkLoopNode)\nlinkLoop.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoop = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoop.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoop.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoop.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoop.link"}
{"tgt": "return bindataRead(\n\t_assetsHomeCatJpg,\n\t\"STR\",\n)", "gen": "var homeCatJpg []byte\nvar homeCatJpg2 []byte\nvar homeCatJpg3 []byte\nvar homeCatJpg4 []byte\nvar homeCatJpg5 []byte\nvar homeCatJpg6 []byte\nhomeCatJpg = bindataRead(homeCatJpg, homeCatJpg2, homeCatJpg3, homeCatJpg4, homeCatJpg5, homeCatJpg6, 19, \".\", \"assets/homeCat.jpg\")\nreturn homeCatJpg\n}\n\n// func bindataRead(homeCatJpg []byte, homeCatJpg2 []byte, homeCatJpg3 []byte, homeCatJpg4 []byte, homeCatJpg5 []byte, homeCatJpg6 []byte, n int, p string, s string) []byte\n// func bindataRead(homeCatJpg []byte, homeCatJpg2 []byte, homeCatJpg3 []byte, homeCatJpg4 []byte, homeCatJpg5 []byte, homeCatJpg6 []byte, n int, p string, s string) []byte {\n// \thomeCatJpg = append(homeCatJpg, homeCatJpg2...)\n// \thomeCatJpg = append(homeCatJpg, homeCatJpg3...)\n// \thomeCatJpg = append(homeCatJpg, homeCatJpg4...)\n// \thomeCatJpg = append(homeCatJpg, homeCatJpg5...)\n// \thomeCatJpg = append(homeCatJpg, homeCatJpg6...)\n// \treturn homeCatJpg\n// }\n\n// func append(s []byte, elems ...byte) []byte {\n// \tvar s1 []byte\n// \ts1 = append(s1, elems...)\n// \treturn s1\n// }\n\n// func append(s []byte, elems ...byte) []byte {\n// \tvar s1 []byte\n// \ts1 = append(s1, elems...)\n// \treturn s1\n// }\n\n// func append(s []byte, elems ...byte)"}
{"tgt": "max := 1000\nsum := 0\nfor i := 1; i < max; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)", "gen": "var a int\nfor i := 1; i < 1000; i++ {\n\tif i%2 == 0 {\n\t\ta += i\n\t} else {\n\t\ta += i * i\n\t}\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.locs); !reflect.DeepEqual(bonuses, tc.bonuses) {\n\t\tt.Errorf(\"STR\", tc.bonuses, bonuses)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "max := 9999\nbiggestPandigital := 0\nvar numberMultiplied int\nfor i := max; i > 0; i-- {\n\tnumberMultiplied = i\n\tfor j := 1; len(digits(numberMultiplied)) <= 9; j++ {\n\t\tnumberMultiplied = concatenMultiplication(i, j)\n\t\tif IsPandigital(numberMultiplied) && numberMultiplied > biggestPandigital {\n\t\t\tfmt.Println(numberMultiplied)\n\t\t\tbiggestPandigital = numberMultiplied\n\t\t}\n\t}\n}", "gen": "var pandigital []int\nfor i := 9999; i > 0; i-- {\n\tif IsPandigital(i) {\n\t\tpandigital = append(pandigital, i)\n\t}\n}\nfor _, i := range pandigital {\n\tif IsPandigital(i * i) {\n\t\tfmt.Println(i, i*i)\n\t}\n}\n}"}
{"tgt": "for {\n\tswitch r := l.next(); {\n\tcase unicode.IsNumber(r):\n\tcase r == \"STR\":\n\t\tl.backup()\n\t\tl.emit(itemEnd)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase r == eof:\n\t\tl.emit(itemEnd)\n\t\treturn byteRangeSet\n\tdefault:\n\t\treturn l.error(\"STR\")\n\t}\n}", "gen": "var r *httprange.Lexer\nr = httprange.NewLexer(\"bytes=0-100\")\nfor {\n\tif r.Next() == 1 {\n\t\tif unicode.IsNumber(r.Peek()) {\n\t\t\tr.Backup()\n\t\t\tr.Emit(4)\n\t\t\tr.Chomp()\n\t\t\tcontinue\n\t\t}\n\t\tif r.Peek() == 44 {\n\t\t\tr.Backup()\n\t\t\tr.Emit(4)\n\t\t\tr.Chomp()\n\t\t\tcontinue\n\t\t}\n\t\tif unicode.IsNumber(r.Peek()) {\n\t\t\tr.Backup()\n\t\t\tr.Emit(4)\n\t\t\tcontinue\n\t\t}\n\t\tr.Error(fmt.Errorf(\"expected byte range set\"))\n\t\tcontinue\n\t}\n\tbreak\n}\nreturn\n}\n"}
{"tgt": "return func(treebinaryTreeIf, node interface{}) bool {\n\tn := node.(*gbtElement)\n\tif !tree.IsNil(n.Left) && n.Left.Key >= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Left, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif !tree.IsNil(n.Right) && n.Right.Key <= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Right, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif debug {\n\t\tfmt.Println(n)\n\t}\n\t*nodeCnt++\n\treturn false\n}", "gen": "var t1 testing.T\nvar b1 bool\nvar n1 int\nvar c1 *go.binaryTree.checkGBT\nc1 = &go.binaryTree.checkGBT{t1, b1, n1}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "iterator := func() <-chan VertexId {\n\tch := make(chan VertexId)\n\tgo func() {\n\t\tif connected, ok := g.edges[vertex]; ok {\n\t\t\tfor VertexId, _ := range connected {\n\t\t\t\tif g.IsEdge(vertex, VertexId) {\n\t\t\t\t\tch <- VertexId\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\nreturn VerticesIterable(&vertexIterableHelper{iterFunc: iterator})", "gen": "g := graph.NewGraph()\nv1 := g.AddVertex(1)\nv2 := g.AddVertex(2)\ng.AddEdge(v1, v2)\nfmt.Println(g)\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 2, 1}, []int{0, 4, 1, 3, 2}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1}, []int{0}, []int{1}},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums, c.index)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums, c.index)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.nums = []int{1, 2, 3, 4}\nsolution.index = 0\nsolution.expect = 5\nsolution.name = \"TestSolution\"\ntesting.MainM(&testing.M{\n\tMatches: []string{\"TestSolution\"},\n\tBenchmarks: []testing.InternalBenchmark{\n\t\ttesting.InternalBenchmark{\n\t\t\tName: \"TestSolution\",\n\t\t\tF: func(b *testing.B) {\n\t\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t\tsolution.c1()\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t},\n}, nil, []testing.InternalBenchmark{})\n}"}
{"tgt": "c.bw.WriteString(\"STR\")\nc.bw.WriteByte(space)\nc.bw.WriteString(key)\nc.bw.WriteByte(space)\nc.bw.Write(strconv.AppendInt(c.numScratch[:0], int64(timeout), 10))\n_, err = c.bw.Write(crlf)\nreturn", "gen": "var w io.Writer\nvar b *bufio.Writer\nvar err error\nvar s string\nvar i int\nvar n int64\nvar n2 int64\nvar n3 int64\nvar n4 int64\nvar n5 int64\nvar n6 int64\nvar n7 int64\nvar n8 int64\nvar n9 int64\nvar n10 int64\nvar n11 int64\nvar n12 int64\nvar n13 int64\nvar n14 int64\nvar n15 int64\nvar n16 int64\nvar n17 int64\nvar n18 int64\nvar n19 int64\nvar n20 int64\nvar n21 int64\nvar n22 int64\nvar n23 int64\nvar n24 int64\nvar n25 int64\nvar n26 int64\nvar n27 int64\nvar n28 int64\nvar n29 int64\nvar n30 int64\nvar n31 int64\nvar n32 int64\nvar n33 int64\nvar n34 int64\nvar n35 int64\nvar n36 int64\nvar n37 int64\nvar n38 int64\nvar n39 int64\nvar n40 int64\nvar n41 int64\nvar n42 int64\nvar n43 int64\nvar n44 int64\nvar n45 int64\nvar n46 int64\nvar n47 int64\nvar n48 int64\nvar n49 int64\nvar n50 int64\nvar n51 int64\nvar n52 int64\nvar n53 int64\nvar"}
{"tgt": "for V > 0 {\n\tV--\n\tif !isDroppedLeft(heights, K) && !isDroppedRight(heights, K) {\n\t\theights[K]++\n\t}\n}\nreturn heights", "gen": "var n, k int\nfmt.Scan(&n, &k)\na := make([]int, n)\nfor i := 0; i < n; i++ {\n\tfmt.Scan(&a[i])\n}\nfor i := 0; i < n; i++ {\n\tif isDroppedLeft(a, i, k) {\n\t\tcontinue\n\t}\n\tif isDroppedRight(a, i, k) {\n\t\tcontinue\n\t}\n\ta[i]++\n}\nfmt.Println(a[0], a[1], a[2])\n}\n"}
{"tgt": "h := &IntMaxHeap{}\nheap.Init(h)\nheap.Push(h, 7)\nheap.Push(h, 3)\nheap.Push(h, 2)\nheap.Push(h, 1)\nheap.Push(h, 5)\nheap.Push(h, 5)\nheap.Push(h, 6)\nheap.Push(h, 7)\nfmt.Printf(\"STR\", (*h))\nfor h.Len() > 0 {\n\tfmt.Printf(\"STR\", heap.Pop(h))\n}", "gen": "heap := &Solution{[]int{3, 2, 1}}\nheap.Init()\nheap.Push(2)\nheap.Push(1)\nheap.Push(5)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(1)\nheap.Push"}
{"tgt": "sLen, pLen := len(s), len(p)\ndp := make([][]bool, sLen+1)\nfor i := range dp {\n\tdp[i] = make([]bool, pLen+1)\n}\ndp[sLen][pLen] = true\nfor i := sLen; i > -1; i-- {\n\tfor j := pLen - 1; j > -1; j-- {\n\t\tfirstMatch := i < sLen && (p[j] == s[i] || p[j] == '.')\n\t\tif j+1 < pLen && p[j+1] == '*' {\n\t\t\tdp[i][j] = dp[i][j+2] || firstMatch && dp[i+1][j]\n\t\t} else {\n\t\t\tdp[i][j] = firstMatch && dp[i+1][j+1]\n\t\t}\n\t}\n}\nreturn dp[0][0]", "gen": "var a []bool\nvar b []bool\nvar c []bool\nvar d bool\na = make([]bool, 1)\nb = make([]bool, 1)\nc = make([]bool, 1)\nd = false\nfor i := 0; i < len(b); i++ {\n\tif i < len(a) {\n\t\td = a[i]\n\t}\n\tif i < len(c) {\n\t\tb[i] = c[i]\n\t}\n\tif i < len(b) {\n\t\tb[i] = d\n\t}\n}\nif c[0] {\n\treturn\n}\nif b[0] {\n\treturn\n}\nif a[0] {\n\treturn\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "l1 := len(board)\nif l1 == 0 {\n\treturn\n}\nl2 := len(board[0])\nif l2 == 0 {\n\treturn\n}\nvisit := make([][]bool, l1)\nfor i := 0; i < l1; i++ {\n\tvisit[i] = make([]bool, l2)\n}\nfor i := 0; i < l1; i++ {\n\tfor j := 0; j < l2; j++ {\n\t\tif !visit[i][j] {\n\t\t\thelper(board, visit, i, j)\n\t\t}\n\t}\n}", "gen": "var a []bool\nvar b []bool\nvar c []bool\nvar d []bool\nvar e []bool\nvar f []bool\nvar g []bool\nvar h []bool\nvar i []bool\nvar j []bool\nvar k []bool\nvar l []bool\nvar m []bool\nvar n []bool\nvar o []bool\nvar p []bool\nvar q []bool\nvar r []bool\nvar s []bool\nvar t []bool\nvar u []bool\nvar v []bool\nvar w []bool\nvar x []bool\nvar y []bool\nvar z []bool\nvar aa []bool\nvar bb []bool\nvar cc []bool\nvar dd []bool\nvar ee []bool\nvar ff []bool\nvar gg []bool\nvar hh []bool\nvar ii []bool\nvar jj []bool\nvar kk []bool\nvar ll []bool\nvar mm []bool\nvar nn []bool\nvar oo []bool\nvar pp []bool\nvar qq []bool\nvar rr []bool\nvar ss []bool\nvar tt []bool\nvar uu []bool\nvar vv []bool\nvar ww []bool\nvar xx []bool\nvar yy []bool\nvar zz []bool\nvar aa1 []bool\nvar bb1 []bool\nvar cc1 []bool\nvar dd1 []bool\nvar ee1 []bool\nvar ff1 []bool\nvar gg1 []bool\nvar hh1 []bool\nvar ii1 []bool\nvar jj1 []bool\nvar kk1 []bool\nvar ll1 []bool\nvar mm1 []bool\nvar nn1 []bool\nvar oo1 []bool\nvar pp1 []bool\nvar qq1 []bool\nvar rr1 []bool\nvar ss1 []bool\nvar tt1 []bool\nvar uu1 []bool\nvar vv1 []bool\nvar ww1 []bool\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.nums); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "sum := 100 * 101 / 2\nsqSum := sum * sum\nsumSq := 0\nfor i := 1; i <= 100; i++ {\n\tsumSq += i * i\n}\nfmt.Println(sqSum - sumSq)", "gen": "var a int\na = 5050\nvar b int\nb = 0\nfor i := 1; i <= 100; i++ {\n\tb += a\n\ta *= i\n}\nvar c int\nc = b\nvar d int\nd = c\nvar e int\ne = d\nvar f int\nf = e\nvar g int\ng = f\nvar h int\nh = g\nvar i int\ni = h\nvar j int\nj = i\nvar k int\nk = j\nvar l int\nl = k\nvar m int\nm = l\nvar n int\nn = m\nvar o int\no = n\nvar p int\np = o\nvar q int\nq = p\nvar r int\nr = q\nvar s int\ns = r\nvar t int\nt = s\nvar u int\nu = t\nvar v int\nv = u\nvar w int\nw = v\nvar x int\nx = w\nvar y int\ny = x\nvar z int\nz = y\nvar aa int\naa = z\nvar bb int\nbb = aa\nvar cc int\ncc = bb\nvar dd int\ndd = cc\nvar ee int\nee = dd\nvar ff int\nff = ee\nvar gg int\ngg = ff\nvar hh int\nhh = gg\nvar ii int\nii = hh\nvar jj int\njj = ii\nvar kk int\nkk = jj\nvar ll int\nll = kk\nvar mm int\nmm = ll\nvar nn int\nnn = mm\nvar oo int\noo = nn\nvar pp int\npp = oo\nvar qq int\nqq = pp\nvar rr int\nrr = qq\nvar ss"}
{"tgt": "return x != y", "gen": "var a float32 = 1.0\nvar b float32 = 2.0\nvar c bool\nc = a < b\nfmt.Println(c)\n}\n\n// 0000000000000000 <main>:\n// \t.cfi_startproc\n// \t.cfi_personality 0x0,__gxx_personality_v0\n// \t.cfi_lsda 0x1,.LLSDA2\n// \t.cfi_loc 1 1 0\n// \tpushq %rbp\n// \tmovq %rsp,%rbp\n// \tsubq $48,%rsp\n// \tmovss %xmm0,-24(%rbp)\n// \tmovss %xmm1,-20(%rbp)\n// \tmovb $0,-1(%rbp)\n// \tmovss -24(%rbp),%xmm0\n// \tucomiss -20(%rbp),%xmm0\n// \tsetp %al\n// \tmovl $1,%edx\n// \tmovss -24(%rbp),%xmm0\n// \tucomiss -20(%rbp),%xmm0\n// \tcmovne %edx,%eax\n// \tmovb %al,-1(%rbp)\n// \tmovzbl -1(%rbp),%eax\n// \tleave\n// \tret\n// \t.cfi_endproc\n// \t.size main, .-main\n// \t.section .rodata\n// \t.align 8\n// .LLSDA2:\n// \t.byte 0x1\n// \t.byte 0x10\n// \t.byte 0x1\n// \t.byte 0x10\n// \t.byte 0x2\n// \t.byte 0x10\n// \t.byte 0x1\n// \t.byte 0x10\n// \t.byte 0x"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 1, 3}},\n\t\tans1051{3},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 2, 3, 4}},\n\t\tans1051{5},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{0},\n\t},\n\t{\n\t\tpara1051{[]int{5, 4, 3, 2, 1}},\n\t\tans1051{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%d %d %d\\n\", 1, 2, 3)\nfmt.Printf(\"%d %d %d\\n\", 4, 1, 2)\nfmt.Printf(\"%d %d %d\\n\", 3, 4, 2)\nfmt.Printf(\"%d %d %d\\n\", 5, 1, 2)\nfmt.Printf(\"%d %d %d\\n\", 5, 4, 3)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5,"}
{"tgt": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"STR\", got, tt.want)\n\t\t}\n\t})\n}", "gen": "tests := []struct {\n\tname string\n\targs args\n\twant int\n}{\n\t{\"\", args{\"abcde\", \"cdefg\"}, 2},\n\t{\"\", args{\"abcd\", \"cdab\"}, 4},\n\t{\"\", args{\"abc\", \"abc\"}, 3},\n\t{\"\", args{\"ab\", \"ab\"}, 3},\n\t{\"\", args{\"a\", \"a\"}, 3},\n\t{\"\", args{\"aa\", \"aa\"}, 3},\n\t{\"\", args{\"aaa\", \"aaa\"}, 3},\n\t{\"\", args{\"aaaaa\", \"aaaaa\"}, 3},\n\t{\"\", args{\"aabbaa\", \"aabbaa\"}, 3},\n\t{\"\", args{\"aabbaa\", \"aabba\"}, 4},\n\t{\"\", args{\"aabbaa\", \"baaab\"}, 4},\n\t{\"\", args{\"aabbaa\", \"ababab\"}, 6},\n\t{\"\", args{\"aabbaa\", \"abbaab\"}, 6},\n\t{\"\", args{\"aabbaa\", \"ababba\"}, 6},\n\t{\"\", args{\"aabbaa\", \"baabab\"}, 6},\n\t{\"\", args{\"aabbaa\", \"babaab\"}, 6},\n\t{\"\", args{\"aabbaa\", \"ababba\"}, 6},\n\t{\"\", args{\"aabbaa\", \"baabab\"}, 6},\n\t{\"\", args{\"aabbaa\", \"babaab\"}, 6},\n\t{\"\", args{\"aabbaa\", \"ababba\"}, 6},\n\t{\"\", args{\"aabbaa\", \"baabab\"}, 6},\n\t{\"\", args{\"aabbaa\", \"babaab\"}, 6},\n\t{\"\", args{\"aabbaa\", \"ababba\"}, 6},\n\t{\"\", args{\"aabbaa\", \"baabab\"}, 6},\n\t{\"\", args{\"aabbaa\", \"babaab\"}, 6},\n\t{\"\","}
{"tgt": "if m == 0 {\n\treturn 1\n}\nswitch n {\ncase 1:\n\treturn 2\ncase 2:\n\tif m == 1 {\n\t\treturn 3\n\t}\n\treturn 4\ndefault:\n\tswitch m {\n\tcase 1:\n\t\treturn 4\n\tcase 2:\n\t\treturn 7\n\tdefault:\n\t\treturn 8\n\t}\n}", "gen": "var a int\nvar b int\nif a == 0 {\n\ta = 1\n} else if a == 1 {\n\ta = 2\n} else if a == 2 {\n\ta = 3\n} else if a == 3 {\n\ta = 4\n}\nif b == 0 {\n\tb = 1\n} else if b == 1 {\n\tb = 2\n} else if b == 2 {\n\tb = 3\n} else if b == 3 {\n\tb = 4\n}\nif a == 1 {\n\ta = 2\n} else if a == 2 {\n\ta = 3\n} else if a == 3 {\n\ta = 4\n} else if a == 4 {\n\ta = 7\n}\nif b == 1 {\n\tb = 2\n} else if b == 2 {\n\tb = 3\n} else if b == 3 {\n\tb = 4\n} else if b == 4 {\n\tb = 7\n}\nif a == 2 {\n\ta = 3\n} else if a == 3 {\n\ta = 4\n} else if a == 4 {\n\ta = 7\n} else if a == 7 {\n\ta = 8\n}\nif b == 2 {\n\tb = 3\n} else if b == 3 {\n\tb = 4\n} else if b == 4 {\n\tb = 7\n} else if b == 7 {\n\tb = 8\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "sort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].End < intervals[j].End\n})\ncount := 0\ncurrent := -int(^uint(0)>>1) - 1\nfor _, interval := range intervals {\n\tif interval.Start >= current {\n\t\tcount++\n\t\tcurrent = interval.End\n\t}\n}\nreturn len(intervals) - count", "gen": "intervals := []Interval{{1, 2}, {2, 3}, {3, 4}, {1, 3}}\nresult := removeIntervals(intervals)\nfmt.Println(result)\n}\n"}
{"tgt": "switch rand.Intn(10) {\ncase 1, 9:\n\treturn io.EOF\ncase 5:\n\treturn errors.New(\"STR\")\ndefault:\n\td.Line = \"STR\"\n\tfmt.Println(\"STR\", d.Line)\n\treturn nil\n}", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\n"}
{"tgt": "fmt.Println(subarrayBitwiseORs([]int{0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))", "gen": "fmt.Println(subarrayBitwiseORs([]int{1, 1, 0}))\nfmt.Println(subarrayBitwiseORs([]int{0, 1}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 1}))\n}\n"}
{"tgt": "dummy := &ListNode{0, head}\nslow, fast := dummy, dummy\nfor fast.Next != nil && fast.Next.Next != nil {\n\tfast = fast.Next.Next\n\tslow = slow.Next\n}\nreturn slow.Next", "gen": "var a *[2]int\nvar b *[2]int\na = new([2]int)\nb = new([2]int)\na[0] = 1\na[1] = 2\nb[0] = 3\nb[1] = 4\nfor a[0] != 0 {\n\ta[0], a[1] = a[1], a[0]\n\tb[0], b[1] = b[1], b[0]\n}\nprintln(b[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "pairs := [...][2]int{{10, 7}, {1000, 983}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p26(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var a, b int\na = 10\nb = 7\nvar c, d int\nc = 1000\nd = 983\nvar e, f int\ne = 2\nfor i := 0; i < 2; i++ {\n\tif i == 1 {\n\t\tbreak\n\t}\n\tvar g, h int\n\tg = 0\n\th = 0\n\tvar i, j int\n\ti = a\n\tj = b\n\tvar k, l int\n\tk = c\n\tl = d\n\tvar m, n int\n\tm = 2\n\tif i == 1 {\n\t\tbreak\n\t}\n\tvar o, p int\n\to = 0\n\tp = 0\n\tvar q, r int\n\tq = 3\n\tr = 3\n\tvar s, t int\n\ts = 3\n\tt = 3\n\tvar u, v int\n\tu = 3\n\tv = 3\n\tvar w, x int\n\tw = 3\n\tx = 3\n\tvar y, z int\n\ty = 3\n\tz = 3\n\tvar aa, ab int\n\taa = 3\n\tab = 3\n\tvar ac, ad int\n\tac = 3\n\tad = 3\n\tvar ae, af int\n\tae = 3\n\taf = 3\n\tvar ag, ah int\n\tag = 3\n\tah = 3\n\tvar ai, aj int\n\tai = 3\n\taj = 3\n\tvar ak, al int\n\tak = 3\n\tal = 3\n\tvar am, an int\n\tam = 3\n\tan = 3\n\tvar ao, ap int\n\tao = 3\n\tap = 3\n\tvar aq"}
{"tgt": "n := len(A)\nfor i := n - 2; i >= 0; i-- {\n\tA[i] += A[i+1]\n}\nmem := [101][33]int{}\nvar dp func(int, int) int\ndp = func(i, m int) int {\n\tif i+2*m >= n {\n\t\treturn A[i]\n\t}\n\tif mem[i][m] > 0 {\n\t\treturn mem[i][m]\n\t}\n\tres := 0\n\tfor x := 1; x <= 2*m; x++ {\n\t\tres = max(\n\t\t\tres,\n\t\t\tA[i]-dp(i+x, max(m, x)),\n\t\t)\n\t}\n\tmem[i][m] = res\n\treturn res\n}\nreturn dp(0, 1)", "gen": "var stones []int\nvar i int\nvar j int\nvar sum int\nvar max int\nvar tmp int\nvar tmp2 int\nvar tmp3 int\nvar tmp4 int\nvar tmp5 int\nvar tmp6 int\nvar tmp7 int\nvar tmp8 int\nvar tmp9 int\nvar tmp10 int\nvar tmp11 int\nvar tmp12 int\nvar tmp13 int\nvar tmp14 int\nvar tmp15 int\nvar tmp16 int\nvar tmp17 int\nvar tmp18 int\nvar tmp19 int\nvar tmp20 int\nvar tmp21 int\nvar tmp22 int\nvar tmp23 int\nvar tmp24 int\nvar tmp25 int\nvar tmp26 int\nvar tmp27 int\nvar tmp28 int\nvar tmp29 int\nvar tmp30 int\nvar tmp31 int\nvar tmp32 int\nvar tmp33 int\nvar tmp34 int\nvar tmp35 int\nvar tmp36 int\nvar tmp37 int\nvar tmp38 int\nvar tmp39 int\nvar tmp40 int\nvar tmp41 int\nvar tmp42 int\nvar tmp43 int\nvar tmp44 int\nvar tmp45 int\nvar tmp46 int\nvar tmp47 int\nvar tmp48 int\nvar tmp49 int\nvar tmp50 int\nvar tmp51 int\nvar tmp52 int\nvar tmp53 int\nvar tmp54 int\nvar tmp55 int\nvar tmp56 int\nvar tmp57 int\nvar tmp58 int\nvar tmp59 int\nvar tmp60 int\nvar tmp61 int\nvar tmp62 int\nvar tmp63 int\nvar tmp64 int\nvar tmp65 int\nvar tmp66 int\nvar tmp67 int\nvar tmp68 int\nvar tmp69 int\n"}
{"tgt": "if n == 0 {\n\treturn 0\n}\nreturn n/5 + trailingZeroes(n/5)", "gen": "fmt.Println(trailingZeroes(10))\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0}, 5},\n\t{\"STR\", []int{0, 0, 0, 0, 1}, []int{1, 0, 0, 0, 0}, 4},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums1, c.nums2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums1, c.nums2)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.nums1 = []int{1, 2, 3, 4}\nsolution.nums2 = []int{2, 3, 4}\nsolution.expect = 3\nsolution.name = \"Test1\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{1, 2}\nsolution.nums2 = []int{1, 2}\nsolution.expect = 3\nsolution.name = \"Test2\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{1, 2}\nsolution.nums2 = []int{3}\nsolution.expect = 0\nsolution.name = \"Test3\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{2, 3, 4}\nsolution.nums2 = []int{1, 2}\nsolution.expect = 3\nsolution.name = \"Test4\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{1, 2, 3, 4}\nsolution.nums2 = []int{1, 2, 3, 4}\nsolution.expect = 3\nsolution.name = \"Test5\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{1, 2, 3, 4}\nsolution.nums2 = []int{1, 2, 3, 4}\nsolution.expect = 3\nsolution.name = \"Test6\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{1, 2, 3, 4}\nsolution.nums2 = []int{1, 2, 3, 4}\nsolution.expect = 3\nsolution.name = \"Test7\"\nsolution.TestSolution()\n\n"}
{"tgt": "list.rear = nil", "gen": "var x *int\n*x = 0\n}\n\n// Test that we can handle a function call with a memory arg.\n// This is a bit tricky because the memory arg is not\n// a pointer, but a value.\n\n<ASM>\nmovq %rdi,-8(%rbp)\nmovq %rsi,-16(%rbp)\nmovq -8(%rbp),%rax\nmovq -16(%rbp),%rdx\nmovq %rdx,(%rax)\nmovq $0,%rax\nleave\nret</ASM>"}
{"tgt": "if len(name) == 0 && len(typed) == 0 {\n\treturn true\n}\nif (len(name) == 0 && len(typed) != 0) || (len(name) != 0 && len(typed) == 0) {\n\treturn false\n}\nj := 0\nfor i := 0; i < len(name); i++ {\n\tif j < len(typed) && name[i] == typed[j] {\n\t\tj++\n\t\tcontinue\n\t} else {\n\t\tif i > 0 && j < len(typed) && name[i-1] == typed[j] {\n\t\t\tj++\n\t\t\ti--\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "var a [2]int\nvar b [2]int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar A int\nvar B int\nvar C int\nvar D int\nvar E int\nvar F int\nvar G int\nvar H int\nvar I int\nvar J int\nvar K int\nvar L int\nvar M int\nvar N int\nvar O int\nvar P int\nvar Q int\nvar R int\nvar S int\nvar T int\nvar U int\nvar V int\nvar W int\nvar X int\nvar Y int\nvar Z int\nvar a1 int\nvar b1 int\nvar c1 int\nvar d1 int\nvar e1 int\nvar f1 int\nvar g1 int\nvar h1 int\nvar i1 int\nvar j1 int\nvar k1 int\nvar l1 int\nvar m1 int\nvar n1 int\nvar o1 int\nvar p1 int\nvar q1 int\nvar r1 int\nvar s1 int\nvar t1 int\nvar u1 int\nvar v1 int\nvar w1 int\nvar x1 int\nvar y1 int\nvar z1 int\nvar A1 int\nvar B1 int\nvar C1 int\nvar D1 int\nvar E1 int\nvar F1 int\nvar G1 int\nvar H1 int\nvar I1 int\nvar J1 int\nvar K1 int\nvar L1 int\nvar M1 int\n"}
{"tgt": "factorial := new(big.Int).MulRange(1, 100)\nbytes := factorial.Append([]byte{}, 10)\nsum := 0\nfor b := range bytes {\n\tsum += int(bytes[b] - '0')\n}\nfmt.Println(\"STR\", sum)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a1 int\nvar b1 int\nvar c1 int\nvar d1 int\nvar e1 int\nvar f1 int\nvar g1 int\nvar h1 int\nvar i1 int\nvar j1 int\nvar k1 int\nvar l1 int\nvar m1 int\nvar n1 int\nvar o1 int\nvar p1 int\nvar q1 int\nvar r1 int\nvar s1 int\nvar t1 int\nvar u1 int\nvar v1 int\nvar w1 int\nvar x1 int\nvar y1 int\nvar z1 int\nvar a2 int\nvar b2 int\nvar c2 int\nvar d2 int\nvar e2 int\nvar f2 int\nvar g2 int\nvar h2 int\nvar i2 int\nvar j2 int\nvar k2 int\nvar l2 int\nvar m2 int\nvar n2 int\nvar o2 int\nvar p2 int\nvar q2 int\nvar r2 int\nvar s2 int\nvar t2 int\nvar u2 int\nvar v2 int\nvar w2 int\nvar x2 int\nvar y2 int\nvar z2 int\nvar a3 int\nvar b3 int\nvar c3 int\nvar d3 int\nvar e3 int\nvar f3 int\nvar g3 int\nvar h3 int\nvar i3 int\nvar j3"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs int\n\texpect int\n}{\n\t{\"STR\", 2, 1},\n\t{\"STR\", 3, 2},\n\t{\"STR\", 4, 3},\n\t{\"STR\", 0, 0},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "sol := Solution{}\nsol.TestSolution()\n}\n"}
{"tgt": "var low, mid, high int = 0, len(sorted) / 2, len(sorted)\nfor low < high {\n\tcurr := sorted[mid]\n\tswitch {\n\tcase curr == target:\n\t\treturn mid\n\tcase inRange(sorted[mid:high], target):\n\t\tlow = mid\n\t\tmid = (low + high) / 2\n\tdefault:\n\t\thigh = mid\n\t\tmid = (low + high) / 2\n\t}\n}\nreturn -1", "gen": "var a []int\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tif i < len(a) {\n\t\tif i >= 0 {\n\t\t\tif i < len(a) {\n\t\t\t\tif i < len(a) {\n\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n"}
{"tgt": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nret := &ListNode{}\nif l1.Val <= l2.Val {\n\tret = l1\n\tret.Next = mergeTwoLists1(l1.Next, l2)\n} else {\n\tret = l2\n\tret.Next = mergeTwoLists1(l1, l2.Next)\n}\nreturn ret", "gen": "a := &ListNode{Val: 1}\nb := &ListNode{Val: 2}\nc := &ListNode{Val: 3}\na.Next = b\nb.Next = c\nd := &ListNode{Val: 4}\ne := &ListNode{Val: 5}\nd.Next = e\nf := &ListNode{Val: 6}\ne.Next = f\ng := &ListNode{Val: 7}\nf.Next = g\nh := &ListNode{Val: 8}\ng.Next = h\ni := &ListNode{Val: 9}\nh.Next = i\nj := &ListNode{Val: 10}\ni.Next = j\nk := &ListNode{Val: 11}\nj.Next = k\nl := &ListNode{Val: 12}\nk.Next = l\nm := &ListNode{Val: 13}\nl.Next = m\nn := &ListNode{Val: 14}\nm.Next = n\no := &ListNode{Val: 15}\nn.Next = o\np := &ListNode{Val: 16}\no.Next = p\nq := &ListNode{Val: 17}\np.Next = q\nr := &ListNode{Val: 18}\nq.Next = r\ns := &ListNode{Val: 19}\nr.Next = s\nt := &ListNode{Val: 20}\ns.Next = t\nu := &ListNode{Val: 21}\nt.Next = u\nv := &ListNode{Val: 22}\nu.Next = v\nw := &ListNode{Val: 23}\nv.Next = w\nx := &ListNode{Val: 24}\nw.Next = x\ny := &ListNode{Val: 25}\nx.Next ="}
{"tgt": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Print(sum, \"STR\")", "gen": "var a int\nfor i := 0; i < 1000; i++ {\n\tif i%3 == 0 {\n\t\ta += i\n\t} else if i%2 == 0 {\n\t\ta += i\n\t}\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "rets := make([][]int, numRows)\nif numRows == 0 {\n\treturn rets\n}\nrets[0] = []int{1}\nfor i := 1; i < numRows; i++ {\n\trets[i] = make([]int, i+1)\n\trets[i][0] = 1\n\trets[i][i] = 1\n\tfor j := 1; j < i; j++ {\n\t\trets[i][j] = rets[i-1][j-1] + rets[i-1][j]\n\t}\n}\nreturn rets", "gen": "var a []int\nvar b []int\nvar c []int\na = make([]int, 10)\nb = make([]int, 10)\nc = make([]int, 10)\nfor i := 0; i < len(a); i++ {\n\ta[i] = 1\n\tb[i] = 1\n\tc[i] = 1\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 1\n\tb[i] = 1\n\tc[i] = 1\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 1\n\tb[i] = 1\n\tc[i] = 1\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 1\n\tb[i] = 1\n\tc[i] = 1\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 1\n\tb[i] = 1\n\tc[i] = 1\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 1\n\tb[i] = 1\n\tc[i] = 1\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 1\n\tb[i] = 1\n\tc[i] = 1\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 1\n\tb[i] = 1\n\tc[i] = 1\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 1\n\tb[i] = 1\n\tc[i]"}
{"tgt": "start := -1\nlenMax := 0\ndict := [256]int{}\nfor i := range dict {\n\tdict[i] = -1\n}\nfor i, r := range s {\n\tif v := dict[r]; v > start {\n\t\tstart = v\n\t}\n\tlength := i - start\n\tif length > lenMax {\n\t\tlenMax = length\n\t}\n\tdict[r] = i\n}\nreturn lenMax", "gen": "var s []byte\nvar i int\nvar j int\nvar k int\nvar n int\nvar m int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int"}
{"tgt": "nlen := len(nums)\nfor i := 0; i < nlen-2; i++ {\n\tif i != 0 && nums[i] == nums[i-1] {\n\t\tcontinue\n\t}\n\tleft, right := i+1, nlen-1\n\tfor left < right {\n\t\tsum := nums[i] + nums[left] + nums[right]\n\t\tif sum == target {\n\t\t\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tleft++\n\t\t\tright--\n\t\t} else if sum < target {\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tleft++\n\t\t} else {\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tright--\n\t\t}\n\t}\n}", "gen": "var a [3]int\nvar b [4]int\nvar c [5]int\nvar d [6]int\nvar e [7]int\nvar f [8]int\nvar g [9]int\nvar h [10]int\nvar i [11]int\nvar j [12]int\nvar k [13]int\nvar l [14]int\nvar m [15]int\nvar n [16]int\nvar o [17]int\nvar p [18]int\nvar q [19]int\nvar r [20]int\nvar s [21]int\nvar t [22]int\nvar u [23]int\nvar v [24]int\nvar w [25]int\nvar x [26]int\nvar y [27]int\nvar z [28]int\nvar aa [29]int\nvar ab [30]int\nvar ac [31]int\nvar ad [32]int\nvar ae [33]int\nvar af [34]int\nvar ag [35]int\nvar ah [36]int\nvar ai [37]int\nvar aj [38]int\nvar ak [39]int\nvar al [40]int\nvar am [41]int\nvar an [42]int\nvar ao [43]int\nvar ap [44]int\nvar aq [45]int\nvar ar [46]int\nvar as [47]int\nvar at [48]int\nvar au [49]int\nvar av [50]int\nvar aw [51]int\nvar ax [52]int\nvar ay [53]int\nvar az [54]int\nvar ba [55]int\nvar bb [56]int\nvar bc [57]int\nvar bd [58]"}
{"tgt": "return strings.ReplaceAll(r.element.Name, \"STR\", \"\")", "gen": "s := \"hello\"\ns = strings.ReplaceAll(s, \"l\", \"L\")\nfmt.Println(s)\n}\n\n// \u6c47\u7f16\u4ee3\u7801\n// 1. \u51fd\u6570\u8c03\u7528\n// 2. \u51fd\u6570\u53c2\u6570\u4f20\u9012\n// 3. \u51fd\u6570\u8fd4\u56de\u503c\n// 4. \u51fd\u6570\u8c03\u7528\u6808\n// 5. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 6. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6536\u7f29\n// 7. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\u548c\u6536\u7f29\n// 8. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\u548c\u6536\u7f29\n// 9. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\u548c\u6536\u7f29\n// 10. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\u548c\u6536\u7f29\n// 11. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\u548c\u6536\u7f29\n// 12. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\u548c\u6536\u7f29\n// 13. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\u548c\u6536\u7f29\n// 14. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\u548c\u6536\u7f29\n// 15. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\u548c\u6536\u7f29\n// 16. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\u548c\u6536\u7f29\n// 17. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\u548c\u6536\u7f29\n// 18. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\u548c\u6536\u7f29\n// 19. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\u548c\u6536\u7f29\n// 20. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\u548c\u6536\u7f29\n// 21. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\u548c\u6536\u7f29\n// 22. \u51fd\u6570\u8c03\u7528\u6808\u7684"}
{"tgt": "var res byte\nfor i := 0; i < len(s); i++ {\n\tres ^= s[i]\n}\nfor i := 0; i < len(t); i++ {\n\tres ^= t[i]\n}\nreturn res", "gen": "var a [10]byte\nvar b [10]byte\nvar c int\nvar d int\nvar e int\nvar f byte\na[0] = 0\nb[0] = 0\nfor c = 0; c < len(a); c++ {\n\tif c == len(b) {\n\t\tbreak\n\t}\n\tif c == len(a) {\n\t\tbreak\n\t}\n\tif c == len(b) {\n\t\tbreak\n\t}\n\tif c == len(a) {\n\t\tbreak\n\t}\n\tif c == len(b) {\n\t\tbreak\n\t}\n\tif c == len(a) {\n\t\tbreak\n\t}\n\tif c == len(b) {\n\t\tbreak\n\t}\n\tif c == len(a) {\n\t\tbreak\n\t}\n\tif c == len(b) {\n\t\tbreak\n\t}\n\tif c == len(a) {\n\t\tbreak\n\t}\n\tif c == len(b) {\n\t\tbreak\n\t}\n\tif c == len(a) {\n\t\tbreak\n\t}\n\tif c == len(b) {\n\t\tbreak\n\t}\n\tif c == len(a) {\n\t\tbreak\n\t}\n\tif c == len(b) {\n\t\tbreak\n\t}\n\tif c == len(a) {\n\t\tbreak\n\t}\n\tif c == len(b) {\n\t\tbreak\n\t}\n\tif c == len(a) {\n\t\tbreak\n\t}\n\tif c == len(b) {\n\t\tbreak\n\t}\n\tif c == len(a) {\n\t\tbreak\n\t}\n\tif c == len(b) {\n\t\tbreak\n\t}\n\tif c == len("}
{"tgt": "m := len(A)\nn := len(A[0])\nans := make([][]int, n)\nfor k := range ans {\n\tans[k] = make([]int, m)\n}\nfor r := 0; r < m; r++ {\n\tfor c := 0; c < n; c++ {\n\t\tans[c][r] = A[r][c]\n\t}\n}\nreturn ans", "gen": "var a [2]int\nvar b [3]int\nvar c [4]int\nvar d [5]int\nvar e [6]int\nvar f [7]int\nvar g [8]int\nvar h [9]int\nvar i [10]int\nvar j [11]int\nvar k [12]int\nvar l [13]int\nvar m [14]int\nvar n [15]int\nvar o [16]int\nvar p [17]int\nvar q [18]int\nvar r [19]int\nvar s [20]int\nvar t [21]int\nvar u [22]int\nvar v [23]int\nvar w [24]int\nvar x [25]int\nvar y [26]int\nvar z [27]int\nvar aa [28]int\nvar bb [29]int\nvar cc [30]int\nvar dd [31]int\nvar ee [32]int\nvar ff [33]int\nvar gg [34]int\nvar hh [35]int\nvar ii [36]int\nvar jj [37]int\nvar kk [38]int\nvar ll [39]int\nvar mm [40]int\nvar nn [41]int\nvar oo [42]int\nvar pp [43]int\nvar qq [44]int\nvar rr [45]int\nvar ss [46]int\nvar tt [47]int\nvar uu [48]int\nvar vv [49]int\nvar ww [50]int\nvar xx [51]int\nvar yy [52]int\nvar zz [53]int\nvar aaa [54]int\nvar bbb [55]int\nvar ccc [5"}
{"tgt": "println(\"STR\", len(a))", "gen": "var a [2]int\nfmt.Println(\"a=\", a)\n}\n\n// Output:\n// a=[0 0]\n"}
{"tgt": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nc, res := []int{}, [][]int{}\nsort.Ints(candidates)\nfindcombinationSum(candidates, target, 0, c, &res)\nreturn res", "gen": "nums := []int{2, 3, 6, 7}\ntarget := 7\ncombinationSum(nums, target)\n}\n"}
{"tgt": "for i := 0; i < len(A)-1; i++ {\n\tif A[i] == i {\n\t\tcontinue\n\t}\n\tif A[i] == i+1 && A[i+1] == i {\n\t\ti++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif i == len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tif i > len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tif i < len(a) {\n\t\tif i == len(a) {\n\t\t\tpanic(\"index out of range\")\n\t\t}\n\t\tif i > len(a) {\n\t\t\tpanic(\"index out of range\")\n\t\t}\n\t\tif i < len(a) {\n\t\t\tif i == len(a) {\n\t\t\t\tpanic(\"index out of range\")\n\t\t\t}\n\t\t\tif i > len(a) {\n\t\t\t\tpanic(\"index out of range\")\n\t\t\t}\n\t\t\tif i < len(a) {\n\t\t\t\tif i == len(a) {\n\t\t\t\t\tpanic(\"index out of range\")\n\t\t\t\t}\n\t\t\t\tif i > len(a) {\n\t\t\t\t\tpanic(\"index out of range\")\n\t\t\t\t}\n\t\t\t\tif i < len(a) {\n\t\t\t\t\tif i == len(a) {\n\t\t\t\t\t\tpanic(\"index out of range\")\n\t\t\t\t\t}\n\t\t\t\t\tif i > len(a) {\n\t\t\t\t\t\tpanic(\"index out of range\")\n\t\t\t\t\t}\n\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\tif i == len(a) {\n\t\t\t\t\t\t\tpanic(\"index out of range\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif i > len(a) {\n\t\t\t\t\t\t\tpanic(\"index out of range\")"}
{"tgt": "for n := 0; n < 32; n++ {\n\tsquare[n] = gf2MatrixTimes(mat, mat[n])\n}", "gen": "var a [32]uint32\nvar b [32]uint32\nvar c uint32\nfor i := 0; i < 32; i++ {\n\ta[i] = gf2MatrixTimes(b, c)\n}\n}\n"}
{"tgt": "for i := 0; i < n; i++ {\n\tif len(squares) != i {\n\t\tprintln(\"STR\", len(squares), \"STR\", i)\n\t}\n\tsquares[i] = i * i\n\tfor j := 0; j <= i; j++ {\n\t\tif v, ok := squares[j]; !ok || v != j*j {\n\t\t\tif !ok {\n\t\t\t\tprintln(\"STR\", j)\n\t\t\t} else {\n\t\t\t\tprintln(\"STR\", j, v)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "var m map[int][2]int\nfor i := 0; i < 10; i++ {\n\tif _, ok := m[i]; !ok {\n\t\tm[i] = [2]int{i, i}\n\t}\n}\n}\n\n// func main() {\n// \tvar m map[int][2]int\n// \tfor i := 0; i < 10; i++ {\n// \t\tif _, ok := m[i]; !ok {\n// \t\t\tm[i] = [2]int{i, i}\n// \t\t}\n// \t}\n// }\n\n// func main() {\n// \tvar m map[int][2]int\n// \tfor i := 0; i < 10; i++ {\n// \t\tif _, ok := m[i]; !ok {\n// \t\t\tm[i] = [2]int{i, i}\n// \t\t}\n// \t}\n// }\n\n// func main() {\n// \tvar m map[int][2]int\n// \tfor i := 0; i < 10; i++ {\n// \t\tif _, ok := m[i]; !ok {\n// \t\t\tm[i] = [2]int{i, i}\n// \t\t}\n// \t}\n// }\n\n// func main() {\n// \tvar m map[int][2]int\n// \tfor i := 0; i < 10; i++ {\n// \t\tif _, ok := m[i]; !ok {\n// \t\t\tm[i] = [2]int{i, i}\n// \t\t}\n// \t}\n// }\n\n// func main() {\n// \tvar m map[int][2]int\n// \tfor i := 0; i < 10; i++ {\n// \t\tif _, ok := m[i]; !ok {\n// \t\t\tm[i] = [2]int{i, i}\n"}
{"tgt": "for j := 1; j <= 20; j++ {\n\tif num%j != 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a int\nfor i := 0; i < 20; i++ {\n\tif i == 0 {\n\t\ta = 1 / i\n\t}\n\tif a == 0 {\n\t\tpanic(\"divide by zero\")\n\t}\n\tif i == 20 {\n\t\tbreak\n\t}\n\ta = a + 1\n}\nif a == 0 {\n\treturn\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(sorted) == 0 {\n\treturn nil\n}\nmid := len(sorted) / 2\nroot := &BST{Value: sorted[mid]}\nroot.Left = SortedSliceToBST(sorted[:mid])\nroot.Right = SortedSliceToBST(sorted[mid+1:])\nreturn root", "gen": "var a []int\nvar b *BST\nif len(a) == 0 {\n\tb = nil\n} else {\n\tb = &BST{}\n\tb.Val = a[0]\n\tif len(a) > 1 {\n\t\tb.Left = SortedSliceToBST(a[1:len(a)])\n\t\tb.Right = SortedSliceToBST(a[len(a)-1:])\n\t}\n}\nreturn b\n}\n"}
{"tgt": "return x * y", "gen": "var a float32 = 1.0\nvar b float32 = 2.0\nvar c float32 = 3.0\nvar d float32 = 4.0\nvar e float32 = 5.0\nvar f float32 = 6.0\nvar g float32 = 7.0\nvar h float32 = 8.0\nvar i float32 = 9.0\nvar j float32 = 10.0\nvar k float32 = 11.0\nvar l float32 = 12.0\nvar m float32 = 13.0\nvar n float32 = 14.0\nvar o float32 = 15.0\nvar p float32 = 16.0\nvar q float32 = 17.0\nvar r float32 = 18.0\nvar s float32 = 19.0\nvar t float32 = 20.0\nvar u float32 = 21.0\nvar v float32 = 22.0\nvar w float32 = 23.0\nvar x float32 = 24.0\nvar y float32 = 25.0\nvar z float32 = 26.0\nvar a1 float32 = 27.0\nvar b1 float32 = 28.0\nvar c1 float32 = 29.0\nvar d1 float32 = 30.0\nvar e1 float32 = 31.0\nvar f1 float32 = 32.0\nvar g1 float32 = 33.0\nvar h1 float32 = 34.0\nvar i1 float32 = 35.0\nvar j1 float32 = 36.0\nvar k1 float32 = 37.0\nvar l1 float32 = 38.0\nvar m"}
{"tgt": "i1 := 0\ni2 := 0\nval1 := 0\nval2 := 0\nfor i1 < len(version1) || i2 < len(version2) {\n\tval1, i1 = parseSeg(version1, i1)\n\tval2, i2 = parseSeg(version2, i2)\n\tif val1 > val2 {\n\t\treturn 1\n\t}\n\tif val1 < val2 {\n\t\treturn -1\n\t}\n}\nif i1 < len(version1) {\n\treturn 1\n}\nif i2 < len(version2) {\n\treturn -1\n}\nreturn 0", "gen": "a := 1\nb := 2\nc := 3\nd := 4\ne := 5\nf := 6\ng := 7\nh := 8\ni := 9\nj := 10\nk := 11\nl := 12\nm := 13\nn := 14\no := 15\np := 16\nq := 17\nr := 18\ns := 19\nt := 20\nu := 21\nv := 22\nw := 23\nx := 24\ny := 25\nz := 26\na1 := 27\nb1 := 28\nc1 := 29\nd1 := 30\ne1 := 31\nf1 := 32\ng1 := 33\nh1 := 34\ni1 := 35\nj1 := 36\nk1 := 37\nl1 := 38\nm1 := 39\nn1 := 40\no1 := 41\np1 := 42\nq1 := 43\nr1 := 44\ns1 := 45\nt1 := 46\nu1 := 47\nv1 := 48\nw1 := 49\nx1 := 50\ny1 := 51\nz1 := 52\na2 := 53\nb2 := 54\nc2 := 55\nd2 := 56\ne2 := 57\nf2 := 58\ng2 := 59\nh2 := 60\ni2 := 61\nj2 := 62\nk2 := 63\nl2 := 64\nm2 := 65\nn2 := 66\no2 := 67"}
{"tgt": "return this.Val", "gen": "var a [4]int\nvar b int\nb = a[0]\n}\n\n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// 0000000000000000 <main>:\n// \t.globl main\n// \t.type main,@function\n// main:                                  # @main\n// \t.cfi_startproc\n// \t.cfi_personality 155, ___gxx_personality_v0\n// \t.cfi_lsda 16, .LASF\n// \tpushq %rbp\n// \tmovq %rsp, %rbp\n// \tsubq $48, %rsp\n// \tmovq %rdi, -40(%rbp)\n// \tmovq -40(%rbp), %rax\n// \tmovq (%rax), %rcx\n// \tmovq <8>(%rax), %rbx\n// \tmovq %rcx, -32(%rbp)\n// \tmovq %rbx, -24(%rbp)\n// \tmovq <16>(%rax), %rcx\n// \tmovq <24>(%rax), %rbx\n// \tmovq %rcx, -16(%rbp)\n// \tmovq %rbx, -8(%rbp)\n// \tmovq $0, -8(%rbp)\n// \tmovq -8(%rbp), %rax\n// \tleave\n// \tret\n// \t.cfi_endproc\n// \t.size main, .-main\n// \t.section .rodata\n// \t.type .LASF,@object\n// \t.section .text.unlikely\n// .LASF:\n// \t.byte 1\n// \t.size .LASF, 1\n// \t.section .text.startup,\"ax\",@prog"}
{"tgt": "str := \"STR\"\nfmt.Println(longestPalindrome(str))", "gen": "fmt.Println(longestPalindrome(\"abccba\"))\n}\n"}
{"tgt": "dat, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\nnamesList := string(dat)\nnamesList = strings.Replace(namesList, \"STR\", \"STR\", -1)\nnames := strings.Split(namesList, \"STR\")\nsort.Strings(names)\nnamesScore := 0\nfor index, name := range names {\n\tnamesScore += nameScore(name) * (index + 1)\n}\nfmt.Println(namesScore)", "gen": "var nameScore int\nvar names []string\nvar err error\nnames, err = ioutil.ReadFile(\"names.txt\")\nif err != nil {\n\tpanic(err)\n}\nnameScore = 0\nfor _, name := range strings.Split(strings.Replace(names, \"\\n\", \"\", -1), \",\") {\n\tnameScore += nameScore(name)\n}\nfmt.Println(nameScore)\n}"}
{"tgt": "res := 0\nsort.Ints(houses)\nsort.Ints(heaters)\nm, n := len(houses), len(heaters)\nindex := sort.SearchInts(heaters, houses[0])\nfor _, house := range houses {\n\tfor index < n && house > heaters[index] {\n\t\tindex++\n\t}\n\tif index == n {\n\t\treturn max(res, houses[m-1]-heaters[index-1])\n\t}\n\tleft := math.MaxInt32\n\tif index > 0 {\n\t\tleft = house - heaters[index-1]\n\t}\n\tright := heaters[index] - house\n\tres = max(res, min(left, right))\n}\nreturn res", "gen": "a := []int{1, 2, 3, 1}\nb := []int{1, 2, 3, 4}\nc := []int{1, 2, 3, 4}\nd := []int{1, 2, 3, 4}\nfmt.Println(maxProfit(a))\nfmt.Println(maxProfit(b))\nfmt.Println(maxProfit(c))\nfmt.Println(maxProfit(d))\n}\n"}
{"tgt": "l, r := &maxHeap{}, &minHeap{}\nheap.Init(l)\nheap.Init(r)\nreturn MedianFinder{l, r}", "gen": "maxHeap := &maxHeap{}\nminHeap := &minHeap{}\ncontainer.Init(maxHeap, minHeap)\n}\n"}
{"tgt": "l := len(preorder)\nif l == 0 {\n\treturn nil\n}\nfor 1 < l && preorder[0] < preorder[l-1] {\n\tl--\n}\nreturn &TreeNode{\n\tVal:   preorder[0],\n\tLeft:  bstFromPreorder(preorder[1:l]),\n\tRight: bstFromPreorder(preorder[l:]),\n}", "gen": "preorder := []int{8, 5, 1, 7, 10, 12}\nroot := bstFromPreorder(preorder)\nfmt.Println(root)\n}\n"}
{"tgt": "ln, err := net.Listen(\"STR\", \"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"STR\", conn.RemoteAddr())\n\tio.WriteString(conn, fmt.Sprint(time.Now()))\n\tconn.Close()\n}", "gen": "var l net.Listener\nl, err := net.Listen(\"tcp\", \":8080\")\nif err != nil {\n\tpanic(err)\n}\ndefer l.Close()\nfor {\n\tconn, err := l.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tgo func() {\n\t\tdefer conn.Close()\n\t\tio.WriteString(conn, time.Now().Format(time.RFC3339))\n\t}()\n}\n}\n"}
{"tgt": "i, l := 0, len(bits)-1\nfor i < l {\n\ti += bits[i] + 1\n}\nreturn i == l", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i\n}\nif i == len(a) {\n\tpanic(\"index out of range\")\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"defangIPaddr\")\nfmt.Printf(\"%d\\n\", defangIPaddr(\"1.1.1.1\"))\nfmt.Printf(\"%d\\n\", defangIPaddr(\"255.100.50.0\"))\nfmt.Printf(\"%d\\n\", defangIPaddr(\"0.0.0.0\"))\nfmt.Printf(\"%d\\n\", defangIPaddr(\"10.0.0.255\"))\nfmt.Printf(\"%d\\n\", defangIPaddr(\"172.16.10.1\"))\nfmt.Printf(\"%d\\n\", defangIPaddr(\"192.168.0.1\"))\nfmt.Printf(\"%d\\n\", defangIPaddr(\"192.168.0.255\"))\nfmt.Printf(\"%d\\n\", defangIPaddr(\"192.168.255.255\"))\nfmt.Printf(\"%d\\n\", defangIPaddr(\"192.168.255.254\"))\nfmt.Printf(\"%d\\n\", defangIPaddr(\"192.168.255.253\"))\nfmt.Printf(\"%d\\n\", defangIPaddr(\"192.168.255.252\"))\nfmt.Printf(\"%d\\n\", defangIPaddr(\"192.168.255.251\"))\nfmt.Printf(\"%d\\n\", defangIPaddr(\"192.168.255.250\"))\nfmt.Printf(\"%d\\n\", defangIPaddr(\"192.168.255.249\"))\nfmt.Printf(\"%d\\n\", defangIPaddr(\"192.168.255.248\"))\nfmt.Printf(\"%d\\n\", defangIPaddr(\"192.168.255.247\"))\nfmt.Printf(\"%d\\n\","}
{"tgt": "start := 0\nend := len(s) - 1\nfor start < end {\n\ts[start], s[end] = s[end], s[start]\n\tstart++\n\tend--\n}\nreturn s", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nfor i := 0; i < len(a); i++ {\n\ta[i] = i\n\tb[i] = i\n\tc[i] = i\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = i\n\tb[i] = i\n\tc[i] = i\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for cur := t.root; cur != nil; {\n\tif cur.Key == key {\n\t\treturn cur\n\t} else if key < cur.Key {\n\t\tcur = cur.left\n\t} else {\n\t\tcur = cur.right\n\t}\n}\nreturn nil", "gen": "var root *binaryTree.BSTElement\nvar element *binaryTree.BSTElement\nvar found *binaryTree.BSTElement\nroot = binaryTree.NewBSTElement(10)\nroot.Left = binaryTree.NewBSTElement(5)\nroot.Right = binaryTree.NewBSTElement(15)\nroot.Left.Left = binaryTree.NewBSTElement(2)\nroot.Left.Right = binaryTree.NewBSTElement(6)\nroot.Right.Left = binaryTree.NewBSTElement(12)\nroot.Right.Right = binaryTree.NewBSTElement(16)\nelement = binaryTree.NewBSTElement(10)\nfound = binaryTree.Find(root, element)\nif found == nil {\n\tfmt.Println(\"Element not found\")\n} else {\n\tfmt.Println(\"Element found\")\n}\nelement = binaryTree.NewBSTElement(11)\nfound = binaryTree.Find(root, element)\nif found == nil {\n\tfmt.Println(\"Element not found\")\n} else {\n\tfmt.Println(\"Element found\")\n}\nelement = binaryTree.NewBSTElement(12)\nfound = binaryTree.Find(root, element)\nif found == nil {\n\tfmt.Println(\"Element not found\")\n} else {\n\tfmt.Println(\"Element found\")\n}\nelement = binaryTree.NewBSTElement(13)\nfound = binaryTree.Find(root, element)\nif found == nil {\n\tfmt.Println(\"Element not found\")\n} else {\n\tfmt.Println(\"Element found\")\n}\nelement = binaryTree.NewBSTElement(14)\nfound = binaryTree.Find(root, element)\nif found == nil {\n\tfmt.Println(\"Element not found\")\n} else {\n\tfmt.Println(\"Element found\")\n}\nelement = binaryTree.NewBSTElement(15)\n"}
{"tgt": "arr := randomSlice(0, 20, 10)\nnodeCnt := 0\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\nrotateNodes := make([]*gbtElement, 0, 0)\ngbt.InOrderWalk(gbt.Root(), func(GBTbinaryTreeIf, node interface{}) bool {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\trotateNodes = append(rotateNodes, node.(*gbtElement))\n\t}\n\treturn false\n})\nfor _, v := range rotateNodes {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\tgbt.LeftRotate(v)\n\t} else {\n\t\tgbt.RightRotate(v)\n\t}\n}\ngbt.InOrderWalk(gbt.Root(), checkGBT(t, &nodeCnt, *debug))\nif nodeCnt != len(arr) {\n\tt.Log(fmt.Sprintf(\"STR\", len(arr), nodeCnt))\n\tt.Fail()\n}", "gen": "gbt := NewGBT()\nfor i := 0; i < 10; i++ {\n\tgbt.Insert(i)\n}\nfor i := 0; i < 10; i++ {\n\tgbt.Delete(i)\n}\nif gbt.Len() != 0 {\n\tt.Fail()\n}\nif gbt.Get(0) != nil {\n\tt.Fail()\n}\nif gbt.Get(1) != nil {\n\tt.Fail()\n}\nif gbt.Get(2) != nil {\n\tt.Fail()\n}\nif gbt.Get(3) != nil {\n\tt.Fail()\n}\nif gbt.Get(4) != nil {\n\tt.Fail()\n}\nif gbt.Get(5) != nil {\n\tt.Fail()\n}\nif gbt.Get(6) != nil {\n\tt.Fail()\n}\nif gbt.Get(7) != nil {\n\tt.Fail()\n}\nif gbt.Get(8) != nil {\n\tt.Fail()\n}\nif gbt.Get(9) != nil {\n\tt.Fail()\n}\nif gbt.Get(10) != nil {\n\tt.Fail()\n}\nif gbt.Get(11) != nil {\n\tt.Fail()\n}\nif gbt.Get(12) != nil {\n\tt.Fail()\n}\nif gbt.Get(13) != nil {\n\tt.Fail()\n}\nif gbt.Get(14) != nil {\n\tt.Fail()\n}\nif gbt.Get(15) != nil {\n\tt.Fail()\n}\nif gbt.Get(16) != nil {\n\tt.Fail()\n}\nif gbt.Get(17) !="}
{"tgt": "return WordDictionary{}", "gen": "var a [27]int\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 4\na[4] = 5\na[5] = 6\na[6] = 7\na[7] = 8\na[8] = 9\na[9] = 10\na[10] = 11\na[11] = 12\na[12] = 13\na[13] = 14\na[14] = 15\na[15] = 16\na[16] = 17\na[17] = 18\na[18] = 19\na[19] = 20\na[20] = 21\na[21] = 22\na[22] = 23\na[23] = 24\na[24] = 25\na[25] = 26\na[26] = 27\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return xtime.Unix(int64(jt), 0)", "gen": "var t time.Time\nvar t2 time.Time\nvar t3 time.Time\nt = time.Now()\nt2 = time.Unix(0, 0)\nt3 = time.Unix(0, 0)\n*t = t2\n*t = t3\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return append(ints, added...)", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb := a[1]\nc := a[2]\nd := a[0]\na[1] = c\na[2] = b\na[0] = d\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "data, err := base64.StdEncoding.DecodeString(b64)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(data)", "gen": "s := \"1234567890\"\nb, err := base64.StdEncoding.DecodeString(s)\nif err != nil {\n\tpanic(err)\n}\nfmt.Println(hex.EncodeToString(b))\n}\n\n// \u7f16\u8bd1\u5668\u4f18\u5316"}
{"tgt": "h := fnv.New64a()\n_, _ = h.Write([]byte(fmt.Sprintf(\"STR\", key)))\nhashValue := h.Sum64()\nreturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))", "gen": "var a, b int\nfmt.Scanf(\"%d %d\", &a, &b)\nif a > b {\n\ta, b = b, a\n}\nif a == 0 {\n\tfmt.Println(b)\n\treturn\n}\nif a == 1 {\n\tfmt.Println(b + 1)\n\treturn\n}\nif a == 2 {\n\tfmt.Println(b + 2)\n\treturn\n}\nif a == 3 {\n\tfmt.Println(b + 3)\n\treturn\n}\nif a == 4 {\n\tfmt.Println(b + 4)\n\treturn\n}\nif a == 5 {\n\tfmt.Println(b + 5)\n\treturn\n}\nif a == 6 {\n\tfmt.Println(b + 6)\n\treturn\n}\nif a == 7 {\n\tfmt.Println(b + 7)\n\treturn\n}\nif a == 8 {\n\tfmt.Println(b + 8)\n\treturn\n}\nif a == 9 {\n\tfmt.Println(b + 9)\n\treturn\n}\nif a == 10 {\n\tfmt.Println(b + 10)\n\treturn\n}\nif a == 11 {\n\tfmt.Println(b + 11)\n\treturn\n}\nif a == 12 {\n\tfmt.Println(b + 12)\n\treturn\n}\nif a == 13 {\n\tfmt.Println(b + 13)\n\treturn\n}\nif a == 14 {\n\tfmt.Println(b + 14)\n\treturn\n}\nif a == 15 {\n\tfmt.Println(b + 15)\n\treturn\n}"}
{"tgt": "return fmt.Sprintf(\"STR\", p.Name, p.Age)", "gen": "var s string\nvar i int\nvar j int\nvar k int\nvar s1 string\nvar i1 int\nvar j1 int\nvar k1 int\nvar s2 string\nvar i2 int\nvar j2 int\nvar k2 int\nvar s3 string\nvar i3 int\nvar j3 int\nvar k3 int\nvar s4 string\nvar i4 int\nvar j4 int\nvar k4 int\nvar s5 string\nvar i5 int\nvar j5 int\nvar k5 int\nvar s6 string\nvar i6 int\nvar j6 int\nvar k6 int\nvar s7 string\nvar i7 int\nvar j7 int\nvar k7 int\nvar s8 string\nvar i8 int\nvar j8 int\nvar k8 int\nvar s9 string\nvar i9 int\nvar j9 int\nvar k9 int\nvar s10 string\nvar i10 int\nvar j10 int\nvar k10 int\nvar s11 string\nvar i11 int\nvar j11 int\nvar k11 int\nvar s12 string\nvar i12 int\nvar j12 int\nvar k12 int\nvar s13 string\nvar i13 int\nvar j13 int\nvar k13 int\nvar s14 string\nvar i14 int\nvar j14 int\nvar k14 int\nvar s15 string\nvar i15 int\nvar j15 int\nvar k15 int\nvar s16 string\nvar i16 int\nvar j16 int\nvar k16 int\nvar s17 string\nvar i17 int\nvar j17 int\nvar k17 int\nvar s18 string\nvar i18 int\nvar j18 int\nvar k18 int\nvar s19 string\nvar i19"}
{"tgt": "parent := this\nfor _, ch := range prefix {\n\tif child, ok := parent.Children[ch]; ok {\n\t\tparent = child\n\t\tcontinue\n\t}\n\treturn false\n}\nreturn true", "gen": "var s Solution\nvar nums = []int{1, 2, 3}\nvar result = s.FindMaximumXOR(nums)\nfmt.Println(result)\n}\n"}
{"tgt": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)", "gen": "var a int\nvar b int\nfor {\n\tif isL(a) {\n\t\ta++\n\t} else {\n\t\tb++\n\t}\n\tif b > 9999 {\n\t\tbreak\n\t}\n}\nfmt.Println(a, b)\n}"}
{"tgt": "close(p.work)\np.wg.Wait()", "gen": "var wg sync.WaitGroup\nch := make(chan int)\nwg.Add(1)\ngo func() {\n\tdefer wg.Done()\n\t<-ch\n}()\nwg.Wait()\n}\n\n// func main() {\n// \tvar wg sync.WaitGroup\n// \tch := make(chan int)\n// \twg.Add(1)\n// \tgo func() {\n// \t\tdefer wg.Done()\n// \t\t<-ch\n// \t}()\n// \twg.Wait()\n// }\n// func main() {\n// \tvar wg sync.WaitGroup\n// \tch := make(chan int)\n// \twg.Add(1)\n// \tgo func() {\n// \t\tdefer wg.Done()\n// \t\t<-ch\n// \t}()\n// \twg.Wait()\n// }\n// func main() {\n// \tvar wg sync.WaitGroup\n// \tch := make(chan int)\n// \twg.Add(1)\n// \tgo func() {\n// \t\tdefer wg.Done()\n// \t\t<-ch\n// \t}()\n// \twg.Wait()\n// }\n// func main() {\n// \tvar wg sync.WaitGroup\n// \tch := make(chan int)\n// \twg.Add(1)\n// \tgo func() {\n// \t\tdefer wg.Done()\n// \t\t<-ch\n// \t}()\n// \twg.Wait()\n// }\n// func main() {\n// \tvar wg sync.WaitGroup\n// \tch := make(chan int)\n// \twg.Add(1)\n// \tgo func() {\n// \t\tdefer wg.Done()\n// \t\t<-ch\n// \t}()\n// \twg.Wait()\n// }\n// func main() {\n// \tvar wg sync.WaitGroup\n//"}
{"tgt": "m := make(map[int]struct{})\nfor _, num := range nums1 {\n\tm[num] = struct{}{}\n}\nnums := make([]int, 0)\nfor _, num := range nums2 {\n\tif _, ok := m[num]; ok {\n\t\tnums = append(nums, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn nums", "gen": "m := make(map[int]struct{})\nfor i := 0; i < 1000000; i++ {\n\tm[i] = struct{}{}\n}\ns := make([]int, 0, len(m))\nfor k := range m {\n\ts = append(s, k)\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return h.FromHexString(string(b))", "gen": "var hash go.metainfo.Hash\nhash.FromHexString(\"1234567890123456789012345678901234567890\")\nfmt.Println(hash)\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif denoms := EgyptianFractions(tc.numerator, tc.denominator); !reflect.DeepEqual(tc.denominators, denoms) {\n\t\tt.Errorf(\"STR\", tc.denominators, denoms)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "log.SetFlags(0)\nvar err error\ntpl := template.New(\"STR\")\ntpl = tpl.Funcs(template.FuncMap{\n\t\"STR\": func(str string) string {\n\t\treturn strings.ToUpper(str)\n\t},\n})\ntpl, err = tpl.ParseFiles(\"STR\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nerr = tpl.ExecuteTemplate(os.Stdout, \"STR\", Page{\n\tTitle: \"STR\",\n\tBody:  \"STR\",\n})\nif err != nil {\n\tlog.Fatalln(err)\n}", "gen": "log.SetFlags(0)\nt := template.New(\"\")\nt = t.Funcs(template.FuncMap{\n\t\"f\": func(s string) string {\n\t\treturn s\n\t},\n})\nt, err := t.ParseFiles(\"type.go\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nvar p Page\nt = t.Parse(string(p))\nvar buf bytes.Buffer\nerr = t.ExecuteTemplate(&buf, \"type\", p)\nif err != nil {\n\tlog.Fatalln(err)\n}\nfmt.Println(buf.String())\n}\n"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA `structs:\"STR\"`\n\tC  int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif ok {\n\tt.Error(\"STR\")\n}", "gen": "var a TestHasZero_OmitNested\na.B.i1.d = 123\nif !reflect.DeepEqual(a, TestHasZero_OmitNested{}) {\n\tt.Error(\"a should be zero\")\n}\n}\n\n// TestHasZero_OmitNested_B_i1_d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d"}
{"tgt": "digits := convert(N + 1)\nbits := len(digits)\nnoRepeat := 0\nfor b := 1; b < bits; b++ {\n\tnoRepeat += 9 * count(9, b-1)\n}\nhasSeen := make(map[int]bool, 10)\nfor b := 0; b < bits; b++ {\n\td := 0\n\tif b == 0 {\n\t\td = 1\n\t}\n\tfor ; d < digits[b]; d++ {\n\t\tif !hasSeen[d] {\n\t\t\tnoRepeat += count(9-b, bits-b-1)\n\t\t}\n\t}\n\tif hasSeen[digits[b]] {\n\t\tbreak\n\t}\n\thasSeen[digits[b]] = true\n}\nreturn N - noRepeat", "gen": "var n int\nfmt.Scan(&n)\nvar a []int\nfor i := 0; i < n; i++ {\n\tvar tmp int\n\tfmt.Scan(&tmp)\n\ta = append(a, tmp)\n}\nvar ans int\nfor i := 0; i < n; i++ {\n\tans += count(a[i], 9)\n}\nfmt.Println(ans)\n}\n"}
{"tgt": "return me[0] == \"STR\"", "gen": "var s []int\nif len(s) != 0 {\n\tpanic(s)\n}\nif s[0] != 0 {\n\tpanic(\"\")\n}\nif len(s) > 1 {\n\tpanic(s)\n}\nif s[1] != 0 {\n\tpanic(\"\")\n}\n}\n\n// func main() {\n// \tvar s []int\n// \tif len(s) != 0 {\n// \t\tpanic(s)\n// \t}\n// \tif s[0] != 0 {\n// \t\tpanic(\"\")\n// \t}\n// \tif len(s) > 1 {\n// \t\tpanic(s)\n// \t}\n// \tif s[1] != 0 {\n// \t\tpanic(\"\")\n// \t}\n// }\n\n// func main() {\n// \tvar s []int\n// \tif len(s) != 0 {\n// \t\tpanic(s)\n// \t}\n// \tif s[0] != 0 {\n// \t\tpanic(\"\")\n// \t}\n// \tif len(s) > 1 {\n// \t\tpanic(s)\n// \t}\n// \tif s[1] != 0 {\n// \t\tpanic(\"\")\n// \t}\n// }\n\n// func main() {\n// \tvar s []int\n// \tif len(s) != 0 {\n// \t\tpanic(s)\n// \t}\n// \tif s[0] != 0 {\n// \t\tpanic(\"\")\n// \t}\n// \tif len(s) > 1 {\n// \t\tpanic(s)\n// \t}\n// \tif s[1] != 0 {\n// \t\tpanic(\"\")\n// \t}\n// }\n\n// func main() {\n// \tvar s []int\n// \tif len(s"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil {\n\t\t\tmax = max.Right\n\t\t}\n\t\tmax.Right = root\n\t\troot, root.Left = root.Left, nil\n\t}\n}\nreturn res", "gen": "var a []int\nfor i := 0; i < 1000000; i++ {\n\ta = append(a, i)\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   0x5555,\n\t\twant: 8,\n\t},\n}\nfor _, tt := range tests {\n\tgot := hammingWeight(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var a uint32 = 2\nvar b uint32 = 3\nvar c uint32 = 7\nvar d uint32 = 8\nvar e uint32 = 1\nvar f uint32 = 21845\nvar g uint32 = 8\nvar h uint32 = 2\nvar i uint32 = 21845\nvar j uint32 = 8\nvar k uint32 = 1\nvar l uint32 = 2\nvar m uint32 = 3\nvar n uint32 = 2\nvar o uint32 = 3\nvar p uint32 = 8\nvar q uint32 = 2\nvar r uint32 = 21845\nvar s uint32 = 8\nvar t uint32 = 2\nvar u uint32 = 21845\nvar v uint32 = 8\nvar w uint32 = 1\nvar x uint32 = 2\nvar y uint32 = 3\nvar z uint32 = 4\nvar a1 uint32\nvar b1 uint32\nvar c1 uint32\nvar d1 uint32\nvar e1 uint32\nvar f1 uint32\nvar g1 uint32\nvar h1 uint32\nvar i1 uint32\nvar j1 uint32\nvar k1 uint32\nvar l1 uint32\nvar m1 uint32\nvar n1 uint32\nvar o1 uint32\nvar p1 uint32\nvar q1 uint32\nvar r1 uint32\nvar s1 uint32\nvar t1 uint32\nvar u1 uint32\nvar v1 uint32\nvar w1 uint32\nvar x1 uint32\nvar y1 uint32\nvar z1 uint32\nfor i := 0; i < 4; i++ {\n"}
{"tgt": "if a == nil && b == nil {\n\treturn true\n}\nif len(a) != len(b) {\n\treturn false\n}\nfor i := range a {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nvar b [10]int\nvar c int\nfor i := 0; i < len(a); i++ {\n\tif a[i] == b[i] {\n\t\tc = 1\n\t} else {\n\t\tc = 0\n\t}\n}\nif c == 1 {\n\tfmt.Println(\"equal\")\n} else {\n\tfmt.Println(\"not equal\")\n}\n}\n"}
{"tgt": "return xtime.Unix(int64(jt), 0), nil", "gen": "var t time.Time\nt = time.Unix(0, 0)\nvar t2 time.Time\nt2 = time.Time{}\nvar t3 time.Time\nt3 = time.Time{}\nvar t4 time.Time\nt4 = time.Time{}\nvar t5 time.Time\nt5 = time.Time{}\nvar t6 time.Time\nt6 = time.Time{}\nvar t7 time.Time\nt7 = time.Time{}\nvar t8 time.Time\nt8 = time.Time{}\nvar t9 time.Time\nt9 = time.Time{}\nvar t10 time.Time\nt10 = time.Time{}\nvar t11 time.Time\nt11 = time.Time{}\nvar t12 time.Time\nt12 = time.Time{}\nvar t13 time.Time\nt13 = time.Time{}\nvar t14 time.Time\nt14 = time.Time{}\nvar t15 time.Time\nt15 = time.Time{}\nvar t16 time.Time\nt16 = time.Time{}\nvar t17 time.Time\nt17 = time.Time{}\nvar t18 time.Time\nt18 = time.Time{}\nvar t19 time.Time\nt19 = time.Time{}\nvar t20 time.Time\nt20 = time.Time{}\nvar t21 time.Time\nt21 = time.Time{}\nvar t22 time.Time\nt22 = time.Time{}\nvar t23 time.Time\nt23 = time.Time{}\nvar t24 time.Time\nt24 = time.Time{}\nvar t25 time.Time\nt25 = time.Time{}\nvar t26 time.Time\nt26 = time.Time{}\nvar t27 time.Time\nt27 = time.Time{}\n"}
{"tgt": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 0},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 11},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 19},\n\t\tans1208{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s, p.t, p.maxCost))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{}\n} else if n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{intervals[0]}\nfor _, cur := range intervals[1:] {\n\tprevious := res[len(res)-1]\n\tif cur.Start <= previous.End {\n\t\tend := previous.End\n\t\tif cur.End > end {\n\t\t\tend = cur.End\n\t\t}\n\t\tres = append(res[:len(res)-1], Interval{Start: previous.Start, End: end})\n\t} else {\n\t\tres = append(res, cur)\n\t}\n}\nreturn res", "gen": "fmt.Println(merge([]Interval{{1, 3}, {2, 6}, {8, 10}, {15, 18}}))\nfmt.Println(merge([]Interval{{1, 4}, {4, 5}}))\nfmt.Println(merge([]Interval{{1, 4}, {2, 3}}))\nfmt.Println(merge([]Interval{{2, 3}, {4, 5}, {6, 7}, {8, 10}, {15, 18}}))\nfmt.Println(merge([]Interval{{1, 4}, {4, 5}, {2, 3}}))\nfmt.Println(merge([]Interval{{1, 4}, {2, 6}, {8, 10}, {15, 18}, {1, 2}}))\nfmt.Println(merge([]Interval{{1, 4}, {4, 5}, {2, 3}, {1, 2}}))\nfmt.Println(merge([]Interval{{1, 4}, {4, 5}, {2, 3}, {1, 2}, {1, 3}}))\nfmt.Println(merge([]Interval{{1, 4}, {4, 5}, {2, 3}, {1, 2}, {1, 3}, {1, 4}}))\nfmt.Println(merge([]Interval{{1, 4}, {4, 5}, {2, 3}, {1, 2}, {1, 3}, {1, 4}, {1, 5}}))\nfmt.Println(merge([]Interval{{1, 4}, {4, 5}, {2, 3}, {1, 2}, {1, 3}, {1, 4}, {1, 5}, {1, 6}}))\nfmt.Println(merge([]Interval{{1, 4}, {4, 5}, {2, 3}, {1, 2}, {1, 3}, {1, 4}, {1, 5}, {"}
{"tgt": "result := make([]int, 0, len(left)+len(right))\nfor len(left) > 0 || len(right) > 0 {\n\tif len(left) == 0 {\n\t\treturn append(result, right...)\n\t}\n\tif len(right) == 0 {\n\t\treturn append(result, left...)\n\t}\n\tif left[0] <= right[0] {\n\t\tresult = append(result, left[0])\n\t\tleft = left[1:]\n\t} else {\n\t\tresult = append(result, right[0])\n\t\tright = right[1:]\n\t}\n}\nreturn result", "gen": "var a []int\nvar b []int\nvar c []int\nvar d []int\nvar e []int\nvar f []int\nvar g []int\nvar h []int\nvar i []int\nvar j []int\nvar k []int\nvar l []int\nvar m []int\nvar n []int\nvar o []int\nvar p []int\nvar q []int\nvar r []int\nvar s []int\nvar t []int\nvar u []int\nvar v []int\nvar w []int\nvar x []int\nvar y []int\nvar z []int\nvar aa []int\nvar bb []int\nvar cc []int\nvar dd []int\nvar ee []int\nvar ff []int\nvar gg []int\nvar hh []int\nvar ii []int\nvar jj []int\nvar kk []int\nvar ll []int\nvar mm []int\nvar nn []int\nvar oo []int\nvar pp []int\nvar qq []int\nvar rr []int\nvar ss []int\nvar tt []int\nvar uu []int\nvar vv []int\nvar ww []int\nvar xx []int\nvar yy []int\nvar zz []int\nvar aaa []int\nvar bbb []int\nvar ccc []int\nvar ddd []int\nvar eee []int\nvar fff []int\nvar ggg []int\nvar hhh []int\nvar iii []int\nvar jjj []int\nvar kkk []int\nvar lll []int\nvar mmm []int\nvar nnn []int\nvar ooo []int\nvar ppp []int\nvar qqq []int\nvar rrr []int\nvar sss []int\nvar ttt []int\nvar uuu []int\nvar vvv []int\nvar www []int\nvar xxx []int\nvar yyy"}
{"tgt": "t.Parallel()\nd := NewTimeMap()\nd.Set(1, 1, 0)\nd.Set(1, 2, 2)\nif result := d.Get(1, 1); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 3); result != 2 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 5)\nif result := d.Get(1, 0); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 10); result != 1 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 0)\nd.Set(1, 2, 0)\nif result := d.Get(1, 0); result != 2 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(2, 0); result != nil {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, -1); result != nil {\n\tt.Errorf(\"STR\")\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{2},\n\t\t\t{3, 4},\n\t\t\t{6, 5, 7},\n\t\t\t{4, 1, 8, 3},\n\t\t},\n\t\t11},\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{1},\n\t\t\t{2, 3},\n\t\t},\n\t\t3},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := minimumTotal(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "pairs := [...][2]int{{15, 26}, {1000, 1366}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p16(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var a [2]int\nvar b [2]int\nvar c [2]int\nvar d [2]int\nvar e [2]int\nvar f [2]int\nvar g [2]int\nvar h [2]int\nvar i [2]int\nvar j [2]int\nvar k [2]int\nvar l [2]int\nvar m [2]int\nvar n [2]int\nvar o [2]int\nvar p [2]int\nvar q [2]int\nvar r [2]int\nvar s [2]int\nvar t [2]int\nvar u [2]int\nvar v [2]int\nvar w [2]int\nvar x [2]int\nvar y [2]int\nvar z [2]int\nvar aa [2]int\nvar ab [2]int\nvar ac [2]int\nvar ad [2]int\nvar ae [2]int\nvar af [2]int\nvar ag [2]int\nvar ah [2]int\nvar ai [2]int\nvar aj [2]int\nvar ak [2]int\nvar al [2]int\nvar am [2]int\nvar an [2]int\nvar ao [2]int\nvar ap [2]int\nvar aq [2]int\nvar ar [2]int\nvar as [2]int\nvar at [2]int\nvar au [2]int\nvar av [2]int\nvar aw [2]int\nvar ax [2]int\nvar ay [2]int\nvar az [2]int\nvar aaa [2]int\nvar aab [2]int\nvar aac [2]int\nvar aad [2]int\nvar aae [2]int\nvar aaf [2]int\nvar aag [2]int\nvar aah [2]int\nvar aai [2]int\n"}
{"tgt": "m := [26]int{}\nfor _, b := range B {\n\tcount := counter(b)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tm[i] = count[i]\n\t\t}\n\t}\n}\nres := []string{}\nfor _, a := range A {\n\tcount := counter(a)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tcontinueL\n\t\t}\n\t}\n\tres = append(res, a)\n}\nreturn res", "gen": "var a = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\nvar b = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\nvar c = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\nvar d = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\nvar e = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\nvar f = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\","}
{"tgt": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\ntmp := nums[0]\nmax := tmp\nfor i := 1; i < n; i++ {\n\tif tmp < 0 {\n\t\ttmp = nums[i]\n\t} else {\n\t\ttmp += nums[i]\n\t}\n\tif max < tmp {\n\t\tmax = tmp\n\t}\n}\nreturn max", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif i == 0 {\n\t\ta[i] = 0\n\t} else if i == 1 {\n\t\ta[i] = a[0]\n\t} else {\n\t\ta[i] = a[i-1] + a[i-2]\n\t}\n}\nfmt.Println(a[len(a)-1])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "hash := uint32(0)\nfor i := len(sep) - 1; i >= 0; i-- {\n\thash = hash*PrimeRK + uint32(sep[i])\n}\nvar pow, sq uint32 = 1, PrimeRK\nfor i := len(sep); i > 0; i >>= 1 {\n\tif i&1 != 0 {\n\t\tpow *= sq\n\t}\n\tsq *= sq\n}\nreturn hash, pow", "gen": "var a [10]int\nvar b int\nfor i := range a {\n\tb += a[i]\n}\nreturn b\n}\n\nTEXT main.main(SB) /Users/mdempsky/go/src/main/main.go\nMOVQ $0, AX\nMOVQ $0, CX\nMOVQ $0, DX\nMOVQ $0, R8\nMOVQ $0, R9\nMOVQ $0, R10\nMOVQ $0, R11\nMOVQ $0, R12\nMOVQ $0, R13\nMOVQ $0, R14\nMOVQ $0, R15\nMOVQ $0, RBP\nMOVQ $0, RSP\nMOVQ $0, RSI\nMOVQ $0, RDI\nMOVQ $0, RBX\nMOVQ $0, RDX\nMOVQ $0, RAX\nMOVQ $0, RCX\nMOVQ $0, R8\nMOVQ $0, R9\nMOVQ $0, R10\nMOVQ $0, R11\nMOVQ $0, R12\nMOVQ $0, R13\nMOVQ $0, R14\nMOVQ $0, R15\nMOVQ $0, RBP\nMOVQ $0, RSP\nMOVQ $0, RSI\nMOVQ $0, RDI\nMOVQ $0, RBX\nMOVQ $0, RDX\nMOVQ $0, RAX\nMOVQ $0, RCX\nMOVQ $0, R8\nMOVQ $0, R9\nMOVQ $0, R10\nMOVQ $0, R11\nMOVQ $0, R12\nMOVQ $0, R13\nMO"}
{"tgt": "b, _ := ioutil.ReadFile(\"STR\")\ns := strings.Replace(string(b), \"STR\", \"STR\", -1)\nnumData := strings.Split(s, \"STR\")\nfor _, n := range numData {\n\tnumber, err := strconv.Atoi(n)\n\tif err == nil {\n\t\tdata = append(data, number)\n\t}\n}", "gen": "data := []int{1, 2, 3}\ndata = append(data, 4)\nfmt.Println(data)\n}\n"}
{"tgt": "if len(A) == len(A[0]) {\n\tfor i := 0; i < len(A); i++ {\n\t\tfor j := 0; j < len(A); j++ {\n\t\t\tif i == j {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]\n\t\t}\n\t}\n\treturn A\n}\nres := make([][]int, len(A[0]))\nfor i := 0; i < len(res); i++ {\n\tres[i] = make([]int, len(A))\n\tfor j := 0; j < len(A); j++ {\n\t\tres[i][j] = A[j][i]\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := SumRevLLNum(tc.first, tc.second); !equal(result, tc.sum) {\n\t\tt.Errorf(\"STR\",\n\t\t\ttcid, String(result), String(tc.sum))\n\t}\n}", "gen": "testing.MainStart(test.Benchmark, nil, nil, nil)\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tm: 3,\n\t\tn: 3,\n\t\tops: [][]int{\n\t\t\t{2, 2},\n\t\t\t{3, 3},\n\t\t},\n\t\twant: 4,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxCount(tt.m, tt.n, tt.ops)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.m, got, tt.want)\n\t}\n}", "gen": "fmt.Println(maxCount([]int{2, 2, 3, 3, 4, 4, 5, 5}))\n}\n"}
{"tgt": "n := len(quality)\nworkers := make([][2]float64, n)\nfor i := 0; i < n; i++ {\n\tw, q := float64(wage[i]), float64(quality[i])\n\tworkers[i][0], workers[i][1] = w/q, q\n}\nsort.Slice(workers, func(i, j int) bool {\n\treturn workers[i][0] < workers[j][0]\n})\nres := math.MaxFloat64\nsum := 0.\nh := floatHeap{}\nfor _, w := range workers {\n\tsum += w[1]\n\theap.Push(&h, w[1])\n\tif len(h) > K {\n\t\tsum -= heap.Pop(&h).(float64)\n\t}\n\tif len(h) == K {\n\t\tres = min(res, sum*w[0])\n\t}\n}\nreturn res", "gen": "fmt.Println(mincostToHireWorkers([]int{10, 20, 5}, []int{7, 15, 20}))\n}\n"}
{"tgt": "flag.Parse()\nroots := flag.Args()\nif len(roots) == 0 {\n\troots = []string{\"STR\"}\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, root := range roots {\n\t\twalkDir(root, fileSizes)\n\t}\n\tclose(fileSizes)\n}()\nvar nfiles, nbytes int64\nfor size := range fileSizes {\n\tnfiles++\n\tnbytes += size\n}\nprintDiskUsage(nfiles, nbytes)", "gen": "flag.Parse()\nargs := flag.Args()\nif len(args) != 2 {\n\tpanic(\"expected two arguments\")\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, arg := range args {\n\t\tfileSizes <- getFileSize(arg)\n\t}\n\tclose(fileSizes)\n}()\ntotal := int64(0)\nfor size := range fileSizes {\n\ttotal += size\n}\nprintDiskUsage(total)\n}"}
{"tgt": "var min int\ntotalPeople := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\ttotalPeople++\n\t}\n}\nif totalPeople < 2 {\n\treturn 0\n}\nmiddle := (totalPeople / 2) + (totalPeople % 2)\nindex := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\tmiddle--\n\t}\n\tif middle == 0 {\n\t\tindex = i\n\t\tbreak\n\t}\n}\nleftZero := 0\nleftZeroFound := false\nfor j := index - 1; j >= 0; j-- {\n\tif !leftZeroFound && seating[j] == 0 {\n\t\tleftZero = j\n\t\tleftZeroFound = true\n\t} else if seating[j] == 1 && j < leftZero {\n\t\tmin += abs(j - leftZero)\n\t\tleftZero--\n\t}\n}\nrightZero := 0\nrightZeroFound := false\nfor j := index + 1; j < len(seating); j++ {\n\tif !rightZeroFound && seating[j] == 0 {\n\t\trightZero = j\n\t\trightZeroFound = true\n\t} else if seating[j] == 1 && j > rightZero {\n\t\tmin += abs(j - rightZero)\n\t\trightZero++\n\t}\n}\nreturn min", "gen": "var a, b, c int\nvar d, e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar ba int\nvar bb int\nvar bc int\nvar bd int\nvar be int\nvar bf int\nvar bg int\nvar bh int\nvar bi int\nvar bj int\nvar bk int\nvar bl int\nvar bm int\nvar bn int\nvar bo int\nvar bp int\nvar bq int\nvar br int\nvar bs int\nvar bt int\nvar bu int\nvar bv int\nvar bw int\nvar bx int\nvar by int\nvar bz int\nvar ca int\nvar cb int\nvar cc int\nvar cd int\nvar ce int\nvar cf int\nvar cg int\nvar ch int\nvar ci int\nvar cj int\nvar ck int\nvar cl int\nvar cm int\nvar cn int\nvar co int\nvar cp int\nvar cq int\nvar cr int\nvar cs int\n"}
{"tgt": "sum := 0\nprev := 1\ncurr := 1\nfor curr <= 4e6 {\n\tprev, curr = curr, prev+curr\n\tif curr%2 == 0 {\n\t\tsum += curr\n\t}\n}\nfmt.Println(sum)", "gen": "var a, b int\na = 1\nb = 1\nfor i := 1; i < 4000000; i++ {\n\tif i%2 == 0 {\n\t\ta += b\n\t} else {\n\t\ta = a + b\n\t}\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "stack := make([]int, 0)\nresult := make([]int, len(T))\nfor i, t := range T {\n\tfor len(stack) > 0 && T[stack[len(stack)-1]] < t {\n\t\tresult[stack[len(stack)-1]] = i - stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t}\n\tstack = append(stack, i)\n}\nfor _, i := range stack {\n\tresult[i] = 0\n}\nreturn result", "gen": "var a []int\nvar b []int\nvar c []int\nfor i := 0; i < 10; i++ {\n\ta = append(a, i)\n\tb = append(b, i)\n\tc = append(c, i)\n}\nfor i := 0; i < len(a); i++ {\n\tif a[i] != b[i] {\n\t\tpanic(\"not equal\")\n\t}\n}\nfor i := 0; i < len(c); i++ {\n\tif c[i] != b[i] {\n\t\tpanic(\"not equal\")\n\t}\n}\n}\n"}
{"tgt": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 2}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello, world\")\n}\n"}
{"tgt": "out := 100\nif x := p33(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "p33 := 100\nif p33 != 100 {\n\tvar p34 interface{}\n\tp34 = p33\n\tvar p35 interface{}\n\tp35 = p34\n\tvar p36 interface{}\n\tp36 = p35\n\ttesting.T.Errorf(0, 24, \"p33 != 100\", p36)\n}\n}\n\n// Testing that we can handle a function call with a constant argument.\n//\n// This is a regression test for issue #1122.\n//\n// func main() {\n// \tp33 := 100\n// \tif p33 != 100 {\n// \t\tvar p34 interface{}\n// \t\tp34 = p33\n// \t\tvar p35 interface{}\n// \t\tp35 = p34\n// \t\tvar p36 interface{}\n// \t\tp36 = p35\n// \t\ttesting.T.Errorf(0, 24, \"p33 != 100\", p36)\n// \t}\n// }\n\n// func main() {\n// \tp33 := 100\n// \tif p33 != 100 {\n// \t\tvar p34 interface{}\n// \t\tp34 = p33\n// \t\tvar p35 interface{}\n// \t\tp35 = p34\n// \t\tvar p36 interface{}\n// \t\tp36 = p35\n// \t\ttesting.T.Errorf(0, 24, \"p33 != 100\", p36)\n// \t}\n// }\n\n// func main() {\n// \tp33 := 100\n// \tif p33 != 100 {\n// \t\tvar p34 interface{}\n// \t\tp34 = p33\n// \t\tvar p35 interface{}\n"}
