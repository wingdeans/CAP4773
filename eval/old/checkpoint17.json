{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif sum := SumBSTRange(tc.root, tc.a, tc.b); sum != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, sum)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SumBSTRange(tc.root, tc.low, tc.high); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "return &linkLoop{\n\tHead: &linkLoopNode{},\n}", "gen": "return &linkLoop{\n\thead: &linkLoopNode{},\n}\n}"}
{"tgt": "return bindataRead(\n\t_assetsHomeCatJpg,\n\t\"STR\",\n)", "gen": "return bindataRead(\n\t\"STR\",\n\tSTR,\n)\n}"}
{"tgt": "max := 1000\nsum := 0\nfor i := 1; i < max; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)", "gen": "max := 1000\nsum := 0\nfor i := 1; i <= max; i++ {\n\tif i%3 == 0 || i%5 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.locs); !reflect.DeepEqual(bonuses, tc.bonuses) {\n\t\tt.Errorf(\"STR\", tc.bonuses, bonuses)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.input); !reflect.DeepEqual(bonuses, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, bonuses)\n\t}\n}\n}"}
{"tgt": "max := 9999\nbiggestPandigital := 0\nvar numberMultiplied int\nfor i := max; i > 0; i-- {\n\tnumberMultiplied = i\n\tfor j := 1; len(digits(numberMultiplied)) <= 9; j++ {\n\t\tnumberMultiplied = concatenMultiplication(i, j)\n\t\tif IsPandigital(numberMultiplied) && numberMultiplied > biggestPandigital {\n\t\t\tfmt.Println(numberMultiplied)\n\t\t\tbiggestPandigital = numberMultiplied\n\t\t}\n\t}\n}", "gen": "n := 9999\nmax := 0\nfor n > 0 {\n\tm := concatenMultiplication(n)\n\tif IsPandigital(m) {\n\t\tif m > max {\n\t\t\tmax = m\n\t\t}\n\t}\n\tn--\n}\nfmt.Println(max)\n}"}
{"tgt": "for {\n\tswitch r := l.next(); {\n\tcase unicode.IsNumber(r):\n\tcase r == \"STR\":\n\t\tl.backup()\n\t\tl.emit(itemEnd)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase r == eof:\n\t\tl.emit(itemEnd)\n\t\treturn byteRangeSet\n\tdefault:\n\t\treturn l.error(\"STR\")\n\t}\n}", "gen": "for {\n\tswitch l.next() {\n\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\tl.backup()\n\t\tl.emit(byteRangeSet)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase ',':\n\t\tl.emit(byteRangeSet)\n\t\treturn byteRangeSet\n\tdefault:\n\t\tl.error(\"STR\")\n\t\treturn byteRangeSet\n\t}\n}\n}"}
{"tgt": "return func(treebinaryTreeIf, node interface{}) bool {\n\tn := node.(*gbtElement)\n\tif !tree.IsNil(n.Left) && n.Left.Key >= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Left, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif !tree.IsNil(n.Right) && n.Right.Key <= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Right, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif debug {\n\t\tfmt.Println(n)\n\t}\n\t*nodeCnt++\n\treturn false\n}", "gen": "t := t1{\n\tt: t,\n\tdebug: debug,\n\tnodeCnt: 0,\n}\nreturn t, func(n *node) {\n\tt.nodeCnt++\n}\n}"}
{"tgt": "iterator := func() <-chan VertexId {\n\tch := make(chan VertexId)\n\tgo func() {\n\t\tif connected, ok := g.edges[vertex]; ok {\n\t\t\tfor VertexId, _ := range connected {\n\t\t\t\tif g.IsEdge(vertex, VertexId) {\n\t\t\t\t\tch <- VertexId\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\nreturn VerticesIterable(&vertexIterableHelper{iterFunc: iterator})", "gen": "g := &graph{\n\tvertices: vertices,\n}\nid := VertexId(id)\nreturn &vertexIterableHelper{\n\tVerticesIter: func(ch chan<- VertexId) {\n\t\tg.GetSuccessors(id, ch)\n\t},\n}\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 2, 1}, []int{0, 4, 1, 3, 2}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1}, []int{0}, []int{1}},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums, c.index)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums, c.index)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 4}, []int{1, 2, 3, 4, 0}},\n\t{\"STR\", []int{4, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}, []int{4, 1, 2, 3, 0}},\n\t{\"STR\", []int{1, 2, 3, 0, 4}, []int{0, 1, 2, 3, 4}, []int{1, 2, 3, 0, 4}},\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{4, 3, 2, 1, 0}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{4, 3, 2, 1, 0}, []int{1, 2, 3, 4, 0}},\n\t{\"STR\", []int{4, 1, 2, 3, 0}, []int{4, 3, 2, 1, 0}, []int{4, 1, 2, 3, 0}},\n\t{\"STR\", []int{1, 2, 3, 0, 4}, []int{4, 3, 2, 1, 0}, []int{1, 2, 3, 0, 4}},\n}\nfor i,"}
{"tgt": "c.bw.WriteString(\"STR\")\nc.bw.WriteByte(space)\nc.bw.WriteString(key)\nc.bw.WriteByte(space)\nc.bw.Write(strconv.AppendInt(c.numScratch[:0], int64(timeout), 10))\n_, err = c.bw.Write(crlf)\nreturn", "gen": "w.WriteString(\"VALUE \")\nw.WriteString(key)\nw.WriteByte(space)\nw.WriteString(strconv.Itoa(flags))\nw.WriteByte(space)\nw.WriteString(strconv.Itoa(expiration))\nw.WriteString(crlf)\nw.WriteString(string(data))\nw.WriteString(crlf)\nw.WriteString(crlf)\nreturn w.Flush()\n}"}
{"tgt": "for V > 0 {\n\tV--\n\tif !isDroppedLeft(heights, K) && !isDroppedRight(heights, K) {\n\t\theights[K]++\n\t}\n}\nreturn heights", "gen": "for i := n - 1; i >= 0; i-- {\n\tif isDroppedLeft(i) || isDroppedRight(i) {\n\t\tcontinue\n\t}\n\tnums[i]++\n}\nreturn nums\n}"}
{"tgt": "h := &IntMaxHeap{}\nheap.Init(h)\nheap.Push(h, 7)\nheap.Push(h, 3)\nheap.Push(h, 2)\nheap.Push(h, 1)\nheap.Push(h, 5)\nheap.Push(h, 5)\nheap.Push(h, 6)\nheap.Push(h, 7)\nfmt.Printf(\"STR\", (*h))\nfor h.Len() > 0 {\n\tfmt.Printf(\"STR\", heap.Pop(h))\n}", "gen": "h := IntMaxHeap{}\nh.Init(nil)\nh.Push(0)\nh.Push(1)\nh.Push(2)\nh.Push(3)\nh.Push(4)\nh.Push(5)\nh.Push(6)\nh.Push(7)\nh.Push(8)\nh.Push(9)\nh.Push(10)\nh.Push(11)\nh.Push(12)\nh.Push(13)\nh.Push(14)\nh.Push(15)\nh.Push(16)\nh.Push(17)\nh.Push(18)\nh.Push(19)\nh.Push(20)\nh.Push(21)\nh.Push(22)\nh.Push(23)\nh.Push(24)\nh.Push(25)\nh.Push(26)\nh.Push(27)\nh.Push(28)\nh.Push(29)\nh.Push(30)\nh.Push(31)\nh.Push(32)\nh.Push(33)\nh.Push(34)\nh.Push(35)\nh.Push(36)\nh.Push(37)\nh.Push(38)\nh.Push(39)\nh.Push(40)\nh.Push(41)\nh.Push(42)\nh.Push(43)\nh.Push(44)\nh.Push(45)\nh.Push(46)\nh.Push(47)\nh.Push(48)\nh.Push(49)\nh.Push(50)\nh.Push(51)\nh.Push(52)\nh.Push(53)\nh.Push(54"}
{"tgt": "sLen, pLen := len(s), len(p)\ndp := make([][]bool, sLen+1)\nfor i := range dp {\n\tdp[i] = make([]bool, pLen+1)\n}\ndp[sLen][pLen] = true\nfor i := sLen; i > -1; i-- {\n\tfor j := pLen - 1; j > -1; j-- {\n\t\tfirstMatch := i < sLen && (p[j] == s[i] || p[j] == '.')\n\t\tif j+1 < pLen && p[j+1] == '*' {\n\t\t\tdp[i][j] = dp[i][j+2] || firstMatch && dp[i+1][j]\n\t\t} else {\n\t\t\tdp[i][j] = firstMatch && dp[i+1][j+1]\n\t\t}\n\t}\n}\nreturn dp[0][0]", "gen": "n := len(s)\ndp := make([][]bool, n+1)\nfor i := range dp {\n\tdp[i] = make([]bool, n+1)\n}\nfor i := 1; i <= n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tif s[j] == '(' {\n\t\t\tdp[i][j+1] = dp[i-1][j]\n\t\t} else if s[j] == ')' {\n\t\t\tdp[i][j+1] = dp[i][j] || dp[i-1][j+1]\n\t\t}\n\t}\n}\nreturn dp[n][0]\n}"}
{"tgt": "l1 := len(board)\nif l1 == 0 {\n\treturn\n}\nl2 := len(board[0])\nif l2 == 0 {\n\treturn\n}\nvisit := make([][]bool, l1)\nfor i := 0; i < l1; i++ {\n\tvisit[i] = make([]bool, l2)\n}\nfor i := 0; i < l1; i++ {\n\tfor j := 0; j < l2; j++ {\n\t\tif !visit[i][j] {\n\t\t\thelper(board, visit, i, j)\n\t\t}\n\t}\n}", "gen": "n := len(A)\nif n == 0 {\n\treturn nil\n}\nm := len(A[0])\nres := make([][]bool, n)\nfor i := 0; i < n; i++ {\n\tres[i] = make([]bool, m)\n\tfor j := 0; j < m; j++ {\n\t\tif A[i][j] == '1' {\n\t\t\tres[i][j] = helper(A, i, j)\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.nums); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.s, tc.k); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "sum := 100 * 101 / 2\nsqSum := sum * sum\nsumSq := 0\nfor i := 1; i <= 100; i++ {\n\tsumSq += i * i\n}\nfmt.Println(sqSum - sumSq)", "gen": "sum := 5050 * 5050\nvar res int\nfor i := 1; i <= 100; i++ {\n\tres += i * i\n}\nfmt.Println(sum - res)\n}"}
{"tgt": "return x != y", "gen": "return a == b || a < b\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 1, 3}},\n\t\tans1051{3},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 2, 3, 4}},\n\t\tans1051{5},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{0},\n\t},\n\t{\n\t\tpara1051{[]int{5, 4, 3, 2, 1}},\n\t\tans1051{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 3}},\n\t\tans1051{true},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 4, 2, 3}},\n\t\tans1051{false},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{false},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4}},\n\t\tans1051{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"STR\", got, tt.want)\n\t\t}\n\t})\n}", "gen": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tgot := largestOverlap(tt.args.A, tt.args.B)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"largestOverlap() = %v, want %v\", got, tt.want)\n\t\t}\n\t})\n}\n}"}
{"tgt": "if m == 0 {\n\treturn 1\n}\nswitch n {\ncase 1:\n\treturn 2\ncase 2:\n\tif m == 1 {\n\t\treturn 3\n\t}\n\treturn 4\ndefault:\n\tswitch m {\n\tcase 1:\n\t\treturn 4\n\tcase 2:\n\t\treturn 7\n\tdefault:\n\t\treturn 8\n\t}\n}", "gen": "if n == 0 {\n\treturn 1\n}\nif n == 1 {\n\treturn 2\n}\nif n == 2 {\n\treturn 3\n}\nif n == 3 {\n\treturn 4\n}\nif n == 4 {\n\treturn 7\n}\nif n == 5 {\n\treturn 8\n}\nreturn 9\n}"}
{"tgt": "sort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].End < intervals[j].End\n})\ncount := 0\ncurrent := -int(^uint(0)>>1) - 1\nfor _, interval := range intervals {\n\tif interval.Start >= current {\n\t\tcount++\n\t\tcurrent = interval.End\n\t}\n}\nreturn len(intervals) - count", "gen": "var res int\nvar intervals = []Interval{{0, 1}}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nfor _, interval := range intervals {\n\tif interval.Start > res {\n\t\tres = interval.Start\n\t}\n}\nreturn res\n}"}
{"tgt": "switch rand.Intn(10) {\ncase 1, 9:\n\treturn io.EOF\ncase 5:\n\treturn errors.New(\"STR\")\ndefault:\n\td.Line = \"STR\"\n\tfmt.Println(\"STR\", d.Line)\n\treturn nil\n}", "gen": "switch rand.Intn(10) {\ncase 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:\n\treturn EOF\ndefault:\n\treturn errors.New(\"STR\")\n}\nfmt.Println(\"STR\")\n}"}
{"tgt": "fmt.Println(subarrayBitwiseORs([]int{0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))", "gen": "fmt.Println(subarrayBitwiseORs([]int{0, 1, 1}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))\n}"}
{"tgt": "dummy := &ListNode{0, head}\nslow, fast := dummy, dummy\nfor fast.Next != nil && fast.Next.Next != nil {\n\tfast = fast.Next.Next\n\tslow = slow.Next\n}\nreturn slow.Next", "gen": "var head *ListNode\nfor head != nil && head.Next != nil && head.Next.Next != nil {\n\thead = head.Next.Next\n}\nreturn head\n}"}
{"tgt": "pairs := [...][2]int{{10, 7}, {1000, 983}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p26(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "tests := [...]struct {\n\tin   int\n\twant int\n}{\n\t{10, 2},\n\t{7, 1},\n\t{1000, 983},\n\t{983, 983},\n}\nfor _, tt := range tests {\n\tgot := p26(tt.in)\n\tif got != tt.want {\n\t\tt.Errorf(\"STR\", tt.in, got, tt.want)\n\t}\n}\n}"}
{"tgt": "n := len(A)\nfor i := n - 2; i >= 0; i-- {\n\tA[i] += A[i+1]\n}\nmem := [101][33]int{}\nvar dp func(int, int) int\ndp = func(i, m int) int {\n\tif i+2*m >= n {\n\t\treturn A[i]\n\t}\n\tif mem[i][m] > 0 {\n\t\treturn mem[i][m]\n\t}\n\tres := 0\n\tfor x := 1; x <= 2*m; x++ {\n\t\tres = max(\n\t\t\tres,\n\t\t\tA[i]-dp(i+x, max(m, x)),\n\t\t)\n\t}\n\tmem[i][m] = res\n\treturn res\n}\nreturn dp(0, 1)", "gen": "n := len(stones)\ndp := make([]int, n+1)\nfor i := n - 1; i >= 0; i-- {\n\tdp[i+1] = dp[i] + stones[i]\n}\nmemset(dp, 0, n)\nvar dfs func(i int) int\ndfs = func(i int) int {\n\tif i < 0 {\n\t\treturn 0\n\t}\n\tif dp[i] != 0 {\n\t\treturn dp[i]\n\t}\n\tdp[i] = -1\n\treturn dp[i]\n}\nreturn dfs(n - 1)\n}"}
{"tgt": "if n == 0 {\n\treturn 0\n}\nreturn n/5 + trailingZeroes(n/5)", "gen": "if n == 0 {\n\treturn 0\n}\nreturn trailingZeroes(n / 5) + n/5\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0}, 5},\n\t{\"STR\", []int{0, 0, 0, 0, 1}, []int{1, 0, 0, 0, 0}, 4},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums1, c.nums2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums1, c.nums2)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0}, []int{0}, 0},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tret := findMedianSortedArrays(c.nums1, c.nums2)\n\t\tif ret != c.expect {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, ret, c.nums1, c.nums2)\n\t\t}\n\t})\n}\n}"}
{"tgt": "list.rear = nil", "gen": "self.data = nil\n}"}
{"tgt": "if len(name) == 0 && len(typed) == 0 {\n\treturn true\n}\nif (len(name) == 0 && len(typed) != 0) || (len(name) != 0 && len(typed) == 0) {\n\treturn false\n}\nj := 0\nfor i := 0; i < len(name); i++ {\n\tif j < len(typed) && name[i] == typed[j] {\n\t\tj++\n\t\tcontinue\n\t} else {\n\t\tif i > 0 && j < len(typed) && name[i-1] == typed[j] {\n\t\t\tj++\n\t\t\ti--\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "if len(s) == 0 || len(t) == 0 {\n\treturn false\n}\nif len(s) != len(t) {\n\treturn false\n}\nif len(s) == len(t) {\n\treturn true\n}\ni, j := 0, 0\nfor i < len(s) {\n\tif s[i] == t[j] {\n\t\ti++\n\t\tj++\n\t} else if i < len(s) {\n\t\ti++\n\t} else if j < len(t) {\n\t\tj++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "factorial := new(big.Int).MulRange(1, 100)\nbytes := factorial.Append([]byte{}, 10)\nsum := 0\nfor b := range bytes {\n\tsum += int(bytes[b] - '0')\n}\nfmt.Println(\"STR\", sum)", "gen": "n := new(big.Int)\nn.MulRange(0, 100)\nn.Append(10)\nvar s string\nfor _, b := range n.Bytes() {\n\ts += string(b - 48)\n}\nfmt.Println(s)\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs int\n\texpect int\n}{\n\t{\"STR\", 2, 1},\n\t{\"STR\", 3, 2},\n\t{\"STR\", 4, 3},\n\t{\"STR\", 0, 0},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{2, 3}, 1},\n\t{\"STR\", []int{2, 3}, 1},\n\t{\"STR\", []int{2, 3}, 1},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}\n}"}
{"tgt": "var low, mid, high int = 0, len(sorted) / 2, len(sorted)\nfor low < high {\n\tcurr := sorted[mid]\n\tswitch {\n\tcase curr == target:\n\t\treturn mid\n\tcase inRange(sorted[mid:high], target):\n\t\tlow = mid\n\t\tmid = (low + high) / 2\n\tdefault:\n\t\thigh = mid\n\t\tmid = (low + high) / 2\n\t}\n}\nreturn -1", "gen": "low, high := 0, len(nums)>>1\nfor low < high {\n\tmid := (low + high) >> 1\n\tif nums[mid] < target {\n\t\tlow = mid + 1\n\t} else if nums[mid] > target {\n\t\thigh = mid\n\t} else {\n\t\treturn mid\n\t}\n}\nreturn -1\n}"}
{"tgt": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nret := &ListNode{}\nif l1.Val <= l2.Val {\n\tret = l1\n\tret.Next = mergeTwoLists1(l1.Next, l2)\n} else {\n\tret = l2\n\tret.Next = mergeTwoLists1(l1, l2.Next)\n}\nreturn ret", "gen": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nif l1.Val < l2.Val {\n\tl1.Next = mergeTwoLists1(l1.Next, l2)\n\treturn l1\n}\nl2.Next = mergeTwoLists1(l1, l2.Next)\nreturn l2\n}"}
{"tgt": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Print(sum, \"STR\")", "gen": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif i%3 == 0 || i%5 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "rets := make([][]int, numRows)\nif numRows == 0 {\n\treturn rets\n}\nrets[0] = []int{1}\nfor i := 1; i < numRows; i++ {\n\trets[i] = make([]int, i+1)\n\trets[i][0] = 1\n\trets[i][i] = 1\n\tfor j := 1; j < i; j++ {\n\t\trets[i][j] = rets[i-1][j-1] + rets[i-1][j]\n\t}\n}\nreturn rets", "gen": "if len(nums) == 0 {\n\treturn nums\n}\nres := [][]int{{1}}\nfor i := 1; i < len(nums); i++ {\n\tfor j := 0; j < len(res); j++ {\n\t\tres[j] = append(res[j], 1)\n\t\tfor k := 0; k < len(res[j]); k++ {\n\t\t\tres[j][k] += res[j][k]\n\t\t\tres[j][k] += nums[i]\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "start := -1\nlenMax := 0\ndict := [256]int{}\nfor i := range dict {\n\tdict[i] = -1\n}\nfor i, r := range s {\n\tif v := dict[r]; v > start {\n\t\tstart = v\n\t}\n\tlength := i - start\n\tif length > lenMax {\n\t\tlenMax = length\n\t}\n\tdict[r] = i\n}\nreturn lenMax", "gen": "max := -1\nmin := 0\nfor i := 0; i < 256; i++ {\n\tdp[i] = -1\n}\nfor i := 0; i < len(s); i++ {\n\tif i < 0 || i > 255 {\n\t\tpanic(\"STR\")\n\t}\n\tdp[i] = -1\n}\nfor i, c := range s {\n\tif c < 0 || c > 127 {\n\t\tpanic(\"STR\")\n\t}\n\tif dp[i] < 0 {\n\t\tdp[i] = c\n\t}\n\tif dp[i] < c {\n\t\tmax = c\n\t}\n\tif i-dp[i] > min {\n\t\tmin = i - dp[i]\n\t}\n}\nreturn min\n}"}
{"tgt": "nlen := len(nums)\nfor i := 0; i < nlen-2; i++ {\n\tif i != 0 && nums[i] == nums[i-1] {\n\t\tcontinue\n\t}\n\tleft, right := i+1, nlen-1\n\tfor left < right {\n\t\tsum := nums[i] + nums[left] + nums[right]\n\t\tif sum == target {\n\t\t\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tleft++\n\t\t\tright--\n\t\t} else if sum < target {\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tleft++\n\t\t} else {\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tright--\n\t\t}\n\t}\n}", "gen": "for i := 0; i < len(nums); i++ {\n\tfor j := i + 1; j < len(nums); j++ {\n\t\tif nums[i]+nums[j] == target {\n\t\t\treturn []int{nums[i], nums[j]}\n\t\t}\n\t}\n\tfor j := i - 1; j >= 0; j-- {\n\t\tif nums[i]+nums[j] == target {\n\t\t\treturn []int{nums[i], nums[j]}\n\t\t}\n\t}\n}\nreturn nil\n}"}
{"tgt": "return strings.ReplaceAll(r.element.Name, \"STR\", \"\")", "gen": "return strings.ReplaceAll(s, \"STR\", \"STR\")\n}"}
{"tgt": "var res byte\nfor i := 0; i < len(s); i++ {\n\tres ^= s[i]\n}\nfor i := 0; i < len(t); i++ {\n\tres ^= t[i]\n}\nreturn res", "gen": "var res bool\nfor i := 0; i < len(s1); i++ {\n\tres ^= s1[i]\n}\nfor i := 0; i < len(s2); i++ {\n\tres ^= s2[i]\n}\nreturn res\n}"}
{"tgt": "m := len(A)\nn := len(A[0])\nans := make([][]int, n)\nfor k := range ans {\n\tans[k] = make([]int, m)\n}\nfor r := 0; r < m; r++ {\n\tfor c := 0; c < n; c++ {\n\t\tans[c][r] = A[r][c]\n\t}\n}\nreturn ans", "gen": "n := len(matrix)\nres := make([][]int, n)\nfor i := range res {\n\tres[i] = make([]int, n)\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tres[i][j] = matrix[i][j]\n\t}\n}\nreturn res\n}"}
{"tgt": "println(\"STR\", len(a))", "gen": "println(\"STR\", 4)\n}"}
{"tgt": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nc, res := []int{}, [][]int{}\nsort.Ints(candidates)\nfindcombinationSum(candidates, target, 0, c, &res)\nreturn res", "gen": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nsort.Ints(candidates)\nreturn findcombinationSum(candidates, target, []int{}, []int{})\n}"}
{"tgt": "for i := 0; i < len(A)-1; i++ {\n\tif A[i] == i {\n\t\tcontinue\n\t}\n\tif A[i] == i+1 && A[i+1] == i {\n\t\ti++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "for i := 0; i < len(nums)-1; i++ {\n\tif nums[i] == nums[i+1] {\n\t\ti++\n\t\tcontinue\n\t}\n\tif i < len(nums)-2 && nums[i] == nums[i+2] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "for n := 0; n < 32; n++ {\n\tsquare[n] = gf2MatrixTimes(mat, mat[n])\n}", "gen": "for i := 0; i < 32; i++ {\n\tcrc[i] = gf2MatrixTimes(crc, poly)\n\tcrc[i] ^= poly[i]\n}\n}"}
{"tgt": "for i := 0; i < n; i++ {\n\tif len(squares) != i {\n\t\tprintln(\"STR\", len(squares), \"STR\", i)\n\t}\n\tsquares[i] = i * i\n\tfor j := 0; j <= i; j++ {\n\t\tif v, ok := squares[j]; !ok || v != j*j {\n\t\t\tif !ok {\n\t\t\t\tprintln(\"STR\", j)\n\t\t\t} else {\n\t\t\t\tprintln(\"STR\", j, v)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "for i := 0; i < n; i++ {\n\tif i == 0 {\n\t\tm[i] = 1\n\t} else {\n\t\tm[i] = i * m[i-1]\n\t}\n\tfor j := 0; j < i; j++ {\n\t\tif j%2 == 0 && m[j] == m[i] {\n\t\t\tfmt.Println(\"STR\", i, j)\n\t\t} else if j%2 == 1 && m[j] == m[i] {\n\t\t\tfmt.Println(\"STR\", i, j)\n\t\t}\n\t}\n}\n}"}
{"tgt": "for j := 1; j <= 20; j++ {\n\tif num%j != 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "for i := 1; i <= 20; i++ {\n\tif n%i != 0 {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "if len(sorted) == 0 {\n\treturn nil\n}\nmid := len(sorted) / 2\nroot := &BST{Value: sorted[mid]}\nroot.Left = SortedSliceToBST(sorted[:mid])\nroot.Right = SortedSliceToBST(sorted[mid+1:])\nreturn root", "gen": "if len(nums) == 0 {\n\treturn nil\n}\nmid := len(nums) / 2\nleft := SortedSliceToBST(nums[:mid])\nright := SortedSliceToBST(nums[mid+1:])\nreturn &BST{\n\tVal:   nums[mid],\n\tLeft:  left,\n\tRight: right,\n}\n}"}
{"tgt": "return x * y", "gen": "return float32(a.X*b.X + a.Y*b.Y + a.Z*b.Z)\n}"}
{"tgt": "i1 := 0\ni2 := 0\nval1 := 0\nval2 := 0\nfor i1 < len(version1) || i2 < len(version2) {\n\tval1, i1 = parseSeg(version1, i1)\n\tval2, i2 = parseSeg(version2, i2)\n\tif val1 > val2 {\n\t\treturn 1\n\t}\n\tif val1 < val2 {\n\t\treturn -1\n\t}\n}\nif i1 < len(version1) {\n\treturn 1\n}\nif i2 < len(version2) {\n\treturn -1\n}\nreturn 0", "gen": "var (\n\tstart, end int\n\ts1, s2    = parseSeg(S), parseSeg(E)\n)\nfor start < len(S) && end < len(E) {\n\tif s1 < s2 {\n\t\treturn 1\n\t}\n\tif s1 > s2 {\n\t\treturn -1\n\t}\n\ts1, s2 = parseSeg(S[start:])\n\ts1, s2 = parseSeg(E[end:])\n\tif s1 < s2 {\n\t\treturn 1\n\t}\n\tif s1 > s2 {\n\t\treturn -1\n\t}\n\tstart++\n\tend++\n}\nif start < len(S) {\n\treturn 1\n}\nif end < len(E) {\n\treturn -1\n}\nreturn 0\n}"}
{"tgt": "return this.Val", "gen": "return h.head\n}"}
{"tgt": "str := \"STR\"\nfmt.Println(longestPalindrome(str))", "gen": "fmt.Println(longestPalindrome(\"STR\"))\n}"}
{"tgt": "dat, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\nnamesList := string(dat)\nnamesList = strings.Replace(namesList, \"STR\", \"STR\", -1)\nnames := strings.Split(namesList, \"STR\")\nsort.Strings(names)\nnamesScore := 0\nfor index, name := range names {\n\tnamesScore += nameScore(name) * (index + 1)\n}\nfmt.Println(namesScore)", "gen": "b, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\ns := strings.Replace(string(b), \"STR\", \"STR\", 1)\ns = strings.Split(s, \"STR\")\nsort.Strings(s)\nvar sum int\nfor _, v := range s {\n\tsum += nameScore(v)\n}\nfmt.Println(sum)\n}"}
{"tgt": "res := 0\nsort.Ints(houses)\nsort.Ints(heaters)\nm, n := len(houses), len(heaters)\nindex := sort.SearchInts(heaters, houses[0])\nfor _, house := range houses {\n\tfor index < n && house > heaters[index] {\n\t\tindex++\n\t}\n\tif index == n {\n\t\treturn max(res, houses[m-1]-heaters[index-1])\n\t}\n\tleft := math.MaxInt32\n\tif index > 0 {\n\t\tleft = house - heaters[index-1]\n\t}\n\tright := heaters[index] - house\n\tres = max(res, min(left, right))\n}\nreturn res", "gen": "sort.Ints(A)\nsort.Ints(B)\ni := sort.SearchInts(A, B[0])\nmax := A[i-1]\nmin := A[i]\nfor i < len(A) && i < len(B) {\n\tmax = max(max, A[i])\n\tmin = min(min, B[i])\n\ti++\n}\nif i < len(B) {\n\tmax = max(max, 2147483647)\n\tmin = min(min, B[i])\n}\nreturn max - min\n}"}
{"tgt": "l, r := &maxHeap{}, &minHeap{}\nheap.Init(l)\nheap.Init(r)\nreturn MedianFinder{l, r}", "gen": "maxHeap := &maxHeap{}\nminHeap := &minHeap{}\nheap.Init(maxHeap)\nheap.Init(minHeap)\nreturn maxHeap, minHeap\n}"}
{"tgt": "l := len(preorder)\nif l == 0 {\n\treturn nil\n}\nfor 1 < l && preorder[0] < preorder[l-1] {\n\tl--\n}\nreturn &TreeNode{\n\tVal:   preorder[0],\n\tLeft:  bstFromPreorder(preorder[1:l]),\n\tRight: bstFromPreorder(preorder[l:]),\n}", "gen": "n := len(preorder)\nif n == 0 {\n\treturn nil\n}\nif n == 1 {\n\treturn &TreeNode{Val: preorder[0]}\n}\nif preorder[0] < preorder[n-1] {\n\treturn &TreeNode{\n\t\tVal:   preorder[0],\n\t\tLeft:  bstFromPreorder(preorder[1 : n-1]),\n\t\tRight: bstFromPreorder(preorder[n-1:]),\n\t}\n}\nreturn bstFromPreorder(preorder[1:n-1])\n}"}
{"tgt": "ln, err := net.Listen(\"STR\", \"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"STR\", conn.RemoteAddr())\n\tio.WriteString(conn, fmt.Sprint(time.Now()))\n\tconn.Close()\n}", "gen": "listener, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\nif err != nil {\n\tpanic(err)\n}\ndefer listener.Close()\nfor {\n\tconn, err := listener.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"STR\")\n\ttime.Sleep(time.Now())\n\tconn.WriteString(\"STR\")\n\tconn.Close()\n}\n}"}
{"tgt": "i, l := 0, len(bits)-1\nfor i < l {\n\ti += bits[i] + 1\n}\nreturn i == l", "gen": "i := 0\nn := len(nums) - 1\nfor i < n {\n\ti += nums[i] + 1\n}\nreturn i == n\n}"}
{"tgt": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.para1108))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "start := 0\nend := len(s) - 1\nfor start < end {\n\ts[start], s[end] = s[end], s[start]\n\tstart++\n\tend--\n}\nreturn s", "gen": "for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n\tnums[i], nums[j] = nums[j], nums[i]\n}\nreturn nums\n}"}
{"tgt": "for cur := t.root; cur != nil; {\n\tif cur.Key == key {\n\t\treturn cur\n\t} else if key < cur.Key {\n\t\tcur = cur.left\n\t} else {\n\t\tcur = cur.right\n\t}\n}\nreturn nil", "gen": "current := b.root\nfor current != nil {\n\tif current.value == value {\n\t\treturn &current.bstElement\n\t} else if current.value < value {\n\t\tcurrent = current.right\n\t} else {\n\t\tcurrent = current.left\n\t}\n}\nreturn nil\n}"}
{"tgt": "arr := randomSlice(0, 20, 10)\nnodeCnt := 0\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\nrotateNodes := make([]*gbtElement, 0, 0)\ngbt.InOrderWalk(gbt.Root(), func(GBTbinaryTreeIf, node interface{}) bool {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\trotateNodes = append(rotateNodes, node.(*gbtElement))\n\t}\n\treturn false\n})\nfor _, v := range rotateNodes {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\tgbt.LeftRotate(v)\n\t} else {\n\t\tgbt.RightRotate(v)\n\t}\n}\ngbt.InOrderWalk(gbt.Root(), checkGBT(t, &nodeCnt, *debug))\nif nodeCnt != len(arr) {\n\tt.Log(fmt.Sprintf(\"STR\", len(arr), nodeCnt))\n\tt.Fail()\n}", "gen": "nodes := randomSlice(10, 20, 0)\ntree := newGBT()\nfor _, node := range nodes {\n\ttree.Insert(node)\n}\nfor _, node := range nodes {\n\tif rand.Intn(2) == 0 {\n\t\ttree.Rotate(node)\n\t}\n}\nif debug {\n\tcheckGBT(tree, nodes)\n}\nif !tree.check() {\n\tt.Log(\"STR\", \"STR\", \"STR\")\n\tt.Fail()\n}\n}"}
{"tgt": "return WordDictionary{}", "gen": "return &Stack{\n\tdata: make([]interface{}, 0, 27),\n}\n}"}
{"tgt": "return xtime.Unix(int64(jt), 0)", "gen": "return time.Unix(t.Unix(), 0)\n}"}
{"tgt": "return append(ints, added...)", "gen": "return append(s, 0)\n}"}
{"tgt": "data, err := base64.StdEncoding.DecodeString(b64)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(data)", "gen": "s, err := base64.StdEncoding.DecodeString(str)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(s)\n}"}
{"tgt": "h := fnv.New64a()\n_, _ = h.Write([]byte(fmt.Sprintf(\"STR\", key)))\nhashValue := h.Sum64()\nreturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))", "gen": "hasher := fnv.New64a()\nhasher.Write([]byte(fmt.Sprintf(\"STR\", 2)))\nreturn hasher.Sum64() & 0xffff\n}"}
{"tgt": "return fmt.Sprintf(\"STR\", p.Name, p.Age)", "gen": "return fmt.Sprintf(\"STR\", t.ID)\n}"}
{"tgt": "parent := this\nfor _, ch := range prefix {\n\tif child, ok := parent.Children[ch]; ok {\n\t\tparent = child\n\t\tcontinue\n\t}\n\treturn false\n}\nreturn true", "gen": "var node *Trie\nfor _, c := range s {\n\tif c > 127 {\n\t\treturn false\n\t}\n\tnode = node.children[c]\n\tif node == nil {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)", "gen": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)\n}"}
{"tgt": "close(p.work)\np.wg.Wait()", "gen": "close(c)\nwg.Wait()\n}"}
{"tgt": "m := make(map[int]struct{})\nfor _, num := range nums1 {\n\tm[num] = struct{}{}\n}\nnums := make([]int, 0)\nfor _, num := range nums2 {\n\tif _, ok := m[num]; ok {\n\t\tnums = append(nums, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn nums", "gen": "m := make(map[int]struct{})\nfor _, num := range nums {\n\tm[num] = struct{}{}\n}\nres := make([]int, 0)\nfor _, num := range nums {\n\tif _, ok := m[num]; !ok {\n\t\tres = append(res, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn res\n}"}
{"tgt": "return h.FromHexString(string(b))", "gen": "return Hash{}.FromHexString(string(b))\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif denoms := EgyptianFractions(tc.numerator, tc.denominator); !reflect.DeepEqual(tc.denominators, denoms) {\n\t\tt.Errorf(\"STR\", tc.denominators, denoms)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := EgyptianFractions(tc.n); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "log.SetFlags(0)\nvar err error\ntpl := template.New(\"STR\")\ntpl = tpl.Funcs(template.FuncMap{\n\t\"STR\": func(str string) string {\n\t\treturn strings.ToUpper(str)\n\t},\n})\ntpl, err = tpl.ParseFiles(\"STR\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nerr = tpl.ExecuteTemplate(os.Stdout, \"STR\", Page{\n\tTitle: \"STR\",\n\tBody:  \"STR\",\n})\nif err != nil {\n\tlog.Fatalln(err)\n}", "gen": "log.SetFlags(log.Lshortfile)\nt := template.New(\"\").Funcs(map[string]interface{}{\n\t\"STR\": STR,\n})\n_, err := t.ParseFiles(\"STR\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nt.ExecuteTemplate(os.Stdout, \"STR\", Page{STR: \"STR\"})\n}"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA `structs:\"STR\"`\n\tC  int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif ok {\n\tt.Error(\"STR\")\n}", "gen": "type B struct {\n\tA *structs.B\n}\nb := B{\n\tA: &structs.B{},\n}\nif HasZero(b) {\n\tt.Error(\"STR\")\n}\n}"}
{"tgt": "digits := convert(N + 1)\nbits := len(digits)\nnoRepeat := 0\nfor b := 1; b < bits; b++ {\n\tnoRepeat += 9 * count(9, b-1)\n}\nhasSeen := make(map[int]bool, 10)\nfor b := 0; b < bits; b++ {\n\td := 0\n\tif b == 0 {\n\t\td = 1\n\t}\n\tfor ; d < digits[b]; d++ {\n\t\tif !hasSeen[d] {\n\t\t\tnoRepeat += count(9-b, bits-b-1)\n\t\t}\n\t}\n\tif hasSeen[digits[b]] {\n\t\tbreak\n\t}\n\thasSeen[digits[b]] = true\n}\nreturn N - noRepeat", "gen": "res := convert(1 + n)\ncount := 0\nfor i := 1; i <= n; i++ {\n\tcount += count(9, i)\n}\nm := make(map[int]bool)\nfor i := 0; i < n; i++ {\n\tif m[res[i]] {\n\t\tcount += count(9, n-i)\n\t}\n\tm[res[i]] = true\n}\nreturn n - count\n}"}
{"tgt": "return me[0] == \"STR\"", "gen": "return len(s) > 1 && s[1] == \"1\"\n}"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil {\n\t\t\tmax = max.Right\n\t\t}\n\t\tmax.Right = root\n\t\troot, root.Left = root.Left, nil\n\t}\n}\nreturn res", "gen": "var res []int\nfor head != nil {\n\tif head.Next == nil {\n\t\tres = append(res, head.Val)\n\t\tbreak\n\t}\n\thead = head.Next\n}\nfor head != nil {\n\thead = head.Next\n}\nhead.Next = &ListNode{Val: 1, Next: nil}\nfor head != nil {\n\thead = head.Next\n}\nreturn res\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   0x5555,\n\t\twant: 8,\n\t},\n}\nfor _, tt := range tests {\n\tgot := hammingWeight(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "tests := [...]struct {\n\tin   uint32\n\twant int\n}{\n\t{3, 2},\n\t{2, 1},\n\t{7, 3},\n\t{3, 2},\n\t{8, 1},\n\t{1, 21845},\n\t{8, 3},\n}\nfor _, tt := range tests {\n\tif got := hammingWeight(tt.in); got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}\n}"}
{"tgt": "if a == nil && b == nil {\n\treturn true\n}\nif len(a) != len(b) {\n\treturn false\n}\nfor i := range a {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "if len(s) == 0 || len(t) == 0 || len(s) != len(t) {\n\treturn false\n}\nfor i := 0; i < len(s); i++ {\n\tif s[i] != t[i] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "return xtime.Unix(int64(jt), 0), nil", "gen": "return Time{time.Unix(t, 0)}\n}"}
{"tgt": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 0},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 11},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 19},\n\t\tans1208{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s, p.t, p.maxCost))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\"},\n\t\ttrue,\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\"},\n\t\ttrue,\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\"},\n\t\ttrue,\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s1, p.s2))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{}\n} else if n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{intervals[0]}\nfor _, cur := range intervals[1:] {\n\tprevious := res[len(res)-1]\n\tif cur.Start <= previous.End {\n\t\tend := previous.End\n\t\tif cur.End > end {\n\t\t\tend = cur.End\n\t\t}\n\t\tres = append(res[:len(res)-1], Interval{Start: previous.Start, End: end})\n\t} else {\n\t\tres = append(res, cur)\n\t}\n}\nreturn res", "gen": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{{}}\n}\nif n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{{intervals[0]}}\nfor i := 1; i < n; i++ {\n\tif res[len(res)-1].End < intervals[i].Start {\n\t\tres = append(res, intervals[i])\n\t} else {\n\t\tres[len(res)-1].End = intervals[i].End\n\t}\n}\nreturn res\n}"}
{"tgt": "result := make([]int, 0, len(left)+len(right))\nfor len(left) > 0 || len(right) > 0 {\n\tif len(left) == 0 {\n\t\treturn append(result, right...)\n\t}\n\tif len(right) == 0 {\n\t\treturn append(result, left...)\n\t}\n\tif left[0] <= right[0] {\n\t\tresult = append(result, left[0])\n\t\tleft = left[1:]\n\t} else {\n\t\tresult = append(result, right[0])\n\t\tright = right[1:]\n\t}\n}\nreturn result", "gen": "res := make([]int, 0, len(nums)+len(queries))\nif len(nums) == 0 {\n\treturn res\n}\nif len(queries) == 0 {\n\treturn append(res, nums...)\n}\nif queries[0] < len(nums) {\n\tres = append(res, nums[:queries[0]+1]...)\n\tnums = nums[queries[0]+1:]\n}\nfor len(nums) > 0 && len(queries) > 0 {\n\tif queries[0] < len(nums) {\n\t\tres = append(res, nums[:queries[0]+1]...)\n\t\tnums = nums[queries[0]+1:]\n\t}\n\tqueries = queries[1:]\n}\nreturn append(res, nums...)\n}"}
{"tgt": "t.Parallel()\nd := NewTimeMap()\nd.Set(1, 1, 0)\nd.Set(1, 2, 2)\nif result := d.Get(1, 1); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 3); result != 2 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 5)\nif result := d.Get(1, 0); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 10); result != 1 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 0)\nd.Set(1, 2, 0)\nif result := d.Get(1, 0); result != 2 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(2, 0); result != nil {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, -1); result != nil {\n\tt.Errorf(\"STR\")\n}", "gen": "t.Parallel()\ntm := NewTimeMap()\ntm.Set(0, 0)\ntm.Set(2, 2)\nif tm.Get(1) != 0 {\n\tt.Errorf(\"STR\")\n}\nif tm.Get(3) != 2 {\n\tt.Errorf(\"STR\")\n}\ntm.Set(5, 1)\nif tm.Get(0) != 0 {\n\tt.Errorf(\"STR\")\n}\nif tm.Get(1) != 1 {\n\tt.Errorf(\"STR\")\n}\nif tm.Get(3) != 2 {\n\tt.Errorf(\"STR\")\n}\nif tm.Get(5) != 1 {\n\tt.Errorf(\"STR\")\n}\ntm.Set(10, 1)\nif tm.Get(0) != 0 {\n\tt.Errorf(\"STR\")\n}\nif tm.Get(1) != 1 {\n\tt.Errorf(\"STR\")\n}\nif tm.Get(3) != 2 {\n\tt.Errorf(\"STR\")\n}\nif tm.Get(5) != 1 {\n\tt.Errorf(\"STR\")\n}\nif tm.Get(10) != 1 {\n\tt.Errorf(\"STR\")\n}\ntm.Set(0, 1)\nif tm.Get(0) != 1 {\n\tt.Errorf(\"STR\")\n}\nif tm.Get(1) != 1 {\n\tt.Errorf(\"STR\")\n}\nif tm.Get(3) != 2 {\n\tt.Errorf(\"STR\")\n}\nif tm.Get(5) != 1 {\n\tt.Errorf(\"STR\")\n}\nif tm.Get(10) != 1 {\n\tt.Errorf(\"STR\")\n}\nif tm.Get(0) != 1"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{2},\n\t\t\t{3, 4},\n\t\t\t{6, 5, 7},\n\t\t\t{4, 1, 8, 3},\n\t\t},\n\t\t11},\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{1},\n\t\t\t{2, 3},\n\t\t},\n\t\t3},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := minimumTotal(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{{2, 3, 4}, {1, 2, 3, 4}, {6, 5, 7, 8, 9}}, 1},\n\t{\"STR\", [][]int{{1, 2, 3, 4}, {1, 2, 3, 4}}, 2},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := findLHS(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got,\n\t\t\t)\n\t\t}\n\t})\n}\n}"}
{"tgt": "pairs := [...][2]int{{15, 26}, {1000, 1366}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p16(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "tests := [...]struct {\n\tin   int\n\twant int\n}{\n\t{15, 1},\n\t{26, 1},\n\t{1000, 1},\n\t{1366, 1},\n}\nfor _, tt := range tests {\n\tgot := p16(tt.in)\n\tif got != tt.want {\n\t\tt.Errorf(\"STR\", tt.in, got, tt.want)\n\t}\n}\n}"}
{"tgt": "m := [26]int{}\nfor _, b := range B {\n\tcount := counter(b)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tm[i] = count[i]\n\t\t}\n\t}\n}\nres := []string{}\nfor _, a := range A {\n\tcount := counter(a)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tcontinueL\n\t\t}\n\t}\n\tres = append(res, a)\n}\nreturn res", "gen": "var res []string\nfor _, word := range words {\n\tcounter := counter(word)\n\tfor i := 0; i < len(word); i++ {\n\t\tif counter[i] == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tfor j := 0; j < len(word); j++ {\n\t\t\tif j == i {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif counter[j] == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tres = append(res, word[:i]+word[j:])\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\ntmp := nums[0]\nmax := tmp\nfor i := 1; i < n; i++ {\n\tif tmp < 0 {\n\t\ttmp = nums[i]\n\t} else {\n\t\ttmp += nums[i]\n\t}\n\tif max < tmp {\n\t\tmax = tmp\n\t}\n}\nreturn max", "gen": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\nmax := nums[0]\nfor i := 1; i < n; i++ {\n\tif nums[i] < 0 {\n\t\tnums[i] += nums[i-1]\n\t} else {\n\t\tnums[i] = nums[i] + nums[i-1]\n\t}\n\tif nums[i] > max {\n\t\tmax = nums[i]\n\t}\n}\nreturn max\n}"}
{"tgt": "hash := uint32(0)\nfor i := len(sep) - 1; i >= 0; i-- {\n\thash = hash*PrimeRK + uint32(sep[i])\n}\nvar pow, sq uint32 = 1, PrimeRK\nfor i := len(sep); i > 0; i >>= 1 {\n\tif i&1 != 0 {\n\t\tpow *= sq\n\t}\n\tsq *= sq\n}\nreturn hash, pow", "gen": "var sum, mul int\nfor i := len(nums) - 1; i >= 0; i-- {\n\tsum += nums[i] * 16777619\n}\nfor i := len(nums) - 1; i >= 0; i-- {\n\tif nums[i]&1 == 1 {\n\t\tsum *= 16777619\n\t}\n\tmul *= 16777619\n}\nreturn sum * mul\n}"}
{"tgt": "b, _ := ioutil.ReadFile(\"STR\")\ns := strings.Replace(string(b), \"STR\", \"STR\", -1)\nnumData := strings.Split(s, \"STR\")\nfor _, n := range numData {\n\tnumber, err := strconv.Atoi(n)\n\tif err == nil {\n\t\tdata = append(data, number)\n\t}\n}", "gen": "data, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\treturn\n}\ndata = []byte(STR)\ndata = []byte(STR)\nfor _, v := range strings.Split(STR, \"STR\") {\n\ti, _ := strconv.Atoi(v)\n\tdata = append(data, i)\n}\nreturn data\n}"}
{"tgt": "if len(A) == len(A[0]) {\n\tfor i := 0; i < len(A); i++ {\n\t\tfor j := 0; j < len(A); j++ {\n\t\t\tif i == j {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]\n\t\t}\n\t}\n\treturn A\n}\nres := make([][]int, len(A[0]))\nfor i := 0; i < len(res); i++ {\n\tres[i] = make([]int, len(A))\n\tfor j := 0; j < len(A); j++ {\n\t\tres[i][j] = A[j][i]\n\t}\n}\nreturn res", "gen": "if len(matrix) == 0 {\n\treturn nil\n}\nif len(matrix[0]) == 0 {\n\treturn nil\n}\nres := make([][]int, len(matrix))\nfor i := 0; i < len(matrix[0]); i++ {\n\tfor j := 0; j < len(matrix); j++ {\n\t\tres[j] = append(res[j], matrix[j][i])\n\t}\n}\nreturn res\n}"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := SumRevLLNum(tc.first, tc.second); !equal(result, tc.sum) {\n\t\tt.Errorf(\"STR\",\n\t\t\ttcid, String(result), String(tc.sum))\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SumRevLLNum(tc.input); !equal(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.input, result, tc.expected)\n\t}\n}\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tm: 3,\n\t\tn: 3,\n\t\tops: [][]int{\n\t\t\t{2, 2},\n\t\t\t{3, 3},\n\t\t},\n\t\twant: 4,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxCount(tt.m, tt.n, tt.ops)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.m, got, tt.want)\n\t}\n}", "gen": "qs := []question598{\n\t{\n\t\tpara1: []int{2, 2, 3, 3},\n\t\tpara2: 2,\n\t\tans:   2,\n\t},\n\t{\n\t\tpara1: []int{2, 2, 3, 3},\n\t\tpara2: 3,\n\t\tans:   3,\n\t},\n\t{\n\t\tpara1: []int{2, 2, 3, 3},\n\t\tpara2: 4,\n\t\tans:   2,\n\t},\n}\nfmt.Printf(\"STR\" +\n\t\"\")\nfor _, q := range qs {\n\t_, p, _ := q.ans, q.para1, q.para2\n\tfmt.Printf(\"STR\" +\n\t\t\"\")\n}\n}"}
{"tgt": "n := len(quality)\nworkers := make([][2]float64, n)\nfor i := 0; i < n; i++ {\n\tw, q := float64(wage[i]), float64(quality[i])\n\tworkers[i][0], workers[i][1] = w/q, q\n}\nsort.Slice(workers, func(i, j int) bool {\n\treturn workers[i][0] < workers[j][0]\n})\nres := math.MaxFloat64\nsum := 0.\nh := floatHeap{}\nfor _, w := range workers {\n\tsum += w[1]\n\theap.Push(&h, w[1])\n\tif len(h) > K {\n\t\tsum -= heap.Pop(&h).(float64)\n\t}\n\tif len(h) == K {\n\t\tres = min(res, sum*w[0])\n\t}\n}\nreturn res", "gen": "n := len(cost)\ndp := make([]float64, n)\nfor i := 0; i < n; i++ {\n\tdp[i] = float64(cost[i]) / float64(cost[i]+cost[n-1])\n}\nsort.Slice(dp, func(i, j int) bool {\n\treturn dp[i] < dp[j]\n})\nmin := math.Inf(1)\nh := &floatHeap{\n\tdata: dp,\n}\nheap.Init(h)\nfor h.Len() < k {\n\tmin += heap.Pop(h).(float64)\n\theap.Push(h, min)\n}\nreturn min\n}"}
{"tgt": "flag.Parse()\nroots := flag.Args()\nif len(roots) == 0 {\n\troots = []string{\"STR\"}\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, root := range roots {\n\t\twalkDir(root, fileSizes)\n\t}\n\tclose(fileSizes)\n}()\nvar nfiles, nbytes int64\nfor size := range fileSizes {\n\tnfiles++\n\tnbytes += size\n}\nprintDiskUsage(nfiles, nbytes)", "gen": "flag.Parse()\nargs := flag.Args()\nif len(args) == 0 {\n\targs = []string{\"./\"}\n}\nch := make(chan int64)\ngo main.roots1(args, ch)\nvar total int64\nfor {\n\tsize, ok := <-ch\n\tif !ok {\n\t\tbreak\n\t}\n\ttotal += size\n}\nprintDiskUsage(total, len(args))\n}"}
{"tgt": "var min int\ntotalPeople := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\ttotalPeople++\n\t}\n}\nif totalPeople < 2 {\n\treturn 0\n}\nmiddle := (totalPeople / 2) + (totalPeople % 2)\nindex := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\tmiddle--\n\t}\n\tif middle == 0 {\n\t\tindex = i\n\t\tbreak\n\t}\n}\nleftZero := 0\nleftZeroFound := false\nfor j := index - 1; j >= 0; j-- {\n\tif !leftZeroFound && seating[j] == 0 {\n\t\tleftZero = j\n\t\tleftZeroFound = true\n\t} else if seating[j] == 1 && j < leftZero {\n\t\tmin += abs(j - leftZero)\n\t\tleftZero--\n\t}\n}\nrightZero := 0\nrightZeroFound := false\nfor j := index + 1; j < len(seating); j++ {\n\tif !rightZeroFound && seating[j] == 0 {\n\t\trightZero = j\n\t\trightZeroFound = true\n\t} else if seating[j] == 1 && j > rightZero {\n\t\tmin += abs(j - rightZero)\n\t\trightZero++\n\t}\n}\nreturn min", "gen": "var sum, count int\nfor _, n := range nums {\n\tif n == 1 {\n\t\tcount++\n\t}\n}\nif count == 0 {\n\treturn 0\n}\nvar i, j int\nfor i = 0; i < len(nums); i++ {\n\tif nums[i] == 1 {\n\t\tj = i\n\t\tbreak\n\t}\n}\nfor i < len(nums) {\n\tif nums[i] == 1 {\n\t\tsum++\n\t}\n\ti++\n}\nfor i < len(nums) {\n\tif nums[i] == 1 {\n\t\tsum++\n\t}\n\ti++\n}\nreturn sum\n}"}
{"tgt": "sum := 0\nprev := 1\ncurr := 1\nfor curr <= 4e6 {\n\tprev, curr = curr, prev+curr\n\tif curr%2 == 0 {\n\t\tsum += curr\n\t}\n}\nfmt.Println(sum)", "gen": "sum := 0\nfor i := 1; i < 4000000; i++ {\n\tif i%2 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "stack := make([]int, 0)\nresult := make([]int, len(T))\nfor i, t := range T {\n\tfor len(stack) > 0 && T[stack[len(stack)-1]] < t {\n\t\tresult[stack[len(stack)-1]] = i - stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t}\n\tstack = append(stack, i)\n}\nfor _, i := range stack {\n\tresult[i] = 0\n}\nreturn result", "gen": "res := make([]int, 0, len(nums))\nfor _, num := range nums {\n\tif len(res) == 0 || res[len(res)-1] < num {\n\t\tres = append(res, num)\n\t} else {\n\t\tres[len(res)-1] = num\n\t}\n}\nfor i := 0; i < len(res); i++ {\n\tres[i] = 0\n}\nreturn res\n}"}
{"tgt": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 2}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 4}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}, {4, 4}}},\n\t\tans1037{false},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "out := 100\nif x := p33(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "if p33(100) != 100 {\n\tt.Errorf(\"STR\", 100, p33(100))\n}\n}"}
