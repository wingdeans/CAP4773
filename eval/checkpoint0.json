{"tgt": "fmt.Println(mostCommonWord(\"STR\", []string{\"STR\", \"STR\"}))", "gen": "fmt.Println(mostCommonWord(\"Bob hit a ball, the hit ball ran up the grass. So hit the ball with the bat.\"))\n}\n"}
{"tgt": "if nil == nums || len(nums) == 0 {\n\treturn\n}\ninsertPos := 0\nfor _, values := range nums {\n\tif 0 != values {\n\t\tnums[insertPos] = values\n\t\tinsertPos++\n\t}\n}\nfor insertPos < len(nums) {\n\tnums[insertPos] = 0\n\tinsertPos++\n}", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname __morestack runtime.morestack"}
{"tgt": "cases := []struct {\n\ta, b, expected int\n}{\n\t{\n\t\ta:        0,\n\t\tb:        0,\n\t\texpected: 0,\n\t},\n\t{\n\t\ta:        1,\n\t\tb:        1,\n\t\texpected: 1,\n\t},\n\t{\n\t\ta:        -1,\n\t\tb:        1,\n\t\texpected: -1,\n\t},\n\t{\n\t\ta:        1,\n\t\tb:        -1,\n\t\texpected: -1,\n\t},\n\t{\n\t\ta:        10,\n\t\tb:        2,\n\t\texpected: 2,\n\t},\n}\nfor _, c := range cases {\n\tactual := Min(c.a, c.b)\n\tif actual != c.expected {\n\t\tt.Errorf(\"STR\", c.expected, actual)\n\t}\n}", "gen": "var a [3]int\na[0] = 1\na[1] = 1\na[2] = 1\nvar b [3]int\nb[0] = 1\nb[1] = 1\nb[2] = 1\nvar c [3]int\nc[0] = 1\nc[1] = 1\nc[2] = 1\nvar d [3]int\nd[0] = 1\nd[1] = 1\nd[2] = 1\nvar e [3]int\ne[0] = 1\ne[1] = 1\ne[2] = 1\nvar f [3]int\nf[0] = 1\nf[1] = 1\nf[2] = 1\nvar g [3]int\ng[0] = 1\ng[1] = 1\ng[2] = 1\nvar h [3]int\nh[0] = 1\nh[1] = 1\nh[2] = 1\nvar i [3]int\ni[0] = 1\ni[1] = 1\ni[2] = 1\nvar j [3]int\nj[0] = 1\nj[1] = 1\nj[2] = 1\nvar k [3]int\nk[0] = 1\nk[1] = 1\nk[2] = 1\nvar l [3]int\nl[0] = 1\nl[1] = 1\nl[2] = 1\nvar m [3]int\nm[0] = 1\nm[1] = 1\nm[2] = 1\nvar n [3]int\nn[0] = 1\nn[1] = 1\nn[2] = 1\nvar o [3]int\no"}
{"tgt": "ma := 0\nif len(heights) < 0 {\n\treturn 0\n}\nvar stack []int\nfor i := 0; i < len(heights); i++ {\n\tif i == 0 {\n\t\tstack = append(stack, heights[i])\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tcontinue\n\t}\n\tif heights[i-1] > heights[i] {\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tstack = changeStack(stack, heights[i])\n\t}\n\tstack = append(stack, heights[i])\n\tif i+1 == len(heights) {\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tcontinue\n\t}\n}\nreturn ma", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "min := func(a, b int) int {\n\treturn int(math.Min(float64(a), float64(b)))\n}\ndp := make([]int, 2)\ndp[0], dp[1] = cost[0], cost[1]\nfor i := 2; i < len(cost); i++ {\n\tdp[i%2] = cost[i] + min(dp[0], dp[1])\n}\nreturn min(dp[0], dp[1])", "gen": "fmt.Println(minCostClimbingStairs([]int{1, 100, 1, 1, 1, 100, 1, 1, 100, 1}))\n}\n"}
{"tgt": "temp, mask := num, 0\nfor temp > 0 {\n\tmask = mask*2 + 1\n\ttemp /= 2\n}\nreturn mask ^ num", "gen": "var a int\nvar b int\na = 1\nb = 2\nc := a + b\nfmt.Println(c)\n}\n"}
{"tgt": "listNode1 := &ListNode{\n\tVal: 4,\n\tNext: &ListNode{\n\t\tVal: 1,\n\t\tNext: &ListNode{\n\t\t\tVal:  4,\n\t\t\tNext: nil,\n\t\t},\n\t},\n}\nlistNode2 := &ListNode{\n\tVal: 1,\n\tNext: &ListNode{\n\t\tVal: 8,\n\t\tNext: &ListNode{\n\t\t\tVal:  4,\n\t\t\tNext: nil,\n\t\t},\n\t},\n}\ngetIntersectionNode(listNode1, listNode2)", "gen": "fmt.Println(getIntersectionNode([]int{4, 1, 2}, []int{1, 3, 4, 2}))\n}\n"}
{"tgt": "switch {\ncase isIPv4(IP):\n\treturn \"STR\"\ncase isIPv6(IP):\n\treturn \"STR\"\ndefault:\n\treturn \"STR\"\n}", "gen": "fmt.Println(isIPv4(\"192.168.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1"}
{"tgt": "l := len(preorder)\nif l == 0 {\n\treturn nil\n}\nfor 1 < l && preorder[0] < preorder[l-1] {\n\tl--\n}\nreturn &TreeNode{\n\tVal:   preorder[0],\n\tLeft:  bstFromPreorder(preorder[1:l]),\n\tRight: bstFromPreorder(preorder[l:]),\n}", "gen": "var preorder = []int{3, 9, 20, 15, 7}\nvar inorder = []int{9, 3, 15, 20, 7}\nroot := bstFromPreorder(preorder, inorder)\nfmt.Println(root)\n}\n"}
{"tgt": "sort.Slice(costs, func(i, j int) bool {\n\treturn abs(costs[i][0]-costs[i][1]) > abs(costs[j][0]-costs[j][1])\n})\ncost, a, b, n := 0, 0, 0, len(costs)/2\nfor _, c := range costs {\n\tif (c[0] < c[1] && a < n) || b == n {\n\t\tcost += c[0]\n\t\ta++\n\t} else {\n\t\tcost += c[1]\n\t\tb++\n\t}\n}\nreturn cost", "gen": "fmt.Println(twoCitySchedCost([]int{10, 20, 30, 40, 50, 60, 70, 80, 90, 100}, []int{10, 20, 30, 40, 50, 60, 70, 80, 90, 100}))\n}\n"}
{"tgt": "println(\"STR\")\nprintln(\"STR\", v1)\nprintln(\"STR\", v2.x, v2.y)\nprintln(\"STR\", len(v3), cap(v3), v3[0], v3[3])\nprintln(\"STR\", len(v4), v4 == nil)\nprintln(\"STR\", len(v5), v5 == nil)\nprintln(\"STR\", v6)\nprintln(\"STR\", cap(v7), string(v7))\nprintln(uint8SliceSrc[0])\nprintln(uint8SliceDst[0])\nprintln(intSliceSrc[0])\nprintln(intSliceDst[0])", "gen": "var v1 [3]int\nvar v2 [3]int\nvar v3 [3]int\nvar v4 *[3]int\nvar v5 *[3]int\nvar v6 bool\nvar v7 [3]int\nvar uint8SliceSrc []byte\nvar uint8SliceDst []byte\nvar intSliceSrc []int\nvar intSliceDst []int\nvar v8 int\nvar v9 int\nvar v10 int\nvar v11 int\nvar v12 int\nvar v13 int\nvar v14 int\nvar v15 int\nvar v16 int\nvar v17 int\nvar v18 int\nvar v19 int\nvar v20 int\nvar v21 int\nvar v22 int\nvar v23 int\nvar v24 int\nvar v25 int\nvar v26 int\nvar v27 int\nvar v28 int\nvar v29 int\nvar v30 int\nvar v31 int\nvar v32 int\nvar v33 int\nvar v34 int\nvar v35 int\nvar v36 int\nvar v37 int\nvar v38 int\nvar v39 int\nvar v40 int\nvar v41 int\nvar v42 int\nvar v43 int\nvar v44 int\nvar v45 int\nvar v46 int\nvar v47 int\nvar v48 int\nvar v49 int\nvar v50 int\nvar v51 int\nvar v52 int\nvar v53 int\nvar v54 int\nvar v55 int\nvar v56 int\nvar v57 int\nvar v58 int\nvar v59 int\nvar v60 int\nvar v61 int\nvar v62 int\nvar v63 int\nvar v64 int"}
{"tgt": "words := strings.Fields(s)\nreturn strings.Join(reverseSlice(words), \"STR\")", "gen": "fmt.Println(reverse(\"hello world\"))\n}\n\n// Output:\n// dlrow olleh\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```asm\n.text\n.globl main\nmain:\npushq %rbp\nmovq %rsp, %rbp\nsubq $16, %rsp\nmovq $0, %rax\nmovq $0, %rdx\nmovq %rax, -8(%rbp)\nmovq %rdx, -16(%rbp)\nmovq $0, -16(%rbp)\nmovq $0, -24(%rbp)\nleaq -16(%rbp), %rax\nmovq -8(%rbp), %rcx\nmovq -16(%rbp), %rdx\nmovq %rcx, %rsi\nmovq %rax, %rdi\ncall <strings.Fields@PLT>\nleaq -8(%rbp), %rax\nsubq $8, %rsp\npushq -24(%rbp)\npushq -32(%rbp)\npushq -40(%rbp)\nmovq %rax, %rdi\ncall <go.Solution.reverseSlice>\naddq $32, %rsp\nleaq .LC23(%rip), %r12\nmovl $1, %r13d\nmovq %r12, %rcx\nmovq %r13, %rbx\nmovq %r12, %rax\nmovq %r13, %rdx\nmovq %rdx, %rax\nsubq $8, %rsp\npushq -48(%rbp)\npushq -56(%rbp)\npushq -64(%rbp)\nmovq %rcx, %rdi\nmovq %rax, %rsi\ncall <strings.Join@PLT>\naddq $32, %r"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect bool\n}{\n\t{\"STR\", []int{1, 2, 2, 3}, true},\n\t{\"STR\", []int{4, 3, 3, 2}, true},\n\t{\"STR\", []int{1, 3, 2}, false},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "indexs := make([]int, 123)\nfor i, c := range order {\n\tindexs[c] = i\n}\nless := func(i, j int) bool {\n\tsi, sj := len(words[i]), len(words[j])\n\tfor k := 0; k < si && k < sj; k++ {\n\t\tii, ij := indexs[words[i][k]], indexs[words[j][k]]\n\t\tswitch {\n\t\tcase ii < ij:\n\t\t\treturn true\n\t\tcase ii > ij:\n\t\t\treturn false\n\t\t}\n\t}\n\treturn si <= sj\n}\nfor i := 1; i < len(words); i++ {\n\tif !less(i-1, i) {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var s []rune\nvar t []rune\nvar res bool\ns = []rune{'a', 'b', 'c'}\nt = []rune{'a', 'b', 'c'}\nres = isAlienSorted(s, t)\nfmt.Println(res)\n}\n"}
{"tgt": "row := len(grid)\ncol := len(grid[0])\ndp := make([][]int, row)\nfor i := 0; i < row; i++ {\n\tdp[i] = make([]int, col)\n}\ndp[0][0] = grid[0][0]\nfor i := 1; i < row; i++ {\n\tdp[i][0] = dp[i-1][0] + grid[i][0]\n}\nfor i := 1; i < col; i++ {\n\tdp[0][i] = dp[0][i-1] + grid[0][i]\n}\nfor i := 1; i < row; i++ {\n\tfor j := 1; j < col; j++ {\n\t\tdp[i][j] = Min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\t}\n}\nreturn dp[row-1][col-1]", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar bb [3]int\nvar cc [3]int\nvar dd [3]int\nvar ee [3]int\nvar ff [3]int\nvar gg [3]int\nvar hh [3]int\nvar ii [3]int\nvar jj [3]int\nvar kk [3]int\nvar ll [3]int\nvar mm [3]int\nvar nn [3]int\nvar oo [3]int\nvar pp [3]int\nvar qq [3]int\nvar rr [3]int\nvar ss [3]int\nvar tt [3]int\nvar uu [3]int\nvar vv [3]int\nvar ww [3]int\nvar xx [3]int\nvar yy [3]int\nvar zz [3]int\nvar aaa [3]int\nvar bbb [3]int\nvar ccc [3]int\nvar ddd [3]int\nvar eee [3]int\nvar fff [3]int\nvar ggg [3]int\nvar hhh [3]"}
{"tgt": "fmt.Fprint(w, \"STR\")", "gen": "var a int\nvar b int\nvar c int\nfmt.Println(a, b, c)\n}\n"}
{"tgt": "l := len(nums)\nk %= l\ns := make([]int, l)\ncopy(s, nums)\nfor i, v := range s[l-k:] {\n\tnums[i] = v\n}\nfor i, v := range s[:l-k] {\n\tnums[k+i] = v\n}", "gen": "var a [10]int\nvar b [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] / b[i]\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if p == nil || q == nil {\n\treturn p == q\n}\nreturn isSameTree(p.Left, q.Left) && p.Val == q.Val && isSameTree(p.Right, q.Right)", "gen": "fmt.Println(isSameTree(nil, nil))\nfmt.Println(isSameTree(nil, &TreeNode{Val: 1}))\nfmt.Println(isSameTree(&TreeNode{Val: 1}, nil))\nfmt.Println(isSameTree(&TreeNode{Val: 1}, &TreeNode{Val: 1}))\nfmt.Println(isSameTree(&TreeNode{Val: 1}, &TreeNode{Val: 2}))\nfmt.Println(isSameTree(&TreeNode{Val: 1, Left: &TreeNode{Val: 2}}, &TreeNode{Val: 1, Right: &TreeNode{Val: 2}}))\nfmt.Println(isSameTree(&TreeNode{Val: 1, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 3}}}, &TreeNode{Val: 1, Right: &TreeNode{Val: 2, Right: &TreeNode{Val: 3}}}))\nfmt.Println(isSameTree(&TreeNode{Val: 1, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 3}}}, &TreeNode{Val: 1, Right: &TreeNode{Val: 2, Right: &TreeNode{Val: 4}}}))\nfmt.Println(isSameTree(&TreeNode{Val: 1, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 3}}}, &TreeNode{Val: 1, Right: &TreeNode{Val: 2, Right: &TreeNode{Val: 4, Left: &TreeNode{Val: 5}}})))\nfmt.Println(isSameTree(&TreeNode{Val: 1, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 3}}}, &TreeNode{Val: 1, Right: &TreeNode{Val: 2, Right: &TreeNode{Val: 4, Right: &TreeNode{Val: 5}}})))\nfmt.Println(is"}
{"tgt": "for cur := t.root; cur != nil; {\n\tif cur.Key == key {\n\t\treturn cur\n\t} else if key < cur.Key {\n\t\tcur = cur.left\n\t} else {\n\t\tcur = cur.right\n\t}\n}\nreturn nil", "gen": "var bst *binaryTree.BST\nbst = binaryTree.NewBST()\nbst.Insert(10)\nbst.Insert(20)\nbst.Insert(30)\nbst.Insert(40)\nbst.Insert(50)\nbst.Insert(60)\nbst.Insert(70)\nbst.Insert(80)\nbst.Insert(90)\nbst.Insert(100)\nbst.Insert(110)\nbst.Insert(120)\nbst.Insert(130)\nbst.Insert(140)\nbst.Insert(150)\nbst.Insert(160)\nbst.Insert(170)\nbst.Insert(180)\nbst.Insert(190)\nbst.Insert(200)\nbst.Insert(210)\nbst.Insert(220)\nbst.Insert(230)\nbst.Insert(240)\nbst.Insert(250)\nbst.Insert(260)\nbst.Insert(270)\nbst.Insert(280)\nbst.Insert(290)\nbst.Insert(300)\nbst.Insert(310)\nbst.Insert(320)\nbst.Insert(330)\nbst.Insert(340)\nbst.Insert(350)\nbst.Insert(360)\nbst.Insert(370)\nbst.Insert(380)\nbst.Insert(390)\nbst.Insert(400)\nbst.Insert(410)\nbst.Insert(420)\nbst.Insert(430)\nbst.Insert(440)\nbst.Insert(450)\nbst.Insert(460)\nbst.Insert(470)\nbst.Insert(480)\nbst.Insert(49"}
{"tgt": "s := []int{}\nfor _, asteroid := range asteroids {\n\tfor len(s) != 0 && s[len(s)-1] > 0 && s[len(s)-1] < -asteroid {\n\t\ts = s[:len(s)-1]\n\t}\n\tif len(s) == 0 || asteroid > 0 || s[len(s)-1] < 0 {\n\t\ts = append(s, asteroid)\n\t} else if asteroid < 0 && s[len(s)-1] == -asteroid {\n\t\ts = s[:len(s)-1]\n\t}\n}\nreturn s", "gen": "var a [3]int\nvar b [4]int\na[2] = 1\nb[3] = 1\na[2] = b[3]\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "sum := 0\nsunday := 5\nyear := 1901\nis_leap := false\nfor year < 2001 {\n\tchecker := month_len\n\tif is_leap {\n\t\tchecker = leap_len\n\t}\n\ttally := sunday\n\tfor _, v := range checker {\n\t\tif tally == 0 {\n\t\t\tsum += 1\n\t\t}\n\t\tif tally < v {\n\t\t\tbreak\n\t\t}\n\t\tif tally >= v {\n\t\t\ttally -= v\n\t\t}\n\t}\n\tsunday += 7\n\tif is_leap && sunday >= 366 {\n\t\tyear++\n\t\tsunday = sunday % 366\n\t\tis_leap = false\n\t} else if !is_leap && sunday >= 365 {\n\t\tyear++\n\t\tsunday = sunday % 365\n\t\tif year%4 == 0 {\n\t\t\tis_leap = true\n\t\t}\n\t}\n}\nfmt.Printf(\"STR\", year, sum)", "gen": "var month_len [12]int\nvar leap_len [12]int\nmonth_len[0] = 31\nmonth_len[1] = 28\nmonth_len[2] = 31\nmonth_len[3] = 30\nmonth_len[4] = 31\nmonth_len[5] = 30\nmonth_len[6] = 31\nmonth_len[7] = 31\nmonth_len[8] = 30\nmonth_len[9] = 31\nmonth_len[10] = 30\nmonth_len[11] = 31\nleap_len[0] = 31\nleap_len[1] = 29\nleap_len[2] = 31\nleap_len[3] = 30\nleap_len[4] = 31\nleap_len[5] = 30\nleap_len[6] = 31\nleap_len[7] = 31\nleap_len[8] = 30\nleap_len[9] = 31\nleap_len[10] = 30\nleap_len[11] = 31\nvar month int\nvar year int\nfmt.Scanf(\"%d %d\", &month, &year)\nvar day int\nday = 0\nfor i := 0; i < month; i++ {\n\tif i == 1 {\n\t\tif year%4 == 0 {\n\t\t\tday += leap_len[i]\n\t\t} else {\n\t\t\tday += month_len[i]\n\t\t}\n\t} else {\n\t\tday += month_len[i]\n\t}\n}\nfmt.Printf(\"%d\\n\", day)\n}\n"}
{"tgt": "max, winner := 0, 0\nfor i := 1; i < 1000000; i++ {\n\tterms := collatz(i)\n\tif terms > max {\n\t\tmax = terms\n\t\twinner = i\n\t}\n}\nfmt.Println(\"STR\", max, \"STR\", winner)", "gen": "var a int\nvar b int\nfmt.Scan(&a)\nfmt.Scan(&b)\nvar c int\nc = collatz(a)\nif c > b {\n\tfmt.Println(\"a\")\n} else {\n\tfmt.Println(\"b\")\n}\n}"}
{"tgt": "return fmt.Sprintf(\"STR\", c.FirstName, c.LastName, c.Email)", "gen": "var s string\ns = \"hello\"\nfmt.Println(s)\n}\n\n// 0000000000000000 <main>:\n// \t.file\t\"main.go\"\n// \t.text\n// \t.globl\tmain\n// \t.type\tmain, @function\n// main:\n// \t.cfi_startproc\n// \t.cfi_personality 0x3,__gxx_personality_v0\n// \t.cfi_lsda 0x3,.LLSDA0\n// \t.cfi_loc 1 1 0\n// \t.cfi_adjust_cfa_offset 48\n// \t.cfi_offset 15, -48\n// \t.cfi_offset 14, -40\n// \t.cfi_offset 13, -32\n// \t.cfi_offset 12, -24\n// \t.cfi_offset 11, -16\n// \t.cfi_offset 10, -8\n// \t.cfi_offset 9, -8\n// \t.cfi_offset 8, -8\n// \t.cfi_offset 7, -8\n// \t.cfi_offset 6, -8\n// \t.cfi_offset 5, -8\n// \t.cfi_offset 4, -8\n// \t.cfi_offset 3, -8\n// \t.cfi_offset 2, -8\n// \t.cfi_offset 1, -8\n// \t.cfi_offset 0, -8\n// \t.loc 1 1 0\n// \t.cfi_loc 1 1 0 is_stmt 1\n// \tpushq\t%rbp\n// \t.cfi_def_cfa_offset 16\n// \t.cfi_offset 6, -16\n// \tmovq\t%rsp, %rbp\n// \t"}
{"tgt": "e.lgu = lgu\ne.mixin = mixin\ne.cluster = make(map[interface{}]*rsVEBTreeElement)\nif e.lgu > 1 {\n\te.summaryLgu = (e.lgu + 1) / 2\n\te.clusterLgu = e.lgu - e.summaryLgu\n\te.summary = new(rsVEBTreeElement).init(e.summaryLgu, e.mixin)\n} else {\n\te.summaryLgu = 0\n\te.clusterLgu = 0\n}\nreturn e", "gen": "var m map[int]int\nm = make(map[int]int)\nm[1] = 1\nm[2] = 2\nm[3] = 3\nm[4] = 4\nm[5] = 5\nm[6] = 6\nm[7] = 7\nm[8] = 8\nm[9] = 9\nm[10] = 10\nm[11] = 11\nm[12] = 12\nm[13] = 13\nm[14] = 14\nm[15] = 15\nm[16] = 16\nm[17] = 17\nm[18] = 18\nm[19] = 19\nm[20] = 20\nm[21] = 21\nm[22] = 22\nm[23] = 23\nm[24] = 24\nm[25] = 25\nm[26] = 26\nm[27] = 27\nm[28] = 28\nm[29] = 29\nm[30] = 30\nm[31] = 31\nm[32] = 32\nm[33] = 33\nm[34] = 34\nm[35] = 35\nm[36] = 36\nm[37] = 37\nm[38] = 38\nm[39] = 39\nm[40] = 40\nm[41] = 41\nm[42] = 42\nm[43] = 43\nm[44] = 44\nm[45] = 45\nm"}
{"tgt": "if isValid := checkHorizontal(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkVertical(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkReachable(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkRotationallySymmetric(puzzle); !isValid {\n\treturn false\n}\nreturn true", "gen": "fmt.Println(checkHorizontal(1, 2, 3, 4, 5))\nfmt.Println(checkVertical(1, 2, 3, 4, 5))\nfmt.Println(checkReachable(1, 2, 3, 4, 5))\nfmt.Println(checkRotationallySymmetric(1, 2, 3, 4, 5))\nfmt.Println(check(1, 2, 3, 4, 5))\n}\n"}
{"tgt": "b.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := SumRevLLNum(tc.first, tc.second); !equal(result, tc.sum) {\n\t\tt.Errorf(\"STR\",\n\t\t\ttcid, String(result), String(tc.sum))\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA `structs:\"STR\"`\n\tC  int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif ok {\n\tt.Error(\"STR\")\n}", "gen": "var t TestHasZero_OmitNested\nt.A = 1\nt.B.i1 = 2\nt.B.i2 = 3\nt.B.d = 4\nt.B.i3 = 5\nt.B.i4 = 6\nt.B.i5 = 7\nt.B.i6 = 8\nt.B.i7 = 9\nt.B.i8 = 10\nt.B.i9 = 11\nt.B.i10 = 12\nt.B.i11 = 13\nt.B.i12 = 14\nt.B.i13 = 15\nt.B.i14 = 16\nt.B.i15 = 17\nt.B.i16 = 18\nt.B.i17 = 19\nt.B.i18 = 20\nt.B.i19 = 21\nt.B.i20 = 22\nt.B.i21 = 23\nt.B.i22 = 24\nt.B.i23 = 25\nt.B.i24 = 26\nt.B.i25 = 27\nt.B.i26 = 28\nt.B.i27 = 29\nt.B.i28 = 30\nt.B.i29 = 31\nt.B.i30 = 32\nt.B.i31 = 33\nt.B.i32 = 34\nt.B.i33 = 35\nt.B.i34 = 36\nt.B.i35 = 37\nt.B.i36 = 38\nt.B.i37 = 39\nt.B."}
{"tgt": "nums := []int{1, 1, 2, 2, 3, 3}\nfmt.Println(distributeCandies(nums))\nnums2 := []int{1, 1, 2, 3}\nfmt.Println(distributeCandies(nums2))", "gen": "distributeCandies(1, 1, 2, 2, 3, 3)\ndistributeCandies(1, 1, 2, 2, 3, 3)\n}\n"}
{"tgt": "i, j := start, len(nums)-1\nfor i < j {\n\tnums[i], nums[j] = nums[j], nums[i]\n\ti++\n\tj--\n}", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "var val int\nfor n := uint(0); num != 0; num >>= 1 {\n\tval |= (1 - (num & 1)) << n\n\tn++\n}\nreturn val", "gen": "var x uint64 = 1\nvar y uint64 = 1\nfor i := uint64(0); i < 63; i++ {\n\tx = x & 1\n\ty = y << 1\n\tif x == y {\n\t\tbreak\n\t}\n}\nprintln(x)\n}\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000001\n\n// 0x0000000000000"}
{"tgt": "size := len(A)\nres := make([]int, size)\neven, odd := 0, 1\nfor _, a := range A {\n\tif a%2 == 0 {\n\t\tres[even] = a\n\t\teven += 2\n\t} else {\n\t\tres[odd] = a\n\t\todd += 2\n\t}\n}\nreturn res", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nfor i := 0; i < len(a); i++ {\n\ta[i] *= 2\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "slow, fast := head, head\nfor fast != nil && fast.Next != nil {\n\tslow = slow.Next\n\tfast = fast.Next.Next\n}\nvar prev *ListNode\nfor slow != nil {\n\tnext := slow.Next\n\tslow.Next = prev\n\tprev, slow = slow, next\n}\nfor p, q := head, prev; p != q; p, q = q, p {\n\tnext := p.Next\n\tp.Next = q\n\tp = next\n}", "gen": "var x, y *int\nx = new(int)\ny = new(int)\n*x = 1\n*y = 2\nruntime.GC()\n*x = 3\n*y = 4\nruntime.GC()\n*x = 5\n*y = 6\nruntime.GC()\n*x = 7\n*y = 8\nruntime.GC()\n*x = 9\n*y = 10\nruntime.GC()\n*x = 11\n*y = 12\nruntime.GC()\n*x = 13\n*y = 14\nruntime.GC()\n*x = 15\n*y = 16\nruntime.GC()\n*x = 17\n*y = 18\nruntime.GC()\n*x = 19\n*y = 20\nruntime.GC()\n*x = 21\n*y = 22\nruntime.GC()\n*x = 23\n*y = 24\nruntime.GC()\n*x = 25\n*y = 26\nruntime.GC()\n*x = 27\n*y = 28\nruntime.GC()\n*x = 29\n*y = 30\nruntime.GC()\n*x = 31\n*y = 32\nruntime.GC()\n*x = 33\n*y = 34\nruntime.GC()\n*x = 35\n*y = 36\nruntime.GC()\n*x = 37\n*y = 38\nruntime.GC()\n*x = 39\n*y = 40\nruntime.GC()\n*x = 41\n*y = 42\nruntime.GC()\n*x = 43\n*y = 44\nruntime.GC()\n"}
{"tgt": "for _, p := range perm6([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) {\n\tvalid := true\n\tfor _, g := range guesses {\n\t\tvar count int\n\t\tfor i := 0; i < len(p); i++ {\n\t\t\tif p[i] == g.Code[i] {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\tif count != g.Score {\n\t\t\tvalid = false\n\t\t\tbreak\n\t\t}\n\t}\n\tif valid {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "for i := 0; i < 100000; i++ {\n\tif i%300 == 0 {\n\t\tarray := GetArrayOfSize(i)\n\t\tif len(array) != i {\n\t\t\tfmt.Println(array)\n\t\t\tt.Error()\n\t\t}\n\t}\n}", "gen": "var a [1000000]int\nvar b [1000000]int\nvar c [1000000]int\nvar d [1000000]int\nvar e [1000000]int\nvar f [1000000]int\nvar g [1000000]int\nvar h [1000000]int\nvar i [1000000]int\nvar j [1000000]int\nvar k [1000000]int\nvar l [1000000]int\nvar m [1000000]int\nvar n [1000000]int\nvar o [1000000]int\nvar p [1000000]int\nvar q [1000000]int\nvar r [1000000]int\nvar s [1000000]int\nvar t [1000000]int\nvar u [1000000]int\nvar v [1000000]int\nvar w [1000000]int\nvar x [1000000]int\nvar y [1000000]int\nvar z [1000000]int\nvar aa [1000000]int\nvar bb [1000000]int\nvar cc [1000000]int\nvar dd [1000000]int\nvar ee [1000000]int\nvar ff [1000000]int\nvar gg [1000000]int\nvar hh [1000000]int\nvar ii [1000000]int\nvar jj [10"}
{"tgt": "parent := this\nfor _, ch := range prefix {\n\tif child, ok := parent.Children[ch]; ok {\n\t\tparent = child\n\t\tcontinue\n\t}\n\treturn false\n}\nreturn true", "gen": "var s Solution\ns.Trie = make(map[int]map[int]int)\ns.Insert(\"apple\")\ns.Insert(\"app\")\ns.Insert(\"ap\")\ns.Insert(\"a\")\ns.Insert(\"banana\")\ns.Insert(\"ban\")\ns.Insert(\"ba\")\ns.Insert(\"b\")\ns.Insert(\"ab\")\ns.Insert(\"aa\")\ns.Insert(\"aab\")\ns.Insert(\"aabac\")\ns.Insert(\"aabacd\")\ns.Insert(\"aabacdab\")\ns.Insert(\"aabacdabcd\")\ns.Insert(\"aabacdabcdab\")\ns.Insert(\"aabacdabcdabcd\")\ns.Insert(\"aabacdabcdabcdab\")\ns.Insert(\"aabacdabcdabcdabcd\")\ns.Insert(\"aabacdabcdabcdabcdab\")\ns.Insert(\"aabacdabcdabcdabcdabcd\")\ns.Insert(\"aabacdabcdabcdabcdabcdab\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcd\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdab\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdabcd\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdabcdab\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdabcdabcd\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdabcdabcdab\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdabcdabcdabcd\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdabcdabcdabcdab\")\ns.Insert(\"aabacdabcdabcdabcdabcdabcdabcdabcdabcd"}
{"tgt": "sema <- struct{}{}\nb := balance\n<-sema\nreturn b", "gen": "var wg sync.WaitGroup\nwg.Add(2)\ngo func() {\n\tdefer wg.Done()\n\tbank(100)\n}()\ngo func() {\n\tdefer wg.Done()\n\tbank(200)\n}()\nwg.Wait()\n}\n"}
{"tgt": "pairs := [...][2]int{{10, 7}, {1000, 983}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p26(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var p26 *int\nvar p27 *int\nvar p28 *int\nvar p29 *int\nvar p30 *int\nvar p31 *int\nvar p32 *int\nvar p33 *int\nvar p34 *int\nvar p35 *int\nvar p36 *int\nvar p37 *int\nvar p38 *int\nvar p39 *int\nvar p40 *int\nvar p41 *int\nvar p42 *int\nvar p43 *int\nvar p44 *int\nvar p45 *int\nvar p46 *int\nvar p47 *int\nvar p48 *int\nvar p49 *int\nvar p50 *int\nvar p51 *int\nvar p52 *int\nvar p53 *int\nvar p54 *int\nvar p55 *int\nvar p56 *int\nvar p57 *int\nvar p58 *int\nvar p59 *int\nvar p60 *int\nvar p61 *int\nvar p62 *int\nvar p63 *int\nvar p64 *int\nvar p65 *int\nvar p66 *int\nvar p67 *int\nvar p68 *int\nvar p69 *int\nvar p70 *int\nvar p71 *int\nvar p72 *int\nvar p73 *int\nvar p74 *int\nvar p75 *int\nvar p76 *int\nvar p77 *int\nvar p78 *int\nvar p79 *int\nvar p80 *int\nvar p81 *int\nvar p82 *int\nvar p83 *int\nvar p84 *int\nvar p85 *int\nvar p86 *int\nvar p87 *int\nvar p8"}
{"tgt": "for i := 0; i < n; i++ {\n\tif len(squares) != i {\n\t\tprintln(\"STR\", len(squares), \"STR\", i)\n\t}\n\tsquares[i] = i * i\n\tfor j := 0; j <= i; j++ {\n\t\tif v, ok := squares[j]; !ok || v != j*j {\n\t\t\tif !ok {\n\t\t\t\tprintln(\"STR\", j)\n\t\t\t} else {\n\t\t\t\tprintln(\"STR\", j, v)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "var m map[int][2]int\nfor i := 0; i < 10; i++ {\n\tm[i] = [2]int{i, i}\n}\nfor i := 0; i < 10; i++ {\n\tfmt.Printf(\"%d %d\\n\", i, m[i][0])\n}\n}\n\n// Output:\n// 0 0\n// 1 1\n// 2 2\n// 3 3\n// 4 4\n// 5 5\n// 6 6\n// 7 7\n// 8 8\n// 9 9\n\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```\n<ASM>\ncmpq %fs:112,%rsp\njnb .L55\nmovl $152,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL3:\nret\n.L55:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $104,%rsp\nmovq %rdi,-104(%rbp)\nmovq %rsi,-112(%rbp)\n.LBB39:\nmovq $0,-56(%rbp)\n.LBB40:\njmp .L36\n.L54:\n.LBB41:\nnop\n.LBE41:\n.LBB42:\n.LBB43:\ncmpq $0,-104(%rbp)\nje .L37\nmovq -104(%rbp),%rax\nmovq (%rax),%rax\njmp .L38\n.L37:\nmovl $0,%eax\n.L38:\ncmpq -56(%rbp),%rax\nje .L39\n.LBB44:\ncmpq $"}
{"tgt": "for _, word := range words {\n\tremainNum[word] = 0\n}\nfor _, word := range words {\n\tremainNum[word]++\n}\nreturn 0", "gen": "var m map[string]int\nm = make(map[string]int)\nm[\"a\"] = 1\nm[\"b\"] = 2\nm[\"c\"] = 3\nm[\"d\"] = 4\nm[\"e\"] = 5\nm[\"f\"] = 6\nm[\"g\"] = 7\nm[\"h\"] = 8\nm[\"i\"] = 9\nm[\"j\"] = 10\nm[\"k\"] = 11\nm[\"l\"] = 12\nm[\"m\"] = 13\nm[\"n\"] = 14\nm[\"o\"] = 15\nm[\"p\"] = 16\nm[\"q\"] = 17\nm[\"r\"] = 18\nm[\"s\"] = 19\nm[\"t\"] = 20\nm[\"u\"] = 21\nm[\"v\"] = 22\nm[\"w\"] = 23\nm[\"x\"] = 24\nm[\"y\"] = 25\nm[\"z\"] = 26\nm[\"aa\"] = 27\nm[\"bb\"] = 28\nm[\"cc\"] = 29\nm[\"dd\"] = 30\nm[\"ee\"] = 31\nm[\"ff\"] = 32\nm[\"gg\"] = 33\nm[\"hh\"] = 34\nm[\"ii\"] = 35\nm[\"jj\"] = 36\nm[\"kk\"] = 37\nm[\"ll\"] = 38\nm[\"mm\"] = 39\nm[\"nn\"] = 40\nm[\"oo\"] = 41\nm[\"pp\"] = 42\nm[\"qq\"] = 43\nm[\"rr\"] = 44\nm[\"ss\"] = 45\nm[\"tt\"] = 46\nm[\"uu\"] = 47\nm[\"vv\"] = 48\nm[\"ww\"]"}
{"tgt": "ad := admin{\n\tuser: user{\n\t\tname:  \"STR\",\n\t\temail: \"STR\",\n\t},\n\tlevel: \"STR\",\n}\nad.user.notify()\nad.notify()", "gen": "user := User{\n\tName: \"John\",\n\tAge:  20,\n}\nadmin := Admin{\n\tName: \"Jane\",\n\tAge:  30,\n}\nuser.notify()\nadmin.notify()\n}\n"}
{"tgt": "if !ok {\n\tpanic(\"STR\")\n}", "gen": "var x int\nx = 1\nif x == 0 {\n\tpanic(\"x is not zero\")\n}\n}\n\n// 0x0000000000000000 <main>:\n// 0000000000000000:\t55                   \tpush   %rbp\n// 0000000000000001:\t48 89 e5             \tmov    %rsp,%rbp\n// 0000000000000004:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// 0000000000000008:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// 000000000000000c:\t48 89 7d f0          \tmov    %rdx,-0x10(%rbp)\n// 0000000000000010:\t48 89 75 e8          \tmov    %rcx,-0x18(%rbp)\n// 0000000000000014:\t48 89 7d e0          \tmov    %rdi,-0x20(%rbp)\n// 0000000000000018:\t48 89 75 d8          \tmov    %rsi,-0x28(%rbp)\n// 000000000000001c:\t48 89 7d d0          \tmov    %rdx,-0x30(%rbp)\n// 0000000000000020:\t48 89 75 c8          \tmov    %rcx,-0x38(%"}
{"tgt": "sum := 0\nprev := 1\ncurr := 1\nfor curr <= 4e6 {\n\tprev, curr = curr, prev+curr\n\tif curr%2 == 0 {\n\t\tsum += curr\n\t}\n}\nfmt.Println(sum)", "gen": "var a int\nvar b int\nvar c int\na = 1\nb = 1\nc = 1\nfor i := 0; i < 4000000; i++ {\n\ta = a + b\n\tb = a + c\n\tc = b + a\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "dist := func(i int) int {\n\tx, y := points[i][0], points[i][1]\n\treturn x*x + y*y\n}\npartition := func(l, r int) int {\n\tpivot, pdist := l, dist(l)\n\tpoints[pivot], points[r] = points[r], points[pivot]\n\tdivider := l\n\tfor i := l; i < r; i++ {\n\t\tif dist(i) < pdist {\n\t\t\tpoints[i], points[divider] = points[divider], points[i]\n\t\t\tdivider++\n\t\t}\n\t}\n\tpoints[divider], points[r] = points[r], points[divider]\n\treturn divider\n}\nl, r := 0, len(points)-1\nfor l < r {\n\ti := partition(l, r)\n\tif i == K {\n\t\tbreak\n\t} else if i > K {\n\t\tr = i - 1\n\t} else {\n\t\tl = i + 1\n\t}\n}\nreturn points[:K]", "gen": "fmt.Println(kClosest([]int{1, 2, 3, 4, 5}, 4))\n}\n"}
{"tgt": "if c < 0 {\n\treturn false\n}\nl, r := 0, mySqrt(c)\nfor l <= r {\n\tcur := l*l + r*r\n\tif cur < c {\n\t\tl++\n\t} else if cur > c {\n\t\tr--\n\t} else {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "fmt.Println(mySqrt(8))\n}\n"}
{"tgt": "n := len(edges)\nparent := make([]int, n+1)\nfor i := 0; i < n; i++ {\n\tparent[i] = i\n}\nvar i int\nvar e []int\nfor i, e = range edges {\n\tf, t := e[0], e[1]\n\tpf := find(parent, f)\n\tpt := find(parent, t)\n\tif pf == pt {\n\t\tbreak\n\t}\n\tparent[pf] = pt\n}\nreturn edges[i]", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "var bin strings.Builder\nfor head != nil {\n\tbin.WriteString(strconv.Itoa(head.Val))\n\thead = head.Next\n}\ni, _ := strconv.ParseInt(bin.String(), 2, 64)\nreturn int(i)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\n"}
{"tgt": "if n == 0 {\n\treturn 0\n}\nreturn n/5 + trailingZeroes(n/5)", "gen": "fmt.Println(trailingZeroes(10))\n}\n"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tpuzzle := make([][]rune, len(tc.puzzle))\n\tfor i := range puzzle {\n\t\tpuzzle[i] = []rune(tc.puzzle[i])\n\t}\n\tif result := FindWordLD(puzzle, []rune(tc.target)); result != tc.expected {\n\t\tt.Errorf(\"STR\", tcid, tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "start := 0\nend := len(s) - 1\nfor start < end {\n\ts[start], s[end] = s[end], s[start]\n\tstart++\n\tend--\n}\nreturn s", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "if m == 0 {\n\treturn 1\n}\nswitch n {\ncase 1:\n\treturn 2\ncase 2:\n\tif m == 1 {\n\t\treturn 3\n\t}\n\treturn 4\ndefault:\n\tswitch m {\n\tcase 1:\n\t\treturn 4\n\tcase 2:\n\t\treturn 7\n\tdefault:\n\t\treturn 8\n\t}\n}", "gen": "var a, b int\na = 1\nb = 2\nvar c int\nc = 0\nswitch {\ncase a == 1:\n\tc = 1\ncase b == 2:\n\tc = 2\ncase a == 1 && b == 2:\n\tc = 3\ncase a == 1 || b == 2:\n\tc = 4\ncase a == 1 && b == 2 && c == 3:\n\tc = 7\ncase a == 1 || b == 2 && c == 3:\n\tc = 8\n}\nif c != 8 {\n\tpanic(\"bad\")\n}\n}\n\n// func main() {\n// \tvar a, b int\n// \ta = 1\n// \tb = 2\n// \tvar c int\n// \tc = 0\n// \tswitch {\n// \tcase a == 1:\n// \t\tc = 1\n// \tcase b == 2:\n// \t\tc = 2\n// \tcase a == 1 && b == 2:\n// \t\tc = 3\n// \tcase a == 1 || b == 2:\n// \t\tc = 4\n// \tcase a == 1 && b == 2 && c == 3:\n// \t\tc = 7\n// \tcase a == 1 || b == 2 && c == 3:\n// \t\tc = 8\n// \t}\n// \tif c != 8 {\n// \t\tpanic(\"bad\")\n// \t}\n// }\n\n// func main() {\n// \tvar a, b int\n// \ta = 1\n// \tb = 2\n// \tvar c int\n// \tc = 0\n// \tswitch {\n// \tcase a == 1:\n// \t\tc = 1\n// \tcase b == 2:\n// \t\tc = 2\n//"}
{"tgt": "last, n := 0, len(s)\nfor i := 1; i < n; i++ {\n\tif s[i-1] == s[i] {\n\t\tcontinue\n\t}\n\tfor l := 0; i+l < n; l++ {\n\t\tif s[last+l] < s[i+l] {\n\t\t\tlast = i\n\t\t\tbreak\n\t\t}\n\t\tif s[last+l] > s[i+l] {\n\t\t\tbreak\n\t\t}\n\t}\n}\nreturn s[last:]", "gen": "var a [10]byte\nvar b [10]byte\nvar c [10]byte\nvar d [10]byte\nvar e [10]byte\nvar f [10]byte\nvar g [10]byte\nvar h [10]byte\nvar i [10]byte\nvar j [10]byte\nvar k [10]byte\nvar l [10]byte\nvar m [10]byte\nvar n [10]byte\nvar o [10]byte\nvar p [10]byte\nvar q [10]byte\nvar r [10]byte\nvar s [10]byte\nvar t [10]byte\nvar u [10]byte\nvar v [10]byte\nvar w [10]byte\nvar x [10]byte\nvar y [10]byte\nvar z [10]byte\nvar aa [10]byte\nvar ab [10]byte\nvar ac [10]byte\nvar ad [10]byte\nvar ae [10]byte\nvar af [10]byte\nvar ag [10]byte\nvar ah [10]byte\nvar ai [10]byte\nvar aj [10]byte\nvar ak [10]byte\nvar al [10]byte\nvar am [10]byte\nvar an [10]byte\nvar ao [10]byte\nvar ap [10]byte\nvar aq [10]byte\nvar ar [10]byte\nvar as [10]byte\nvar at [10]byte\nvar au [10]byte\nvar av [10]byte\nvar aw [10]byte\nvar ax [10]byte\nvar ay [10]byte\nvar az [10]byte\nvar aaa [10]byte\nvar aab [10]byte\nvar aac [10]byte\n"}
{"tgt": "fmt.Println(checkPerfectNumber(6))\nfmt.Println(checkPerfectNumber(28))\nfmt.Println(checkPerfectNumber(30))", "gen": "fmt.Println(checkPerfectNumber(6))\nfmt.Println(checkPerfectNumber(28))\nfmt.Println(checkPerfectNumber(30))\n}\n"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := EqualWithShifting(tc.A, tc.B); result != tc.expected {\n\t\tt.Errorf(\"STR\", tcid, tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "s = strings.TrimSpace(s)\n_, err := strconv.ParseFloat(s, 64)\nreturn err == nil || err.(*strconv.NumError).Err != strconv.ErrSyntax", "gen": "fmt.Println(parseFloat(\"123.456\"))\n}\n"}
{"tgt": "qs := []question76{\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans76, q.para76\n\tfmt.Printf(\"STR\", p, minWindow(p.s, p.p))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0}, 5},\n\t{\"STR\", []int{0, 0, 0, 0, 1}, []int{1, 0, 0, 0, 0}, 4},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums1, c.nums2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums1, c.nums2)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "return strings.ReplaceAll(r.element.Name, \"STR\", \"\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n\n// Output:\n// Hello, playground\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n// \u6c47\u7f16\u4ee3\u7801\n.text\n.globl main\nmain:\npushq %rbp\nmovq %rsp, %rbp\nsubq $16, %rsp\nmovq $0, %rax\nmovq $0, %rdx\nmovq $0, %rcx\nmovq $0, %r8\nmovq $0, %r9\nmovq $0, %r10\nmovq $0, %r11\nmovq $0, %r12\nmovq $0, %r13\nmovq $0, %r14\nmovq $0, %r15\nmovq $0, %rdi\nmovq $0, %rsi\nmovq $0, %rbx\nmovq $0, %r11\nmovq $0, %r12\nmovq $0, %r13\nmovq $0, %r14\nmovq $0, %r15\nmovq $0, %rdi\nmovq $0, %rsi\nmovq $0, %rbx\nmovq $0, %r11\nmovq $0, %r12\nmovq $0, %r13\nmovq $0, %r14\nmovq $0, %r15\nmovq $0, %rdi\nmovq $0, %rsi\nmovq $0, %rbx\nmovq $0, %r11\nmovq $0, %r12\nmovq $0, %r13\nmovq $0, %r14\nmovq $0, %r15\nmovq $0, %rdi\nmovq $0, %rsi\nmovq $0, %rbx\nmovq $0"}
{"tgt": "result := Mul3And5(5)\nif result != 3 {\n\tt.Errorf(\"STR\", result, 3)\n}\nresult = Mul3And5(6)\nif result != 8 {\n\tt.Errorf(\"STR\", result, 8)\n}\nresult = Mul3And5(7)\nif result != 14 {\n\tt.Errorf(\"STR\", result, 14)\n}\nresult = Mul3And5(10)\nif result != 23 {\n\tt.Errorf(\"STR\", result, 23)\n}\nresult = Mul3And5(11)\nif result != 33 {\n\tt.Errorf(\"STR\", result, 33)\n}", "gen": "var t testing.T\nt.Errorf(\"\")\n}\n\n// Test that we can handle a function with a large number of arguments.\n// This is a regression test for issue 10721.\n\n<ASM>\n.LFB19:\nleaq -680(%rsp),%r11\ncmpq %fs:112,%r11\njnb .L213\nmovl $680,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL20:\nret\n.L213:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $632,%rsp\nmovq %rdi,-456(%rbp)\nmovl $5,%edi\ncall <main.Mul3And5>\nmovq %rax,-56(%rbp)\n.LBB177:\ncmpq $3,-56(%rbp)\nje .L198\n.LBB178:\nleaq <int..d>(%rip),%rax\nmovq %rax,-672(%rbp)\nleaq <int..d>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-448(%rbp)\nmovq -448(%rbp),%rdx\nmovq -56(%rbp),%rax\nmovq %rax,(%rdx)\nmovq -448(%rbp),%rax\nmovq %rax,-664(%rbp)\nleaq <int..d>(%rip),%r12\nleaq <go..C38>(%rip),%r13\nleaq <type...62x.7interface.4.5>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-440(%rbp)\nmovd"}
{"tgt": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "if root == nil {\n\treturn nil\n}\nif root.Key == key {\n\treturn root\n} else if root.Key < key {\n\troot = root.Right\n} else {\n\troot = root.Left\n}\nreturn Get(root, key)", "gen": "var a, b int\na = 1\nb = 2\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else {\n\ta = 1\n}\nif a < b {\n\ta = 2\n} else"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1},\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1, 4, 2},\n\t\twant: 6,\n\t},\n\t{\n\t\tin:   []int{1},\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   []int{2, 1, 1, 2, 1, 3, 3, 3, 1, 3, 1, 3, 2},\n\t\twant: 7,\n\t},\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1},\n\t\twant: 2,\n\t},\n}\nfor _, tt := range tests {\n\tgot := findShortestSubArray(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var a [7]int\na[0] = 1\na[1] = 2\na[2] = 2\na[3] = 3\na[4] = 1\na[5] = 2\na[6] = 3\nvar b [7]int\nb[0] = 1\nb[1] = 2\nb[2] = 2\nb[3] = 3\nb[4] = 1\nb[5] = 2\nb[6] = 3\nvar c [7]int\nc[0] = 1\nc[1] = 2\nc[2] = 2\nc[3] = 3\nc[4] = 1\nc[5] = 2\nc[6] = 3\nvar d [7]int\nd[0] = 1\nd[1] = 2\nd[2] = 2\nd[3] = 3\nd[4] = 1\nd[5] = 2\nd[6] = 3\nvar e [7]int\ne[0] = 1\ne[1] = 2\ne[2] = 2\ne[3] = 3\ne[4] = 1\ne[5] = 2\ne[6] = 3\nvar f [7]int\nf[0] = 1\nf[1] = 2\nf[2] = 2\nf[3] = 3\nf[4] = 1\nf[5] = 2\nf[6] = 3\nvar g [7]int\ng[0] = 1\ng[1] = 2\ng[2] = 2\ng[3] = 3\ng[4] = 1\ng[5] = 2\ng[6] = 3\nvar h"}
{"tgt": "fmt.Println(runtime.GOOS, runtime.GOARCH)", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "result := make([]string, 0)\nstart := -1\nend := -1\nfor i, num := range nums {\n\tif i > 0 && num == nums[i-1]+1 {\n\t\tend = i\n\t} else {\n\t\tif i > 0 {\n\t\t\tresult = appendRanges(result, nums, start, end)\n\t\t}\n\t\tstart = i\n\t\tend = i\n\t}\n}\nif end >= 0 {\n\tresult = appendRanges(result, nums, start, end)\n}\nreturn result", "gen": "var a []int\na = append(a, 1)\na = append(a, 2)\na = append(a, 3)\na = append(a, 4)\na = append(a, 5)\na = append(a, 6)\na = append(a, 7)\na = append(a, 8)\na = append(a, 9)\na = append(a, 10)\na = append(a, 11)\na = append(a, 12)\na = append(a, 13)\na = append(a, 14)\na = append(a, 15)\na = append(a, 16)\na = append(a, 17)\na = append(a, 18)\na = append(a, 19)\na = append(a, 20)\na = append(a, 21)\na = append(a, 22)\na = append(a, 23)\na = append(a, 24)\na = append(a, 25)\na = append(a, 26)\na = append(a, 27)\na = append(a, 28)\na = append(a, 29)\na = append(a, 30)\na = append(a, 31)\na = append(a, 32)\na = append(a, 33)\na = append(a, 34)\na = append(a, 35)\na = append(a, 36)\na = append(a, 37)\na = append(a, 38)\na = append(a, 39)\na = append(a, 40)\na = append(a, 41)\na = append(a, 42)"}
{"tgt": "pigs := 0\nfor mypow(minutesToTest/minutesToDie+1, pigs) < buckets {\n\tpigs++\n}\nreturn pigs", "gen": "fmt.Println(mypow(2, 10))\n}\n"}
{"tgt": "qs := []question470{\n\t{\n\t\tpara470{},\n\t\tans470{2},\n\t},\n\t{\n\t\tpara470{},\n\t\tans470{0},\n\t},\n\t{\n\t\tpara470{},\n\t\tans470{1},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans470, q.para470\n\tfmt.Printf(\"STR\", p, rand10())\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "if s == nil {\n\treturn false\n}\nreturn isSubtree(s.Left, t) || isSameTree(s, t) || isSubtree(s.Right, t)", "gen": "var a, b *TreeNode\na = &TreeNode{Val: 1}\nb = &TreeNode{Val: 1}\na.Left = &TreeNode{Val: 2}\na.Right = &TreeNode{Val: 3}\nb.Left = &TreeNode{Val: 2}\nb.Right = &TreeNode{Val: 3}\nfmt.Println(isSubtree(a, b))\n}\n"}
{"tgt": "if p := e.r; e.list != nil && p != &e.list.root {\n\treturn p\n}\nreturn nil", "gen": "var a [1000000]int\nvar b [1000000]int\nvar c [1000000]int\nvar d [1000000]int\nvar e [1000000]int\nvar f [1000000]int\nvar g [1000000]int\nvar h [1000000]int\nvar i [1000000]int\nvar j [1000000]int\nvar k [1000000]int\nvar l [1000000]int\nvar m [1000000]int\nvar n [1000000]int\nvar o [1000000]int\nvar p [1000000]int\nvar q [1000000]int\nvar r [1000000]int\nvar s [1000000]int\nvar t [1000000]int\nvar u [1000000]int\nvar v [1000000]int\nvar w [1000000]int\nvar x [1000000]int\nvar y [1000000]int\nvar z [1000000]int\nvar aa [1000000]int\nvar ab [1000000]int\nvar ac [1000000]int\nvar ad [1000000]int\nvar ae [1000000]int\nvar af [1000000]int\nvar ag [1000000]int\nvar ah [1000000]int\nvar ai [1000000]int\nvar aj [10000"}
{"tgt": "switch {\ncase one == nil && two == nil:\n\treturn nil\ncase one == nil:\n\treturn &BinaryTree{two.Val,\n\t\tMergeBinaryTrees(nil, two.Left),\n\t\tMergeBinaryTrees(nil, two.Right),\n\t}\ncase two == nil:\n\treturn &BinaryTree{one.Val,\n\t\tMergeBinaryTrees(one.Left, nil),\n\t\tMergeBinaryTrees(one.Right, nil),\n\t}\n}\nreturn &BinaryTree{one.Val + two.Val,\n\tMergeBinaryTrees(one.Left, two.Left),\n\tMergeBinaryTrees(one.Right, two.Right),\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "rets := make([][]int, numRows)\nif numRows == 0 {\n\treturn rets\n}\nrets[0] = []int{1}\nfor i := 1; i < numRows; i++ {\n\trets[i] = make([]int, i+1)\n\trets[i][0] = 1\n\trets[i][i] = 1\n\tfor j := 1; j < i; j++ {\n\t\trets[i][j] = rets[i-1][j-1] + rets[i-1][j]\n\t}\n}\nreturn rets", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb := a[0:2]\nb[0] = 10\nb[1] = 20\na[0] = 100\nfmt.Println(a[0], a[1], a[2])\n}\n\n// Output:\n// 100 20 3\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n.LBB0:\nleaq -344(%rsp),%r11\ncmpq %fs:112,%r11\njnb .L49\nmovl $344,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L49:\npushq %rbp\nmovq %rsp,%rbp\npushq %rbx\nsubq $328,%rsp\nmovq %rdi,-328(%rbp)\nmovq %rsi,-336(%rbp)\nmovq $0,-288(%rbp)\nmovq $0,-280(%rbp)\nmovq $0,-272(%rbp)\n.LBB2:\nmovq -336(%rbp),%rbx\nmovq %rbx,%rdx\nmovq %rbx,%rsi\nleaq <type...6.7int>(%rip),%rdi\ncall <runtime.makeslice@PLT>\nmovq %rax,-320(%rbp)\nmovq %rbx,-312(%rbp)\nmovq %rbx,-304(%rbp)\n.LBB3:\ncmpq $0,-336(%rbp)\njne .L2\n.LBB4:\n.LBB5:\nmovq -320(%rbp),%rax\nmovq -312(%rbp),%rdx\nmovq %rax,-288"}
{"tgt": "i, l := 0, len(bits)-1\nfor i < l {\n\ti += bits[i] + 1\n}\nreturn i == l", "gen": "var a [10]int\na[10] = 1\n}\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n// 0000000000000000 <main>:\n// \t.globl\tmain\n// \t.type\tmain,@function\n// main:                                   # @main\n// \t.cfi_startproc\n// \t.cfi_personality 0x3,__gxx_personality_v0\n// \t.cfi_lsda 0x3,.LLSDA0\n// \t.cfi_loc 1 1 0\n// \t.cfi_adjust_cfa_offset 32\n// \t.cfi_offset 11, -32\n// \t.cfi_offset 12, -24\n// \t.cfi_offset 13, -16\n// \t.cfi_offset 14, -8\n// \t.cfi_offset 15, -16\n// \t.cfi_offset 16, -24\n// \t.cfi_offset 17, -32\n// \t.cfi_offset 18, -40\n// \t.cfi_offset 19, -48\n// \t.cfi_offset 20, -56\n// \t.cfi_offset 21, -64\n// \t.cfi_offset 22, -72\n// \t.cfi_offset 23, -80\n// \t.cfi_offset 24, -88\n// \t.cfi_offset 25, -96\n// \t.cfi_offset 26, -104\n// \t.cfi_offset 27, -112\n// \t.cfi_offset 28, -120\n// \t.cfi_offset 29, -128\n//"}
{"tgt": "fname, lname := \"STR\", \"STR\"\nage := 35\nfmt.Println(Title)\nfmt.Println(\"STR\", fname)\nfmt.Println(\"STR\", lname)\nfmt.Println(\"STR\", age)\nfmt.Println(\"STR\", Country)", "gen": "var c Country\nvar s string\nvar i int\nfmt.Println(c, s, i)\nc = Country{\"China\", \"Beijing\"}\ns = \"Hello, world\"\ni = 100\nfmt.Println(c, s, i)\nc = Country{\"USA\", \"Washington\"}\ns = \"Hello, world\"\ni = 100\nfmt.Println(c, s, i)\nc = Country{\"China\", \"Beijing\"}\ns = \"Hello, world\"\ni = 100\nfmt.Println(c, s, i)\nc = Country{\"USA\", \"Washington\"}\ns = \"Hello, world\"\ni = 100\nfmt.Println(c, s, i)\nc = Country{\"China\", \"Beijing\"}\ns = \"Hello, world\"\ni = 100\nfmt.Println(c, s, i)\nc = Country{\"USA\", \"Washington\"}\ns = \"Hello, world\"\ni = 100\nfmt.Println(c, s, i)\nc = Country{\"China\", \"Beijing\"}\ns = \"Hello, world\"\ni = 100\nfmt.Println(c, s, i)\nc = Country{\"USA\", \"Washington\"}\ns = \"Hello, world\"\ni = 100\nfmt.Println(c, s, i)\nc = Country{\"China\", \"Beijing\"}\ns = \"Hello, world\"\ni = 100\nfmt.Println(c, s, i)\nc = Country{\"USA\", \"Washington\"}\ns = \"Hello, world\"\ni = 100\nfmt.Println(c, s, i)\nc = Country{\"China\", \"Beijing\"}\ns = \"Hello, world\"\ni = 100\nfmt.Println(c, s, i"}
{"tgt": "for i := 0; i < b.N; i++ {\n\tSum(7, 8, 10)\n}", "gen": "fmt.Println(Sum(1, 2, 3, 4, 5))\n}\n"}
{"tgt": "dec := xml.NewDecoder(os.Stdin)\nvar stack []string\nfor {\n\ttok, err := dec.Token()\n\tif err == io.EOF {\n\t\tbreak\n\t} else if err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"STR\", err)\n\t\tos.Exit(1)\n\t}\n\tswitch tok := tok.(type) {\n\tcase xml.StartElement:\n\t\tstack = append(stack, tok.Name.Local)\n\tcase xml.EndElement:\n\t\tstack = stack[:len(stack)-1]\n\tcase xml.CharData:\n\t\tif containsAll(stack, os.Args[1:]) {\n\t\t\tfmt.Printf(\"STR\", strings.Join(stack, \"STR\"), tok)\n\t\t}\n\t}\n}", "gen": "var buf bytes.Buffer\nenc := xml.NewEncoder(&buf)\nenc.Indent(\"\", \"  \")\nif err := enc.Encode(os.Stdin); err != nil {\n\tpanic(err)\n}\nfmt.Fprintf(os.Stderr, \"%s\\n\", buf.String())\n}\n"}
{"tgt": "var sentences []string\nvar start int\nspaceDelimited := strings.Split(text, \"STR\")\npossibleSentence := false\nfor i, part := range spaceDelimited {\n\trunes := []rune(part)\n\tif part == \"STR\" || !isValid(runes) {\n\t\tpossibleSentence = false\n\t\tcontinue\n\t}\n\tif runes[0] >= 'A' && runes[0] <= 'Z' {\n\t\tpossibleSentence = true\n\t\tstart = i\n\t\tcontinue\n\t}\n\tif last := runes[len(runes)-1]; last == '.' || last == '!' || last == '?' {\n\t\tif possibleSentence {\n\t\t\tsentences = append(sentences, strings.Join(spaceDelimited[start:i+1], \"STR\"))\n\t\t}\n\t}\n}\nreturn sentences", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "arr := randomSlice(0, 20, 10)\ndeleteSequence := randomSlice(0, 10, 10)\nnodeCnt := 0\nrbt := newRBT()\nfor _, v := range arr {\n\trbt.Insert(uint32(v))\n}\nfor i, v := range deleteSequence {\n\trbt.Delete(uint32(arr[v]))\n\tstop := rbt.PreOrderWalk(rbt.Root(), checkGBT(t, &nodeCnt, *debug))\n\tif stop {\n\t\treturn\n\t}\n\tif nodeCnt != len(deleteSequence)-1-i {\n\t\tt.Log(\"STR\", len(deleteSequence)-1-i, \"STR\", nodeCnt)\n\t\tt.Fail()\n\t}\n\tnodeCnt = 0\n\tif i != len(deleteSequence)-1 {\n\t\tstop = checkRBT(t, rbt)\n\t\tif stop {\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "testing.M()\n}\n"}
{"tgt": "ans := make([]int, len(nums))\nfor i, idx := range index {\n\tcopy(ans[idx+1:], ans[idx:])\n\tans[idx] = nums[i]\n}\nreturn ans", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "min, max := A[0], A[0]\nfor _, a := range A {\n\tif a < min {\n\t\tmin = a\n\t}\n\tif a > max {\n\t\tmax = a\n\t}\n}\nif max-min <= K+K {\n\treturn 0\n}\nreturn max - min - K - K", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\tprintln(a[i])\n}\n}\n\n// Output:\n// 0\n// 1\n// 2\n// 3\n// 4\n// 5\n// 6\n// 7\n// 8\n// 9\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n.LFB0:\ncmpq %fs:112,%rsp\njnb .L15\nmovl $88,%r10d\nmovl $24,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L15:\npushq %rbp\nmovq %rsp,%rbp\nsubq $80,%rsp\nmovq %rdi,-72(%rbp)\nmovl $0,-24(%rbp)\n.LBB2:\nmovq <24>(%rbp),%rax\ntestq %rax,%rax\njg .L2\nmovq %rax,%rsi\nmovl $0,%edi\ncall <runtime.goPanicIndex@PLT>\n.L2:\nmovq <16>(%rbp),%rax\nmovq (%rax),%rax\nmovq %rax,-8(%rbp)\nmovq <24>(%rbp),%rax\ntestq %rax,%rax\njg .L3\nmovq %rax,%rsi\nmovl $0,%edi\ncall <runtime.goPanicIndex@PLT>\n.L3:\nmovq <16>(%rbp),%rax\nmovq (%rax),%rax\nmovq %rax,-16(%rbp)\n.LBB3:\nmovq $0,-32(%rbp)\n.LBB4:\n.LBB5:\n.LBB6:"}
{"tgt": "left := 0\nright := len(numbers) - 1\nfor left != right {\n\tif numbers[left]+numbers[right] == target {\n\t\tbreak\n\t}\n\tif numbers[left]+numbers[right] > target {\n\t\tright--\n\t}\n\tif numbers[left]+numbers[right] < target {\n\t\tleft++\n\t}\n}\nreturn []int{left + 1, right + 1}", "gen": "var a [2]int\nvar b [2]int\na[0] = 1\na[1] = 2\nb[0] = 3\nb[1] = 4\nc := a + b\nfmt.Println(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for a != nil && b != nil {\n\tif a.Value != b.Value {\n\t\treturn false\n\t}\n\ta = a.Next\n\tb = b.Next\n}\nreturn a == nil && b == nil", "gen": "var a, b int\na = 1\nb = 2\nif a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a != b\")\n}\nif a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a != b\")\n}\nif a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a != b\")\n}\nif a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a != b\")\n}\nif a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a != b\")\n}\nif a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a != b\")\n}\nif a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a != b\")\n}\nif a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a != b\")\n}\nif a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a != b\")\n}\nif a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a != b\")\n}\nif a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a != b\")\n}\nif a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a != b\")\n}\nif a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a != b\")\n}\nif a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a != b\")\n}\nif a == b {\n\tprintln(\"a == b\")\n} else"}
{"tgt": "return func(treebinaryTreeIf, node interface{}) bool {\n\tn := node.(*gbtElement)\n\tif !tree.IsNil(n.Left) && n.Left.Key >= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Left, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif !tree.IsNil(n.Right) && n.Right.Key <= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Right, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif debug {\n\t\tfmt.Println(n)\n\t}\n\t*nodeCnt++\n\treturn false\n}", "gen": "var t1 testing.T\nvar bt binaryTree\nbt.checkGBT(&t1, true, 10)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "n := len(A)\nif n == 0 {\n\treturn A\n}\nabs := func(num int) int { return int(math.Abs(float64(num))) }\nans := make([]int, n)\ni, j, k := 0, n-1, n-1\nfor i <= j {\n\tif abs(A[i]) > abs(A[j]) {\n\t\tans[k] = A[i] * A[i]\n\t\ti++\n\t} else {\n\t\tans[k] = A[j] * A[j]\n\t\tj--\n\t}\n\tk--\n}\nreturn ans", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 4\nb[1] = 5\nb[2] = 6\nc[0] = 7\nc[1] = 8\nc[2] = 9\ngo.Solution.Solution.func"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif denoms := EgyptianFractions(tc.numerator, tc.denominator); !reflect.DeepEqual(tc.denominators, denoms) {\n\t\tt.Errorf(\"STR\", tc.denominators, denoms)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "nums1 := []int{2}\nnums2 := []int{}\nmerge(nums1, 1, nums2, 0)\nfmt.Println(nums1)", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\na[0] = 1\na[1] = 1\na[2] = 0\nb[0] = 2\nb[1] = 0\nb[2] = 0\nc[0] = 0\nc[1] = 0\nc[2] = 0\nmerge(&a, &b, &c)\nfmt.Println(a, b, c)\n}"}
{"tgt": "result := 0\nfor num != 0 {\n\tresult++\n\tnum = num & (num - 1)\n}\nreturn result", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0;"}
{"tgt": "qs := []question448{\n\t{\n\t\tpara448{[]int{4, 3, 2, 7, 8, 2, 3, 1}},\n\t\tans448{[]int{5, 6}},\n\t},\n\t{\n\t\tpara448{[]int{4, 3, 2, 10, 9, 2, 3, 1, 1, 1, 1}},\n\t\tans448{[]int{5, 6, 7, 8, 11}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans448, q.para448\n\tfmt.Printf(\"STR\", p, findDisappearedNumbers(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "flag.Parse()\nroots := flag.Args()\nif len(roots) == 0 {\n\troots = []string{\"STR\"}\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, root := range roots {\n\t\twalkDir(root, fileSizes)\n\t}\n\tclose(fileSizes)\n}()\nvar nfiles, nbytes int64\nfor size := range fileSizes {\n\tnfiles++\n\tnbytes += size\n}\nprintDiskUsage(nfiles, nbytes)", "gen": "flag.Parse()\nargs := flag.Args()\nif len(args) != 2 {\n\tfmt.Println(\"Usage:\", os.Args[0], \"source_file dest_file\")\n\tos.Exit(1)\n}\nsource := args[0]\ndest := args[1]\nfileSizes := make(chan int64)\ngo func() {\n\tfileSizes <- getFileSize(source)\n}()\ngo func() {\n\tfileSizes <- getFileSize(dest)\n}()\nroots := make(chan string)\ngo func() {\n\troots <- source\n\troots <- dest\n\tclose(roots)\n}()\nvar total int64\nfor path := range roots {\n\tfileSizes <- walk(path, fileSizes)\n}\nfor size := range fileSizes {\n\ttotal += size\n}\nprintDiskUsage(total)\n}"}
{"tgt": "return toString[t]", "gen": "beer := Beer{\n\tName: \"Budweiser\",\n\tType: BeerType(\"lager\"),\n}\nfmt.Println(beer)\n}\n"}
{"tgt": "for step := len(nums) / 2; step > 0; step /= 2 {\n\tfor i := step; i < len(nums); i++ {\n\t\tfor j := i - step; j >= 0 && nums[j+step] < nums[j]; j -= step {\n\t\t\tnums[j], nums[j+step] = nums[j+step], nums[j]\n\t\t}\n\t}\n}\nreturn nums", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor"}
{"tgt": "var tests = []struct {\n\ttree *TreeNode\n\tvals []int\n}{\n\t{newTree(1, 2, 3, nil, 5, nil, 4), []int{1, 3, 4}},\n\t{newTree(1, 2, 3, 4, 5, nil, 6, nil, 7, nil, nil, 8, nil, nil, 9, nil, nil, nil, 10), []int{1, 3, 6, 8, 9, 10}},\n}\nfor _, tt := range tests {\n\tvals := rightSideView(tt.tree)\n\tif reflect.DeepEqual(vals, tt.vals) == false {\n\t\tt.Errorf(\"STR\", tt.tree, vals, tt.vals)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "nodes := []int{\n\t1, 2, 3, 4, 5, 6,\n}\nedges := [][]bool{\n\t{false, true, true, false, false, false},\n\t{true, false, false, true, false, false},\n\t{true, false, false, true, false, false},\n\t{false, true, true, false, true, false},\n\t{false, false, false, true, false, true},\n\t{false, false, false, false, true, false},\n}\nstart := 1\nend := 6\nroute, _ := dfs(start, end, nodes, edges)\nfmt.Println(route)", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aaa [3]int\nvar aab [3]int\nvar aac [3]int\nvar aad [3]int\nvar aae [3]int\nvar aaf [3]int\nvar aag [3]int\nvar aah [3]int\nvar aai [3]int\n"}
{"tgt": "if target < 0 {\n\ttarget = -target\n}\nk := 0\nfor target > 0 {\n\tk++\n\ttarget -= k\n}\nif target%2 == 0 {\n\treturn k\n}\nreturn k + 1 + k%2", "gen": "var a int\nfor i := 0; i < 1000000000; i++ {\n\ta += i\n}\nprintln(a)\n}\n"}
{"tgt": "if mod == 1 {\n\treturn 0, nil\n}\nif exponent < 0 {\n\treturn -1, ErrorNegativeExponent\n}\n_, err := Multiply64BitInt(mod-1, mod-1)\nif err != nil {\n\treturn -1, err\n}\nvar result int64 = 1\nbase = base % mod\nfor exponent > 0 {\n\tif exponent%2 == 1 {\n\t\tresult = (result * base) % mod\n\t}\n\texponent = exponent >> 1\n\tbase = (base * base) % mod\n}\nreturn result, nil", "gen": "var a, b, c int64\nfmt.Scan(&a, &b, &c)\nfmt.Println(a * b / c)\n}\n"}
{"tgt": "for n := 0; n < 32; n++ {\n\tsquare[n] = gf2MatrixTimes(mat, mat[n])\n}", "gen": "var a [32]byte\nvar b [32]byte\nvar c [32]byte\nvar d [32]byte\nvar e [32]byte\nvar f [32]byte\nvar g [32]byte\nvar h [32]byte\nvar i [32]byte\nvar j [32]byte\nvar k [32]byte\nvar l [32]byte\nvar m [32]byte\nvar n [32]byte\nvar o [32]byte\nvar p [32]byte\nvar q [32]byte\nvar r [32]byte\nvar s [32]byte\nvar t [32]byte\nvar u [32]byte\nvar v [32]byte\nvar w [32]byte\nvar x [32]byte\nvar y [32]byte\nvar z [32]byte\nvar aa [32]byte\nvar ab [32]byte\nvar ac [32]byte\nvar ad [32]byte\nvar ae [32]byte\nvar af [32]byte\nvar ag [32]byte\nvar ah [32]byte\nvar ai [32]byte\nvar aj [32]byte\nvar ak [32]byte\nvar al [32]byte\nvar am [32]byte\nvar an [32]byte\nvar ao [32]byte\nvar ap [32]byte\nvar aq [32]byte\nvar ar [32]byte\nvar as [32]byte\nvar at [32]byte\nvar au [32]byte\nvar av [32]byte\nvar aw [32]byte\nvar ax [32]byte\nvar ay [32]byte\nvar az [32]byte\nvar ba [32]byte\nvar bb [32]byte\nvar bc [32]byte\n"}
{"tgt": "return n.Ns == nil", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "n := len(p)\ndestination := n * n\nsquares := make([]int, 400)\nisChecked := [401]bool{}\nsquares[0] = 1\nisChecked[1] = true\nsteps := 0\nfor len(squares) > 0 {\n\tsteps++\n\tsize := len(squares)\n\tfor j := 0; j < size; j++ {\n\t\ts := squares[j]\n\t\tfor i := 1; i <= 6; i++ {\n\t\t\tsi := s + i\n\t\t\tx, y := position(si, n)\n\t\t\tif p[x][y] != -1 {\n\t\t\t\tisChecked[si] = true\n\t\t\t\tsi = p[x][y]\n\t\t\t}\n\t\t\tif si == destination {\n\t\t\t\treturn steps\n\t\t\t}\n\t\t\tif !isChecked[si] {\n\t\t\t\tsquares = append(squares, si)\n\t\t\t\tisChecked[si] = true\n\t\t\t}\n\t\t}\n\t}\n\tsquares = squares[size:]\n}\nreturn -1", "gen": "var a [400]int\nvar b [50]int\nvar c [400]int\nvar d [400]int\nvar e [400]int\nvar f [400]int\nvar g [400]int\nvar h [400]int\nvar i [400]int\nvar j [400]int\nvar k [400]int\nvar l [400]int\nvar m [400]int\nvar n [400]int\nvar o [400]int\nvar p [400]int\nvar q [400]int\nvar r [400]int\nvar s [400]int\nvar t [400]int\nvar u [400]int\nvar v [400]int\nvar w [400]int\nvar x [400]int\nvar y [400]int\nvar z [400]int\nvar aa [400]int\nvar ab [400]int\nvar ac [400]int\nvar ad [400]int\nvar ae [400]int\nvar af [400]int\nvar ag [400]int\nvar ah [400]int\nvar ai [400]int\nvar aj [400]int\nvar ak [400]int\nvar al [400]int\nvar am [400]int\nvar an [400]int\nvar ao [400]int\nvar ap [400]int\nvar aq [400]int\nvar ar [400]int\nvar as [400]int\nvar at [400]int\nvar au [400]int\nvar av [400]int\nvar aw [400]int\nvar ax [400]int"}
{"tgt": "return &linkLoop{\n\tHead: &linkLoopNode{},\n}", "gen": "var d *linkLoopNode\nd = new(linkLoopNode)\nd.linkLoop = new(linkLoop)\nd.linkLoop.linkLoopNode = d\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname __morestack runtime.morestack"}
{"tgt": "return bindataRead(\n\t_dataCustomersJson,\n\t\"STR\",\n)", "gen": "var dataCustomersJson = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30},{\"id\":2,\"name\":\"Jane\",\"age\":29}]`)\nvar dataCustomersJson2 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30},{\"id\":2,\"name\":\"Jane\",\"age\":29}]`)\nvar dataCustomersJson3 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30},{\"id\":2,\"name\":\"Jane\",\"age\":29}]`)\nvar dataCustomersJson4 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30},{\"id\":2,\"name\":\"Jane\",\"age\":29}]`)\nvar dataCustomersJson5 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30},{\"id\":2,\"name\":\"Jane\",\"age\":29}]`)\nvar dataCustomersJson6 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30},{\"id\":2,\"name\":\"Jane\",\"age\":29}]`)\nvar dataCustomersJson7 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30},{\"id\":2,\"name\":\"Jane\",\"age\":29}]`)\nvar dataCustomersJson8 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30},{\"id\":2,\"name\":\"Jane\",\"age\":29}]`)\nvar dataCustomersJson9 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30},{\"id\":2,\"name\":\"Jane\",\"age\":29}]`)\nvar dataCustomersJson10 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30},{\"id\":2,\"name\":\"Jane\",\"age\":29}]`)\nvar dataCustomersJson11 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30},{\"id\":2,\"name\":\"Jane\",\"age\":29}]`)\nvar dataCustomersJson12 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30"}
{"tgt": "m := len(matrix)\nif m == 0 {\n\treturn 0\n}\nn := len(matrix[0])\nif n == 0 {\n\treturn 0\n}\nmaxEdge := 0\ndp := make([][]int, m+1)\nfor i := range dp {\n\tdp[i] = make([]int, n+1)\n}\nfor i := 1; i <= m; i++ {\n\tfor j := 1; j <= n; j++ {\n\t\tif matrix[i-1][j-1] == '1' {\n\t\t\tdp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))\n\t\t\tmaxEdge = max(maxEdge, dp[i][j])\n\t\t}\n\t}\n}\nreturn maxEdge * maxEdge", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar bb [3]int\nvar cc [3]int\nvar dd [3]int\nvar ee [3]int\nvar ff [3]int\nvar gg [3]int\nvar hh [3]int\nvar ii [3]int\nvar jj [3]int\nvar kk [3]int\nvar ll [3]int\nvar mm [3]int\nvar nn [3]int\nvar oo [3]int\nvar pp [3]int\nvar qq [3]int\nvar rr [3]int\nvar ss [3]int\nvar tt [3]int\nvar uu [3]int\nvar vv [3]int\nvar ww [3]int\nvar xx [3]int\nvar yy [3]int\nvar zz [3]int\nvar aaa [3]int\nvar bbb [3]int\nvar ccc [3]int\nvar ddd [3]int\nvar eee [3]int\nvar fff [3]int\nvar ggg [3]int\nvar hhh [3]"}
{"tgt": "return x * y", "gen": "var a float32 = 1.0\nvar b float32 = 2.0\nvar c float32 = 3.0\nvar d float32 = 4.0\nvar e float32 = 5.0\nvar f float32 = 6.0\nvar g float32 = 7.0\nvar h float32 = 8.0\nvar i float32 = 9.0\nvar j float32 = 10.0\nvar k float32 = 11.0\nvar l float32 = 12.0\nvar m float32 = 13.0\nvar n float32 = 14.0\nvar o float32 = 15.0\nvar p float32 = 16.0\nvar q float32 = 17.0\nvar r float32 = 18.0\nvar s float32 = 19.0\nvar t float32 = 20.0\nvar u float32 = 21.0\nvar v float32 = 22.0\nvar w float32 = 23.0\nvar x float32 = 24.0\nvar y float32 = 25.0\nvar z float32 = 26.0\nvar aa float32 = 27.0\nvar bb float32 = 28.0\nvar cc float32 = 29.0\nvar dd float32 = 30.0\nvar ee float32 = 31.0\nvar ff float32 = 32.0\nvar gg float32 = 33.0\nvar hh float32 = 34.0\nvar ii float32 = 35.0\nvar jj float32 = 36.0\nvar kk float32 = 37.0\nvar ll float32 = 38.0\nvar mm float32 = 39"}
{"tgt": "if len(a) != len(b) {\n\treturn false\n}\nfor i, v := range a {\n\tif v != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "if len(s) <= 1 {\n\treturn s\n}\ni := getIndex(s + \"STR\" + reverse(s))\nreturn reverse(s[i:]) + s", "gen": "fmt.Println(reverse(\"hello\"))\nfmt.Println(reverse(\"world\"))\nfmt.Println(reverse(\"!\"))\nfmt.Println(reverse(\"\"))\nfmt.Println(reverse(\"a\"))\nfmt.Println(reverse(\"ab\"))\nfmt.Println(reverse(\"abc\"))\nfmt.Println(reverse(\"abcd\"))\nfmt.Println(reverse(\"abcde\"))\nfmt.Println(reverse(\"abcdef\"))\nfmt.Println(reverse(\"abcdefg\"))\nfmt.Println(reverse(\"abcdefgh\"))\nfmt.Println(reverse(\"abcdefghi\"))\nfmt.Println(reverse(\"abcdefghij\"))\nfmt.Println(reverse(\"abcdefghijk\"))\nfmt.Println(reverse(\"abcdefghijkl\"))\nfmt.Println(reverse(\"abcdefghijklm\"))\nfmt.Println(reverse(\"abcdefghijklmn\"))\nfmt.Println(reverse(\"abcdefghijklmno\"))\nfmt.Println(reverse(\"abcdefghijklmnop\"))\nfmt.Println(reverse(\"abcdefghijklmnopq\"))\nfmt.Println(reverse(\"abcdefghijklmnopqr\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrs\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrst\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrstu\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrstuv\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrstuvw\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrstuvwx\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrstuvwxy\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrstuvwxyz\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrst"}
{"tgt": "sorted := make([]int, 0, m+n)\np, q := 0, 0\nfor {\n\tif p == m {\n\t\tsorted = append(sorted, nums2[q:]...)\n\t\tbreak\n\t}\n\tif q == n {\n\t\tsorted = append(sorted, nums1[p:]...)\n\t\tbreak\n\t}\n\tif nums1[p] < nums2[q] {\n\t\tsorted = append(sorted, nums1[p])\n\t\tp++\n\t} else {\n\t\tsorted = append(sorted, nums2[q])\n\t\tq++\n\t}\n}\ncopy(nums1, sorted)", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "freq := make(map[rune]int)\nfor _, r := range s {\n\tfreq[r]++\n}\ntype frequency struct {\n\tr     rune\n\tcount int\n}\nletters := make([]*frequency, 0, len(freq))\nfor letter, count := range freq {\n\tletters = append(letters, &frequency{letter, count})\n}\nsort.Slice(letters, func(i, j int) bool {\n\treturn letters[i].count > letters[j].count\n})\nvar sb strings.Builder\nfor len(letters) != 0 {\n\tif len(letters) == 1 && letters[0].count > 1 {\n\t\treturn \"STR\"\n\t}\n\tfor _, f := range letters {\n\t\tsb.WriteRune(f.r)\n\t\tf.count--\n\t}\n\tfor len(letters) != 0 && letters[len(letters)-1].count == 0 {\n\t\tletters = letters[:len(letters)-1]\n\t}\n}\nreturn sb.String()", "gen": "fmt.Println(day231.NoAdjacent([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\n}\n"}
{"tgt": "n := len(A)\nfor i := n - 2; i >= 0; i-- {\n\tA[i] += A[i+1]\n}\nmem := [101][33]int{}\nvar dp func(int, int) int\ndp = func(i, m int) int {\n\tif i+2*m >= n {\n\t\treturn A[i]\n\t}\n\tif mem[i][m] > 0 {\n\t\treturn mem[i][m]\n\t}\n\tres := 0\n\tfor x := 1; x <= 2*m; x++ {\n\t\tres = max(\n\t\t\tres,\n\t\t\tA[i]-dp(i+x, max(m, x)),\n\t\t)\n\t}\n\tmem[i][m] = res\n\treturn res\n}\nreturn dp(0, 1)", "gen": "stoneGameII([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n}\n"}
{"tgt": "if n <= 2 {\n\treturn n\n}\nvar dp [2]int\ndp[0], dp[1] = 1, 2\nfor i := 2; i < n; i++ {\n\tdp[i%2] = dp[i%2] + dp[(i-1)%2]\n}\nreturn dp[(n-1)%2]", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "email = strings.TrimSpace(email)\nemail = strings.ToLower(email)\nh := md5.New()\nio.WriteString(h, email)\nfinalBytes := h.Sum(nil)\nfinalString := hex.EncodeToString(finalBytes)\nreturn finalString", "gen": "var s string\nfmt.Scan(&s)\nfmt.Println(md5(s))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t}, {\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n}\nfor _, tt := range tests {\n\tgot := repeatedSubstringPattern(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var s string\nvar b bool\nvar i int\nvar p *int\nvar f float64\nvar c complex128\nvar r rune\nvar b2 bool\nvar i2 int\nvar p2 *int\nvar f2 float64\nvar c2 complex128\nvar r2 rune\nvar s2 string\nvar b3 bool\nvar i3 int\nvar p3 *int\nvar f3 float64\nvar c3 complex128\nvar r3 rune\nvar s3 string\nvar b4 bool\nvar i4 int\nvar p4 *int\nvar f4 float64\nvar c4 complex128\nvar r4 rune\nvar s4 string\nvar b5 bool\nvar i5 int\nvar p5 *int\nvar f5 float64\nvar c5 complex128\nvar r5 rune\nvar s5 string\nvar b6 bool\nvar i6 int\nvar p6 *int\nvar f6 float64\nvar c6 complex128\nvar r6 rune\nvar s6 string\nvar b7 bool\nvar i7 int\nvar p7 *int\nvar f7 float64\nvar c7 complex128\nvar r7 rune\nvar s7 string\nvar b8 bool\nvar i8 int\nvar p8 *int\nvar f8 float64\nvar c8 complex128\nvar r8 rune\nvar s8 string\nvar b9 bool\nvar i9 int\nvar p9 *int\nvar f9 float64\nvar c9 complex128\nvar r9 rune\nvar s9 string\nvar b10 bool\nvar i10 int\nvar p10 *int\nvar f10 float64\nvar c10 complex128\nvar r10 rune\nvar s10 string\nvar b11 bool\nvar i"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   0x5555,\n\t\twant: 8,\n\t},\n}\nfor _, tt := range tests {\n\tgot := hammingWeight(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var a uint32 = 0x00000000\nvar b uint32 = 0x00000001\nvar c uint32 = 0x00000002\nvar d uint32 = 0x00000003\nvar e uint32 = 0x00000004\nvar f uint32 = 0x00000005\nvar g uint32 = 0x00000006\nvar h uint32 = 0x00000007\nvar i uint32 = 0x00000008\nvar j uint32 = 0x00000009\nvar k uint32 = 0x0000000a\nvar l uint32 = 0x0000000b\nvar m uint32 = 0x0000000c\nvar n uint32 = 0x0000000d\nvar o uint32 = 0x0000000e\nvar p uint32 = 0x0000000f\nvar q uint32 = 0x00000010\nvar r uint32 = 0x00000011\nvar s uint32 = 0x00000012\nvar t uint32 = 0x00000013\nvar u uint32 = 0x00000014\nvar v uint32 = 0x00000015\nvar w uint32 = 0x00000016\nvar x uint32 = 0x00000017\nvar y uint32 = 0x00000018\nvar z uint32 = 0x00000019\nvar aa uint32"}
{"tgt": "return bindataRead(\n\t_assetsHomeCatJpg,\n\t\"STR\",\n)", "gen": "var a [4]int\nvar b [4]int\nvar c [4]int\nvar d [4]int\nvar e [4]int\nvar f [4]int\nvar g [4]int\nvar h [4]int\nvar i [4]int\nvar j [4]int\nvar k [4]int\nvar l [4]int\nvar m [4]int\nvar n [4]int\nvar o [4]int\nvar p [4]int\nvar q [4]int\nvar r [4]int\nvar s [4]int\nvar t [4]int\nvar u [4]int\nvar v [4]int\nvar w [4]int\nvar x [4]int\nvar y [4]int\nvar z [4]int\nvar aa [4]int\nvar ab [4]int\nvar ac [4]int\nvar ad [4]int\nvar ae [4]int\nvar af [4]int\nvar ag [4]int\nvar ah [4]int\nvar ai [4]int\nvar aj [4]int\nvar ak [4]int\nvar al [4]int\nvar am [4]int\nvar an [4]int\nvar ao [4]int\nvar ap [4]int\nvar aq [4]int\nvar ar [4]int\nvar as [4]int\nvar at [4]int\nvar au [4]int\nvar av [4]int\nvar aw [4]int\nvar ax [4]int\nvar ay [4]int\nvar az [4]int\nvar aaa [4]int\nvar aab [4]int\nvar aac [4]int\nvar aad [4]int\nvar aae [4]int\nvar aaf [4]int\nvar aag [4]int\nvar aah [4]int\nvar aai [4]int\n"}
{"tgt": "b.table = make(map[string]*entry, capacity)\nb.priorityQueue = make([]*entry, 0, capacity)\nb.lruList.Init()\nb.freeList.Init()\nheap.Init(&b.priorityQueue)\narrayOfEntries := make([]entry, capacity)\nfor i := uint(0); i < capacity; i++ {\n\te := &arrayOfEntries[i]\n\te.element.Value = e\n\te.index = -1\n\tb.freeList.PushElementBack(&e.element)\n}", "gen": "var c = New(10)\nfor i := 0; i < 1000000; i++ {\n\tc.Get(i)\n}\n}\n"}
{"tgt": "list.rear = nil", "gen": "var x int\nvar y int\nx = 1\ny = 2\nx = x + y\nprintln(x)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "h := newLinkedHeap()\nbenchmarkHeap(b, h)", "gen": "var h heap.Heap\nh = heap.NewLinkedHeap()\nbenchmarkHeap(&h)\n}\n"}
{"tgt": "close(p.work)\np.wg.Wait()", "gen": "var wg sync.WaitGroup\nch := make(chan int)\nwg.Add(1)\ngo func() {\n\tdefer wg.Done()\n\t<-ch\n}()\nwg.Wait()\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "res := 0\nfactor := 1\nsize := len(s)\nfor i := 0; i < size; i++ {\n\tif s[i] == '(' {\n\t\tfactor *= 2\n\t} else {\n\t\tfactor /= 2\n\t}\n\tif s[i] == '(' && s[i+1] == ')' {\n\t\tres += factor / 2\n\t}\n}\nreturn res", "gen": "var a [10]byte\nvar b [10]byte\nvar c [10]byte\nvar d [10]byte\nvar e [10]byte\nvar f [10]byte\nvar g [10]byte\nvar h [10]byte\nvar i [10]byte\nvar j [10]byte\nvar k [10]byte\nvar l [10]byte\nvar m [10]byte\nvar n [10]byte\nvar o [10]byte\nvar p [10]byte\nvar q [10]byte\nvar r [10]byte\nvar s [10]byte\nvar t [10]byte\nvar u [10]byte\nvar v [10]byte\nvar w [10]byte\nvar x [10]byte\nvar y [10]byte\nvar z [10]byte\nvar aa [10]byte\nvar ab [10]byte\nvar ac [10]byte\nvar ad [10]byte\nvar ae [10]byte\nvar af [10]byte\nvar ag [10]byte\nvar ah [10]byte\nvar ai [10]byte\nvar aj [10]byte\nvar ak [10]byte\nvar al [10]byte\nvar am [10]byte\nvar an [10]byte\nvar ao [10]byte\nvar ap [10]byte\nvar aq [10]byte\nvar ar [10]byte\nvar as [10]byte\nvar at [10]byte\nvar au [10]byte\nvar av [10]byte\nvar aw [10]byte\nvar ax [10]byte\nvar ay [10]byte\nvar az [10]byte\nvar ba [10]byte\nvar bb [10]byte\nvar bc [10]byte\n"}
{"tgt": "qs := []question454{\n\t{\n\t\tpara454{[]int{1, 2}, []int{-2, -1}, []int{-1, 2}, []int{0, 2}},\n\t\tans454{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans454, q.para454\n\tfmt.Printf(\"STR\", p, fourSumCount(p.a, p.b, p.c, p.d))\n}\nfmt.Printf(\"STR\")", "gen": "var a = []int{1, 2}\nvar b = []int{-2, -1}\nvar c = []int{-1, 2}\nvar d = []int{0, 2}\nvar ans int\nfor i := 0; i < len(a); i++ {\n\tfor j := 0; j < len(b); j++ {\n\t\tfor k := 0; k < len(c); k++ {\n\t\t\tfor l := 0; l < len(d); l++ {\n\t\t\t\tans += fourSumCount(a, b, c, d)\n\t\t\t}\n\t\t}\n\t}\n}\nfmt.Println(ans)\n}\n"}
{"tgt": "for i := range langs {\n\tlanguage := langs[i]\n\tif strings.EqualFold(language.Lang, str) {\n\t\treturn &language\n\t}\n}\nreturn nil", "gen": "langs := []Language{\n\t{\"Go\", \"golang\", \"golang\"},\n\t{\"Python\", \"python\", \"python\"},\n\t{\"Ruby\", \"ruby\", \"ruby\"},\n}\nfor _, lang := range langs {\n\tif lang.Name == \"Go\" {\n\t\tfmt.Println(\"Found Go\")\n\t}\n}\n}\n\n// \u7f16\u8bd1\u540e\u7684\u6c47\u7f16\u4ee3\u7801\n// 0x0000000000000000 <main>:\n// 0:\t55                   \tpush   %rbp\n// 1:\t48 89 e5             \tmov    %rsp,%rbp\n// 4:\t48 83 ec 20          \tsub    $0x20,%rsp\n// 8:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// c:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// f:\t48 89 7d e8          \tmov    %rdx,-0x18(%rbp)\n// 13:\t48 89 75 d8          \tmov    %rsi,-0x28(%rbp)\n// 17:\t48 89 7d d0          \tmov    %rdx,-0x30(%rbp)\n// 1b:\t48 89 75 c8          \tmov    %rsi,-0x38(%rbp)\n// 1f:\t48 89 7d c0          \tmov    %rdx,-0x40(%rbp)\n// 23:\t48 89 75 b8          \tmov    %rsi,-0x50(%rbp)\n// 27:\t48 89 7d b0          \tmov    %rdx,-0x58(%rbp)\n// 2b:\t48"}
{"tgt": "sort.Ints(houses)\nsort.Ints(heaters)\ni, ans := 0, 0\nfor _, house := range houses {\n\tfor i < len(heaters)-1 && heaters[i]+heaters[i+1] <= house*2 {\n\t\ti++\n\t}\n\tans = maxInt(ans, absInt(heaters[i]-house))\n}\nreturn ans", "gen": "var a []int\nvar b []int\nvar c int\na = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nb = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nc = problem475(a, b)\nfmt.Println(c)\n}\n"}
{"tgt": "return h.FromHexString(string(b))", "gen": "var hash go.metainfo.Hash\nhash.FromHexString(\"1234567890123456789012345678901234567890\")\nfmt.Println(hash)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{\n\t\t{10, 16},\n\t\t{2, 8},\n\t\t{1, 6},\n\t\t{7, 12},\n\t}, 2},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := findMinArrowShots(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "if n < 2 {\n\treturn false\n}\nfor i := 2; i < n; i++ {\n\tif n%i == 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a int\nvar b int\na = 1\nb = 0\nfor a < 10 {\n\ta = a + 1\n\tif a == 5 {\n\t\tb = 0\n\t}\n}\nif b == 0 {\n\tprintln(\"b is zero\")\n}\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{5, 3, 4, 5},\n\t\twant: true,\n\t},\n\t{\n\t\tin:   []int{2, 5, 7, 3},\n\t\twant: true,\n\t},\n}\nfor _, tt := range tests {\n\tgot := stoneGame(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(stoneGame([]int{5, 3, 4, 5}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4, 7}))\nfmt.Println(stoneGame([]int{2, 5, 4,"}
{"tgt": "return self.code", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb := a\nb[0] = 4\nb[1] = 5\nb[2] = 6\nfmt.Println(a[0], a[1], a[2])\nfmt.Println(b[0], b[1], b[2])\n}\n\n// Output:\n// 1 2 3\n// 4 5 6\n\n```\n\n### 2. \u5806\u6808\u6ea2\u51fa\n\n```go\npackage main\n\nimport \"fmt\"\n"}
{"tgt": "if N == 1 {\n\treturn 0\n}\nif K%2 == 1 {\n\treturn kthGrammar(N-1, (K+1)/2)\n}\nreturn opposite(kthGrammar(N-1, K/2))", "gen": "fmt.Println(kthGrammar(1, 1))\nfmt.Println(kthGrammar(1, 2))\nfmt.Println(kthGrammar(2, 1))\nfmt.Println(kthGrammar(2, 2))\nfmt.Println(kthGrammar(2, 3))\nfmt.Println(kthGrammar(2, 4))\nfmt.Println(kthGrammar(2, 5))\nfmt.Println(kthGrammar(2, 6))\nfmt.Println(kthGrammar(2, 7))\nfmt.Println(kthGrammar(2, 8))\nfmt.Println(kthGrammar(2, 9))\nfmt.Println(kthGrammar(2, 10))\nfmt.Println(kthGrammar(2, 11))\nfmt.Println(kthGrammar(2, 12))\nfmt.Println(kthGrammar(2, 13))\nfmt.Println(kthGrammar(2, 14))\nfmt.Println(kthGrammar(2, 15))\nfmt.Println(kthGrammar(2, 16))\nfmt.Println(kthGrammar(2, 17))\nfmt.Println(kthGrammar(2, 18))\nfmt.Println(kthGrammar(2, 19))\nfmt.Println(kthGrammar(2, 20))\nfmt.Println(kthGrammar(2, 21))\nfmt.Println(kthGrammar(2, 22))\nfmt.Println(kthGrammar(2, 23))\nfmt.Println(kthGrammar(2, 24))\nfmt.Println(kthGrammar(2, 25"}
{"tgt": "tests := [...]testType{\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := buddyStrings(tt.a, tt.b)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.a, tt.b, got, tt.want)\n\t}\n}", "gen": "buddyStrings(\"ab\", \"ba\")\nbuddyStrings(\"ab\", \"ab\")\nbuddyStrings(\"ab\", \"aa\")\nbuddyStrings(\"aa\", \"aa\")\nbuddyStrings(\"aa\", \"ab\")\nbuddyStrings(\"aaaaaaabc\", \"aaaaaaacb\")\nbuddyStrings(\"\", \"\")\nbuddyStrings(\"\", \"aa\")\nbuddyStrings(\"aa\", \"\")\nbuddyStrings(\"abc\", \"abc\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"acb\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\", \"abcd\")\nbuddyStrings(\"abc\","}
{"tgt": "ope := [][]int{\n\t{2, 2},\n\t{3, 3}}\nfmt.Println(maxCount(3, 3, ope))", "gen": "var a, b int\nfmt.Scan(&a, &b)\nfmt.Println(maxCount(a, b))\n}\n"}
{"tgt": "qs := []question274{\n\t{\n\t\tpara274{[]int{3, 6, 9, 1}},\n\t\tans274{3},\n\t},\n\t{\n\t\tpara274{[]int{1}},\n\t\tans274{1},\n\t},\n\t{\n\t\tpara274{[]int{}},\n\t\tans274{0},\n\t},\n\t{\n\t\tpara274{[]int{3, 0, 6, 1, 5}},\n\t\tans274{3},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans274, q.para274\n\tfmt.Printf(\"STR\", p, hIndex(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "sort.Strings(words)\nmp := make(map[string]bool)\nvar res string\nfor _, word := range words {\n\tsize := len(word)\n\tif size == 1 || mp[word[:size-1]] {\n\t\tif size > len(res) {\n\t\t\tres = word\n\t\t}\n\t\tmp[word] = true\n\t}\n}\nreturn res", "gen": "var a [3]string\na[0] = \"a\"\na[1] = \"b\"\na[2] = \"c\"\nsort.Strings(a[:])\nm := make(map[string]bool)\nfor _, v := range a {\n\tm[v] = true\n}\nfmt.Println(m)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "longestCenter, longestLength := 0, 0\nfor i, v := range P {\n\tif v > longestLength {\n\t\tlongestLength = v\n\t\tlongestCenter = i\n\t}\n}\noffset := (longestCenter - longestLength) / 2\nreturn s[offset : offset+longestLength]", "gen": "var a [10]int\nvar b [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < 10; i++ {\n\ta[i] += b[i]\n}\nprintln(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for j := 1; j <= 20; j++ {\n\tif num%j != 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a int\nvar b int\na = 10\nb = 2\nc := a / b\nfmt.Println(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "n := node.(*bstElement)\nif n == nil {\n\treturn nil\n}\nif n.right != nil {\n\treturn t.Min(n.right)\n}\ncur := n\nfor cur.parent != nil && cur.parent.left != cur {\n\tcur = cur.parent\n}\nreturn cur.parent", "gen": "var bst *BST\nbst = NewBST()\nbst.Insert(10)\nbst.Insert(20)\nbst.Insert(30)\nbst.Insert(40)\nbst.Insert(50)\nbst.Insert(60)\nbst.Insert(70)\nbst.Insert(80)\nbst.Insert(90)\nbst.Insert(100)\nbst.Insert(110)\nbst.Insert(120)\nbst.Insert(130)\nbst.Insert(140)\nbst.Insert(150)\nbst.Insert(160)\nbst.Insert(170)\nbst.Insert(180)\nbst.Insert(190)\nbst.Insert(200)\nbst.Insert(210)\nbst.Insert(220)\nbst.Insert(230)\nbst.Insert(240)\nbst.Insert(250)\nbst.Insert(260)\nbst.Insert(270)\nbst.Insert(280)\nbst.Insert(290)\nbst.Insert(300)\nbst.Insert(310)\nbst.Insert(320)\nbst.Insert(330)\nbst.Insert(340)\nbst.Insert(350)\nbst.Insert(360)\nbst.Insert(370)\nbst.Insert(380)\nbst.Insert(390)\nbst.Insert(400)\nbst.Insert(410)\nbst.Insert(420)\nbst.Insert(430)\nbst.Insert(440)\nbst.Insert(450)\nbst.Insert(460)\nbst.Insert(470)\nbst.Insert(480)\nbst.Insert(490)\nbst."}
{"tgt": "var r [][]int\nfor i := begin; i <= end; i++ {\n\tif 1 == k {\n\t\tr = append(r, []int{i})\n\t\tcontinue\n\t}\n\tsuf := comb(i+1, end, k-1)\n\tfor _, j := range suf {\n\t\tr = append(r, append([]int{i}, j...))\n\t}\n}\nreturn r", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aaa [3]int\nvar aab [3]int\nvar aac [3]int\nvar aad [3]int\nvar aae [3]int\nvar aaf [3]int\nvar aag [3]int\nvar aah [3]int\nvar aai [3]int\n"}
{"tgt": "b.lock.Lock()\ndefer b.lock.Unlock()\ne := b.table[key]\nif e == nil {\n\treturn nil, false\n}\nif e.expire.Before(now) {\n\tif b.ExpireGracePeriod == 0 || e.expire.Sub(now) > b.ExpireGracePeriod {\n\t\tb.removeEntry(e)\n\t}\n\treturn nil, false\n}\nb.touchEntry(e)\nreturn e.value, true", "gen": "var m sync.Mutex\nvar c = NewLRUCache(100)\nc.Add(\"a\", 1)\nc.Add(\"b\", 2)\nc.Add(\"c\", 3)\nc.Add(\"d\", 4)\nc.Add(\"e\", 5)\nc.Add(\"f\", 6)\nc.Add(\"g\", 7)\nc.Add(\"h\", 8)\nc.Add(\"i\", 9)\nc.Add(\"j\", 10)\nc.Add(\"k\", 11)\nc.Add(\"l\", 12)\nc.Add(\"m\", 13)\nc.Add(\"n\", 14)\nc.Add(\"o\", 15)\nc.Add(\"p\", 16)\nc.Add(\"q\", 17)\nc.Add(\"r\", 18)\nc.Add(\"s\", 19)\nc.Add(\"t\", 20)\nc.Add(\"u\", 21)\nc.Add(\"v\", 22)\nc.Add(\"w\", 23)\nc.Add(\"x\", 24)\nc.Add(\"y\", 25)\nc.Add(\"z\", 26)\nc.Add(\"aa\", 27)\nc.Add(\"bb\", 28)\nc.Add(\"cc\", 29)\nc.Add(\"dd\", 30)\nc.Add(\"ee\", 31)\nc.Add(\"ff\", 32)\nc.Add(\"gg\", 33)\nc.Add(\"hh\", 34)\nc.Add(\"ii\", 35)\nc.Add(\"jj\", 36)\nc.Add(\"kk\", 37)\nc.Add(\"ll\", 38)\nc.Add(\"mm\", 39)\nc.Add(\"nn\", 40)\nc.Add(\""}
{"tgt": "if root == nil {\n\treturn 0\n}\nresult := 0\nif root.Val >= L && root.Val <= R {\n\tresult += root.Val\n}\nif root.Val >= L {\n\tresult += rangeSumBST(root.Left, L, R)\n}\nif root.Val <= R {\n\tresult += rangeSumBST(root.Right, L, R)\n}\nreturn result", "gen": "fmt.Println(rangeSumBST(nil, 1))\nfmt.Println(rangeSumBST([]int{10, 5, 15, 3, 7}, 7))\nfmt.Println(rangeSumBST([]int{10, 5, 15, 3, 7}, 4))\nfmt.Println(rangeSumBST([]int{10, 5, 15, 3, 7}, 14))\nfmt.Println(rangeSumBST([]int{10, 5, 15, 3, 7}, 15))\nfmt.Println(rangeSumBST([]int{10, 5, 15, 3, 7}, 16))\nfmt.Println(rangeSumBST([]int{10, 5, 15, 3, 7}, 17))\nfmt.Println(rangeSumBST([]int{10, 5, 15, 3, 7}, 18))\nfmt.Println(rangeSumBST([]int{10, 5, 15, 3, 7}, 19))\nfmt.Println(rangeSumBST([]int{10, 5, 15, 3, 7}, 20))\nfmt.Println(rangeSumBST([]int{10, 5, 15, 3, 7}, 21))\nfmt.Println(rangeSumBST([]int{10, 5, 15, 3, 7}, 22))\nfmt.Println(rangeSumBST([]int{10, 5, 15, 3, 7}, 23))\nfmt.Println(rangeSumBST([]int{10, 5, 15, 3, 7}, 24))\nfmt.Println(rangeSumBST([]int{10, 5, 15, 3, 7},"}
{"tgt": "if tree.root == nil {\n\treturn nil, false\n}\ncurrentNode := tree.root\nfor currentNode != nil {\n\tif i == currentNode.data {\n\t\treturn currentNode, true\n\t} else if i > currentNode.data {\n\t\tcurrentNode = currentNode.right\n\t} else if i < currentNode.data {\n\t\tcurrentNode = currentNode.left\n\t}\n}\nreturn nil, false", "gen": "var a, b int\nvar c, d int\nvar e, f int\nvar g, h int\nvar i, j int\nvar k, l int\nvar m, n int\nvar o, p int\nvar q, r int\nvar s, t int\nvar u, v int\nvar w, x int\nvar y, z int\nvar aa, ab int\nvar ac, ad int\nvar ae, af int\nvar ag, ah int\nvar ai, aj int\nvar ak, al int\nvar am, an int\nvar ao, ap int\nvar aq, ar int\nvar as, at int\nvar au, av int\nvar aw, ax int\nvar ay, az int\nvar aaa, aab int\nvar aac, aad int\nvar aae, aaf int\nvar aag, aah int\nvar aai, aaj int\nvar aak, aal int\nvar aam, aan int\nvar aao, aap int\nvar aaq, aar int\nvar aas, aat int\nvar aau, aav int\nvar aaw, aax int\nvar aay, aaz int\nvar aba, abb int\nvar abc, abd int\nvar abe, abf int\nvar abg, abh int\nvar abi, abj int\nvar abk, abl int\nvar abm, abn int\nvar abo, abp int\nvar abq, abr int\nvar abs, abt int\nvar abu, abv int\nvar abw, abx int\nvar aby, abz int\nvar acb, acc int\nvar ace, acf int\nvar acg, ach int\nvar aci, acj int\nvar ack, acl int\nvar acm, acn int\nvar aco, acp int\nvar acq, acr int\nvar acs, act int\nvar acu, acv int\n"}
{"tgt": "length := len(nums)\nif length == 0 || length == 1 && nums[0] != target {\n\treturn []int{-1, -1}\n}\nreturn searchRangeI(nums, 0, length-1, target)", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nsearchRangeI(a, 2)\n}\n"}
{"tgt": "var (\n\tl int\n\tr = len(nums) - 1\n)\nfor l <= r {\n\tmid := l + (r-l)/2\n\tif target == nums[mid] {\n\t\treturn mid\n\t}\n\tif nums[mid] >= nums[l] && nums[mid] > nums[r] {\n\t\tif target >= nums[l] && target < nums[mid] {\n\t\t\tr = mid - 1\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t} else {\n\t\tif target > nums[mid] && target <= nums[r] {\n\t\t\tl = mid + 1\n\t\t} else {\n\t\t\tr = mid - 1\n\t\t}\n\t}\n}\nreturn -1", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor"}
{"tgt": "if squares < 3 {\n\treturn 1\n}\nif answer, ok := memo[squares]; ok {\n\treturn answer\n}\ntotal := int64(1)\nfor size := 3; size <= squares; size++ {\n\tfor start := 0; start <= squares-size; start++ {\n\t\tanswer := int64(1)\n\t\tanswer *= ways(squares - start - size - 1)\n\t\ttotal += answer\n\t}\n}\nmemo[squares] = total\nreturn total", "gen": "var memo map[int][2]int64\nways := make([]int64, 100)\nfor i := 0; i < 100; i++ {\n\tways[i] = 1\n}\nfor i := 1; i < 100; i++ {\n\tfor j := 1; j < i; j++ {\n\t\tways[i] += ways[j] * ways[i-j-1]\n\t}\n}\nfmt.Println(ways[99])\n}\n"}
{"tgt": "return &CircularBuffer{\n\tbuffer: make([]interface{}, size),\n\tsize:   size,\n\tavail:  make(chan bool, size),\n}", "gen": "var c chan bool\nvar s []bool\nvar b CircularBuffer\nc = make(chan bool)\ns = make([]bool, 168)\nb = CircularBuffer{}\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\nb.Write(s)\n"}
{"tgt": "return uint32((dev >> 8) & 0xff)", "gen": "var a int\na = 1\na = 2\na = 3\na = 4\na = 5\na = 6\na = 7\na = 8\na = 9\na = 10\na = 11\na = 12\na = 13\na = 14\na = 15\na = 16\na = 17\na = 18\na = 19\na = 20\na = 21\na = 22\na = 23\na = 24\na = 25\na = 26\na = 27\na = 28\na = 29\na = 30\na = 31\na = 32\na = 33\na = 34\na = 35\na = 36\na = 37\na = 38\na = 39\na = 40\na = 41\na = 42\na = 43\na = 44\na = 45\na = 46\na = 47\na = 48\na = 49\na = 50\na = 51\na = 52\na = 53\na = 54\na = 55\na = 56\na = 57\na = 58\na = 59\na = 60\na = 61\na = 62\na = 63\na = 64\na = 65\na = 66\na = 67\na = 68\na = 69\na = 70\na = 71\na = 72\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 4,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 6,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 6,\n\t},\n}\nfor _, tt := range tests {\n\tgot := longestValidParentheses(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(longestValidParentheses(\"(()\"))\nfmt.Println(longestValidParentheses(\")()())\"))\nfmt.Println(longestValidParentheses(\"()(()\"))\nfmt.Println(longestValidParentheses(\")()()\"))\nfmt.Println(longestValidParentheses(\"()\"))\nfmt.Println(longestValidParentheses(\"()()\"))\nfmt.Println(longestValidParentheses(\"()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()"}
{"tgt": "iterator := func() <-chan VertexId {\n\tch := make(chan VertexId)\n\tgo func() {\n\t\tif connected, ok := g.edges[vertex]; ok {\n\t\t\tfor VertexId, _ := range connected {\n\t\t\t\tif g.IsEdge(vertex, VertexId) {\n\t\t\t\t\tch <- VertexId\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\nreturn VerticesIterable(&vertexIterableHelper{iterFunc: iterator})", "gen": "g := NewGraph()\nv1 := g.NewVertex(1)\nv2 := g.NewVertex(2)\ng.AddEdge(v1, v2)\nfmt.Println(g.GetSuccessors(v1))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "ans := 0\nfor ; x != 0; x /= 10 {\n\tans = ans*10 + x%10\n}\nif ans < math.MinInt32 || ans > math.MaxInt32 {\n\treturn 0\n}\nreturn ans", "gen": "var a int64 = 1\nvar b int64 = 2\nvar c int64 = 3\nvar d int64 = 4\nvar e int64 = 5\nvar f int64 = 6\nvar g int64 = 7\nvar h int64 = 8\nvar i int64 = 9\nvar j int64 = 10\nvar k int64 = 11\nvar l int64 = 12\nvar m int64 = 13\nvar n int64 = 14\nvar o int64 = 15\nvar p int64 = 16\nvar q int64 = 17\nvar r int64 = 18\nvar s int64 = 19\nvar t int64 = 20\nvar u int64 = 21\nvar v int64 = 22\nvar w int64 = 23\nvar x int64 = 24\nvar y int64 = 25\nvar z int64 = 26\nvar aa int64 = 27\nvar bb int64 = 28\nvar cc int64 = 29\nvar dd int64 = 30\nvar ee int64 = 31\nvar ff int64 = 32\nvar gg int64 = 33\nvar hh int64 = 34\nvar ii int64 = 35\nvar jj int64 = 36\nvar kk int64 = 37\nvar ll int64 = 38\nvar mm int64 = 39\nvar nn int64 = 40\nvar oo int64 = 41\nvar pp int64 = 42\nvar qq int64 = 43\nvar rr int64 = 44\nvar ss int64 = 45\nvar tt int"}
{"tgt": "i, size := 0, len(s)\nss := make([]string, numRows)\nfor i < size {\n\tfor j := 0; j < numRows && i < size; j++ {\n\t\tss[j] += string(s[i])\n\t\ti++\n\t}\n\tfor j := numRows - 2; j > 0 && i < size; j-- {\n\t\tss[j] += string(s[i])\n\t\ti++\n\t}\n}\nvar ret string\nfor j := 0; j < numRows; j++ {\n\tret += ss[j]\n}\nreturn ret", "gen": "var s []string\ns = append(s, \"a\")\ns = append(s, \"b\")\ns = append(s, \"c\")\ns = append(s, \"d\")\ns = append(s, \"e\")\ns = append(s, \"f\")\ns = append(s, \"g\")\ns = append(s, \"h\")\ns = append(s, \"i\")\ns = append(s, \"j\")\ns = append(s, \"k\")\ns = append(s, \"l\")\ns = append(s, \"m\")\ns = append(s, \"n\")\ns = append(s, \"o\")\ns = append(s, \"p\")\ns = append(s, \"q\")\ns = append(s, \"r\")\ns = append(s, \"s\")\ns = append(s, \"t\")\ns = append(s, \"u\")\ns = append(s, \"v\")\ns = append(s, \"w\")\ns = append(s, \"x\")\ns = append(s, \"y\")\ns = append(s, \"z\")\ns = append(s, \"A\")\ns = append(s, \"B\")\ns = append(s, \"C\")\ns = append(s, \"D\")\ns = append(s, \"E\")\ns = append(s, \"F\")\ns = append(s, \"G\")\ns = append(s, \"H\")\ns = append(s, \"I\")\ns = append(s, \"J\")\ns = append(s, \"K\")\ns = append(s, \"L\")\ns = append(s, \"M\")\ns = append(s, \"N\")\ns = append(s, \"O\")\ns = append(s, \"P\")\ns = append(s, \"Q\")\ns = append(s, \"R\")\ns = append(s, \"S\")"}
{"tgt": "sum := big.NewInt(0)\nfor i := int64(1); i <= 1000; i++ {\n\tval := big.NewInt(i)\n\tsum.Add(sum, pow(val, i))\n}\nfmt.Println(\"STR\", sum.String())", "gen": "var a big.Int\na.SetInt64(1)\nvar b big.Int\nb.SetInt64(1)\nfor i := 0; i < 1000; i++ {\n\ta.Add(&a, &b)\n}\nfmt.Println(a)\n}\n"}
{"tgt": "for l, r := 0, len(A)-1; ; {\n\tm := (l + r) / 2\n\tif A[m] < A[m+1] {\n\t\tl = m\n\t} else if A[m-1] > A[m] {\n\t\tr = m\n\t} else {\n\t\treturn m\n\t}\n}", "gen": "var a [10]int\na[10] = 1\n}\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n\n// func main() {\n// \tvar a [10]int\n// \ta[10] = 1\n// }\n\n// func main() {\n// \tvar a [10]int"}
{"tgt": "max := 1000\nsum := 0\nfor i := 1; i < max; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)", "gen": "var a int\nvar b int\nvar c int\nvar d int\na = 1\nb = 1\nfor i := 0; i < 1000; i++ {\n\tif i%2 == 0 {\n\t\tc = a * b\n\t\td = a + b\n\t\ta = d\n\t\tb = c\n\t} else {\n\t\tc = a - b\n\t\td = a + b\n\t\ta = d\n\t\tb = c\n\t}\n}\nfmt.Println(a, b, c, d)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if k < 0 || len(nums) == 0 {\n\treturn 0\n}\nvar count int\nm := make(map[int]int, len(nums))\nfor _, value := range nums {\n\tm[value]++\n}\nfor key := range m {\n\tif k == 0 && m[key] > 1 {\n\t\tcount++\n\t\tcontinue\n\t}\n\tif k > 0 && m[key+k] > 0 {\n\t\tcount++\n\t}\n}\nreturn count", "gen": "var m map[int][2]int\nm[0] = [2]int{1, 2}\nm[1] = [2]int{3, 4}\nm[2] = [2]int{5, 6}\nm[3] = [2]int{7, 8}\nm[4] = [2]int{9, 10}\nm[5] = [2]int{11, 12}\nm[6] = [2]int{13, 14}\nm[7] = [2]int{15, 16}\nm[8] = [2]int{17, 18}\nm[9] = [2]int{19, 20}\nm[10] = [2]int{21, 22}\nm[11] = [2]int{23, 24}\nm[12] = [2]int{25, 26}\nm[13] = [2]int{27, 28}\nm[14] = [2]int{29, 30}\nm[15] = [2]int{31, 32}\nm[16] = [2]int{33, 34}\nm[17] = [2]int{35, 36}\nm[18] = [2]int{37, 38}\nm[19] = [2]int{39, 40}\nm[20] = [2]int{41, 42}\nm[21] = [2]int{43, 44}\nm[22] = [2]int{45, 46}\nm[23] = [2]int{47, 48}\nm[24] = [2]int{49, 50}\nm[25] = ["}
{"tgt": "parentMap, countMap := make(map[int]int), make(map[int]int)\nfor _, num := range nums {\n\tif _, exists := parentMap[num]; exists {\n\t\tcontinue\n\t}\n\tparentMap[num], countMap[num] = num, 1\n\tneighbors := [2]int{num - 1, num + 1}\n\tfor _, n := range neighbors {\n\t\tif _, exists := parentMap[n]; exists {\n\t\t\tcount1 := countMap[getParent128(n, parentMap)]\n\t\t\tcount2 := countMap[getParent128(num, parentMap)]\n\t\t\tunion128(n, num, parentMap)\n\t\t\tcountMap[getParent128(num, parentMap)] = count1 + count2\n\t\t}\n\t}\n}\nmax := 0\nfor _, count := range countMap {\n\tif count > max {\n\t\tmax = count\n\t}\n}\nreturn max", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "sort.Ints(people)\nthin, fat := 0, len(people)-1\nres := 0\nfor thin <= fat {\n\tif people[thin]+people[fat] <= limit {\n\t\tthin++\n\t}\n\tfat--\n\tres++\n}\nreturn res", "gen": "var a [5]int\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 4\na[4] = 5\nsort.Ints(a[:])\nfmt.Println(a)\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{1, 8, 6, 2, 5, 4, 8, 3, 7},\n\t\twant: 49,\n\t},\n\t{\n\t\tin:   []int{1, 8, 6, 30, 20, 6, 9, 10, 1},\n\t\twant: 48,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxArea(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var a [2]int\nvar b [2]int\nvar c [2]int\nvar d [2]int\nvar e [2]int\nvar f [2]int\nvar g [2]int\nvar h [2]int\nvar i [2]int\nvar j [2]int\nvar k [2]int\nvar l [2]int\nvar m [2]int\nvar n [2]int\nvar o [2]int\nvar p [2]int\nvar q [2]int\nvar r [2]int\nvar s [2]int\nvar t [2]int\nvar u [2]int\nvar v [2]int\nvar w [2]int\nvar x [2]int\nvar y [2]int\nvar z [2]int\nvar aa [2]int\nvar ab [2]int\nvar ac [2]int\nvar ad [2]int\nvar ae [2]int\nvar af [2]int\nvar ag [2]int\nvar ah [2]int\nvar ai [2]int\nvar aj [2]int\nvar ak [2]int\nvar al [2]int\nvar am [2]int\nvar an [2]int\nvar ao [2]int\nvar ap [2]int\nvar aq [2]int\nvar ar [2]int\nvar as [2]int\nvar at [2]int\nvar au [2]int\nvar av [2]int\nvar aw [2]int\nvar ax [2]int\nvar ay [2]int\nvar az [2]int\nvar aaa [2]int\nvar aab [2]int\nvar aac [2]int\nvar aad [2]int\nvar aae [2]int\nvar aaf [2]int\nvar aag [2]int\nvar aah [2]int\nvar aai [2]int\n"}
{"tgt": "count, k := make([]int, 128), len(s)/4\nfor _, v := range s {\n\tcount[int(v)]++\n}\nleft, right, res := 0, -1, len(s)\nfor left < len(s) {\n\tif count['Q'] > k || count['W'] > k || count['E'] > k || count['R'] > k {\n\t\tif right+1 < len(s) {\n\t\t\tright++\n\t\t\tcount[s[right]]--\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t} else {\n\t\tres = min(res, right-left+1)\n\t\tcount[s[left]]++\n\t\tleft++\n\t}\n}\nreturn res", "gen": "var s string\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\n"}
{"tgt": "http.HandleFunc(\"STR\", handler)", "gen": "http.HandleFunc(\"/\", handler)\nhttp.ListenAndServe(\":8080\", nil)\n}\n"}
{"tgt": "pairs := [...][2]int{{15, 26}, {1000, 1366}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p16(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var p16 [2]int\np16[0] = 15\np16[1] = 26\nvar p1000 [2]int\np1000[0] = 1366\np1000[1] = 1000\nvar p1 [2]int\np1[0] = 15\np1[1] = 26\nvar p2 [2]int\np2[0] = 1366\np2[1] = 1000\nvar p3 [2]int\np3[0] = 15\np3[1] = 26\nvar p4 [2]int\np4[0] = 1366\np4[1] = 1000\nvar p5 [2]int\np5[0] = 15\np5[1] = 26\nvar p6 [2]int\np6[0] = 1366\np6[1] = 1000\nvar p7 [2]int\np7[0] = 15\np7[1] = 26\nvar p8 [2]int\np8[0] = 1366\np8[1] = 1000\nvar p9 [2]int\np9[0] = 15\np9[1] = 26\nvar p10 [2]int\np10[0] = 1366\np10[1] = 1000\nvar p11 [2]int\np11[0] = 15\np11[1] = 26\nvar p12 [2]int\np12[0] = 1366\np12[1] = 1000\nvar p13 [2]int\np13[0]"}
{"tgt": "n := len(matrix)\nl, r := matrix[0][0], matrix[n-1][n-1]\nfor l < r {\n\tm := (l + r) / 2\n\tcount := 0\n\tfor i := 0; i < n; i++ {\n\t\tj := n - 1\n\t\tfor j >= 0 && matrix[i][j] > m {\n\t\t\tj--\n\t\t}\n\t\tcount += j + 1\n\t}\n\tif count < k {\n\t\tl = m + 1\n\t} else {\n\t\tr = m\n\t}\n}\nreturn l", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tm: 3,\n\t\tn: 3,\n\t\tops: [][]int{\n\t\t\t{2, 2},\n\t\t\t{3, 3},\n\t\t},\n\t\twant: 4,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxCount(tt.m, tt.n, tt.ops)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.m, got, tt.want)\n\t}\n}", "gen": "var a [5]int\nvar b [5]int\nvar c [5]int\nvar d [5]int\nvar e [5]int\nvar f [5]int\nvar g [5]int\nvar h [5]int\nvar i [5]int\nvar j [5]int\nvar k [5]int\nvar l [5]int\nvar m [5]int\nvar n [5]int\nvar o [5]int\nvar p [5]int\nvar q [5]int\nvar r [5]int\nvar s [5]int\nvar t [5]int\nvar u [5]int\nvar v [5]int\nvar w [5]int\nvar x [5]int\nvar y [5]int\nvar z [5]int\nvar aa [5]int\nvar ab [5]int\nvar ac [5]int\nvar ad [5]int\nvar ae [5]int\nvar af [5]int\nvar ag [5]int\nvar ah [5]int\nvar ai [5]int\nvar aj [5]int\nvar ak [5]int\nvar al [5]int\nvar am [5]int\nvar an [5]int\nvar ao [5]int\nvar ap [5]int\nvar aq [5]int\nvar ar [5]int\nvar as [5]int\nvar at [5]int\nvar au [5]int\nvar av [5]int\nvar aw [5]int\nvar ax [5]int\nvar ay [5]int\nvar az [5]int\nvar aaa [5]int\nvar aab [5]int\nvar aac [5]int\nvar aad [5]int\nvar aae [5]int\nvar aaf [5]int\nvar aag [5]int\nvar aah [5]int\nvar aai [5]int\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif isPartite := IsBipartiteGraph(tc.g); isPartite != tc.isPartite {\n\t\tt.Errorf(\"STR\", tc.isPartite, isPartite)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "var i int\nlength := len(nums)\nif length <= 1 {\n\treturn\n}\nfor i = length - 1; i >= 1; i-- {\n\tif nums[i] > nums[i-1] {\n\t\tbreak\n\t}\n}\nif i > 0 {\n\tsort.Ints(nums[i:])\n\tfor j := i - 1; j < length; j++ {\n\t\tif nums[j] > nums[i-1] {\n\t\t\tnums[i-1], nums[j] = nums[j], nums[i-1]\n\t\t\treturn\n\t\t}\n\t}\n}\nsort.Ints(nums)", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "return LoadUint64(&r.Reg)", "gen": "var x uint64\nfor i := 0; i < 1000000; i++ {\n\tx = x + 1\n}\nprintln(x)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var tests = []struct {\n\tnumber int\n\ttitle  string\n}{\n\t{1, \"STR\"},\n\t{28, \"STR\"},\n\t{701, \"STR\"},\n}\nfor _, tt := range tests {\n\ttitle := convertToTitle(tt.number)\n\tif title != tt.title {\n\t\tt.Errorf(\"STR\", tt.number, title, tt.title)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "empty := countBucket{}\nfor i, _ := range ss.olist {\n\tdelete(ss.hash, ss.olist[i].key)\n\tss.olist[i] = empty\n}", "gen": "var m map[string]uint32\nm = make(map[string]uint32)\nm[\"hello\"] = 1\nm[\"world\"] = 2\nm[\"hello\"] = 3\nm[\"world\"] = 4\nm[\"hello\"] = 5\nm[\"world\"] = 6\nm[\"hello\"] = 7\nm[\"world\"] = 8\nm[\"hello\"] = 9\nm[\"world\"] = 10\nm[\"hello\"] = 11\nm[\"world\"] = 12\nm[\"hello\"] = 13\nm[\"world\"] = 14\nm[\"hello\"] = 15\nm[\"world\"] = 16\nm[\"hello\"] = 17\nm[\"world\"] = 18\nm[\"hello\"] = 19\nm[\"world\"] = 20\nm[\"hello\"] = 21\nm[\"world\"] = 22\nm[\"hello\"] = 23\nm[\"world\"] = 24\nm[\"hello\"] = 25\nm[\"world\"] = 26\nm[\"hello\"] = 27\nm[\"world\"] = 28\nm[\"hello\"] = 29\nm[\"world\"] = 30\nm[\"hello\"] = 31\nm[\"world\"] = 32\nm[\"hello\"] = 33\nm[\"world\"] = 34\nm[\"hello\"] = 35\nm[\"world\"] = 36\nm[\"hello\"] = 37\nm[\"world\"] = 38\nm[\"hello\"] = 39\nm[\"world\"] = 40\nm[\"hello\"] = 41\nm[\"world\"] = 42\nm[\"hello\"] = 43\nm[\"world\"] = 44\nm[\"hello\"] = 45\nm[\"world\"] = 46\nm[\"hello\"] = 47\nm[\"world\"] = 48\nm[\"hello"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tresult := EloGames(tc.scores, tc.kFactor, tc.matches)\n\tfor i := range result {\n\t\tresult[i] = math.Round(result[i]*tc.tolerance) / tc.tolerance\n\t}\n\tif !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "l.insert(e, &l.root)", "gen": "fibHeap := NewFibHeap()\nfibHeap.Insert(1, 1)\nfibHeap.Insert(2, 2)\nfibHeap.Insert(3, 3)\nfibHeap.Insert(4, 4)\nfibHeap.Insert(5, 5)\nfibHeap.Insert(6, 6)\nfibHeap.Insert(7, 7)\nfibHeap.Insert(8, 8)\nfibHeap.Insert(9, 9)\nfibHeap.Insert(10, 10)\nfibHeap.Insert(11, 11)\nfibHeap.Insert(12, 12)\nfibHeap.Insert(13, 13)\nfibHeap.Insert(14, 14)\nfibHeap.Insert(15, 15)\nfibHeap.Insert(16, 16)\nfibHeap.Insert(17, 17)\nfibHeap.Insert(18, 18)\nfibHeap.Insert(19, 19)\nfibHeap.Insert(20, 20)\nfibHeap.Insert(21, 21)\nfibHeap.Insert(22, 22)\nfibHeap.Insert(23, 23)\nfibHeap.Insert(24, 24)\nfibHeap.Insert(25, 25)\nfibHeap.Insert(26, 26)\nfibHeap.Insert(27, 27)\nfibHeap.Insert(28, 28)\nfibHeap.Insert(29, 29)\nfibHeap.Insert(30, 30)\nfibHeap.Insert(31, 31)\nfibHeap.Insert(3"}
{"tgt": "if root == nil {\n\treturn 0\n}\nmax := height(root.Left)\nif h := height(root.Right); h > max {\n\tmax = h\n}\nreturn max + 1", "gen": "fmt.Println(maxArea([]int{1, 8, 6, 2, 5, 4, 8, 3, 7}))\n}\n"}
{"tgt": "qs := []question598{\n\t{\n\t\tpara598{3, 3, [][]int{{2, 2}, {3, 3}}},\n\t\tans598{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans598, q.para598\n\tfmt.Printf(\"STR\", p, maxCount(p.m, p.n, p.ops))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "var tests = []struct {\n\tnums    []int\n\ttarget  int\n\tindices []int\n}{\n\t{[]int{2, 7, 11, 15}, 9, []int{0, 1}},\n\t{[]int{2, 3, 4, 6}, 6, []int{0, 2}},\n\t{[]int{2, 3, 4, 7}, 8, nil},\n\t{nil, 8, nil},\n}\nfor _, tt := range tests {\n\tindices := twoSum(tt.nums, tt.target)\n\tif reflect.DeepEqual(indices, tt.indices) == false {\n\t\tt.Errorf(\"STR\", tt.nums, tt.target, indices, tt.indices)\n\t}\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "if isSquare(n) {\n\treturn 1\n}\nfor n%4 == 0 {\n\tn /= 4\n}\nif n%8 == 7 {\n\treturn 4\n}\nfor i := 1; i <= mySqrt(n); i++ {\n\tif isSquare(n - i*i) {\n\t\treturn 2\n\t}\n}\nreturn 3", "gen": "fmt.Println(mySqrt(8))\n}\n"}
{"tgt": "if N < 3 {\n\treturn N\n} else if N == 3 {\n\treturn 5\n}\nmod := 1000000007\ndp := make([]int, N+1)\ndp[1], dp[2], dp[3] = 1, 2, 5\nfor i := 4; i <= N; i++ {\n\tdp[i] = 2*dp[i-1] + dp[i-3]\n\tdp[i] %= mod\n}\nreturn dp[N]", "gen": "var a [10]int\na[1] = 1\na[2] = 2\na[3] = 3\na[4] = 4\na[5] = 5\na[6] = 6\na[7] = 7\na[8] = 8\na[9] = 9\na[10] = 10\na[11] = 11\na[12] = 12\na[13] = 13\na[14] = 14\na[15] = 15\na[16] = 16\na[17] = 17\na[18] = 18\na[19] = 19\na[20] = 20\na[21] = 21\na[22] = 22\na[23] = 23\na[24] = 24\na[25] = 25\na[26] = 26\na[27] = 27\na[28] = 28\na[29] = 29\na[30] = 30\na[31] = 31\na[32] = 32\na[33] = 33\na[34] = 34\na[35] = 35\na[36] = 36\na[37] = 37\na[38] = 38\na[39] = 39\na[40] = 40\na[41] = 41\na[42] = 42\na[43] = 43\na[44] = 44\na[45] = 45\na[46] = 46\na["}
{"tgt": "stack := []byte{}\nfor i := range num {\n\tdigit := num[i]\n\tfor k > 0 && len(stack) > 0 && digit < stack[len(stack)-1] {\n\t\tstack = stack[:len(stack)-1]\n\t\tk--\n\t}\n\tstack = append(stack, digit)\n}\nstack = stack[:len(stack)-k]\nans := strings.TrimLeft(string(stack), \"STR\")\nif ans == \"STR\" {\n\tans = \"STR\"\n}\nreturn ans", "gen": "var s []byte\nfor i := 0; i < 1000000; i++ {\n\ts = append(s, 'a')\n}\ns = append(s, 'b')\ns = append(s, 'c')\ns = append(s, 'd')\ns = append(s, 'e')\ns = append(s, 'f')\ns = append(s, 'g')\ns = append(s, 'h')\ns = append(s, 'i')\ns = append(s, 'j')\ns = append(s, 'k')\ns = append(s, 'l')\ns = append(s, 'm')\ns = append(s, 'n')\ns = append(s, 'o')\ns = append(s, 'p')\ns = append(s, 'q')\ns = append(s, 'r')\ns = append(s, 's')\ns = append(s, 't')\ns = append(s, 'u')\ns = append(s, 'v')\ns = append(s, 'w')\ns = append(s, 'x')\ns = append(s, 'y')\ns = append(s, 'z')\ns = append(s, 'A')\ns = append(s, 'B')\ns = append(s, 'C')\ns = append(s, 'D')\ns = append(s, 'E')\ns = append(s, 'F')\ns = append(s, 'G')\ns = append(s, 'H')\ns = append(s, 'I')\ns = append(s, 'J')\ns = append(s, 'K')\ns = append(s, 'L')\ns = append(s, 'M')\ns = append(s, 'N')\ns = append(s, 'O')\ns = append(s, 'P')\ns = append(s"}
{"tgt": "if e.element.list != &b.freeList {\n\tpanic(\"STR\")\n}\nif !e.expire.IsZero() {\n\theap.Push(&b.priorityQueue, e)\n}\nb.freeList.Remove(&e.element)\nb.lruList.PushElementFront(&e.element)\nb.table[e.key] = e", "gen": "var m = New(100)\nm.Set(\"a\", 1)\nm.Set(\"b\", 2)\nm.Set(\"c\", 3)\nm.Set(\"d\", 4)\nm.Set(\"e\", 5)\nm.Set(\"f\", 6)\nm.Set(\"g\", 7)\nm.Set(\"h\", 8)\nm.Set(\"i\", 9)\nm.Set(\"j\", 10)\nm.Set(\"k\", 11)\nm.Set(\"l\", 12)\nm.Set(\"m\", 13)\nm.Set(\"n\", 14)\nm.Set(\"o\", 15)\nm.Set(\"p\", 16)\nm.Set(\"q\", 17)\nm.Set(\"r\", 18)\nm.Set(\"s\", 19)\nm.Set(\"t\", 20)\nm.Set(\"u\", 21)\nm.Set(\"v\", 22)\nm.Set(\"w\", 23)\nm.Set(\"x\", 24)\nm.Set(\"y\", 25)\nm.Set(\"z\", 26)\nm.Set(\"aa\", 27)\nm.Set(\"bb\", 28)\nm.Set(\"cc\", 29)\nm.Set(\"dd\", 30)\nm.Set(\"ee\", 31)\nm.Set(\"ff\", 32)\nm.Set(\"gg\", 33)\nm.Set(\"hh\", 34)\nm.Set(\"ii\", 35)\nm.Set(\"jj\", 36)\nm.Set(\"kk\", 37)\nm.Set(\"ll\", 38)\nm.Set(\"mm\", 39)\nm.Set(\"nn\", 40)\nm.Set(\"oo\", 41)\nm.Set(\""}
{"tgt": "in := make([]int, N)\nout := make([]int, N)\nfor _, pair := range trust {\n\tout[pair[0]-1]++\n\tin[pair[1]-1]++\n}\nfor i := 0; i < N; i++ {\n\tif in[i] == N-1 && out[i] == 0 {\n\t\treturn i + 1\n\t}\n}\nreturn -1", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs int\n\texpect int\n}{\n\t{\"STR\", 2, 1},\n\t{\"STR\", 3, 2},\n\t{\"STR\", 4, 3},\n\t{\"STR\", 0, 0},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "return xtime.Unix(int64(jt), 0), nil", "gen": "var t time.Time\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\nt.Unix(0, 0)\n"}
{"tgt": "if len(name) == 0 && len(typed) == 0 {\n\treturn true\n}\nif (len(name) == 0 && len(typed) != 0) || (len(name) != 0 && len(typed) == 0) {\n\treturn false\n}\nj := 0\nfor i := 0; i < len(name); i++ {\n\tif j < len(typed) && name[i] == typed[j] {\n\t\tj++\n\t\tcontinue\n\t} else {\n\t\tif i > 0 && j < len(typed) && name[i-1] == typed[j] {\n\t\t\tj++\n\t\t\ti--\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "var a [10]byte\nvar b [10]byte\nvar c [10]byte\nvar d [10]byte\nvar e [10]byte\nvar f [10]byte\nvar g [10]byte\nvar h [10]byte\nvar i [10]byte\nvar j [10]byte\nvar k [10]byte\nvar l [10]byte\nvar m [10]byte\nvar n [10]byte\nvar o [10]byte\nvar p [10]byte\nvar q [10]byte\nvar r [10]byte\nvar s [10]byte\nvar t [10]byte\nvar u [10]byte\nvar v [10]byte\nvar w [10]byte\nvar x [10]byte\nvar y [10]byte\nvar z [10]byte\nvar aa [10]byte\nvar ab [10]byte\nvar ac [10]byte\nvar ad [10]byte\nvar ae [10]byte\nvar af [10]byte\nvar ag [10]byte\nvar ah [10]byte\nvar ai [10]byte\nvar aj [10]byte\nvar ak [10]byte\nvar al [10]byte\nvar am [10]byte\nvar an [10]byte\nvar ao [10]byte\nvar ap [10]byte\nvar aq [10]byte\nvar ar [10]byte\nvar as [10]byte\nvar at [10]byte\nvar au [10]byte\nvar av [10]byte\nvar aw [10]byte\nvar ax [10]byte\nvar ay [10]byte\nvar az [10]byte\nvar aaa [10]byte\nvar aab [10]byte\nvar aac [10]byte\n"}
{"tgt": "var i, j, tmp int\nfor i = 1; i < len(arr); i++ {\n\ttmp = arr[i]\n\tfor j = i; j > 0 && arr[j-1] > tmp; j-- {\n\t\tarr[j] = arr[j-1]\n\t}\n\tarr[j] = tmp\n}\nreturn arr", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\na[0] = a[0] + a[1] + a[2]\nprintln(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "res = [][]string{}\nif len(s) < 1 {\n\treturn res\n}\nhelper(s, 0, []string{})\nreturn res", "gen": "var res string\nres = \"hello\"\nres += \"world\"\nfmt.Println(res)\n}\n"}
{"tgt": "if from == to {\n\treturn errors.New(\"STR\")\n}\nif !g.CheckVertex(from) || !g.CheckVertex(to) {\n\treturn errors.New(\"STR\")\n}\ni, _ := g.edges[from][to]\nj, _ := g.edges[to][from]\nif i > 0 || j > 0 {\n\treturn errors.New(\"STR\")\n}\ng.TouchVertex(from)\ng.TouchVertex(to)\ng.edges[from][to] = weight\nif !g.isDirected {\n\tg.edges[to][from] = weight\n}\ng.edgesCount++\nreturn nil", "gen": "g := graph.New()\ng.AddVertex(1)\ng.AddVertex(2)\ng.AddVertex(3)\ng.AddVertex(4)\ng.AddVertex(5)\ng.AddVertex(6)\ng.AddVertex(7)\ng.AddVertex(8)\ng.AddVertex(9)\ng.AddVertex(10)\ng.AddVertex(11)\ng.AddVertex(12)\ng.AddVertex(13)\ng.AddVertex(14)\ng.AddVertex(15)\ng.AddVertex(16)\ng.AddVertex(17)\ng.AddVertex(18)\ng.AddVertex(19)\ng.AddVertex(20)\ng.AddVertex(21)\ng.AddVertex(22)\ng.AddVertex(23)\ng.AddVertex(24)\ng.AddVertex(25)\ng.AddVertex(26)\ng.AddVertex(27)\ng.AddVertex(28)\ng.AddVertex(29)\ng.AddVertex(30)\ng.AddVertex(31)\ng.AddVertex(32)\ng.AddVertex(33)\ng.AddVertex(34)\ng.AddVertex(35)\ng.AddVertex(36)\ng.AddVertex(37)\ng.AddVertex(38)\ng.AddVertex(39)\ng.AddVertex(40)\ng.AddVertex(41)\ng.AddVertex(42)\ng.AddVertex(43)\ng.AddVertex(44)\ng.AddVertex(45)\ng.AddVertex(46)\ng.AddVertex(47)\ng.AddVertex(48)\ng.AddVertex(49)\ng.AddVertex(50)\n"}
{"tgt": "i := 0\ndefer fmt.Println(\"STR\", i)\ndefer fmt.Println(\"STR\")\ndefer fmt.Println(\"STR\")\ni++\nfmt.Println(\"STR\", i)", "gen": "defer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer\")\n}()\ndefer func() {\n\tfmt.Println(\"defer"}
{"tgt": "maxIndex := [26]int{}\nfor i, b := range S {\n\tmaxIndex[b-'a'] = i\n}\nbegin := 0\nend := maxIndex[S[begin]-'a']\nres := make([]int, 0, len(S))\nfor i, b := range S {\n\tif i < end {\n\t\tend = max(end, maxIndex[b-'a'])\n\t\tcontinue\n\t}\n\tres = append(res, i-begin+1)\n\tbegin = i + 1\n\tif begin < len(S) {\n\t\tend = maxIndex[S[begin]-'a']\n\t}\n}\nreturn res", "gen": "var s []byte\nvar i int\nvar r rune\nvar n int\nvar max int\nvar j int\nvar c int\nvar b int\nvar a int\nvar x int\nvar y int\nvar z int\nvar w int\nvar v int\nvar u int\nvar t int\nvar s2 []byte\nvar i2 int\nvar r2 rune\nvar n2 int\nvar max2 int\nvar j2 int\nvar c2 int\nvar b2 int\nvar a2 int\nvar x2 int\nvar y2 int\nvar z2 int\nvar w2 int\nvar v2 int\nvar u2 int\nvar t2 int\nvar s3 []byte\nvar i3 int\nvar r3 rune\nvar n3 int\nvar max3 int\nvar j3 int\nvar c3 int\nvar b3 int\nvar a3 int\nvar x3 int\nvar y3 int\nvar z3 int\nvar w3 int\nvar v3 int\nvar u3 int\nvar t3 int\nvar s4 []byte\nvar i4 int\nvar r4 rune\nvar n4 int\nvar max4 int\nvar j4 int\nvar c4 int\nvar b4 int\nvar a4 int\nvar x4 int\nvar y4 int\nvar z4 int\nvar w4 int\nvar v4 int\nvar u4 int\nvar t4 int\nvar s5 []byte\nvar i5 int\nvar r5 rune\nvar n5 int\nvar max5 int\nvar j5 int\nvar c5 int\nvar b5 int\nvar a5 int\nvar x5 int\nvar y5 int\nvar z5 int\nvar w5 int\nvar v5 int\nvar u5 int\nvar t5 int\nvar s6 []byte\nvar i6 int\nvar r6 rune\nvar n6 int\n"}
{"tgt": "FirstNumber := 1\nSecondNumber := 2\nnextNumber := 0\nsum := SecondNumber\nfor nextNumber < 4000000 {\n\tnextNumber = FirstNumber + SecondNumber\n\tif nextNumber%2 == 0 {\n\t\tsum = sum + nextNumber\n\t}\n\tFirstNumber = SecondNumber\n\tSecondNumber = nextNumber\n}\nfmt.Println(\"STR\", sum, \"STR\")", "gen": "var a, b int\nfmt.Scan(&a, &b)\nc := a + b\nvar d string\nfmt.Scan(&d)\nvar e string\nfmt.Scan(&e)\nvar f int\nfmt.Scan(&f)\nvar g int\nfmt.Scan(&g)\nvar h int\nfmt.Scan(&h)\nvar i int\nfmt.Scan(&i)\nvar j int\nfmt.Scan(&j)\nvar k int\nfmt.Scan(&k)\nvar l int\nfmt.Scan(&l)\nvar m int\nfmt.Scan(&m)\nvar n int\nfmt.Scan(&n)\nvar o int\nfmt.Scan(&o)\nvar p int\nfmt.Scan(&p)\nvar q int\nfmt.Scan(&q)\nvar r int\nfmt.Scan(&r)\nvar s int\nfmt.Scan(&s)\nvar t int\nfmt.Scan(&t)\nvar u int\nfmt.Scan(&u)\nvar v int\nfmt.Scan(&v)\nvar w int\nfmt.Scan(&w)\nvar x int\nfmt.Scan(&x)\nvar y int\nfmt.Scan(&y)\nvar z int\nfmt.Scan(&z)\nvar aa int\nfmt.Scan(&aa)\nvar bb int\nfmt.Scan(&bb)\nvar cc int\nfmt.Scan(&cc)\nvar dd int\nfmt.Scan(&dd)\nvar ee int\nfmt.Scan(&ee)\nvar ff int\nfmt.Scan(&ff)\nvar gg int\nfmt.Scan(&gg)\nvar hh int\nfmt.Scan(&hh)\nvar ii int\nfmt.Scan(&ii)\nvar jj int\nfmt.Scan(&jj)\nvar kk int\nfmt.Scan(&kk)\nvar ll int\nfmt.Scan(&ll)\nvar mm int\nfmt.Scan(&mm)\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{2},\n\t\t\t{3, 4},\n\t\t\t{6, 5, 7},\n\t\t\t{4, 1, 8, 3},\n\t\t},\n\t\t11},\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{1},\n\t\t\t{2, 3},\n\t\t},\n\t\t3},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := minimumTotal(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "timeDelta := now.Sub(r.lastTimestamp)\nreturn r.Ewma.Update(nanosec/float64(timeDelta.Nanoseconds()), now)", "gen": "var ewma ewma.Ewma\nvar t time.Time\nvar d time.Duration\nvar n int64\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\n"}
{"tgt": "if list.head == nil {\n\treturn false\n}\nif list.head.data == i {\n\tlist.head = list.head.next\n\treturn true\n}\ncurrent := list.head\nfor current.next != nil {\n\tif current.next.data == i {\n\t\tcurrent.next = current.next.next\n\t\treturn true\n\t}\n\tcurrent = current.next\n}\nreturn false", "gen": "var a [10]int\nvar b [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = b[i]\n}\n}\n"}
{"tgt": "mySet := make(map[int]int, 0)\nfor _, v := range candies {\n\tmySet[v]++\n}\nif len(mySet) >= len(candies)/2 {\n\treturn len(candies) / 2\n}\nreturn len(mySet)", "gen": "var m map[int]int\nfor i := 0; i < 100; i++ {\n\tm[i] = i\n}\nprintln(m[99])\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname __morestack runtime.morestack"}
{"tgt": "a := []float64{1, 2, 3, 4, 5, 6}\nA := MakeMatrix(a, 3, 2)\nif A.cols != 2 ||\n\tA.rows != 3 ||\n\t!FloatArrayEquals(A.Elements, a) {\n\tt.Error()\n}", "gen": "var a = [6]float64{1, 2, 3, 4, 5, 6}\nvar b = [6]float64{1, 2, 3, 4, 5, 6}\nvar c = [6]float64{1, 2, 3, 4, 5, 6}\nvar d = [6]float64{1, 2, 3, 4, 5, 6}\nvar e = [6]float64{1, 2, 3, 4, 5, 6}\nvar f = [6]float64{1, 2, 3, 4, 5, 6}\nvar g = [6]float64{1, 2, 3, 4, 5, 6}\nvar h = [6]float64{1, 2, 3, 4, 5, 6}\nvar i = [6]float64{1, 2, 3, 4, 5, 6}\nvar j = [6]float64{1, 2, 3, 4, 5, 6}\nvar k = [6]float64{1, 2, 3, 4, 5, 6}\nvar l = [6]float64{1, 2, 3, 4, 5, 6}\nvar m = [6]float64{1, 2, 3, 4, 5, 6}\nvar n = [6]float64{1, 2, 3, 4, 5, 6}\nvar o = [6]float64{1, 2, 3, 4, 5, 6}\nvar p = [6]float64{1, 2, 3, 4, 5, 6}\nvar q = [6]float64{1, 2, 3, 4, 5, 6}\nvar r = [6]"}
{"tgt": "count := 0\nfor _, c := range word {\n\tif unicode.IsUpper(c) {\n\t\tcount++\n\t}\n}\nreturn count == 0 || count == len(word) || (count == 1 && unicode.IsUpper(rune(word[0])))", "gen": "var s string\nvar i int\nfor i, _ = range s {\n\tif unicode.IsUpper(rune(s[i])) {\n\t\ti++\n\t}\n}\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname __morestack runtime.morestack"}
{"tgt": "p.mu.Lock()\nactive := p.active\np.mu.Unlock()\nreturn active", "gen": "var m sync.Mutex\nvar x int\nm.Lock()\nx = 42\nm.Unlock()\nprintln(x)\n}\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 42\n// \tm.Unlock()\n// \tprintln(x)\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 42\n// \tm.Unlock()\n// \tprintln(x)\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 42\n// \tm.Unlock()\n// \tprintln(x)\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 42\n// \tm.Unlock()\n// \tprintln(x)\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 42\n// \tm.Unlock()\n// \tprintln(x)\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 42\n// \tm.Unlock()\n// \tprintln(x)\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 42\n// \tm.Unlock()\n// \tprintln(x)\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int"}
{"tgt": "select {\ncase r, ok := <-p.resources:\n\tlog.Println(\"STR\", \"STR\")\n\tif !ok {\n\t\treturn nil, ErrPoolClosed\n\t}\n\treturn r, nil\ndefault:\n\tlog.Println(\"STR\", \"STR\")\n\treturn p.factory()\n}", "gen": "var c chan int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c"}
{"tgt": "err := ioutil.WriteFile(path, []byte(content), 0755)\nif err != nil {\n\tlog.Fatal(err)\n}", "gen": "var s string\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\n"}
{"tgt": "tree := New(compare)\ntree.Insert(1)\ntree.Insert(2)\ntree.Insert(3)\nfindTree := tree.Search(2)\nif findTree.node != 2 {\n\tt.Error(\"STR\")\n}\nfindNilTree := tree.Search(100)\nif findNilTree != nil {\n\tt.Error(\"STR\")\n}", "gen": "var t testing.T\nvar bt *binaryTree.BinaryTree\nbt = binaryTree.New()\nbt.Insert(1)\nbt.Insert(2)\nbt.Insert(3)\nif bt.Search(1) != 1 {\n\tt.Error(\"Search(1) != 1\")\n}\nif bt.Search(2) != 2 {\n\tt.Error(\"Search(2) != 2\")\n}\nif bt.Search(3) != 3 {\n\tt.Error(\"Search(3) != 3\")\n}\nif bt.Search(4) != nil {\n\tt.Error(\"Search(4) != nil\")\n}\n}\n"}
{"tgt": "l := new(ListNode)\nn := l\nvar extra int\nfor l1 != nil || l2 != nil {\n\tn.Next = new(ListNode)\n\tn = n.Next\n\tif l1 != nil {\n\t\textra += l1.Val\n\t\tl1 = l1.Next\n\t}\n\tif l2 != nil {\n\t\textra += l2.Val\n\t\tl2 = l2.Next\n\t}\n\tn.Val = extra % 10\n\textra /= 10\n}\nif extra > 0 {\n\tn.Next = &ListNode{Val: extra}\n}\nreturn l.Next", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "empty := 0\nhold := -1 << 63\nfor _, p := range prices {\n\ttemp := empty\n\tempty = max(empty, hold+p)\n\thold = max(hold, temp-p-fee)\n}\nreturn empty", "gen": "var a [10]int\nvar b [10]int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar ba int\nvar bb int\nvar bc int\nvar bd int\nvar be int\nvar bf int\nvar bg int\nvar bh int\nvar bi int\nvar bj int\nvar bk int\nvar bl int\nvar bm int\nvar bn int\nvar bo int\nvar bp int\nvar bq int\nvar br int\nvar bs int\nvar bt int\nvar bu int\nvar bv int\nvar bw int\nvar bx int\nvar by int\nvar bz int\nvar ca int\nvar cb int\nvar cc int\nvar cd int\nvar ce int\nvar cf int\nvar cg int\nvar ch int\nvar ci int\nvar cj int\nvar ck int\nvar cl int\nvar cm int\nvar cn int\nvar co int\nvar cp int"}
{"tgt": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"STR\", got, tt.want)\n\t\t}\n\t})\n}", "gen": "tests := []struct {\n\tname string\n\targs []string\n\twant int\n}{\n\t{\"test1\", []string{\"abcde\", \"cdefg\"}, 2},\n\t{\"test2\", []string{\"abcd\", \"cdab\"}, 4},\n\t{\"test3\", []string{\"abcde\", \"fghij\"}, 0},\n\t{\"test4\", []string{\"abcde\", \"abcde\"}, 4},\n\t{\"test5\", []string{\"abcde\", \"abcdefg\"}, 4},\n\t{\"test6\", []string{\"abcde\", \"abcdefgh\"}, 4},\n\t{\"test7\", []string{\"abcde\", \"abcdefghi\"}, 4},\n\t{\"test8\", []string{\"abcde\", \"abcdefghij\"}, 4},\n\t{\"test9\", []string{\"abcde\", \"abcdefghijk\"}, 4},\n\t{\"test10\", []string{\"abcde\", \"abcdefghijkl\"}, 4},\n\t{\"test11\", []string{\"abcde\", \"abcdefghijklm\"}, 4},\n\t{\"test12\", []string{\"abcde\", \"abcdefghijklmn\"}, 4},\n\t{\"test13\", []string{\"abcde\", \"abcdefghijklmno\"}, 4},\n\t{\"test14\", []string{\"abcde\", \"abcdefghijklmnop\"}, 4},\n\t{\"test15\", []string{\"abcde\", \"abcdefghijklmnopq\"}, 4},\n\t{\"test16\", []string{\"abcde\", \"abcdefghijklmnopqr\"}, 4},\n\t{\"test17\", []string{\"abcde\", \"abcdefghijklmnopqrs\"}, 4},\n\t{\"test18\", []string{\"abcde\", \"abcdefghijklmnopqrst\"}, 4},\n\t{\"test19\", []string{\"abcde\", \"abcdefghijklmnopqrstu\"}, 4},\n\t{\"test20\", []string{\"abcde\", \"abc"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   5,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   10,\n\t\twant: 5,\n\t},\n\t{\n\t\tin:   0,\n\t\twant: 1,\n\t},\n}\nfor _, tt := range tests {\n\tgot := bitwiseComplement(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var a, b, c, d int\na = 5\nb = 2\nc = 7\nd = 0\nfmt.Println(bitwiseComplement(a, b, c, d))\n}\n"}
{"tgt": "syscall.Exit(code)", "gen": "for i := 0; i < 1000000000; i++ {\n\tprintln(i)\n}\n}\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```asm\n.LVL1:\nret\n.L6:\npushq %rbp\nmovq %rsp,%rbp\nsubq $16,%rsp\nmovq %rdi,-8(%rbp)\nmovq -8(%rbp),%rax\nmovq %rax,%rdi\ncall <syscall.Exit@PLT>\nleave\nret\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```asm\n.LVL1:\nret\n.L6:\npushq %rbp\nmovq %rsp,%rbp\nsubq $16,%rsp\nmovq %rdi,-8(%rbp)\nmovq -8(%rbp),%rax\nmovq %rax,%rdi\ncall <syscall.Exit@PLT>\nleave\nret\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```asm\n.LVL1:\nret\n.L6:\npushq %rbp\nmovq %rsp,%rbp\nsubq $16,%rsp\nmovq %rdi,-8(%rbp)\nmovq -8(%rbp),%rax\nmovq %rax,%rdi\ncall <syscall.Exit@PLT>\nleave\nret\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```asm\n.LVL1:\nret\n.L6:\npushq %rbp\nmovq %rsp,%rbp\nsubq $16,%rsp\nmovq %rdi,-8(%rbp)\nmovq -8(%rbp),%rax\nmovq %rax,%rdi\ncall <syscall.Exit@PLT>\nleave\nret\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```asm\n.LVL1:\nret\n.L6:\npushq %rbp\nmovq %rsp,%rbp\nsub"}
{"tgt": "if len(input) == 0 {\n\treturn true\n}\nif len(input)%2 != 0 {\n\treturn false\n}\nvar stack []byte\nfor i := 0; i < len(input); i++ {\n\tif input[i] == \"STR\" || input[i] == \"STR\" || input[i] == \"STR\" {\n\t\tstack = append(stack, input[i])\n\t} else {\n\t\tif len(stack) > 0 {\n\t\t\tpair := string(stack[len(stack)-1]) + string(input[i])\n\t\t\tstack = stack[:len(stack)-1]\n\t\t\tif pair != \"STR\" && pair != \"STR\" && pair != \"STR\" {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn len(stack) == 0", "gen": "var s []byte\ns = append(s, 'a')\ns = append(s, 'b')\ns = append(s, 'c')\ns = append(s, 'd')\ns = append(s, 'e')\ns = append(s, 'f')\ns = append(s, 'g')\ns = append(s, 'h')\ns = append(s, 'i')\ns = append(s, 'j')\ns = append(s, 'k')\ns = append(s, 'l')\ns = append(s, 'm')\ns = append(s, 'n')\ns = append(s, 'o')\ns = append(s, 'p')\ns = append(s, 'q')\ns = append(s, 'r')\ns = append(s, 's')\ns = append(s, 't')\ns = append(s, 'u')\ns = append(s, 'v')\ns = append(s, 'w')\ns = append(s, 'x')\ns = append(s, 'y')\ns = append(s, 'z')\ns = append(s, 'A')\ns = append(s, 'B')\ns = append(s, 'C')\ns = append(s, 'D')\ns = append(s, 'E')\ns = append(s, 'F')\ns = append(s, 'G')\ns = append(s, 'H')\ns = append(s, 'I')\ns = append(s, 'J')\ns = append(s, 'K')\ns = append(s, 'L')\ns = append(s, 'M')\ns = append(s, 'N')\ns = append(s, 'O')\ns = append(s, 'P')\ns = append(s, 'Q')\ns = append(s, 'R')\ns = append(s, 'S')"}
{"tgt": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 0},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 11},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 19},\n\t\tans1208{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s, p.t, p.maxCost))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{124123, 13425, 123, 65, 1, 54362, 134, 6543, 213}, 3},\n\t{\"STR\", []int{}, 0},\n\t{\"STR\", []int{4253626756, 3245876, 2345897, 23490}, 1},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "if len(sorted) == 0 {\n\treturn nil\n}\nmid := len(sorted) / 2\nroot := &BST{Value: sorted[mid]}\nroot.Left = SortedSliceToBST(sorted[:mid])\nroot.Right = SortedSliceToBST(sorted[mid+1:])\nreturn root", "gen": "var a [10]int\nvar b *BST\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nb = SortedSliceToBST(a[:], 0, 9)\nfmt.Println(b.data)\n}\n"}
{"tgt": "negative := false\nif num < 0 {\n\tnegative = true\n\tnum = -num\n}\nbf := bytes.NewBufferString(\"STR\")\nfor num >= 7 {\n\tmod := num % 7\n\tnum /= 7\n\tbf.WriteByte(byte(mod) + 48)\n}\nbf.WriteByte(byte(num) + 48)\nif negative {\n\tbf.WriteByte('-')\n}\nbs := bf.Bytes()\nfor s, e := 0, len(bs)-1; s < e; s, e = s+1, e-1 {\n\tbs[s], bs[e] = bs[e], bs[s]\n}\nreturn string(bs)", "gen": "var a [10]byte\nvar b [10]byte\nvar c [10]byte\nvar d [10]byte\nvar e [10]byte\nvar f [10]byte\nvar g [10]byte\nvar h [10]byte\nvar i [10]byte\nvar j [10]byte\nvar k [10]byte\nvar l [10]byte\nvar m [10]byte\nvar n [10]byte\nvar o [10]byte\nvar p [10]byte\nvar q [10]byte\nvar r [10]byte\nvar s [10]byte\nvar t [10]byte\nvar u [10]byte\nvar v [10]byte\nvar w [10]byte\nvar x [10]byte\nvar y [10]byte\nvar z [10]byte\nvar aa [10]byte\nvar bb [10]byte\nvar cc [10]byte\nvar dd [10]byte\nvar ee [10]byte\nvar ff [10]byte\nvar gg [10]byte\nvar hh [10]byte\nvar ii [10]byte\nvar jj [10]byte\nvar kk [10]byte\nvar ll [10]byte\nvar mm [10]byte\nvar nn [10]byte\nvar oo [10]byte\nvar pp [10]byte\nvar qq [10]byte\nvar rr [10]byte\nvar ss [10]byte\nvar tt [10]byte\nvar uu [10]byte\nvar vv [10]byte\nvar ww [10]byte\nvar xx [10]byte\nvar yy [10]byte\nvar zz [10]byte\nvar aaa [10]byte\nvar bbb [10]"}
{"tgt": "s = strings.ToLower(s)\ni, j := 0, len(s)-1\nfor i < j {\n\tfor i < j && !isChar(s[i]) {\n\t\ti++\n\t}\n\tfor i < j && !isChar(s[j]) {\n\t\tj--\n\t}\n\tif s[i] != s[j] {\n\t\treturn false\n\t}\n\ti++\n\tj--\n}\nreturn true", "gen": "fmt.Println(isAnagram(\"anagram\", \"nagaram\"))\n}\n"}
{"tgt": "n := len(nums)\ntmp := make([]int, n)\ncopy(tmp, nums)\nfor i := 0; i < n; i++ {\n\tnums[(i+k)%n] = tmp[i]\n}", "gen": "var a [10]int\nvar b [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + b[i]\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "random := rand.New(rand.NewSource(time.Now().UnixNano()))\narray := make([]int, random.Intn(100-10)+10)\nfor i := range array {\n\tarray[i] = random.Intn(100)\n}\nSortArray(array)\nfor _, value := range array {\n\tresult := ExponentialSearch(array, value)\n\tif result == -1 {\n\t\tt.Fail()\n\t}\n}", "gen": "var t testing.T\nvar a [100]int\nvar b [100]int\nvar c [100]int\nvar d [100]int\nvar e [100]int\nvar f [100]int\nvar g [100]int\nvar h [100]int\nvar i [100]int\nvar j [100]int\nvar k [100]int\nvar l [100]int\nvar m [100]int\nvar n [100]int\nvar o [100]int\nvar p [100]int\nvar q [100]int\nvar r [100]int\nvar s [100]int\nvar t [100]int\nvar u [100]int\nvar v [100]int\nvar w [100]int\nvar x [100]int\nvar y [100]int\nvar z [100]int\nvar aa [100]int\nvar bb [100]int\nvar cc [100]int\nvar dd [100]int\nvar ee [100]int\nvar ff [100]int\nvar gg [100]int\nvar hh [100]int\nvar ii [100]int\nvar jj [100]int\nvar kk [100]int\nvar ll [100]int\nvar mm [100]int\nvar nn [100]int\nvar oo [100]int\nvar pp [100]int\nvar qq [100]int\nvar rr [100]int\nvar ss [100]int\nvar tt [100]int\nvar uu [100]int\nvar vv [100]int\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimumPartitionPalindrome(tc.input); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "obj := Constructor732()\nfmt.Printf(\"STR\", obj.Book(10, 20))\nfmt.Printf(\"STR\", obj.Book(50, 60))\nfmt.Printf(\"STR\", obj.Book(10, 40))\nfmt.Printf(\"STR\", obj.Book(5, 15))\nfmt.Printf(\"STR\", obj.Book(5, 10))\nfmt.Printf(\"STR\", obj.Book(25, 55))", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "if a == nil && b == nil {\n\treturn true\n}\nif len(a) != len(b) {\n\treturn false\n}\nfor i := range a {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "val := \"STR\"\nfor i := 1; i < n; i++ {\n\tvar (\n\t\tc   int\n\t\tv   byte\n\t\tstr string\n\t)\n\tfor j := 0; j < len(val); j++ {\n\t\tif val[j] == v {\n\t\t\tc++\n\t\t\tcontinue\n\t\t}\n\t\tif c != 0 {\n\t\t\tstr += string(c+'0') + string(v)\n\t\t}\n\t\tc, v = 1, val[j]\n\t}\n\tval = str + string(c+'0') + string(v)\n}\nreturn val", "gen": "var s string\nfor i := 0; i < 1000000; i++ {\n\ts += fmt.Sprintf(\"%d\", i)\n}\nfmt.Println(s)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "res := 0\nif n != 0 {\n\trightMostBitInt := n & -n\n\tnextHigherSetBitInt := n + rightMostBitInt\n\td := n ^ nextHigherSetBitInt\n\td /= rightMostBitInt\n\td >>= 2\n\tres = nextHigherSetBitInt | d\n}\nreturn res", "gen": "var a int64 = 1\nvar b int64 = 2\nvar c int64 = 3\nvar d int64 = 4\nvar e int64 = 5\nvar f int64 = 6\nvar g int64 = 7\nvar h int64 = 8\nvar i int64 = 9\nvar j int64 = 10\nvar k int64 = 11\nvar l int64 = 12\nvar m int64 = 13\nvar n int64 = 14\nvar o int64 = 15\nvar p int64 = 16\nvar q int64 = 17\nvar r int64 = 18\nvar s int64 = 19\nvar t int64 = 20\nvar u int64 = 21\nvar v int64 = 22\nvar w int64 = 23\nvar x int64 = 24\nvar y int64 = 25\nvar z int64 = 26\nvar aa int64 = 27\nvar bb int64 = 28\nvar cc int64 = 29\nvar dd int64 = 30\nvar ee int64 = 31\nvar ff int64 = 32\nvar gg int64 = 33\nvar hh int64 = 34\nvar ii int64 = 35\nvar jj int64 = 36\nvar kk int64 = 37\nvar ll int64 = 38\nvar mm int64 = 39\nvar nn int64 = 40\nvar oo int64 = 41\nvar pp int64 = 42\nvar qq int64 = 43\nvar rr int64 = 44\nvar ss int64 = 45\nvar tt int"}
{"tgt": "if len(nums) == 0 || len(nums) < k {\n\treturn make([]int, 0)\n}\nqueue := make([]int, 0, k)\nans := make([]int, len(nums)-k+1)\nfor left, right := 1-k, 0; right < len(nums); left, right = left+1, right+1 {\n\tif left > 0 && queue[0] == nums[left-1] {\n\t\tqueue = queue[1:len(queue)]\n\t}\n\tfor len(queue) != 0 && queue[len(queue)-1] < nums[right] {\n\t\tqueue = queue[:len(queue)-1]\n\t}\n\tqueue = append(queue, nums[right])\n\tif left >= 0 {\n\t\tans[left] = queue[0]\n\t}\n}\nreturn ans", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{}\n} else if n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{intervals[0]}\nfor _, cur := range intervals[1:] {\n\tprevious := res[len(res)-1]\n\tif cur.Start <= previous.End {\n\t\tend := previous.End\n\t\tif cur.End > end {\n\t\t\tend = cur.End\n\t\t}\n\t\tres = append(res[:len(res)-1], Interval{Start: previous.Start, End: end})\n\t} else {\n\t\tres = append(res, cur)\n\t}\n}\nreturn res", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "max := 9999\nbiggestPandigital := 0\nvar numberMultiplied int\nfor i := max; i > 0; i-- {\n\tnumberMultiplied = i\n\tfor j := 1; len(digits(numberMultiplied)) <= 9; j++ {\n\t\tnumberMultiplied = concatenMultiplication(i, j)\n\t\tif IsPandigital(numberMultiplied) && numberMultiplied > biggestPandigital {\n\t\t\tfmt.Println(numberMultiplied)\n\t\t\tbiggestPandigital = numberMultiplied\n\t\t}\n\t}\n}", "gen": "var a, b int\nfmt.Scan(&a, &b)\nfmt.Println(a * b)\n}\n"}
{"tgt": "n := len(pushed)\ns := make([]int, 0, n)\ni := 0\nfor _, x := range pushed {\n\ts = append(s, x)\n\tfor len(s) != 0 && s[len(s)-1] == popped[i] {\n\t\ts = s[:len(s)-1]\n\t\ti++\n\t}\n}\nreturn i == n", "gen": "var a [10]int\nvar b [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = b[i]\n}\nif a[0] != 0 {\n\tpanic(\"a[0] != 0\")\n}\nif a[1] != 1 {\n\tpanic(\"a[1] != 1\")\n}\nif a[2] != 2 {\n\tpanic(\"a[2] != 2\")\n}\nif a[3] != 3 {\n\tpanic(\"a[3] != 3\")\n}\nif a[4] != 4 {\n\tpanic(\"a[4] != 4\")\n}\nif a[5] != 5 {\n\tpanic(\"a[5] != 5\")\n}\nif a[6] != 6 {\n\tpanic(\"a[6] != 6\")\n}\nif a[7] != 7 {\n\tpanic(\"a[7] != 7\")\n}\nif a[8] != 8 {\n\tpanic(\"a[8] != 8\")\n}\nif a[9] != 9 {\n\tpanic(\"a[9] != 9\")\n}\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname __morestack runtime.morestack"}
{"tgt": "testCases := [][]int{\n\t{1, 2, 3, 1},\n\t{1, 0, 1, 1},\n\t{1, 2, 3, 1, 2, 3},\n}\nks := []int{3, 1, 2}\nexpected := []bool{true, true, false}\nfor index, nums := range testCases {\n\tif res := containsNearbyDuplicate(nums, ks[index]); res != expected[index] {\n\t\tt.Errorf(\"STR\", expected[index], res)\n\t}\n}", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i + 1\n}\nfor i := 0; i < 10; i++ {\n\tif a[i] != i+1 {\n\t\tpanic(\"bad\")\n\t}\n}\nvar b [10]interface{}\nfor i := 0; i < 10; i++ {\n\tb[i] = i + 1\n}\nfor i := 0; i < 10; i++ {\n\tif b[i] != i+1 {\n\t\tpanic(\"bad\")\n\t}\n}\nvar c [10]bool\nfor i := 0; i < 10; i++ {\n\tc[i] = i%2 == 0\n}\nfor i := 0; i < 10; i++ {\n\tif c[i] != (i%2 == 0) {\n\t\tpanic(\"bad\")\n\t}\n}\nvar d [10]bool\nfor i := 0; i < 10; i++ {\n\td[i] = i%2 == 0\n}\nfor i := 0; i < 10; i++ {\n\tif d[i] != (i%2 == 0) {\n\t\tpanic(\"bad\")\n\t}\n}\nvar e [10]bool\nfor i := 0; i < 10; i++ {\n\te[i] = i%2 == 0\n}\nfor i := 0; i < 10; i++ {\n\tif e[i] != (i%2 == 0) {\n\t\tpanic(\"bad\")\n\t}\n}\nvar f [10]bool\nfor i := 0; i < 10; i++ {\n\tf[i] = i%2 == 0\n}\n"}
{"tgt": "item := req.URL.Query().Get(\"STR\")\nif price, ok := db[item]; ok {\n\tfmt.Fprintf(w, \"STR\", price)\n} else {\n\tw.WriteHeader(http.StatusNotFound)\n\tfmt.Fprintf(w, \"STR\", item)\n}", "gen": "var url = \"http://www.baidu.com/s?wd=golang\"\nvar query = url.Query()\nvar v = query.Get(\"wd\")\nfmt.Println(v)\n}\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```\n<ASM>\nleaq -440(%rsp),%r11\ncmpq %fs:112,%r11\njnb .L29\nmovl $440,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL2:\nret\n.L29:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $392,%rsp\nmovq %rdi,-328(%rbp)\nmovq %rsi,%rax\nmovq %rdx,%rsi\nmovq %rsi,%rdx\nmovq %rax,-352(%rbp)\nmovq %rdx,-344(%rbp)\nmovq %rcx,-336(%rbp)\nmovq -328(%rbp),%rax\nmovq %rax,-56(%rbp)\n.LBB19:\nmovq -336(%rbp),%rax\nmovq <16>(%rax),%rax\nmovq %rax,%rdi\ncall <net..z2furl.URL.Query@PLT>\nmovq %rax,%rdi\nleaq <.LC37>(%rip),%r12\nmovl $4,%r13d\nmovq %r12,%rcx\nmovq %r13,%rbx\nmovq %r12,%rax\nmovq %r13,%rdx\nmovq %rdx,%rax\nmovq %rcx,%rsi\nmovq %rax,%rdx\ncall <net..z2furl.Values.Get"}
{"tgt": "l, r := &maxHeap{}, &minHeap{}\nheap.Init(l)\nheap.Init(r)\nreturn MedianFinder{l, r}", "gen": "fmt.Println(maxHeap.Len())\nfmt.Println(minHeap.Len())\nmaxHeap.Push(1)\nmaxHeap.Push(2)\nmaxHeap.Push(3)\nmaxHeap.Push(4)\nmaxHeap.Push(5)\nmaxHeap.Push(6)\nmaxHeap.Push(7)\nmaxHeap.Push(8)\nmaxHeap.Push(9)\nmaxHeap.Push(10)\nmaxHeap.Push(11)\nmaxHeap.Push(12)\nmaxHeap.Push(13)\nmaxHeap.Push(14)\nmaxHeap.Push(15)\nmaxHeap.Push(16)\nmaxHeap.Push(17)\nmaxHeap.Push(18)\nmaxHeap.Push(19)\nmaxHeap.Push(20)\nmaxHeap.Push(21)\nmaxHeap.Push(22)\nmaxHeap.Push(23)\nmaxHeap.Push(24)\nmaxHeap.Push(25)\nmaxHeap.Push(26)\nmaxHeap.Push(27)\nmaxHeap.Push(28)\nmaxHeap.Push(29)\nmaxHeap.Push(30)\nmaxHeap.Push(31)\nmaxHeap.Push(32)\nmaxHeap.Push(33)\nmaxHeap.Push(34)\nmaxHeap.Push(35)\nmaxHeap.Push(36)\nmaxHeap.Push(37)\nmaxHeap.Push(38)\nmaxHeap.Push(39)\nmaxHeap.Push(40)\nmaxHeap.Push(41)\nmaxHeap.Push(42)\nmaxHeap.Push(43)\nmaxHeap.Push(44)"}
{"tgt": "var buf [32]byte\ni := len(buf) - 1\nfor val >= 10 {\n\tbuf[i] = byte(val%10 + \"STR\")\n\ti--\n\tval /= 10\n}\nbuf[i] = byte(val + \"STR\")\nreturn string(buf[i:])", "gen": "var s []byte\ns = make([]byte, 100)\ns[100] = 1\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(nums1) == 0 || len(nums2) == 0 {\n\treturn []int{}\n}\nnum1Map := make(map[int]bool)\nfor i := range nums1 {\n\tnum1Map[nums1[i]] = true\n}\nnum2Map := make(map[int]bool)\nvar res []int\nfor i := range nums2 {\n\tif _, ok1 := num1Map[nums2[i]]; ok1 && !num2Map[nums2[i]] {\n\t\tnum2Map[nums2[i]] = true\n\t\tres = append(res, nums2[i])\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [4]int\nvar c [5]int\nvar d [6]int\nvar e [7]int\nvar f [8]int\nvar g [9]int\nvar h [10]int\nvar i [11]int\nvar j [12]int\nvar k [13]int\nvar l [14]int\nvar m [15]int\nvar n [16]int\nvar o [17]int\nvar p [18]int\nvar q [19]int\nvar r [20]int\nvar s [21]int\nvar t [22]int\nvar u [23]int\nvar v [24]int\nvar w [25]int\nvar x [26]int\nvar y [27]int\nvar z [28]int\nvar aa [29]int\nvar ab [30]int\nvar ac [31]int\nvar ad [32]int\nvar ae [33]int\nvar af [34]int\nvar ag [35]int\nvar ah [36]int\nvar ai [37]int\nvar aj [38]int\nvar ak [39]int\nvar al [40]int\nvar am [41]int\nvar an [42]int\nvar ao [43]int\nvar ap [44]int\nvar aq [45]int\nvar ar [46]int\nvar as [47]int\nvar at [48]int\nvar au [49]int\nvar av [50]int\nvar aw [51]int\nvar ax [52]int\nvar ay [53]int\nvar az [54]int\nvar ba [55]int\nvar bb [56]int\nvar bc [57]int\nvar bd [58]"}
{"tgt": "var ret [][]int\nvar nums []int\nnums = []int{-1, 0, 1, 2, -1, -4}\nret = [][]int{{-1, -1, 2}, {-1, 0, 1}}\nfor k, num := range threeSum(nums) {\n\tfor i, v := range num {\n\t\tif v != ret[k][i] {\n\t\t\tt.Fatalf(\"STR\", ret)\n\t\t}\n\t}\n}", "gen": "var a [3]int\na[0] = 0\na[1] = 1\na[2] = 2\nvar b [3]int\nb[0] = -1\nb[1] = -1\nb[2] = 2\nvar c [3]int\nc[0] = -1\nc[1] = -4\nc[2] = 2\nvar d [3]int\nd[0] = -1\nd[1] = -1\nd[2] = 2\nvar e [3]int\ne[0] = -1\ne[1] = -1\ne[2] = 2\nvar f [3]int\nf[0] = -1\nf[1] = -1\nf[2] = 2\nvar g [3]int\ng[0] = -1\ng[1] = -4\ng[2] = 2\nvar h [3]int\nh[0] = -1\nh[1] = -1\nh[2] = 2\nvar i [3]int\ni[0] = -1\ni[1] = -1\ni[2] = 2\nvar j [3]int\nj[0] = -1\nj[1] = -1\nj[2] = 2\nvar k [3]int\nk[0] = -1\nk[1] = -4\nk[2] = 2\nvar l [3]int\nl[0] = -1\nl[1] = -1\nl[2] = 2\nvar m [3]int\nm[0] = -1\nm[1] = -1\nm[2] = 2\nvar n [3]int\nn[0] = -1\nn[1] = -1\nn[2] = 2\nvar o [3]int\no"}
{"tgt": "dist := make([]int, N+1)\nfor i := 0; i < len(dist); i++ {\n\tdist[i] = math.MaxInt32\n}\ndist[K] = 0\nfor i := 0; i < N; i++ {\n\tfor _, t := range times {\n\t\tu, v, w := t[0], t[1], t[2]\n\t\tif dist[u] != math.MaxInt32 && dist[v] > dist[u]+w {\n\t\t\tdist[v] = dist[u] + w\n\t\t}\n\t}\n}\nmx := 0\nfor i := 1; i <= N; i++ {\n\tif mx < dist[i] {\n\t\tmx = dist[i]\n\t}\n}\nif mx == math.MaxInt32 {\n\treturn -1\n}\nreturn mx", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "dat, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\nnamesList := string(dat)\nnamesList = strings.Replace(namesList, \"STR\", \"STR\", -1)\nnames := strings.Split(namesList, \"STR\")\nsort.Strings(names)\nnamesScore := 0\nfor index, name := range names {\n\tnamesScore += nameScore(name) * (index + 1)\n}\nfmt.Println(namesScore)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\n"}
{"tgt": "var matrix [][]int\nmatrix = [][]int{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 9},\n}\nrotate(matrix)", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nrotate(a, 3)\nfmt.Println(a)\n}\n"}
{"tgt": "curr := n\nfor _, c := range s {\n\tnext, ok := curr.children[c]\n\tif !ok {\n\t\tnext = NewNode()\n\t\tcurr.children[c] = next\n\t}\n\tcurr = next\n}\ncurr.isLeaf = true", "gen": "var s string\nvar i int\nfor i = 0; i < 1000000; i++ {\n\ts += \"a\"\n}\nfmt.Println(s)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "sum := 0\nfor i := 2; i < 999999; i++ {\n\tif isSumOfFivePowerOfDigitsEqualToNumber(i) {\n\t\tsum += i\n\t}\n}\nreturn sum", "gen": "fmt.Println(isSumOfFivePowerOfDigitsEqualToNumber(153))\nfmt.Println(isSumOfFivePowerOfDigitsEqualToNumber(1024))\nfmt.Println(isSumOfFivePowerOfDigitsEqualToNumber(1000000))\nfmt.Println(isSumOfFivePowerOfDigitsEqualToNumber(1000000000))\nfmt.Println(isSumOfFivePowerOfDigitsEqualToNumber(1000000000000))\nfmt.Println(isSumOfFivePowerOfDigitsEqualToNumber(1000000000000000))\nfmt.Println(isSumOfFivePowerOfDigitsEqualToNumber(1000000000000000000))\nfmt.Println(isSumOfFivePowerOfDigitsEqualToNumber(10000000000000000000000))\nfmt.Println(isSumOfFivePowerOfDigitsEqualToNumber(1000000000000000000000000000))\nfmt.Println(isSumOfFivePowerOfDigitsEqualToNumber(1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}
{"tgt": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nret := &ListNode{}\nif l1.Val <= l2.Val {\n\tret = l1\n\tret.Next = mergeTwoLists1(l1.Next, l2)\n} else {\n\tret = l2\n\tret.Next = mergeTwoLists1(l1, l2.Next)\n}\nreturn ret", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "a := int(math.Log10(float64(number))) + 1\nresult := 0\nfor i := 1; i <= a; i++ {\n\tresult += digit(number, i) * int(math.Pow10(a-i))\n}\nreturn result", "gen": "var x float64\nfmt.Scan(&x)\nfmt.Println(digit(x))\n}"}
{"tgt": "maxans := 0\ndp := make([]int, len(s))\nfor i := 1; i < len(s); i++ {\n\tif s[i] == \"STR\" {\n\t\tif s[i-1] == \"STR\" {\n\t\t\tif i >= 2 {\n\t\t\t\tdp[i] = dp[i-2] + 2\n\t\t\t} else {\n\t\t\t\tdp[i] = 2\n\t\t\t}\n\t\t} else if i-dp[i-1] > 0 && s[i-dp[i-1]-1] == \"STR\" {\n\t\t\tif i-dp[i-1] >= 2 {\n\t\t\t\tdp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2\n\t\t\t} else {\n\t\t\t\tdp[i] = dp[i-1] + 2\n\t\t\t}\n\t\t}\n\t}\n\tmaxans = Max(maxans, dp[i])\n}\nreturn maxans", "gen": "var s Solution\nvar nums = []int{3, 2, 1}\nfmt.Println(s.MaxProfit(nums))\n}\n"}
{"tgt": "s.lock.Lock()\ndefer s.lock.Unlock()\nl := len(s.nodes)\nif l == 0 {\n\treturn nil, errors.New(\"STR\")\n}\nnode := s.nodes[l-1]\ns.nodes = s.nodes[:l-1]\nreturn node, nil", "gen": "var s Solution\ns.SolveNQueens(4)\n}\n"}
{"tgt": "max1, max2, max3, min1, min2 := -1001, -1001, -1001, 1001, 1001\nfor _, v := range nums {\n\tif v > max1 {\n\t\tmax3 = max2\n\t\tmax2 = max1\n\t\tmax1 = v\n\t} else if v > max2 {\n\t\tmax3 = max2\n\t\tmax2 = v\n\t} else if v > max3 {\n\t\tmax3 = v\n\t}\n\tif v < min1 {\n\t\tmin2 = min1\n\t\tmin1 = v\n\t} else if v < min2 {\n\t\tmin2 = v\n\t}\n}\nreturn max(max1*min1*min2, max1*max2*max3)", "gen": "var a [4]int\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 4\nvar b [4]int\nb[0] = 1\nb[1] = 2\nb[2] = 3\nb[3] = 4\nvar c [4]int\nc[0] = 1\nc[1] = 2\nc[2] = 3\nc[3] = 4\nvar d [4]int\nd[0] = 1\nd[1] = 2\nd[2] = 3\nd[3] = 4\nvar e [4]int\ne[0] = 1\ne[1] = 2\ne[2] = 3\ne[3] = 4\nvar f [4]int\nf[0] = 1\nf[1] = 2\nf[2] = 3\nf[3] = 4\nvar g [4]int\ng[0] = 1\ng[1] = 2\ng[2] = 3\ng[3] = 4\nvar h [4]int\nh[0] = 1\nh[1] = 2\nh[2] = 3\nh[3] = 4\nvar i [4]int\ni[0] = 1\ni[1] = 2\ni[2] = 3\ni[3] = 4\nvar j [4]int\nj[0] = 1\nj[1] = 2\nj[2] = 3\nj[3] = 4\nvar k [4]int\nk[0] = 1\nk[1] = 2\nk[2] = 3\nk[3] = 4\nvar l [4]int\nl[0] = 1"}
{"tgt": "h := fnv.New64a()\n_, _ = h.Write([]byte(fmt.Sprintf(\"STR\", key)))\nhashValue := h.Sum64()\nreturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))", "gen": "var a, b int\nfmt.Scan(&a, &b)\nfmt.Println(a + b)\n}\n"}
{"tgt": "arr := make([]int, n+1, n+1)\narr[0] = 0\narr[1] = 1\nfor x := 2; x <= n; x++ {\n\tarr[x] = -1\n}\nreturn fibonacciDyamic(n, arr)", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = fibonacciDyamic(i)\n}\nfmt.Println(a)\n}\n"}
{"tgt": "*ss = Count{\n\tolist: make([]countBucket, size),\n\thash:  make(map[string]uint32, size),\n}\nreturn ss", "gen": "var m map[string]uint32\nm = make(map[string]uint32)\nm[\"a\"] = 1\nm[\"b\"] = 2\nm[\"c\"] = 3\nm[\"d\"] = 4\nm[\"e\"] = 5\nm[\"f\"] = 6\nm[\"g\"] = 7\nm[\"h\"] = 8\nm[\"i\"] = 9\nm[\"j\"] = 10\nm[\"k\"] = 11\nm[\"l\"] = 12\nm[\"m\"] = 13\nm[\"n\"] = 14\nm[\"o\"] = 15\nm[\"p\"] = 16\nm[\"q\"] = 17\nm[\"r\"] = 18\nm[\"s\"] = 19\nm[\"t\"] = 20\nm[\"u\"] = 21\nm[\"v\"] = 22\nm[\"w\"] = 23\nm[\"x\"] = 24\nm[\"y\"] = 25\nm[\"z\"] = 26\nm[\"aa\"] = 27\nm[\"bb\"] = 28\nm[\"cc\"] = 29\nm[\"dd\"] = 30\nm[\"ee\"] = 31\nm[\"ff\"] = 32\nm[\"gg\"] = 33\nm[\"hh\"] = 34\nm[\"ii\"] = 35\nm[\"jj\"] = 36\nm[\"kk\"] = 37\nm[\"ll\"] = 38\nm[\"mm\"] = 39\nm[\"nn\"] = 40\nm[\"oo\"] = 41\nm[\"pp\"] = 42\nm[\"qq\"] = 43\nm[\"rr\"] = 44\nm[\"ss\"] = 45\nm[\"tt\"] = 46\nm[\"uu\"] = 47\nm[\"vv\"] = 48\n"}
{"tgt": "if len(nums) == 0 {\n\treturn 0\n} else if len(nums) == 1 {\n\treturn nums[0]\n}\nmax := func(m, n int) int {\n\tif m > n {\n\t\treturn m\n\t}\n\treturn n\n}\ndp := []int{nums[0], max(nums[0], nums[1])}\nfor i := 2; i < len(nums); i++ {\n\tdp[i%2] = max(dp[(i-1)%2], nums[i]+dp[i%2])\n}\nreturn dp[(len(nums)-1)%2]", "gen": "fmt.Println(rob([]int{2, 3, 2}))\nfmt.Println(rob([]int{1, 2, 3, 1}))\nfmt.Println(rob([]int{2, 7, 9, 3, 1}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{1, 2, 3, 1}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{1, 2, 3, 1}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, "}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CanHopToEnd(tc.hops); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.hops, tc.expected, result)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "n := NewNode()\ninsertWords := [...]string{\n\t\"STR\",\n\t\"STR\",\n}\ncheckWords := map[string]bool{\n\t\"STR\": false,\n\t\"STR\": false,\n\t\"STR\": true,\n}\nfor _, w := range insertWords {\n\tn.Insert(w)\n\tt.Logf(\n\t\t\"STR\",\n\t\tw,\n\t)\n}\nfor k, v := range checkWords {\n\tok := n.Find(k)\n\tif ok != v {\n\t\tt.Fatalf(\n\t\t\t\"STR\",\n\t\t\tk,\n\t\t\tmap[bool]string{true: \"STR\"}[v],\n\t\t)\n\t}\n\tt.Logf(\n\t\t\"STR\",\n\t\tk,\n\t\tmap[bool]string{true: \"STR\"}[ok],\n\t)\n}", "gen": "trie := NewNode()\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\","}
{"tgt": "if cl.Size > 0 {\n\tif places < 0 {\n\t\tmultiple := cl.Size - 1 - places/cl.Size\n\t\tplaces += multiple * cl.Size\n\t}\n\tplaces %= cl.Size\n\tif places > cl.Size/2 {\n\t\tplaces = cl.Size - places\n\t\tfor i := 0; i < places; i++ {\n\t\t\tcl.Head = cl.Head.Prev\n\t\t}\n\t} else if places == 0 {\n\t\treturn\n\t} else {\n\t\tfor i := 0; i < places; i++ {\n\t\t\tcl.Head = cl.Head.Next\n\t\t}\n\t}\n}", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "s.lock.Lock()\ndefer s.lock.Unlock()\nreturn s.len", "gen": "var m sync.Mutex\ndefer m.Unlock()\ndefer func() {\n\tif recover() != nil {\n\t\tpanic(\"panic\")\n\t}\n}()\nvar x int\nx = 0\nx = 1\nx = 2\nx = 3\nx = 4\nx = 5\nx = 6\nx = 7\nx = 8\nx = 9\nx = 10\nx = 11\nx = 12\nx = 13\nx = 14\nx = 15\nx = 16\nx = 17\nx = 18\nx = 19\nx = 20\nx = 21\nx = 22\nx = 23\nx = 24\nx = 25\nx = 26\nx = 27\nx = 28\nx = 29\nx = 30\nx = 31\nx = 32\nx = 33\nx = 34\nx = 35\nx = 36\nx = 37\nx = 38\nx = 39\nx = 40\nx = 41\nx = 42\nx = 43\nx = 44\nx = 45\nx = 46\nx = 47\nx = 48\nx = 49\nx = 50\nx = 51\nx = 52\nx = 53\nx = 54\nx = 55\nx = 56\nx = 57\nx = 58\nx = 59\nx = 60\nx = 61\nx = 62\nx = 63\nx = 6"}
{"tgt": "return fmt.Sprintf(\"STR\", p.Name, p.Age)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aaa int\nvar bbb int\nvar ccc int\nvar ddd int\nvar eee int\nvar fff int\nvar ggg int\nvar hhh int\nvar iii int\nvar jjj int\nvar kkk int\nvar lll int\nvar mmm int\nvar nnn int\nvar ooo int\nvar ppp int\nvar qqq int\nvar rrr int\nvar sss int\nvar ttt int\nvar uuu int\nvar vvv int\nvar www int\nvar xxx int\nvar yyy int\nvar zzz int\nvar aaaa int\nvar bbbb int\nvar cccc int\nvar dddd int\nvar eeee int\nvar ffff int\nvar gggg int\nvar hhhh int\nvar iiii int\nvar jjjj int\n"}
{"tgt": "if n < 2 {\n\treturn 1\n}\nrec := make([]int, n+1)\nrec[0], rec[1] = 1, 1\nfor i := 2; i <= n; i++ {\n\trec[i] = rec[i-1] + rec[i-2]\n}\nreturn rec[n]", "gen": "var a [10]int\na[1] = 1\na[2] = 2\na[3] = 3\na[4] = 4\na[5] = 5\na[6] = 6\na[7] = 7\na[8] = 8\na[9] = 9\na[10] = 10\na[11] = 11\na[12] = 12\na[13] = 13\na[14] = 14\na[15] = 15\na[16] = 16\na[17] = 17\na[18] = 18\na[19] = 19\na[20] = 20\na[21] = 21\na[22] = 22\na[23] = 23\na[24] = 24\na[25] = 25\na[26] = 26\na[27] = 27\na[28] = 28\na[29] = 29\na[30] = 30\na[31] = 31\na[32] = 32\na[33] = 33\na[34] = 34\na[35] = 35\na[36] = 36\na[37] = 37\na[38] = 38\na[39] = 39\na[40] = 40\na[41] = 41\na[42] = 42\na[43] = 43\na[44] = 44\na[45] = 45\na[46] = 46\na["}
{"tgt": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\ntmp := nums[0]\nmax := tmp\nfor i := 1; i < n; i++ {\n\tif tmp < 0 {\n\t\ttmp = nums[i]\n\t} else {\n\t\ttmp += nums[i]\n\t}\n\tif max < tmp {\n\t\tmax = tmp\n\t}\n}\nreturn max", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor"}
{"tgt": "return syscall.Getgid()", "gen": "fmt.Println(syscall.Getgid())\n}\n\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n// 0x1000000000000000\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tarr1   []int\n\tarr2   []int\n\td      int\n\texpect int\n}{\n\t{\"STR\", []int{4, 5, 8}, []int{10, 9, 1, 8}, 2, 2},\n\t{\"STR\", []int{1, 4, 2, 3}, []int{-4, -3, 6, 10, 20, 30}, 3, 2},\n\t{\"STR\", []int{2, 1, 100, 3}, []int{-5, -2, 10, -3, 7}, 6, 1},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.arr1, c.arr2, c.d)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.arr1, c.arr2, c.d)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "if h.Count != 0 {\n\tfor i := 0; i < int(h.Cap); i++ {\n\t\thashValue := h.hash(key, uint32(i))\n\t\tif h.backets[hashValue] != nil && h.backets[hashValue].Key == key {\n\t\t\treturn h.backets[hashValue].Value, h.backets[hashValue].exist\n\t\t}\n\t}\n}\nreturn nil, false", "gen": "var m map[string]int\nm = make(map[string]int)\nm[\"a\"] = 1\nm[\"b\"] = 2\nm[\"c\"] = 3\nm[\"d\"] = 4\nm[\"e\"] = 5\nm[\"f\"] = 6\nm[\"g\"] = 7\nm[\"h\"] = 8\nm[\"i\"] = 9\nm[\"j\"] = 10\nm[\"k\"] = 11\nm[\"l\"] = 12\nm[\"m\"] = 13\nm[\"n\"] = 14\nm[\"o\"] = 15\nm[\"p\"] = 16\nm[\"q\"] = 17\nm[\"r\"] = 18\nm[\"s\"] = 19\nm[\"t\"] = 20\nm[\"u\"] = 21\nm[\"v\"] = 22\nm[\"w\"] = 23\nm[\"x\"] = 24\nm[\"y\"] = 25\nm[\"z\"] = 26\nm[\"aa\"] = 27\nm[\"bb\"] = 28\nm[\"cc\"] = 29\nm[\"dd\"] = 30\nm[\"ee\"] = 31\nm[\"ff\"] = 32\nm[\"gg\"] = 33\nm[\"hh\"] = 34\nm[\"ii\"] = 35\nm[\"jj\"] = 36\nm[\"kk\"] = 37\nm[\"ll\"] = 38\nm[\"mm\"] = 39\nm[\"nn\"] = 40\nm[\"oo\"] = 41\nm[\"pp\"] = 42\nm[\"qq\"] = 43\nm[\"rr\"] = 44\nm[\"ss\"] = 45\nm[\"tt\"] = 46\nm[\"uu\"] = 47\nm[\"vv\"] = 48\nm[\"ww\"]"}
{"tgt": "l1 := len(board)\nif l1 == 0 {\n\treturn\n}\nl2 := len(board[0])\nif l2 == 0 {\n\treturn\n}\nvisit := make([][]bool, l1)\nfor i := 0; i < l1; i++ {\n\tvisit[i] = make([]bool, l2)\n}\nfor i := 0; i < l1; i++ {\n\tfor j := 0; j < l2; j++ {\n\t\tif !visit[i][j] {\n\t\t\thelper(board, visit, i, j)\n\t\t}\n\t}\n}", "gen": "var a [10]bool\nvar b [10]bool\nvar c [10]bool\nvar d [10]bool\nvar e [10]bool\nvar f [10]bool\nvar g [10]bool\nvar h [10]bool\nvar i [10]bool\nvar j [10]bool\nvar k [10]bool\nvar l [10]bool\nvar m [10]bool\nvar n [10]bool\nvar o [10]bool\nvar p [10]bool\nvar q [10]bool\nvar r [10]bool\nvar s [10]bool\nvar t [10]bool\nvar u [10]bool\nvar v [10]bool\nvar w [10]bool\nvar x [10]bool\nvar y [10]bool\nvar z [10]bool\nvar aa [10]bool\nvar ab [10]bool\nvar ac [10]bool\nvar ad [10]bool\nvar ae [10]bool\nvar af [10]bool\nvar ag [10]bool\nvar ah [10]bool\nvar ai [10]bool\nvar aj [10]bool\nvar ak [10]bool\nvar al [10]bool\nvar am [10]bool\nvar an [10]bool\nvar ao [10]bool\nvar ap [10]bool\nvar aq [10]bool\nvar ar [10]bool\nvar as [10]bool\nvar at [10]bool\nvar au [10]bool\nvar av [10]bool\nvar aw [10]bool\nvar ax [10]bool\nvar ay [10]bool\nvar az [10]bool\nvar ba [10]bool\nvar bb [10]bool\nvar bc [10]bool\n"}
{"tgt": "return me[0] == \"STR\"", "gen": "var a [10]int\na[1] = 1\na[2] = 2\na[3] = 3\na[4] = 4\na[5] = 5\na[6] = 6\na[7] = 7\na[8] = 8\na[9] = 9\na[10] = 10\na[11] = 11\na[12] = 12\na[13] = 13\na[14] = 14\na[15] = 15\na[16] = 16\na[17] = 17\na[18] = 18\na[19] = 19\na[20] = 20\na[21] = 21\na[22] = 22\na[23] = 23\na[24] = 24\na[25] = 25\na[26] = 26\na[27] = 27\na[28] = 28\na[29] = 29\na[30] = 30\na[31] = 31\na[32] = 32\na[33] = 33\na[34] = 34\na[35] = 35\na[36] = 36\na[37] = 37\na[38] = 38\na[39] = 39\na[40] = 40\na[41] = 41\na[42] = 42\na[43] = 43\na[44] = 44\na[45] = 45\na[46] = 46\na["}
{"tgt": "if len(intervals) <= 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i][0] <= intervals[j][0]\n})\nresult := make([][]int, 0)\ncur := intervals[0]\nfor i := 1; i < len(intervals); i++ {\n\tif intervals[i][0] > cur[1] {\n\t\tresult = append(result, cur)\n\t\tcur = intervals[i]\n\t} else {\n\t\tcur[1] = int(math.Max(float64(cur[1]), float64(intervals[i][1])))\n\t}\n}\nresult = append(result, cur)\nreturn result", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "return Frame{}, false", "gen": "var a [4]int\nvar b [4]int\nvar c [4]int\nvar d [4]int\nvar e [4]int\nvar f [4]int\nvar g [4]int\nvar h [4]int\nvar i [4]int\nvar j [4]int\nvar k [4]int\nvar l [4]int\nvar m [4]int\nvar n [4]int\nvar o [4]int\nvar p [4]int\nvar q [4]int\nvar r [4]int\nvar s [4]int\nvar t [4]int\nvar u [4]int\nvar v [4]int\nvar w [4]int\nvar x [4]int\nvar y [4]int\nvar z [4]int\nvar aa [4]int\nvar ab [4]int\nvar ac [4]int\nvar ad [4]int\nvar ae [4]int\nvar af [4]int\nvar ag [4]int\nvar ah [4]int\nvar ai [4]int\nvar aj [4]int\nvar ak [4]int\nvar al [4]int\nvar am [4]int\nvar an [4]int\nvar ao [4]int\nvar ap [4]int\nvar aq [4]int\nvar ar [4]int\nvar as [4]int\nvar at [4]int\nvar au [4]int\nvar av [4]int\nvar aw [4]int\nvar ax [4]int\nvar ay [4]int\nvar az [4]int\nvar aaa [4]int\nvar aab [4]int\nvar aac [4]int\nvar aad [4]int\nvar aae [4]int\nvar aaf [4]int\nvar aag [4]int\nvar aah [4]int\nvar aai [4]int\n"}
{"tgt": "dist := [200][][]int{}\nfor r := 0; r < R; r++ {\n\tfor c := 0; c < C; c++ {\n\t\td := abs(r-r0) + abs(c-c0)\n\t\tdist[d] = append(dist[d], []int{r, c})\n\t}\n}\nbegin, end := 0, 0\nfor d := 0; len(dist[d]) > 0; d++ {\n\tbegin, end = end, end+len(dist[d])\n\tcopy(res[begin:end], dist[d])\n}\nreturn res[:end]", "gen": "var a [10000]int\nvar b [10000]int\nvar c [10000]int\nvar d [10000]int\nvar e [10000]int\nvar f [10000]int\nvar g [10000]int\nvar h [10000]int\nvar i [10000]int\nvar j [10000]int\nvar k [10000]int\nvar l [10000]int\nvar m [10000]int\nvar n [10000]int\nvar o [10000]int\nvar p [10000]int\nvar q [10000]int\nvar r [10000]int\nvar s [10000]int\nvar t [10000]int\nvar u [10000]int\nvar v [10000]int\nvar w [10000]int\nvar x [10000]int\nvar y [10000]int\nvar z [10000]int\nvar aa [10000]int\nvar ab [10000]int\nvar ac [10000]int\nvar ad [10000]int\nvar ae [10000]int\nvar af [10000]int\nvar ag [10000]int\nvar ah [10000]int\nvar ai [10000]int\nvar aj [10000]int\nvar ak [10000]int\nvar al [10000]int\nvar am [10000]int\nvar an [10000]int\nvar ao [10000]int\nvar ap [100"}
{"tgt": "n, err := io.Copy(h, r)\nif err != nil {\n\treturn err\n}\nif n != fSize {\n\treturn errReadSizeMismatch\n}\nreturn nil", "gen": "var r io.ReadSeeker\nvar w io.Writer\nvar err error\nvar n int64\nvar size int64\nvar buf []byte\nvar n2 int\nvar n3 int\nvar n4 int\nvar n5 int\nvar n6 int\nvar n7 int\nvar n8 int\nvar n9 int\nvar n10 int\nvar n11 int\nvar n12 int\nvar n13 int\nvar n14 int\nvar n15 int\nvar n16 int\nvar n17 int\nvar n18 int\nvar n19 int\nvar n20 int\nvar n21 int\nvar n22 int\nvar n23 int\nvar n24 int\nvar n25 int\nvar n26 int\nvar n27 int\nvar n28 int\nvar n29 int\nvar n30 int\nvar n31 int\nvar n32 int\nvar n33 int\nvar n34 int\nvar n35 int\nvar n36 int\nvar n37 int\nvar n38 int\nvar n39 int\nvar n40 int\nvar n41 int\nvar n42 int\nvar n43 int\nvar n44 int\nvar n45 int\nvar n46 int\nvar n47 int\nvar n48 int\nvar n49 int\nvar n50 int\nvar n51 int\nvar n52 int\nvar n53 int\nvar n54 int\nvar n55 int\nvar n56 int\nvar n57 int\nvar n58 int\nvar n59 int\nvar n60 int\nvar n61 int\nvar n62 int\nvar n63 int\nvar n64 int\nvar n65 int\nvar n66 int\nvar n67 int\nvar n6"}
{"tgt": "if max.Sign() <= 0 {\n\tpanic(\"STR\")\n}\nn = new(big.Int)\nn.Sub(max, n.SetUint64(1))\nbitLen := n.BitLen()\nif bitLen == 0 {\n\treturn\n}\nk := (bitLen + 7) / 8\nb := uint(bitLen % 8)\nif b == 0 {\n\tb = 8\n}\nbytes := make([]byte, k)\nfor {\n\t_, err = io.ReadFull(rand, bytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbytes[0] &= uint8(int(1<<b) - 1)\n\tn.SetBytes(bytes)\n\tif n.Cmp(max) < 0 {\n\t\treturn\n\t}\n}", "gen": "var a, b, c int\nfmt.Scan(&a, &b, &c)\nfmt.Println(a + b + c)\n}\n"}
{"tgt": "s := \"STR\"\nfmt.Println(reverseString(s))", "gen": "var s string\nfmt.Scan(&s)\nreverseString(s)\nfmt.Println(s)\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tnums: []int{1, 2, 3, 1},\n\t\tk:    3,\n\t\twant: true,\n\t},\n\t{\n\t\tnums: []int{1, 0, 1, 1},\n\t\tk:    1,\n\t\twant: true,\n\t},\n\t{\n\t\tnums: []int{1, 2, 3, 1, 2, 3},\n\t\tk:    2,\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := containsNearbyDuplicate(tt.nums, tt.k)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.nums, tt.k, got, tt.want)\n\t}\n}", "gen": "var a [7]int\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 1\na[4] = 4\na[5] = 4\na[6] = 3\nvar b [7]int\nb[0] = 1\nb[1] = 0\nb[2] = 1\nb[3] = 1\nb[4] = 2\nb[5] = 3\nb[6] = 3\nvar c [6]int\nc[0] = 1\nc[1] = 2\nc[2] = 3\nc[3] = 1\nc[4] = 4\nc[5] = 4\nvar d [6]int\nd[0] = 1\nd[1] = 2\nd[2] = 3\nd[3] = 1\nd[4] = 2\nd[5] = 3\nvar e [6]int\ne[0] = 1\ne[1] = 2\ne[2] = 3\ne[3] = 1\ne[4] = 4\ne[5] = 4\nvar f [6]int\nf[0] = 1\nf[1] = 2\nf[2] = 3\nf[3] = 1\nf[4] = 2\nf[5] = 3\nvar g [6]int\ng[0] = 1\ng[1] = 2\ng[2] = 3\ng[3] = 1\ng[4] = 4\ng[5] = 4\nvar h [6]int\nh[0] = 1\nh[1] = 2\nh[2] = 3\nh[3] = 1\nh[4"}
{"tgt": "for V > 0 {\n\tV--\n\tif !isDroppedLeft(heights, K) && !isDroppedRight(heights, K) {\n\t\theights[K]++\n\t}\n}\nreturn heights", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\na[0], a[1], a[2] = a[2], a[0], a[1]\nfmt.Println(a[0], a[1], a[2])\n}\n"}
{"tgt": "qs := []question231{\n\t{\n\t\tpara231{1},\n\t\tans231{true},\n\t},\n\t{\n\t\tpara231{16},\n\t\tans231{true},\n\t},\n\t{\n\t\tpara231{218},\n\t\tans231{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans231, q.para231\n\tfmt.Printf(\"STR\", p, isPowerOfTwo(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "m := map[string]struct{}{}\nfor _, email := range emails {\n\tn := len(email)\n\tbs := strings.Builder{}\n\tignore := false\n\tfor i := 0; i < n; i++ {\n\t\tif email[i] == '@' {\n\t\t\tbs.WriteString(email[i:])\n\t\t\tbreak\n\t\t}\n\t\tif ignore || email[i] == '.' {\n\t\t\tcontinue\n\t\t}\n\t\tif email[i] == '+' {\n\t\t\tignore = true\n\t\t\tcontinue\n\t\t}\n\t\tbs.WriteByte(email[i])\n\t}\n\tm[bs.String()] = struct{}{}\n}\nreturn len(m)", "gen": "var m map[string]struct{}\nm = make(map[string]struct{})\nm[\"hello\"] = struct{}{}\nm[\"world\"] = struct{}{}\nfmt.Println(m)\n}\n\n// Output:\n// map[hello:{} world:{}\n// ]\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```asm\n.LBB0:\ncmpq %fs:112,%rsp\njnb .L35\nmovl $216,%r10d\nmovl $24,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L35:\npushq %rbp\nmovq %rsp,%rbp\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $176,%rsp\nmovq $0,-56(%rbp)\n.LBB2:\nmovl $0,%r8d\nmovl $16,%ecx\nmovl $24,%edx\nmovl $0,%esi\nleaq <type..map.6string.7struct.4.5>(%rip),%rdi\ncall <__go_construct_map@PLT>\nmovq %rax,-64(%rbp)\n.LBB3:\nmovq $0,-208(%rbp)\nmovq $0,-200(%rbp)\n.LBB4:\n.LBB5:\n.LBB6:\nmovq <16>(%rbp),%rax\nmovq <24>(%rbp),%rdx\nmovq %rax,-160(%rbp)\nmovq %rdx,-152(%rbp)\nmovq <32>(%rbp),%rax\nmovq %rax,-144(%rbp)\nmovq -152(%rbp),%r14\nmovl $0,%ebx\n.LBE6:\njmp .L2\n.L34:\n.LBB7:\nnop\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinput1 string\n\tinput2 string\n\texpect bool\n}{\n\t{\"STR\", \"STR\", \"STR\", false},\n\t{\"STR\", \"STR\", \"STR\", false},\n\t{\"STR\", \"STR\", \"STR\", true},\n\t{\"STR\", \"STR\", \"STR\", true},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := canConstruct2(c.input1, c.input2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.input1, c.input2)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "for {\n\tswitch r := l.next(); {\n\tcase unicode.IsNumber(r):\n\tcase r == \"STR\":\n\t\tl.backup()\n\t\tl.emit(itemEnd)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase r == eof:\n\t\tl.emit(itemEnd)\n\t\treturn byteRangeSet\n\tdefault:\n\t\treturn l.error(\"STR\")\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "var res byte\nfor i := 0; i < len(s); i++ {\n\tres ^= s[i]\n}\nfor i := 0; i < len(t); i++ {\n\tres ^= t[i]\n}\nreturn res", "gen": "var a [10]byte\nvar b [10]byte\nvar c [10]byte\nvar d [10]byte\nvar e [10]byte\nvar f [10]byte\nvar g [10]byte\nvar h [10]byte\nvar i [10]byte\nvar j [10]byte\nvar k [10]byte\nvar l [10]byte\nvar m [10]byte\nvar n [10]byte\nvar o [10]byte\nvar p [10]byte\nvar q [10]byte\nvar r [10]byte\nvar s [10]byte\nvar t [10]byte\nvar u [10]byte\nvar v [10]byte\nvar w [10]byte\nvar x [10]byte\nvar y [10]byte\nvar z [10]byte\nvar aa [10]byte\nvar ab [10]byte\nvar ac [10]byte\nvar ad [10]byte\nvar ae [10]byte\nvar af [10]byte\nvar ag [10]byte\nvar ah [10]byte\nvar ai [10]byte\nvar aj [10]byte\nvar ak [10]byte\nvar al [10]byte\nvar am [10]byte\nvar an [10]byte\nvar ao [10]byte\nvar ap [10]byte\nvar aq [10]byte\nvar ar [10]byte\nvar as [10]byte\nvar at [10]byte\nvar au [10]byte\nvar av [10]byte\nvar aw [10]byte\nvar ax [10]byte\nvar ay [10]byte\nvar az [10]byte\nvar ba [10]byte\nvar bb [10]byte\nvar bc [10]byte\n"}
{"tgt": "var s int\nfor _, c := range m.cache {\n\ts += c.Expire()\n}\nreturn s", "gen": "var m = new(LRUCache)\nm.Add(1, 1)\nm.Add(2, 2)\nm.Add(3, 3)\nm.Add(4, 4)\nm.Add(5, 5)\nm.Add(6, 6)\nm.Add(7, 7)\nm.Add(8, 8)\nm.Add(9, 9)\nm.Add(10, 10)\nm.Add(11, 11)\nm.Add(12, 12)\nm.Add(13, 13)\nm.Add(14, 14)\nm.Add(15, 15)\nm.Add(16, 16)\nm.Add(17, 17)\nm.Add(18, 18)\nm.Add(19, 19)\nm.Add(20, 20)\nm.Add(21, 21)\nm.Add(22, 22)\nm.Add(23, 23)\nm.Add(24, 24)\nm.Add(25, 25)\nm.Add(26, 26)\nm.Add(27, 27)\nm.Add(28, 28)\nm.Add(29, 29)\nm.Add(30, 30)\nm.Add(31, 31)\nm.Add(32, 32)\nm.Add(33, 33)\nm.Add(34, 34)\nm.Add(35, 35)\nm.Add(36, 36)\nm.Add(37, 37)\nm.Add(38, 38)\nm.Add(39, 39)\n"}
{"tgt": "if len(num) <= 1 {\n\treturn\n}\nfor i := len(num) - 1; i > 0; i-- {\n\tif num[i-1] < num[i] {\n\t\tj := len(num) - 1\n\t\tfor num[i-1] >= num[j] {\n\t\t\tj--\n\t\t}\n\t\tnum[j], num[i-1] = num[i-1], num[j]\n\t\treverse(num[i:])\n\t\tfmt.Println(num)\n\t\treturn\n\t}\n\tif i == 1 {\n\t\treturn\n\t}\n}", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar bb [3]int\nvar cc [3]int\nvar dd [3]int\nvar ee [3]int\nvar ff [3]int\nvar gg [3]int\nvar hh [3]int\nvar ii [3]int\nvar jj [3]int\nvar kk [3]int\nvar ll [3]int\nvar mm [3]int\nvar nn [3]int\nvar oo [3]int\nvar pp [3]int\nvar qq [3]int\nvar rr [3]int\nvar ss [3]int\nvar tt [3]int\nvar uu [3]int\nvar vv [3]int\nvar ww [3]int\nvar xx [3]int\nvar yy [3]int\nvar zz [3]int\nvar aaa [3]int\nvar bbb [3]int\nvar ccc [3]int\nvar ddd [3]int\nvar eee [3]int\nvar fff [3]int\nvar ggg [3]int\nvar hhh [3]"}
{"tgt": "words := map[string]struct{}{}\ncap, vowel := map[string]string{}, map[string]string{}\nfor _, word := range wordlist {\n\twords[word] = struct{}{}\n\tlower := strings.ToLower(word)\n\tif _, ok := cap[lower]; !ok {\n\t\tcap[lower] = word\n\t\tif _, ok = vowel[todev(lower)]; !ok {\n\t\t\tvowel[todev(lower)] = word\n\t\t}\n\t}\n}\nfor i, query := range queries {\n\tif _, ok := words[query]; ok {\n\t\tcontinue\n\t}\n\tlower := strings.ToLower(query)\n\tif word, ok := cap[lower]; ok {\n\t\tqueries[i] = word\n\t} else if word, ok = vowel[todev(lower)]; ok {\n\t\tqueries[i] = word\n\t} else {\n\t\tqueries[i] = \"STR\"\n\t}\n}\nreturn queries", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "return c.name", "gen": "var a, b int\na = 1\nb = 2\nfmt.Println(a, b)\n}\n\n// \u7f16\u8bd1\u5668\u4f1a\u628a\u8fd9\u6bb5\u4ee3\u7801\u8f6c\u6362\u6210\u5982\u4e0b\u7684\u6c47\u7f16\u4ee3\u7801\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9%rax\u548c%rdx\n// \u7136\u540e\u5c06%rax\u548c%rdx\u7684\u503c\u8d4b\u503c\u7ed9-16(%rbp)\u548c-8(%rbp)\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06-16(%rbp)\u548c-8(%rbp)\u7684\u503c\u8d4b\u503c\u7ed9%rax\u548c%rdx\n// \u7136\u540e\u5c06%rax\u548c%rdx\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9%rax\u548c%rdx\n// \u7136\u540e\u5c06%rax\u548c%rdx\u7684\u503c\u8d4b\u503c\u7ed9-16(%rbp)\u548c-8(%rbp)\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06-16(%rbp)\u548c-8(%rbp)\u7684\u503c\u8d4b\u503c\u7ed9%rax\u548c%rdx\n// \u7136\u540e\u5c06%rax\u548c%rdx\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9%rax\u548c%rdx\n// \u7136\u540e\u5c06%rax\u548c%rdx\u7684\u503c\u8d4b\u503c\u7ed9-16(%rbp)\u548c-8(%rbp)\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06-16(%rbp)\u548c-8(%rbp)\u7684\u503c\u8d4b\u503c\u7ed9%rax\u548c%rdx\n// \u7136\u540e\u5c06%rax\u548c%rdx\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9%rax\u548c%rdx\n// \u7136\u540e"}
{"tgt": "qs := []question984{\n\t{\n\t\tpara984{1, 2},\n\t\tans984{\"STR\"},\n\t},\n\t{\n\t\tpara984{4, 1},\n\t\tans984{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans984, q.para984\n\tfmt.Printf(\"STR\", p, strWithout3a3b(p.a, p.b))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "var sum int\nfor i := start; i < end; i++ {\n\tsum += l[i]\n}\nreturn sum", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nvar sum int\nfor i = 0; i < 10; i++ {\n\tsum += a[i]\n}\nprintln(sum)\n}\n\n// 0000000000000000 <main>:\n// 0:\t55                   \tpush   %rbp\n// 1:\t48 89 e5             \tmov    %rsp,%rbp\n// 4:\t48 83 ec 30          \tsub    $0x30,%rsp\n// 8:\t48 8d 3d 00 00 00 00 \tlea    0x0(%rip),%rdi        # 10 <main+0x10>\n// d:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// 12:\t48 8d 7d f0          \tlea    -0x10(%rbp),%rdi\n// 16:\t48 89 75 f0          \tmov    %rdx,-0x10(%rbp)\n// 1a:\t48 89 c7             \tmov    %rax,%rdi\n// 1d:\te8 00 00 00 00       \tcallq  1f\n// 22:\t48 8d 3d 00 00 00 00 \tlea    0x0(%rip),%rdi        # 28 <main+0x28>\n// 29:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// 2d:\t48 8d 7d f0          \tlea    -0x10(%rbp),%rdi\n// 31:\t48"}
{"tgt": "arr := make([]bool, 1000000)\narr[1] = true\nprime := 3\ncount := 13\nvar k, tmp, localCount int\nvar str string\nfor {\n\tfor k = prime * 2; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tstr = strconv.Itoa(prime)\n\t\tif prime > 100 {\n\t\t\tlocalCount = 1\n\t\t\tfor i := 0; i < len(str)-1; i++ {\n\t\t\t\tstr = str[1:] + str[0:1]\n\t\t\t\ttmp, _ = strconv.Atoi(str)\n\t\t\t\tif tmp > prime {\n\t\t\t\t\tcontinueprimeloop\n\t\t\t\t} else if !arr[tmp] && tmp%2 != 0 {\n\t\t\t\t\tlocalCount++\n\t\t\t\t} else {\n\t\t\t\t\tcontinueprimeloop\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount += localCount\n\t\t}\n\t} else {\n\t\tbreak\n\t}\n}\nprintln(count)", "gen": "var a [1000000]byte\nvar b [1000000]byte\nvar c [1000000]byte\nvar d [1000000]byte\nvar e [1000000]byte\nvar f [1000000]byte\nvar g [1000000]byte\nvar h [1000000]byte\nvar i [1000000]byte\nvar j [1000000]byte\nvar k [1000000]byte\nvar l [1000000]byte\nvar m [1000000]byte\nvar n [1000000]byte\nvar o [1000000]byte\nvar p [1000000]byte\nvar q [1000000]byte\nvar r [1000000]byte\nvar s [1000000]byte\nvar t [1000000]byte\nvar u [1000000]byte\nvar v [1000000]byte\nvar w [1000000]byte\nvar x [1000000]byte\nvar y [1000000]byte\nvar z [1000000]byte\nvar aa [1000000]byte\nvar bb [1000000]byte\nvar cc [1000000]byte\nvar dd [1000000]byte\nvar ee [1000000]byte\nvar ff [1000000]byte\nvar gg [1000000]byte\nvar hh [1000000]byte\nvar ii [1000000]byte\nvar jj [10"}
{"tgt": "count := make(map[string]int, len(words))\nfor _, w := range words {\n\tcount[w]++\n}\nfw := make(freWords, 0, len(count))\nfor w, c := range count {\n\tfw = append(fw, &entry{\n\t\tword:      w,\n\t\tfrequence: c,\n\t})\n}\nsort.Sort(fw)\nres := make([]string, k)\nfor i := 0; i < k; i++ {\n\tres[i] = fw[i].word\n}\nreturn res", "gen": "var m map[string]int\nvar s []string\nvar e entry\nvar fw freWords\nvar i int\nvar k int\nvar v int\nvar ok bool\nvar n int\nvar s1 string\nvar s2 string\nvar s3 string\nvar s4 string\nvar s5 string\nvar s6 string\nvar s7 string\nvar s8 string\nvar s9 string\nvar s10 string\nvar s11 string\nvar s12 string\nvar s13 string\nvar s14 string\nvar s15 string\nvar s16 string\nvar s17 string\nvar s18 string\nvar s19 string\nvar s20 string\nvar s21 string\nvar s22 string\nvar s23 string\nvar s24 string\nvar s25 string\nvar s26 string\nvar s27 string\nvar s28 string\nvar s29 string\nvar s30 string\nvar s31 string\nvar s32 string\nvar s33 string\nvar s34 string\nvar s35 string\nvar s36 string\nvar s37 string\nvar s38 string\nvar s39 string\nvar s40 string\nvar s41 string\nvar s42 string\nvar s43 string\nvar s44 string\nvar s45 string\nvar s46 string\nvar s47 string\nvar s48 string\nvar s49 string\nvar s50 string\nvar s51 string\nvar s52 string\nvar s53 string\nvar s54 string\nvar s55 string\nvar s56 string\nvar s57 string\nvar s58 string\nvar s59 string\nvar s60 string\nvar s61 string\nvar s62 string\nvar s63 string\nvar s64 string\nvar s65 string\n"}
{"tgt": "str1 := \"STR\"\nfmt.Println(largeGroupPositions(str1))\nstr2 := \"STR\"\nfmt.Println(largeGroupPositions(str2))\nstr3 := \"STR\"\nfmt.Println(largeGroupPositions(str3))\nstr4 := \"STR\"\nfmt.Println(largeGroupPositions(str4))", "gen": "fmt.Println(largeGroupPositions(\"aaa\"))\nfmt.Println(largeGroupPositions(\"aa\"))\nfmt.Println(largeGroupPositions(\"abcde\"))\nfmt.Println(largeGroupPositions(\"abababab\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd"}
{"tgt": "list := NewCyclic()\nfillList(list, 3)\nwant := 1\ngot := list.Walk()\nif got.Val != want {\n\tt.Errorf(\"STR\", got)\n}", "gen": "var l *Cyclic\nl = NewCyclic(3)\nl.FillList()\nl.Walk()\nif l.Front().Value != 1 {\n\tt.Errorf(\"Front value is %d, want 1\", l.Front().Value)\n}\nif l.Back().Value != 3 {\n\tt.Errorf(\"Back value is %d, want 3\", l.Back().Value)\n}\nif l.Front().Next.Value != 2 {\n\tt.Errorf(\"Front.Next value is %d, want 2\", l.Front().Next.Value)\n}\nif l.Front().Next.Next.Value != 1 {\n\tt.Errorf(\"Front.Next.Next value is %d, want 1\", l.Front().Next.Next.Value)\n}\nif l.Front().Next.Next.Next.Value != 2 {\n\tt.Errorf(\"Front.Next.Next.Next value is %d, want 2\", l.Front().Next.Next.Next.Value)\n}\nif l.Front().Next.Next.Next.Next.Value != 1 {\n\tt.Errorf(\"Front.Next.Next.Next.Next value is %d, want 1\", l.Front().Next.Next.Next.Next.Value)\n}\nif l.Front().Next.Next.Next.Next.Next.Value != 2 {\n\tt.Errorf(\"Front.Next.Next.Next.Next.Next value is %d, want 2\", l.Front().Next.Next.Next.Next.Next.Value)\n}\nif l.Front().Next.Next.Next.Next.Next.Next.Value != 1 {\n\tt.Errorf(\"Front.Next.Next.Next.Next.Next.Next value is %d, want 1\", l.Front().Next.Next.Next.Next.Next.Next.Value)\n}\nif l.Front().Next.Next.Next.Next.Next.Next.Next.Value != 2 {\n\tt"}
{"tgt": "m := make(map[int]struct{})\nfor _, num := range nums1 {\n\tm[num] = struct{}{}\n}\nnums := make([]int, 0)\nfor _, num := range nums2 {\n\tif _, ok := m[num]; ok {\n\t\tnums = append(nums, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn nums", "gen": "var m map[int]struct {\n\ta, b, c int\n}\nm = make(map[int]struct {\n\ta, b, c int\n})\nfor i := 0; i < 1000000; i++ {\n\tm[i] = struct {\n\t\ta, b, c int\n\t}{i, i, i}\n}\nfor i := 0; i < 1000000; i++ {\n\tif m[i].a != i {\n\t\tpanic(\"bad\")\n\t}\n}\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname __morestack runtime.morestack"}
{"tgt": "factorial := new(big.Int).MulRange(1, 100)\nbytes := factorial.Append([]byte{}, 10)\nsum := 0\nfor b := range bytes {\n\tsum += int(bytes[b] - '0')\n}\nfmt.Println(\"STR\", sum)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aaa int\nvar bbb int\nvar ccc int\nvar ddd int\nvar eee int\nvar fff int\nvar ggg int\nvar hhh int\nvar iii int\nvar jjj int\nvar kkk int\nvar lll int\nvar mmm int\nvar nnn int\nvar ooo int\nvar ppp int\nvar qqq int\nvar rrr int\nvar sss int\nvar ttt int\nvar uuu int\nvar vvv int\nvar www int\nvar xxx int\nvar yyy int\nvar zzz int\nvar aaaa int\nvar bbbb int\nvar cccc int\nvar dddd int\nvar eeee int\nvar ffff int\nvar gggg int\nvar hhhh int\nvar iiii int\nvar jjjj int\n"}
{"tgt": "qs := []question1003{\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{true},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{true},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{false},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1003, q.para1003\n\tfmt.Printf(\"STR\", p, isValid1003(p.s))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "var v *error\nreturn v", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\n"}
{"tgt": "m := map[string]int{}\nrets := []string{}\nfor i := 0; i <= len(s)-10; i++ {\n\tsub := string(s[i : i+10])\n\tm[sub]++\n\tif m[sub] == 2 {\n\t\trets = append(rets, sub)\n\t}\n}\nreturn rets", "gen": "var m map[string]int\nm = make(map[string]int)\nm[\"foo\"] = 1\nm[\"bar\"] = 2\nm[\"baz\"] = 3\nfmt.Println(m)\n}\n\n// Output:\n// map[bar:2 baz:3 foo:1]\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n$ go tool compile -S main.go\n\n// main.go"}
{"tgt": "q[i], q[j] = q[j], q[i]", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\na[0] = 1\nb[0] = 2\nc[0] = 3\nd[0] = 4\ne[0] = 5\nf[0] = 6\ng[0] = 7\nh[0] = 8\ni[0] = 9\nj[0] = 10\nk[0] = 11\nl[0] = 12\nm[0] = 13\nn[0] = 14\no[0] = 15\np[0] = 16\nq[0] = 17\nr[0] = 18\ns[0] = 19\nt[0] = 20\nu[0] = 21\nv[0] = 22\nw[0] = 23\nx[0] = 24\ny[0] = 25\nz[0] = 26\na[1] = 1\nb[1] ="}
{"tgt": "runes := []rune(s)\nlength := len(runes)\nif length <= 1 {\n\treturn s\n}\nmaxRune := runes[0:1]\nfor i := 0; i < length-1; i++ {\n\ttmpRune := findPalindrome(runes, i, i)\n\tif len(tmpRune) > len(maxRune) {\n\t\tmaxRune = tmpRune\n\t}\n\tif runes[i] == runes[i+1] {\n\t\ttmpRune = findPalindrome(runes, i, i+1)\n\t\tif len(tmpRune) > len(maxRune) {\n\t\t\tmaxRune = tmpRune\n\t\t}\n\t}\n}\nreturn string(maxRune)", "gen": "fmt.Println(longestPalindrome(\"babad\"))\n}\n"}
{"tgt": "stack, j, N := []int{}, 0, len(pushed)\nfor _, x := range pushed {\n\tstack = append(stack, x)\n\tfmt.Printf(\"STR\", stack, j)\n\tfor len(stack) != 0 && j < N && stack[len(stack)-1] == popped[j] {\n\t\tstack = stack[0 : len(stack)-1]\n\t\tj++\n\t}\n\tfmt.Printf(\"STR\", stack, j)\n}\nreturn j == N", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar bb [3]int\nvar cc [3]int\nvar dd [3]int\nvar ee [3]int\nvar ff [3]int\nvar gg [3]int\nvar hh [3]int\nvar ii [3]int\nvar jj [3]int\nvar kk [3]int\nvar ll [3]int\nvar mm [3]int\nvar nn [3]int\nvar oo [3]int\nvar pp [3]int\nvar qq [3]int\nvar rr [3]int\nvar ss [3]int\nvar tt [3]int\nvar uu [3]int\nvar vv [3]int\nvar ww [3]int\nvar xx [3]int\nvar yy [3]int\nvar zz [3]int\nvar aaa [3]int\nvar bbb [3]int\nvar ccc [3]int\nvar ddd [3]int\nvar eee [3]int\nvar fff [3]int\nvar ggg [3]int\nvar hhh [3]"}
{"tgt": "return numDistinctBytes([]byte(s), []byte(t))", "gen": "fmt.Println(numDistinctBytes(\"abc\", \"bca\"))\n}\n"}
{"tgt": "return key1.(int) < key2.(int)", "gen": "var a int\nvar b int\na = 1\nb = 2\nif a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a != b\")\n}\n}\n\n// 0000000000000000 <main>:\n// \t.globl\tmain\n// \t.type\tmain,@function\n// \t.p2align\t4\n// main:\n// \t.cfi_startproc\n// \t.cfi_personality 0x3,__gxx_personality_v0\n// \t.cfi_lsda 0x3,.LLSDA0\n// \t.cfi_loc\t1 1 0\n// \t.cfi_adjust_cfa_offset 4\n// \t.cfi_offset 16, -4\n// \t.cfi_offset 3, -8\n// \t.cfi_offset 6, -12\n// \t.cfi_offset 7, -16\n// \t.cfi_offset 8, -20\n// \t.cfi_offset 9, -24\n// \t.cfi_offset 10, -28\n// \t.cfi_offset 11, -32\n// \t.cfi_offset 12, -36\n// \t.cfi_offset 13, -40\n// \t.cfi_offset 14, -44\n// \t.cfi_offset 15, -48\n// \t.cfi_offset 16, -52\n// \t.cfi_offset 17, -56\n// \t.cfi_offset 18, -60\n// \t.cfi_offset 19, -64\n// \t.cfi_offset 20, -68\n// \t.cfi_offset 21, -72\n// \t.cfi_offset 22, -76\n// \t."}
{"tgt": "return x != y", "gen": "var a, b float32\na = 1.0\nb = 2.0\nif a < b {\n\tprintln(\"a < b\")\n} else if a == b {\n\tprintln(\"a == b\")\n} else {\n\tprintln(\"a > b\")\n}\n}\n\n// 0000000000000000 <main>:\n// 0:\t55                   \tpush   %rbp\n// 1:\t48 89 e5             \tmov    %rsp,%rbp\n// 4:\t48 8d 3d 00 00 00 00 \tlea    0x0(%rip),%rdi        # 10 <main+0x10>\n// 10:\te8 00 00 00 00       \tcallq  15 <main+0x15>\n// 15:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// 19:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// 1d:\t48 89 7d f0          \tmov    %rdx,-0x10(%rbp)\n// 21:\t48 89 75 e8          \tmov    %rsi,-0x18(%rbp)\n// 25:\t48 89 7d e8          \tmov    %rdx,-0x18(%rbp)\n// 29:\t48 89 75 e0          \tmov    %rsi,-0x20(%rbp)\n// 2d:\t48 89 7d e0          \tmov    %rdx,-0x20(%rbp)\n// 31:\t48 89 75 d8          \tmov    %rsi,-0x28(%rbp)\n// 35:\t48 "}
{"tgt": "for prime := range sig(a) {\n\tif sig(b)[prime] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var m map[int64]bool\nvar s int64\nfor i := 0; i < 1000000; i++ {\n\tm[i] = true\n\ts += i\n}\nif s != 499999500000 {\n\tprintln(\"BUG\")\n}\nif m[0] {\n\tprintln(\"BUG\")\n}\nif !m[1] {\n\tprintln(\"BUG\")\n}\nif m[2] {\n\tprintln(\"BUG\")\n}\nif !m[3] {\n\tprintln(\"BUG\")\n}\nif m[4] {\n\tprintln(\"BUG\")\n}\nif !m[5] {\n\tprintln(\"BUG\")\n}\nif m[6] {\n\tprintln(\"BUG\")\n}\nif !m[7] {\n\tprintln(\"BUG\")\n}\nif m[8] {\n\tprintln(\"BUG\")\n}\nif !m[9] {\n\tprintln(\"BUG\")\n}\nif m[10] {\n\tprintln(\"BUG\")\n}\nif !m[11] {\n\tprintln(\"BUG\")\n}\nif m[12] {\n\tprintln(\"BUG\")\n}\nif !m[13] {\n\tprintln(\"BUG\")\n}\nif m[14] {\n\tprintln(\"BUG\")\n}\nif !m[15] {\n\tprintln(\"BUG\")\n}\nif m[16] {\n\tprintln(\"BUG\")\n}\nif !m[17] {\n\tprintln(\"BUG\")\n}\nif m[18] {\n\tprintln(\"BUG\")\n}\nif !m[19] {\n\tprintln(\"BUG\")\n}\nif m[20] {\n\tprintln(\"BUG\")\n}\nif !m[21] {\n\tprintln(\""}
{"tgt": "var low, mid, high int = 0, len(sorted) / 2, len(sorted)\nfor low < high {\n\tcurr := sorted[mid]\n\tswitch {\n\tcase curr == target:\n\t\treturn mid\n\tcase inRange(sorted[mid:high], target):\n\t\tlow = mid\n\t\tmid = (low + high) / 2\n\tdefault:\n\t\thigh = mid\n\t\tmid = (low + high) / 2\n\t}\n}\nreturn -1", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "if n < sumOfProperDivisors(n) {\n\treturn true\n}\nreturn false", "gen": "sumOfProperDivisors(12)\n}\n"}
{"tgt": "ss := []string{S}\nfor i := 0; i < len(S); i++ {\n\tif S[i] < '0' || S[i] > '9' {\n\t\tfor _, s := range ss {\n\t\t\tb := []byte(s)\n\t\t\tletterCase(b, i)\n\t\t\tss = append(ss, string(b))\n\t\t}\n\t}\n}\nreturn ss", "gen": "fmt.Println(letterCase(\"a\"))\nfmt.Println(letterCase(\"A\"))\nfmt.Println(letterCase(\"ab\"))\nfmt.Println(letterCase(\"aB\"))\nfmt.Println(letterCase(\"123\"))\nfmt.Println(letterCase(\"a123\"))\nfmt.Println(letterCase(\"A123\"))\nfmt.Println(letterCase(\"ab123\"))\nfmt.Println(letterCase(\"aB123\"))\nfmt.Println(letterCase(\"123a\"))\nfmt.Println(letterCase(\"123A\"))\nfmt.Println(letterCase(\"123ab\"))\nfmt.Println(letterCase(\"123aB\"))\nfmt.Println(letterCase(\"123A456\"))\nfmt.Println(letterCase(\"123a456\"))\nfmt.Println(letterCase(\"123A456\"))\nfmt.Println(letterCase(\"123ab456\"))\nfmt.Println(letterCase(\"123aB456\"))\nfmt.Println(letterCase(\"123A45678\"))\nfmt.Println(letterCase(\"123a45678\"))\nfmt.Println(letterCase(\"123A45678\"))\nfmt.Println(letterCase(\"123ab45678\"))\nfmt.Println(letterCase(\"123aB45678\"))\nfmt.Println(letterCase(\"123A456789\"))\nfmt.Println(letterCase(\"123a456789\"))\nfmt.Println(letterCase(\"123A456789\"))\nfmt.Println(letterCase(\"123ab456789\"))\nfmt.Println(letterCase(\"123aB456789\"))\nfmt.Println(letterCase(\"123A4567"}
{"tgt": "digits := convert(N + 1)\nbits := len(digits)\nnoRepeat := 0\nfor b := 1; b < bits; b++ {\n\tnoRepeat += 9 * count(9, b-1)\n}\nhasSeen := make(map[int]bool, 10)\nfor b := 0; b < bits; b++ {\n\td := 0\n\tif b == 0 {\n\t\td = 1\n\t}\n\tfor ; d < digits[b]; d++ {\n\t\tif !hasSeen[d] {\n\t\t\tnoRepeat += count(9-b, bits-b-1)\n\t\t}\n\t}\n\tif hasSeen[digits[b]] {\n\t\tbreak\n\t}\n\thasSeen[digits[b]] = true\n}\nreturn N - noRepeat", "gen": "var a [10]int\nvar b [10]bool\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar ba [10]int\nvar bb [10]int\nvar bc [10]int\n"}
{"tgt": "b := NewLRUCache(1000)\nfor i := 0; i < 1000; i++ {\n\tb.Set(randomString(2), \"STR\", expire)\n}\nreturn b", "gen": "var c = NewLRUCache(1000)\nfor i := 0; i < 1000; i++ {\n\tc.Set(i, i)\n}\n}\n"}
{"tgt": "h := &IntMaxHeap{}\nheap.Init(h)\nheap.Push(h, 7)\nheap.Push(h, 3)\nheap.Push(h, 2)\nheap.Push(h, 1)\nheap.Push(h, 5)\nheap.Push(h, 5)\nheap.Push(h, 6)\nheap.Push(h, 7)\nfmt.Printf(\"STR\", (*h))\nfor h.Len() > 0 {\n\tfmt.Printf(\"STR\", heap.Pop(h))\n}", "gen": "var s Solution\ns.Solution()\n}\n"}
{"tgt": "return MyCalendar{\n\tbooks: make([]seg, 0),\n}", "gen": "var s Solution\ns.Solution()\n}\n"}
{"tgt": "var buf bytes.Buffer\nbuf.WriteByte(\"STR\")\nfor i, word := range s.words {\n\tif word == 0 {\n\t\tcontinue\n\t}\n\tfor j := 0; j < 64; j++ {\n\t\tif word&(1<<uint(j)) != 0 {\n\t\t\tif buf.Len() > len(\"STR\") {\n\t\t\t\tbuf.WriteByte(\"STR\")\n\t\t\t}\n\t\t\tfmt.Fprintf(&buf, \"STR\", 64*i+j)\n\t\t}\n\t}\n}\nbuf.WriteByte(\"STR\")\nreturn buf.String()", "gen": "var buf bytes.Buffer\nbuf.WriteByte(123)\nfmt.Fprintf(&buf, \"%d\", 1)\nfmt.Println(buf.String())\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "matrix := [][]int{\n\t{5, 1, 9, 11},\n\t{2, 4, 8, 10},\n\t{13, 3, 6, 7},\n\t{15, 14, 12, 16},\n}\nmatrix = rotate(matrix)\nfor _, nums := range matrix {\n\tfor _, num := range nums {\n\t\tfmt.Print(num, \"STR\")\n\t}\n\tfmt.Println()\n}", "gen": "var a [16]int\nvar b [16]int\nvar c [16]int\nvar d [16]int\nvar e [16]int\nvar f [16]int\nvar g [16]int\nvar h [16]int\nvar i [16]int\nvar j [16]int\nvar k [16]int\nvar l [16]int\nvar m [16]int\nvar n [16]int\nvar o [16]int\nvar p [16]int\nvar q [16]int\nvar r [16]int\nvar s [16]int\nvar t [16]int\nvar u [16]int\nvar v [16]int\nvar w [16]int\nvar x [16]int\nvar y [16]int\nvar z [16]int\nvar aa [16]int\nvar bb [16]int\nvar cc [16]int\nvar dd [16]int\nvar ee [16]int\nvar ff [16]int\nvar gg [16]int\nvar hh [16]int\nvar ii [16]int\nvar jj [16]int\nvar kk [16]int\nvar ll [16]int\nvar mm [16]int\nvar nn [16]int\nvar oo [16]int\nvar pp [16]int\nvar qq [16]int\nvar rr [16]int\nvar ss [16]int\nvar tt [16]int\nvar uu [16]int\nvar vv [16]int\nvar ww [16]int\nvar xx [16]int\nvar yy [16]int\nvar zz [16]int\nvar aaa [16]int\nvar bbb [16]"}
{"tgt": "return MyQueue{\n\tlist: list.New(),\n}", "gen": "var l *z2flist.List\nl = z2flist.New()\n}\n\n<ASM>\n.LFB1:\ncmpq %fs:112,%rsp\njnb .L1\nmovl $24,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L1:\npushq %rbp\nmovq %rsp,%rbp\nsubq $16,%rsp\nmovq $0,-8(%rbp)\n.LBB4:\n.LBB5:\ncall <container..z2flist.New@PLT>\nmovq %rax,-8(%rbp)\nmovq -8(%rbp),%rax\n.LBE5:\n.LBE4:\nleave\nret</ASM>"}
{"tgt": "res := sizeOfLargestBST(tree)\nreturn res.AnsPtr", "gen": "root := &TreeNode{Val: 3}\nroot.Left = &TreeNode{Val: 2}\nroot.Right = &TreeNode{Val: 5}\nroot.Left.Left = &TreeNode{Val: 1}\nroot.Left.Right = &TreeNode{Val: 4}\nroot.Right.Right = &TreeNode{Val: 6}\nfmt.Println(sizeOfLargestBST(root))\n}\n"}
{"tgt": "sort.Ints(candidates)\nvar res [][]int\ndfs(candidates, nil, target, 0, &res)\nreturn res", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\ndfs(&a)\nfmt.Println(a[0], a[1], a[2])\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := checkRecord(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var a = make([]int, 10)\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"bad\")\n\t}\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"bad\")\n\t}\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"bad\")\n\t}\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"bad\")\n\t}\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"bad\")\n\t}\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"bad\")\n\t}\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\t"}
{"tgt": "for i := 1; i < len(arr); i++ {\n\tvalue := arr[i]\n\tj := i - 1\n\tfor j >= 0 && arr[j] > value {\n\t\tarr[j+1] = arr[j]\n\t\tj = j - 1\n\t}\n\tarr[j+1] = value\n}", "gen": "var a [10]int\na[10] = 1\na[10] = 2\na[10] = 3\na[10] = 4\na[10] = 5\na[10] = 6\na[10] = 7\na[10] = 8\na[10] = 9\na[10] = 10\na[10] = 11\na[10] = 12\na[10] = 13\na[10] = 14\na[10] = 15\na[10] = 16\na[10] = 17\na[10] = 18\na[10] = 19\na[10] = 20\na[10] = 21\na[10] = 22\na[10] = 23\na[10] = 24\na[10] = 25\na[10] = 26\na[10] = 27\na[10] = 28\na[10] = 29\na[10] = 30\na[10] = 31\na[10] = 32\na[10] = 33\na[10] = 34\na[10] = 35\na[10] = 36\na[10] = 37\na[10] = 38\na[10] = 39\na[10] = 40\na[10] = 41\na[10] = 42\na[10] = 43\na[10] = 44\na[10] = 45\na[10"}
{"tgt": "var nums []int\nvar ret bool\nnums = []int{1, 2, 3, 1}\nret = true\nif ret != containsDuplicate(nums) {\n\tt.Fatalf(\"STR\", ret)\n}\nnums = []int{1, 2, 3, 4}\nret = false\nif ret != containsDuplicate(nums) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "switch {\ncase head.Left == nil && head.Right == nil:\n\treturn head.Value\ncase head.Left != nil && head.Right != nil:\n\tleft := head.Value + MinPathSum(head.Left)\n\tright := head.Value + MinPathSum(head.Right)\n\treturn min(left, right)\ncase head.Left != nil:\n\treturn head.Value + MinPathSum(head.Left)\ndefault:\n\treturn head.Value + MinPathSum(head.Right)\n}", "gen": "fmt.Println(MinPathSum([][]int{{1, 3, 1}, {1, 5, 1}, {4, 2, 1}}))\n}\n"}
{"tgt": "sets := make([][]int, 1, 1<<uint(len(nums)))\nfor _, num := range nums {\n\tfor _, set := range sets {\n\t\ts := make([]int, len(set), len(set)+1)\n\t\tcopy(s, set)\n\t\tsets = append(sets, append(s, num))\n\t}\n}\nreturn sets", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "out := 100\nif x := p33(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "var p33 *int\nvar p34 *int\nvar p35 *int\nvar p36 *int\nvar p37 *int\nvar p38 *int\nvar p39 *int\nvar p40 *int\nvar p41 *int\nvar p42 *int\nvar p43 *int\nvar p44 *int\nvar p45 *int\nvar p46 *int\nvar p47 *int\nvar p48 *int\nvar p49 *int\nvar p50 *int\nvar p51 *int\nvar p52 *int\nvar p53 *int\nvar p54 *int\nvar p55 *int\nvar p56 *int\nvar p57 *int\nvar p58 *int\nvar p59 *int\nvar p60 *int\nvar p61 *int\nvar p62 *int\nvar p63 *int\nvar p64 *int\nvar p65 *int\nvar p66 *int\nvar p67 *int\nvar p68 *int\nvar p69 *int\nvar p70 *int\nvar p71 *int\nvar p72 *int\nvar p73 *int\nvar p74 *int\nvar p75 *int\nvar p76 *int\nvar p77 *int\nvar p78 *int\nvar p79 *int\nvar p80 *int\nvar p81 *int\nvar p82 *int\nvar p83 *int\nvar p84 *int\nvar p85 *int\nvar p86 *int\nvar p87 *int\nvar p88 *int\nvar p89 *int\nvar p90 *int\nvar p91 *int\nvar p92 *int\nvar p93 *int\nvar p94 *int\nvar p9"}
{"tgt": "steps := countSteps([]int{0, 0}, target)\nfor _, g := range ghosts {\n\tif steps >= countSteps(g, target) {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "fmt.Println(countSteps(2, 2, 48))\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CourseOrder(tc.prereqs); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "if nil == root || k <= 0 {\n\treturn nil\n}\nvar target *BinaryTreeNode\nif root.left != nil {\n\ttarget = kthNode(root.left, k)\n}\nif target == nil {\n\tif 1 == k {\n\t\ttarget = root\n\t} else {\n\t\tk--\n\t}\n}\nif target == nil && root.right != nil {\n\ttarget = kthNode(root.right, k)\n}\nreturn target", "gen": "var root *Node\nvar k int\nfmt.Scan(&root)\nfmt.Scan(&k)\nfmt.Println(kthNode(root, k))\n}\n"}
{"tgt": "nums := []int{0, 0, 1, 2}\nfmt.Println(dominantIndex(nums))", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar b = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar c = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar d = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar e = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar f = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar g = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar h = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar i = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar j = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar k = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar m = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar n = []int"}
{"tgt": "if root == nil {\n\treturn nil\n}\nif root.Val < L {\n\treturn trimBST(root.Right, L, R)\n}\nif root.Val > R {\n\treturn trimBST(root.Left, L, R)\n}\nroot.Left = trimBST(root.Left, L, R)\nroot.Right = trimBST(root.Right, L, R)\nreturn root", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "length := len(matrix)\nfor i := 0; 2*i < length-1; i++ {\n\tfor j := i; j < length-i-1; j++ {\n\t\tmatrix[i][j], matrix[j][length-i-1], matrix[length-i-1][length-j-1], matrix[length-j-1][i] =\n\t\t\tmatrix[length-j-1][i], matrix[i][j], matrix[j][length-i-1], matrix[length-i-1][length-j-1]\n\t}\n}", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "p = len(postorder) - 1\nidxMap = make(map[int]int)\nfor i, v := range inorder {\n\tidxMap[v] = i\n}\nreturn build(0, len(inorder)-1, postorder)", "gen": "s := Solution{\n\tp: 10,\n}\ns.build()\nfmt.Println(s.idxMap)\n}\n"}
{"tgt": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Print(sum, \"STR\")", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aaa int\nvar bbb int\nvar ccc int\nvar ddd int\nvar eee int\nvar fff int\nvar ggg int\nvar hhh int\nvar iii int\nvar jjj int\nvar kkk int\nvar lll int\nvar mmm int\nvar nnn int\nvar ooo int\nvar ppp int\nvar qqq int\nvar rrr int\nvar sss int\nvar ttt int\nvar uuu int\nvar vvv int\nvar www int\nvar xxx int\nvar yyy int\nvar zzz int\nvar aaaa int\nvar bbbb int\nvar cccc int\nvar dddd int\nvar eeee int\nvar ffff int\nvar gggg int\nvar hhhh int\nvar iiii int\nvar jjjj int\n"}
{"tgt": "qs := []question856{\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{1},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{2},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{2},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{6},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{3},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{8},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans856, q.para856\n\tfmt.Printf(\"STR\", p, scoreOfParentheses(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "const (\n\txmin, ymin, xmax, ymax = -2, -2, +2, +2\n\twidth, height          = 1024, 1024\n)\nimg := image.NewRGBA(image.Rect(0, 0, width, height))\nfor py := 0; py < height; py++ {\n\ty := float64(py)/height*(ymax-ymin) + ymin\n\tfor px := 0; px < width; px++ {\n\t\tx := float64(px)/width*(xmax-xmin) + xmin\n\t\tz := complex(x, y)\n\t\timg.Set(px, py, mandelbrot(z))\n\t}\n}\npng.Encode(os.Stdout, img)", "gen": "f, err := os.Create(\"mandelbrot.png\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer f.Close()\n\nimg := image.NewRGBA(image.Rect(0, 0, 1024, 1024))\nfor py := 0; py < 1024; py++ {\n\tfor px := 0; px < 1024; px++ {\n\t\tc := complex(float64(px)/1024, float64(py)/1024)\n\t\tz := complex(0, 0)\n\t\tfor i := 0; i < 255; i++ {\n\t\t\tz = z*z + c\n\t\t\tif cmplx.Abs(z) > 2 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\timg.Set(px, py, color.Color(i))\n\t}\n}\npng.Encode(f, img)\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif start, end := BusiestBuildingTimes(tc.moves); start != tc.start || end != tc.end {\n\t\tt.Errorf(\"STR\", tc.start, tc.end, start, end)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "n := len(cost)\ndp := make([]int, n+1)\nfor i := 2; i <= n; i++ {\n\tdp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])\n}\nreturn dp[n]", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar b = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar c = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar d = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar e = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar f = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar g = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar h = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar i = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar j = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar k = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar m = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar n = []int"}
{"tgt": "return new(runningSchTaskList).init(tasks)", "gen": "var a = new(greedy.runningSchTaskList)\na.init(32, 24, 16)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return area(A, B, C, D) + area(E, F, G, H) - area(max(A, E), max(B, F), min(C, G), min(D, H))", "gen": "var a, b, c, d float64\nfmt.Scan(&a, &b, &c, &d)\nfmt.Println(area(a, b, c, d))\n}\n"}
{"tgt": "r, err := http.Get(os.Args[1])\nif err != nil {\n\tfmt.Println(err)\n\treturn\n}\nio.Copy(os.Stdout, r.Body)\nif err := r.Body.Close(); err != nil {\n\tfmt.Println(err)\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\nresp, err := http.Get(\"https://www.baidu.com\")\nif err != nil {\n\tpanic(err)\n}\ndefer resp.Body.Close()\nio.Copy(os.Stdout, resp.Body)\nfmt.Println(\"Hello, \u4e16\u754c\")\n}\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```asm\n.text\n.globl main\n.type main, @function\nmain:\nleaq -472(%rsp),%r11\ncmpq %fs:112,%r11\njnb .L15\nmovl $472,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L15:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $424,%rsp\nmovq <8+os.Args>(%rip),%rax\ncmpq $1,%rax\njg .L5\nmovq %rax,%rsi\nmovl $1,%edi\ncall <runtime.goPanicIndex@PLT>\n.L5:\nmovq <os.Args>(%rip),%rax\naddq $16,%rax\nleaq -240(%rbp),%rcx\nmovq (%rax),%rdx\nmovq <8>(%rax),%rax\nmovq %rdx,%rsi\nmovq %rax,%rdx\nmovq %rcx,%rdi\ncall <net..z2fhttp.Get@PLT>\nmovq -240(%rbp),%rax\nmovq -232(%rbp),%rdx\nmovq %rax,-400(%rbp)\nmovq %rdx,-392(%rbp)\nmovq -224(%rbp),%"}
{"tgt": "qs := []question1304{\n\t{\n\t\tpara1304{5},\n\t\tans1304{[]int{-7, -1, 1, 3, 4}},\n\t},\n\t{\n\t\tpara1304{0},\n\t\tans1304{[]int{}},\n\t},\n\t{\n\t\tpara1304{3},\n\t\tans1304{[]int{-1, 0, 1}},\n\t},\n\t{\n\t\tpara1304{1},\n\t\tans1304{[]int{0}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1304, q.para1304\n\tfmt.Printf(\"STR\", p, sumZero(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 2, 1}, []int{0, 4, 1, 3, 2}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1}, []int{0}, []int{1}},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums, c.index)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums, c.index)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := isRobotBounded(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "seen := make(map[string]struct{})\nfor _, tier := range al {\n\tfor _, v := range tier {\n\t\tif _, ok := seen[v]; !ok {\n\t\t\tseen[v] = struct{}{}\n\t\t\tret = append(ret, v)\n\t\t}\n\t}\n}\nreturn", "gen": "var m map[string]struct{}\nfor i := 0; i < 1000000; i++ {\n\tm[fmt.Sprintf(\"%d\", i)] = struct{}{}\n}\n}\n"}
{"tgt": "return h.tasks[i].r < h.tasks[j].r", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb := a[0:2]\nb[0] = 10\nb[1] = 20\nfmt.Println(a)\n}\n\n// Output:\n// [10 20 3]\n\n```\n\n### 2. \u6808\u4e0a\u5206\u914d\n\n```go\npackage main\n\nimport \"fmt\"\n"}
{"tgt": "return xtime.Unix(int64(jt), 0)", "gen": "var t time.Time\nt.Unix()\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return RandomizedSet{\n\tl: []int{},\n\tm: make(map[int]int),\n}", "gen": "var m map[string]int\nm = make(map[string]int)\nm[\"hello\"] = 123\nfmt.Println(m)\n}\n\n<ASM>\n.LFB0:\ncmpq %fs:112,%rsp\njnb .L3\nmovl $120,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L3:\npushq %rbp\nmovq %rsp,%rbp\npushq %rbx\nsubq $104,%rsp\nmovq %rdi,-104(%rbp)\nmovq $0,-96(%rbp)\nmovq $0,-88(%rbp)\nmovq $0,-80(%rbp)\nmovq $0,-72(%rbp)\n.LBB2:\n.LBB3:\ncall <runtime.makemap_small@PLT>\nmovq %rax,%rbx\nleaq <type...60x.7int>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-56(%rbp)\nmovq -56(%rbp),%rax\nmovq %rax,-48(%rbp)\nmovq $0,-40(%rbp)\nmovq $0,-32(%rbp)\nmovq -48(%rbp),%rax\nmovq -40(%rbp),%rdx\nmovq %rax,-96(%rbp)\nmovq %rdx,-88(%rbp)\nmovq -32(%rbp),%rax\nmovq %rax,-80(%rbp)\nmovq %rbx,-72(%rbp)\nmovq -104(%rbp),%rcx\nmovq -96(%rbp),%rax\nmovq -88(%rbp),%rdx\nmovq %rax,(%rcx)\nmovq %rdx,<8>(%rcx)\nmovq -80"}
{"tgt": "return TypeInt, nil", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nvar b [3]int\nb[0] = 4\nb[1] = 5\nb[2] = 6\nvar c [3]int\nc[0] = 7\nc[1] = 8\nc[2] = 9\nvar d [3]int\nd[0] = 10\nd[1] = 11\nd[2] = 12\nvar e [3]int\ne[0] = 13\ne[1] = 14\ne[2] = 15\nvar f [3]int\nf[0] = 16\nf[1] = 17\nf[2] = 18\nvar g [3]int\ng[0] = 19\ng[1] = 20\ng[2] = 21\nvar h [3]int\nh[0] = 22\nh[1] = 23\nh[2] = 24\nvar i [3]int\ni[0] = 25\ni[1] = 26\ni[2] = 27\nvar j [3]int\nj[0] = 28\nj[1] = 29\nj[2] = 30\nvar k [3]int\nk[0] = 31\nk[1] = 32\nk[2] = 33\nvar l [3]int\nl[0] = 34\nl[1] = 35\nl[2] = 36\nvar m [3]int\nm[0] = 37\nm[1] = 38\nm[2] = 39\nvar n [3]int\nn[0] = "}
{"tgt": "return createSkyline(buildings, 0, len(buildings)-1)", "gen": "var skyline [][]int\nskyline = append(skyline, []int{2, 9, 10})\nskyline = append(skyline, []int{3, 7, 15})\nskyline = append(skyline, []int{5, 12, 12})\nskyline = append(skyline, []int{15, 20, 10})\nskyline = append(skyline, []int{19, 24, 8})\nskyline = append(skyline, []int{23, 25, 5})\nskyline = append(skyline, []int{24, 20, 9})\nskyline = append(skyline, []int{27, 30, 11})\nskyline = append(skyline, []int{30, 22, 10})\nskyline = append(skyline, []int{34, 28, 7})\nskyline = append(skyline, []int{38, 26, 6})\nskyline = append(skyline, []int{42, 30, 9})\nskyline = append(skyline, []int{46, 34, 10})\nskyline = append(skyline, []int{50, 38, 11})\nskyline = append(skyline, []int{54, 42, 12})\nskyline = append(skyline, []int{58, 46, 13})\nskyline = append(skyline, []int{62, 50, 14})\nskyline = append(skyline, []int{66, 54, 15})\nskyline = append(skyline, []int{70, 58, 16})\nskyline = append(skyline, []int{74, 62, 17})\nskyline = append(skyline, []int{78, 66, 18})"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil && max.Right != root {\n\t\t\tmax = max.Right\n\t\t}\n\t\tif max.Right == nil {\n\t\t\tmax.Right = root\n\t\t\troot = root.Left\n\t\t} else {\n\t\t\tres = append(res, root.Val)\n\t\t\troot = root.Right\n\t\t\tmax.Right = nil\n\t\t}\n\t}\n}\nreturn res", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "_, err := os.Open(\"STR\")\nif !os.IsNotExist(err) {\n\tpanic(\"STR\")\n}\nf, err := os.Open(\"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer func() {\n\tif err := f.Close(); err != nil {\n\t\tpanic(err)\n\t}\n\t_, err := f.Read(make([]byte, 10))\n\tif err == nil {\n\t\tpanic(\"STR\")\n\t}\n}()\ndata, err := ioutil.ReadAll(f)\nif err != nil {\n\tpanic(err)\n}\nprint(string(data))", "gen": "f, err := os.Open(\"test.txt\")\nif err != nil {\n\tpanic(err)\n}\ndefer f.Close()\nb, err := ioutil.ReadAll(f)\nif err != nil {\n\tpanic(err)\n}\nfmt.Println(string(b))\n}\n\n```\n\n### \u6c47\u7f16\u4ee3\u7801\u89e3\u6790\n\n```\n.LFB0:\nleaq -584(%rsp),%r11\ncmpq %fs:112,%r11\njnb .L20\nmovl $584,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\n.LEHB0:\nret\n.L20:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $536,%rsp\n.LEHE0:\nmovb $0,-457(%rbp)\n.LBB2:\nleaq <.LC4>(%rip),%rax\nmovl $9,%edx\nleaq -160(%rbp),%rdi\nmovq %rax,%rcx\nmovq %rdx,%rbx\nmovq %rdx,%rax\nmovq %rcx,%rsi\nmovq %rax,%rdx\n.LEHB1:\ncall <os.Open@PLT>\nmovq -160(%rbp),%rax\nmovq -152(%rbp),%rdx\nmovq %rax,-448(%rbp)\nmovq %rdx,-440(%rbp)\nmovq -144(%rbp),%rax\nmovq %rax,-432(%rbp)\nmovq -448(%rbp),%rax\nmovq %rax,-56(%rbp)\nmovq -440(%"}
{"tgt": "start, total, tank := 0, 0, 0\nfor i, g := range gas {\n\ttank += g - cost[i]\n\tif tank < 0 {\n\t\tstart = i + 1\n\t\ttotal += tank\n\t\ttank = 0\n\t}\n}\nif total+tank < 0 {\n\treturn -1\n}\nreturn start", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\tprintln(a[i])\n}\n}\n\n// func main() {\n// \tvar a [10]int\n// \tvar i int\n// \tfor i = 0; i < 10; i++ {\n// \t\ta[i] = i\n// \t}\n// \tfor i = 0; i < 10; i++ {\n// \t\tprintln(a[i])\n// \t}\n// }\n\n// func main() {\n// \tvar a [10]int\n// \tvar i int\n// \tfor i = 0; i < 10; i++ {\n// \t\ta[i] = i\n// \t}\n// \tfor i = 0; i < 10; i++ {\n// \t\tprintln(a[i])\n// \t}\n// }\n\n// func main() {\n// \tvar a [10]int\n// \tvar i int\n// \tfor i = 0; i < 10; i++ {\n// \t\ta[i] = i\n// \t}\n// \tfor i = 0; i < 10; i++ {\n// \t\tprintln(a[i])\n// \t}\n// }\n\n// func main() {\n// \tvar a [10]int\n// \tvar i int\n// \tfor i = 0; i < 10; i++ {\n// \t\ta[i] = i\n// \t}\n// \tfor i = 0; i < 10; i++ {\n// \t\tprintln(a[i])\n// \t}\n// }\n\n// func main() {\n// \tvar a [10]int\n// \tvar i int\n// \tfor i = 0;"}
{"tgt": "fmt.Println(btree.Data)", "gen": "fmt.Println(1, 1)\n}\n\n<ASM>\n.LFB0:\ncmpq %fs:112,%rsp\njnb .L2\nmovl $136,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L2:\npushq %rbp\nmovq %rsp,%rbp\naddq $-128,%rsp\nmovq %rdi,-120(%rbp)\nmovq -120(%rbp),%rax\nmovq <8>(%rax),%rdx\nmovq (%rax),%rax\nmovq %rax,-80(%rbp)\nmovq %rdx,-72(%rbp)\nleaq -80(%rbp),%rax\nmovq %rax,-64(%rbp)\nmovq $1,-56(%rbp)\nmovq $1,-48(%rbp)\nleaq -32(%rbp),%rax\nsubq $8,%rsp\npushq -48(%rbp)\npushq -56(%rbp)\npushq -64(%rbp)\nmovq %rax,%rdi\ncall <fmt.Println@PLT>\naddq $32,%rsp\nmovq -32(%rbp),%rax\nmovq -24(%rbp),%rdx\nmovq %rax,-112(%rbp)\nmovq %rdx,-104(%rbp)\nmovq -16(%rbp),%rax\nmovq %rax,-96(%rbp)\nleave\nret</ASM>"}
{"tgt": "n := len(num)\nres := []string{}\nvar dfs func(string, int, int, int)\ndfs = func(path string, index, result, pre int) {\n\tif index == n && result == target {\n\t\tres = append(res, path)\n\t\treturn\n\t}\n\tfor i := index; i < n; i++ {\n\t\tif num[index] == '0' && i != index {\n\t\t\treturn\n\t\t}\n\t\tcurrStr := num[index : i+1]\n\t\tcurr, _ := strconv.Atoi(currStr)\n\t\tif index == 0 {\n\t\t\tdfs(currStr, i+1, curr, curr)\n\t\t} else {\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result+curr, curr)\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result-curr, -curr)\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result-pre+pre*curr, pre*curr)\n\t\t}\n\t}\n}\ndfs(\"STR\", 0, 0, 0)\nreturn res", "gen": "fmt.Println(addOperators(\"123+567\", 1000))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: \"STR\",\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: \"STR\",\n\t},\n}\nfor _, tt := range tests {\n\tgot := defangIPaddr(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := Base64DecodeDelegate(tc.base64); res != tc.decoded {\n\t\tt.Errorf(\"STR\", tc.decoded, res)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "qs := []question1207{\n\t{\n\t\tpara1207{[]int{1, 2, 2, 1, 1, 3}},\n\t\tans1207{true},\n\t},\n\t{\n\t\tpara1207{[]int{1, 2}},\n\t\tans1207{false},\n\t},\n\t{\n\t\tpara1207{[]int{-3, 0, 1, -3, 1, 1, 1, -3, 10, 0}},\n\t\tans1207{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1207, q.para1207\n\tfmt.Printf(\"STR\", p, uniqueOccurrences(p.arr))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "max := -1001\nmax1 := -1001\nmax2 := -1001\nmin1 := 1001\nmin2 := 1001\nfor _, n := range nums {\n\tswitch {\n\tcase n > max:\n\t\tmax2, max1, max = max1, max, n\n\tcase n > max1:\n\t\tmax2, max1 = max1, n\n\tcase n > max2:\n\t\tmax2 = n\n\t}\n\tswitch {\n\tcase n < min1:\n\t\tmin2, min1 = min1, n\n\tcase n < min2:\n\t\tmin2 = n\n\t}\n}\nreturn bigger(max1*max2, min1*min2) * max", "gen": "var a, b, c int\nfmt.Scan(&a, &b, &c)\nfmt.Println(bigger(a, b, c))\n}"}
{"tgt": "var ret float64\nvar x float64\nvar n int\nret = 0\nx = 0.00001\nn = 2147483647\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 1.0000\nx = 2\nn = 0\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 10.0000\nx = 10.0000\nn = 1\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 0.25000\nx = 2.0000\nn = -2\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "for len(w.data) > 0 && w.data[len(w.data)-1] < n {\n\tw.data = w.data[0 : len(w.data)-1]\n}\nw.data = append(w.data, n)", "gen": "var a [10]int\nvar b [10]int\na[0] = 1\nb[0] = 2\na[1] = 3\nb[1] = 4\na[2] = 5\nb[2] = 6\na[3] = 7\nb[3] = 8\na[4] = 9\nb[4] = 10\na[5] = 11\nb[5] = 12\na[6] = 13\nb[6] = 14\na[7] = 15\nb[7] = 16\na[8] = 17\nb[8] = 18\na[9] = 19\nb[9] = 20\na[0] = a[0] + b[0]\na[1] = a[1] + b[1]\na[2] = a[2] + b[2]\na[3] = a[3] + b[3]\na[4] = a[4] + b[4]\na[5] = a[5] + b[5]\na[6] = a[6] + b[6]\na[7] = a[7] + b[7]\na[8] = a[8] + b[8]\na[9] = a[9] + b[9]\nfmt.Println(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "n := 0\ntmp := head\nfor tmp != nil {\n\tn++\n\ttmp = tmp.Next\n}\nreturn helper(&head, 0, n-1)", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar b = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar c = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar d = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar e = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar f = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar g = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar h = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar i = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar j = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar k = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar m = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar n = []int"}
{"tgt": "const templ = `<p>A:{{.A}}</p><p>B:{{.B}}</p>`\nt := template.Must(template.New(\"STR\").Parse(templ))\nvar data struct {\n\tA string\n\tBtemplate.HTML\n}\ndata.A = \"STR\"\ndata.B = \"STR\"\nif err := t.Execute(os.Stdout, data); err != nil {\n\tlog.Fatal(err)\n}", "gen": "var t = template.New(\"\")\nt, err := t.Parse(\"<html><body>{{.}}</body></html>\")\nif err != nil {\n\tlog.Fatal(err)\n}\nvar buf bytes.Buffer\nerr = t.Execute(&buf, \"hello, world\")\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Println(buf.String())\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(A) == len(A[0]) {\n\tfor i := 0; i < len(A); i++ {\n\t\tfor j := 0; j < len(A); j++ {\n\t\t\tif i == j {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]\n\t\t}\n\t}\n\treturn A\n}\nres := make([][]int, len(A[0]))\nfor i := 0; i < len(res); i++ {\n\tres[i] = make([]int, len(A))\n\tfor j := 0; j < len(A); j++ {\n\t\tres[i][j] = A[j][i]\n\t}\n}\nreturn res", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "out := make(map[string]string)\nmain_pieces := strings.Split(s, sep1)\nfor _, piece := range main_pieces {\n\tminor_pieces := strings.Split(piece, sep2)\n\tout[minor_pieces[0]] = minor_pieces[1]\n}\nreturn out", "gen": "var a = \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\"\nvar b = \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\"\nvar c = \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\"\nvar d = \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\"\nvar e = \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\"\nvar f = \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\"\nvar g = \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\"\nvar h = \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\"\nvar i = \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CountLargerAndSmallerBrute(tc.mat, tc.i1, tc.j1, tc.i2, tc.j2); result != tc.count {\n\t\tt.Errorf(\"STR\", tc.count, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "size := len(a)\nlo, hi := 0, size-1\nvar miD, miA int\nfor lo <= hi {\n\tmiD = (lo + hi) / 2\n\tmiA = size - miD - 1\n\tif a[miA] > miD {\n\t\tlo = miD + 1\n\t} else {\n\t\thi = miD - 1\n\t}\n}\nreturn lo", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0;"}
{"tgt": "l1, l2 := []int{}, []int{}\ndfs(root1, &l1)\ndfs(root2, &l2)\nif len(l1) != len(l2) {\n\treturn false\n}\nfor i, _ := range l1 {\n\tif l1[i] != l2[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [3]int\nvar b [3]int\ndfs(&a, &b)\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result, err := ShortestRunnerPath(tc.elevations, tc.paths); result != tc.shortestRoute || err != tc.err {\n\t\tt.Errorf(\"STR\", tc.shortestRoute, tc.err, result, err)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "sLen, pLen := len(s), len(p)\ndp := make([][]bool, sLen+1)\nfor i := range dp {\n\tdp[i] = make([]bool, pLen+1)\n}\ndp[sLen][pLen] = true\nfor i := sLen; i > -1; i-- {\n\tfor j := pLen - 1; j > -1; j-- {\n\t\tfirstMatch := i < sLen && (p[j] == s[i] || p[j] == '.')\n\t\tif j+1 < pLen && p[j+1] == '*' {\n\t\t\tdp[i][j] = dp[i][j+2] || firstMatch && dp[i+1][j]\n\t\t} else {\n\t\t\tdp[i][j] = firstMatch && dp[i+1][j+1]\n\t\t}\n\t}\n}\nreturn dp[0][0]", "gen": "var a [10]bool\nvar b [10]bool\nvar c [10]bool\nvar d [10]bool\nvar e [10]bool\nvar f [10]bool\nvar g [10]bool\nvar h [10]bool\nvar i [10]bool\nvar j [10]bool\nvar k [10]bool\nvar l [10]bool\nvar m [10]bool\nvar n [10]bool\nvar o [10]bool\nvar p [10]bool\nvar q [10]bool\nvar r [10]bool\nvar s [10]bool\nvar t [10]bool\nvar u [10]bool\nvar v [10]bool\nvar w [10]bool\nvar x [10]bool\nvar y [10]bool\nvar z [10]bool\nvar aa [10]bool\nvar bb [10]bool\nvar cc [10]bool\nvar dd [10]bool\nvar ee [10]bool\nvar ff [10]bool\nvar gg [10]bool\nvar hh [10]bool\nvar ii [10]bool\nvar jj [10]bool\nvar kk [10]bool\nvar ll [10]bool\nvar mm [10]bool\nvar nn [10]bool\nvar oo [10]bool\nvar pp [10]bool\nvar qq [10]bool\nvar rr [10]bool\nvar ss [10]bool\nvar tt [10]bool\nvar uu [10]bool\nvar vv [10]bool\nvar ww [10]bool\nvar xx [10]bool\nvar yy [10]bool\nvar zz [10]bool\nvar aaa [10]bool\nvar bbb [10]"}
{"tgt": "sort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].End < intervals[j].End\n})\ncount := 0\ncurrent := -int(^uint(0)>>1) - 1\nfor _, interval := range intervals {\n\tif interval.Start >= current {\n\t\tcount++\n\t\tcurrent = interval.End\n\t}\n}\nreturn len(intervals) - count", "gen": "fmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 3}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {1, 2}, {1, 2}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 4}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {1, 2}, {2, 3}, {3, 4}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 4}, {4, 5}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 5}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 5}, {5, 6}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 5}, {5, 6}, {6, 7}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 5}, {5, 6}, {6, 7}, {7, 8}}))\nfmt.Println(MinRemoveNoOverlap([]Interval{{1, 2}, {2, 3}, {3, 4}, {1, 5}, {5, 6}, {6, 7}, {7, 8}, {8, 9}}))\nfmt.Println(MinRemoveNoOverlap("}
{"tgt": "i := len(nums) - 2\nfor i >= 0 && nums[i] >= nums[i+1] {\n\ti--\n}\nj, k := i+1, len(nums)-1\nfor j < k {\n\tnums[j], nums[k] = nums[k], nums[j]\n\tj, k = j+1, k-1\n}\nif i >= 0 {\n\tj = i + 1\n\tfor nums[j] <= nums[i] {\n\t\tj++\n\t}\n\tnums[i], nums[j] = nums[j], nums[i]\n}", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "denoms := make(map[int]struct{})\nfor d, way := range ways {\n\tif others := waysToProduce(d, denoms); (way == 1 && d > 0) || others == way-1 {\n\t\tdenoms[d] = struct{}{}\n\t}\n}\nres := make([]int, 0, len(denoms))\nfor k := range denoms {\n\tres = append(res, k)\n}\nsort.Ints(res)\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "return len(self.data)", "gen": "var a [1000000000]int\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 4\na[4] = 5\na[5] = 6\na[6] = 7\na[7] = 8\na[8] = 9\na[9] = 10\na[10] = 11\na[11] = 12\na[12] = 13\na[13] = 14\na[14] = 15\na[15] = 16\na[16] = 17\na[17] = 18\na[18] = 19\na[19] = 20\na[20] = 21\na[21] = 22\na[22] = 23\na[23] = 24\na[24] = 25\na[25] = 26\na[26] = 27\na[27] = 28\na[28] = 29\na[29] = 30\na[30] = 31\na[31] = 32\na[32] = 33\na[33] = 34\na[34] = 35\na[35] = 36\na[36] = 37\na[37] = 38\na[38] = 39\na[39] = 40\na[40] = 41\na[41] = 42\na[42] = 43\na[43] = 44\na[44] = 45\na[45] ="}
{"tgt": "var ri, gi int\nfor i, r := range letters {\n\tif r == 'R' {\n\t\tletters[i] = letters[gi]\n\t\tletters[gi] = letters[ri]\n\t\tletters[ri] = r\n\t\tgi++\n\t\tri++\n\t} else if r == 'G' {\n\t\tletters[i] = letters[gi]\n\t\tletters[gi] = r\n\t\tgi++\n\t}\n}", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "switch rand.Intn(10) {\ncase 1, 9:\n\treturn io.EOF\ncase 5:\n\treturn errors.New(\"STR\")\ndefault:\n\td.Line = \"STR\"\n\tfmt.Println(\"STR\", d.Line)\n\treturn nil\n}", "gen": "var s string\nfmt.Scan(&s)\nfmt.Println(s)\n}\n"}
{"tgt": "return helper(root, p, q)", "gen": "helper(1, 2, 3)\n}\n"}
{"tgt": "benchmark(bb, 16384, 0.1)", "gen": "var b bytes.Buffer\nb.WriteString(\"hello\")\nb.WriteString(\"world\")\nb.WriteString(\"!\")\nfmt.Println(b.String())\n}\n\n<ASM>\nmovq %fs:112,%rsp\njnb .L298\nmovl $24,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL22:\nret\n.L298:\npushq %rbp\nmovq %rsp,%rbp\nsubq $16,%rsp\nmovq %rdi,-8(%rbp)\nmovq <.LC191>(%rip),%rdx\nmovq -8(%rbp),%rax\nmovq %rdx,%xmm0\nmovl $16384,%esi\nmovq %rax,%rdi\ncall <go.spacesaving.benchmark>\nleave\nret</ASM>"}
{"tgt": "this.mutex.Lock()\ndefer this.mutex.Unlock()\nif priority < 0 || priority > this.max {\n\treturn nil\n}\nreturn this.queues[priority].Peek()", "gen": "var wg sync.WaitGroup\nwg.Add(1)\ngo func() {\n\tdefer wg.Done()\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"recovered:\", r)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"recovered:\", r)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"recovered:\", r)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"recovered:\", r)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"recovered:\", r)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"recovered:\", r)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"recovered:\", r)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"recovered:\", r)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"recovered:\", r)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"recovered:"}
{"tgt": "if i < 0 || i >= itemKind(len(_itemKind_index)-1) {\n\treturn fmt.Sprintf(\"STR\", i)\n}\nreturn _itemKind_name[_itemKind_index[i]:_itemKind_index[i+1]]", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "arr := randomSlice(0, 20, 10)\nnodeCnt := 0\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\nrotateNodes := make([]*gbtElement, 0, 0)\ngbt.InOrderWalk(gbt.Root(), func(GBTbinaryTreeIf, node interface{}) bool {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\trotateNodes = append(rotateNodes, node.(*gbtElement))\n\t}\n\treturn false\n})\nfor _, v := range rotateNodes {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\tgbt.LeftRotate(v)\n\t} else {\n\t\tgbt.RightRotate(v)\n\t}\n}\ngbt.InOrderWalk(gbt.Root(), checkGBT(t, &nodeCnt, *debug))\nif nodeCnt != len(arr) {\n\tt.Log(fmt.Sprintf(\"STR\", len(arr), nodeCnt))\n\tt.Fail()\n}", "gen": "var t testing.T\nt.Log(\"Testing GBT\")\nvar bt *binaryTree.GBT\nbt = binaryTree.NewGBT()\nbt.Insert(10)\nbt.Insert(20)\nbt.Insert(30)\nbt.Insert(40)\nbt.Insert(50)\nbt.Insert(60)\nbt.Insert(70)\nbt.Insert(80)\nbt.Insert(90)\nbt.Insert(100)\nbt.Insert(110)\nbt.Insert(120)\nbt.Insert(130)\nbt.Insert(140)\nbt.Insert(150)\nbt.Insert(160)\nbt.Insert(170)\nbt.Insert(180)\nbt.Insert(190)\nbt.Insert(200)\nbt.Insert(210)\nbt.Insert(220)\nbt.Insert(230)\nbt.Insert(240)\nbt.Insert(250)\nbt.Insert(260)\nbt.Insert(270)\nbt.Insert(280)\nbt.Insert(290)\nbt.Insert(300)\nbt.Insert(310)\nbt.Insert(320)\nbt.Insert(330)\nbt.Insert(340)\nbt.Insert(350)\nbt.Insert(360)\nbt.Insert(370)\nbt.Insert(380)\nbt.Insert(390)\nbt.Insert(400)\nbt.Insert(410)\nbt.Insert(420)\nbt.Insert(430)\nbt.Insert(440)\nbt.Insert(450)\nbt.Insert(460)\nbt.Insert(470)"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := InversionCountBrute(tc.input); result != tc.inversions {\n\t\tt.Errorf(\"STR\", tc.inversions, result)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "fmt.Println(subarrayBitwiseORs([]int{0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))", "gen": "var a [3]int\na[0] = 1\na[1] = 1\na[2] = 2\nfmt.Println(subarrayBitwiseORs(a))\nvar b [3]int\nb[0] = 1\nb[1] = 3\nb[2] = 3\nfmt.Println(subarrayBitwiseORs(b))\nvar c [3]int\nc[0] = 1\nc[1] = 1\nc[2] = 4\nfmt.Println(subarrayBitwiseORs(c))\n}\n"}
{"tgt": "if nil == root {\n\treturn []int{}\n}\nlargestVals := []int{}\nchildren := []*TreeNode{root}\nfor len(children) > 0 {\n\ttmp := children[:]\n\tchildren = []*TreeNode{}\n\tlargest := -(1 << 32)\n\tfor _, child := range tmp {\n\t\tif child.Val > largest {\n\t\t\tlargest = child.Val\n\t\t}\n\t\tif nil != child.Left {\n\t\t\tchildren = append(children, child.Left)\n\t\t}\n\t\tif nil != child.Right {\n\t\t\tchildren = append(children, child.Right)\n\t\t}\n\t}\n\tlargestVals = append(largestVals, largest)\n}\nreturn largestVals", "gen": "var t TreeNode\nt.TreeNode = [3]int{1, 2, 3}\nt.TreeNode[0] = 1\nt.TreeNode[1] = 2\nt.TreeNode[2] = 3\nt.TreeNode[0] = 1\nt.TreeNode[1] = 2\nt.TreeNode[2] = 3\nt.TreeNode[0] = 1\nt.TreeNode[1] = 2\nt.TreeNode[2] = 3\nt.TreeNode[0] = 1\nt.TreeNode[1] = 2\nt.TreeNode[2] = 3\nt.TreeNode[0] = 1\nt.TreeNode[1] = 2\nt.TreeNode[2] = 3\nt.TreeNode[0] = 1\nt.TreeNode[1] = 2\nt.TreeNode[2] = 3\nt.TreeNode[0] = 1\nt.TreeNode[1] = 2\nt.TreeNode[2] = 3\nt.TreeNode[0] = 1\nt.TreeNode[1] = 2\nt.TreeNode[2] = 3\nt.TreeNode[0] = 1\nt.TreeNode[1] = 2\nt.TreeNode[2] = 3\nt.TreeNode[0] = 1\nt.TreeNode[1] = 2\nt.TreeNode[2] = 3\nt.TreeNode[0] = 1\nt.TreeNode[1] = 2\nt.TreeNode[2] = 3\nt.TreeNode[0] = 1\nt.TreeNode[1] = 2\nt.TreeNode[2] = 3\nt.TreeNode[0] = 1\nt.TreeNode[1] = 2\nt.TreeNode[2] = 3\nt.TreeNode["}
{"tgt": "{\n\tdata, err := json.Marshal(movies)\n\tif err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Printf(\"STR\", data)\n}\n{\n\tdata, err := json.MarshalIndent(movies, \"STR\")\n\tif err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Printf(\"STR\", data)\n\tvar titles []struct{ Title string }\n\tif err := json.Unmarshal(data, &titles); err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Println(titles)\n}", "gen": "movies := []Movie{\n\t{Title: \"Casablanca\", Year: 1942, Color: false},\n\t{Title: \"Cool Hand Luke\", Year: 1966, Color: true},\n\t{Title: \"Bullitt\", Year: 1968, Color: true},\n}\nb, err := json.Marshal(movies)\nif err != nil {\n\tlog.Fatal(err)\n}\nvar movies2 []Movie\nerr = json.Unmarshal(b, &movies2)\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Printf(\"%s\\n\", b)\nfmt.Printf(\"%s\\n\", movies2)\n}\n\n// Output:\n// [{\"Title\":\"Casablanca\",\"Year\":1942,\"Color\":false},{\"Title\":\"Cool Hand Luke\",\"Year\":1966,\"Color\":true},{\"Title\":\"Bullitt\",\"Year\":1968,\"Color\":true}]\n// [{Casablanca 1942 false} {Cool Hand Luke 1966 true} {Bullitt 1968 true}]\n\n```\n\n### \u603b\u7ed3\n\n- \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u751f\u6210\u4e00\u4e9b\u51fd\u6570\uff0c\u6bd4\u5982`newobject`\uff0c`typedmemmove`\u7b49\uff0c\u8fd9\u4e9b\u51fd\u6570\u7684\u5b9e\u73b0\u5728`runtime`\u5305\u4e2d\u3002\n- \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u751f\u6210\u4e00\u4e9b\u53d8\u91cf\uff0c\u6bd4\u5982`morestack`\uff0c`writeBarrier`\u7b49\uff0c\u8fd9\u4e9b\u53d8\u91cf\u7684\u5b9e\u73b0\u5728`runtime`\u5305\u4e2d\u3002\n- \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u751f\u6210\u4e00\u4e9b\u5e38\u91cf\uff0c\u6bd4\u5982`_morestack`\uff0c`_writeBarrier`\u7b49\uff0c\u8fd9\u4e9b\u5e38\u91cf\u7684\u5b9e\u73b0\u5728`runtime`\u5305\u4e2d\u3002\n- \u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u751f\u6210\u4e00\u4e9b\u6307\u4ee4\uff0c\u6bd4\u5982`leaq`\uff0c`movq`\u7b49\uff0c\u8fd9\u4e9b\u6307\u4ee4\u7684\u5b9e\u73b0\u5728`runtime`\u5305\u4e2d\u3002\n- \u7f16\ufffd"}
{"tgt": "if num <= 0 {\n\treturn false\n}\nif num&(num-1) != 0 {\n\treturn false\n}\nif num&0x55555555 == 0 {\n\treturn false\n}\nreturn true", "gen": "var x int\nfor i := 0; i < 1000000000; i++ {\n\tx = i\n}\nprintln(x)\n}\n\n// 0x0000000000000000 <main>:\n// 0000000000000000:\t55                   \tpush   %rbp\n// 0000000000000001:\t48 89 e5             \tmov    %rsp,%rbp\n// 0000000000000004:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// 0000000000000008:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// 000000000000000c:\t48 89 7d f0          \tmov    %rdx,-0x10(%rbp)\n// 0000000000000010:\t48 89 75 e8          \tmov    %rcx,-0x18(%rbp)\n// 0000000000000014:\t48 89 7d e0          \tmov    %r8,-0x20(%rbp)\n// 0000000000000018:\t48 89 75 d8          \tmov    %r9,-0x28(%rbp)\n// 000000000000001c:\t48 89 7d d0          \tmov    %r10,-0x30(%rbp)\n// 0000000000000020:\t48 89 75 c8"}
{"tgt": "major := uint32((dev & 0x00000000000fff00) >> 8)\nmajor |= uint32((dev & 0xfffff00000000000) >> 32)\nreturn major", "gen": "var a int\na = 1\na = 2\na = 3\na = 4\na = 5\na = 6\na = 7\na = 8\na = 9\na = 10\na = 11\na = 12\na = 13\na = 14\na = 15\na = 16\na = 17\na = 18\na = 19\na = 20\na = 21\na = 22\na = 23\na = 24\na = 25\na = 26\na = 27\na = 28\na = 29\na = 30\na = 31\na = 32\na = 33\na = 34\na = 35\na = 36\na = 37\na = 38\na = 39\na = 40\na = 41\na = 42\na = 43\na = 44\na = 45\na = 46\na = 47\na = 48\na = 49\na = 50\na = 51\na = 52\na = 53\na = 54\na = 55\na = 56\na = 57\na = 58\na = 59\na = 60\na = 61\na = 62\na = 63\na = 64\na = 65\na = 66\na = 67\na = 68\na = 69\na = 70\na = 71\na = 72\n"}
{"tgt": "t.Parallel()\nvar ba BitArray\nfor _, tc := range testcases {\n\tba.Init(tc.size)\n\tfor index, val := range tc.ones {\n\t\tif err := ba.Set(index, val); err != nil {\n\t\t\tt.Errorf(\"STR\")\n\t\t}\n\t}\n\tfor i := 0; i < tc.size; i++ {\n\t\tif val, err := ba.Get(i); err != nil {\n\t\t\tt.Errorf(\"STR\", err)\n\t\t} else if tc.ones[i] != val {\n\t\t\tt.Errorf(\"STR\", tc.ones[i], val, i)\n\t\t}\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "if a == b {\n\treturn -1\n}\nif len(a) > len(b) {\n\treturn len(a)\n}\nreturn len(b)", "gen": "var a [56]byte\nvar b [56]byte\nvar c [56]byte\nvar d [56]byte\nvar e [56]byte\nvar f [56]byte\nvar g [56]byte\nvar h [56]byte\nvar i [56]byte\nvar j [56]byte\nvar k [56]byte\nvar l [56]byte\nvar m [56]byte\nvar n [56]byte\nvar o [56]byte\nvar p [56]byte\nvar q [56]byte\nvar r [56]byte\nvar s [56]byte\nvar t [56]byte\nvar u [56]byte\nvar v [56]byte\nvar w [56]byte\nvar x [56]byte\nvar y [56]byte\nvar z [56]byte\nvar aa [56]byte\nvar ab [56]byte\nvar ac [56]byte\nvar ad [56]byte\nvar ae [56]byte\nvar af [56]byte\nvar ag [56]byte\nvar ah [56]byte\nvar ai [56]byte\nvar aj [56]byte\nvar ak [56]byte\nvar al [56]byte\nvar am [56]byte\nvar an [56]byte\nvar ao [56]byte\nvar ap [56]byte\nvar aq [56]byte\nvar ar [56]byte\nvar as [56]byte\nvar at [56]byte\nvar au [56]byte\nvar av [56]byte\nvar aw [56]byte\nvar ax [56]byte\nvar ay [56]byte\nvar az [56]byte\nvar ba [56]byte\nvar bb [56]byte\nvar bc [56]byte\n"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil {\n\t\t\tmax = max.Right\n\t\t}\n\t\tmax.Right = root\n\t\troot, root.Left = root.Left, nil\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aaa [3]int\nvar aab [3]int\nvar aac [3]int\nvar aad [3]int\nvar aae [3]int\nvar aaf [3]int\nvar aag [3]int\nvar aah [3]int\nvar aai [3]int\n"}
{"tgt": "if a > b {\n\treturn b\n}\nreturn a", "gen": "var a, b int\na = 1\nb = 2\nif a <= b {\n\ta = b\n}\nprintln(a)\n}\n\n// 0x0000000000000000 <main>:\n// 0000000000000000:\t55                   \tpush   %rbp\n// 0000000000000001:\t48 89 e5             \tmov    %rsp,%rbp\n// 0000000000000004:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// 0000000000000008:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// 000000000000000c:\t48 83 ec 08          \tsub    $0x8,%rsp\n// 0000000000000010:\t48 89 7d f0          \tmov    %rdi,-0x10(%rbp)\n// 0000000000000014:\t48 89 75 e8          \tmov    %rsi,-0x18(%rbp)\n// 0000000000000018:\t48 83 c4 08          \tadd    $0x8,%rsp\n// 000000000000001c:\t48 8b 75 e8          \tmov    -0x18(%rbp),%rsi\n// 0000000000000020:\t48 8b 7d f0          \tmov    -0x10(%rbp),%rdi"}
{"tgt": "var buf bytes.Buffer\nif err := encode(&buf, reflect.ValueOf(v)); err != nil {\n\treturn nil, err\n}\nreturn buf.Bytes(), nil", "gen": "var buf bytes.Buffer\nfmt.Println(buf.Bytes())\n}\n\n// Output:\n// 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n// 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n// 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n// 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n// 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n// 0000 0000 0000 0000 0000 0000 0000 000"}
{"tgt": "m := map[byte]struct{}{}\nfor i := range J {\n\tm[J[i]] = struct{}{}\n}\nres := 0\nfor i := range S {\n\tif _, ok := m[S[i]]; ok {\n\t\tres++\n\t}\n}\nreturn res", "gen": "var m map[uint8]struct{}\nvar s string\nvar i int\nvar j int\nvar k int\nvar l int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int"}
{"tgt": "if numRows < 2 {\n\treturn s\n}\nmaxInterval := (numRows - 1) << 1\ninterval := maxInterval\nafter := \"STR\"\nfor i := 0; i < numRows; i++ {\n\tif numRows-1 == i {\n\t\tinterval = maxInterval\n\t}\n\tfor j, no := i, 0; j < len(s); no++ {\n\t\tafter += string(s[j])\n\t\tif i > 0 && i < numRows-1 && 1 == no&1 {\n\t\t\tj += maxInterval - interval\n\t\t\tcontinue\n\t\t}\n\t\tj += interval\n\t}\n\tinterval -= 2\n}\nreturn after", "gen": "var a [10]byte\nvar b [10]byte\nvar c [10]byte\nvar d [10]byte\nvar e [10]byte\nvar f [10]byte\nvar g [10]byte\nvar h [10]byte\nvar i [10]byte\nvar j [10]byte\nvar k [10]byte\nvar l [10]byte\nvar m [10]byte\nvar n [10]byte\nvar o [10]byte\nvar p [10]byte\nvar q [10]byte\nvar r [10]byte\nvar s [10]byte\nvar t [10]byte\nvar u [10]byte\nvar v [10]byte\nvar w [10]byte\nvar x [10]byte\nvar y [10]byte\nvar z [10]byte\nvar aa [10]byte\nvar ab [10]byte\nvar ac [10]byte\nvar ad [10]byte\nvar ae [10]byte\nvar af [10]byte\nvar ag [10]byte\nvar ah [10]byte\nvar ai [10]byte\nvar aj [10]byte\nvar ak [10]byte\nvar al [10]byte\nvar am [10]byte\nvar an [10]byte\nvar ao [10]byte\nvar ap [10]byte\nvar aq [10]byte\nvar ar [10]byte\nvar as [10]byte\nvar at [10]byte\nvar au [10]byte\nvar av [10]byte\nvar aw [10]byte\nvar ax [10]byte\nvar ay [10]byte\nvar az [10]byte\nvar aaa [10]byte\nvar aab [10]byte\nvar aac [10]byte\n"}
{"tgt": "var result []string\ndfs(s, []string{}, &result)\nreturn result", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aaa [3]int\nvar aab [3]int\nvar aac [3]int\nvar aad [3]int\nvar aae [3]int\nvar aaf [3]int\nvar aag [3]int\nvar aah [3]int\nvar aai [3]int\n"}
{"tgt": "if n < 7 {\n\treturn int64(n + 1)\n}\nans := (1 + int64(n%7)) * row(n/7)\nreturn ans", "gen": "var a [6]int\nvar i int\nfor i = 0; i < 6; i++ {\n\ta[i] = i\n}\nrow(a, 0)\nfmt.Println(a[0])\n}"}
{"tgt": "if len(mat) == 0 || len(mat[0]) == 0 {\n\treturn []int{}\n}\nm, n := len(mat), len(mat[0])\nisUpping := true\nnext := func(i, j int) (int, int) {\n\tif isUpping {\n\t\ti--\n\t\tj++\n\t\tif 0 <= i && j < n {\n\t\t\treturn i, j\n\t\t}\n\t\tisUpping = false\n\t\tif i < 0 && j < n {\n\t\t\treturn 0, j\n\t\t}\n\t\treturn i + 2, j - 1\n\t}\n\ti++\n\tj--\n\tif i < m && 0 <= j {\n\t\treturn i, j\n\t}\n\tisUpping = true\n\tif i < m && j < 0 {\n\t\treturn i, 0\n\t}\n\treturn i - 1, j + 2\n}\nmn := m * n\nres := make([]int, mn)\ni, j := 0, 0\nfor k := 0; k < mn; k++ {\n\tres[k] = mat[i][j]\n\ti, j = next(i, j)\n}\nreturn res", "gen": "var a [6]int\nvar b [6]int\nvar c [6]int\nvar d [6]int\nvar e [6]int\nvar f [6]int\nvar g [6]int\nvar h [6]int\nvar i [6]int\nvar j [6]int\nvar k [6]int\nvar l [6]int\nvar m [6]int\nvar n [6]int\nvar o [6]int\nvar p [6]int\nvar q [6]int\nvar r [6]int\nvar s [6]int\nvar t [6]int\nvar u [6]int\nvar v [6]int\nvar w [6]int\nvar x [6]int\nvar y [6]int\nvar z [6]int\nvar aa [6]int\nvar ab [6]int\nvar ac [6]int\nvar ad [6]int\nvar ae [6]int\nvar af [6]int\nvar ag [6]int\nvar ah [6]int\nvar ai [6]int\nvar aj [6]int\nvar ak [6]int\nvar al [6]int\nvar am [6]int\nvar an [6]int\nvar ao [6]int\nvar ap [6]int\nvar aq [6]int\nvar ar [6]int\nvar as [6]int\nvar at [6]int\nvar au [6]int\nvar av [6]int\nvar aw [6]int\nvar ax [6]int\nvar ay [6]int\nvar az [6]int\nvar ba [6]int\nvar bb [6]int\nvar bc [6]int\nvar bd [6]int\nvar be [6]int\nvar bf [6]int\nvar bg [6]int\nvar bh [6]int\nvar bi [6]int\nvar bj ["}
{"tgt": "n := len(quality)\nworkers := make([][2]float64, n)\nfor i := 0; i < n; i++ {\n\tw, q := float64(wage[i]), float64(quality[i])\n\tworkers[i][0], workers[i][1] = w/q, q\n}\nsort.Slice(workers, func(i, j int) bool {\n\treturn workers[i][0] < workers[j][0]\n})\nres := math.MaxFloat64\nsum := 0.\nh := floatHeap{}\nfor _, w := range workers {\n\tsum += w[1]\n\theap.Push(&h, w[1])\n\tif len(h) > K {\n\t\tsum -= heap.Pop(&h).(float64)\n\t}\n\tif len(h) == K {\n\t\tres = min(res, sum*w[0])\n\t}\n}\nreturn res", "gen": "var a = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar b = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar c = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar d = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar e = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar f = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar g = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar h = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar i = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar j = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar k = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar l = []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar m = []float64{1, 2, 3, 4,"}
{"tgt": "t.Parallel()\nlfu := NewLFUCache(3)\nlfu.Set(\"STR\", \"STR\")\nlfu.Set(1, 2)\nlfu.Set(\"STR\", \"STR\")\nlfu.Get(1)\nlfu.Get(\"STR\")\nlfu.Set(100, 1)\nif result := lfu.Get(\"STR\"); result != nil {\n\tt.Errorf(\"STR\", result)\n}\nif result := lfu.Get(1); result == nil {\n\tt.Errorf(\"STR\")\n}\nif result := lfu.Get(\"STR\"); result == nil {\n\tt.Errorf(\"STR\")\n}\nif result := lfu.Get(100); result == nil {\n\tt.Errorf(\"STR\")\n}\nlfu.Set(100, \"STR\")\nif result := lfu.Get(100); result.(string) != \"STR\" {\n\tt.Errorf(\"STR\")\n}", "gen": "testing.M()\n}\n"}
{"tgt": "m := len(pattern)\nnext := make([]int, m)\nfor index := range next {\n\tnext[index] = -1\n}\nfor i := 1; i < m-1; i++ {\n\tj := next[i-1]\n\tfor pattern[j+1] != pattern[i] && j >= 0 {\n\t\tj = next[j]\n\t}\n\tif pattern[j+1] == pattern[i] {\n\t\tj += 1\n\t}\n\tnext[i] = j\n}\nreturn next", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := AllPossibleSubsequences(tc.input); !reflect.DeepEqual(result, tc.subseq) {\n\t\tt.Errorf(\"STR\", tc.subseq, result)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 3, 4, 2, 2}, 2},\n\t{\"STR\", []int{3, 1, 3, 4, 2}, 3},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := findDuplicate(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "cases := []struct {\n\tname    string\n\tinputs  []int\n\texpects bool\n}{\n\t{\"STR\", []int{1, 2, 3, 1}, true},\n\t{\"STR\", []int{1, 2, 3, 4}, false},\n\t{\"STR\", []int{1, 1, 1, 3, 3, 4, 3, 2, 4, 2}, true},\n}\nfor _, testcase := range cases {\n\tt.Run(testcase.name, func(t *testing.T) {\n\t\tresult := containsDuplicate(testcase.inputs)\n\t\tif !reflect.DeepEqual(result, testcase.expects) {\n\t\t\tt.Fatalf(\"STR\", testcase.expects, result, testcase.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "arr := randomSlice(0, 20, 10)\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\ncheckGBTPreOrder(t, gbt, arr)", "gen": "var t *Tree\nt = New(10)\nt.Insert(20)\nt.Insert(30)\nt.Insert(40)\nt.Insert(50)\nt.Insert(60)\nt.Insert(70)\nt.Insert(80)\nt.Insert(90)\nt.Insert(100)\nt.Insert(110)\nt.Insert(120)\nt.Insert(130)\nt.Insert(140)\nt.Insert(150)\nt.Insert(160)\nt.Insert(170)\nt.Insert(180)\nt.Insert(190)\nt.Insert(200)\nt.Insert(210)\nt.Insert(220)\nt.Insert(230)\nt.Insert(240)\nt.Insert(250)\nt.Insert(260)\nt.Insert(270)\nt.Insert(280)\nt.Insert(290)\nt.Insert(300)\nt.Insert(310)\nt.Insert(320)\nt.Insert(330)\nt.Insert(340)\nt.Insert(350)\nt.Insert(360)\nt.Insert(370)\nt.Insert(380)\nt.Insert(390)\nt.Insert(400)\nt.Insert(410)\nt.Insert(420)\nt.Insert(430)\nt.Insert(440)\nt.Insert(450)\nt.Insert(460)\nt.Insert(470)\nt.Insert(480)\nt.Insert(490)\nt.Insert(500)\nt."}
{"tgt": "fmt.Println(maxDistToClosest([]int{1, 0, 0, 0, 1, 0, 1}))\nfmt.Println(maxDistToClosest([]int{1, 0, 0, 0}))\nfmt.Println(maxDistToClosest([]int{0, 1}))\nfmt.Println(maxDistToClosest([]int{0, 1, 1, 1, 0, 0, 1, 0, 0}))\nfmt.Println(maxDistToClosest([]int{0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0}))", "gen": "fmt.Println(maxDistToClosest([]int{1, 2, 3, 4}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 1}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 1, 2}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 1, 2, 3}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 1, 2, 3, 4}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 1, 2, 3, 4, 1}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 1, 2, 3, 4, 1, 2}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4,"}
{"tgt": "iE := i.(*ltHeapElement)\njE := j.(*ltHeapElement)\nif iE == nil {\n\treturn jE\n}\nif jE == nil {\n\treturn iE\n}\nif h.Key(iE) < h.Key(jE) {\n\th.Swap(&iE, &jE)\n}\niE.right = h.merge(iE.right, jE).(*ltHeapElement)\nif iE.left == nil || iE.right.dist > iE.left.dist {\n\th.Swap(&iE.left, &iE.right)\n}\nif iE.right == nil {\n\tiE.dist = 0\n} else {\n\tiE.dist = iE.right.dist + 1\n}\nreturn iE", "gen": "var h go.heap.ltHeapArray\nh.Init()\nh.Push(go.heap.ltHeapElement{1})\nh.Push(go.heap.ltHeapElement{2})\nh.Push(go.heap.ltHeapElement{3})\nh.Push(go.heap.ltHeapElement{4})\nh.Push(go.heap.ltHeapElement{5})\nh.Push(go.heap.ltHeapElement{6})\nh.Push(go.heap.ltHeapElement{7})\nh.Push(go.heap.ltHeapElement{8})\nh.Push(go.heap.ltHeapElement{9})\nh.Push(go.heap.ltHeapElement{10})\nh.Push(go.heap.ltHeapElement{11})\nh.Push(go.heap.ltHeapElement{12})\nh.Push(go.heap.ltHeapElement{13})\nh.Push(go.heap.ltHeapElement{14})\nh.Push(go.heap.ltHeapElement{15})\nh.Push(go.heap.ltHeapElement{16})\nh.Push(go.heap.ltHeapElement{17})\nh.Push(go.heap.ltHeapElement{18})\nh.Push(go.heap.ltHeapElement{19})\nh.Push(go.heap.ltHeapElement{20})\nh.Push(go.heap.ltHeapElement{21})\nh.Push(go.heap.ltHeapElement{22})\nh.Push(go.heap.ltHeapElement{23})\nh.Push(go.heap.ltHeapElement{24})\nh.Push(go.heap.ltHeapElement{25})\nh.Push(go.heap.ltHeapElement{"}
{"tgt": "result := MakeMatrix(make([]float64, A.cols*A.rows), A.cols, A.rows)\nfor i := 0; i < A.rows; i++ {\n\tfor j := 0; j < A.cols; j++ {\n\t\tsum := float64(0)\n\t\tfor k := 0; k < A.cols; k++ {\n\t\t\tsum += A.GetElm(i, k) * B.GetElm(k, j)\n\t\t}\n\t\tresult.SetElm(i, j, sum)\n\t}\n}\nreturn result", "gen": "var a, b, c Matrix\na.Init(2, 2)\nb.Init(2, 2)\nc.Init(2, 2)\na.SetElm(0, 0, 1.0)\na.SetElm(0, 1, 2.0)\na.SetElm(1, 0, 3.0)\na.SetElm(1, 1, 4.0)\nb.SetElm(0, 0, 5.0)\nb.SetElm(0, 1, 6.0)\nb.SetElm(1, 0, 7.0)\nb.SetElm(1, 1, 8.0)\nc.Mul(&a, &b)\nfmt.Println(c.GetElm(0, 0))\nfmt.Println(c.GetElm(0, 1))\nfmt.Println(c.GetElm(1, 0))\nfmt.Println(c.GetElm(1, 1))\n}\n"}
{"tgt": "if head == nil {\n\treturn nil\n}\neven := head.Next\np, q := head, head.Next\nfor q != nil && q.Next != nil {\n\tp.Next = q.Next\n\tp = p.Next\n\tq.Next = p.Next\n\tq = q.Next\n}\np.Next = even\nreturn head", "gen": "var x [10]int\nvar y [10]int\nfor i := 0; i < 10; i++ {\n\tx[i] = i\n\ty[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tx[i] = x[i] + y[i]\n}\nfor i := 0; i < 10; i++ {\n\tif x[i] != 2*i {\n\t\tprintln(\"BUG\")\n\t}\n}\n}\n\n// func main() {\n// \tvar x [10]int\n// \tvar y [10]int\n// \tfor i := 0; i < 10; i++ {\n// \t\tx[i] = i\n// \t\ty[i] = i\n// \t}\n// \tfor i := 0; i < 10; i++ {\n// \t\tx[i] = x[i] + y[i]\n// \t}\n// \tfor i := 0; i < 10; i++ {\n// \t\tif x[i] != 2*i {\n// \t\t\tprintln(\"BUG\")\n// \t\t}\n// \t}\n// }\n\n// func main() {\n// \tvar x [10]int\n// \tvar y [10]int\n// \tfor i := 0; i < 10; i++ {\n// \t\tx[i] = i\n// \t\ty[i] = i\n// \t}\n// \tfor i := 0; i < 10; i++ {\n// \t\tx[i] = x[i] + y[i]\n// \t}\n// \tfor i := 0; i < 10; i++ {\n// \t\tif x[i] != 2*i {\n// \t\t\tprintln(\"BUG\")\n// \t\t}\n// \t}\n// }\n\n// func main()"}
{"tgt": "for i := 0; i < b.N; i++ {\n\thmap.HashInsert(rand.Intn(128), i)\n}", "gen": "var a, b int\na = 1\nb = 2\nvar c int\nc = a + b\nprintln(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "size := len(prices)\nif size <= 1 {\n\treturn 0\n}\nprofits := []int{}\ntemp := 0\nfor i := 1; i < size; i++ {\n\tdiff := prices[i] - prices[i-1]\n\tif temp*diff >= 0 {\n\t\ttemp += diff\n\t\tcontinue\n\t}\n\tprofits = append(profits, temp)\n\ttemp = diff\n}\nprofits = append(profits, temp)\nres := 0\nfor i := 0; i < len(profits); i++ {\n\ttemp = max(profits[:i]) + max(profits[i:])\n\tif res < temp {\n\t\tres = temp\n\t}\n}\nreturn res", "gen": "var a [10]int\nvar b [10]int\nvar c int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nc = max(a, b)\nfmt.Println(c)\n}"}
{"tgt": "_a := a\n_b := b\nif a < 0 {\n\ta *= -1\n}\nif b < 0 {\n\tb *= -1\n}\nx0, y0 := 0, 1\nx1, y1 := 1, 0\nfor b != 0 {\n\tquotient := a / b\n\ta, b = b, divide(a, b)\n\tx1, x0 = x0-quotient*x1, x1\n\ty1, y0 = y0-quotient*y1, y1\n}\nif _a < 0 {\n\ty0 *= -1\n}\nif _b < 0 {\n\tx0 *= -1\n}\nreturn y0, x0", "gen": "var a, b int64\nfmt.Scan(&a, &b)\nfmt.Println(a / b)\n}\n\n// Output:\n// 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}
{"tgt": "t.Run(\"STR\", func(t *testing.T) {\n\tdata := []int{1, 1, 2}\n\tgot := removeDuplicates(data)\n\twant := 2\n\tif got != want {\n\t\tt.Error(\"STR\", got, \"STR\", want)\n\t}\n})\nt.Run(\"STR\", func(t *testing.T) {\n\tdata := []int{0, 0, 1, 1, 1, 2, 2, 3, 3, 4}\n\tgot := removeDuplicates(data)\n\twant := 5\n\tif got != want {\n\t\tt.Error(\"STR\", got, \"STR\", want)\n\t}\n})", "gen": "solution := Solution{}\ntest := testing.T{}\ntest.Run(\"TestSolution\", solution.TestSolution)\n}\n"}
{"tgt": "if list == nil || list.Size == 0 {\n\tfmt.Println(\"STR\")\n\treturn\n}\nlist.mutex.RLock()\ndefer list.mutex.RUnlock()\nfmt.Printf(\"STR\", list.Size)\nptr := list.Head\nvar i uint\nfor i = 0; i < list.Size; i++ {\n\tfmt.Printf(\"STR\", i+1, ptr.Data)\n\tptr = ptr.Next\n}", "gen": "var a = Solution{\n\tA: 1,\n\tB: 2,\n\tC: 3,\n}\nvar b = Solution{\n\tA: 4,\n\tB: 5,\n\tC: 6,\n}\nvar c = Solution{\n\tA: 7,\n\tB: 8,\n\tC: 9,\n}\nvar d = Solution{\n\tA: 10,\n\tB: 11,\n\tC: 12,\n}\nvar e = Solution{\n\tA: 13,\n\tB: 14,\n\tC: 15,\n}\nvar f = Solution{\n\tA: 16,\n\tB: 17,\n\tC: 18,\n}\nvar g = Solution{\n\tA: 19,\n\tB: 20,\n\tC: 21,\n}\nvar h = Solution{\n\tA: 22,\n\tB: 23,\n\tC: 24,\n}\nvar i = Solution{\n\tA: 25,\n\tB: 26,\n\tC: 27,\n}\nvar j = Solution{\n\tA: 28,\n\tB: 29,\n\tC: 30,\n}\nvar k = Solution{\n\tA: 31,\n\tB: 32,\n\tC: 33,\n}\nvar l = Solution{\n\tA: 34,\n\tB: 35,\n\tC: 36,\n}\nvar m = Solution{\n\tA: 37,\n\tB: 38,\n\tC: 39,\n}\nvar n = Solution{\n\tA: 40,\n\tB: 41,\n\tC"}
{"tgt": "commonChars := make([]string, 0)\nif len(A) == 0 {\n\treturn commonChars\n}\nminFrequencies := [26]int{}\nfor i := range minFrequencies {\n\tminFrequencies[i] = math.MaxInt32\n}\nfor _, word := range A {\n\tcharFrequencies := [26]int{}\n\tfor _, char := range word {\n\t\tcharFrequencies[char-\"STR\"]++\n\t}\n\tfor i := 0; i < 26; i++ {\n\t\tminFrequencies[i] = min(minFrequencies[i], charFrequencies[i])\n\t}\n}\nfor i := 0; i < 26; i++ {\n\tfor minFrequencies[i] > 0 {\n\t\tcommonChars = append(commonChars, string(rune(i)+\"STR\"))\n\t\tminFrequencies[i]--\n\t}\n}\nreturn commonChars", "gen": "var s string\nvar i int\nvar j int\nvar k int\nvar m int\nvar n int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\n"}
{"tgt": "return N&1 == 0", "gen": "var a [10]byte\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 4\na[4] = 5\na[5] = 6\na[6] = 7\na[7] = 8\na[8] = 9\na[9] = 10\nvar b [10]byte\nb[0] = 1\nb[1] = 2\nb[2] = 3\nb[3] = 4\nb[4] = 5\nb[5] = 6\nb[6] = 7\nb[7] = 8\nb[8] = 9\nb[9] = 10\nvar c [10]byte\nc[0] = 1\nc[1] = 2\nc[2] = 3\nc[3] = 4\nc[4] = 5\nc[5] = 6\nc[6] = 7\nc[7] = 8\nc[8] = 9\nc[9] = 10\nvar d [10]byte\nd[0] = 1\nd[1] = 2\nd[2] = 3\nd[3] = 4\nd[4] = 5\nd[5] = 6\nd[6] = 7\nd[7] = 8\nd[8] = 9\nd[9] = 10\nvar e [10]byte\ne[0] = 1\ne[1] = 2\ne[2] = 3\ne[3] = 4\ne[4] = 5\ne[5] = 6\ne[6] = 7\ne[7] = 8\ne[8] = 9\ne[9] = 10\n"}
{"tgt": "var head *event\nreturn MyCalendar{head: head}", "gen": "var a int\na = 1\nvar b int\nb = 2\nvar c int\nc = 3\nvar d int\nd = 4\nvar e int\ne = 5\nvar f int\nf = 6\nvar g int\ng = 7\nvar h int\nh = 8\nvar i int\ni = 9\nvar j int\nj = 10\nvar k int\nk = 11\nvar l int\nl = 12\nvar m int\nm = 13\nvar n int\nn = 14\nvar o int\no = 15\nvar p int\np = 16\nvar q int\nq = 17\nvar r int\nr = 18\nvar s int\ns = 19\nvar t int\nt = 20\nvar u int\nu = 21\nvar v int\nv = 22\nvar w int\nw = 23\nvar x int\nx = 24\nvar y int\ny = 25\nvar z int\nz = 26\nvar a1 int\na1 = 27\nvar b1 int\nb1 = 28\nvar c1 int\nc1 = 29\nvar d1 int\nd1 = 30\nvar e1 int\ne1 = 31\nvar f1 int\nf1 = 32\nvar g1 int\ng1 = 33\nvar h1 int\nh1 = 34\nvar i1 int\ni1 = 35\nvar j1 int\nj1 = 36\nvar k1 int\nk1 = 37\nvar l1 int\nl1 = 38\nvar m1 int\nm1 = 39\nvar n1 int\nn1 = 40\n"}
{"tgt": "var num uint32\nvar ret int\nnum = 00000000000000000000000000001011\nret = 3\nif ret != hammingWeight(num) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "fmt.Println(hammingWeight(11))\n}\n"}
{"tgt": "if head == nil || head.Next == nil {\n\treturn head\n}\nresult := head.Next\nresult.Next, head.Next = head, head.Next.Next\nresult.Next.Next = SwapEveryTwo(result.Next.Next)\nreturn result", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\ta[i], a[i+1] = a[i+1], a[i]\n}\nfor i := 0; i < 10; i++ {\n\tfmt.Println(a[i])\n}\n}\n"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := AreSentencesEquivalentTransitive(tc.sentence1,\n\t\ttc.sentence2, tc.thesaurus); result != tc.expectedTransitive {\n\t\tt.Errorf(\"STR\", tcid,\n\t\t\ttc.expectedTransitive, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "m := make(map[int]int)\nfor k, v := range nums {\n\tif idx, ok := m[target-v]; ok {\n\t\treturn []int{idx, k}\n\t}\n\tm[v] = k\n}\nreturn nil", "gen": "var m map[int][2]int\nm[0] = [2]int{1, 2}\nm[1] = [2]int{3, 4}\nm[2] = [2]int{5, 6}\nm[3] = [2]int{7, 8}\nm[4] = [2]int{9, 10}\nm[5] = [2]int{11, 12}\nm[6] = [2]int{13, 14}\nm[7] = [2]int{15, 16}\nm[8] = [2]int{17, 18}\nm[9] = [2]int{19, 20}\nm[10] = [2]int{21, 22}\nm[11] = [2]int{23, 24}\nm[12] = [2]int{25, 26}\nm[13] = [2]int{27, 28}\nm[14] = [2]int{29, 30}\nm[15] = [2]int{31, 32}\nm[16] = [2]int{33, 34}\nm[17] = [2]int{35, 36}\nm[18] = [2]int{37, 38}\nm[19] = [2]int{39, 40}\nm[20] = [2]int{41, 42}\nm[21] = [2]int{43, 44}\nm[22] = [2]int{45, 46}\nm[23] = [2]int{47, 48}\nm[24] = [2]int{49, 50}\nm[25] = ["}
{"tgt": "sum := 100 * 101 / 2\nsqSum := sum * sum\nsumSq := 0\nfor i := 1; i <= 100; i++ {\n\tsumSq += i * i\n}\nfmt.Println(sqSum - sumSq)", "gen": "var a int\nvar b int\nvar c int\nvar d int\na = 1\nb = 1\nfor i := 1; i <= 100; i++ {\n\tc = a + b\n\ta = b\n\tb = c\n}\nd = a\nfmt.Println(d)\n}\n\n<ASM>\n.LFB0:\ncmpq %fs:112,%rsp\njnb .L7\nmovl $168,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L7:\npushq %rbp\nmovq %rsp,%rbp\npushq %r13\npushq %r12\nsubq $144,%rsp\nmovq $5050,-40(%rbp)\nmovq -40(%rbp),%rax\nimulq %rax,%rax\nmovq %rax,-48(%rbp)\nmovq $0,-24(%rbp)\n.LBB2:\nmovq $1,-32(%rbp)\n.LBB3:\njmp .L2\n.L6:\n.LBB4:\nnop\n.LBE4:\n.LBB5:\nmovq -32(%rbp),%rax\nimulq %rax,%rax\naddq %rax,-24(%rbp)\n.LBE5:\n.LBB6:\naddq $1,-32(%rbp)\n.L2:\n.LBE6:\ncmpq $100,-32(%rbp)\njle .L6\n.LBE3:\n.LBE2:\nleaq <int..d>(%rip),%r12\nleaq <int..d>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-136(%rbp)\nmovq -136(%rbp),%rax\nmovq -48(%rbp"}
{"tgt": "if a > b {\n\treturn b\n}\nreturn a", "gen": "var a, b int\na = 1\nb = 2\nif a <= b {\n\ta = b\n}\nprintln(a)\n}\n\n// 0x0000000000000000 <main>:\n// 0000000000000000:\t55                   \tpush   %rbp\n// 0000000000000001:\t48 89 e5             \tmov    %rsp,%rbp\n// 0000000000000004:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// 0000000000000008:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// 000000000000000c:\t48 83 ec 08          \tsub    $0x8,%rsp\n// 0000000000000010:\t48 89 7d f0          \tmov    %rdi,-0x10(%rbp)\n// 0000000000000014:\t48 89 75 e8          \tmov    %rsi,-0x18(%rbp)\n// 0000000000000018:\t48 83 c4 08          \tadd    $0x8,%rsp\n// 000000000000001c:\t48 8b 75 e8          \tmov    -0x18(%rbp),%rsi\n// 0000000000000020:\t48 8b 7d f0          \tmov    -0x10(%rbp),%rdi"}
{"tgt": "return this.Val", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "n := len(prices)\nif 0 == n || 1 == n {\n\treturn 0\n}\nvar (\n\tres      int\n\tminPrice = prices[0]\n)\nfor i := 1; i < n; i++ {\n\tif prices[i] < prices[i-1] {\n\t\tres += prices[i-1] - minPrice\n\t\tminPrice = prices[i]\n\t}\n\tif i == n-1 {\n\t\tres += prices[i] - minPrice\n\t}\n}\nreturn res", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor"}
{"tgt": "bs := []byte(s)\nvar recur func(int, int) bool\nrecur = func(l, r int) bool {\n\tfor l < r {\n\t\tif bs[l] != bs[r] {\n\t\t\treturn false\n\t\t}\n\t\tl++\n\t\tr--\n\t}\n\treturn true\n}\nfor l, r := 0, len(s)-1; l < r; l, r = l+1, r-1 {\n\tif bs[l] == bs[r] {\n\t\tcontinue\n\t}\n\treturn recur(l+1, r) || recur(l, r-1)\n}\nreturn true", "gen": "fmt.Println(validPalindrome(\"A man, a plan, a canal: Panama\"))\nfmt.Println(validPalindrome(\"race a car\"))\nfmt.Println(validPalindrome(\"0P\"))\nfmt.Println(validPalindrome(\"\"))\nfmt.Println(validPalindrome(\" \"))\nfmt.Println(validPalindrome(\"ab\"))\nfmt.Println(validPalindrome(\"a\"))\nfmt.Println(validPalindrome(\"aa\"))\nfmt.Println(validPalindrome(\"abba\"))\nfmt.Println(validPalindrome(\"abca\"))\nfmt.Println(validPalindrome(\"abcba\"))\nfmt.Println(validPalindrome(\"abcbaa\"))\nfmt.Println(validPalindrome(\"abcbaaa\"))\nfmt.Println(validPalindrome(\"abcbaaaa\"))\nfmt.Println(validPalindrome(\"abcbaaaab\"))\nfmt.Println(validPalindrome(\"abcbaaaabba\"))\nfmt.Println(validPalindrome(\"abcbaaaabbaa\"))\nfmt.Println(validPalindrome(\"abcbaaaabbaaa\"))\nfmt.Println(validPalindrome(\"abcbaaaabbaaaa\"))\nfmt.Println(validPalindrome(\"abcbaaaabbaaaab\"))\nfmt.Println(validPalindrome(\"abcbaaaabbaaaaba\"))\nfmt.Println(validPalindrome(\"abcbaaaabbaaaabab\"))\nfmt.Println(validPalindrome(\"abcbaaaabbaaaababa\"))\nfmt.Println(validPalindrome(\"abcbaaaabbaaaababab\"))\nfmt.Println(validPalindrome(\"abcbaaaabbaaaabababa\"))\nfmt.Println(validPalindrome(\"abcbaaaabbaaaabababab\"))\nfmt.Println(validPalindrome(\"abcbaaaabbaaaababababa\"))\nfmt.Println(validPalindrome(\"abcbaaaabbaaa"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 0,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxNumberOfBalloons(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(problem1189.maxNumberOfBalloons(\"egg\", \"add\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"foo\", \"bar\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"eggegg\", \"add\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"egg\", \"addgg\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"egg\", \"addggg\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"egg\", \"addgggg\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"egg\", \"addggggg\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"egg\", \"addgggggg\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"egg\", \"addggggggg\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"egg\", \"addgggggggg\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"egg\", \"addggggggggg\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"egg\", \"addgggggggggg\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"egg\", \"addggggggggggg\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"egg\", \"addgggggggggggg\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"egg\", \"addggggggggggggg\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"egg\", \"addgggggggggggggg\"))\nfmt.Println(problem1189.maxNumberOfBalloons(\"egg\", \"addgggggggggg"}
{"tgt": "tests := [...]testType{\n\t{\n\t\twords: []string{\"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  true,\n\t},\n\t{\n\t\twords: []string{\"STR\", \"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  false,\n\t},\n\t{\n\t\twords: []string{\"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := isAlienSorted(tt.words, tt.order)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.words, got, tt.want)\n\t}\n}", "gen": "var s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20, s21, s22, s23, s24, s25, s26, s27, s28, s29, s30, s31, s32, s33, s34, s35, s36, s37, s38, s39, s40, s41, s42, s43, s44, s45, s46, s47, s48, s49, s50, s51, s52, s53, s54, s55, s56, s57, s58, s59, s60, s61, s62, s63, s64, s65, s66, s67, s68, s69, s70, s71, s72, s73, s74, s75, s76, s77, s78, s79, s80, s81, s82, s83, s84, s85, s86, s87, s88, s89, s90, s91, s92, s93, s94, s95, s96, s97, s98, s99, s100, s101, s102, s103, s104, s105, s106, s107, s108, s109, s110, s111, s112, s113, s114, s115, s116, s117, s118, s119, s120, s121, s"}
{"tgt": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 1, 3}},\n\t\tans1051{3},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 2, 3, 4}},\n\t\tans1051{5},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{0},\n\t},\n\t{\n\t\tpara1051{[]int{5, 4, 3, 2, 1}},\n\t\tans1051{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "i := 1\ntmp := 0\nfor i < len(arr) {\n\tif arr[i] >= arr[i-1] {\n\t\ti++\n\t} else {\n\t\ttmp = arr[i]\n\t\tarr[i] = arr[i-1]\n\t\tarr[i-1] = tmp\n\t\tif i > 1 {\n\t\t\ti--\n\t\t}\n\t}\n}", "gen": "var a [10]int\na[10] = 1\na[10] = 2\na[10] = 3\na[10] = 4\na[10] = 5\na[10] = 6\na[10] = 7\na[10] = 8\na[10] = 9\na[10] = 10\na[10] = 11\na[10] = 12\na[10] = 13\na[10] = 14\na[10] = 15\na[10] = 16\na[10] = 17\na[10] = 18\na[10] = 19\na[10] = 20\na[10] = 21\na[10] = 22\na[10] = 23\na[10] = 24\na[10] = 25\na[10] = 26\na[10] = 27\na[10] = 28\na[10] = 29\na[10] = 30\na[10] = 31\na[10] = 32\na[10] = 33\na[10] = 34\na[10] = 35\na[10] = 36\na[10] = 37\na[10] = 38\na[10] = 39\na[10] = 40\na[10] = 41\na[10] = 42\na[10] = 43\na[10] = 44\na[10] = 45\na[10"}
{"tgt": "if maxSize > 0 {\n\tstack := &Stack{}\n\tstack.top = nil\n\tstack.size = 0\n\tstack.maxSize = maxSize\n\treturn stack\n}\nreturn nil", "gen": "var s Stack\ns.f = 1\ns.g = 2\ns.h = 3\nprintln(s.f, s.g, s.h)\n}\n\n// Output:\n// 1 2 3\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n// \u6c47\u7f16\u4ee3\u7801\n.LFB2:\ncmpq %fs:112,%rsp\njnb .L55\nmovl $88,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL11:\nret\n.L55:\npushq %rbp\nmovq %rsp,%rbp\nsubq $80,%rsp\nmovq %rdi,-72(%rbp)\nmovq $0,-8(%rbp)\n.LBB36:\n.LBB37:\ncmpq $0,-72(%rbp)\nje .L49\n.LBB38:\nleaq <go.rtarea.Stack..d>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-56(%rbp)\nmovq $0,-48(%rbp)\nmovq $0,-40(%rbp)\nmovq $0,-32(%rbp)\nleaq <runtime.writeBarrier>(%rip),%rax\nmovl (%rax),%eax\ntestl %eax,%eax\njne .L50\n.LBB39:\nmovq -56(%rbp),%rcx\nmovq -48(%rbp),%rax\nmovq -40(%rbp),%rdx\nmovq %rax,(%rcx)\nmovq %rdx,<8>(%rcx)\nmovq -32(%rbp),%rax\nmovq %rax,<16>(%rcx)\n.LBE39:\njmp .L51\n.L50:\n.LBB40:\nmovq -56(%"}
{"tgt": "b, _ := ioutil.ReadFile(\"STR\")\ns := strings.Replace(string(b), \"STR\", \"STR\", -1)\nnumData := strings.Split(s, \"STR\")\nfor _, n := range numData {\n\tnumber, err := strconv.Atoi(n)\n\tif err == nil {\n\t\tdata = append(data, number)\n\t}\n}", "gen": "var data [3]int\nvar line string\nvar err error\nif line, err = io.ReadFile(\"input.txt\"); err != nil {\n\tpanic(err)\n}\nvar lines []string\nif lines = strings.Split(line, \"\\n\"); err != nil {\n\tpanic(err)\n}\nfor i, line := range lines {\n\tvar nums []int\n\tif nums, err = strconv.Atoi(strings.Replace(line, \",\", \"\", -1)); err != nil {\n\t\tpanic(err)\n\t}\n\tdata[i] = nums[0]\n}\nfmt.Println(data)\n}\n"}
{"tgt": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nc, res := []int{}, [][]int{}\nsort.Ints(candidates)\nfindcombinationSum(candidates, target, 0, c, &res)\nreturn res", "gen": "fmt.Println(findCombinationSum([]int{2, 3, 6, 7}, 7))\n}\n"}
{"tgt": "qs := []question786{\n\t{\n\t\tpara786{[]int{1, 2, 3, 5}, 3},\n\t\tans786{[]int{2, 5}},\n\t},\n\t{\n\t\tpara786{[]int{1, 7}, 1},\n\t\tans786{[]int{1, 7}},\n\t},\n\t{\n\t\tpara786{[]int{1, 2}, 1},\n\t\tans786{[]int{1, 2}},\n\t},\n\t{\n\t\tpara786{[]int{1, 2, 3, 5, 7}, 6},\n\t\tans786{[]int{3, 7}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans786, q.para786\n\tfmt.Printf(\"STR\", p, kthSmallestPrimeFraction(p.A, p.K))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "errObj := appError{\n\tError:      handlerError.Error(),\n\tMessage:    message,\n\tHTTPStatus: code,\n}\nError.Printf(\"STR\", handlerError)\nw.Header().Set(\"STR\", \"STR\")\nw.WriteHeader(code)\nif j, err := json.Marshal(errorResource{Data: errObj}); err == nil {\n\tw.Write(j)\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "if len(strs) == 0 {\n\treturn nil\n}\nr := make(map[string][]string)\nfor _, str := range strs {\n\tcount := make([]int, 26)\n\tfor _, b := range []byte(str) {\n\t\tcount[b-'a']++\n\t}\n\tbs := make([]byte, 26*2)\n\tfor i, c := range count {\n\t\tbs[2*i] = '#'\n\t\tbs[2*i+1] = byte(c) + '0'\n\t}\n\tkey := string(bs)\n\tr[key] = append(r[key], str)\n}\nres := make([][]string, len(r))\ni := 0\nfor _, l := range r {\n\tres[i] = l\n\ti++\n}\nreturn res", "gen": "var m map[string]string\nm = make(map[string]string)\nm[\"hello\"] = \"world\"\nfmt.Println(m)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "type Address struct {\n\tCountry string  `json:\"STR\"`\n\tPerson  *Person `json:\"STR\"`\n}\nperson := &Person{\n\tName: \"STR\",\n\tAge:  23,\n}\naddress := &Address{\n\tCountry: \"STR\",\n\tPerson:  person,\n}\ndefer func() {\n\terr := recover()\n\tif err != nil {\n\t\tfmt.Printf(\"STR\", err)\n\t\tt.Error(\"STR\")\n\t}\n}()\ns := New(address)\ns.TagName = \"STR\"\nm := s.Map()\nif m[\"STR\"] != person.String() {\n\tt.Errorf(\"STR\", person.String(), m[\"STR\"])\n}\nvs := s.Values()\nif vs[1] != person.String() {\n\tt.Errorf(\"STR\", person.String(), vs[1])\n}", "gen": "var p Person\np.Name = \"Alice\"\np.Age = 20\np.Address = &Address{\n\tStreet: \"High Street\",\n\tNumber: 10,\n}\np.Map = map[string]interface{}{\n\t\"Name\": p.Name,\n\t\"Age\":  p.Age,\n\t\"Address\": p.Address,\n}\nfmt.Println(p)\n}\n"}
{"tgt": "if parser.tokens_head > 0 && len(parser.tokens) == cap(parser.tokens) {\n\tif parser.tokens_head != len(parser.tokens) {\n\t\tcopy(parser.tokens, parser.tokens[parser.tokens_head:])\n\t}\n\tparser.tokens = parser.tokens[:len(parser.tokens)-parser.tokens_head]\n\tparser.tokens_head = 0\n}\nparser.tokens = append(parser.tokens, *token)\nif pos < 0 {\n\treturn\n}\ncopy(parser.tokens[parser.tokens_head+pos+1:], parser.tokens[parser.tokens_head+pos:])\nparser.tokens[parser.tokens_head+pos] = *token", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar bb [10]int\nvar cc [10]int\nvar dd [10]int\nvar ee [10]int\nvar ff [10]int\nvar gg [10]int\nvar hh [10]int\nvar ii [10]int\nvar jj [10]int\nvar kk [10]int\nvar ll [10]int\nvar mm [10]int\nvar nn [10]int\nvar oo [10]int\nvar pp [10]int\nvar qq [10]int\nvar rr [10]int\nvar ss [10]int\nvar tt [10]int\nvar uu [10]int\nvar vv [10]int\nvar ww [10]int\nvar xx [10]int\nvar yy [10]int\nvar zz [10]int\nvar aaa [10]int\nvar bbb [10]"}
{"tgt": "str := \"STR\"\nfmt.Println(longestPalindrome(str))", "gen": "fmt.Println(longestPalindrome(\"abba\"))\nfmt.Println(longestPalindrome(\"abcd\"))\nfmt.Println(longestPalindrome(\"abcba\"))\nfmt.Println(longestPalindrome(\"abcdcba\"))\nfmt.Println(longestPalindrome(\"abcdcbaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(longestPal"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   5,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   0,\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   1,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   2,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   13,\n\t\twant: 4,\n\t},\n\t{\n\t\tin:   130,\n\t\twant: 15,\n\t},\n}\nfor _, tt := range tests {\n\tgot := arrangeCoins(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(arrangeCoins(2))\nfmt.Println(arrangeCoins(5))\nfmt.Println(arrangeCoins(8))\nfmt.Println(arrangeCoins(13))\nfmt.Println(arrangeCoins(15))\nfmt.Println(arrangeCoins(130))\nfmt.Println(arrangeCoins(150))\nfmt.Println(arrangeCoins(1500))\nfmt.Println(arrangeCoins(15000))\nfmt.Println(arrangeCoins(150000))\nfmt.Println(arrangeCoins(1500000))\nfmt.Println(arrangeCoins(15000000))\nfmt.Println(arrangeCoins(150000000))\nfmt.Println(arrangeCoins(1500000000))\nfmt.Println(arrangeCoins(15000000000))\nfmt.Println(arrangeCoins(150000000000))\nfmt.Println(arrangeCoins(1500000000000))\nfmt.Println(arrangeCoins(15000000000000))\nfmt.Println(arrangeCoins(150000000000000))\nfmt.Println(arrangeCoins(1500000000000000))\nfmt.Println(arrangeCoins(15000000000000000))\nfmt.Println(arrangeCoins(150000000000000000))\nfmt.Println(arrangeCoins(1500000000000000000))\nfmt.Print"}
{"tgt": "return WordDictionary{}", "gen": "var a [20]int\na[19] = 1\na[18] = 2\na[17] = 3\na[16] = 4\na[15] = 5\na[14] = 6\na[13] = 7\na[12] = 8\na[11] = 9\na[10] = 10\na[9] = 11\na[8] = 12\na[7] = 13\na[6] = 14\na[5] = 15\na[4] = 16\na[3] = 17\na[2] = 18\na[1] = 19\na[0] = 20\nfmt.Println(a)\n}\n"}
{"tgt": "tcs := []struct {\n\ts   string\n\tans bool\n}{\n\t{\n\t\t\"STR\",\n\t\tfalse,\n\t},\n\t{\n\t\t\"STR\",\n\t\ttrue,\n\t},\n\t{\n\t\t\"STR\",\n\t\tfalse,\n\t},\n\t{\n\t\t\"STR\",\n\t\ttrue,\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, tc := range tcs {\n\tfmt.Printf(\"STR\", tc, isPalindrome(tc.s))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "var drinks []Drink\ninverted := make(map[Drink][]Customer)\nfor cust, favorites := range prefs {\n\tfor _, drink := range favorites {\n\t\tinverted[drink] = append(inverted[drink], cust)\n\t}\n}\ntotalCustomers := len(prefs)\nserved := make(map[Customer]struct{}, totalCustomers)\nfor len(served) < totalCustomers {\n\tvar largest []Customer\n\tvar largestDrink Drink\n\tvar largestIncrease int\n\tfor drink, custs := range inverted {\n\t\tvar newlyServed int\n\t\tfor _, cust := range custs {\n\t\t\tif _, found := served[cust]; !found {\n\t\t\t\tnewlyServed++\n\t\t\t}\n\t\t}\n\t\tif newlyServed > largestIncrease {\n\t\t\tlargestIncrease = newlyServed\n\t\t\tlargestDrink = drink\n\t\t\tlargest = custs\n\t\t}\n\t}\n\tdelete(inverted, largestDrink)\n\tdrinks = append(drinks, largestDrink)\n\tfor _, cust := range largest {\n\t\tserved[cust] = struct{}{}\n\t}\n}\nsort.Slice(drinks, func(i, j int) bool {\n\treturn drinks[i] < drinks[j]\n})\nreturn drinks", "gen": "var b Bartender\nb.Serve()\n}\n"}
{"tgt": "wg.Add(2)\ngoincCounter(1)\ngoincCounter(2)\nwg.Wait()\nfmt.Println(\"STR\", counter)", "gen": "var wg sync.WaitGroup\nwg.Add(2)\ngo func() {\n\tcounter := 0\n\tfor i := 0; i < 1000000000; i++ {\n\t\tcounter++\n\t}\n\twg.Done()\n}()\ngo func() {\n\tcounter := 0\n\tfor i := 0; i < 1000000000; i++ {\n\t\tcounter++\n\t}\n\twg.Done()\n}()\nwg.Wait()\nfmt.Println(counter)\n}\n\n<ASM>\ncmpq %fs:112,%rsp\njnb .L18\nmovl $184,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL5:\nret\n.L18:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\nsubq $144,%rsp\nmovl $2,%esi\nleaq <main.wg>(%rip),%rdi\ncall <sync.WaitGroup.Add@PLT>\n.LBB8:\nleaq <type..struct.4.4x.5.5>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-176(%rbp)\nmovq -176(%rbp),%rax\nleaq <main.main..thunk0>(%rip),%rdx\nmovq %rax,%rsi\nmovq %rdx,%rdi\ncall <__go_go@PLT>\n.LBE8:\n.LBB9:\nleaq <type..struct.4.4x.5.5>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-168(%rbp)\nmovq -168(%rbp"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{{-1, 2, 1, -4}, {1}}, 2},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tret := threeSumClosest(c.inputs[0], c.inputs[1][0])\n\t\tif !reflect.DeepEqual(ret, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, ret, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 2}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello, world\")\n}\n"}
{"tgt": "sort.Slice(words, func(i, j int) bool {\n\tcuri := len(words[i])\n\tcurj := len(words[j])\n\tfor curi > 0 && curj > 0 {\n\t\tcuri--\n\t\tcurj--\n\t\tif words[i][curi] == words[j][curj] {\n\t\t\tcontinue\n\t\t}\n\t\tif words[i][curi] > words[j][curj] {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\treturn curi == 0\n})\nwords = append(words, \"STR\")\nres, i := 0, 1\nfor ; i < len(words); i++ {\n\tif !endWith(words[i], words[i-1]) {\n\t\tres += len(words[i-1]) + 1\n\t}\n}\nreturn res", "gen": "fmt.Println(minimumLengthEncoding(\"a\"))\nfmt.Println(minimumLengthEncoding(\"aa\"))\nfmt.Println(minimumLengthEncoding(\"aaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding"}
{"tgt": "fmt.Println(badLongestPalindrome(\"STR\"))\nfmt.Println(goodLongestPalindrome(\"STR\"))\nfmt.Println(bestLongestPalindrome(\"STR\"))", "gen": "fmt.Println(badLongestPalindrome(\"abba\"))\nfmt.Println(goodLongestPalindrome(\"abba\"))\nfmt.Println(bestLongestPalindrome(\"abba\"))\n}\n"}
{"tgt": "for i := 0; i < len(A)-1; i++ {\n\tif A[i] == i {\n\t\tcontinue\n\t}\n\tif A[i] == i+1 && A[i+1] == i {\n\t\ti++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"bad\")\n\t}\n}\n}\n\n// 0000000000000000 <main>:\n// 0:\t55                   \tpush   %rbp\n// 1:\t48 89 e5             \tmov    %rsp,%rbp\n// 4:\t48 83 ec 10          \tsub    $0x10,%rsp\n// 8:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// c:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// f:\t48 89 7d f0          \tmov    %rdx,-0x10(%rbp)\n// 13:\t48 89 75 e8          \tmov    %rsi,-0x18(%rbp)\n// 17:\t48 89 7d e0          \tmov    %rdx,-0x20(%rbp)\n// 1b:\t48 89 75 d8          \tmov    %rsi,-0x28(%rbp)\n// 1f:\t48 89 7d d0          \tmov    %rdx,-0x30(%rbp)\n// 23:\t48 89 75 c8          \tmov    %rsi,-0x38(%rbp)\n// 27:\t48 89 7d c0          \tmov    %rdx,-0x40(%rbp)\n// 2b:\t48 89 75 b8          \tmov    %rsi,-0x48(%rbp)\n// 2"}
{"tgt": "hash := uint32(0)\nfor i := len(sep) - 1; i >= 0; i-- {\n\thash = hash*PrimeRK + uint32(sep[i])\n}\nvar pow, sq uint32 = 1, PrimeRK\nfor i := len(sep); i > 0; i >>= 1 {\n\tif i&1 != 0 {\n\t\tpow *= sq\n\t}\n\tsq *= sq\n}\nreturn hash, pow", "gen": "var a [10]int\nvar b [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < 10; i++ {\n\ta[i] += b[i]\n}\nfmt.Println(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif sum := SumBSTRange(tc.root, tc.a, tc.b); sum != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, sum)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "arr := make([]bool, 105000)\narr[0], arr[1] = true, true\ncount, prime := 2, 3\nvar k int\nfor {\n\tfor k = 2 * prime; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tcount++\n\t\tif count == 10001 {\n\t\t\tprintln(prime)\n\t\t\tbreak\n\t\t}\n\t} else {\n\t\tbreak\n\t}\n}", "gen": "var a [100000]byte\nfor i := 0; i < 100000; i++ {\n\ta[i] = 1\n\ta[i+1] = 2\n}\nfor i := 0; i < 100000; i++ {\n\tif a[i] != 1 {\n\t\tpanic(\"a[i] != 1\")\n\t}\n\tif a[i+1] != 2 {\n\t\tpanic(\"a[i+1] != 2\")\n\t}\n}\nfor i := 0; i < 100000; i++ {\n\ta[i] = 0\n\ta[i+1] = 0\n}\nfor i := 0; i < 100000; i++ {\n\tif a[i] != 0 {\n\t\tpanic(\"a[i] != 0\")\n\t}\n\tif a[i+1] != 0 {\n\t\tpanic(\"a[i+1] != 0\")\n\t}\n}\nfor i := 0; i < 100000; i++ {\n\ta[i] = 1\n\ta[i+1] = 2\n}\nfor i := 0; i < 100000; i++ {\n\tif a[i] != 1 {\n\t\tpanic(\"a[i] != 1\")\n\t}\n\tif a[i+1] != 2 {\n\t\tpanic(\"a[i+1] != 2\")\n\t}\n}\nfor i := 0; i < 100000; i++ {\n\ta[i] = 0\n\ta[i+1] = 0\n}\nfor i := 0; i < 100000; i++ {\n\tif a[i] != 0 {\n"}
{"tgt": "n1, n2 := len(nums1), len(nums2)\nif n1 > n2 {\n\tn1, n2, nums1, nums2 = n2, n1, nums2, nums1\n}\nm := make(map[int]int, n1)\nfor _, num := range nums1 {\n\tm[num]++\n}\nres := make([]int, 0, n1)\nfor _, num := range nums2 {\n\tif v, ok := m[num]; ok && v > 0 {\n\t\tres = append(res, num)\n\t\tm[num]--\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [4]int\nvar c [5]int\nvar d [6]int\nvar e [7]int\nvar f [8]int\nvar g [9]int\nvar h [10]int\nvar i [11]int\nvar j [12]int\nvar k [13]int\nvar l [14]int\nvar m [15]int\nvar n [16]int\nvar o [17]int\nvar p [18]int\nvar q [19]int\nvar r [20]int\nvar s [21]int\nvar t [22]int\nvar u [23]int\nvar v [24]int\nvar w [25]int\nvar x [26]int\nvar y [27]int\nvar z [28]int\nvar aa [29]int\nvar ab [30]int\nvar ac [31]int\nvar ad [32]int\nvar ae [33]int\nvar af [34]int\nvar ag [35]int\nvar ah [36]int\nvar ai [37]int\nvar aj [38]int\nvar ak [39]int\nvar al [40]int\nvar am [41]int\nvar an [42]int\nvar ao [43]int\nvar ap [44]int\nvar aq [45]int\nvar ar [46]int\nvar as [47]int\nvar at [48]int\nvar au [49]int\nvar av [50]int\nvar aw [51]int\nvar ax [52]int\nvar ay [53]int\nvar az [54]int\nvar ba [55]int\nvar bb [56]int\nvar bc [57]int\nvar bd [58]"}
{"tgt": "if root == nil {\n\treturn nil\n}\ns := []*TreeNode{root}\nres := [][]int{}\nzigzag := false\nfor len(s) != 0 {\n\ttmp := []*TreeNode{}\n\tl := []int{}\n\tfor i, node := range s {\n\t\tif zigzag {\n\t\t\tl = append(l, s[len(s)-i-1].Val)\n\t\t} else {\n\t\t\tl = append(l, node.Val)\n\t\t}\n\t\tif node.Left != nil {\n\t\t\ttmp = append(tmp, node.Left)\n\t\t}\n\t\tif node.Right != nil {\n\t\t\ttmp = append(tmp, node.Right)\n\t\t}\n\t}\n\tres = append(res, l)\n\ts = tmp\n\tzigzag = !zigzag\n}\nreturn res", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aaa int\nvar bbb int\nvar ccc int\nvar ddd int\nvar eee int\nvar fff int\nvar ggg int\nvar hhh int\nvar iii int\nvar jjj int\nvar kkk int\nvar lll int\nvar mmm int\nvar nnn int\nvar ooo int\nvar ppp int\nvar qqq int\nvar rrr int\nvar sss int\nvar ttt int\nvar uuu int\nvar vvv int\nvar www int\nvar xxx int\nvar yyy int\nvar zzz int\nvar aaaa int\nvar bbbb int\nvar cccc int\nvar dddd int\nvar eeee int\nvar ffff int\nvar gggg int\nvar hhhh int\nvar iiii int\nvar jjjj int\n"}
{"tgt": "if len(str) == 0 {\n\treturn 0\n}\nvar (\n\tnum int\n\tneg bool\n)\nfor i, s := range str {\n\tif s != ' ' {\n\t\tstr = str[i:]\n\t\tbreak\n\t}\n}\nif str[0] == '+' {\n\tstr = str[1:]\n} else if str[0] == '-' {\n\tstr = str[1:]\n\tneg = true\n}\nfor _, s := range str {\n\tif s < '0' || s > '9' {\n\t\tbreak\n\t}\n\tnum = num*10 + int(s-'0')\n\tif num > 2147483648 {\n\t\tnum = 2147483648\n\t\tbreak\n\t}\n}\nif neg {\n\tnum *= -1\n} else if num > 2147483647 {\n\tnum = 2147483647\n}\nreturn num", "gen": "var s []byte\nvar i int\nfor i = 0; i < 1000000000; i++ {\n\ts = append(s, 'a')\n}\nprintln(string(s))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "ans, m, n := []int{}, len(matrix), len(matrix[0])\nfor j := 0; j < n; j++ {\n\tmax, rowIndex := 1, 0\n\tfor i := 0; i < m; i++ {\n\t\tif matrix[i][j] > max {\n\t\t\tmax = matrix[i][j]\n\t\t\trowIndex = i\n\t\t}\n\t}\n\tif Min(matrix[rowIndex]) == max {\n\t\tans = append(ans, max)\n\t}\n}\nreturn ans", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "strNumber := strconv.Itoa(number)\nfor _, runeDigit := range []rune(strNumber) {\n\tdigit := int(runeDigit - '0')\n\tlist = append(list, digit)\n}\nreturn", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "if num == 0 {\n\treturn \"STR\"\n}\nh := []string{\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\",\n\t\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\"}\nres := \"STR\"\nfor i := 0; i < 8 && num != 0; i++ {\n\tres = h[num&15] + res\n\tnum >>= 4\n}\nreturn res", "gen": "var s string\nfor i := 0; i < 8; i++ {\n\ts += \"hello\"\n}\nprintln(s)\n}\n\n// func main() {\n// \tvar s string\n// \tfor i := 0; i < 8; i++ {\n// \t\ts += \"hello\"\n// \t}\n// \tprintln(s)\n// }\n\n// func main() {\n// \tvar s string\n// \tfor i := 0; i < 8; i++ {\n// \t\ts += \"hello\"\n// \t}\n// \tprintln(s)\n// }\n\n// func main() {\n// \tvar s string\n// \tfor i := 0; i < 8; i++ {\n// \t\ts += \"hello\"\n// \t}\n// \tprintln(s)\n// }\n\n// func main() {\n// \tvar s string\n// \tfor i := 0; i < 8; i++ {\n// \t\ts += \"hello\"\n// \t}\n// \tprintln(s)\n// }\n\n// func main() {\n// \tvar s string\n// \tfor i := 0; i < 8; i++ {\n// \t\ts += \"hello\"\n// \t}\n// \tprintln(s)\n// }\n\n// func main() {\n// \tvar s string\n// \tfor i := 0; i < 8; i++ {\n// \t\ts += \"hello\"\n// \t}\n// \tprintln(s)\n// }\n\n// func main() {\n// \tvar s string\n// \tfor i := 0; i < 8; i++ {\n// \t\ts += \"hello\"\n// \t}\n// \tprintln(s)\n// }\n\n// func main() {\n// \tvar s string\n// \tfor i := 0; i < 8; i++ {\n// \t\ts += \"hello\"\n// \t}\n// \tprintln(s)"}
{"tgt": "if len(n.Exprs) == 0 {\n\treturn TypeString, nil\n}\nif len(n.Exprs) == 1 {\n\texprType, err := n.Exprs[0].Type(s)\n\tif err != nil {\n\t\treturn TypeInvalid, err\n\t}\n\tswitch exprType {\n\tcase TypeList:\n\t\treturn TypeList, nil\n\tcase TypeMap:\n\t\treturn TypeMap, nil\n\t}\n}\nfor index, expr := range n.Exprs {\n\texprType, err := expr.Type(s)\n\tif err != nil {\n\t\treturn TypeInvalid, err\n\t}\n\tif exprType == TypeList || exprType == TypeMap {\n\t\treturn TypeInvalid, fmt.Errorf(\n\t\t\t\"STR\",\n\t\t\tindex, exprType)\n\t}\n}\nreturn TypeString, nil", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "psum, min := 0, 1\nfor _, val := range nums {\n\tpsum += val\n\tif psum < min {\n\t\tmin = psum\n\t}\n}\nif min > 0 {\n\treturn min\n}\nreturn -min + 1", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tprintln(a[i])\n}\n}\n\n// Output:\n// 0\n// 1\n// 2\n// 3\n// 4\n// 5\n// 6\n// 7\n// 8\n// 9\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n.LBB26:\nmovq $0,-24(%rbp)\n.LBB27:\nmovq $0,-8(%rbp)\n.LBB28:\n.LBB29:\n.LBB30:\nmovq <16>(%rbp),%rax\nmovq <24>(%rbp),%rdx\nmovq %rax,-64(%rbp)\nmovq %rdx,-56(%rbp)\nmovq <32>(%rbp),%rax\nmovq %rax,-48(%rbp)\nmovq -56(%rbp),%rcx\nmovl $0,%eax\n.LBE30:\njmp .L29\n.L38:\n.LBB31:\nnop\n.LBE31:\n.LBB32:\n.LBB33:\nmovq -56(%rbp),%rdx\ntestq %rax,%rax\njs .L30\ncmpq %rdx,%rax\njge .L30\nmovq -64(%rbp),%rdx\nmovq %rax,%rsi\nsalq $3,%rsi\naddq %rsi,%rdx\nmovq (%rdx),%rdx\n.LBE33:\n.LBB34:\nmovq %rdx,-32(%rbp)\n.LBE34:\n.LBB35:\nmovq -32(%rbp),%rdx\naddq %rdx,-8"}
{"tgt": "arr := make([]bool, 2000000)\narr[0], arr[1] = true, true\nsum, prime := int64(5), 3\nvar k int\nfor {\n\tfor k = 2 * prime; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tsum += int64(k)\n\t} else {\n\t\tbreak\n\t}\n}\nprintln(sum)", "gen": "var a [2000000]byte\na[1] = 1\na[2] = 1\na[3] = 1\na[4] = 1\na[5] = 1\na[6] = 1\na[7] = 1\na[8] = 1\na[9] = 1\na[10] = 1\na[11] = 1\na[12] = 1\na[13] = 1\na[14] = 1\na[15] = 1\na[16] = 1\na[17] = 1\na[18] = 1\na[19] = 1\na[20] = 1\na[21] = 1\na[22] = 1\na[23] = 1\na[24] = 1\na[25] = 1\na[26] = 1\na[27] = 1\na[28] = 1\na[29] = 1\na[30] = 1\na[31] = 1\na[32] = 1\na[33] = 1\na[34] = 1\na[35] = 1\na[36] = 1\na[37] = 1\na[38] = 1\na[39] = 1\na[40] = 1\na[41] = 1\na[42] = 1\na[43] = 1\na[44] = 1\na[45] = 1\na[46] = 1\na[47] = 1\na[48] = 1\na[49] = 1\na[50"}
{"tgt": "qs := []question693{\n\t{\n\t\tpara693{5},\n\t\tans693{true},\n\t},\n\t{\n\t\tpara693{7},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{11},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{10},\n\t\tans693{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans693, q.para693\n\tfmt.Printf(\"STR\", p, hasAlternatingBits(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "sum := 0\nfor i := 1; i <= n; i++ {\n\tsquare := i * i\n\tsum += square\n}\nreturn sum", "gen": "var a, b int\nfor i := 0; i < 1000000000; i++ {\n\ta = i\n\tb = i * i\n}\nprintln(a, b)\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.nums); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "var i int\nfor j, k := 0, 0; j < len(nums); j = k {\n\tfor k < len(nums) && nums[j] == nums[k] {\n\t\tif k < j+2 {\n\t\t\tnums[i] = nums[k]\n\t\t\ti++\n\t\t}\n\t\tk++\n\t}\n}\nreturn i", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor"}
{"tgt": "result := make([]int, 0, len(left)+len(right))\nfor len(left) > 0 || len(right) > 0 {\n\tif len(left) == 0 {\n\t\treturn append(result, right...)\n\t}\n\tif len(right) == 0 {\n\t\treturn append(result, left...)\n\t}\n\tif left[0] <= right[0] {\n\t\tresult = append(result, left[0])\n\t\tleft = left[1:]\n\t} else {\n\t\tresult = append(result, right[0])\n\t\tright = right[1:]\n\t}\n}\nreturn result", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "if 0 == n {\n\treturn 0\n} else {\n\treturn n/5 + trailingZeroes(n/5)\n}", "gen": "fmt.Println(trailingZeroes(1000000000000000000))\n}\n"}
{"tgt": "n := len(s)\nuf := newUnionFind(n)\nfor _, p := range pairs {\n\tuf.connect(p[0], p[1])\n}\ngroups := make(map[int][]int, n)\nfor c, p := range uf.parent {\n\tp = uf.find(p)\n\tgroups[p] = append(groups[p], c)\n}\nbytes := []byte(s)\nres := make([]byte, n)\nfor _, g := range groups {\n\tsize := len(g)\n\ta := make([]int, size)\n\tcopy(a, g)\n\tsort.Slice(a, func(i, j int) bool {\n\t\treturn bytes[a[i]] < bytes[a[j]]\n\t})\n\tsort.Ints(g)\n\tfor i := 0; i < size; i++ {\n\t\tres[g[i]] = bytes[a[i]]\n\t}\n}\nreturn string(res)", "gen": "fmt.Println(smallestStringWithSwaps([]string{\"dc\", \"cb\", \"ab\"}, [][]int{{0, 1}, {1, 0}}))\nfmt.Println(smallestStringWithSwaps([]string{\"cba\", \"da\", \"cb\"}, [][]int{{1, 2}, {0, 1}, {1, 0}}))\nfmt.Println(smallestStringWithSwaps([]string{\"abcd\", \"cdab\", \"adcb\", \"cbad\"}, [][]int{{0, 1}, {1, 2}, {0, 2}, {1, 3}}))\nfmt.Println(smallestStringWithSwaps([]string{\"abcd\", \"cdab\", \"adcb\", \"cbad\"}, [][]int{{0, 1}, {1, 2}, {0, 3}, {1, 3}}))\nfmt.Println(smallestStringWithSwaps([]string{\"abcd\", \"cdab\", \"adcb\", \"cbad\"}, [][]int{{0, 1}, {1, 2}, {0, 3}, {1, 0}}))\nfmt.Println(smallestStringWithSwaps([]string{\"abcd\", \"cdab\", \"adcb\", \"cbad\"}, [][]int{{0, 1}, {1, 2}, {0, 3}, {0, 1}}))\nfmt.Println(smallestStringWithSwaps([]string{\"abcd\", \"cdab\", \"adcb\", \"cbad\"}, [][]int{{0, 1}, {1, 2}, {0, 3}, {0, 1}, {0, 1}}))\nfmt.Println(smallestStringWithSwaps([]string{\"abcd\", \"cdab\", \"adcb\", \"cbad\"}, [][]int{{0, 1}, {1, 2}, {0, 3}, {0, 1}, {0, 1}, {0, 1}}))\nfmt.Println(smallestStringWithSwaps([]string{\"abcd\", \"cdab\", \"adcb\", \"cbad\"}, [][]"}
{"tgt": "data := [][]int{\n\t{2},\n\t{3, 4},\n\t{6, 5, 7},\n\t{4, 1, 8, 3}}\nfmt.Println(minimumTotal(data))", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nvar b [3]int\nb[0] = 4\nb[1] = 5\nb[2] = 6\nvar c [3]int\nc[0] = 7\nc[1] = 8\nc[2] = 9\nvar d [3]int\nd[0] = 10\nd[1] = 11\nd[2] = 12\nvar e [3]int\ne[0] = 13\ne[1] = 14\ne[2] = 15\nvar f [3]int\nf[0] = 16\nf[1] = 17\nf[2] = 18\nvar g [3]int\ng[0] = 19\ng[1] = 20\ng[2] = 21\nvar h [3]int\nh[0] = 22\nh[1] = 23\nh[2] = 24\nvar i [3]int\ni[0] = 25\ni[1] = 26\ni[2] = 27\nvar j [3]int\nj[0] = 28\nj[1] = 29\nj[2] = 30\nvar k [3]int\nk[0] = 31\nk[1] = 32\nk[2] = 33\nvar l [3]int\nl[0] = 34\nl[1] = 35\nl[2] = 36\nvar m [3]int\nm[0] = 37\nm[1] = 38\nm[2] = 39\nvar n [3]int\nn[0] = "}
{"tgt": "left, right, res := 0, -1, 0\nfor left < len(s) {\n\tif right+1 < len(s) && maxCost-abs(int(s[right+1]-'a')-int(t[right+1]-'a')) >= 0 {\n\t\tright++\n\t\tmaxCost -= abs(int(s[right]-'a') - int(t[right]-'a'))\n\t} else {\n\t\tres = max(res, right-left+1)\n\t\tmaxCost += abs(int(s[left]-'a') - int(t[left]-'a'))\n\t\tleft++\n\t}\n}\nreturn res", "gen": "fmt.Println(abs(-1))\nfmt.Println(abs(0))\nfmt.Println(abs(1))\nfmt.Println(abs(10))\nfmt.Println(abs(-10))\nfmt.Println(abs(100))\nfmt.Println(abs(-100))\nfmt.Println(abs(1000))\nfmt.Println(abs(-1000))\nfmt.Println(abs(10000))\nfmt.Println(abs(-10000))\nfmt.Println(abs(100000))\nfmt.Println(abs(-100000))\nfmt.Println(abs(1000000))\nfmt.Println(abs(-1000000))\nfmt.Println(abs(10000000))\nfmt.Println(abs(-10000000))\nfmt.Println(abs(100000000))\nfmt.Println(abs(-100000000))\nfmt.Println(abs(1000000000))\nfmt.Println(abs(-1000000000))\nfmt.Println(abs(10000000000))\nfmt.Println(abs(-10000000000))\nfmt.Println(abs(100000000000))\nfmt.Println(abs(-100000000000))\nfmt.Println(abs(1000000000000))\nfmt.Println(abs(-1000000000000))\nfmt.Println(abs(10000000000000))\nfmt.Println(abs(-10000000000000))"}
{"tgt": "nums := []int{}\nfor n != 0 {\n\tnums = append(nums, n%10)\n\tn /= 10\n}\nm := len(nums)\nif m < 2 {\n\treturn -1\n}\ni := 1\nfor i < m {\n\tif nums[i] < nums[i-1] {\n\t\tbreak\n\t}\n\ti++\n}\nif i == m {\n\treturn -1\n}\nj := 0\nfor j < i {\n\tif nums[j] > nums[i] {\n\t\tbreak\n\t}\n\tj++\n}\nnums[i], nums[j] = nums[j], nums[i]\nfor k := 0; k < i/2; k++ {\n\tnums[k], nums[i-k-1] = nums[i-k-1], nums[k]\n}\nres := 0\np := 1\nfor _, n := range nums {\n\tres += n * p\n\tp *= 10\n}\nif res > math.MaxInt32 {\n\treturn -1\n}\nreturn res", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nvar b [3]int\nb[0] = 1\nb[1] = 2\nb[2] = 3\nvar c [3]int\nc[0] = 1\nc[1] = 2\nc[2] = 3\nvar d [3]int\nd[0] = 1\nd[1] = 2\nd[2] = 3\nvar e [3]int\ne[0] = 1\ne[1] = 2\ne[2] = 3\nvar f [3]int\nf[0] = 1\nf[1] = 2\nf[2] = 3\nvar g [3]int\ng[0] = 1\ng[1] = 2\ng[2] = 3\nvar h [3]int\nh[0] = 1\nh[1] = 2\nh[2] = 3\nvar i [3]int\ni[0] = 1\ni[1] = 2\ni[2] = 3\nvar j [3]int\nj[0] = 1\nj[1] = 2\nj[2] = 3\nvar k [3]int\nk[0] = 1\nk[1] = 2\nk[2] = 3\nvar l [3]int\nl[0] = 1\nl[1] = 2\nl[2] = 3\nvar m [3]int\nm[0] = 1\nm[1] = 2\nm[2] = 3\nvar n [3]int\nn[0] = 1\nn[1] = 2\nn[2] = 3\nvar o [3]int\no"}
{"tgt": "x := []int{10, 20, 30, 40, 50}\nfor k, v := range x {\n\tfmt.Printf(\"STR\", k, v)\n}", "gen": "var a [5]int\nvar b [5]int\nvar c [5]int\nvar d [5]int\nvar e [5]int\nvar f [5]int\nvar g [5]int\nvar h [5]int\nvar i [5]int\nvar j [5]int\nvar k [5]int\nvar l [5]int\nvar m [5]int\nvar n [5]int\nvar o [5]int\nvar p [5]int\nvar q [5]int\nvar r [5]int\nvar s [5]int\nvar t [5]int\nvar u [5]int\nvar v [5]int\nvar w [5]int\nvar x [5]int\nvar y [5]int\nvar z [5]int\nvar aa [5]int\nvar ab [5]int\nvar ac [5]int\nvar ad [5]int\nvar ae [5]int\nvar af [5]int\nvar ag [5]int\nvar ah [5]int\nvar ai [5]int\nvar aj [5]int\nvar ak [5]int\nvar al [5]int\nvar am [5]int\nvar an [5]int\nvar ao [5]int\nvar ap [5]int\nvar aq [5]int\nvar ar [5]int\nvar as [5]int\nvar at [5]int\nvar au [5]int\nvar av [5]int\nvar aw [5]int\nvar ax [5]int\nvar ay [5]int\nvar az [5]int\nvar ba [5]int\nvar bb [5]int\nvar bc [5]int\nvar bd [5]int\nvar be [5]int\nvar bf [5]int\nvar bg [5]int\nvar bh [5]int\nvar bi [5]int\nvar bj ["}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif jumps, impassable := MinimumJumps(tc.maxSteps); impassable != tc.impassable || jumps != tc.expectedJumps {\n\t\tt.Errorf(\"STR\", tc.expectedJumps, tc.impassable, jumps, impassable)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "c.bw.WriteString(\"STR\")\nc.bw.WriteByte(space)\nc.bw.WriteString(key)\nc.bw.WriteByte(space)\nc.bw.Write(strconv.AppendInt(c.numScratch[:0], int64(timeout), 10))\n_, err = c.bw.Write(crlf)\nreturn", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```\n.file\t\"main.go\"\n.text\n.globl\tmain\n.type\tmain, @function\nmain:\n.LFB254:\n.cfi_startproc\npushq\t%rbp\n.cfi_def_cfa_offset 16\n.cfi_offset 6, -16\nmovq\t%rsp, %rbp\n.cfi_def_cfa_register 6\nsubq\t$368, %rsp\nmovq\t%rdi, -344(%rbp)\nmovq\t%rsi, -368(%rbp)\nmovq\t%rdx, -360(%rbp)\nmovl\t%ecx, -348(%rbp)\nmovq\t$0, -336(%rbp)\nmovq\t$0, -328(%rbp)\n.L289:\nleaq\t.LC195(%rip), %r8\nmovl\t$5, %r9d\nmovq\t-344(%rbp), %rax\nmovq\t64(%rax), %rsi\nleaq\t-160(%rbp), %rax\nmovq\t%r8, %rdx\nmovq\t%r9, %rcx\nmovq\t%rax, %rdi\ncall\tbufio.Writer.WriteString@PLT\nmovq\t-160(%rbp), %rax\nmovq\t-152(%rbp), %rdx\nmovq\t%rax, -320(%rbp)\nmovq\t%rdx, -312(%rbp)\nmovq\t-144(%rbp), %rax\nmovq\t%rax, -304(%rbp)\nmovzbl\tgo.memcache.space(%rip), %edx\n"}
{"tgt": "if len(s) == 0 {\n\treturn \"STR\"\n}\nstart := 0\nmaxLen := 1\nfor index := range s {\n\tl := index - maxLen\n\tend := index + 1\n\tif l >= 1 && sym(s[l-1:end]) {\n\t\tstart = l - 1\n\t\tmaxLen += 2\n\t} else if l >= 0 && sym(s[l:end]) {\n\t\tstart = l\n\t\tmaxLen += 1\n\t}\n}\nreturn s[start : start+maxLen]", "gen": "var s []byte\nvar i int\nfor {\n\tif i >= len(s) {\n\t\tbreak\n\t}\n\tif s[i] == 127 {\n\t\tbreak\n\t}\n\ti++\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "http.HandleFunc(path, func(res http.ResponseWriter, req *http.Request) {\n\terr := handleFunc(res, req)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), 500)\n\t}\n})", "gen": "http.HandleFunc(\"/\", handle)\n}\n"}
{"tgt": "kind := t.Kind()\nif kind >= Int && kind <= Complex128 {\n\treturn int(t.Size()) * 8\n}\npanic(TypeError{\"STR\"})", "gen": "var x int\nvar y int\nvar z int\nvar w int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\n"}
{"tgt": "println(\"STR\", len(a))", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\tprintln(a[i])\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return e.Errs[0].Error()", "gen": "var a [3]int\na[1] = 1\na[2] = 2\na[0] = a[1] + a[2]\nprintln(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "stack := make([]int, 0)\nresult := make([]int, len(T))\nfor i, t := range T {\n\tfor len(stack) > 0 && T[stack[len(stack)-1]] < t {\n\t\tresult[stack[len(stack)-1]] = i - stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t}\n\tstack = append(stack, i)\n}\nfor _, i := range stack {\n\tresult[i] = 0\n}\nreturn result", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "h := new(IntArray)\nh.heapIntArrays = arr\nh.heap.binHeapArrayIf = &h.heapIntArrays\nh.BuildHeap()\nreturn h", "gen": "var a = IntArray{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\na.BuildHeap()\nfmt.Println(a)\n}\n"}
{"tgt": "if n == 1 || n == 2 {\n\treturn big.NewInt(1)\n}\nif mem[n] != nil {\n\treturn mem[n]\n}\nresult := big.NewInt(0)\nresult.Add(FibonacciHelper(n-1, mem), FibonacciHelper(n-2, mem))\nmem[n] = result\nreturn result", "gen": "var a [100]int\nvar b [100]int\nvar c [100]int\nvar d [100]int\nvar e [100]int\nvar f [100]int\nvar g [100]int\nvar h [100]int\nvar i [100]int\nvar j [100]int\nvar k [100]int\nvar l [100]int\nvar m [100]int\nvar n [100]int\nvar o [100]int\nvar p [100]int\nvar q [100]int\nvar r [100]int\nvar s [100]int\nvar t [100]int\nvar u [100]int\nvar v [100]int\nvar w [100]int\nvar x [100]int\nvar y [100]int\nvar z [100]int\nvar aa [100]int\nvar ab [100]int\nvar ac [100]int\nvar ad [100]int\nvar ae [100]int\nvar af [100]int\nvar ag [100]int\nvar ah [100]int\nvar ai [100]int\nvar aj [100]int\nvar ak [100]int\nvar al [100]int\nvar am [100]int\nvar an [100]int\nvar ao [100]int\nvar ap [100]int\nvar aq [100]int\nvar ar [100]int\nvar as [100]int\nvar at [100]int\nvar au [100]int\nvar av [100]int\nvar aw [100]int\nvar ax [100]"}
{"tgt": "coins := []int{1, 2, 5, 10, 20, 50, 100, 200}\nmemo := make(map[string]int)\nreturn findAllWays(coins, 0, n, memo)", "gen": "var m map[int]int\nm[1] = 2\nm[5] = 10\nm[10] = 20\nm[20] = 50\nm[50] = 100\nm[100] = 200\nm[8] = 8\nfmt.Println(findAllWays(m))\n}\n"}
{"tgt": "data, err := base64.StdEncoding.DecodeString(b64)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(data)", "gen": "var s = \"1234567890\"\nvar b []byte\nb = []byte(s)\nvar s2 = \"1234567890\"\nvar b2 []byte\nb2 = []byte(s2)\nvar s3 = \"1234567890\"\nvar b3 []byte\nb3 = []byte(s3)\nvar s4 = \"1234567890\"\nvar b4 []byte\nb4 = []byte(s4)\nvar s5 = \"1234567890\"\nvar b5 []byte\nb5 = []byte(s5)\nvar s6 = \"1234567890\"\nvar b6 []byte\nb6 = []byte(s6)\nvar s7 = \"1234567890\"\nvar b7 []byte\nb7 = []byte(s7)\nvar s8 = \"1234567890\"\nvar b8 []byte\nb8 = []byte(s8)\nvar s9 = \"1234567890\"\nvar b9 []byte\nb9 = []byte(s9)\nvar s10 = \"1234567890\"\nvar b10 []byte\nb10 = []byte(s10)\nvar s11 = \"1234567890\"\nvar b11 []byte\nb11 = []byte(s11)\nvar s12 = \"1234567890\"\nvar b12 []byte\nb12 = []byte(s12)\nvar s13 = \"1234567890\"\nvar b13 []byte\nb13 = []byte(s13)\nvar s14 = \"1234567890\"\n"}
{"tgt": "qs := []question322{\n\t{\n\t\tpara322{[]int{186, 419, 83, 408}, 6249},\n\t\tans322{20},\n\t},\n\t{\n\t\tpara322{[]int{1, 2147483647}, 2},\n\t\tans322{2},\n\t},\n\t{\n\t\tpara322{[]int{1, 2, 5}, 11},\n\t\tans322{3},\n\t},\n\t{\n\t\tpara322{[]int{2}, 3},\n\t\tans322{-1},\n\t},\n\t{\n\t\tpara322{[]int{1}, 0},\n\t\tans322{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans322, q.para322\n\tfmt.Printf(\"STR\", p, coinChange(p.one, p.amount))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.locs); !reflect.DeepEqual(bonuses, tc.bonuses) {\n\t\tt.Errorf(\"STR\", tc.bonuses, bonuses)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "count := uint32(0)\nfor num != 0 {\n\tcount += num & 1\n\tnum = num >> 1\n}\nreturn int(count)", "gen": "var a int\na = 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\na = a >> 1\na = a << 1\na = a & 1\n"}
{"tgt": "var sum int\nfor _, num := range nums {\n\tsum += num\n}\nif sum%2 != 0 {\n\treturn false\n}\nc := sum / 2\nn := len(nums)\nmemo := make([]bool, c+1)\nfor i := 0; i <= c; i++ {\n\tmemo[i] = nums[0] == i\n}\nfor i := 0; i < n; i++ {\n\tfor j := c; j >= nums[i]; j-- {\n\t\tmemo[j] = memo[j] || memo[j-nums[i]]\n\t}\n}\nreturn memo[c]", "gen": "var a [10]byte\nvar b [10]byte\nvar c [10]byte\nvar d [10]byte\nvar e [10]byte\nvar f [10]byte\nvar g [10]byte\nvar h [10]byte\nvar i [10]byte\nvar j [10]byte\nvar k [10]byte\nvar l [10]byte\nvar m [10]byte\nvar n [10]byte\nvar o [10]byte\nvar p [10]byte\nvar q [10]byte\nvar r [10]byte\nvar s [10]byte\nvar t [10]byte\nvar u [10]byte\nvar v [10]byte\nvar w [10]byte\nvar x [10]byte\nvar y [10]byte\nvar z [10]byte\nvar aa [10]byte\nvar ab [10]byte\nvar ac [10]byte\nvar ad [10]byte\nvar ae [10]byte\nvar af [10]byte\nvar ag [10]byte\nvar ah [10]byte\nvar ai [10]byte\nvar aj [10]byte\nvar ak [10]byte\nvar al [10]byte\nvar am [10]byte\nvar an [10]byte\nvar ao [10]byte\nvar ap [10]byte\nvar aq [10]byte\nvar ar [10]byte\nvar as [10]byte\nvar at [10]byte\nvar au [10]byte\nvar av [10]byte\nvar aw [10]byte\nvar ax [10]byte\nvar ay [10]byte\nvar az [10]byte\nvar aaa [10]byte\nvar aab [10]byte\nvar aac [10]byte\n"}
{"tgt": "count1 := 0\nfor _, r := range S {\n\tif r == '(' {\n\t\tcount1++\n\t} else if count1 > 0 {\n\t\tcount1--\n\t}\n}\ncount2 := 0\nfor i := len(S) - 1; i >= 0; i-- {\n\tif S[i] == ')' {\n\t\tcount2++\n\t} else if count2 > 0 {\n\t\tcount2--\n\t}\n}\nreturn count1 + count2", "gen": "var s string\nvar i int\nfor i = 0; i < 10; i++ {\n\ts += \"a\"\n}\nprintln(s)\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname __morestack runtime.morestack"}
{"tgt": "for i := rangeMin; i <= rangeMax; i++ {\n\tif evenlyDivisble%i != 0 {\n\t\tevenlyDivisble = evenlyDivisble * lcm(evenlyDivisble, i)\n\t}\n\tfmt.Println(evenlyDivisble, \"STR\", i, \"STR\", evenlyDivisble/i)\n}", "gen": "var rangeMin int64 = 1\nvar rangeMax int64 = 20\nvar evenlyDivisble int64 = 2\nvar lcm int64\nfor i := rangeMin; i <= rangeMax; i++ {\n\tif i % evenlyDivisble == 0 {\n\t\tlcm = lcm * i / gcd(lcm, i)\n\t}\n}\nfmt.Println(lcm)\n}"}
{"tgt": "log.SetFlags(0)\nvar err error\ntpl := template.New(\"STR\")\ntpl = tpl.Funcs(template.FuncMap{\n\t\"STR\": func(str string) string {\n\t\treturn strings.ToUpper(str)\n\t},\n})\ntpl, err = tpl.ParseFiles(\"STR\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nerr = tpl.ExecuteTemplate(os.Stdout, \"STR\", Page{\n\tTitle: \"STR\",\n\tBody:  \"STR\",\n})\nif err != nil {\n\tlog.Fatalln(err)\n}", "gen": "log.SetFlags(0)\nt := template.New(\"\")\nt = t.Funcs(template.FuncMap{\n\t\"f\": func(s string) string {\n\t\treturn strings.ToUpper(s)\n\t},\n})\nt, _ = t.ParseFiles(\"test.html\")\np := Page{Title: \"Test Page\", Body: \"This is a test page.\"}\nt.ExecuteTemplate(os.Stdout, \"test.html\", p)\n}\n"}
{"tgt": "return append(ints, added...)", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "left, right := 0, len(nums)-1\nfor left < right {\n\tmid := (left + right) / 2\n\tcount := 0\n\tfor _, num := range nums {\n\t\tif num <= mid {\n\t\t\tcount++\n\t\t}\n\t}\n\tif count > mid {\n\t\tright = mid\n\t} else {\n\t\tleft = mid + 1\n\t}\n}\nreturn left", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tprintln(a[i])\n}\n}\n\n// func main() {\n// \tvar a [10]int\n// \tfor i := 0; i < 10; i++ {\n// \t\ta[i] = i\n// \t}\n// \tfor i := 0; i < 10; i++ {\n// \t\tprintln(a[i])\n// \t}\n// }\n\n// func main() {\n// \tvar a [10]int\n// \tfor i := 0; i < 10; i++ {\n// \t\ta[i] = i\n// \t}\n// \tfor i := 0; i < 10; i++ {\n// \t\tprintln(a[i])\n// \t}\n// }\n\n// func main() {\n// \tvar a [10]int\n// \tfor i := 0; i < 10; i++ {\n// \t\ta[i] = i\n// \t}\n// \tfor i := 0; i < 10; i++ {\n// \t\tprintln(a[i])\n// \t}\n// }\n\n// func main() {\n// \tvar a [10]int\n// \tfor i := 0; i < 10; i++ {\n// \t\ta[i] = i\n// \t}\n// \tfor i := 0; i < 10; i++ {\n// \t\tprintln(a[i])\n// \t}\n// }\n\n// func main() {\n// \tvar a [10]int\n// \tfor i := 0; i < 10; i++ {\n// \t\ta[i] = i\n// \t}\n// \tfor i := 0; i < 10"}
{"tgt": "var min int\ntotalPeople := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\ttotalPeople++\n\t}\n}\nif totalPeople < 2 {\n\treturn 0\n}\nmiddle := (totalPeople / 2) + (totalPeople % 2)\nindex := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\tmiddle--\n\t}\n\tif middle == 0 {\n\t\tindex = i\n\t\tbreak\n\t}\n}\nleftZero := 0\nleftZeroFound := false\nfor j := index - 1; j >= 0; j-- {\n\tif !leftZeroFound && seating[j] == 0 {\n\t\tleftZero = j\n\t\tleftZeroFound = true\n\t} else if seating[j] == 1 && j < leftZero {\n\t\tmin += abs(j - leftZero)\n\t\tleftZero--\n\t}\n}\nrightZero := 0\nrightZeroFound := false\nfor j := index + 1; j < len(seating); j++ {\n\tif !rightZeroFound && seating[j] == 0 {\n\t\trightZero = j\n\t\trightZeroFound = true\n\t} else if seating[j] == 1 && j > rightZero {\n\t\tmin += abs(j - rightZero)\n\t\trightZero++\n\t}\n}\nreturn min", "gen": "var a [3]int\nvar b [3]int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar ba int\nvar bb int\nvar bc int\nvar bd int\nvar be int\nvar bf int\nvar bg int\nvar bh int\nvar bi int\nvar bj int\nvar bk int\nvar bl int\nvar bm int\nvar bn int\nvar bo int\nvar bp int\nvar bq int\nvar br int\nvar bs int\nvar bt int\nvar bu int\nvar bv int\nvar bw int\nvar bx int\nvar by int\nvar bz int\nvar ca int\nvar cb int\nvar cc int\nvar cd int\nvar ce int\nvar cf int\nvar cg int\nvar ch int\nvar ci int\nvar cj int\nvar ck int\nvar cl int\nvar cm int\nvar cn int\nvar co int\nvar cp int\n"}
{"tgt": "targetRange := []int{-1, -1}\nfor i := 0; i < len(nums); i++ {\n\tif nums[i] == target {\n\t\ttargetRange[0] = i\n\t\tbreak\n\t}\n}\nif targetRange[0] == -1 {\n\treturn targetRange\n}\nfor j := len(nums) - 1; j >= 0; j-- {\n\tif nums[j] == target {\n\t\ttargetRange[1] = j\n\t\tbreak\n\t}\n}\nreturn targetRange", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aaa [3]int\nvar aab [3]int\nvar aac [3]int\nvar aad [3]int\nvar aae [3]int\nvar aaf [3]int\nvar aag [3]int\nvar aah [3]int\nvar aai [3]int\n"}
{"tgt": "var tests = []struct {\n\tbefore []int\n\tafter  *ListNode\n}{\n\t{[]int{}, nil},\n\t{[]int{1}, newList(1)},\n\t{[]int{1, 2, 3, 4, 5}, newList(1, 3, 5, 2, 4)},\n\t{[]int{1, 2, 3, 4, 5, 6}, newList(1, 3, 5, 2, 4, 6)},\n\t{[]int{2, 1, 3, 5, 6, 4, 7}, newList(2, 3, 6, 7, 1, 5, 4)},\n}\nfor _, tt := range tests {\n\tafter := oddEvenList(newList(tt.before...))\n\tif reflect.DeepEqual(after, tt.after) == false {\n\t\tt.Errorf(\"STR\", newList(tt.before...), after, tt.after)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "out := 45228\nif x := p32(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "var p32 *int32\nvar p64 *int64\nvar p8 *int8\nvar p16 *int16\nvar p32p *int32\nvar p64p *int64\nvar p8p *int8\nvar p16p *int16\nvar p32pp *int32\nvar p64pp *int64\nvar p8pp *int8\nvar p16pp *int16\nvar p32ppp *int32\nvar p64ppp *int64\nvar p8ppp *int8\nvar p16ppp *int16\nvar p32pppp *int32\nvar p64pppp *int64\nvar p8pppp *int8\nvar p16pppp *int16\nvar p32ppppp *int32\nvar p64ppppp *int64\nvar p8ppppp *int8\nvar p16ppppp *int16\nvar p32pppppp *int32\nvar p64pppppp *int64\nvar p8pppppp *int8\nvar p16pppppp *int16\nvar p32ppppppp *int32\nvar p64ppppppp *int64\nvar p8ppppppp *int8\nvar p16ppppppp *int16\nvar p32pppppppp *int32\nvar p64pppppppp *int64\nvar p8pppppppp *int8\nvar p16pppppppp *int16\nvar p32ppppppppp *int32\nvar p64ppppppppp *int64\nvar p8ppppppppp *int8\nvar p16ppppppppp *int16\nvar p32pppppppppp *int32\nvar p64"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SecondLargest(tc.root); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "primes := [...]int{2: 1, 3: 1, 5: 1, 7: 1, 11: 1, 13: 1, 17: 1, 19: 1}\nres := 0\nfor i := L; i <= R; i++ {\n\tbits := 0\n\tfor n := i; n > 0; n >>= 1 {\n\t\tbits += n & 1\n\t}\n\tres += primes[bits]\n}\nreturn res", "gen": "var a [20]int\nvar i int\nfor i = 0; i < 20; i++ {\n\ta[i] = 1\n}\nfor i = 0; i < 20; i++ {\n\ta[i] = a[i] & 1\n\ta[i] = a[i] >> 1\n}\nfor i = 0; i < 20; i++ {\n\tif a[i] != 0 {\n\t\ta[i] = 1\n\t} else {\n\t\ta[i] = 0\n\t}\n\ta[i] = a[i] << 1\n}\nfor i = 0; i < 20; i++ {\n\tif a[i] > 19 {\n\t\tpanic(\"index out of range\")\n\t}\n\ta[i] = a[i] + a[i]\n}\nfor i = 0; i < 20; i++ {\n\tif a[i] < 0 {\n\t\tpanic(\"index out of range\")\n\t}\n\ta[i] = a[i] - a[i]\n}\nfor i = 0; i < 20; i++ {\n\tif a[i] > 19 {\n\t\tpanic(\"index out of range\")\n\t}\n\ta[i] = a[i] + a[i]\n}\nfor i = 0; i < 20; i++ {\n\tif a[i] < 0 {\n\t\tpanic(\"index out of range\")\n\t}\n\ta[i] = a[i] - a[i]\n}\nfor i = 0; i < 20; i++ {\n\tif a[i] > 19 {\n\t\tpanic(\"index out of range\")\n\t}\n\ta[i] = a[i] + a[i]\n}"}
{"tgt": "qs := []question1232{\n\t{\n\t\tpara1232{[][]int{{1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6}, {6, 7}}},\n\t\tans1232{true},\n\t},\n\t{\n\t\tpara1232{[][]int{{1, 1}, {2, 2}, {3, 4}, {4, 5}, {5, 6}, {7, 7}}},\n\t\tans1232{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1232, q.para1232\n\tfmt.Printf(\"STR\", p, checkStraightLine(p.arr))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "var tests = []struct {\n\tnums    []int\n\tmissing int\n}{\n\t{[]int{1, 1}, 2},\n\t{[]int{1, 2, 0}, 3},\n\t{[]int{3, 4, -1, 1}, 2},\n\t{[]int{7, 8, 9, 11, 12}, 1},\n}\nfor _, tt := range tests {\n\tnums := make([]int, len(tt.nums))\n\tcopy(nums, tt.nums)\n\tmissing := firstMissingPositive(tt.nums)\n\tif missing != tt.missing {\n\t\tt.Errorf(\"STR\", nums, missing, tt.missing)\n\t}\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "if nil == head || nil == head.Next ||\n\tm == n {\n\treturn head\n}\nstep := n - m\nvar leftTail *ListNode\np := head\nfor m > 1 {\n\tleftTail = p\n\tp = p.Next\n\tm--\n}\nq := p.Next\np.Next = nil\nmidTail := p\nfor step > 0 {\n\tr := q.Next\n\tq.Next = p\n\tp = q\n\tq = r\n\tstep--\n}\nif nil == leftTail {\n\tmidTail.Next = q\n\treturn p\n}\nleftTail.Next = p\nmidTail.Next = q\nreturn head", "gen": "var a [100]int\nvar b [100]int\nvar c [100]int\nvar d [100]int\nvar e [100]int\nvar f [100]int\nvar g [100]int\nvar h [100]int\nvar i [100]int\nvar j [100]int\nvar k [100]int\nvar l [100]int\nvar m [100]int\nvar n [100]int\nvar o [100]int\nvar p [100]int\nvar q [100]int\nvar r [100]int\nvar s [100]int\nvar t [100]int\nvar u [100]int\nvar v [100]int\nvar w [100]int\nvar x [100]int\nvar y [100]int\nvar z [100]int\nvar aa [100]int\nvar ab [100]int\nvar ac [100]int\nvar ad [100]int\nvar ae [100]int\nvar af [100]int\nvar ag [100]int\nvar ah [100]int\nvar ai [100]int\nvar aj [100]int\nvar ak [100]int\nvar al [100]int\nvar am [100]int\nvar an [100]int\nvar ao [100]int\nvar ap [100]int\nvar aq [100]int\nvar ar [100]int\nvar as [100]int\nvar at [100]int\nvar au [100]int\nvar av [100]int\nvar aw [100]int\nvar ax [100]"}
{"tgt": "var tests = []struct {\n\ttree  *TreeNode\n\tdepth int\n}{\n\t{newTree(3, 9, 20, nil, nil, 15, 7), 2},\n\t{newTree(1, 2), 2},\n\t{newTree(1, 2, 2, 3), 2},\n\t{newTree(1, 2, 2, 3, 3, nil, nil, 4, 4), 2},\n\t{newTree(1, 2, 2, 3, nil, 3, 3, 4), 3},\n\t{newTree(1, 2, 2, nil, nil, nil, 3, 4, 4), 2},\n}\nfor _, tt := range tests {\n\tdepth := minDepth(tt.tree)\n\tif depth != tt.depth {\n\t\tt.Errorf(\"STR\", tt.tree, depth, tt.depth)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "t.Parallel()\nd := NewTimeMap()\nd.Set(1, 1, 0)\nd.Set(1, 2, 2)\nif result := d.Get(1, 1); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 3); result != 2 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 5)\nif result := d.Get(1, 0); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 10); result != 1 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 0)\nd.Set(1, 2, 0)\nif result := d.Get(1, 0); result != 2 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(2, 0); result != nil {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, -1); result != nil {\n\tt.Errorf(\"STR\")\n}", "gen": "testing.M()\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname __morestack runtime.morestack"}
{"tgt": "if len(steps) < 2 {\n\treturn true\n}\nfor step := 1; step <= steps[0] && step <= len(steps); step++ {\n\tif CanAdvanceToEndBrute(steps[step:]) {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "obj := Constructor225()\nfmt.Printf(\"STR\", obj)\nparam5 := obj.Empty()\nfmt.Printf(\"STR\", param5)\nobj.Push(2)\nfmt.Printf(\"STR\", obj)\nobj.Push(10)\nfmt.Printf(\"STR\", obj)\nparam2 := obj.Pop()\nfmt.Printf(\"STR\", param2)\nparam3 := obj.Top()\nfmt.Printf(\"STR\", param3)\nparam4 := obj.Empty()\nfmt.Printf(\"STR\", param4)", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []string\n\texpect [][]string\n}{\n\t{\"STR\", []string{\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\"},\n\t\t[][]string{\n\t\t\t{\"STR\", \"STR\", \"STR\"},\n\t\t\t{\"STR\", \"STR\"},\n\t\t\t{\"STR\"},\n\t\t},\n\t},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := groupAnagrams(c.inputs)\n\t\tfmt.Println(got)\n\t})\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "i1 := 0\ni2 := 0\nval1 := 0\nval2 := 0\nfor i1 < len(version1) || i2 < len(version2) {\n\tval1, i1 = parseSeg(version1, i1)\n\tval2, i2 = parseSeg(version2, i2)\n\tif val1 > val2 {\n\t\treturn 1\n\t}\n\tif val1 < val2 {\n\t\treturn -1\n\t}\n}\nif i1 < len(version1) {\n\treturn 1\n}\nif i2 < len(version2) {\n\treturn -1\n}\nreturn 0", "gen": "fmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\nfmt.Println(parseSeg(\"1000-1000\"))\n"}
{"tgt": "result := make([]int, 0)\nfor i := 0; i < n; i++ {\n\tresult = append(result, nums[i])\n\tresult = append(result, nums[n+i])\n}\nreturn result", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "nums := make([]byte, n)\nfor i := 0; i < n; i++ {\n\tnums[i] = byte(i) + '1'\n}\nfor i := 2; i <= k; i++ {\n\tnextPermutation60(nums)\n}\nreturn string(nums)", "gen": "fmt.Println(nextPermutation([]int{1, 2, 3}))\nfmt.Println(nextPermutation([]int{1, 3, 2}))\nfmt.Println(nextPermutation([]int{3, 2, 1}))\nfmt.Println(nextPermutation([]int{1, 1, 5}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 4, 5}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MakePalindrome(tc.input); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "ln, err := net.Listen(\"STR\", \"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"STR\", conn.RemoteAddr())\n\tio.WriteString(conn, fmt.Sprint(time.Now()))\n\tconn.Close()\n}", "gen": "var l net.Listener\nl, err := net.Listen(\"tcp\", \"127.0.0.1:8080\")\nif err != nil {\n\tpanic(err)\n}\ndefer l.Close()\nfor {\n\tconn, err := l.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tgo handleConn(conn)\n}\n}"}
{"tgt": "self.table[index].Num = value", "gen": "var a [3]int\na[1] = 1\na[2] = 2\na[3] = 3\na[4] = 4\na[5] = 5\na[6] = 6\na[7] = 7\na[8] = 8\na[9] = 9\na[10] = 10\na[11] = 11\na[12] = 12\na[13] = 13\na[14] = 14\na[15] = 15\na[16] = 16\na[17] = 17\na[18] = 18\na[19] = 19\na[20] = 20\na[21] = 21\na[22] = 22\na[23] = 23\na[24] = 24\na[25] = 25\na[26] = 26\na[27] = 27\na[28] = 28\na[29] = 29\na[30] = 30\na[31] = 31\na[32] = 32\na[33] = 33\na[34] = 34\na[35] = 35\na[36] = 36\na[37] = 37\na[38] = 38\na[39] = 39\na[40] = 40\na[41] = 41\na[42] = 42\na[43] = 43\na[44] = 44\na[45] = 45\na[46] = 46\na[4"}
{"tgt": "return x.(int) < y.(int)", "gen": "var a int = 1\nvar b int = 2\nvar c int = 3\nvar d int = 4\nvar e int = 5\nvar f int = 6\nvar g int = 7\nvar h int = 8\nvar i int = 9\nvar j int = 10\nvar k int = 11\nvar l int = 12\nvar m int = 13\nvar n int = 14\nvar o int = 15\nvar p int = 16\nvar q int = 17\nvar r int = 18\nvar s int = 19\nvar t int = 20\nvar u int = 21\nvar v int = 22\nvar w int = 23\nvar x int = 24\nvar y int = 25\nvar z int = 26\nvar aa int = 27\nvar bb int = 28\nvar cc int = 29\nvar dd int = 30\nvar ee int = 31\nvar ff int = 32\nvar gg int = 33\nvar hh int = 34\nvar ii int = 35\nvar jj int = 36\nvar kk int = 37\nvar ll int = 38\nvar mm int = 39\nvar nn int = 40\nvar oo int = 41\nvar pp int = 42\nvar qq int = 43\nvar rr int = 44\nvar ss int = 45\nvar tt int = 46\nvar uu int = 47\nvar vv int = 48\nvar ww int = 49\nvar xx int = 50\nvar yy int = 51\nvar zz int = 52\nvar aaa int = 53\nvar bbb int = 54\nvar ccc int = "}
{"tgt": "return strings.Replace(address, \"STR\", \"STR\", -1)", "gen": "fmt.Println(strings.Replace(\"hello\", \"e\", \"a\", 3))\n}\n\n// Output:\n// haaa\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n$ go tool compile -S main.go\n\n// main.go"}
{"tgt": "var parts []string\nvar isFile bool\nvar partStart, tabCount, maxLength int\nfor i, r := range fs {\n\tswitch {\n\tcase isNewStart(i, r, fs):\n\t\tpartStart = i\n\tcase r == '.':\n\t\tisFile = true\n\tcase r == '\\t':\n\t\ttabCount++\n\tcase r == '\\n':\n\t\tif pos := tabCount; len(parts) > pos {\n\t\t\tparts = parts[:pos]\n\t\t}\n\t\tparts = append(parts, fs[partStart:i])\n\t\tif len := len(strings.Join(parts, \"STR\")); isFile && len > maxLength {\n\t\t\tmaxLength = len\n\t\t}\n\t\tisFile = false\n\t\ttabCount = 0\n\t}\n}\nif isFile {\n\tparts = append(parts, fs[partStart:])\n}\nreturn len(strings.Join(parts, \"STR\"))", "gen": "var s []byte\nvar i int\nfor {\n\tr, _ := utf8.DecodeRune(s)\n\tif r == utf8.RuneError {\n\t\tbreak\n\t}\n\tif unicode.IsSpace(r) {\n\t\tcontinue\n\t}\n\tif r == '(' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif r == ')' {\n\t\ti--\n\t\tcontinue\n\t}\n\ts = append(s, byte(r))\n}\nfmt.Println(string(s), i)\n}\n"}
{"tgt": "FprintVersion(os.Stdout)", "gen": "fmt.Println(\"Hello, playground\")\n}\n```\n\n### \u7f16\u8bd1\u5668\u4f18\u5316\n\n\u7f16\u8bd1\u5668\u4f18\u5316\u662f\u6307\u5728\u7f16\u8bd1\u65f6\uff0c\u5bf9\u7a0b\u5e8f\u8fdb\u884c\u4f18\u5316\uff0c\u4ee5\u63d0\u9ad8\u7a0b\u5e8f\u7684\u8fd0\u884c\u6548\u7387\u3002\n\nGo \u8bed\u8a00\u7684\u7f16\u8bd1\u5668\u4f18\u5316\u4e3b\u8981\u5305\u62ec\uff1a\n\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e\u9759\u6001\u5355\u8d4b\u503c\u7684\u4f18\u5316\n- \u57fa\u4e8e"}
{"tgt": "cnt := 0\nfor i := 0; cnt < n && i < len(flowerbed); i++ {\n\tif i > 0 && flowerbed[i-1] == 1 {\n\t\tcontinue\n\t}\n\tif i < len(flowerbed)-1 && flowerbed[i+1] == 1 {\n\t\tcontinue\n\t}\n\tif flowerbed[i] != 0 {\n\t\tcontinue\n\t}\n\tflowerbed[i] = 1\n\tcnt++\n\tif i < len(flowerbed)-1 {\n\t\tflowerbed[i+1] = -1\n\t}\n}\nreturn cnt >= n", "gen": "var a [10]int\na[10] = 1\na[10] = 2\na[10] = 3\na[10] = 4\na[10] = 5\na[10] = 6\na[10] = 7\na[10] = 8\na[10] = 9\na[10] = 10\na[10] = 11\na[10] = 12\na[10] = 13\na[10] = 14\na[10] = 15\na[10] = 16\na[10] = 17\na[10] = 18\na[10] = 19\na[10] = 20\na[10] = 21\na[10] = 22\na[10] = 23\na[10] = 24\na[10] = 25\na[10] = 26\na[10] = 27\na[10] = 28\na[10] = 29\na[10] = 30\na[10] = 31\na[10] = 32\na[10] = 33\na[10] = 34\na[10] = 35\na[10] = 36\na[10] = 37\na[10] = 38\na[10] = 39\na[10] = 40\na[10] = 41\na[10] = 42\na[10] = 43\na[10] = 44\na[10] = 45\na[10"}
{"tgt": "m := len(A)\nn := len(A[0])\nans := make([][]int, n)\nfor k := range ans {\n\tans[k] = make([]int, m)\n}\nfor r := 0; r < m; r++ {\n\tfor c := 0; c < n; c++ {\n\t\tans[c][r] = A[r][c]\n\t}\n}\nreturn ans", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "patternMap := make(map[string]string)\nstrMap := make(map[string]string)\nplen := len(pattern)\nstrArr := strings.Split(str, \"STR\")\npatternArr := strings.Split(pattern, \"STR\")\nif plen != len(strArr) {\n\treturn false\n}\nfor i := 0; i < plen; i++ {\n\tif _, ok := patternMap[patternArr[i]]; !ok {\n\t\tpatternMap[patternArr[i]] = strArr[i]\n\t}\n\tif _, ok := strMap[strArr[i]]; !ok {\n\t\tstrMap[strArr[i]] = patternArr[i]\n\t}\n\tif patternMap[patternArr[i]] != strArr[i] || strMap[strArr[i]] != patternArr[i] {\n\t\tfmt.Println(\"STR\", patternMap)\n\t\tfmt.Println(\"STR\", strMap)\n\t\treturn false\n\t}\n}\nfmt.Println(\"STR\", patternMap)\nfmt.Println(\"STR\", strMap)\nreturn true", "gen": "var m map[string]string\nm = make(map[string]string)\nm[\"a\"] = \"b\"\nm[\"c\"] = \"d\"\nfmt.Println(m)\nfmt.Println(m)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "nlen := len(nums)\nfor i := 0; i < nlen-2; i++ {\n\tif i != 0 && nums[i] == nums[i-1] {\n\t\tcontinue\n\t}\n\tleft, right := i+1, nlen-1\n\tfor left < right {\n\t\tsum := nums[i] + nums[left] + nums[right]\n\t\tif sum == target {\n\t\t\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tleft++\n\t\t\tright--\n\t\t} else if sum < target {\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tleft++\n\t\t} else {\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tright--\n\t\t}\n\t}\n}", "gen": "var a [4]int\nvar b [4]int\nvar c [4]int\nvar d [4]int\nvar e [4]int\nvar f [4]int\nvar g [4]int\nvar h [4]int\nvar i [4]int\nvar j [4]int\nvar k [4]int\nvar l [4]int\nvar m [4]int\nvar n [4]int\nvar o [4]int\nvar p [4]int\nvar q [4]int\nvar r [4]int\nvar s [4]int\nvar t [4]int\nvar u [4]int\nvar v [4]int\nvar w [4]int\nvar x [4]int\nvar y [4]int\nvar z [4]int\nvar aa [4]int\nvar ab [4]int\nvar ac [4]int\nvar ad [4]int\nvar ae [4]int\nvar af [4]int\nvar ag [4]int\nvar ah [4]int\nvar ai [4]int\nvar aj [4]int\nvar ak [4]int\nvar al [4]int\nvar am [4]int\nvar an [4]int\nvar ao [4]int\nvar ap [4]int\nvar aq [4]int\nvar ar [4]int\nvar as [4]int\nvar at [4]int\nvar au [4]int\nvar av [4]int\nvar aw [4]int\nvar ax [4]int\nvar ay [4]int\nvar az [4]int\nvar ba [4]int\nvar bb [4]int\nvar bc [4]int\nvar bd [4]int\nvar be [4]int\nvar bf [4]int\nvar bg [4]int\nvar bh [4]int\nvar bi [4]int\nvar bj ["}
{"tgt": "sLen, tLen := len(s), len(t)\nneed := [256]int{}\nfor i := range t {\n\tneed[t[i]]++\n}\nhas := [256]int{}\nmin := sLen + 1\nbegin, end, winBegin, winEnd, count := 0, 0, 0, 0, 0\nfor ; end < sLen; end++ {\n\tif need[s[end]] == 0 {\n\t\tcontinue\n\t}\n\tif has[s[end]] < need[s[end]] {\n\t\tcount++\n\t}\n\thas[s[end]]++\n\tif count == tLen {\n\t\tfor need[s[begin]] == 0 || has[s[begin]] > need[s[begin]] {\n\t\t\tif has[s[begin]] > need[s[begin]] {\n\t\t\t\thas[s[begin]]--\n\t\t\t}\n\t\t\tbegin++\n\t\t}\n\t\ttemp := end - begin + 1\n\t\tif min > temp {\n\t\t\tmin = temp\n\t\t\twinBegin = begin\n\t\t\twinEnd = end\n\t\t}\n\t}\n}\nif count < tLen {\n\treturn \"STR\"\n}\nreturn s[winBegin : winEnd+1]", "gen": "var s []byte\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s1 []byte\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s1 []byte\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s1 []byte\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s1 []byte\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif steps := MinimumStepsPath(tc.path); steps != tc.minimumSteps {\n\t\tt.Errorf(\"STR\", tc.minimumSteps, steps)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "n := len(cost)\ndp := make([]int, n)\ndp[0], dp[1] = cost[0], cost[1]\nfor i := 2; i < n; i++ {\n\tdp[i] = cost[i] + min(dp[i-2], dp[i-1])\n}\nreturn min(dp[n-2], dp[n-1])", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar b = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar c = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar d = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar e = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar f = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar g = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar h = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar i = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar j = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar k = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar m = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar n = []int"}
{"tgt": "qs := []question845{\n\t{\n\t\tpara845{[]int{875, 884, 239, 731, 723, 685}},\n\t\tans845{4},\n\t},\n\t{\n\t\tpara845{[]int{0, 1, 2, 3, 4, 5, 4, 3, 2, 1, 0}},\n\t\tans845{11},\n\t},\n\t{\n\t\tpara845{[]int{2, 3}},\n\t\tans845{0},\n\t},\n\t{\n\t\tpara845{[]int{2, 1, 4, 7, 3, 2, 5}},\n\t\tans845{5},\n\t},\n\t{\n\t\tpara845{[]int{2, 2, 2}},\n\t\tans845{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans845, q.para845\n\tfmt.Printf(\"STR\", p, longestMountain(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "res := make([]int, 0)\nfor i := 0; i < len(nums); i = i + 2 {\n\tfreq, val := nums[i], nums[i+1]\n\tfor j := 0; j < freq; j++ {\n\t\tres = append(res, val)\n\t}\n}\nreturn res", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb := a[0:2]\nb[0] = 4\nb[1] = 5\nfmt.Println(a)\n}\n\n// Output:\n// [4 5 3]\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n<ASM>\n.LFB2:\ncmpq %fs:112,%rsp\njnb .L56\nmovl $200,%r10d\nmovl $24,%r11d\ncall <__morestack>\n.LVL4:\nret\n.L56:\npushq %rbp\nmovq %rsp,%rbp\npushq %rbx\nsubq $184,%rsp\nmovq %rdi,-184(%rbp)\nmovq $0,-144(%rbp)\nmovq $0,-136(%rbp)\nmovq $0,-128(%rbp)\n.LBB34:\nmovl $0,%edx\nmovl $0,%esi\nleaq <int..d>(%rip),%rdi\ncall <runtime.makeslice@PLT>\nmovq %rax,-176(%rbp)\nmovq $0,-168(%rbp)\nmovq $0,-160(%rbp)\n.LBB35:\nmovq $0,-24(%rbp)\n.LBB36:\njmp .L37\n.L55:\n.LBB37:\nnop\n.LBE37:\n.LBB38:\nmovq <24>(%rbp),%rax\ncmpq $0,-24(%rbp)\njs .L38\ncmpq %rax,-24(%rbp)\njl .L50\n.L38:\nmovq -24(%rbp),%rdx\nmovq %rax,%rsi\nmovq"}
{"tgt": "defer wg.Done()\nfor v := range taskQueue {\n\tfmt.Printf(\"STR\", workerId, v.Id, v.JobId)\n\tv.Run()\n\tfmt.Printf(\"STR\", workerId, v.Status, v.Id, v.JobId)\n}", "gen": "var ch chan int\nvar i int\nvar j int\nvar k int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := Reverse32Bits(tc.given); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "dummy := &ListNode{0, head}\nslow, fast := dummy, dummy\nfor fast.Next != nil && fast.Next.Next != nil {\n\tfast = fast.Next.Next\n\tslow = slow.Next\n}\nreturn slow.Next", "gen": "var a [2]int\nvar b [2]int\na[0] = 1\na[1] = 2\nb[0] = 3\nb[1] = 4\nvar c [2]int\nc[0] = a[0] + b[0]\nc[1] = a[1] + b[1]\nprintln(c[0], c[1])\n}\n\n// 0 6\n\n<ASM>\n.LFB23:\nmovq %rdi,-8(%rbp)\nmovq %rsi,-16(%rbp)\nmovq %rdx,-24(%rbp)\nmovq %rcx,-32(%rbp)\nmovq %r8,-40(%rbp)\nmovq %r9,-48(%rbp)\nmovq -8(%rbp),%rax\nmovq %rax,-8(%rbp)\nmovq -16(%rbp),%rax\nmovq %rax,-16(%rbp)\nmovq -24(%rbp),%rax\nmovq %rax,-24(%rbp)\nmovq -32(%rbp),%rax\nmovq %rax,-32(%rbp)\nmovq -40(%rbp),%rax\nmovq %rax,-40(%rbp)\nmovq -48(%rbp),%rax\nmovq %rax,-48(%rbp)\nmovq -8(%rbp),%rax\nmovq -16(%rbp),%rdx\nmovq %rdx,-16(%rbp)\nmovq -24(%rbp),%rdx\nmovq %rdx,-24(%rbp)\nmovq -32(%rbp),%rdx\nmovq %rdx,-32(%rbp)\nmovq -40(%rbp),%rdx\nmovq %rdx,-40(%rbp)\nmovq -48(%rbp),%rdx\nmovq %rdx,-48(%rbp)\nmov"}
{"tgt": "fmt.Println(superEggDrop(1, 2))\nfmt.Println(superEggDrop(2, 6))\nfmt.Println(superEggDrop(2, 4))", "gen": "fmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 100))\nfmt.Println("}
{"tgt": "var res []int\nstack := []*preOrderTree{root}\nfor len(stack) > 0 {\n\troot = stack[0]\n\tstack = stack[1:]\n\tres = append(res, root.data)\n\tif root.left != nil {\n\t\tstack = append(stack, root.left)\n\t}\n\tif root.right != nil {\n\t\tstack = append(stack, root.right)\n\t}\n}\nreturn res", "gen": "var t preOrderTree\nt.preOrderTree(1)\n}\n"}
{"tgt": "l, r := 0, 0\nn := len(s)\nfor i := 0; i < n; i++ {\n\tif s[i] == ')' {\n\t\tl--\n\t} else {\n\t\tl++\n\t}\n\tj := n - i - 1\n\tif s[j] == '(' {\n\t\tr--\n\t} else {\n\t\tr++\n\t}\n\tif l < 0 || r < 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [100]byte\nvar b [100]byte\nvar c [100]byte\nvar d [100]byte\nvar e [100]byte\nvar f [100]byte\nvar g [100]byte\nvar h [100]byte\nvar i [100]byte\nvar j [100]byte\nvar k [100]byte\nvar l [100]byte\nvar m [100]byte\nvar n [100]byte\nvar o [100]byte\nvar p [100]byte\nvar q [100]byte\nvar r [100]byte\nvar s [100]byte\nvar t [100]byte\nvar u [100]byte\nvar v [100]byte\nvar w [100]byte\nvar x [100]byte\nvar y [100]byte\nvar z [100]byte\nvar aa [100]byte\nvar ab [100]byte\nvar ac [100]byte\nvar ad [100]byte\nvar ae [100]byte\nvar af [100]byte\nvar ag [100]byte\nvar ah [100]byte\nvar ai [100]byte\nvar aj [100]byte\nvar ak [100]byte\nvar al [100]byte\nvar am [100]byte\nvar an [100]byte\nvar ao [100]byte\nvar ap [100]byte\nvar aq [100]byte\nvar ar [100]byte\nvar as [100]byte\nvar at [100]byte\nvar au [100]byte\nvar av [100]byte\nvar aw [100]byte\nvar ax [100]"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA\n\tC int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif !ok {\n\tt.Error(\"STR\")\n}", "gen": "var t TestHasZero_Nested\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d = 123\nt.B.i1.d ="}
{"tgt": "for i, row := range matrix[1:] {\n\tfor j, v := range row[1:] {\n\t\tif v != matrix[i][j] {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "var a [10]int\na[1] = 1\na[2] = 2\na[3] = 3\na[4] = 4\na[5] = 5\na[6] = 6\na[7] = 7\na[8] = 8\na[9] = 9\na[0] = 0\na[10] = 10\na[11] = 11\na[12] = 12\na[13] = 13\na[14] = 14\na[15] = 15\na[16] = 16\na[17] = 17\na[18] = 18\na[19] = 19\na[20] = 20\na[21] = 21\na[22] = 22\na[23] = 23\na[24] = 24\na[25] = 25\na[26] = 26\na[27] = 27\na[28] = 28\na[29] = 29\na[30] = 30\na[31] = 31\na[32] = 32\na[33] = 33\na[34] = 34\na[35] = 35\na[36] = 36\na[37] = 37\na[38] = 38\na[39] = 39\na[40] = 40\na[41] = 41\na[42] = 42\na[43] = 43\na[44] = 44\na[45] = 45\na[46"}
{"tgt": "qs := []question28{\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{2},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{5},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{-1},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans28, q.para28\n\tfmt.Printf(\"STR\", p, strStr(p.s, p.p))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "digits := \"STR\"\nfor i := 1; i < 9999; i++ {\n\tnum := \"STR\"\n\tfor j := 1; j < 5; j++ {\n\t\tif len(num) < 9 {\n\t\t\tnum += strconv.Itoa(i * j)\n\t\t}\n\t}\n\tarr := strings.Split(num, \"STR\")\n\tsort.Strings(arr)\n\tnumSorted := strings.Join(arr, \"STR\")\n\tif numSorted == digits {\n\t\treturn num\n\t}\n}\nreturn \"STR\"", "gen": "var a, b int\nfmt.Scan(&a, &b)\nfmt.Println(a + b)\n}\n"}
{"tgt": "obj := Constructor933()\nfmt.Printf(\"STR\", obj)\nparam1 := obj.Ping(1)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(100)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(3001)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(3002)\nfmt.Printf(\"STR\", param1)", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "root := new(*TreeNode)\ninsertArrayToTreeNode(root, array, 0)\nreturn *root", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar root = insertArrayToTreeNode(a, 0, len(a)-1)\nfmt.Println(root)\n}\n"}
{"tgt": "res := 0\nsort.Ints(houses)\nsort.Ints(heaters)\nm, n := len(houses), len(heaters)\nindex := sort.SearchInts(heaters, houses[0])\nfor _, house := range houses {\n\tfor index < n && house > heaters[index] {\n\t\tindex++\n\t}\n\tif index == n {\n\t\treturn max(res, houses[m-1]-heaters[index-1])\n\t}\n\tleft := math.MaxInt32\n\tif index > 0 {\n\t\tleft = house - heaters[index-1]\n\t}\n\tright := heaters[index] - house\n\tres = max(res, min(left, right))\n}\nreturn res", "gen": "fmt.Println(maxProfit([]int{7, 1, 5, 3, 6, 4}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5}))\nfmt.Println(maxProfit([]int{7, 6, 4, 3, 1}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}))\nfmt.Println(maxProfit([]"}
{"tgt": "c := Candidates(candidates)\nsort.Sort(c)\nreturn orderedCombinationSum2(c, target)", "gen": "var a = []int{10, 1, 2, 7, 6, 1, 5}\nvar b = []int{1, 2, 3}\nvar c = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar d = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}\nvar e = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 8"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tresults := HeapsAlgorithmRecursive(tc.input)\n\tpos := 0\n\tfor result := range results {\n\t\tif !reflect.DeepEqual(result, tc.expected[pos]) {\n\t\t\tt.Errorf(\"STR\", tc.expected[pos], result)\n\t\t}\n\t\tpos++\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "for i := 1; i < len(nums); i++ {\n\tif nums[i-1] > nums[i] {\n\t\tpre := deepCopy(nums)\n\t\tpre[i-1] = pre[i]\n\t\tnext := deepCopy(nums)\n\t\tnext[i] = next[i-1]\n\t\treturn sort.IsSorted(sort.IntSlice(pre)) || sort.IsSorted(sort.IntSlice(next))\n\t}\n}\nreturn true", "gen": "var a [10]int\nvar b [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\ncopy(a[:], b[:])\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "res := []int{}\nfor _, num := range nums {\n\tn := num\n\tif n < 0 {\n\t\tn *= -1\n\t}\n\tif nums[n-1] < 0 {\n\t\tres = append(res, n)\n\t} else {\n\t\tnums[n-1] *= -1\n\t}\n}\nreturn res", "gen": "var a [3]int\na[2] = 1\na[0] = 2\na[1] = 3\nfmt.Println(a)\n}\n\n// Output:\n// [2 3 1]\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n<ASM>\n.LFB0:\ncmpq %fs:112,%rsp\njnb .L23\nmovl $232,%r10d\nmovl $24,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L23:\npushq %rbp\nmovq %rsp,%rbp\npushq %r13\npushq %r12\npushq %rbx\nsubq $200,%rsp\nmovq %rdi,-216(%rbp)\nmovq $0,-176(%rbp)\nmovq $0,-168(%rbp)\nmovq $0,-160(%rbp)\n.LBB2:\nleaq <type...60x.7int>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-152(%rbp)\nmovq -152(%rbp),%rax\nmovq %rax,-208(%rbp)\nmovq $0,-200(%rbp)\nmovq $0,-192(%rbp)\n.LBB3:\nmovq $0,-48(%rbp)\n.LBB4:\n.LBB5:\n.LBB6:\nmovq <16>(%rbp),%rax\nmovq <24>(%rbp),%rdx\nmovq %rax,-144(%rbp)\nmovq %rdx,-136(%rbp)\nmovq <32>(%rbp),%rax\nmovq %rax,-128(%rbp)\nmovq -136(%rbp),%r13\nmovl $0,%ebx"}
{"tgt": "qs := []question1281{\n\t{\n\t\tpara1281{234},\n\t\tans1281{15},\n\t},\n\t{\n\t\tpara1281{4421},\n\t\tans1281{21},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1281, q.para1281\n\tfmt.Printf(\"STR\", p, subtractProductAndSum(p.n))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "fp := float64(p)\nfa := float64(a)\nfb := (fp * (fp - 2.0*fa)) / (2.0 * (fp - fa))\nb = int(fb)\nvalid = math.Abs(fb-math.Floor(fb)) < 0.000001\nreturn", "gen": "var a, b, c float64\nfmt.Scan(&a, &b, &c)\nif a == 0 || b == 0 || c == 0 {\n\tfmt.Println(\"0\")\n\treturn\n}\nif a < 0 || b < 0 || c < 0 {\n\tfmt.Println(\"-1\")\n\treturn\n}\nif a > b {\n\ta, b = b, a\n}\nif a > c {\n\ta, c = c, a\n}\nif b > c {\n\tb, c = c, b\n}\nif a == b {\n\tfmt.Println(\"1\")\n\treturn\n}\nif a == c {\n\tfmt.Println(\"2\")\n\treturn\n}\nif b == c {\n\tfmt.Println(\"3\")\n\treturn\n}\nif a == b+c {\n\tfmt.Println(\"4\")\n\treturn\n}\nif a == b-c {\n\tfmt.Println(\"5\")\n\treturn\n}\nif a == c-b {\n\tfmt.Println(\"6\")\n\treturn\n}\nif b == c-a {\n\tfmt.Println(\"7\")\n\treturn\n}\nif b == a-c {\n\tfmt.Println(\"8\")\n\treturn\n}\nif c == a-b {\n\tfmt.Println(\"9\")\n\treturn\n}\nfmt.Println(\"-1\")\n}\n"}
{"tgt": "start := -1\nlenMax := 0\ndict := [256]int{}\nfor i := range dict {\n\tdict[i] = -1\n}\nfor i, r := range s {\n\tif v := dict[r]; v > start {\n\t\tstart = v\n\t}\n\tlength := i - start\n\tif length > lenMax {\n\t\tlenMax = length\n\t}\n\tdict[r] = i\n}\nreturn lenMax", "gen": "var s []byte\ns = append(s, 1)\ns = append(s, 2)\ns = append(s, 3)\ns = append(s, 4)\ns = append(s, 5)\ns = append(s, 6)\ns = append(s, 7)\ns = append(s, 8)\ns = append(s, 9)\ns = append(s, 10)\ns = append(s, 11)\ns = append(s, 12)\ns = append(s, 13)\ns = append(s, 14)\ns = append(s, 15)\ns = append(s, 16)\ns = append(s, 17)\ns = append(s, 18)\ns = append(s, 19)\ns = append(s, 20)\ns = append(s, 21)\ns = append(s, 22)\ns = append(s, 23)\ns = append(s, 24)\ns = append(s, 25)\ns = append(s, 26)\ns = append(s, 27)\ns = append(s, 28)\ns = append(s, 29)\ns = append(s, 30)\ns = append(s, 31)\ns = append(s, 32)\ns = append(s, 33)\ns = append(s, 34)\ns = append(s, 35)\ns = append(s, 36)\ns = append(s, 37)\ns = append(s, 38)\ns = append(s, 39)\ns = append(s, 40)\ns = append(s, 41)\ns = append(s, 42)"}
{"tgt": "return &skipListNode{v: v, score: score, forwards: make([]*skipListNode, level, level), level: level}", "gen": "var s *skipListNode\ns = new(skipListNode)\ns.d = 1\ns.next = new(skipListNode)\ns.next.d = 2\ns.next.next = new(skipListNode)\ns.next.next.d = 3\ns.next.next.next = new(skipListNode)\ns.next.next.next.d = 4\ns.next.next.next.next = new(skipListNode)\ns.next.next.next.next.d = 5\ns.next.next.next.next.next = new(skipListNode)\ns.next.next.next.next.next.d = 6\ns.next.next.next.next.next.next = new(skipListNode)\ns.next.next.next.next.next.next.d = 7\ns.next.next.next.next.next.next.next = new(skipListNode)\ns.next.next.next.next.next.next.next.d = 8\ns.next.next.next.next.next.next.next.next = new(skipListNode)\ns.next.next.next.next.next.next.next.next.d = 9\ns.next.next.next.next.next.next.next.next.next = new(skipListNode)\ns.next.next.next.next.next.next.next.next.next.d = 10\ns.next.next.next.next.next.next.next.next.next.next = new(skipListNode)\ns.next.next.next.next.next.next.next.next.next.next.d = 11\ns.next.next.next.next.next.next.next.next.next.next.next = new(skipListNode)\ns.next.next.next.next.next.next.next.next.next.next.next.d = 12\ns.next.next.next."}
{"tgt": "m := [26]int{}\nfor _, b := range B {\n\tcount := counter(b)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tm[i] = count[i]\n\t\t}\n\t}\n}\nres := []string{}\nfor _, a := range A {\n\tcount := counter(a)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tcontinueL\n\t\t}\n\t}\n\tres = append(res, a)\n}\nreturn res", "gen": "var a [26]string\nvar b [26]string\nvar c [26]string\nvar d [26]string\nvar e [26]string\nvar f [26]string\nvar g [26]string\nvar h [26]string\nvar i [26]string\nvar j [26]string\nvar k [26]string\nvar l [26]string\nvar m [26]string\nvar n [26]string\nvar o [26]string\nvar p [26]string\nvar q [26]string\nvar r [26]string\nvar s [26]string\nvar t [26]string\nvar u [26]string\nvar v [26]string\nvar w [26]string\nvar x [26]string\nvar y [26]string\nvar z [26]string\nvar aa [26]string\nvar bb [26]string\nvar cc [26]string\nvar dd [26]string\nvar ee [26]string\nvar ff [26]string\nvar gg [26]string\nvar hh [26]string\nvar ii [26]string\nvar jj [26]string\nvar kk [26]string\nvar ll [26]string\nvar mm [26]string\nvar nn [26]string\nvar oo [26]string\nvar pp [26]string\nvar qq [26]string\nvar rr [26]string\nvar ss [26]string\nvar tt [26]string\nvar uu [26]string\nvar vv [26]string\nvar ww [26]string\nvar xx [26]string\nvar yy [26]string\nvar zz [26]string\nvar aaa [26]string\nvar bbb [26]"}
{"tgt": "bulls, cows := 0, 0\nnums := [10]int{}\nfor i := 0; i < len(secret); i++ {\n\ts, g := int(secret[i]-'0'), int(guess[i]-'0')\n\tif s == g {\n\t\tbulls++\n\t} else {\n\t\tif nums[s] < 0 {\n\t\t\tcows++\n\t\t}\n\t\tif nums[g] > 0 {\n\t\t\tcows++\n\t\t}\n\t\tnums[s]++\n\t\tnums[g]--\n\t}\n}\nreturn fmt.Sprintf(\"STR\", bulls, cows)", "gen": "var a [10]int\nvar b [10]int\nvar c [2]int\na[9] = 1\nb[9] = 1\nc[1] = 1\nfmt.Printf(\"%d %d %d\\n\", a[9], b[9], c[1])\n}\n\n// Output:\n// 1 1 1\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n<ASM>\n.LFB0:\nleaq -312(%rsp),%r11\ncmpq %fs:112,%r11\njnb .L28\nmovl $312,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L28:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $264,%rsp\nmovq %rsi,%rax\nmovq %rdi,%r8\nmovq %r8,%rsi\nmovq %r9,%rdi\nmovq %rax,%rdi\nmovq %rsi,-272(%rbp)\nmovq %rdi,-264(%rbp)\nmovq %rdx,-288(%rbp)\nmovq %rcx,-280(%rbp)\nmovq $0,-176(%rbp)\nmovq $0,-168(%rbp)\n.LBB2:\nmovq $0,-56(%rbp)\nmovq $0,-64(%rbp)\nmovq $0,-256(%rbp)\nmovq $0,-248(%rbp)\nmovq $0,-240(%rbp)\nmovq $0,-232(%rbp)\nmovq $0,-224(%rbp)\nmovq $0,-216(%rbp)\n"}
{"tgt": "t.Parallel()\nfor _, l := range mathTestData {\n\tif log2Floor(l.n) != l.f || log2Ceil(l.n) != l.c {\n\t\tt.Errorf(\"STR\",\n\t\t\tl.n, l.f, l.c, log2Floor(l.n), log2Ceil(l.n))\n\t}\n}", "gen": "testing.MainStart(nil, nil, nil)\ntesting.MainEnd()\n}\n"}
{"tgt": "bs := strings.Builder{}\nvar dfs func(*TreeNode)\ndfs = func(node *TreeNode) {\n\tif node == nil {\n\t\treturn\n\t}\n\tbs.WriteString(strconv.Itoa(node.Val))\n\tif node.Left == nil && node.Right == nil {\n\t\treturn\n\t}\n\tbs.WriteByte('(')\n\tif node.Left != nil {\n\t\tdfs(node.Left)\n\t}\n\tbs.WriteByte(')')\n\tif node.Right != nil {\n\t\tbs.WriteByte('(')\n\t\tdfs(node.Right)\n\t\tbs.WriteByte(')')\n\t}\n}\ndfs(t)\nreturn bs.String()", "gen": "fmt.Println(tree2str(nil))\nfmt.Println(tree2str(buildTree([]int{1, 2, 3, 4, 5})))\nfmt.Println(tree2str(buildTree([]int{1, 2, 3, nil, 5})))\nfmt.Println(tree2str(buildTree([]int{1, 2, 3, nil, nil, 5})))\nfmt.Println(tree2str(buildTree([]int{1, 2, 3, nil, nil, nil, 5})))\nfmt.Println(tree2str(buildTree([]int{1, 2, 3, nil, nil, nil, nil, 5})))\nfmt.Println(tree2str(buildTree([]int{1, 2, 3, nil, nil, nil, nil, nil, 5})))\nfmt.Println(tree2str(buildTree([]int{1, 2, 3, nil, nil, nil, nil, nil, nil, 5})))\nfmt.Println(tree2str(buildTree([]int{1, 2, 3, nil, nil, nil, nil, nil, nil, nil, 5})))\nfmt.Println(tree2str(buildTree([]int{1, 2, 3, nil, nil, nil, nil, nil, nil, nil, nil, 5})))\nfmt.Println(tree2str(buildTree([]int{1, 2, 3, nil, nil, nil, nil, nil, nil, nil, nil, nil, 5})))\nfmt.Println(tree2str(buildTree([]int{1, 2, 3, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 5})))\nfmt.Println(tree2str(buildTree([]int{1, 2, 3, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 5})))\nfmt.Print"}
{"tgt": "return nil == root || isSame(root.Left, root.Right)", "gen": "var a, b int\nfmt.Scan(&a, &b)\nif isSame(a, b) {\n\tfmt.Println(\"same\")\n} else {\n\tfmt.Println(\"different\")\n}\n}\n"}
{"tgt": "cases := []struct {\n\tname      string\n\tflowerbed []int\n\tn         int\n\texpect    bool\n}{\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 1, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 2, false},\n\t{\"STR\", []int{1, 0, 1, 0}, 0, true},\n\t{\"STR\", []int{0}, 1, true},\n\t{\"STR\", []int{1, 0, 1, 0, 1, 0, 1}, 1, false},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.flowerbed, c.n)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.flowerbed, c.n)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "const maxDiv = 20\ni, div := maxDiv, maxDiv-1\nfor {\n\tif i%div == 0 {\n\t\tif div > 1 {\n\t\t\tdiv--\n\t\t} else {\n\t\t\tfmt.Println(i)\n\t\t\tos.Exit(0)\n\t\t}\n\t} else {\n\t\ti += maxDiv\n\t\tdiv = maxDiv - 1\n\t}\n}", "gen": "var a int\nvar b int\na = 10\nb = 2\nc := a / b\nfmt.Println(c)\nos.Exit(0)\n}\n\n<ASM>\n.LFB0:\ncmpq %fs:112,%rsp\njnb .L9\nmovl $152,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L9:\npushq %rbp\nmovq %rsp,%rbp\npushq %r13\npushq %r12\naddq $-128,%rsp\nmovq $20,-24(%rbp)\nmovq $19,-32(%rbp)\n.L8:\n.LBB2:\n.LBB3:\n.LBB4:\n.LBB5:\ncmpq $-1,-32(%rbp)\nje .L2\ncmpq $0,-32(%rbp)\njne .L3\ncall <runtime.panicdivide@PLT>\n.L3:\nmovq -24(%rbp),%rax\ncqto\nidivq -32(%rbp)\nmovq %rdx,%rax\ntestq %rax,%rax\nsete %al\njmp .L4\n.L2:\nmovl $1,%eax\n.L4:\ntestb %al,%al\nje .L5\n.LBB6:\n.LBB7:\ncmpq $1,-32(%rbp)\njle .L6\n.LBB8:\nsubq $1,-32(%rbp)\n.LBE8:\njmp .L8\n.L6:\n.LBB9:\nleaq <int..d>(%rip),%r12\nleaq <int..d>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-120(%rbp)\nmovq -120(%rbp),%rax\nmovq -2"}
