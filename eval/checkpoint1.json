{"tgt": "fmt.Println(mostCommonWord(\"STR\", []string{\"STR\", \"STR\"}))", "gen": "fmt.Println(mostCommonWord(\"Bob hit a ball, the hit ball ran up the grass. So hit the ball with the bat. That hit the ball with the bat ball!\", []string{\"hit\"}))\n}\n"}
{"tgt": "if nil == nums || len(nums) == 0 {\n\treturn\n}\ninsertPos := 0\nfor _, values := range nums {\n\tif 0 != values {\n\t\tnums[insertPos] = values\n\t\tinsertPos++\n\t}\n}\nfor insertPos < len(nums) {\n\tnums[insertPos] = 0\n\tinsertPos++\n}", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "cases := []struct {\n\ta, b, expected int\n}{\n\t{\n\t\ta:        0,\n\t\tb:        0,\n\t\texpected: 0,\n\t},\n\t{\n\t\ta:        1,\n\t\tb:        1,\n\t\texpected: 1,\n\t},\n\t{\n\t\ta:        -1,\n\t\tb:        1,\n\t\texpected: -1,\n\t},\n\t{\n\t\ta:        1,\n\t\tb:        -1,\n\t\texpected: -1,\n\t},\n\t{\n\t\ta:        10,\n\t\tb:        2,\n\t\texpected: 2,\n\t},\n}\nfor _, c := range cases {\n\tactual := Min(c.a, c.b)\n\tif actual != c.expected {\n\t\tt.Errorf(\"STR\", c.expected, actual)\n\t}\n}", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar bb [3]int\nvar cc [3]int\nvar dd [3]int\nvar ee [3]int\nvar ff [3]int\nvar gg [3]int\nvar hh [3]int\nvar ii [3]int\nvar jj [3]int\nvar kk [3]int\nvar ll [3]int\nvar mm [3]int\nvar nn [3]int\nvar oo [3]int\nvar pp [3]int\nvar qq [3]int\nvar rr [3]int\nvar ss [3]int\nvar tt [3]int\nvar uu [3]int\nvar vv [3]int\nvar ww [3]int\nvar xx [3]int\nvar yy [3]int\nvar zz [3]int\nvar aaa [3]int\nvar bbb [3]int\nvar ccc [3]int\nvar ddd [3]int\nvar eee [3]int\nvar fff [3]int\nvar ggg [3]int\nvar hhh [3]"}
{"tgt": "ma := 0\nif len(heights) < 0 {\n\treturn 0\n}\nvar stack []int\nfor i := 0; i < len(heights); i++ {\n\tif i == 0 {\n\t\tstack = append(stack, heights[i])\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tcontinue\n\t}\n\tif heights[i-1] > heights[i] {\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tstack = changeStack(stack, heights[i])\n\t}\n\tstack = append(stack, heights[i])\n\tif i+1 == len(heights) {\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tcontinue\n\t}\n}\nreturn ma", "gen": "var a []int\nvar max int\nfor i := 0; i < 1000000; i++ {\n\ta = append(a, i)\n\tif i == 0 {\n\t\tmax = i\n\t} else {\n\t\tif i > max {\n\t\t\tmax = i\n\t\t}\n\t}\n}\nif max != 999999 {\n\tpanic(\"max != 999999\")\n}\n}\n"}
{"tgt": "min := func(a, b int) int {\n\treturn int(math.Min(float64(a), float64(b)))\n}\ndp := make([]int, 2)\ndp[0], dp[1] = cost[0], cost[1]\nfor i := 2; i < len(cost); i++ {\n\tdp[i%2] = cost[i] + min(dp[0], dp[1])\n}\nreturn min(dp[0], dp[1])", "gen": "fmt.Println(minCostClimbingStairs([]int{1, 100, 1, 1, 1, 100, 1, 1, 100, 1}))\n}\n"}
{"tgt": "temp, mask := num, 0\nfor temp > 0 {\n\tmask = mask*2 + 1\n\ttemp /= 2\n}\nreturn mask ^ num", "gen": "var a int64 = 1\nvar b int64 = 2\nvar c int64 = 3\nvar d int64 = 4\nvar e int64 = 5\nvar f int64 = 6\nvar g int64 = 7\nvar h int64 = 8\nvar i int64 = 9\nvar j int64 = 10\nvar k int64 = 11\nvar l int64 = 12\nvar m int64 = 13\nvar n int64 = 14\nvar o int64 = 15\nvar p int64 = 16\nvar q int64 = 17\nvar r int64 = 18\nvar s int64 = 19\nvar t int64 = 20\nvar u int64 = 21\nvar v int64 = 22\nvar w int64 = 23\nvar x int64 = 24\nvar y int64 = 25\nvar z int64 = 26\nvar aa int64 = 27\nvar bb int64 = 28\nvar cc int64 = 29\nvar dd int64 = 30\nvar ee int64 = 31\nvar ff int64 = 32\nvar gg int64 = 33\nvar hh int64 = 34\nvar ii int64 = 35\nvar jj int64 = 36\nvar kk int64 = 37\nvar ll int64 = 38\nvar mm int64 = 39\nvar nn int64 = 40\nvar oo int64 = 41\nvar pp int64 = 42\nvar qq int64 = 43\nvar rr int64 = 44\nvar ss int64 = 45\nvar tt int"}
{"tgt": "listNode1 := &ListNode{\n\tVal: 4,\n\tNext: &ListNode{\n\t\tVal: 1,\n\t\tNext: &ListNode{\n\t\t\tVal:  4,\n\t\t\tNext: nil,\n\t\t},\n\t},\n}\nlistNode2 := &ListNode{\n\tVal: 1,\n\tNext: &ListNode{\n\t\tVal: 8,\n\t\tNext: &ListNode{\n\t\t\tVal:  4,\n\t\t\tNext: nil,\n\t\t},\n\t},\n}\ngetIntersectionNode(listNode1, listNode2)", "gen": "l1 := &ListNode{Val: 4, Next: &ListNode{Val: 1, Next: &ListNode{Val: 8}}}\nl2 := &ListNode{Val: 5, Next: &ListNode{Val: 0, Next: &ListNode{Val: 1}}}\nl3 := getIntersectionNode(l1, l2)\nfmt.Println(l3.Val)\n}\n"}
{"tgt": "switch {\ncase isIPv4(IP):\n\treturn \"STR\"\ncase isIPv6(IP):\n\treturn \"STR\"\ndefault:\n\treturn \"STR\"\n}", "gen": "fmt.Println(isIPv4(\"192.168.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4"}
{"tgt": "l := len(preorder)\nif l == 0 {\n\treturn nil\n}\nfor 1 < l && preorder[0] < preorder[l-1] {\n\tl--\n}\nreturn &TreeNode{\n\tVal:   preorder[0],\n\tLeft:  bstFromPreorder(preorder[1:l]),\n\tRight: bstFromPreorder(preorder[l:]),\n}", "gen": "preorder := []int{3, 9, 20, 15, 7}\nroot := bstFromPreorder(preorder)\nfmt.Println(root)\n}\n"}
{"tgt": "sort.Slice(costs, func(i, j int) bool {\n\treturn abs(costs[i][0]-costs[i][1]) > abs(costs[j][0]-costs[j][1])\n})\ncost, a, b, n := 0, 0, 0, len(costs)/2\nfor _, c := range costs {\n\tif (c[0] < c[1] && a < n) || b == n {\n\t\tcost += c[0]\n\t\ta++\n\t} else {\n\t\tcost += c[1]\n\t\tb++\n\t}\n}\nreturn cost", "gen": "fmt.Println(twoCitySchedCost([][]int{{10, 20}, {30, 200}, {400, 50}, {30, 20}}))\n}\n"}
{"tgt": "println(\"STR\")\nprintln(\"STR\", v1)\nprintln(\"STR\", v2.x, v2.y)\nprintln(\"STR\", len(v3), cap(v3), v3[0], v3[3])\nprintln(\"STR\", len(v4), v4 == nil)\nprintln(\"STR\", len(v5), v5 == nil)\nprintln(\"STR\", v6)\nprintln(\"STR\", cap(v7), string(v7))\nprintln(uint8SliceSrc[0])\nprintln(uint8SliceDst[0])\nprintln(intSliceSrc[0])\nprintln(intSliceDst[0])", "gen": "v1 := 1\nv2 := 2\nv3 := []int{1, 2, 3}\nv4 := v3[0]\nv5 := v3[1]\nv6 := v3[2]\nv7 := []byte{1, 2, 3}\nv8 := []int{1, 2, 3}\nv9 := []int{1, 2, 3}\nv10 := []int{1, 2, 3}\nv11 := []int{1, 2, 3}\nv12 := []int{1, 2, 3}\nv13 := []int{1, 2, 3}\nv14 := []int{1, 2, 3}\nv15 := []int{1, 2, 3}\nv16 := []int{1, 2, 3}\nv17 := []int{1, 2, 3}\nv18 := []int{1, 2, 3}\nv19 := []int{1, 2, 3}\nv20 := []int{1, 2, 3}\nv21 := []int{1, 2, 3}\nv22 := []int{1, 2, 3}\nv23 := []int{1, 2, 3}\nv24 := []int{1, 2, 3}\nv25 := []int{1, 2, 3}\nv26 := []int{1, 2, 3}\nv27 := []int{1, 2, 3}\nv28 := []int{1, 2, 3}\nv29 := []int{1, 2, 3}\nv30 := []int{1, 2, 3}\nv31 := []int{1, 2, 3}\nv32 := []int{1, 2, 3}\n"}
{"tgt": "words := strings.Fields(s)\nreturn strings.Join(reverseSlice(words), \"STR\")", "gen": "fmt.Println(reverseSlice([]string{\"a\", \"b\", \"c\", \"d\"}))\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect bool\n}{\n\t{\"STR\", []int{1, 2, 2, 3}, true},\n\t{\"STR\", []int{4, 3, 3, 2}, true},\n\t{\"STR\", []int{1, 3, 2}, false},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "indexs := make([]int, 123)\nfor i, c := range order {\n\tindexs[c] = i\n}\nless := func(i, j int) bool {\n\tsi, sj := len(words[i]), len(words[j])\n\tfor k := 0; k < si && k < sj; k++ {\n\t\tii, ij := indexs[words[i][k]], indexs[words[j][k]]\n\t\tswitch {\n\t\tcase ii < ij:\n\t\t\treturn true\n\t\tcase ii > ij:\n\t\t\treturn false\n\t\t}\n\t}\n\treturn si <= sj\n}\nfor i := 1; i < len(words); i++ {\n\tif !less(i-1, i) {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var s1, s2 string\nfmt.Scan(&s1, &s2)\nif isAlienSorted(s1, s2) {\n\tfmt.Println(\"Yes\")\n} else {\n\tfmt.Println(\"No\")\n}\n}\n"}
{"tgt": "row := len(grid)\ncol := len(grid[0])\ndp := make([][]int, row)\nfor i := 0; i < row; i++ {\n\tdp[i] = make([]int, col)\n}\ndp[0][0] = grid[0][0]\nfor i := 1; i < row; i++ {\n\tdp[i][0] = dp[i-1][0] + grid[i][0]\n}\nfor i := 1; i < col; i++ {\n\tdp[0][i] = dp[0][i-1] + grid[0][i]\n}\nfor i := 1; i < row; i++ {\n\tfor j := 1; j < col; j++ {\n\t\tdp[i][j] = Min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\t}\n}\nreturn dp[row-1][col-1]", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar bb [3]int\nvar cc [3]int\nvar dd [3]int\nvar ee [3]int\nvar ff [3]int\nvar gg [3]int\nvar hh [3]int\nvar ii [3]int\nvar jj [3]int\nvar kk [3]int\nvar ll [3]int\nvar mm [3]int\nvar nn [3]int\nvar oo [3]int\nvar pp [3]int\nvar qq [3]int\nvar rr [3]int\nvar ss [3]int\nvar tt [3]int\nvar uu [3]int\nvar vv [3]int\nvar ww [3]int\nvar xx [3]int\nvar yy [3]int\nvar zz [3]int\nvar aaa [3]int\nvar bbb [3]int\nvar ccc [3]int\nvar ddd [3]int\nvar eee [3]int\nvar fff [3]int\nvar ggg [3]int\nvar hhh [3]"}
{"tgt": "fmt.Fprint(w, \"STR\")", "gen": "var a int\nvar b int\nvar c int\nfmt.Println(a, b, c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "l := len(nums)\nk %= l\ns := make([]int, l)\ncopy(s, nums)\nfor i, v := range s[l-k:] {\n\tnums[i] = v\n}\nfor i, v := range s[:l-k] {\n\tnums[k+i] = v\n}", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar bb [10]int\nvar cc [10]int\nvar dd [10]int\nvar ee [10]int\nvar ff [10]int\nvar gg [10]int\nvar hh [10]int\nvar ii [10]int\nvar jj [10]int\nvar kk [10]int\nvar ll [10]int\nvar mm [10]int\nvar nn [10]int\nvar oo [10]int\nvar pp [10]int\nvar qq [10]int\nvar rr [10]int\nvar ss [10]int\nvar tt [10]int\nvar uu [10]int\nvar vv [10]int\nvar ww [10]int\nvar xx [10]int\nvar yy [10]int\nvar zz [10]int\nvar aaa [10]int\nvar bbb [10]"}
{"tgt": "if p == nil || q == nil {\n\treturn p == q\n}\nreturn isSameTree(p.Left, q.Left) && p.Val == q.Val && isSameTree(p.Right, q.Right)", "gen": "a := &TreeNode{Val: 1}\nb := &TreeNode{Val: 1}\nfmt.Println(isSameTree(a, b))\n}\n"}
{"tgt": "for cur := t.root; cur != nil; {\n\tif cur.Key == key {\n\t\treturn cur\n\t} else if key < cur.Key {\n\t\tcur = cur.left\n\t} else {\n\t\tcur = cur.right\n\t}\n}\nreturn nil", "gen": "var bst *binaryTree.BST\nbst = binaryTree.NewBST()\nbst.Insert(10)\nbst.Insert(20)\nbst.Insert(30)\nbst.Insert(40)\nbst.Insert(50)\nbst.Insert(60)\nbst.Insert(70)\nbst.Insert(80)\nbst.Insert(90)\nbst.Insert(100)\nbst.Insert(110)\nbst.Insert(120)\nbst.Insert(130)\nbst.Insert(140)\nbst.Insert(150)\nbst.Insert(160)\nbst.Insert(170)\nbst.Insert(180)\nbst.Insert(190)\nbst.Insert(200)\nbst.Insert(210)\nbst.Insert(220)\nbst.Insert(230)\nbst.Insert(240)\nbst.Insert(250)\nbst.Insert(260)\nbst.Insert(270)\nbst.Insert(280)\nbst.Insert(290)\nbst.Insert(300)\nbst.Insert(310)\nbst.Insert(320)\nbst.Insert(330)\nbst.Insert(340)\nbst.Insert(350)\nbst.Insert(360)\nbst.Insert(370)\nbst.Insert(380)\nbst.Insert(390)\nbst.Insert(400)\nbst.Insert(410)\nbst.Insert(420)\nbst.Insert(430)\nbst.Insert(440)\nbst.Insert(450)\nbst.Insert(460)\nbst.Insert(470)\nbst.Insert(480)\nbst.Insert(49"}
{"tgt": "s := []int{}\nfor _, asteroid := range asteroids {\n\tfor len(s) != 0 && s[len(s)-1] > 0 && s[len(s)-1] < -asteroid {\n\t\ts = s[:len(s)-1]\n\t}\n\tif len(s) == 0 || asteroid > 0 || s[len(s)-1] < 0 {\n\t\ts = append(s, asteroid)\n\t} else if asteroid < 0 && s[len(s)-1] == -asteroid {\n\t\ts = s[:len(s)-1]\n\t}\n}\nreturn s", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\na[0] = a[0] + a[1] + a[2]\nfmt.Println(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "sum := 0\nsunday := 5\nyear := 1901\nis_leap := false\nfor year < 2001 {\n\tchecker := month_len\n\tif is_leap {\n\t\tchecker = leap_len\n\t}\n\ttally := sunday\n\tfor _, v := range checker {\n\t\tif tally == 0 {\n\t\t\tsum += 1\n\t\t}\n\t\tif tally < v {\n\t\t\tbreak\n\t\t}\n\t\tif tally >= v {\n\t\t\ttally -= v\n\t\t}\n\t}\n\tsunday += 7\n\tif is_leap && sunday >= 366 {\n\t\tyear++\n\t\tsunday = sunday % 366\n\t\tis_leap = false\n\t} else if !is_leap && sunday >= 365 {\n\t\tyear++\n\t\tsunday = sunday % 365\n\t\tif year%4 == 0 {\n\t\t\tis_leap = true\n\t\t}\n\t}\n}\nfmt.Printf(\"STR\", year, sum)", "gen": "var month_len [12]int\nvar leap_len [12]int\nmonth_len[0] = 31\nmonth_len[1] = 28\nmonth_len[2] = 31\nmonth_len[3] = 30\nmonth_len[4] = 31\nmonth_len[5] = 30\nmonth_len[6] = 31\nmonth_len[7] = 31\nmonth_len[8] = 30\nmonth_len[9] = 31\nmonth_len[10] = 30\nmonth_len[11] = 31\nleap_len[0] = 31\nleap_len[1] = 29\nleap_len[2] = 31\nleap_len[3] = 30\nleap_len[4] = 31\nleap_len[5] = 30\nleap_len[6] = 31\nleap_len[7] = 31\nleap_len[8] = 30\nleap_len[9] = 31\nleap_len[10] = 30\nleap_len[11] = 31\nvar month int\nvar year int\nvar day int\nmonth = 0\nyear = 2000\nday = 1\nfor {\n\tif month == 12 {\n\t\tbreak\n\t}\n\tif day > month_len[month] {\n\t\tday = day - month_len[month]\n\t\tmonth = month + 1\n\t}\n\tif day == 1 {\n\t\tfmt.Printf(\"%d %d %d\\n\", year, month, day)\n\t}\n\tif day == 1 && month == 1 {\n\t\tbreak\n\t}\n\tday = day + 1\n}\n}\n"}
{"tgt": "max, winner := 0, 0\nfor i := 1; i < 1000000; i++ {\n\tterms := collatz(i)\n\tif terms > max {\n\t\tmax = terms\n\t\twinner = i\n\t}\n}\nfmt.Println(\"STR\", max, \"STR\", winner)", "gen": "var a int\nvar b int\nfor i := 1; i <= 999999; i++ {\n\ta = i\n\tb = collatz(i)\n\tif b > a {\n\t\ta = b\n\t\tb = i\n\t}\n}\nfmt.Println(a)\nfmt.Println(b)\n}"}
{"tgt": "return fmt.Sprintf(\"STR\", c.FirstName, c.LastName, c.Email)", "gen": "var s string\ns = \"hello\"\nfmt.Println(s)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "e.lgu = lgu\ne.mixin = mixin\ne.cluster = make(map[interface{}]*rsVEBTreeElement)\nif e.lgu > 1 {\n\te.summaryLgu = (e.lgu + 1) / 2\n\te.clusterLgu = e.lgu - e.summaryLgu\n\te.summary = new(rsVEBTreeElement).init(e.summaryLgu, e.mixin)\n} else {\n\te.summaryLgu = 0\n\te.clusterLgu = 0\n}\nreturn e", "gen": "var m map[int]int\nm = make(map[int]int)\nm[1] = 1\nm[2] = 2\nm[3] = 3\nm[4] = 4\nm[5] = 5\nm[6] = 6\nm[7] = 7\nm[8] = 8\nm[9] = 9\nm[10] = 10\nm[11] = 11\nm[12] = 12\nm[13] = 13\nm[14] = 14\nm[15] = 15\nm[16] = 16\nm[17] = 17\nm[18] = 18\nm[19] = 19\nm[20] = 20\nm[21] = 21\nm[22] = 22\nm[23] = 23\nm[24] = 24\nm[25] = 25\nm[26] = 26\nm[27] = 27\nm[28] = 28\nm[29] = 29\nm[30] = 30\nm[31] = 31\nm[32] = 32\nm[33] = 33\nm[34] = 34\nm[35] = 35\nm[36] = 36\nm[37] = 37\nm[38] = 38\nm[39] = 39\nm[40] = 40\nm[41] = 41\nm[42] = 42\nm[43] = 43\nm[44] = 44\nm[45] = 45\nm"}
{"tgt": "if isValid := checkHorizontal(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkVertical(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkReachable(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkRotationallySymmetric(puzzle); !isValid {\n\treturn false\n}\nreturn true", "gen": "fmt.Println(check([][]byte{\n\t[]byte{'A', 'B', 'C', 'E'},\n\t[]byte{'S', 'F', 'C', 'S'},\n\t[]byte{'A', 'D', 'E', 'E'},\n}))\nfmt.Println(check([][]byte{\n\t[]byte{'A', 'B', 'C', 'E'},\n\t[]byte{'S', 'F', 'C', 'S'},\n\t[]byte{'A', 'D', 'E', 'E'},\n\t[]byte{'A', 'B', 'C', 'E'},\n}))\nfmt.Println(check([][]byte{\n\t[]byte{'A', 'B', 'C', 'E'},\n\t[]byte{'S', 'F', 'C', 'S'},\n\t[]byte{'A', 'D', 'E', 'E'},\n\t[]byte{'A', 'B', 'C', 'E'},\n\t[]byte{'A', 'B', 'C', 'E'},\n}))\nfmt.Println(check([][]byte{\n\t[]byte{'A', 'B', 'C', 'E'},\n\t[]byte{'S', 'F', 'C', 'S'},\n\t[]byte{'A', 'D', 'E', 'E'},\n\t[]byte{'A', 'B', 'C', 'E'},\n\t[]byte{'A', 'B', 'C', 'E'},\n\t[]byte{'A', 'B', 'C', 'E'},\n}))\nfmt.Println(check([][]byte{\n\t[]byte{'A', 'B', 'C', 'E'},\n\t[]byte{'S', 'F', 'C', 'S'},\n\t[]byte{'A', 'D', 'E', 'E'},\n\t[]byte{'A', 'B', 'C', 'E'},\n\t[]byte{'A', 'B', 'C', 'E'},\n\t[]byte{'A', 'B', 'C', 'E'},\n\t[]byte{'A', 'B', 'C', 'E"}
{"tgt": "b.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := SumRevLLNum(tc.first, tc.second); !equal(result, tc.sum) {\n\t\tt.Errorf(\"STR\",\n\t\t\ttcid, String(result), String(tc.sum))\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA `structs:\"STR\"`\n\tC  int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif ok {\n\tt.Error(\"STR\")\n}", "gen": "var t TestHasZero_OmitNested\nt.B.i1.d = 123\nif !reflect.DeepEqual(t, TestHasZero_OmitNested{}) {\n\tpanic(\"not equal\")\n}\n}\n\n// TestHasZero_OmitNested_B_I1_D\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B"}
{"tgt": "nums := []int{1, 1, 2, 2, 3, 3}\nfmt.Println(distributeCandies(nums))\nnums2 := []int{1, 1, 2, 3}\nfmt.Println(distributeCandies(nums2))", "gen": "distributeCandies(1, 1, 2, 2, 3, 3)\ndistributeCandies(6, 6)\n}\n"}
{"tgt": "i, j := start, len(nums)-1\nfor i < j {\n\tnums[i], nums[j] = nums[j], nums[i]\n\ti++\n\tj--\n}", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\na[0] = 1\nb[0] = 2\nc[0] = 3\nd[0] = 4\ne[0] = 5\nf[0] = 6\ng[0] = 7\nh[0] = 8\ni[0] = 9\nj[0] = 10\nk[0] = 11\nl[0] = 12\nm[0] = 13\nn[0] = 14\no[0] = 15\np[0] = 16\nq[0] = 17\nr[0] = 18\ns[0] = 19\nt[0] = 20\nu[0] = 21\nv[0] = 22\nw[0] = 23\nx[0] = 24\ny[0] = 25\nz[0] = 26\na[1] = 27\nb[1]"}
{"tgt": "var val int\nfor n := uint(0); num != 0; num >>= 1 {\n\tval |= (1 - (num & 1)) << n\n\tn++\n}\nreturn val", "gen": "var x uint64 = 1\nvar y uint64 = 1\nfor i := uint64(0); i < 63; i++ {\n\tx = x & 1\n\ty = y << 1\n\tif x == y {\n\t\tbreak\n\t}\n}\nfmt.Println(x)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "size := len(A)\nres := make([]int, size)\neven, odd := 0, 1\nfor _, a := range A {\n\tif a%2 == 0 {\n\t\tres[even] = a\n\t\teven += 2\n\t} else {\n\t\tres[odd] = a\n\t\todd += 2\n\t}\n}\nreturn res", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nfor i := 0; i < len(a); i++ {\n\ta[i] *= 2\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "slow, fast := head, head\nfor fast != nil && fast.Next != nil {\n\tslow = slow.Next\n\tfast = fast.Next.Next\n}\nvar prev *ListNode\nfor slow != nil {\n\tnext := slow.Next\n\tslow.Next = prev\n\tprev, slow = slow, next\n}\nfor p, q := head, prev; p != q; p, q = q, p {\n\tnext := p.Next\n\tp.Next = q\n\tp = next\n}", "gen": "var a [10]int\nvar b [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = b[i]\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for _, p := range perm6([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) {\n\tvalid := true\n\tfor _, g := range guesses {\n\t\tvar count int\n\t\tfor i := 0; i < len(p); i++ {\n\t\t\tif p[i] == g.Code[i] {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\tif count != g.Score {\n\t\t\tvalid = false\n\t\t\tbreak\n\t\t}\n\t}\n\tif valid {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar bb [10]int\nvar cc [10]int\nvar dd [10]int\nvar ee [10]int\nvar ff [10]int\nvar gg [10]int\nvar hh [10]int\nvar ii [10]int\nvar jj [10]int\nvar kk [10]int\nvar ll [10]int\nvar mm [10]int\nvar nn [10]int\nvar oo [10]int\nvar pp [10]int\nvar qq [10]int\nvar rr [10]int\nvar ss [10]int\nvar tt [10]int\nvar uu [10]int\nvar vv [10]int\nvar ww [10]int\nvar xx [10]int\nvar yy [10]int\nvar zz [10]int\nvar aaa [10]int\nvar bbb [10]"}
{"tgt": "for i := 0; i < 100000; i++ {\n\tif i%300 == 0 {\n\t\tarray := GetArrayOfSize(i)\n\t\tif len(array) != i {\n\t\t\tfmt.Println(array)\n\t\t\tt.Error()\n\t\t}\n\t}\n}", "gen": "var a int\nfor i := 0; i < 100000; i++ {\n\ta = i\n}\nfmt.Println(a)\n}\n"}
{"tgt": "parent := this\nfor _, ch := range prefix {\n\tif child, ok := parent.Children[ch]; ok {\n\t\tparent = child\n\t\tcontinue\n\t}\n\treturn false\n}\nreturn true", "gen": "fmt.Println(Solution([]string{\"hello\", \"world\", \"leetcode\"}))\n}\n"}
{"tgt": "sema <- struct{}{}\nb := balance\n<-sema\nreturn b", "gen": "var wg sync.WaitGroup\nwg.Add(2)\ngo func() {\n\tdefer wg.Done()\n\tfor i := 0; i < 1000; i++ {\n\t\tdeposit(100)\n\t}\n}()\ngo func() {\n\tdefer wg.Done()\n\tfor i := 0; i < 1000; i++ {\n\t\twithdraw(100)\n\t}\n}()\nwg.Wait()\n}\n"}
{"tgt": "pairs := [...][2]int{{10, 7}, {1000, 983}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p26(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var a [2]int\nvar b [2]int\nvar c [2]int\nvar d [2]int\nvar e [2]int\nvar f [2]int\nvar g [2]int\nvar h [2]int\nvar i [2]int\nvar j [2]int\nvar k [2]int\nvar l [2]int\nvar m [2]int\nvar n [2]int\nvar o [2]int\nvar p [2]int\nvar q [2]int\nvar r [2]int\nvar s [2]int\nvar t [2]int\nvar u [2]int\nvar v [2]int\nvar w [2]int\nvar x [2]int\nvar y [2]int\nvar z [2]int\nvar aa [2]int\nvar bb [2]int\nvar cc [2]int\nvar dd [2]int\nvar ee [2]int\nvar ff [2]int\nvar gg [2]int\nvar hh [2]int\nvar ii [2]int\nvar jj [2]int\nvar kk [2]int\nvar ll [2]int\nvar mm [2]int\nvar nn [2]int\nvar oo [2]int\nvar pp [2]int\nvar qq [2]int\nvar rr [2]int\nvar ss [2]int\nvar tt [2]int\nvar uu [2]int\nvar vv [2]int\nvar ww [2]int\nvar xx [2]int\nvar yy [2]int\nvar zz [2]int\nvar aa1 [2]int\nvar bb1 [2]int\nvar cc1 [2]int\nvar dd1 [2]int\nvar ee1 [2]int\nvar ff1 [2]int\nvar gg1 [2]int\nvar hh1"}
{"tgt": "for i := 0; i < n; i++ {\n\tif len(squares) != i {\n\t\tprintln(\"STR\", len(squares), \"STR\", i)\n\t}\n\tsquares[i] = i * i\n\tfor j := 0; j <= i; j++ {\n\t\tif v, ok := squares[j]; !ok || v != j*j {\n\t\t\tif !ok {\n\t\t\t\tprintln(\"STR\", j)\n\t\t\t} else {\n\t\t\t\tprintln(\"STR\", j, v)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "var m map[int][2]int\nfor i := 0; i < 10; i++ {\n\tm[i] = [2]int{i, i}\n}\nfor k, v := range m {\n\tfmt.Printf(\"k=%d, v=%d\\n\", k, v[0])\n}\n}\n\n// Output:\n// k=0, v=0\n// k=1, v=1\n// k=2, v=2\n// k=3, v=3\n// k=4, v=4\n// k=5, v=5\n// k=6, v=6\n// k=7, v=7\n// k=8, v=8\n// k=9, v=9\n\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```\n<ASM>\ncmpq %fs:112,%rsp\njnb .L55\nmovl $152,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL3:\nret\n.L55:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $104,%rsp\nmovq %rdi,-104(%rbp)\nmovq %rsi,-112(%rbp)\n.LBB39:\nmovq $0,-56(%rbp)\n.LBB40:\njmp .L36\n.L54:\n.LBB41:\nnop\n.LBE41:\n.LBB42:\n.LBB43:\ncmpq $0,-104(%rbp)\nje .L37\nmovq -104(%rbp),%rax\nmovq (%rax),%rax\njmp .L38\n.L37:\nmovl $0,%eax\n.L38:\ncmpq -5"}
{"tgt": "for _, word := range words {\n\tremainNum[word] = 0\n}\nfor _, word := range words {\n\tremainNum[word]++\n}\nreturn 0", "gen": "m := make(map[string]int)\nfor i := 0; i < 1000; i++ {\n\tm[fmt.Sprintf(\"%d\", i)] = i\n}\nfor k, v := range m {\n\tfmt.Printf(\"%s: %d\\n\", k, v)\n}\n}\n\n// Output:\n// 0: 0\n// 1: 1\n// 2: 2\n// 3: 3\n// 4: 4\n// 5: 5\n// 6: 6\n// 7: 7\n// 8: 8\n// 9: 9\n// 10: 10\n// 11: 11\n// 12: 12\n// 13: 13\n// 14: 14\n// 15: 15\n// 16: 16\n// 17: 17\n// 18: 18\n// 19: 19\n// 20: 20\n// 21: 21\n// 22: 22\n// 23: 23\n// 24: 24\n// 25: 25\n// 26: 26\n// 27: 27\n// 28: 28\n// 29: 29\n// 30: 30\n// 31: 31\n// 32: 32\n// 33: 33\n// 34: 34\n// 35: 35\n// 36: 36\n// 37: 37\n// 38: 38\n// 39: 39\n// 40: 40\n// 41: 41\n// 42: 42\n// 43: 43\n// 44: 44\n// 45: 45\n// 46: 46\n// 47: 47"}
{"tgt": "ad := admin{\n\tuser: user{\n\t\tname:  \"STR\",\n\t\temail: \"STR\",\n\t},\n\tlevel: \"STR\",\n}\nad.user.notify()\nad.notify()", "gen": "user := User{\n\tName: \"Joe\",\n\tAge:  20,\n}\nadmin := Admin{\n\tName: \"Jane\",\n\tAge:  30,\n}\nuser.notify()\nadmin.notify()\n}\n"}
{"tgt": "if !ok {\n\tpanic(\"STR\")\n}", "gen": "var x int\nx = 1\nif x == 0 {\n\tpanic(\"x is zero\")\n}\n}\n\n<ASM>\nmovl $1,%eax\nmovl %eax,-4(%rbp)\nmovl -4(%rbp),%eax\ntestl %eax,%eax\njne .L79\nmovl $40,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL4:\nret\n.L79:\npushq %rbp\nmovq %rsp,%rbp\npushq %rbx\nsubq $24,%rsp\nmovl $1,%eax\nmovl %eax,-4(%rbp)\n.LBB62:\nmovl -4(%rbp),%eax\ntestl %eax,%eax\njne .L80\n.LBB63:\nleaq <string..d>(%rip),%rax\nleaq <go..C29>(%rip),%rdx\nmovq %rax,%rcx\nmovq %rdx,%rbx\nmovq %rdx,%rax\nmovq %rcx,%rdi\nmovq %rax,%rsi\ncall <runtime.gopanic@PLT>\n.L80:\n.LBE63:\n.LBE62:\nmovq -8(%rbp),%rbx\nleave\nret</ASM>"}
{"tgt": "sum := 0\nprev := 1\ncurr := 1\nfor curr <= 4e6 {\n\tprev, curr = curr, prev+curr\n\tif curr%2 == 0 {\n\t\tsum += curr\n\t}\n}\nfmt.Println(sum)", "gen": "var a, b int\na = 1\nb = 1\nfor i := 0; i < 4000000; i++ {\n\ta, b = b, a+b\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "dist := func(i int) int {\n\tx, y := points[i][0], points[i][1]\n\treturn x*x + y*y\n}\npartition := func(l, r int) int {\n\tpivot, pdist := l, dist(l)\n\tpoints[pivot], points[r] = points[r], points[pivot]\n\tdivider := l\n\tfor i := l; i < r; i++ {\n\t\tif dist(i) < pdist {\n\t\t\tpoints[i], points[divider] = points[divider], points[i]\n\t\t\tdivider++\n\t\t}\n\t}\n\tpoints[divider], points[r] = points[r], points[divider]\n\treturn divider\n}\nl, r := 0, len(points)-1\nfor l < r {\n\ti := partition(l, r)\n\tif i == K {\n\t\tbreak\n\t} else if i > K {\n\t\tr = i - 1\n\t} else {\n\t\tl = i + 1\n\t}\n}\nreturn points[:K]", "gen": "fmt.Println(kClosest([]int{1, 2, 3, 4, 5}, 4))\n}\n"}
{"tgt": "if c < 0 {\n\treturn false\n}\nl, r := 0, mySqrt(c)\nfor l <= r {\n\tcur := l*l + r*r\n\tif cur < c {\n\t\tl++\n\t} else if cur > c {\n\t\tr--\n\t} else {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "fmt.Println(mySqrt(8))\n}\n"}
{"tgt": "n := len(edges)\nparent := make([]int, n+1)\nfor i := 0; i < n; i++ {\n\tparent[i] = i\n}\nvar i int\nvar e []int\nfor i, e = range edges {\n\tf, t := e[0], e[1]\n\tpf := find(parent, f)\n\tpt := find(parent, t)\n\tif pf == pt {\n\t\tbreak\n\t}\n\tparent[pf] = pt\n}\nreturn edges[i]", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\ta = append(a, i)\n}\nfmt.Println(a)\nfmt.Println(find(a, 2))\nfmt.Println(find(a, 10))\nfmt.Println(find(a, 11))\nfmt.Println(find(a, 12))\nfmt.Println(find(a, 13))\nfmt.Println(find(a, 14))\nfmt.Println(find(a, 15))\nfmt.Println(find(a, 16))\nfmt.Println(find(a, 17))\nfmt.Println(find(a, 18))\nfmt.Println(find(a, 19))\nfmt.Println(find(a, 20))\nfmt.Println(find(a, 21))\nfmt.Println(find(a, 22))\nfmt.Println(find(a, 23))\nfmt.Println(find(a, 24))\nfmt.Println(find(a, 25))\nfmt.Println(find(a, 26))\nfmt.Println(find(a, 27))\nfmt.Println(find(a, 28))\nfmt.Println(find(a, 29))\nfmt.Println(find(a, 30))\nfmt.Println(find(a, 31))\nfmt.Println(find(a, 32))\nfmt.Println(find(a, 33))\nfmt.Println(find(a, 34))\nfmt.Println(find(a, 35))\nfmt.Println(find(a, 36))\nfmt.Println(find(a, 37))\nfmt.Println(find(a, 38))\nfmt.Println"}
{"tgt": "var bin strings.Builder\nfor head != nil {\n\tbin.WriteString(strconv.Itoa(head.Val))\n\thead = head.Next\n}\ni, _ := strconv.ParseInt(bin.String(), 2, 64)\nreturn int(i)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar"}
{"tgt": "if n == 0 {\n\treturn 0\n}\nreturn n/5 + trailingZeroes(n/5)", "gen": "fmt.Println(trailingZeroes(10))\n}\n"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tpuzzle := make([][]rune, len(tc.puzzle))\n\tfor i := range puzzle {\n\t\tpuzzle[i] = []rune(tc.puzzle[i])\n\t}\n\tif result := FindWordLD(puzzle, []rune(tc.target)); result != tc.expected {\n\t\tt.Errorf(\"STR\", tcid, tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(test, nil, nil, nil)\n}"}
{"tgt": "start := 0\nend := len(s) - 1\nfor start < end {\n\ts[start], s[end] = s[end], s[start]\n\tstart++\n\tend--\n}\nreturn s", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "if m == 0 {\n\treturn 1\n}\nswitch n {\ncase 1:\n\treturn 2\ncase 2:\n\tif m == 1 {\n\t\treturn 3\n\t}\n\treturn 4\ndefault:\n\tswitch m {\n\tcase 1:\n\t\treturn 4\n\tcase 2:\n\t\treturn 7\n\tdefault:\n\t\treturn 8\n\t}\n}", "gen": "var a int\nvar b int\na = 1\nb = 2\nvar c int\nc = 0\nif a == 1 {\n\tc = 1\n} else if a == 2 {\n\tc = 2\n} else {\n\tc = 3\n}\nif b == 1 {\n\tc = 4\n} else if b == 2 {\n\tc = 5\n} else {\n\tc = 6\n}\nif a == 1 {\n\tc = 7\n} else if a == 2 {\n\tc = 8\n} else {\n\tc = 9\n}\nif b == 1 {\n\tc = 10\n} else if b == 2 {\n\tc = 11\n} else {\n\tc = 12\n}\nfmt.Println(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "last, n := 0, len(s)\nfor i := 1; i < n; i++ {\n\tif s[i-1] == s[i] {\n\t\tcontinue\n\t}\n\tfor l := 0; i+l < n; l++ {\n\t\tif s[last+l] < s[i+l] {\n\t\t\tlast = i\n\t\t\tbreak\n\t\t}\n\t\tif s[last+l] > s[i+l] {\n\t\t\tbreak\n\t\t}\n\t}\n}\nreturn s[last:]", "gen": "var a [10]byte\nvar b [10]byte\nvar c [10]byte\nvar d [10]byte\nvar e [10]byte\nvar f [10]byte\nvar g [10]byte\nvar h [10]byte\nvar i [10]byte\nvar j [10]byte\nvar k [10]byte\nvar l [10]byte\nvar m [10]byte\nvar n [10]byte\nvar o [10]byte\nvar p [10]byte\nvar q [10]byte\nvar r [10]byte\nvar s [10]byte\nvar t [10]byte\nvar u [10]byte\nvar v [10]byte\nvar w [10]byte\nvar x [10]byte\nvar y [10]byte\nvar z [10]byte\nvar aa [10]byte\nvar bb [10]byte\nvar cc [10]byte\nvar dd [10]byte\nvar ee [10]byte\nvar ff [10]byte\nvar gg [10]byte\nvar hh [10]byte\nvar ii [10]byte\nvar jj [10]byte\nvar kk [10]byte\nvar ll [10]byte\nvar mm [10]byte\nvar nn [10]byte\nvar oo [10]byte\nvar pp [10]byte\nvar qq [10]byte\nvar rr [10]byte\nvar ss [10]byte\nvar tt [10]byte\nvar uu [10]byte\nvar vv [10]byte\nvar ww [10]byte\nvar xx [10]byte\nvar yy [10]byte\nvar zz [10]byte\nvar aaa [10]byte\nvar bbb [10]"}
{"tgt": "fmt.Println(checkPerfectNumber(6))\nfmt.Println(checkPerfectNumber(28))\nfmt.Println(checkPerfectNumber(30))", "gen": "checkPerfectNumber(6)\ncheckPerfectNumber(28)\ncheckPerfectNumber(30)\n}\n"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := EqualWithShifting(tc.A, tc.B); result != tc.expected {\n\t\tt.Errorf(\"STR\", tcid, tc.expected, result)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "s = strings.TrimSpace(s)\n_, err := strconv.ParseFloat(s, 64)\nreturn err == nil || err.(*strconv.NumError).Err != strconv.ErrSyntax", "gen": "fmt.Println(parseFloat(\"123.456\"))\n}\n"}
{"tgt": "qs := []question76{\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans76, q.para76\n\tfmt.Printf(\"STR\", p, minWindow(p.s, p.p))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0}, 5},\n\t{\"STR\", []int{0, 0, 0, 0, 1}, []int{1, 0, 0, 0, 0}, 4},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums1, c.nums2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums1, c.nums2)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "return strings.ReplaceAll(r.element.Name, \"STR\", \"\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "result := Mul3And5(5)\nif result != 3 {\n\tt.Errorf(\"STR\", result, 3)\n}\nresult = Mul3And5(6)\nif result != 8 {\n\tt.Errorf(\"STR\", result, 8)\n}\nresult = Mul3And5(7)\nif result != 14 {\n\tt.Errorf(\"STR\", result, 14)\n}\nresult = Mul3And5(10)\nif result != 23 {\n\tt.Errorf(\"STR\", result, 23)\n}\nresult = Mul3And5(11)\nif result != 33 {\n\tt.Errorf(\"STR\", result, 33)\n}", "gen": "var t testing.T\nvar m Mul3And5\nvar i interface{}\nvar j interface{}\nvar k interface{}\nvar l interface{}\nvar m interface{}\nvar n interface{}\nvar o interface{}\nvar p interface{}\nvar q interface{}\nvar r interface{}\nvar s interface{}\nvar t interface{}\nvar u interface{}\nvar v interface{}\nvar w interface{}\nvar x interface{}\nvar y interface{}\nvar z interface{}\nvar a interface{}\nvar b interface{}\nvar c interface{}\nvar d interface{}\nvar e interface{}\nvar f interface{}\nvar g interface{}\nvar h interface{}\nvar i interface{}\nvar j interface{}\nvar k interface{}\nvar l interface{}\nvar m interface{}\nvar n interface{}\nvar o interface{}\nvar p interface{}\nvar q interface{}\nvar r interface{}\nvar s interface{}\nvar t interface{}\nvar u interface{}\nvar v interface{}\nvar w interface{}\nvar x interface{}\nvar y interface{}\nvar z interface{}\nvar a interface{}\nvar b interface{}\nvar c interface{}\nvar d interface{}\nvar e interface{}\nvar f interface{}\nvar g interface{}\nvar h interface{}\nvar i interface{}\nvar j interface{}\nvar k interface{}\nvar l interface{}\nvar m interface{}\nvar n interface{}\nvar o interface{}\nvar p interface{}\nvar q interface{}\nvar r interface{}\nvar s interface{}\nvar t interface{}\nvar u interface{}\nvar v interface{}\nvar w interface{}\nvar x interface{}\nvar y interface{}\nvar z interface{}\nvar a interface{}\nvar b interface{}\nvar c interface{}\nvar d interface{}\nvar e interface{}\nvar f interface{}\nvar g interface{}\nvar h interface{}\nvar i interface{}\nvar j interface{}\nvar k interface{}"}
{"tgt": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "if root == nil {\n\treturn nil\n}\nif root.Key == key {\n\treturn root\n} else if root.Key < key {\n\troot = root.Right\n} else {\n\troot = root.Left\n}\nreturn Get(root, key)", "gen": "var a, b int\nfmt.Scan(&a, &b)\nfmt.Println(a + b)\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1},\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1, 4, 2},\n\t\twant: 6,\n\t},\n\t{\n\t\tin:   []int{1},\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   []int{2, 1, 1, 2, 1, 3, 3, 3, 1, 3, 1, 3, 2},\n\t\twant: 7,\n\t},\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1},\n\t\twant: 2,\n\t},\n}\nfor _, tt := range tests {\n\tgot := findShortestSubArray(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(findShortestSubArray([]int{1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2,"}
{"tgt": "fmt.Println(runtime.GOOS, runtime.GOARCH)", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "result := make([]string, 0)\nstart := -1\nend := -1\nfor i, num := range nums {\n\tif i > 0 && num == nums[i-1]+1 {\n\t\tend = i\n\t} else {\n\t\tif i > 0 {\n\t\t\tresult = appendRanges(result, nums, start, end)\n\t\t}\n\t\tstart = i\n\t\tend = i\n\t}\n}\nif end >= 0 {\n\tresult = appendRanges(result, nums, start, end)\n}\nreturn result", "gen": "var a []int\na = append(a, 1)\na = append(a, 2)\na = append(a, 3)\na = append(a, 4)\na = append(a, 5)\na = append(a, 6)\na = append(a, 7)\na = append(a, 8)\na = append(a, 9)\na = append(a, 10)\na = append(a, 11)\na = append(a, 12)\na = append(a, 13)\na = append(a, 14)\na = append(a, 15)\na = append(a, 16)\na = append(a, 17)\na = append(a, 18)\na = append(a, 19)\na = append(a, 20)\na = append(a, 21)\na = append(a, 22)\na = append(a, 23)\na = append(a, 24)\na = append(a, 25)\na = append(a, 26)\na = append(a, 27)\na = append(a, 28)\na = append(a, 29)\na = append(a, 30)\na = append(a, 31)\na = append(a, 32)\na = append(a, 33)\na = append(a, 34)\na = append(a, 35)\na = append(a, 36)\na = append(a, 37)\na = append(a, 38)\na = append(a, 39)\na = append(a, 40)\na = append(a, 41)\na = append(a, 42)"}
{"tgt": "pigs := 0\nfor mypow(minutesToTest/minutesToDie+1, pigs) < buckets {\n\tpigs++\n}\nreturn pigs", "gen": "fmt.Println(mypow(2, 10))\n}\n"}
{"tgt": "qs := []question470{\n\t{\n\t\tpara470{},\n\t\tans470{2},\n\t},\n\t{\n\t\tpara470{},\n\t\tans470{0},\n\t},\n\t{\n\t\tpara470{},\n\t\tans470{1},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans470, q.para470\n\tfmt.Printf(\"STR\", p, rand10())\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "if s == nil {\n\treturn false\n}\nreturn isSubtree(s.Left, t) || isSameTree(s, t) || isSubtree(s.Right, t)", "gen": "var a *TreeNode\nvar b *TreeNode\nvar c bool\nc = isSubtree(a, b)\nc = isSameTree(a, b)\nc = isSubtree(a, b)\nc = isSameTree(a, b)\n}\n"}
{"tgt": "if p := e.r; e.list != nil && p != &e.list.root {\n\treturn p\n}\nreturn nil", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad"}
{"tgt": "switch {\ncase one == nil && two == nil:\n\treturn nil\ncase one == nil:\n\treturn &BinaryTree{two.Val,\n\t\tMergeBinaryTrees(nil, two.Left),\n\t\tMergeBinaryTrees(nil, two.Right),\n\t}\ncase two == nil:\n\treturn &BinaryTree{one.Val,\n\t\tMergeBinaryTrees(one.Left, nil),\n\t\tMergeBinaryTrees(one.Right, nil),\n\t}\n}\nreturn &BinaryTree{one.Val + two.Val,\n\tMergeBinaryTrees(one.Left, two.Left),\n\tMergeBinaryTrees(one.Right, two.Right),\n}", "gen": "fmt.Println(mergeTrees(nil, nil))\nfmt.Println(mergeTrees(nil, &TreeNode{Val: 1}))\nfmt.Println(mergeTrees(&TreeNode{Val: 1}, nil))\nfmt.Println(mergeTrees(&TreeNode{Val: 1}, &TreeNode{Val: 2}))\nfmt.Println(mergeTrees(&TreeNode{Val: 1}, &TreeNode{Val: 2, Left: &TreeNode{Val: 3}}))\nfmt.Println(mergeTrees(&TreeNode{Val: 1}, &TreeNode{Val: 2, Right: &TreeNode{Val: 3}}))\nfmt.Println(mergeTrees(&TreeNode{Val: 1, Left: &TreeNode{Val: 2}}, &TreeNode{Val: 3, Right: &TreeNode{Val: 4}}))\nfmt.Println(mergeTrees(&TreeNode{Val: 1, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 3}}}, &TreeNode{Val: 4, Right: &TreeNode{Val: 5, Left: &TreeNode{Val: 6}}}))\nfmt.Println(mergeTrees(&TreeNode{Val: 1, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 3}}}, &TreeNode{Val: 4, Right: &TreeNode{Val: 5, Right: &TreeNode{Val: 6}}}))\nfmt.Println(mergeTrees(&TreeNode{Val: 1, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 3}}}, &TreeNode{Val: 4, Right: &TreeNode{Val: 5, Right: &TreeNode{Val: 6, Left: &TreeNode{Val: 7}}}}))\nfmt.Println(mergeTrees(&TreeNode{Val: 1, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 3}}}, &TreeNode{Val: 4"}
{"tgt": "rets := make([][]int, numRows)\nif numRows == 0 {\n\treturn rets\n}\nrets[0] = []int{1}\nfor i := 1; i < numRows; i++ {\n\trets[i] = make([]int, i+1)\n\trets[i][0] = 1\n\trets[i][i] = 1\n\tfor j := 1; j < i; j++ {\n\t\trets[i][j] = rets[i-1][j-1] + rets[i-1][j]\n\t}\n}\nreturn rets", "gen": "var a [3]int\na[0] = 1\na[1] = 1\na[2] = 1\nb := a[0:1]\nb[0] = 1\nb = a[1:2]\nb[0] = 1\nb = a[2:3]\nb[0] = 1\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "i, l := 0, len(bits)-1\nfor i < l {\n\ti += bits[i] + 1\n}\nreturn i == l", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"bad\")\n\t}\n}\n}\n\n// 0000000000000000 <main>:\n// \t.globl\tmain\n// \t.type\tmain,@function\n// main:\n// \t.cfi_startproc\n// \t.cfi_personality 0x0,__gxx_personality_v0\n// \t.cfi_lsda 0x1b,.LLSDA0\n// \t.cfi_loc 1 0 0\n// \t.cfi_adjust_cfa_offset 32\n// \t.cfi_offset 11, -32\n// \t.cfi_offset 12, -24\n// \tpushq\t%rbp\n// \tmovq\t%rsp, %rbp\n// \tsubq\t$32, %rsp\n// \tmovb\t$0, -9(%rbp)\n// \tmovq\t$0, -8(%rbp)\n// \tmovq\t$0, -24(%rbp)\n// \tjmp\t.L2\n// .L3:\n// \tmovq\t-8(%rbp), %rax\n// \tsubq\t$1, %rax\n// \tmovq\t%rax, -24(%rbp)\n// \tjmp\t.L1\n// .L4:\n// \tmovq\t-8(%rbp), %rax\n// \tcmpq\t$0, -24(%rbp)\n// \tjns\t.L4\n// \tmovq\t-8(%rbp), %rax\n// \tcmpq\t-24(%rbp), %rax\n// \tjg\t.L"}
{"tgt": "fname, lname := \"STR\", \"STR\"\nage := 35\nfmt.Println(Title)\nfmt.Println(\"STR\", fname)\nfmt.Println(\"STR\", lname)\nfmt.Println(\"STR\", age)\nfmt.Println(\"STR\", Country)", "gen": "fmt.Println(\"Hello, playground\")\nvar a int\na = 1\nvar b int\nb = 1\nfmt.Println(a, b)\nvar c int\nc = 2\nvar d int\nd = 2\nfmt.Println(c, d)\nvar e int\ne = 3\nvar f int\nf = 3\nfmt.Println(e, f)\nvar g string\ng = \"Hello\"\nvar h string\nh = \"World\"\nfmt.Println(g, h)\nvar i string\ni = \"Hello\"\nvar j string\nj = \"World\"\nfmt.Println(i, j)\nvar k string\nk = \"Hello\"\nvar l string\nl = \"World\"\nfmt.Println(k, l)\nvar m string\nm = \"Hello\"\nvar n string\nn = \"World\"\nfmt.Println(m, n)\nvar o string\no = \"Hello\"\nvar p string\np = \"World\"\nfmt.Println(o, p)\nvar q string\nq = \"Hello\"\nvar r string\nr = \"World\"\nfmt.Println(q, r)\nvar s string\ns = \"Hello\"\nvar t string\nt = \"World\"\nfmt.Println(s, t)\nvar u string\nu = \"Hello\"\nvar v string\nv = \"World\"\nfmt.Println(u, v)\nvar w string\nw = \"Hello\"\nvar x string\nx = \"World\"\nfmt.Println(w, x)\nvar y string\ny = \"Hello\"\nvar z string\nz = \"World\"\nfmt.Println(y, z)\nvar aa string\naa = \"Hello\"\nvar bb string\nbb = \"World\"\nfmt.Println(aa, bb)\nvar"}
{"tgt": "for i := 0; i < b.N; i++ {\n\tSum(7, 8, 10)\n}", "gen": "fmt.Println(Sum(7, 8, 10))\n}\n"}
{"tgt": "dec := xml.NewDecoder(os.Stdin)\nvar stack []string\nfor {\n\ttok, err := dec.Token()\n\tif err == io.EOF {\n\t\tbreak\n\t} else if err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"STR\", err)\n\t\tos.Exit(1)\n\t}\n\tswitch tok := tok.(type) {\n\tcase xml.StartElement:\n\t\tstack = append(stack, tok.Name.Local)\n\tcase xml.EndElement:\n\t\tstack = stack[:len(stack)-1]\n\tcase xml.CharData:\n\t\tif containsAll(stack, os.Args[1:]) {\n\t\t\tfmt.Printf(\"STR\", strings.Join(stack, \"STR\"), tok)\n\t\t}\n\t}\n}", "gen": "var s string\nvar err error\ns, err = ioutil.ReadAll(os.Stdin)\nif err != nil {\n\tpanic(err)\n}\nvar decoder *xml.Decoder\ndecoder = xml.NewDecoder(strings.NewReader(s))\nvar token xml.Token\nfor {\n\ttoken, err = decoder.Token()\n\tif err != nil {\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tpanic(err)\n\t}\n\tswitch token.(type) {\n\tcase xml.StartElement:\n\t\tvar start xml.StartElement\n\t\tstart = token.(xml.StartElement)\n\t\tvar name xml.Name\n\t\tname = start.Name\n\t\tvar attrs []xml.Attr\n\t\tattrs = start.Attr\n\t\tvar attrs2 []xml.Attr\n\t\tattrs2 = start.Attr\n\t\tvar attrs3 []xml.Attr\n\t\tattrs3 = start.Attr\n\t\tvar attrs4 []xml.Attr\n\t\tattrs4 = start.Attr\n\t\tvar attrs5 []xml.Attr\n\t\tattrs5 = start.Attr\n\t\tvar attrs6 []xml.Attr\n\t\tattrs6 = start.Attr\n\t\tvar attrs7 []xml.Attr\n\t\tattrs7 = start.Attr\n\t\tvar attrs8 []xml.Attr\n\t\tattrs8 = start.Attr\n\t\tvar attrs9 []xml.Attr\n\t\tattrs9 = start.Attr\n\t\tvar attrs10 []xml.Attr\n\t\tattrs10 = start.Attr\n\t\tvar attrs11 []xml.Attr\n\t\tattrs11 = start.Attr\n\t\tvar attrs12 []xml.Attr\n\t\tattrs12 = start.Attr\n\t\tvar attrs13 []xml.Attr\n\t\tattrs13"}
{"tgt": "var sentences []string\nvar start int\nspaceDelimited := strings.Split(text, \"STR\")\npossibleSentence := false\nfor i, part := range spaceDelimited {\n\trunes := []rune(part)\n\tif part == \"STR\" || !isValid(runes) {\n\t\tpossibleSentence = false\n\t\tcontinue\n\t}\n\tif runes[0] >= 'A' && runes[0] <= 'Z' {\n\t\tpossibleSentence = true\n\t\tstart = i\n\t\tcontinue\n\t}\n\tif last := runes[len(runes)-1]; last == '.' || last == '!' || last == '?' {\n\t\tif possibleSentence {\n\t\t\tsentences = append(sentences, strings.Join(spaceDelimited[start:i+1], \"STR\"))\n\t\t}\n\t}\n}\nreturn sentences", "gen": "fmt.Println(isValid(\"1234567890\"))\nfmt.Println(isValid(\"12345678901234567890\"))\nfmt.Println(isValid(\"123456789012345678901234567890\"))\nfmt.Println(isValid(\"1234567890123456789012345678901234567890\"))\nfmt.Println(isValid(\"12345678901234567890123456789012345678901234567890\"))\nfmt.Println(isValid(\"123456789012345678901234567890123456789012345678901234567890\"))\nfmt.Println(isValid(\"1234567890123456789012345678901234567890123456789012345678901234567890\"))\nfmt.Println(isValid(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"))\nfmt.Println(isValid(\"1234567890123456789012345678901234567890123"}
{"tgt": "arr := randomSlice(0, 20, 10)\ndeleteSequence := randomSlice(0, 10, 10)\nnodeCnt := 0\nrbt := newRBT()\nfor _, v := range arr {\n\trbt.Insert(uint32(v))\n}\nfor i, v := range deleteSequence {\n\trbt.Delete(uint32(arr[v]))\n\tstop := rbt.PreOrderWalk(rbt.Root(), checkGBT(t, &nodeCnt, *debug))\n\tif stop {\n\t\treturn\n\t}\n\tif nodeCnt != len(deleteSequence)-1-i {\n\t\tt.Log(\"STR\", len(deleteSequence)-1-i, \"STR\", nodeCnt)\n\t\tt.Fail()\n\t}\n\tnodeCnt = 0\n\tif i != len(deleteSequence)-1 {\n\t\tstop = checkRBT(t, rbt)\n\t\tif stop {\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "testing.M()\n}\n"}
{"tgt": "ans := make([]int, len(nums))\nfor i, idx := range index {\n\tcopy(ans[idx+1:], ans[idx:])\n\tans[idx] = nums[i]\n}\nreturn ans", "gen": "var a [3]int\nvar b [4]int\nvar c [5]int\nvar d [6]int\nvar e [7]int\nvar f [8]int\nvar g [9]int\nvar h [10]int\nvar i [11]int\nvar j [12]int\nvar k [13]int\nvar l [14]int\nvar m [15]int\nvar n [16]int\nvar o [17]int\nvar p [18]int\nvar q [19]int\nvar r [20]int\nvar s [21]int\nvar t [22]int\nvar u [23]int\nvar v [24]int\nvar w [25]int\nvar x [26]int\nvar y [27]int\nvar z [28]int\nvar aa [29]int\nvar ab [30]int\nvar ac [31]int\nvar ad [32]int\nvar ae [33]int\nvar af [34]int\nvar ag [35]int\nvar ah [36]int\nvar ai [37]int\nvar aj [38]int\nvar ak [39]int\nvar al [40]int\nvar am [41]int\nvar an [42]int\nvar ao [43]int\nvar ap [44]int\nvar aq [45]int\nvar ar [46]int\nvar as [47]int\nvar at [48]int\nvar au [49]int\nvar av [50]int\nvar aw [51]int\nvar ax [52]int\nvar ay [53]int\nvar az [54]int\nvar ba [55]int\nvar bb [56]int\nvar bc [57]int\nvar bd [58]"}
{"tgt": "min, max := A[0], A[0]\nfor _, a := range A {\n\tif a < min {\n\t\tmin = a\n\t}\n\tif a > max {\n\t\tmax = a\n\t}\n}\nif max-min <= K+K {\n\treturn 0\n}\nreturn max - min - K - K", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\tprintln(a[i])\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "left := 0\nright := len(numbers) - 1\nfor left != right {\n\tif numbers[left]+numbers[right] == target {\n\t\tbreak\n\t}\n\tif numbers[left]+numbers[right] > target {\n\t\tright--\n\t}\n\tif numbers[left]+numbers[right] < target {\n\t\tleft++\n\t}\n}\nreturn []int{left + 1, right + 1}", "gen": "var a [2][2]int\na[0][0] = 1\na[0][1] = 2\na[1][0] = 3\na[1][1] = 4\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for a != nil && b != nil {\n\tif a.Value != b.Value {\n\t\treturn false\n\t}\n\ta = a.Next\n\tb = b.Next\n}\nreturn a == nil && b == nil", "gen": "var a, b int\na = 1\nb = 2\nif a == b {\n\tfmt.Println(\"a == b\")\n} else {\n\tfmt.Println(\"a != b\")\n}\nif a == b {\n\tfmt.Println(\"a == b\")\n} else {\n\tfmt.Println(\"a != b\")\n}\nif a == b {\n\tfmt.Println(\"a == b\")\n} else {\n\tfmt.Println(\"a != b\")\n}\nif a == b {\n\tfmt.Println(\"a == b\")\n} else {\n\tfmt.Println(\"a != b\")\n}\nif a == b {\n\tfmt.Println(\"a == b\")\n} else {\n\tfmt.Println(\"a != b\")\n}\nif a == b {\n\tfmt.Println(\"a == b\")\n} else {\n\tfmt.Println(\"a != b\")\n}\nif a == b {\n\tfmt.Println(\"a == b\")\n} else {\n\tfmt.Println(\"a != b\")\n}\nif a == b {\n\tfmt.Println(\"a == b\")\n} else {\n\tfmt.Println(\"a != b\")\n}\nif a == b {\n\tfmt.Println(\"a == b\")\n} else {\n\tfmt.Println(\"a != b\")\n}\nif a == b {\n\tfmt.Println(\"a == b\")\n} else {\n\tfmt.Println(\"a != b\")\n}\nif a == b {\n\tfmt.Println(\"a == b\")\n} else {\n\tfmt.Println(\"a != b\")\n}\nif a == b {\n\tfmt.Println(\"a == b\")\n} else {\n\tfmt.Println(\"a != b\")\n}\nif a == b {\n\tfmt.Println"}
{"tgt": "return func(treebinaryTreeIf, node interface{}) bool {\n\tn := node.(*gbtElement)\n\tif !tree.IsNil(n.Left) && n.Left.Key >= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Left, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif !tree.IsNil(n.Right) && n.Right.Key <= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Right, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif debug {\n\t\tfmt.Println(n)\n\t}\n\t*nodeCnt++\n\treturn false\n}", "gen": "var t1 testing.T\nvar bt binaryTree\nbt.checkGBT(&t1, true, 1)\n}\n"}
{"tgt": "n := len(A)\nif n == 0 {\n\treturn A\n}\nabs := func(num int) int { return int(math.Abs(float64(num))) }\nans := make([]int, n)\ni, j, k := 0, n-1, n-1\nfor i <= j {\n\tif abs(A[i]) > abs(A[j]) {\n\t\tans[k] = A[i] * A[i]\n\t\ti++\n\t} else {\n\t\tans[k] = A[j] * A[j]\n\t\tj--\n\t}\n\tk--\n}\nreturn ans", "gen": "var a = Solution{1, 2, 3}\nvar b = Solution{4, 5, 6}\nvar c = Solution{7, 8, 9}\nvar d = Solution{10, 11, 12}\nvar e = Solution{13, 14, 15}\nvar f = Solution{16, 17, 18}\nvar g = Solution{19, 20, 21}\nvar h = Solution{22, 23, 24}\nvar i = Solution{25, 26, 27}\nvar j = Solution{28, 29, 30}\nvar k = Solution{31, 32, 33}\nvar l = Solution{34, 35, 36}\nvar m = Solution{37, 38, 39}\nvar n = Solution{40, 41, 42}\nvar o = Solution{43, 44, 45}\nvar p = Solution{46, 47, 48}\nvar q = Solution{49, 50, 51}\nvar r = Solution{52, 53, 54}\nvar s = Solution{55, 56, 57}\nvar t = Solution{58, 59, 60}\nvar u = Solution{61, 62, 63}\nvar v = Solution{64, 65, 66}\nvar w = Solution{67, 68, 69}\nvar x = Solution{70, 71, 72}\nvar y = Solution{73, 74, 75}\nvar z = Solution{76, 77, 78}\nvar aa = Solution{79, 80, 81}\nvar bb = Solution{82, 83, 84}\nvar cc ="}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif denoms := EgyptianFractions(tc.numerator, tc.denominator); !reflect.DeepEqual(tc.denominators, denoms) {\n\t\tt.Errorf(\"STR\", tc.denominators, denoms)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "nums1 := []int{2}\nnums2 := []int{}\nmerge(nums1, 1, nums2, 0)\nfmt.Println(nums1)", "gen": "var a [3]int\na[0] = 2\na[1] = 1\nvar b [3]int\nb[0] = 1\nb[1] = 1\nvar c [3]int\nc[0] = 0\nc[1] = 0\nvar d [3]int\nd[0] = 0\nd[1] = 0\nvar e [3]int\ne[0] = 0\ne[1] = 0\nvar f [3]int\nf[0] = 0\nf[1] = 0\nvar g [3]int\ng[0] = 0\ng[1] = 0\nvar h [3]int\nh[0] = 0\nh[1] = 0\nvar i [3]int\ni[0] = 0\ni[1] = 0\nvar j [3]int\nj[0] = 0\nj[1] = 0\nvar k [3]int\nk[0] = 0\nk[1] = 0\nvar l [3]int\nl[0] = 0\nl[1] = 0\nvar m [3]int\nm[0] = 0\nm[1] = 0\nvar n [3]int\nn[0] = 0\nn[1] = 0\nvar o [3]int\no[0] = 0\no[1] = 0\nvar p [3]int\np[0] = 0\np[1] = 0\nvar q [3]int\nq[0] = 0\nq[1] = 0\nvar r [3]int\nr[0] = 0\nr[1] = 0\nvar s [3]int\ns[0] = 0\ns[1] = 0\nvar t [3]"}
{"tgt": "result := 0\nfor num != 0 {\n\tresult++\n\tnum = num & (num - 1)\n}\nreturn result", "gen": "var a int\nfor i := 0; i < 1000000000; i++ {\n\ta += i\n}\nprintln(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "qs := []question448{\n\t{\n\t\tpara448{[]int{4, 3, 2, 7, 8, 2, 3, 1}},\n\t\tans448{[]int{5, 6}},\n\t},\n\t{\n\t\tpara448{[]int{4, 3, 2, 10, 9, 2, 3, 1, 1, 1, 1}},\n\t\tans448{[]int{5, 6, 7, 8, 11}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans448, q.para448\n\tfmt.Printf(\"STR\", p, findDisappearedNumbers(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "flag.Parse()\nroots := flag.Args()\nif len(roots) == 0 {\n\troots = []string{\"STR\"}\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, root := range roots {\n\t\twalkDir(root, fileSizes)\n\t}\n\tclose(fileSizes)\n}()\nvar nfiles, nbytes int64\nfor size := range fileSizes {\n\tnfiles++\n\tnbytes += size\n}\nprintDiskUsage(nfiles, nbytes)", "gen": "flag.Parse()\nargs := flag.Args()\nif len(args) != 2 {\n\tfmt.Println(\"Usage:\", os.Args[0], \"source destination\")\n\tos.Exit(1)\n}\nsource := args[0]\ndestination := args[1]\nfileSizes1, fileSizes2 := make(chan int64), make(chan int64)\ngo func() {\n\tvar wg sync.WaitGroup\n\tvar n int64\n\tfor i := 0; i < 100; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tfor _, f := range []string(source) {\n\t\t\t\tfileSizes1 <- f.Size()\n\t\t\t}\n\t\t\twg.Done()\n\t\t}()\n\t}\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(fileSizes1)\n\t}()\n}()\ngo func() {\n\tvar wg sync.WaitGroup\n\tvar n int64\n\tfor i := 0; i < 100; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tfor _, f := range []string(destination) {\n\t\t\t\tfileSizes2 <- f.Size()\n\t\t\t}\n\t\t\twg.Done()\n\t\t}()\n\t}\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(fileSizes2)\n\t}()\n}()\nprintDiskUsage(fileSizes1, fileSizes2)\n}"}
{"tgt": "return toString[t]", "gen": "beer := Beer{\n\tName: \"Budweiser\",\n\tType: BeerType(\"lager\"),\n}\nfmt.Println(beer)\n}\n"}
{"tgt": "for step := len(nums) / 2; step > 0; step /= 2 {\n\tfor i := step; i < len(nums); i++ {\n\t\tfor j := i - step; j >= 0 && nums[j+step] < nums[j]; j -= step {\n\t\t\tnums[j], nums[j+step] = nums[j+step], nums[j]\n\t\t}\n\t}\n}\nreturn nums", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + a[i+1]\n}\nfmt.Println(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var tests = []struct {\n\ttree *TreeNode\n\tvals []int\n}{\n\t{newTree(1, 2, 3, nil, 5, nil, 4), []int{1, 3, 4}},\n\t{newTree(1, 2, 3, 4, 5, nil, 6, nil, 7, nil, nil, 8, nil, nil, 9, nil, nil, nil, 10), []int{1, 3, 6, 8, 9, 10}},\n}\nfor _, tt := range tests {\n\tvals := rightSideView(tt.tree)\n\tif reflect.DeepEqual(vals, tt.vals) == false {\n\t\tt.Errorf(\"STR\", tt.tree, vals, tt.vals)\n\t}\n}", "gen": "fmt.Println(rightSideView(tree))\n}\n"}
{"tgt": "nodes := []int{\n\t1, 2, 3, 4, 5, 6,\n}\nedges := [][]bool{\n\t{false, true, true, false, false, false},\n\t{true, false, false, true, false, false},\n\t{true, false, false, true, false, false},\n\t{false, true, true, false, true, false},\n\t{false, false, false, true, false, true},\n\t{false, false, false, false, true, false},\n}\nstart := 1\nend := 6\nroute, _ := dfs(start, end, nodes, edges)\nfmt.Println(route)", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aaa [3]int\nvar aab [3]int\nvar aac [3]int\nvar aad [3]int\nvar aae [3]int\nvar aaf [3]int\nvar aag [3]int\nvar aah [3]int\nvar aai [3]int\n"}
{"tgt": "if target < 0 {\n\ttarget = -target\n}\nk := 0\nfor target > 0 {\n\tk++\n\ttarget -= k\n}\nif target%2 == 0 {\n\treturn k\n}\nreturn k + 1 + k%2", "gen": "var a int64 = 1000000000000000000\nvar b int64 = 1000000000000000000\nvar c int64 = 0\nfor i := 0; i < 1000000000000000000; i++ {\n\tc = a + b\n\ta = b\n\tb = c\n}\nfmt.Println(c)\n}\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n.LFB0:\ncmpq\t%fs:112,%rsp\njnb\t.L10\nmovl\t$8,%r10d\nmovl\t$0,%r11d\ncall\t<__morestack>\n.LVL0:\nret\n.L10:\npushq\t%rbp\nmovq\t%rsp,%rbp\nmovq\t%rdi,-24(%rbp)\nmovq\t$0,-16(%rbp)\n.LBB2:\n.LBB3:\ncmpq\t$0,-24(%rbp)\njns\t.L2\n.LBB4:\nnegq\t-24(%rbp)\n.L2:\n.LBE4:\n.LBE3:\nmovq\t$0,-8(%rbp)\n.LBB5:\n.LBB6:\njmp\t.L3\n.L9:\n.LBB7:\nnop\n.LBE7:\n.LBB8:\naddq\t$1,-8(%rbp)\nmovq\t-8(%rbp),%rax\nsubq\t%rax,-24(%rbp)\n.L3:\n.LBE8:\ncmpq\t$0,-24(%rbp)\njg\t.L9\n.LBE6:\n.LBE5:\n.LBB"}
{"tgt": "if mod == 1 {\n\treturn 0, nil\n}\nif exponent < 0 {\n\treturn -1, ErrorNegativeExponent\n}\n_, err := Multiply64BitInt(mod-1, mod-1)\nif err != nil {\n\treturn -1, err\n}\nvar result int64 = 1\nbase = base % mod\nfor exponent > 0 {\n\tif exponent%2 == 1 {\n\t\tresult = (result * base) % mod\n\t}\n\texponent = exponent >> 1\n\tbase = (base * base) % mod\n}\nreturn result, nil", "gen": "var a, b, c int64\nfmt.Scan(&a, &b, &c)\nfmt.Println(a * b / c)\n}\n"}
{"tgt": "for n := 0; n < 32; n++ {\n\tsquare[n] = gf2MatrixTimes(mat, mat[n])\n}", "gen": "var a [32]byte\nvar b [32]byte\nvar c [32]byte\nvar d [32]byte\nvar e [32]byte\nvar f [32]byte\nvar g [32]byte\nvar h [32]byte\nvar i [32]byte\nvar j [32]byte\nvar k [32]byte\nvar l [32]byte\nvar m [32]byte\nvar n [32]byte\nvar o [32]byte\nvar p [32]byte\nvar q [32]byte\nvar r [32]byte\nvar s [32]byte\nvar t [32]byte\nvar u [32]byte\nvar v [32]byte\nvar w [32]byte\nvar x [32]byte\nvar y [32]byte\nvar z [32]byte\nvar aa [32]byte\nvar ab [32]byte\nvar ac [32]byte\nvar ad [32]byte\nvar ae [32]byte\nvar af [32]byte\nvar ag [32]byte\nvar ah [32]byte\nvar ai [32]byte\nvar aj [32]byte\nvar ak [32]byte\nvar al [32]byte\nvar am [32]byte\nvar an [32]byte\nvar ao [32]byte\nvar ap [32]byte\nvar aq [32]byte\nvar ar [32]byte\nvar as [32]byte\nvar at [32]byte\nvar au [32]byte\nvar av [32]byte\nvar aw [32]byte\nvar ax [32]byte\nvar ay [32]byte\nvar az [32]byte\nvar ba [32]byte\nvar bb [32]byte\nvar bc [32]byte\n"}
{"tgt": "return n.Ns == nil", "gen": "var a [3]int\nvar b [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb = a\nprintln(b[0], b[1], b[2])\n}\n\n<ASM>\n.LFB4:\ncmpq %fs:112,%rsp\njnb .L10\nmovl $72,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L10:\npushq %rbp\nmovq %rsp,%rbp\nsubq $48,%rsp\nmovq %rdi,-40(%rbp)\nmovq %rdi,-32(%rbp)\nmovq %rdi,-24(%rbp)\nmovq %rdi,-16(%rbp)\nmovq %rdi,-8(%rbp)\nmovq %rdi,(%rbp)\nmovq %rdi,<8>(%rbp)\nmovq %rdi,<16>(%rbp)\nmovq %rdi,<24>(%rbp)\nmovq %rdi,<32>(%rbp)\nmovq %rdi,<40>(%rbp)\nmovq %rdi,<48>(%rbp)\nmovq %rdi,<56>(%rbp)\nmovq %rdi,<64>(%rbp)\nmovq %rdi,<72>(%rbp)\nmovq %rdi,<80>(%rbp)\nmovq %rdi,<88>(%rbp)\nmovq %rdi,<96>(%rbp)\nmovq %rdi,<104>(%rbp)\nmovq %rdi,<112>(%rbp)\nmovq %rdi,<120>(%rbp)\nmovq %rdi,<128>(%rbp)\nmovq %rdi,<136>(%rbp)\nmov"}
{"tgt": "n := len(p)\ndestination := n * n\nsquares := make([]int, 400)\nisChecked := [401]bool{}\nsquares[0] = 1\nisChecked[1] = true\nsteps := 0\nfor len(squares) > 0 {\n\tsteps++\n\tsize := len(squares)\n\tfor j := 0; j < size; j++ {\n\t\ts := squares[j]\n\t\tfor i := 1; i <= 6; i++ {\n\t\t\tsi := s + i\n\t\t\tx, y := position(si, n)\n\t\t\tif p[x][y] != -1 {\n\t\t\t\tisChecked[si] = true\n\t\t\t\tsi = p[x][y]\n\t\t\t}\n\t\t\tif si == destination {\n\t\t\t\treturn steps\n\t\t\t}\n\t\t\tif !isChecked[si] {\n\t\t\t\tsquares = append(squares, si)\n\t\t\t\tisChecked[si] = true\n\t\t\t}\n\t\t}\n\t}\n\tsquares = squares[size:]\n}\nreturn -1", "gen": "var a [400]int\nvar b [50]int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar ba int\nvar bb int\nvar bc int\nvar bd int\nvar be int\nvar bf int\nvar bg int\nvar bh int\nvar bi int\nvar bj int\nvar bk int\nvar bl int\nvar bm int\nvar bn int\nvar bo int\nvar bp int\nvar bq int\nvar br int\nvar bs int\nvar bt int\nvar bu int\nvar bv int\nvar bw int\nvar bx int\nvar by int\nvar bz int\nvar ca int\nvar cb int\nvar cc int\nvar cd int\nvar ce int\nvar cf int\nvar cg int\nvar ch int\nvar ci int\nvar cj int\nvar ck int\nvar cl int\nvar cm int\nvar cn int\nvar co int\nvar cp"}
{"tgt": "return &linkLoop{\n\tHead: &linkLoopNode{},\n}", "gen": "var d *linkLoopNode\nd = new(linkLoopNode)\nd.linkLoop = new(linkLoop)\nd.linkLoop.linkLoopNode = d\n}\n\n<ASM>\n.LFB1:\nmovq %rdi,-24(%rbp)\nmovq %rsi,-16(%rbp)\nmovq %rdx,-8(%rbp)\nmovq -24(%rbp),%rax\nmovq -16(%rbp),%rdx\nmovq %rdx,(%rax)\nmovq -8(%rbp),%rax\nmovq %rax,<8>(%rax)\nmovq -24(%rbp),%rax\nmovq %rax,%rax\nleave\nret</ASM>"}
{"tgt": "return bindataRead(\n\t_dataCustomersJson,\n\t\"STR\",\n)", "gen": "var dataCustomersJson = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30,\"city\":\"New York\"},{\"id\":2,\"name\":\"Jack\",\"age\":20,\"city\":\"London\"},{\"id\":3,\"name\":\"Mike\",\"age\":25,\"city\":\"Paris\"}]`)\nvar dataCustomersJson2 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30,\"city\":\"New York\"},{\"id\":2,\"name\":\"Jack\",\"age\":20,\"city\":\"London\"},{\"id\":3,\"name\":\"Mike\",\"age\":25,\"city\":\"Paris\"}]`)\nvar dataCustomersJson3 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30,\"city\":\"New York\"},{\"id\":2,\"name\":\"Jack\",\"age\":20,\"city\":\"London\"},{\"id\":3,\"name\":\"Mike\",\"age\":25,\"city\":\"Paris\"}]`)\nvar dataCustomersJson4 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30,\"city\":\"New York\"},{\"id\":2,\"name\":\"Jack\",\"age\":20,\"city\":\"London\"},{\"id\":3,\"name\":\"Mike\",\"age\":25,\"city\":\"Paris\"}]`)\nvar dataCustomersJson5 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30,\"city\":\"New York\"},{\"id\":2,\"name\":\"Jack\",\"age\":20,\"city\":\"London\"},{\"id\":3,\"name\":\"Mike\",\"age\":25,\"city\":\"Paris\"}]`)\nvar dataCustomersJson6 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30,\"city\":\"New York\"},{\"id\":2,\"name\":\"Jack\",\"age\":20,\"city\":\"London\"},{\"id\":3,\"name\":\"Mike\",\"age\":25,\"city\":\"Paris\"}]`)\nvar dataCustomersJson7 = []byte(`[{\"id\":1,\"name\":\"John\",\"age\":30,\"city\":\"New York\"},{\"id\":2,\"name\":\"Jack\",\"age\":20,\"city\":\"London\"},{\"id\":3,\"name\":\"Mike\",\"age\":2"}
{"tgt": "m := len(matrix)\nif m == 0 {\n\treturn 0\n}\nn := len(matrix[0])\nif n == 0 {\n\treturn 0\n}\nmaxEdge := 0\ndp := make([][]int, m+1)\nfor i := range dp {\n\tdp[i] = make([]int, n+1)\n}\nfor i := 1; i <= m; i++ {\n\tfor j := 1; j <= n; j++ {\n\t\tif matrix[i-1][j-1] == '1' {\n\t\t\tdp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))\n\t\t\tmaxEdge = max(maxEdge, dp[i][j])\n\t\t}\n\t}\n}\nreturn maxEdge * maxEdge", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "return x * y", "gen": "var a float32 = 1.0\nvar b float32 = 2.0\nvar c float32 = 3.0\nvar d float32 = 4.0\nvar e float32 = 5.0\nvar f float32 = 6.0\nvar g float32 = 7.0\nvar h float32 = 8.0\nvar i float32 = 9.0\nvar j float32 = 10.0\nvar k float32 = 11.0\nvar l float32 = 12.0\nvar m float32 = 13.0\nvar n float32 = 14.0\nvar o float32 = 15.0\nvar p float32 = 16.0\nvar q float32 = 17.0\nvar r float32 = 18.0\nvar s float32 = 19.0\nvar t float32 = 20.0\nvar u float32 = 21.0\nvar v float32 = 22.0\nvar w float32 = 23.0\nvar x float32 = 24.0\nvar y float32 = 25.0\nvar z float32 = 26.0\nvar aa float32 = 27.0\nvar bb float32 = 28.0\nvar cc float32 = 29.0\nvar dd float32 = 30.0\nvar ee float32 = 31.0\nvar ff float32 = 32.0\nvar gg float32 = 33.0\nvar hh float32 = 34.0\nvar ii float32 = 35.0\nvar jj float32 = 36.0\nvar kk float32 = 37.0\nvar ll float32 = 38.0\nvar mm float32 = 39"}
{"tgt": "if len(a) != len(b) {\n\treturn false\n}\nfor i, v := range a {\n\tif v != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nvar b [10]int\nvar c int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tc = a[i] + b[i]\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(s) <= 1 {\n\treturn s\n}\ni := getIndex(s + \"STR\" + reverse(s))\nreturn reverse(s[i:]) + s", "gen": "fmt.Println(reverse(\"hello\"))\nfmt.Println(reverse(\"world\"))\nfmt.Println(reverse(\"!\"))\nfmt.Println(reverse(\"\"))\nfmt.Println(reverse(\"a\"))\nfmt.Println(reverse(\"ab\"))\nfmt.Println(reverse(\"abc\"))\nfmt.Println(reverse(\"abcd\"))\nfmt.Println(reverse(\"abcde\"))\nfmt.Println(reverse(\"abcdef\"))\nfmt.Println(reverse(\"abcdefg\"))\nfmt.Println(reverse(\"abcdefgh\"))\nfmt.Println(reverse(\"abcdefghi\"))\nfmt.Println(reverse(\"abcdefghij\"))\nfmt.Println(reverse(\"abcdefghijk\"))\nfmt.Println(reverse(\"abcdefghijkl\"))\nfmt.Println(reverse(\"abcdefghijklm\"))\nfmt.Println(reverse(\"abcdefghijklmn\"))\nfmt.Println(reverse(\"abcdefghijklmno\"))\nfmt.Println(reverse(\"abcdefghijklmnop\"))\nfmt.Println(reverse(\"abcdefghijklmnopq\"))\nfmt.Println(reverse(\"abcdefghijklmnopqr\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrs\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrst\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrstu\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrstuv\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrstuvw\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrstuvwx\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrstuvwxy\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrstuvwxyz\"))\nfmt.Println(reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrst"}
{"tgt": "sorted := make([]int, 0, m+n)\np, q := 0, 0\nfor {\n\tif p == m {\n\t\tsorted = append(sorted, nums2[q:]...)\n\t\tbreak\n\t}\n\tif q == n {\n\t\tsorted = append(sorted, nums1[p:]...)\n\t\tbreak\n\t}\n\tif nums1[p] < nums2[q] {\n\t\tsorted = append(sorted, nums1[p])\n\t\tp++\n\t} else {\n\t\tsorted = append(sorted, nums2[q])\n\t\tq++\n\t}\n}\ncopy(nums1, sorted)", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "freq := make(map[rune]int)\nfor _, r := range s {\n\tfreq[r]++\n}\ntype frequency struct {\n\tr     rune\n\tcount int\n}\nletters := make([]*frequency, 0, len(freq))\nfor letter, count := range freq {\n\tletters = append(letters, &frequency{letter, count})\n}\nsort.Slice(letters, func(i, j int) bool {\n\treturn letters[i].count > letters[j].count\n})\nvar sb strings.Builder\nfor len(letters) != 0 {\n\tif len(letters) == 1 && letters[0].count > 1 {\n\t\treturn \"STR\"\n\t}\n\tfor _, f := range letters {\n\t\tsb.WriteRune(f.r)\n\t\tf.count--\n\t}\n\tfor len(letters) != 0 && letters[len(letters)-1].count == 0 {\n\t\tletters = letters[:len(letters)-1]\n\t}\n}\nreturn sb.String()", "gen": "fmt.Println(day231.NoAdjacent([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\n}\n"}
{"tgt": "n := len(A)\nfor i := n - 2; i >= 0; i-- {\n\tA[i] += A[i+1]\n}\nmem := [101][33]int{}\nvar dp func(int, int) int\ndp = func(i, m int) int {\n\tif i+2*m >= n {\n\t\treturn A[i]\n\t}\n\tif mem[i][m] > 0 {\n\t\treturn mem[i][m]\n\t}\n\tres := 0\n\tfor x := 1; x <= 2*m; x++ {\n\t\tres = max(\n\t\t\tres,\n\t\t\tA[i]-dp(i+x, max(m, x)),\n\t\t)\n\t}\n\tmem[i][m] = res\n\treturn res\n}\nreturn dp(0, 1)", "gen": "var stones []int\nvar A, B int\nfmt.Scan(&A, &B)\nstones = make([]int, A+B)\nfor i := 0; i < A; i++ {\n\tfmt.Scan(&stones[i])\n}\nfor i := A; i < A+B; i++ {\n\tfmt.Scan(&stones[i])\n}\nfmt.Println(stoneGameII(stones))\n}\n"}
{"tgt": "if n <= 2 {\n\treturn n\n}\nvar dp [2]int\ndp[0], dp[1] = 1, 2\nfor i := 2; i < n; i++ {\n\tdp[i%2] = dp[i%2] + dp[(i-1)%2]\n}\nreturn dp[(n-1)%2]", "gen": "var a [2]int\na[0] = 1\na[1] = 2\na[0], a[1] = a[1], a[0]\nprintln(a[0], a[1])\n}\n\n// Output:\n// 2 1\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n// \u6c47\u7f16\u4ee3\u7801\n.LFB32:\ncmpq %fs:112,%rsp\njnb .L697\nmovl $56,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL41:\nret\n.L697:\npushq %rbp\nmovq %rsp,%rbp\nsubq $48,%rsp\nmovq %rdi,-40(%rbp)\nmovq $0,-16(%rbp)\n.LBB595:\n.LBB596:\ncmpq $2,-40(%rbp)\njg .L676\n.LBB597:\n.LBB598:\nmovq -40(%rbp),%rax\nmovq %rax,-16(%rbp)\nmovq -16(%rbp),%rax\njmp .L689\n.L676:\n.LBE598:\n.LBE597:\n.LBE596:\nmovq $0,-32(%rbp)\nmovq $0,-24(%rbp)\n.LBB599:\nmovl $1,%edx\nmovl $2,%eax\nmovq %rdx,-32(%rbp)\nmovq %rax,-24(%rbp)\n.LBE599:\n.LBB600:\nmovq $2,-8(%rbp)\n.LBB601:\njmp .L678\n.L696:\n.LBB602:\nnop\n.LBE602:\n.LBB603"}
{"tgt": "email = strings.TrimSpace(email)\nemail = strings.ToLower(email)\nh := md5.New()\nio.WriteString(h, email)\nfinalBytes := h.Sum(nil)\nfinalString := hex.EncodeToString(finalBytes)\nreturn finalString", "gen": "var s string\nfmt.Scan(&s)\ns = strings.TrimSpace(s)\ns = strings.ToLower(s)\nh := md5.New()\nio.WriteString(h, s)\nfmt.Printf(\"%x\\n\", h.Sum(nil))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t}, {\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n}\nfor _, tt := range tests {\n\tgot := repeatedSubstringPattern(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(repeatedSubstringPattern(\"abab\"))\nfmt.Println(repeatedSubstringPattern(\"aba\"))\nfmt.Println(repeatedSubstringPattern(\"abcabcabcabc\"))\nfmt.Println(repeatedSubstringPattern(\"abcabcab\"))\nfmt.Println(repeatedSubstringPattern(\"abcabc\"))\nfmt.Println(repeatedSubstringPattern(\"abcab\"))\nfmt.Println(repeatedSubstringPattern(\"abc\"))\nfmt.Println(repeatedSubstringPattern(\"a\"))\nfmt.Println(repeatedSubstringPattern(\"\"))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   0x5555,\n\t\twant: 8,\n\t},\n}\nfor _, tt := range tests {\n\tgot := hammingWeight(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var a, b, c, d int\na = 3\nb = 2\nc = 7\nd = 8\nvar e, f, g, h int\ne = 1\nf = 21845\ng = 8\nh = 2\nvar i, j, k, l int\ni = 4\nj = 0\nk = 0\nl = 0\nvar m, n, o, p int\nm = 4\nn = 0\no = 0\np = 0\nvar q, r, s, t int\nq = 4\nr = 0\ns = 0\nt = 0\nvar u, v, w, x int\nu = 4\nv = 0\nw = 0\nx = 0\nvar y, z int\ny = 4\nz = 0\nvar aa, ab, ac, ad int\naa = 4\nab = 0\nac = 0\nad = 0\nvar ae, af, ag, ah int\nae = 4\naf = 0\nag = 0\nah = 0\nvar ai, aj, ak, al int\nai = 4\naj = 0\nak = 0\nal = 0\nvar am, an, ao, ap int\nam = 4\nan = 0\nao = 0\nap = 0\nvar aq, ar, as, at int\naq = 4\nar = 0\nas = 0\nat = 0\nvar au, av, aw, ax int\nau = 4\nav = 0\naw = 0\nax = 0\nvar ay, az int\nay = 4\naz = 0\nvar ba, bb, bc, bd int\nba = 4\nbb = 0\nbc = 0\nbd ="}
{"tgt": "return bindataRead(\n\t_assetsHomeCatJpg,\n\t\"STR\",\n)", "gen": "var homeCatJpg []byte\nvar homeCatJpg2 []byte\nvar homeCatJpg3 []byte\nvar homeCatJpg4 []byte\nvar homeCatJpg5 []byte\nvar homeCatJpg6 []byte\nvar homeCatJpg7 []byte\nvar homeCatJpg8 []byte\nvar homeCatJpg9 []byte\nvar homeCatJpg10 []byte\nvar homeCatJpg11 []byte\nvar homeCatJpg12 []byte\nvar homeCatJpg13 []byte\nvar homeCatJpg14 []byte\nvar homeCatJpg15 []byte\nvar homeCatJpg16 []byte\nvar homeCatJpg17 []byte\nvar homeCatJpg18 []byte\nvar homeCatJpg19 []byte\nvar homeCatJpg20 []byte\nvar homeCatJpg21 []byte\nvar homeCatJpg22 []byte\nvar homeCatJpg23 []byte\nvar homeCatJpg24 []byte\nvar homeCatJpg25 []byte\nvar homeCatJpg26 []byte\nvar homeCatJpg27 []byte\nvar homeCatJpg28 []byte\nvar homeCatJpg29 []byte\nvar homeCatJpg30 []byte\nvar homeCatJpg31 []byte\nvar homeCatJpg32 []byte\nvar homeCatJpg33 []byte\nvar homeCatJpg34 []byte\nvar homeCatJpg35 []byte\nvar homeCatJpg36 []byte\nvar homeCatJpg37 []byte\nvar homeCatJpg38 []byte\nvar homeCatJpg39 []byte\nvar homeCatJpg40 []byte\nvar homeCatJpg41 []byte\nvar homeCatJpg42 []byte\nvar homeCatJpg43 []byte\nvar homeCatJpg44 []byte\nvar homeCatJpg45 []byte\nvar homeCatJpg46 []byte\nvar homeCat"}
{"tgt": "b.table = make(map[string]*entry, capacity)\nb.priorityQueue = make([]*entry, 0, capacity)\nb.lruList.Init()\nb.freeList.Init()\nheap.Init(&b.priorityQueue)\narrayOfEntries := make([]entry, capacity)\nfor i := uint(0); i < capacity; i++ {\n\te := &arrayOfEntries[i]\n\te.element.Value = e\n\te.index = -1\n\tb.freeList.PushElementBack(&e.element)\n}", "gen": "var m = New(10)\nfor i := 0; i < 100; i++ {\n\tm.Get(i)\n}\n}\n"}
{"tgt": "list.rear = nil", "gen": "var x *int\n*x = 0\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "h := newLinkedHeap()\nbenchmarkHeap(b, h)", "gen": "var h heap.Heap\nh = heap.NewLinkedHeap()\nbenchmarkHeap(&h)\n}\n"}
{"tgt": "close(p.work)\np.wg.Wait()", "gen": "var wg sync.WaitGroup\nch := make(chan int)\nwg.Add(1)\ngo func() {\n\tdefer wg.Done()\n\t<-ch\n}()\nwg.Wait()\n}\n\n<ASM>\nmovq %fs:112,%r10\nmovq %rsp,%r11\nsubq $16,%rsp\nmovq %rdi,-8(%rsp)\nmovq -8(%rsp),%rax\nmovq (%rax),%rax\nmovq %rax,-16(%rsp)\nmovq -16(%rsp),%rax\nmovq %rax,-8(%rsp)\nmovq -8(%rsp),%rax\nmovq (%rax),%rax\nmovq %rax,-8(%rsp)\nmovq -8(%rsp),%rax\nmovq (%rax),%rax\nmovq %rax,-8(%rsp)\nmovq -8(%rsp),%rax\nmovq (%rax),%rax\nmovq %rax,-8(%rsp)\nmovq -8(%rsp),%rax\nmovq (%rax),%rax\nmovq %rax,-8(%rsp)\nmovq -8(%rsp),%rax\nmovq (%rax),%rax\nmovq %rax,-8(%rsp)\nmovq -8(%rsp),%rax\nmovq (%rax),%rax\nmovq %rax,-8(%rsp)\nmovq -8(%rsp),%rax\nmovq (%rax),%rax\nmovq %rax,-8(%rsp)\nmovq -8(%rsp),%rax\nmovq (%rax),%rax\nmovq %rax,-8(%rsp)\nmovq -8(%rsp),%rax\nmovq (%rax),%rax\nmovq %rax,-8(%rsp)\nmovq -8(%rsp),%rax\nmov"}
{"tgt": "res := 0\nfactor := 1\nsize := len(s)\nfor i := 0; i < size; i++ {\n\tif s[i] == '(' {\n\t\tfactor *= 2\n\t} else {\n\t\tfactor /= 2\n\t}\n\tif s[i] == '(' && s[i+1] == ')' {\n\t\tres += factor / 2\n\t}\n}\nreturn res", "gen": "var a [10]byte\nvar i int\nfor i = 0; i < 10; i++ {\n\tif i == 0 {\n\t\ta[i] = 'a'\n\t} else if i == 1 {\n\t\ta[i] = 'b'\n\t} else {\n\t\ta[i] = 'c'\n\t}\n}\nfmt.Println(string(a[:]))\n}\n\n// Output:\n// a\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n.LFB0:\ncmpq %fs:112,%rsp\njnb .L18\nmovl $72,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L18:\npushq %rbp\nmovq %rsp,%rbp\nsubq $64,%rsp\nmovq %rdi,%rax\nmovq %rsi,%rcx\nmovq %rcx,%rdx\nmovq %rax,-64(%rbp)\nmovq %rdx,-56(%rbp)\nmovq $0,-32(%rbp)\n.LBB2:\nmovq $0,-8(%rbp)\nmovq $1,-16(%rbp)\nmovq -56(%rbp),%rax\nmovq %rax,-40(%rbp)\n.LBB3:\nmovq $0,-24(%rbp)\n.LBB4:\njmp .L2\n.L17:\n.LBB5:\nnop\n.LBE5:\n.LBB6:\n.LBB7:\nmovq -56(%rbp),%rax\ncmpq $0,-24(%rbp)\njs .L3\ncmpq %rax,-24(%rbp)\njge .L3\nmovq -64(%rbp),%rdx\nmovq -24(%rbp),%rax\naddq %rdx,%ra"}
{"tgt": "qs := []question454{\n\t{\n\t\tpara454{[]int{1, 2}, []int{-2, -1}, []int{-1, 2}, []int{0, 2}},\n\t\tans454{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans454, q.para454\n\tfmt.Printf(\"STR\", p, fourSumCount(p.a, p.b, p.c, p.d))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "for i := range langs {\n\tlanguage := langs[i]\n\tif strings.EqualFold(language.Lang, str) {\n\t\treturn &language\n\t}\n}\nreturn nil", "gen": "langs := []Language{\n\t{\"Go\", \"golang\", \"golang\"},\n\t{\"Python\", \"python\", \"python\"},\n\t{\"Ruby\", \"ruby\", \"ruby\"},\n}\nvar lang Language\nfor _, l := range langs {\n\tif l.Name == \"Go\" {\n\t\tlang = l\n\t\tbreak\n\t}\n}\nfmt.Println(lang)\n}\n"}
{"tgt": "sort.Ints(houses)\nsort.Ints(heaters)\ni, ans := 0, 0\nfor _, house := range houses {\n\tfor i < len(heaters)-1 && heaters[i]+heaters[i+1] <= house*2 {\n\t\ti++\n\t}\n\tans = maxInt(ans, absInt(heaters[i]-house))\n}\nreturn ans", "gen": "var a, b []int\nfmt.Scan(&a, &b)\nsort.Ints(a)\nsort.Ints(b)\nvar c int\nfor i := 0; i < len(a); i++ {\n\tfor j := 0; j < len(b); j++ {\n\t\tif a[i] == b[j] {\n\t\t\tc++\n\t\t}\n\t}\n}\nfmt.Println(c)\n}\n"}
{"tgt": "return h.FromHexString(string(b))", "gen": "var hash go.metainfo.Hash\nhash.FromHexString(\"1234567890123456789012345678901234567890\")\nfmt.Println(hash)\n}\n\n// Output:\n// 1234567890123456789012345678901234567890\n```\n\n### 2.2.2. \u6c47\u7f16\u4ee3\u7801\n\n```asm"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{\n\t\t{10, 16},\n\t\t{2, 8},\n\t\t{1, 6},\n\t\t{7, 12},\n\t}, 2},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := findMinArrowShots(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "if n < 2 {\n\treturn false\n}\nfor i := 2; i < n; i++ {\n\tif n%i == 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a int\nvar b int\na = 1\nb = 2\nfor a < b {\n\tif a == -1 {\n\t\tpanic(\"divide by zero\")\n\t}\n\tif a == 0 {\n\t\tbreak\n\t}\n\ta = a / b\n}\nif a == 0 {\n\tfmt.Println(\"a is zero\")\n} else {\n\tfmt.Println(\"a is not zero\")\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{5, 3, 4, 5},\n\t\twant: true,\n\t},\n\t{\n\t\tin:   []int{2, 5, 7, 3},\n\t\twant: true,\n\t},\n}\nfor _, tt := range tests {\n\tgot := stoneGame(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(stoneGame([]int{5, 3, 4, 5}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5, 7}))\nfmt.Println(stoneGame([]int{2, 5, 5,"}
{"tgt": "return self.code", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nfmt.Println(a)\n}\n\n// Output:\n// [1 2 3]\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```"}
{"tgt": "if N == 1 {\n\treturn 0\n}\nif K%2 == 1 {\n\treturn kthGrammar(N-1, (K+1)/2)\n}\nreturn opposite(kthGrammar(N-1, K/2))", "gen": "fmt.Println(kthGrammar(1, 1))\nfmt.Println(kthGrammar(2, 1))\nfmt.Println(kthGrammar(3, 1))\nfmt.Println(kthGrammar(4, 1))\nfmt.Println(kthGrammar(5, 1))\nfmt.Println(kthGrammar(6, 1))\nfmt.Println(kthGrammar(7, 1))\nfmt.Println(kthGrammar(8, 1))\nfmt.Println(kthGrammar(9, 1))\nfmt.Println(kthGrammar(10, 1))\nfmt.Println(kthGrammar(11, 1))\nfmt.Println(kthGrammar(12, 1))\nfmt.Println(kthGrammar(13, 1))\nfmt.Println(kthGrammar(14, 1))\nfmt.Println(kthGrammar(15, 1))\nfmt.Println(kthGrammar(16, 1))\nfmt.Println(kthGrammar(17, 1))\nfmt.Println(kthGrammar(18, 1))\nfmt.Println(kthGrammar(19, 1))\nfmt.Println(kthGrammar(20, 1))\nfmt.Println(kthGrammar(21, 1))\nfmt.Println(kthGrammar(22, 1))\nfmt.Println(kthGrammar(23, 1))\nfmt.Println(kthGrammar(24, 1))\nfmt.Println(kthGrammar(25, 1))\nfmt.Println(kthGrammar(26, 1))\nfmt.Println(kthGrammar(27,"}
{"tgt": "tests := [...]testType{\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := buddyStrings(tt.a, tt.b)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.a, tt.b, got, tt.want)\n\t}\n}", "gen": "buddyStrings(\"ab\", \"ba\")\n}\n"}
{"tgt": "ope := [][]int{\n\t{2, 2},\n\t{3, 3}}\nfmt.Println(maxCount(3, 3, ope))", "gen": "var a, b int\nfmt.Scan(&a, &b)\nfmt.Println(maxCount(a, b))\n}\n"}
{"tgt": "qs := []question274{\n\t{\n\t\tpara274{[]int{3, 6, 9, 1}},\n\t\tans274{3},\n\t},\n\t{\n\t\tpara274{[]int{1}},\n\t\tans274{1},\n\t},\n\t{\n\t\tpara274{[]int{}},\n\t\tans274{0},\n\t},\n\t{\n\t\tpara274{[]int{3, 0, 6, 1, 5}},\n\t\tans274{3},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans274, q.para274\n\tfmt.Printf(\"STR\", p, hIndex(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world!\")\n}\n"}
{"tgt": "sort.Strings(words)\nmp := make(map[string]bool)\nvar res string\nfor _, word := range words {\n\tsize := len(word)\n\tif size == 1 || mp[word[:size-1]] {\n\t\tif size > len(res) {\n\t\t\tres = word\n\t\t}\n\t\tmp[word] = true\n\t}\n}\nreturn res", "gen": "var a []string\nvar b []string\nvar c map[string]bool\nsort.Strings(a)\nsort.Strings(b)\nc = make(map[string]bool)\nfor i := 0; i < len(a); i++ {\n\tif c[a[i]] {\n\t\tpanic(\"duplicate\")\n\t}\n\tc[a[i]] = true\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "longestCenter, longestLength := 0, 0\nfor i, v := range P {\n\tif v > longestLength {\n\t\tlongestLength = v\n\t\tlongestCenter = i\n\t}\n}\noffset := (longestCenter - longestLength) / 2\nreturn s[offset : offset+longestLength]", "gen": "var a [10]int\nvar b [10]int\nvar c int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tc = a[i] + b[i]\n}\nprintln(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for j := 1; j <= 20; j++ {\n\tif num%j != 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a int\nfor i := 0; i < 20; i++ {\n\ta = a / i\n\tif a == 0 {\n\t\tbreak\n\t}\n}\nif a == 0 {\n\tpanic(\"divide by zero\")\n}\nprintln(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "n := node.(*bstElement)\nif n == nil {\n\treturn nil\n}\nif n.right != nil {\n\treturn t.Min(n.right)\n}\ncur := n\nfor cur.parent != nil && cur.parent.left != cur {\n\tcur = cur.parent\n}\nreturn cur.parent", "gen": "var bst *BST\nbst = NewBST()\nbst.Insert(10)\nbst.Insert(20)\nbst.Insert(30)\nbst.Insert(40)\nbst.Insert(50)\nbst.Insert(60)\nbst.Insert(70)\nbst.Insert(80)\nbst.Insert(90)\nbst.Insert(100)\nbst.Insert(110)\nbst.Insert(120)\nbst.Insert(130)\nbst.Insert(140)\nbst.Insert(150)\nbst.Insert(160)\nbst.Insert(170)\nbst.Insert(180)\nbst.Insert(190)\nbst.Insert(200)\nbst.Insert(210)\nbst.Insert(220)\nbst.Insert(230)\nbst.Insert(240)\nbst.Insert(250)\nbst.Insert(260)\nbst.Insert(270)\nbst.Insert(280)\nbst.Insert(290)\nbst.Insert(300)\nbst.Insert(310)\nbst.Insert(320)\nbst.Insert(330)\nbst.Insert(340)\nbst.Insert(350)\nbst.Insert(360)\nbst.Insert(370)\nbst.Insert(380)\nbst.Insert(390)\nbst.Insert(400)\nbst.Insert(410)\nbst.Insert(420)\nbst.Insert(430)\nbst.Insert(440)\nbst.Insert(450)\nbst.Insert(460)\nbst.Insert(470)\nbst.Insert(480)\nbst.Insert(490)\nbst."}
{"tgt": "var r [][]int\nfor i := begin; i <= end; i++ {\n\tif 1 == k {\n\t\tr = append(r, []int{i})\n\t\tcontinue\n\t}\n\tsuf := comb(i+1, end, k-1)\n\tfor _, j := range suf {\n\t\tr = append(r, append([]int{i}, j...))\n\t}\n}\nreturn r", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aaa [3]int\nvar aab [3]int\nvar aac [3]int\nvar aad [3]int\nvar aae [3]int\nvar aaf [3]int\nvar aag [3]int\nvar aah [3]int\nvar aai [3]int\n"}
{"tgt": "b.lock.Lock()\ndefer b.lock.Unlock()\ne := b.table[key]\nif e == nil {\n\treturn nil, false\n}\nif e.expire.Before(now) {\n\tif b.ExpireGracePeriod == 0 || e.expire.Sub(now) > b.ExpireGracePeriod {\n\t\tb.removeEntry(e)\n\t}\n\treturn nil, false\n}\nb.touchEntry(e)\nreturn e.value, true", "gen": "var m sync.Mutex\nvar c = NewLRUCache(100)\nm.Lock()\nc.Add(\"a\", 1)\nc.Add(\"b\", 2)\nc.Add(\"c\", 3)\nc.Add(\"d\", 4)\nc.Add(\"e\", 5)\nc.Add(\"f\", 6)\nc.Add(\"g\", 7)\nc.Add(\"h\", 8)\nc.Add(\"i\", 9)\nc.Add(\"j\", 10)\nc.Add(\"k\", 11)\nc.Add(\"l\", 12)\nc.Add(\"m\", 13)\nc.Add(\"n\", 14)\nc.Add(\"o\", 15)\nc.Add(\"p\", 16)\nc.Add(\"q\", 17)\nc.Add(\"r\", 18)\nc.Add(\"s\", 19)\nc.Add(\"t\", 20)\nc.Add(\"u\", 21)\nc.Add(\"v\", 22)\nc.Add(\"w\", 23)\nc.Add(\"x\", 24)\nc.Add(\"y\", 25)\nc.Add(\"z\", 26)\nm.Unlock()\nfor i := 0; i < 100; i++ {\n\tm.Lock()\n\tc.Get(\"a\")\n\tc.Get(\"b\")\n\tc.Get(\"c\")\n\tc.Get(\"d\")\n\tc.Get(\"e\")\n\tc.Get(\"f\")\n\tc.Get(\"g\")\n\tc.Get(\"h\")\n\tc.Get(\"i\")\n\tc.Get(\"j\")\n\tc.Get(\"k\")\n\tc.Get(\"l\")\n\tc.Get(\"m\")\n\tc.Get(\"n\")\n\tc.Get(\"o\")\n"}
{"tgt": "if root == nil {\n\treturn 0\n}\nresult := 0\nif root.Val >= L && root.Val <= R {\n\tresult += root.Val\n}\nif root.Val >= L {\n\tresult += rangeSumBST(root.Left, L, R)\n}\nif root.Val <= R {\n\tresult += rangeSumBST(root.Right, L, R)\n}\nreturn result", "gen": "fmt.Println(rangeSumBST(nil, 1))\nfmt.Println(rangeSumBST([]int{10}, 1))\nfmt.Println(rangeSumBST([]int{10, 5}, 7))\nfmt.Println(rangeSumBST([]int{10, 5}, 12))\nfmt.Println(rangeSumBST([]int{10, 5}, 11))\nfmt.Println(rangeSumBST([]int{10, 5}, 10))\nfmt.Println(rangeSumBST([]int{10, 5}, 5))\nfmt.Println(rangeSumBST([]int{10, 5}, 4))\nfmt.Println(rangeSumBST([]int{10, 5}, 3))\nfmt.Println(rangeSumBST([]int{10, 5}, 2))\nfmt.Println(rangeSumBST([]int{10, 5}, 1))\nfmt.Println(rangeSumBST([]int{10, 5}, 0))\nfmt.Println(rangeSumBST([]int{10, 5}, -1))\nfmt.Println(rangeSumBST([]int{10, 5}, -2))\nfmt.Println(rangeSumBST([]int{10, 5}, -3))\nfmt.Println(rangeSumBST([]int{10, 5}, -4))\nfmt.Println(rangeSumBST([]int{10, 5}, -5))\nfmt.Println(rangeSumBST([]int{10, 5}, -6))\nfmt.Println(rangeSumBST([]int{10, 5}, -7))\nfmt.Println(rangeSumBST([]int{10, 5}, -8))\nfmt.Println(rangeSumBST([]int{10, 5}, -9))\nfmt."}
{"tgt": "if tree.root == nil {\n\treturn nil, false\n}\ncurrentNode := tree.root\nfor currentNode != nil {\n\tif i == currentNode.data {\n\t\treturn currentNode, true\n\t} else if i > currentNode.data {\n\t\tcurrentNode = currentNode.right\n\t} else if i < currentNode.data {\n\t\tcurrentNode = currentNode.left\n\t}\n}\nreturn nil, false", "gen": "var a, b int\nvar c bool\na = 1\nb = 2\nc = a < b\nfmt.Println(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "length := len(nums)\nif length == 0 || length == 1 && nums[0] != target {\n\treturn []int{-1, -1}\n}\nreturn searchRangeI(nums, 0, length-1, target)", "gen": "var nums = []int{2, 5, 6, 0, 0, 1, 2}\nvar target = 3\nfmt.Println(searchRange(nums, target))\n}\n"}
{"tgt": "var (\n\tl int\n\tr = len(nums) - 1\n)\nfor l <= r {\n\tmid := l + (r-l)/2\n\tif target == nums[mid] {\n\t\treturn mid\n\t}\n\tif nums[mid] >= nums[l] && nums[mid] > nums[r] {\n\t\tif target >= nums[l] && target < nums[mid] {\n\t\t\tr = mid - 1\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t} else {\n\t\tif target > nums[mid] && target <= nums[r] {\n\t\t\tl = mid + 1\n\t\t} else {\n\t\t\tr = mid - 1\n\t\t}\n\t}\n}\nreturn -1", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"fail\")\n\t}\n}\nfor i = 9; i >= 0; i-- {\n\tif a[i] != i {\n\t\tpanic(\"fail\")\n\t}\n}\nfor i = 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"fail\")\n\t}\n}\nfor i = 9; i >= 0; i-- {\n\tif a[i] != i {\n\t\tpanic(\"fail\")\n\t}\n}\nfor i = 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"fail\")\n\t}\n}\nfor i = 9; i >= 0; i-- {\n\tif a[i] != i {\n\t\tpanic(\"fail\")\n\t}\n}\nfor i = 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"fail\")\n\t}\n}\nfor i = 9; i >= 0; i-- {\n\tif a[i] != i {\n\t\tpanic(\"fail\")\n\t}\n}\nfor i = 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"fail\")\n\t}\n}\nfor i = 9; i >= 0; i-- {\n\tif a[i] != i {\n\t\tpanic(\"fail\")\n\t}\n}\nfor i = 0; i < 10; i++ {\n\tif a["}
{"tgt": "if squares < 3 {\n\treturn 1\n}\nif answer, ok := memo[squares]; ok {\n\treturn answer\n}\ntotal := int64(1)\nfor size := 3; size <= squares; size++ {\n\tfor start := 0; start <= squares-size; start++ {\n\t\tanswer := int64(1)\n\t\tanswer *= ways(squares - start - size - 1)\n\t\ttotal += answer\n\t}\n}\nmemo[squares] = total\nreturn total", "gen": "var n int\nfmt.Scan(&n)\nfmt.Println(ways(n))\n}\n"}
{"tgt": "return &CircularBuffer{\n\tbuffer: make([]interface{}, size),\n\tsize:   size,\n\tavail:  make(chan bool, size),\n}", "gen": "var c chan bool\nvar s []bool\nvar b CircularBuffer\nc = make(chan bool)\ns = make([]bool, 0)\nb = CircularBuffer{}\n}\n\n<ASM>\n.LFB233:\ncmpq %fs:112,%rsp\njnb .L264\nmovl $168,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL233:\nret\n.L264:\npushq %rbp\nmovq %rsp,%rbp\npushq %r13\npushq %r12\npushq %rbx\nsubq $136,%rsp\nmovq %rdi,-152(%rbp)\nmovq $0,-40(%rbp)\n.LBB234:\nmovq -152(%rbp),%rbx\n.LBB235:\nmovq %rbx,%rdx\nmovq %rbx,%rax\nmovq %rax,%rsi\nleaq <type..interface.4.5>(%rip),%rdi\ncall <runtime.makeslice@PLT>\nmovq %rax,%r13\nmovq -152(%rbp),%rax\nmovq %rax,%rsi\nleaq <type..chan.0bool>(%rip),%rdi\ncall <runtime.makechan@PLT>\nmovq %rax,%r12\nmovq %r13,-144(%rbp)\nmovq %rbx,-136(%rbp)\nmovq %rbx,-128(%rbp)\nleaq <go.circularbuffer.CircularBuffer..d>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-120(%rbp)\nmovq $0,-112(%rbp)\nmovq $0,-104(%rbp)\nmovq $0,-96(%rbp)\nmovq $0,-88(%rbp"}
{"tgt": "return uint32((dev >> 8) & 0xff)", "gen": "var a int\na = 0\na >>= 8\nprintln(a)\n}\n\n<ASM>\n.LFB2:\nmovl $0,-4(%rbp)\nmovl $0,-4(%rbp)\nmovl -4(%rbp),%eax\n.LBE2:\npopq %rbp\nret</ASM>"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 4,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 6,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 6,\n\t},\n}\nfor _, tt := range tests {\n\tgot := longestValidParentheses(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(longestValidParentheses(\"(()\"))\nfmt.Println(longestValidParentheses(\")()())\"))\nfmt.Println(longestValidParentheses(\"()(()\"))\nfmt.Println(longestValidParentheses(\")()()\"))\nfmt.Println(longestValidParentheses(\"()\"))\nfmt.Println(longestValidParentheses(\"()()\"))\nfmt.Println(longestValidParentheses(\"()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()"}
{"tgt": "iterator := func() <-chan VertexId {\n\tch := make(chan VertexId)\n\tgo func() {\n\t\tif connected, ok := g.edges[vertex]; ok {\n\t\t\tfor VertexId, _ := range connected {\n\t\t\t\tif g.IsEdge(vertex, VertexId) {\n\t\t\t\t\tch <- VertexId\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\nreturn VerticesIterable(&vertexIterableHelper{iterFunc: iterator})", "gen": "g := NewGraph()\nv1 := g.AddVertex(\"1\")\nv2 := g.AddVertex(\"2\")\ng.AddEdge(v1, v2)\nfmt.Println(g)\n}\n"}
{"tgt": "ans := 0\nfor ; x != 0; x /= 10 {\n\tans = ans*10 + x%10\n}\nif ans < math.MinInt32 || ans > math.MaxInt32 {\n\treturn 0\n}\nreturn ans", "gen": "var a int64 = 1\nvar b int64 = 2\nvar c int64 = 3\nvar d int64 = 4\nvar e int64 = 5\nvar f int64 = 6\nvar g int64 = 7\nvar h int64 = 8\nvar i int64 = 9\nvar j int64 = 10\nvar k int64 = 11\nvar l int64 = 12\nvar m int64 = 13\nvar n int64 = 14\nvar o int64 = 15\nvar p int64 = 16\nvar q int64 = 17\nvar r int64 = 18\nvar s int64 = 19\nvar t int64 = 20\nvar u int64 = 21\nvar v int64 = 22\nvar w int64 = 23\nvar x int64 = 24\nvar y int64 = 25\nvar z int64 = 26\nvar aa int64 = 27\nvar bb int64 = 28\nvar cc int64 = 29\nvar dd int64 = 30\nvar ee int64 = 31\nvar ff int64 = 32\nvar gg int64 = 33\nvar hh int64 = 34\nvar ii int64 = 35\nvar jj int64 = 36\nvar kk int64 = 37\nvar ll int64 = 38\nvar mm int64 = 39\nvar nn int64 = 40\nvar oo int64 = 41\nvar pp int64 = 42\nvar qq int64 = 43\nvar rr int64 = 44\nvar ss int64 = 45\nvar tt int"}
{"tgt": "i, size := 0, len(s)\nss := make([]string, numRows)\nfor i < size {\n\tfor j := 0; j < numRows && i < size; j++ {\n\t\tss[j] += string(s[i])\n\t\ti++\n\t}\n\tfor j := numRows - 2; j > 0 && i < size; j-- {\n\t\tss[j] += string(s[i])\n\t\ti++\n\t}\n}\nvar ret string\nfor j := 0; j < numRows; j++ {\n\tret += ss[j]\n}\nreturn ret", "gen": "var s []string\ns = append(s, \"a\")\ns = append(s, \"b\")\ns = append(s, \"c\")\ns = append(s, \"d\")\ns = append(s, \"e\")\ns = append(s, \"f\")\ns = append(s, \"g\")\ns = append(s, \"h\")\ns = append(s, \"i\")\ns = append(s, \"j\")\ns = append(s, \"k\")\ns = append(s, \"l\")\ns = append(s, \"m\")\ns = append(s, \"n\")\ns = append(s, \"o\")\ns = append(s, \"p\")\ns = append(s, \"q\")\ns = append(s, \"r\")\ns = append(s, \"s\")\ns = append(s, \"t\")\ns = append(s, \"u\")\ns = append(s, \"v\")\ns = append(s, \"w\")\ns = append(s, \"x\")\ns = append(s, \"y\")\ns = append(s, \"z\")\ns = append(s, \"A\")\ns = append(s, \"B\")\ns = append(s, \"C\")\ns = append(s, \"D\")\ns = append(s, \"E\")\ns = append(s, \"F\")\ns = append(s, \"G\")\ns = append(s, \"H\")\ns = append(s, \"I\")\ns = append(s, \"J\")\ns = append(s, \"K\")\ns = append(s, \"L\")\ns = append(s, \"M\")\ns = append(s, \"N\")\ns = append(s, \"O\")\ns = append(s, \"P\")\ns = append(s, \"Q\")\ns = append(s, \"R\")\ns = append(s, \"S\")"}
{"tgt": "sum := big.NewInt(0)\nfor i := int64(1); i <= 1000; i++ {\n\tval := big.NewInt(i)\n\tsum.Add(sum, pow(val, i))\n}\nfmt.Println(\"STR\", sum.String())", "gen": "var a big.Int\na.SetInt64(1)\nvar b big.Int\nb.SetInt64(1)\nfor i := 0; i < 1000; i++ {\n\tb.Add(&a, &b)\n}\nfmt.Println(b.String())\n}"}
{"tgt": "for l, r := 0, len(A)-1; ; {\n\tm := (l + r) / 2\n\tif A[m] < A[m+1] {\n\t\tl = m\n\t} else if A[m-1] > A[m] {\n\t\tr = m\n\t} else {\n\t\treturn m\n\t}\n}", "gen": "var a [10]int\na[10] = 1\n}\n\n// 0000000000000000 <main>:\n// \t.globl\tmain\n// \t.type\tmain,@function\n// \t.p2align\t4\n// main:\n// \t.cfi_startproc\n// \t.cfi_personality 0x0,__gxx_personality_v0\n// \t.cfi_lsda 0x1b,.LLSDA0\n// \t.cfi_loc\t1 0 0\n// \t.cfi_adjust_cfa_offset 4\n// \t.cfi_endproc\n// \t.size\tmain, .-main\n// \t.ident\t\"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-36)\"\n// \t.section\t.note.GNU-stack,\"\",@progbits\n\n// 0000000000000000 <main>:\n// \t.globl\tmain\n// \t.type\tmain,@function\n// \t.p2align\t4\n// main:\n// \t.cfi_startproc\n// \t.cfi_personality 0x0,__gxx_personality_v0\n// \t.cfi_lsda 0x1b,.LLSDA0\n// \t.cfi_loc\t1 0 0\n// \t.cfi_adjust_cfa_offset 4\n// \t.cfi_endproc\n// \t.size\tmain, .-main\n// \t.ident\t\"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-36)\"\n// \t.section\t.note.GNU-stack,\"\",@progbits\n\n// 0000000000000000 <main>:\n// "}
{"tgt": "max := 1000\nsum := 0\nfor i := 1; i < max; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)", "gen": "var a int\nvar b int\nvar c int\nvar d int\na = 1000\nb = 0\nfor i := 1; i < 1000; i++ {\n\tif i%3 == 0 {\n\t\tb += i\n\t}\n\tif i%5 == 0 {\n\t\tc += i\n\t}\n\tif i%3 == 0 && i%5 == 0 {\n\t\td += i\n\t}\n}\nfmt.Println(a, b, c, d)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if k < 0 || len(nums) == 0 {\n\treturn 0\n}\nvar count int\nm := make(map[int]int, len(nums))\nfor _, value := range nums {\n\tm[value]++\n}\nfor key := range m {\n\tif k == 0 && m[key] > 1 {\n\t\tcount++\n\t\tcontinue\n\t}\n\tif k > 0 && m[key+k] > 0 {\n\t\tcount++\n\t}\n}\nreturn count", "gen": "var m map[int][2]int\nvar i int\nfor i = 0; i < 1000000; i++ {\n\tm[i] = [2]int{i, i}\n}\nvar j int\nfor j = 0; j < 1000000; j++ {\n\tm[j][0] = j\n}\nvar k int\nfor k = 0; k < 1000000; k++ {\n\tm[k][1] = k\n}\nvar l int\nfor l = 0; l < 1000000; l++ {\n\tm[l][0] = l\n}\nvar m2 map[int][2]int\nvar i2 int\nfor i2 = 0; i2 < 1000000; i2++ {\n\tm2[i2] = [2]int{i2, i2}\n}\nvar j2 int\nfor j2 = 0; j2 < 1000000; j2++ {\n\tm2[j2][0] = j2\n}\nvar k2 int\nfor k2 = 0; k2 < 1000000; k2++ {\n\tm2[k2][1] = k2\n}\nvar l2 int\nfor l2 = 0; l2 < 1000000; l2++ {\n\tm2[l2][0] = l2\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "parentMap, countMap := make(map[int]int), make(map[int]int)\nfor _, num := range nums {\n\tif _, exists := parentMap[num]; exists {\n\t\tcontinue\n\t}\n\tparentMap[num], countMap[num] = num, 1\n\tneighbors := [2]int{num - 1, num + 1}\n\tfor _, n := range neighbors {\n\t\tif _, exists := parentMap[n]; exists {\n\t\t\tcount1 := countMap[getParent128(n, parentMap)]\n\t\t\tcount2 := countMap[getParent128(num, parentMap)]\n\t\t\tunion128(n, num, parentMap)\n\t\t\tcountMap[getParent128(num, parentMap)] = count1 + count2\n\t\t}\n\t}\n}\nmax := 0\nfor _, count := range countMap {\n\tif count > max {\n\t\tmax = count\n\t}\n}\nreturn max", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "sort.Ints(people)\nthin, fat := 0, len(people)-1\nres := 0\nfor thin <= fat {\n\tif people[thin]+people[fat] <= limit {\n\t\tthin++\n\t}\n\tfat--\n\tres++\n}\nreturn res", "gen": "var a []int\nsort.Ints(a)\n}\n\n<ASM>\n.LFB1:\ncmpq %fs:112,%rsp\njnb .L1\nmovl $56,%r10d\nmovl $24,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L1:\npushq %rbp\nmovq %rsp,%rbp\nsubq $48,%rsp\nmovq %rdi,-40(%rbp)\nmovq $0,-32(%rbp)\n.LBB10:\nsubq $8,%rsp\npushq <32>(%rbp)\npushq <24>(%rbp)\npushq <16>(%rbp)\ncall <sort.Ints@PLT>\naddq $32,%rsp\nmovq $0,-8(%rbp)\nmovq <24>(%rbp),%rax\nsubq $1,%rax\nmovq %rax,-16(%rbp)\nmovq $0,-24(%rbp)\n.LBB11:\n.LBB12:\njmp .L2\n.L10:\n.LBB13:\nnop\n.LBE13:\n.LBB14:\n.LBB15:\nmovq <24>(%rbp),%rax\ncmpq $0,-8(%rbp)\njs .L3\ncmpq %rax,-8(%rbp)\njl .L11\n.L3:\nmovq -8(%rbp),%rdx\nmovq %rax,%rsi\nmovq %rdx,%rdi\ncall <runtime.goPanicIndex@PLT>\n.L11:\nmovq <24>(%rbp),%rax\ncmpq $0,-16(%rbp)\njs .L5\ncmpq %rax,-16(%rbp)\njl .L12\n.L5:\nmovq -16(%rbp),%rdx\nmovq %rax,%r"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{1, 8, 6, 2, 5, 4, 8, 3, 7},\n\t\twant: 49,\n\t},\n\t{\n\t\tin:   []int{1, 8, 6, 30, 20, 6, 9, 10, 1},\n\t\twant: 48,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxArea(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "count, k := make([]int, 128), len(s)/4\nfor _, v := range s {\n\tcount[int(v)]++\n}\nleft, right, res := 0, -1, len(s)\nfor left < len(s) {\n\tif count['Q'] > k || count['W'] > k || count['E'] > k || count['R'] > k {\n\t\tif right+1 < len(s) {\n\t\t\tright++\n\t\t\tcount[s[right]]--\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t} else {\n\t\tres = min(res, right-left+1)\n\t\tcount[s[left]]++\n\t\tleft++\n\t}\n}\nreturn res", "gen": "var s string\nvar t string\nvar res int\ns = \"a\"\nt = \"a\"\nres = min(len(s), len(t))\nfmt.Println(res)\n}\n"}
{"tgt": "http.HandleFunc(\"STR\", handler)", "gen": "http.HandleFunc(\"/\", handler)\nhttp.ListenAndServe(\":8080\", nil)\n}\n"}
{"tgt": "pairs := [...][2]int{{15, 26}, {1000, 1366}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p16(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var p16 [2]int\np16[0] = 15\np16[1] = 26\nvar p1000 [2]int\np1000[0] = 1366\np1000[1] = 1000\nvar p1 [2]int\np1[0] = 15\np1[1] = 26\nvar p2 [2]int\np2[0] = 1366\np2[1] = 1000\nvar p3 [2]int\np3[0] = 15\np3[1] = 26\nvar p4 [2]int\np4[0] = 1366\np4[1] = 1000\nvar p5 [2]int\np5[0] = 15\np5[1] = 26\nvar p6 [2]int\np6[0] = 1366\np6[1] = 1000\nvar p7 [2]int\np7[0] = 15\np7[1] = 26\nvar p8 [2]int\np8[0] = 1366\np8[1] = 1000\nvar p9 [2]int\np9[0] = 15\np9[1] = 26\nvar p10 [2]int\np10[0] = 1366\np10[1] = 1000\nvar p11 [2]int\np11[0] = 15\np11[1] = 26\nvar p12 [2]int\np12[0] = 1366\np12[1] = 1000\nvar p13 [2]int\np13[0]"}
{"tgt": "n := len(matrix)\nl, r := matrix[0][0], matrix[n-1][n-1]\nfor l < r {\n\tm := (l + r) / 2\n\tcount := 0\n\tfor i := 0; i < n; i++ {\n\t\tj := n - 1\n\t\tfor j >= 0 && matrix[i][j] > m {\n\t\t\tj--\n\t\t}\n\t\tcount += j + 1\n\t}\n\tif count < k {\n\t\tl = m + 1\n\t} else {\n\t\tr = m\n\t}\n}\nreturn l", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + a[i]\n}\nfmt.Println(a[9])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tm: 3,\n\t\tn: 3,\n\t\tops: [][]int{\n\t\t\t{2, 2},\n\t\t\t{3, 3},\n\t\t},\n\t\twant: 4,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxCount(tt.m, tt.n, tt.ops)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.m, got, tt.want)\n\t}\n}", "gen": "fmt.Println(problem598.MaxCount([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif isPartite := IsBipartiteGraph(tc.g); isPartite != tc.isPartite {\n\t\tt.Errorf(\"STR\", tc.isPartite, isPartite)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "var i int\nlength := len(nums)\nif length <= 1 {\n\treturn\n}\nfor i = length - 1; i >= 1; i-- {\n\tif nums[i] > nums[i-1] {\n\t\tbreak\n\t}\n}\nif i > 0 {\n\tsort.Ints(nums[i:])\n\tfor j := i - 1; j < length; j++ {\n\t\tif nums[j] > nums[i-1] {\n\t\t\tnums[i-1], nums[j] = nums[j], nums[i-1]\n\t\t\treturn\n\t\t}\n\t}\n}\nsort.Ints(nums)", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar bb [10]int\nvar cc [10]int\nvar dd [10]int\nvar ee [10]int\nvar ff [10]int\nvar gg [10]int\nvar hh [10]int\nvar ii [10]int\nvar jj [10]int\nvar kk [10]int\nvar ll [10]int\nvar mm [10]int\nvar nn [10]int\nvar oo [10]int\nvar pp [10]int\nvar qq [10]int\nvar rr [10]int\nvar ss [10]int\nvar tt [10]int\nvar uu [10]int\nvar vv [10]int\nvar ww [10]int\nvar xx [10]int\nvar yy [10]int\nvar zz [10]int\nvar aaa [10]int\nvar bbb [10]"}
{"tgt": "return LoadUint64(&r.Reg)", "gen": "var x uint64\nx = 0\nfor i := 0; i < 1000000000; i++ {\n\tx += 1\n}\nprintln(x)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var tests = []struct {\n\tnumber int\n\ttitle  string\n}{\n\t{1, \"STR\"},\n\t{28, \"STR\"},\n\t{701, \"STR\"},\n}\nfor _, tt := range tests {\n\ttitle := convertToTitle(tt.number)\n\tif title != tt.title {\n\t\tt.Errorf(\"STR\", tt.number, title, tt.title)\n\t}\n}", "gen": "fmt.Println(convertToTitle(1))\nfmt.Println(convertToTitle(28))\nfmt.Println(convertToTitle(701))\nfmt.Println(convertToTitle(2147483647))\n}\n"}
{"tgt": "empty := countBucket{}\nfor i, _ := range ss.olist {\n\tdelete(ss.hash, ss.olist[i].key)\n\tss.olist[i] = empty\n}", "gen": "var m map[string]uint32\nm = make(map[string]uint32)\nm[\"a\"] = 1\nm[\"b\"] = 2\nm[\"c\"] = 3\nm[\"d\"] = 4\nm[\"e\"] = 5\nm[\"f\"] = 6\nm[\"g\"] = 7\nm[\"h\"] = 8\nm[\"i\"] = 9\nm[\"j\"] = 10\nm[\"k\"] = 11\nm[\"l\"] = 12\nm[\"m\"] = 13\nm[\"n\"] = 14\nm[\"o\"] = 15\nm[\"p\"] = 16\nm[\"q\"] = 17\nm[\"r\"] = 18\nm[\"s\"] = 19\nm[\"t\"] = 20\nm[\"u\"] = 21\nm[\"v\"] = 22\nm[\"w\"] = 23\nm[\"x\"] = 24\nm[\"y\"] = 25\nm[\"z\"] = 26\nfor k, v := range m {\n\tfmt.Printf(\"%s: %d\\n\", k, v)\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tresult := EloGames(tc.scores, tc.kFactor, tc.matches)\n\tfor i := range result {\n\t\tresult[i] = math.Round(result[i]*tc.tolerance) / tc.tolerance\n\t}\n\tif !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "l.insert(e, &l.root)", "gen": "fibHeap := NewFibHeap()\nfibHeap.Insert(10)\nfibHeap.Insert(20)\nfibHeap.Insert(30)\nfibHeap.Insert(40)\nfibHeap.Insert(50)\nfibHeap.Insert(60)\nfibHeap.Insert(70)\nfibHeap.Insert(80)\nfibHeap.Insert(90)\nfibHeap.Insert(100)\nfibHeap.Insert(110)\nfibHeap.Insert(120)\nfibHeap.Insert(130)\nfibHeap.Insert(140)\nfibHeap.Insert(150)\nfibHeap.Insert(160)\nfibHeap.Insert(170)\nfibHeap.Insert(180)\nfibHeap.Insert(190)\nfibHeap.Insert(200)\nfibHeap.Insert(210)\nfibHeap.Insert(220)\nfibHeap.Insert(230)\nfibHeap.Insert(240)\nfibHeap.Insert(250)\nfibHeap.Insert(260)\nfibHeap.Insert(270)\nfibHeap.Insert(280)\nfibHeap.Insert(290)\nfibHeap.Insert(300)\nfibHeap.Insert(310)\nfibHeap.Insert(320)\nfibHeap.Insert(330)\nfibHeap.Insert(340)\nfibHeap.Insert(350)\nfibHeap.Insert(360)\nfibHeap.Insert(370)\nfibHeap.Insert(380)\nf"}
{"tgt": "if root == nil {\n\treturn 0\n}\nmax := height(root.Left)\nif h := height(root.Right); h > max {\n\tmax = h\n}\nreturn max + 1", "gen": "fmt.Println(maxArea([]int{1, 8, 6, 2, 5, 4, 8, 3, 7}))\n}\n"}
{"tgt": "qs := []question598{\n\t{\n\t\tpara598{3, 3, [][]int{{2, 2}, {3, 3}}},\n\t\tans598{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans598, q.para598\n\tfmt.Printf(\"STR\", p, maxCount(p.m, p.n, p.ops))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "var tests = []struct {\n\tnums    []int\n\ttarget  int\n\tindices []int\n}{\n\t{[]int{2, 7, 11, 15}, 9, []int{0, 1}},\n\t{[]int{2, 3, 4, 6}, 6, []int{0, 2}},\n\t{[]int{2, 3, 4, 7}, 8, nil},\n\t{nil, 8, nil},\n}\nfor _, tt := range tests {\n\tindices := twoSum(tt.nums, tt.target)\n\tif reflect.DeepEqual(indices, tt.indices) == false {\n\t\tt.Errorf(\"STR\", tt.nums, tt.target, indices, tt.indices)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "if isSquare(n) {\n\treturn 1\n}\nfor n%4 == 0 {\n\tn /= 4\n}\nif n%8 == 7 {\n\treturn 4\n}\nfor i := 1; i <= mySqrt(n); i++ {\n\tif isSquare(n - i*i) {\n\t\treturn 2\n\t}\n}\nreturn 3", "gen": "fmt.Println(mySqrt(8))\n}\n"}
{"tgt": "if N < 3 {\n\treturn N\n} else if N == 3 {\n\treturn 5\n}\nmod := 1000000007\ndp := make([]int, N+1)\ndp[1], dp[2], dp[3] = 1, 2, 5\nfor i := 4; i <= N; i++ {\n\tdp[i] = 2*dp[i-1] + dp[i-3]\n\tdp[i] %= mod\n}\nreturn dp[N]", "gen": "var a [3]int\na[1] = 2\na[2] = 3\na[0] = 1\nfmt.Println(a[1])\nfmt.Println(a[2])\nfmt.Println(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "stack := []byte{}\nfor i := range num {\n\tdigit := num[i]\n\tfor k > 0 && len(stack) > 0 && digit < stack[len(stack)-1] {\n\t\tstack = stack[:len(stack)-1]\n\t\tk--\n\t}\n\tstack = append(stack, digit)\n}\nstack = stack[:len(stack)-k]\nans := strings.TrimLeft(string(stack), \"STR\")\nif ans == \"STR\" {\n\tans = \"STR\"\n}\nreturn ans", "gen": "var s []byte\nfor i := 0; i < 10; i++ {\n\tr, _ := utf8.DecodeRuneInString(\"a\")\n\ts = append(s, byte(r))\n}\nfmt.Println(string(s))\n}\n\n// Output:\n// aaaaaaaaaa\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n<ASM>\n.LFB0:\nleaq -264(%rsp),%r11\ncmpq %fs:112,%r11\njnb .L39\nmovl $264,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L39:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $216,%rsp\nmovq %rdi,%rcx\nmovq %rsi,%rax\nmovq %rax,%rbx\nmovq %rcx,-224(%rbp)\nmovq %rbx,-216(%rbp)\nmovq %rdx,-232(%rbp)\nmovq $0,-160(%rbp)\nmovq $0,-152(%rbp)\n.LBB2:\nleaq <type...60x.7uint8>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-136(%rbp)\nmovq -136(%rbp),%rax\nmovq %rax,-192(%rbp)\nmovq $0,-184(%rbp)\nmovq $0,-176(%rbp)\n.LBB3:\nleaq <type...60x.7uint8>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-128(%rbp"}
{"tgt": "if e.element.list != &b.freeList {\n\tpanic(\"STR\")\n}\nif !e.expire.IsZero() {\n\theap.Push(&b.priorityQueue, e)\n}\nb.freeList.Remove(&e.element)\nb.lruList.PushElementFront(&e.element)\nb.table[e.key] = e", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "in := make([]int, N)\nout := make([]int, N)\nfor _, pair := range trust {\n\tout[pair[0]-1]++\n\tin[pair[1]-1]++\n}\nfor i := 0; i < N; i++ {\n\tif in[i] == N-1 && out[i] == 0 {\n\t\treturn i + 1\n\t}\n}\nreturn -1", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs int\n\texpect int\n}{\n\t{\"STR\", 2, 1},\n\t{\"STR\", 3, 2},\n\t{\"STR\", 4, 3},\n\t{\"STR\", 0, 0},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "return xtime.Unix(int64(jt), 0), nil", "gen": "var t time.Time\nt = time.Unix(0, 0)\nfmt.Println(t)\n}\n\n```\n\n### \u6c47\u7f16\u4ee3\u7801\n\n```"}
{"tgt": "if len(name) == 0 && len(typed) == 0 {\n\treturn true\n}\nif (len(name) == 0 && len(typed) != 0) || (len(name) != 0 && len(typed) == 0) {\n\treturn false\n}\nj := 0\nfor i := 0; i < len(name); i++ {\n\tif j < len(typed) && name[i] == typed[j] {\n\t\tj++\n\t\tcontinue\n\t} else {\n\t\tif i > 0 && j < len(typed) && name[i-1] == typed[j] {\n\t\t\tj++\n\t\t\ti--\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "var a [10]byte\nvar b [10]byte\nvar c [10]byte\nvar d [10]byte\nvar e [10]byte\nvar f [10]byte\nvar g [10]byte\nvar h [10]byte\nvar i [10]byte\nvar j [10]byte\nvar k [10]byte\nvar l [10]byte\nvar m [10]byte\nvar n [10]byte\nvar o [10]byte\nvar p [10]byte\nvar q [10]byte\nvar r [10]byte\nvar s [10]byte\nvar t [10]byte\nvar u [10]byte\nvar v [10]byte\nvar w [10]byte\nvar x [10]byte\nvar y [10]byte\nvar z [10]byte\nvar aa [10]byte\nvar bb [10]byte\nvar cc [10]byte\nvar dd [10]byte\nvar ee [10]byte\nvar ff [10]byte\nvar gg [10]byte\nvar hh [10]byte\nvar ii [10]byte\nvar jj [10]byte\nvar kk [10]byte\nvar ll [10]byte\nvar mm [10]byte\nvar nn [10]byte\nvar oo [10]byte\nvar pp [10]byte\nvar qq [10]byte\nvar rr [10]byte\nvar ss [10]byte\nvar tt [10]byte\nvar uu [10]byte\nvar vv [10]byte\nvar ww [10]byte\nvar xx [10]byte\nvar yy [10]byte\nvar zz [10]byte\nvar aaa [10]byte\nvar bbb [10]"}
{"tgt": "var i, j, tmp int\nfor i = 1; i < len(arr); i++ {\n\ttmp = arr[i]\n\tfor j = i; j > 0 && arr[j-1] > tmp; j-- {\n\t\tarr[j] = arr[j-1]\n\t}\n\tarr[j] = tmp\n}\nreturn arr", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 4\nb[1] = 5\nb[2] = 6\nc[0] = 7\nc[1] = 8\nc[2] = 9\ncopy(a[:], b[:])\ncopy(b[:], c[:])\ncopy(c[:], a[:])\nfmt.Println(a[0], a[1], a[2])\nfmt.Println(b[0], b[1], b[2])\nfmt.Println(c[0], c[1], c[2])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "res = [][]string{}\nif len(s) < 1 {\n\treturn res\n}\nhelper(s, 0, []string{})\nreturn res", "gen": "var res string\nres = \"hello\"\nres += \"world\"\nfmt.Println(res)\n}\n"}
{"tgt": "if from == to {\n\treturn errors.New(\"STR\")\n}\nif !g.CheckVertex(from) || !g.CheckVertex(to) {\n\treturn errors.New(\"STR\")\n}\ni, _ := g.edges[from][to]\nj, _ := g.edges[to][from]\nif i > 0 || j > 0 {\n\treturn errors.New(\"STR\")\n}\ng.TouchVertex(from)\ng.TouchVertex(to)\ng.edges[from][to] = weight\nif !g.isDirected {\n\tg.edges[to][from] = weight\n}\ng.edgesCount++\nreturn nil", "gen": "g := graph.New()\ng.AddVertex(1)\ng.AddVertex(2)\ng.AddVertex(3)\ng.AddVertex(4)\ng.AddVertex(5)\ng.AddVertex(6)\ng.AddVertex(7)\ng.AddVertex(8)\ng.AddVertex(9)\ng.AddVertex(10)\ng.AddVertex(11)\ng.AddVertex(12)\ng.AddVertex(13)\ng.AddVertex(14)\ng.AddVertex(15)\ng.AddVertex(16)\ng.AddVertex(17)\ng.AddVertex(18)\ng.AddVertex(19)\ng.AddVertex(20)\ng.AddVertex(21)\ng.AddVertex(22)\ng.AddVertex(23)\ng.AddVertex(24)\ng.AddVertex(25)\ng.AddVertex(26)\ng.AddVertex(27)\ng.AddVertex(28)\ng.AddVertex(29)\ng.AddVertex(30)\ng.AddVertex(31)\ng.AddVertex(32)\ng.AddVertex(33)\ng.AddVertex(34)\ng.AddVertex(35)\ng.AddVertex(36)\ng.AddVertex(37)\ng.AddVertex(38)\ng.AddVertex(39)\ng.AddVertex(40)\ng.AddVertex(41)\ng.AddVertex(42)\ng.AddVertex(43)\ng.AddVertex(44)\ng.AddVertex(45)\ng.AddVertex(46)\ng.AddVertex(47)\ng.AddVertex(48)\ng.AddVertex(49)\ng.AddVertex(50)\n"}
{"tgt": "i := 0\ndefer fmt.Println(\"STR\", i)\ndefer fmt.Println(\"STR\")\ndefer fmt.Println(\"STR\")\ni++\nfmt.Println(\"STR\", i)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\n"}
{"tgt": "maxIndex := [26]int{}\nfor i, b := range S {\n\tmaxIndex[b-'a'] = i\n}\nbegin := 0\nend := maxIndex[S[begin]-'a']\nres := make([]int, 0, len(S))\nfor i, b := range S {\n\tif i < end {\n\t\tend = max(end, maxIndex[b-'a'])\n\t\tcontinue\n\t}\n\tres = append(res, i-begin+1)\n\tbegin = i + 1\n\tif begin < len(S) {\n\t\tend = maxIndex[S[begin]-'a']\n\t}\n}\nreturn res", "gen": "var s []byte\nvar i int\nfor i = 0; i < 26; i++ {\n\tr, _ := utf8.DecodeRuneInString(string(s[i]))\n\tif r > 127 {\n\t\tpanic(\"\")\n\t}\n}\nfor i = 0; i < 26; i++ {\n\tr, _ := utf8.DecodeRuneInString(string(s[i]))\n\tif r > 127 {\n\t\tpanic(\"\")\n\t}\n}\nfor i = 0; i < 26; i++ {\n\tr, _ := utf8.DecodeRuneInString(string(s[i]))\n\tif r > 127 {\n\t\tpanic(\"\")\n\t}\n}\nfor i = 0; i < 26; i++ {\n\tr, _ := utf8.DecodeRuneInString(string(s[i]))\n\tif r > 127 {\n\t\tpanic(\"\")\n\t}\n}\nfor i = 0; i < 26; i++ {\n\tr, _ := utf8.DecodeRuneInString(string(s[i]))\n\tif r > 127 {\n\t\tpanic(\"\")\n\t}\n}\nfor i = 0; i < 26; i++ {\n\tr, _ := utf8.DecodeRuneInString(string(s[i]))\n\tif r > 127 {\n\t\tpanic(\"\")\n\t}\n}\nfor i = 0; i < 26; i++ {\n\tr, _ := utf8.DecodeRuneInString(string(s[i]))\n\tif r > 127 {\n\t\tpanic(\"\")\n\t}\n}\nfor i = 0; i < 26; i++ {\n\tr, _ := utf8.De"}
{"tgt": "FirstNumber := 1\nSecondNumber := 2\nnextNumber := 0\nsum := SecondNumber\nfor nextNumber < 4000000 {\n\tnextNumber = FirstNumber + SecondNumber\n\tif nextNumber%2 == 0 {\n\t\tsum = sum + nextNumber\n\t}\n\tFirstNumber = SecondNumber\n\tSecondNumber = nextNumber\n}\nfmt.Println(\"STR\", sum, \"STR\")", "gen": "var a, b int\na = 1\nb = 2\nvar c int\nc = a + b\nvar d int\nd = c & 1\nif d == 0 {\n\td = c + 1\n}\nvar e int\ne = d\nvar f int\nf = e\nvar g int\ng = f\nvar h int\nh = g\nvar i int\ni = h\nvar j int\nj = i\nvar k int\nk = j\nvar l int\nl = k\nvar m int\nm = l\nvar n int\nn = m\nvar o int\no = n\nvar p int\np = o\nvar q int\nq = p\nvar r int\nr = q\nvar s int\ns = r\nvar t int\nt = s\nvar u int\nu = t\nvar v int\nv = u\nvar w int\nw = v\nvar x int\nx = w\nvar y int\ny = x\nvar z int\nz = y\nvar aa int\naa = z\nvar bb int\nbb = aa\nvar cc int\ncc = bb\nvar dd int\ndd = cc\nvar ee int\nee = dd\nvar ff int\nff = ee\nvar gg int\ngg = ff\nvar hh int\nhh = gg\nvar ii int\nii = hh\nvar jj int\njj = ii\nvar kk int\nkk = jj\nvar ll int\nll = kk\nvar mm int\nmm = ll\nvar nn int\nnn = mm\nvar oo int\noo = nn\nvar pp int\npp = oo\nvar qq int\nqq = pp\nvar rr int\nrr = qq\nvar ss int\nss = rr\nvar tt int\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{2},\n\t\t\t{3, 4},\n\t\t\t{6, 5, 7},\n\t\t\t{4, 1, 8, 3},\n\t\t},\n\t\t11},\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{1},\n\t\t\t{2, 3},\n\t\t},\n\t\t3},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := minimumTotal(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "timeDelta := now.Sub(r.lastTimestamp)\nreturn r.Ewma.Update(nanosec/float64(timeDelta.Nanoseconds()), now)", "gen": "var ewma ewma.Ewma\nvar start time.Time\nvar duration time.Duration\nvar elapsed time.Duration\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\n"}
{"tgt": "if list.head == nil {\n\treturn false\n}\nif list.head.data == i {\n\tlist.head = list.head.next\n\treturn true\n}\ncurrent := list.head\nfor current.next != nil {\n\tif current.next.data == i {\n\t\tcurrent.next = current.next.next\n\t\treturn true\n\t}\n\tcurrent = current.next\n}\nreturn false", "gen": "var a [10]int\nvar b [10]int\nvar c int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tc = 0\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}\n\tif a[i] == b[i] {\n\t\tc = 1\n\t}"}
{"tgt": "mySet := make(map[int]int, 0)\nfor _, v := range candies {\n\tmySet[v]++\n}\nif len(mySet) >= len(candies)/2 {\n\treturn len(candies) / 2\n}\nreturn len(mySet)", "gen": "m := make(map[int]int)\nfor i := 0; i < 100; i++ {\n\tm[i] = i + 1\n}\nfor i := 0; i < 100; i++ {\n\tif m[i] != i + 1 {\n\t\tpanic(\"bad\")\n\t}\n}\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname __morestack runtime.morestack"}
{"tgt": "a := []float64{1, 2, 3, 4, 5, 6}\nA := MakeMatrix(a, 3, 2)\nif A.cols != 2 ||\n\tA.rows != 3 ||\n\t!FloatArrayEquals(A.Elements, a) {\n\tt.Error()\n}", "gen": "var a = Matrix{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 9},\n}\nvar b = Matrix{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 9},\n}\nif !a.Equals(b) {\n\ttesting.T.Error(\"a should equal b\")\n}\n}\n"}
{"tgt": "count := 0\nfor _, c := range word {\n\tif unicode.IsUpper(c) {\n\t\tcount++\n\t}\n}\nreturn count == 0 || count == len(word) || (count == 1 && unicode.IsUpper(rune(word[0])))", "gen": "var s string\nvar i int\nvar b bool\nfor i, b = range s {\n\tif unicode.IsUpper(b) {\n\t\ti++\n\t}\n}\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname decoderune internal/bytealg.decoderune"}
{"tgt": "p.mu.Lock()\nactive := p.active\np.mu.Unlock()\nreturn active", "gen": "var m sync.Mutex\nvar x int\nm.Lock()\nx = 42\nm.Unlock()\nprintln(x)\n}\n\n<ASM>\nmovq %rdi,-24(%rbp)\nmovq $0,-8(%rbp)\n.LBB2:\ncmpq $0,-24(%rbp)\njne .L2\ncall <runtime.panicmem@PLT>\n.L2:\nmovq -24(%rbp),%rax\naddq $44,%rax\nmovq %rax,%rdi\ncall <sync.Mutex.Lock@PLT>\nmovq -24(%rbp),%rax\nmovq <72>(%rax),%rax\nmovq %rax,-16(%rbp)\ncmpq $0,-24(%rbp)\njne .L3\ncall <runtime.panicmem@PLT>\n.L3:\nmovq -24(%rbp),%rax\naddq $44,%rax\nmovq %rax,%rdi\ncall <sync.Mutex.Unlock@PLT>\n.LBB3:\nmovq -16(%rbp),%rax\nmovq %rax,-8(%rbp)\nmovq -8(%rbp),%rax\n.LBE3:\n.LBE2:\nleave\nret</ASM>"}
{"tgt": "select {\ncase r, ok := <-p.resources:\n\tlog.Println(\"STR\", \"STR\")\n\tif !ok {\n\t\treturn nil, ErrPoolClosed\n\t}\n\treturn r, nil\ndefault:\n\tlog.Println(\"STR\", \"STR\")\n\treturn p.factory()\n}", "gen": "var ch chan int\nvar x int\nselect {\ncase x = <-ch:\ndefault:\n}\nfmt.Println(x)\n}\n\n// func main() {\n// \tvar ch chan int\n// \tvar x int\n// \tselect {\n// \tcase x = <-ch:\n// \tdefault:\n// \t}\n// \tfmt.Println(x)\n// }\n\n// func main() {\n// \tvar ch chan int\n// \tvar x int\n// \tselect {\n// \tcase x = <-ch:\n// \tdefault:\n// \t}\n// \tfmt.Println(x)\n// }\n\n// func main() {\n// \tvar ch chan int\n// \tvar x int\n// \tselect {\n// \tcase x = <-ch:\n// \tdefault:\n// \t}\n// \tfmt.Println(x)\n// }\n\n// func main() {\n// \tvar ch chan int\n// \tvar x int\n// \tselect {\n// \tcase x = <-ch:\n// \tdefault:\n// \t}\n// \tfmt.Println(x)\n// }\n\n// func main() {\n// \tvar ch chan int\n// \tvar x int\n// \tselect {\n// \tcase x = <-ch:\n// \tdefault:\n// \t}\n// \tfmt.Println(x)\n// }\n\n// func main() {\n// \tvar ch chan int\n// \tvar x int\n// \tselect {\n// \tcase x = <-ch:\n// \tdefault:\n// \t}\n// \tfmt.Println(x)\n// }\n\n// func main() {\n// \tvar ch chan int\n// \tvar x int\n// \tselect {\n// \tcase x = <-ch:\n// \tdefault:\n// \t}\n// \tfmt.Println(x)\n// }\n\n// func main() {\n// \t"}
{"tgt": "err := ioutil.WriteFile(path, []byte(content), 0755)\nif err != nil {\n\tlog.Fatal(err)\n}", "gen": "var s string\nvar b []byte\nvar err error\ns = \"hello\"\nb = []byte(s)\nerr = ioutil.WriteFile(\"hello.txt\", b, 0644)\nif err != nil {\n\tlog.Fatal(err)\n}\n}\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3\u7801\n// \u6c47\u7f16\u4ee3"}
{"tgt": "tree := New(compare)\ntree.Insert(1)\ntree.Insert(2)\ntree.Insert(3)\nfindTree := tree.Search(2)\nif findTree.node != 2 {\n\tt.Error(\"STR\")\n}\nfindNilTree := tree.Search(100)\nif findNilTree != nil {\n\tt.Error(\"STR\")\n}", "gen": "var t testing.T\nvar bt *binaryTree.BinaryTree\nbt = binaryTree.New(binaryTree.Compare)\nbt.Insert(1)\nbt.Insert(2)\nbt.Insert(3)\nif bt.Search(1) != 1 {\n\tt.Error(\"1\")\n}\nif bt.Search(2) != 2 {\n\tt.Error(\"2\")\n}\nif bt.Search(3) != 3 {\n\tt.Error(\"3\")\n}\nif bt.Search(4) != nil {\n\tt.Error(\"4\")\n}\n}\n"}
{"tgt": "l := new(ListNode)\nn := l\nvar extra int\nfor l1 != nil || l2 != nil {\n\tn.Next = new(ListNode)\n\tn = n.Next\n\tif l1 != nil {\n\t\textra += l1.Val\n\t\tl1 = l1.Next\n\t}\n\tif l2 != nil {\n\t\textra += l2.Val\n\t\tl2 = l2.Next\n\t}\n\tn.Val = extra % 10\n\textra /= 10\n}\nif extra > 0 {\n\tn.Next = &ListNode{Val: extra}\n}\nreturn l.Next", "gen": "fmt.Println(addTwoNumbers(\n\t&go.leetcode.ListNode{Val: 2, Next: &go.leetcode.ListNode{Val: 4, Next: &go.leetcode.ListNode{Val: 3}}},\n\t&go.leetcode.ListNode{Val: 5, Next: &go.leetcode.ListNode{Val: 6, Next: &go.leetcode.ListNode{Val: 4}}},\n))\n}\n"}
{"tgt": "empty := 0\nhold := -1 << 63\nfor _, p := range prices {\n\ttemp := empty\n\tempty = max(empty, hold+p)\n\thold = max(hold, temp-p-fee)\n}\nreturn empty", "gen": "var a [10]int\nvar b [10]int\nvar c int\nvar d int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tif a[i] > b[i] {\n\t\tc = a[i]\n\t} else {\n\t\tc = b[i]\n\t}\n\tif c > d {\n\t\td = c\n\t}\n}\nfmt.Println(d)\n}\n"}
{"tgt": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"STR\", got, tt.want)\n\t\t}\n\t})\n}", "gen": "tests := []struct {\n\tname string\n\targs []string\n\twant int\n}{\n\t{\"test1\", []string{\"abcde\", \"cdefg\"}, 2},\n\t{\"test2\", []string{\"abcd\", \"cdab\"}, 4},\n\t{\"test3\", []string{\"abcde\", \"fghij\"}, 0},\n\t{\"test4\", []string{\"abcde\", \"abcde\"}, 4},\n\t{\"test5\", []string{\"abcde\", \"abcdefg\"}, 4},\n\t{\"test6\", []string{\"abcde\", \"abcdefgh\"}, 4},\n\t{\"test7\", []string{\"abcde\", \"abcdefghi\"}, 4},\n\t{\"test8\", []string{\"abcde\", \"abcdefghij\"}, 4},\n\t{\"test9\", []string{\"abcde\", \"abcdefghijk\"}, 4},\n\t{\"test10\", []string{\"abcde\", \"abcdefghijkl\"}, 4},\n\t{\"test11\", []string{\"abcde\", \"abcdefghijklm\"}, 4},\n\t{\"test12\", []string{\"abcde\", \"abcdefghijklmn\"}, 4},\n\t{\"test13\", []string{\"abcde\", \"abcdefghijklmno\"}, 4},\n\t{\"test14\", []string{\"abcde\", \"abcdefghijklmnop\"}, 4},\n\t{\"test15\", []string{\"abcde\", \"abcdefghijklmnopq\"}, 4},\n\t{\"test16\", []string{\"abcde\", \"abcdefghijklmnopqr\"}, 4},\n\t{\"test17\", []string{\"abcde\", \"abcdefghijklmnopqrs\"}, 4},\n\t{\"test18\", []string{\"abcde\", \"abcdefghijklmnopqrst\"}, 4},\n\t{\"test19\", []string{\"abcde\", \"abcdefghijklmnopqrstu\"}, 4},\n\t{\"test20\", []string{\"abcde\", \"abc"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   5,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   10,\n\t\twant: 5,\n\t},\n\t{\n\t\tin:   0,\n\t\twant: 1,\n\t},\n}\nfor _, tt := range tests {\n\tgot := bitwiseComplement(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(bitwiseComplement(5))\nfmt.Println(bitwiseComplement(2))\nfmt.Println(bitwiseComplement(7))\nfmt.Println(bitwiseComplement(0))\nfmt.Println(bitwiseComplement(10))\nfmt.Println(bitwiseComplement(5))\nfmt.Println(bitwiseComplement(0))\nfmt.Println(bitwiseComplement(1))\n}\n"}
{"tgt": "syscall.Exit(code)", "gen": "for i := 0; i < 1000000000; i++ {\n\tfmt.Println(i)\n}\n}\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```"}
{"tgt": "if len(input) == 0 {\n\treturn true\n}\nif len(input)%2 != 0 {\n\treturn false\n}\nvar stack []byte\nfor i := 0; i < len(input); i++ {\n\tif input[i] == \"STR\" || input[i] == \"STR\" || input[i] == \"STR\" {\n\t\tstack = append(stack, input[i])\n\t} else {\n\t\tif len(stack) > 0 {\n\t\t\tpair := string(stack[len(stack)-1]) + string(input[i])\n\t\t\tstack = stack[:len(stack)-1]\n\t\t\tif pair != \"STR\" && pair != \"STR\" && pair != \"STR\" {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn len(stack) == 0", "gen": "var s []byte\nvar i int\nvar b bool\ns = []byte{'a', 'b', 'c'}\ni = 0\nb = true\nfor i < len(s) {\n\tif s[i] == 'a' {\n\t\tb = false\n\t\tbreak\n\t}\n\ti++\n}\nif b {\n\tprintln(\"ok\")\n} else {\n\tprintln(\"not ok\")\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 0},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 11},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 19},\n\t\tans1208{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s, p.t, p.maxCost))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{124123, 13425, 123, 65, 1, 54362, 134, 6543, 213}, 3},\n\t{\"STR\", []int{}, 0},\n\t{\"STR\", []int{4253626756, 3245876, 2345897, 23490}, 1},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "if len(sorted) == 0 {\n\treturn nil\n}\nmid := len(sorted) / 2\nroot := &BST{Value: sorted[mid]}\nroot.Left = SortedSliceToBST(sorted[:mid])\nroot.Right = SortedSliceToBST(sorted[mid+1:])\nreturn root", "gen": "var a []int\na = append(a, 1)\na = append(a, 2)\na = append(a, 3)\na = append(a, 4)\na = append(a, 5)\na = append(a, 6)\na = append(a, 7)\na = append(a, 8)\na = append(a, 9)\na = append(a, 10)\na = append(a, 11)\na = append(a, 12)\na = append(a, 13)\na = append(a, 14)\na = append(a, 15)\na = append(a, 16)\na = append(a, 17)\na = append(a, 18)\na = append(a, 19)\na = append(a, 20)\na = append(a, 21)\na = append(a, 22)\na = append(a, 23)\na = append(a, 24)\na = append(a, 25)\na = append(a, 26)\na = append(a, 27)\na = append(a, 28)\na = append(a, 29)\na = append(a, 30)\na = append(a, 31)\na = append(a, 32)\na = append(a, 33)\na = append(a, 34)\na = append(a, 35)\na = append(a, 36)\na = append(a, 37)\na = append(a, 38)\na = append(a, 39)\na = append(a, 40)\na = append(a, 41)\na = append(a, 42)"}
{"tgt": "negative := false\nif num < 0 {\n\tnegative = true\n\tnum = -num\n}\nbf := bytes.NewBufferString(\"STR\")\nfor num >= 7 {\n\tmod := num % 7\n\tnum /= 7\n\tbf.WriteByte(byte(mod) + 48)\n}\nbf.WriteByte(byte(num) + 48)\nif negative {\n\tbf.WriteByte('-')\n}\nbs := bf.Bytes()\nfor s, e := 0, len(bs)-1; s < e; s, e = s+1, e-1 {\n\tbs[s], bs[e] = bs[e], bs[s]\n}\nreturn string(bs)", "gen": "var s string\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\n"}
{"tgt": "s = strings.ToLower(s)\ni, j := 0, len(s)-1\nfor i < j {\n\tfor i < j && !isChar(s[i]) {\n\t\ti++\n\t}\n\tfor i < j && !isChar(s[j]) {\n\t\tj--\n\t}\n\tif s[i] != s[j] {\n\t\treturn false\n\t}\n\ti++\n\tj--\n}\nreturn true", "gen": "fmt.Println(isAnagram(\"anagram\", \"nagaram\"))\n}\n"}
{"tgt": "n := len(nums)\ntmp := make([]int, n)\ncopy(tmp, nums)\nfor i := 0; i < n; i++ {\n\tnums[(i+k)%n] = tmp[i]\n}", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad"}
{"tgt": "random := rand.New(rand.NewSource(time.Now().UnixNano()))\narray := make([]int, random.Intn(100-10)+10)\nfor i := range array {\n\tarray[i] = random.Intn(100)\n}\nSortArray(array)\nfor _, value := range array {\n\tresult := ExponentialSearch(array, value)\n\tif result == -1 {\n\t\tt.Fail()\n\t}\n}", "gen": "var t testing.T\nvar a []int\nvar b []int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t1 time.Time\nvar t2 time.Time\nvar t3 time.Time\nvar t4 time.Time\nvar t5 time.Time\nvar t6 time.Time\nvar t7 time.Time\nvar t8 time.Time\nvar t9 time.Time\nvar t10 time.Time\nvar t11 time.Time\nvar t12 time.Time\nvar t13 time.Time\nvar t14 time.Time\nvar t15 time.Time\nvar t16 time.Time\nvar t17 time.Time\nvar t18 time.Time\nvar t19 time.Time\nvar t20 time.Time\nvar t21 time.Time\nvar t22 time.Time\nvar t23 time.Time\nvar t24 time.Time\nvar t25 time.Time\nvar t26 time.Time\nvar t27 time.Time\nvar t28 time.Time\nvar t29 time.Time\nvar t30 time.Time\nvar t31 time.Time\nvar t32 time.Time\nvar t33 time.Time\nvar t34 time.Time\nvar t35 time.Time\nvar t36 time.Time\nvar t37 time.Time\nvar t38 time.Time\nvar t39 time.Time\nvar t40 time.Time\nvar t41 time.Time\nvar t42 time.Time\nvar t43 time.Time\nvar t44 time.Time\nvar t45 time.Time\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimumPartitionPalindrome(tc.input); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "fmt.Println(\"Day 181\")\nfmt.Println(\"Part 1\")\nfmt.Println(\"Part 2\")\n}\n"}
{"tgt": "obj := Constructor732()\nfmt.Printf(\"STR\", obj.Book(10, 20))\nfmt.Printf(\"STR\", obj.Book(50, 60))\nfmt.Printf(\"STR\", obj.Book(10, 40))\nfmt.Printf(\"STR\", obj.Book(5, 15))\nfmt.Printf(\"STR\", obj.Book(5, 10))\nfmt.Printf(\"STR\", obj.Book(25, 55))", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "if a == nil && b == nil {\n\treturn true\n}\nif len(a) != len(b) {\n\treturn false\n}\nfor i := range a {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nvar b [10]int\nvar c int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tif a[i] != b[i] {\n\t\tc = 0\n\t\tbreak\n\t}\n\tc = 1\n}\nif c == 0 {\n\tprintln(\"a != b\")\n} else {\n\tprintln(\"a == b\")\n}\n}\n\n// func main() {\n// \tvar a [10]int\n// \tvar b [10]int\n// \tvar c int\n// \tfor i := 0; i < 10; i++ {\n// \t\ta[i] = i\n// \t\tb[i] = i\n// \t}\n// \tfor i := 0; i < 10; i++ {\n// \t\tif a[i] != b[i] {\n// \t\t\tc = 0\n// \t\t\tbreak\n// \t\t}\n// \t\tc = 1\n// \t}\n// \tif c == 0 {\n// \t\tprintln(\"a != b\")\n// \t} else {\n// \t\tprintln(\"a == b\")\n// \t}\n// }\n\n// func main() {\n// \tvar a [10]int\n// \tvar b [10]int\n// \tvar c int\n// \tfor i := 0; i < 10; i++ {\n// \t\ta[i] = i\n// \t\tb[i] = i\n// \t}\n// \tfor i := 0; i < 10; i++ {\n// \t\tif a[i] != b[i] {\n// \t\t\tc = 0\n// \t\t\tbreak\n// \t\t}\n// \t\t"}
{"tgt": "val := \"STR\"\nfor i := 1; i < n; i++ {\n\tvar (\n\t\tc   int\n\t\tv   byte\n\t\tstr string\n\t)\n\tfor j := 0; j < len(val); j++ {\n\t\tif val[j] == v {\n\t\t\tc++\n\t\t\tcontinue\n\t\t}\n\t\tif c != 0 {\n\t\t\tstr += string(c+'0') + string(v)\n\t\t}\n\t\tc, v = 1, val[j]\n\t}\n\tval = str + string(c+'0') + string(v)\n}\nreturn val", "gen": "var a [10]byte\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = byte(i)\n}\nvar s string\nfor i = 0; i < 10; i++ {\n\ts += fmt.Sprintf(\"%d\", a[i])\n}\nfmt.Println(s)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "res := 0\nif n != 0 {\n\trightMostBitInt := n & -n\n\tnextHigherSetBitInt := n + rightMostBitInt\n\td := n ^ nextHigherSetBitInt\n\td /= rightMostBitInt\n\td >>= 2\n\tres = nextHigherSetBitInt | d\n}\nreturn res", "gen": "var a int64 = -1\nvar b int64 = 2\nvar c int64 = a / b\nfmt.Println(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(nums) == 0 || len(nums) < k {\n\treturn make([]int, 0)\n}\nqueue := make([]int, 0, k)\nans := make([]int, len(nums)-k+1)\nfor left, right := 1-k, 0; right < len(nums); left, right = left+1, right+1 {\n\tif left > 0 && queue[0] == nums[left-1] {\n\t\tqueue = queue[1:len(queue)]\n\t}\n\tfor len(queue) != 0 && queue[len(queue)-1] < nums[right] {\n\t\tqueue = queue[:len(queue)-1]\n\t}\n\tqueue = append(queue, nums[right])\n\tif left >= 0 {\n\t\tans[left] = queue[0]\n\t}\n}\nreturn ans", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{}\n} else if n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{intervals[0]}\nfor _, cur := range intervals[1:] {\n\tprevious := res[len(res)-1]\n\tif cur.Start <= previous.End {\n\t\tend := previous.End\n\t\tif cur.End > end {\n\t\t\tend = cur.End\n\t\t}\n\t\tres = append(res[:len(res)-1], Interval{Start: previous.Start, End: end})\n\t} else {\n\t\tres = append(res, cur)\n\t}\n}\nreturn res", "gen": "fmt.Println(merge([]Interval{{1, 3}, {2, 6}, {8, 10}, {15, 18}}))\n}\n"}
{"tgt": "max := 9999\nbiggestPandigital := 0\nvar numberMultiplied int\nfor i := max; i > 0; i-- {\n\tnumberMultiplied = i\n\tfor j := 1; len(digits(numberMultiplied)) <= 9; j++ {\n\t\tnumberMultiplied = concatenMultiplication(i, j)\n\t\tif IsPandigital(numberMultiplied) && numberMultiplied > biggestPandigital {\n\t\t\tfmt.Println(numberMultiplied)\n\t\t\tbiggestPandigital = numberMultiplied\n\t\t}\n\t}\n}", "gen": "var pandigital []int\nfor i := 1; i < 10000; i++ {\n\tif IsPandigital(i) {\n\t\tpandigital = append(pandigital, i)\n\t}\n}\nfor _, i := range pandigital {\n\tfor _, j := range pandigital {\n\t\tif i != j {\n\t\t\tif IsPandigital(i*j) {\n\t\t\t\tfmt.Println(i, \"*\", j, \"=\", i*j)\n\t\t\t}\n\t\t}\n\t}\n}\n}"}
{"tgt": "n := len(pushed)\ns := make([]int, 0, n)\ni := 0\nfor _, x := range pushed {\n\ts = append(s, x)\n\tfor len(s) != 0 && s[len(s)-1] == popped[i] {\n\t\ts = s[:len(s)-1]\n\t\ti++\n\t}\n}\nreturn i == n", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "testCases := [][]int{\n\t{1, 2, 3, 1},\n\t{1, 0, 1, 1},\n\t{1, 2, 3, 1, 2, 3},\n}\nks := []int{3, 1, 2}\nexpected := []bool{true, true, false}\nfor index, nums := range testCases {\n\tif res := containsNearbyDuplicate(nums, ks[index]); res != expected[index] {\n\t\tt.Errorf(\"STR\", expected[index], res)\n\t}\n}", "gen": "var a [4]int\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 1\na[4] = 1\na[5] = 2\na[6] = 3\na[7] = 1\na[8] = 2\na[9] = 3\na[10] = 1\na[11] = 2\na[12] = 3\na[13] = 1\na[14] = 2\na[15] = 3\na[16] = 1\na[17] = 2\na[18] = 3\na[19] = 1\na[20] = 2\na[21] = 3\na[22] = 1\na[23] = 2\na[24] = 3\na[25] = 1\na[26] = 2\na[27] = 3\na[28] = 1\na[29] = 2\na[30] = 3\na[31] = 1\na[32] = 2\na[33] = 3\na[34] = 1\na[35] = 2\na[36] = 3\na[37] = 1\na[38] = 2\na[39] = 3\na[40] = 1\na[41] = 2\na[42] = 3\na[43] = 1\na[44] = 2\na[45] = 3\na[46] = 1\na[47] = 2\na[48] = 3\na[49] = 1\na"}
{"tgt": "item := req.URL.Query().Get(\"STR\")\nif price, ok := db[item]; ok {\n\tfmt.Fprintf(w, \"STR\", price)\n} else {\n\tw.WriteHeader(http.StatusNotFound)\n\tfmt.Fprintf(w, \"STR\", item)\n}", "gen": "url := \"http://www.baidu.com\"\nresp, err := http.Get(url)\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer resp.Body.Close()\nbody, err := ioutil.ReadAll(resp.Body)\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Println(string(body))\n}\n```\n\n## \u53c2\u8003\n\n- [Go\u8bed\u8a00\u7684\u53cd\u6c47\u7f16](https://www.cnblogs.com/wangxin1988/p/10457759.html)\n- [Go\u8bed\u8a00\u7684\u53cd\u6c47\u7f16](https://www.cnblogs.com/wangxin1988/p/10457759.html)\n- [Go\u8bed\u8a00\u7684\u53cd\u6c47\u7f16](https://www.cnblogs.com/wangxin1988/p/10457759.html)\n- [Go\u8bed\u8a00\u7684\u53cd\u6c47\u7f16](https://www.cnblogs.com/wangxin1988/p/10457759.html)\n- [Go\u8bed\u8a00\u7684\u53cd\u6c47\u7f16](https://www.cnblogs.com/wangxin1988/p/10457759.html)\n- [Go\u8bed\u8a00\u7684\u53cd\u6c47\u7f16](https://www.cnblogs.com/wangxin1988/p/10457759.html)\n- [Go\u8bed\u8a00\u7684\u53cd\u6c47\u7f16](https://www.cnblogs.com/wangxin1988/p/10457759.html)\n- [Go\u8bed\u8a00\u7684\u53cd\u6c47\u7f16](https://www.cnblogs.com/wangxin1988/p/10457759.html)\n- [Go\u8bed\u8a00\u7684\u53cd\u6c47\u7f16](https://www.cnblogs.com/wangxin1988/"}
{"tgt": "l, r := &maxHeap{}, &minHeap{}\nheap.Init(l)\nheap.Init(r)\nreturn MedianFinder{l, r}", "gen": "fmt.Println(maxHeap.Len())\nfmt.Println(minHeap.Len())\nmaxHeap.Push(1)\nmaxHeap.Push(2)\nmaxHeap.Push(3)\nmaxHeap.Push(4)\nmaxHeap.Push(5)\nmaxHeap.Push(6)\nmaxHeap.Push(7)\nmaxHeap.Push(8)\nmaxHeap.Push(9)\nmaxHeap.Push(10)\nmaxHeap.Push(11)\nmaxHeap.Push(12)\nmaxHeap.Push(13)\nmaxHeap.Push(14)\nmaxHeap.Push(15)\nmaxHeap.Push(16)\nmaxHeap.Push(17)\nmaxHeap.Push(18)\nmaxHeap.Push(19)\nmaxHeap.Push(20)\nmaxHeap.Push(21)\nmaxHeap.Push(22)\nmaxHeap.Push(23)\nmaxHeap.Push(24)\nmaxHeap.Push(25)\nmaxHeap.Push(26)\nmaxHeap.Push(27)\nmaxHeap.Push(28)\nmaxHeap.Push(29)\nmaxHeap.Push(30)\nmaxHeap.Push(31)\nmaxHeap.Push(32)\nmaxHeap.Push(33)\nmaxHeap.Push(34)\nmaxHeap.Push(35)\nmaxHeap.Push(36)\nmaxHeap.Push(37)\nmaxHeap.Push(38)\nmaxHeap.Push(39)\nmaxHeap.Push(40)\nmaxHeap.Push(41)\nmaxHeap.Push(42)\nmaxHeap.Push(43)\nmaxHeap.Push(44)"}
{"tgt": "var buf [32]byte\ni := len(buf) - 1\nfor val >= 10 {\n\tbuf[i] = byte(val%10 + \"STR\")\n\ti--\n\tval /= 10\n}\nbuf[i] = byte(val + \"STR\")\nreturn string(buf[i:])", "gen": "var s []byte\ns = append(s, \"hello\"...)\nprintln(string(s))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(nums1) == 0 || len(nums2) == 0 {\n\treturn []int{}\n}\nnum1Map := make(map[int]bool)\nfor i := range nums1 {\n\tnum1Map[nums1[i]] = true\n}\nnum2Map := make(map[int]bool)\nvar res []int\nfor i := range nums2 {\n\tif _, ok1 := num1Map[nums2[i]]; ok1 && !num2Map[nums2[i]] {\n\t\tnum2Map[nums2[i]] = true\n\t\tres = append(res, nums2[i])\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "var ret [][]int\nvar nums []int\nnums = []int{-1, 0, 1, 2, -1, -4}\nret = [][]int{{-1, -1, 2}, {-1, 0, 1}}\nfor k, num := range threeSum(nums) {\n\tfor i, v := range num {\n\t\tif v != ret[k][i] {\n\t\t\tt.Fatalf(\"STR\", ret)\n\t\t}\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "dist := make([]int, N+1)\nfor i := 0; i < len(dist); i++ {\n\tdist[i] = math.MaxInt32\n}\ndist[K] = 0\nfor i := 0; i < N; i++ {\n\tfor _, t := range times {\n\t\tu, v, w := t[0], t[1], t[2]\n\t\tif dist[u] != math.MaxInt32 && dist[v] > dist[u]+w {\n\t\t\tdist[v] = dist[u] + w\n\t\t}\n\t}\n}\nmx := 0\nfor i := 1; i <= N; i++ {\n\tif mx < dist[i] {\n\t\tmx = dist[i]\n\t}\n}\nif mx == math.MaxInt32 {\n\treturn -1\n}\nreturn mx", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar bb [10]int\nvar cc [10]int\nvar dd [10]int\nvar ee [10]int\nvar ff [10]int\nvar gg [10]int\nvar hh [10]int\nvar ii [10]int\nvar jj [10]int\nvar kk [10]int\nvar ll [10]int\nvar mm [10]int\nvar nn [10]int\nvar oo [10]int\nvar pp [10]int\nvar qq [10]int\nvar rr [10]int\nvar ss [10]int\nvar tt [10]int\nvar uu [10]int\nvar vv [10]int\nvar ww [10]int\nvar xx [10]int\nvar yy [10]int\nvar zz [10]int\nvar aaa [10]int\nvar bbb [10]"}
{"tgt": "dat, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\nnamesList := string(dat)\nnamesList = strings.Replace(namesList, \"STR\", \"STR\", -1)\nnames := strings.Split(namesList, \"STR\")\nsort.Strings(names)\nnamesScore := 0\nfor index, name := range names {\n\tnamesScore += nameScore(name) * (index + 1)\n}\nfmt.Println(namesScore)", "gen": "var s string\nfmt.Scan(&s)\nvar a, b, c int\nfmt.Scan(&a, &b, &c)\nvar d, e, f int\nfmt.Scan(&d, &e, &f)\nvar g, h, i int\nfmt.Scan(&g, &h, &i)\nvar j, k, l int\nfmt.Scan(&j, &k, &l)\nvar m, n, o int\nfmt.Scan(&m, &n, &o)\nvar p, q, r int\nfmt.Scan(&p, &q, &r)\nvar s, t, u int\nfmt.Scan(&s, &t, &u)\nvar v, w, x int\nfmt.Scan(&v, &w, &x)\nvar y, z, aa int\nfmt.Scan(&y, &z, &aa)\nvar bb, cc, dd int\nfmt.Scan(&bb, &cc, &dd)\nvar ee, ff, gg int\nfmt.Scan(&ee, &ff, &gg)\nvar hh, ii, jj int\nfmt.Scan(&hh, &ii, &jj)\nvar kk, ll, mm int\nfmt.Scan(&kk, &ll, &mm)\nvar nn, oo, pp int\nfmt.Scan(&nn, &oo, &pp)\nvar qq, rr, ss int\nfmt.Scan(&qq, &rr, &ss)\nvar tt, uu, vv int\nfmt.Scan(&tt, &uu, &vv)\nvar ww, xx, yy int\nfmt.Scan(&ww, &xx, &yy)\nvar zz, aa, bb int\nfmt.Scan(&zz, &aa, &bb)\nvar cc, dd, ee int\nfmt.Scan(&cc, &dd, &ee)\nvar ff, gg, hh int\nfmt.Scan(&ff, &gg, &hh)\nvar ii, jj,"}
{"tgt": "var matrix [][]int\nmatrix = [][]int{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 9},\n}\nrotate(matrix)", "gen": "rotate([]int{1, 2, 3, 4, 5, 6, 7}, 3)\n}\n"}
{"tgt": "curr := n\nfor _, c := range s {\n\tnext, ok := curr.children[c]\n\tif !ok {\n\t\tnext = NewNode()\n\t\tcurr.children[c] = next\n\t}\n\tcurr = next\n}\ncurr.isLeaf = true", "gen": "var m map[int32]Node\nvar i int32\nfor i = 0; i < 100; i++ {\n\tm[i] = NewNode()\n}\nm[100] = NewNode()\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "sum := 0\nfor i := 2; i < 999999; i++ {\n\tif isSumOfFivePowerOfDigitsEqualToNumber(i) {\n\t\tsum += i\n\t}\n}\nreturn sum", "gen": "var sum int64\nfor i := int64(0); i < 999999; i++ {\n\tif isSumOfFivePowerOfDigitsEqualToNumber(i) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}\n"}
{"tgt": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nret := &ListNode{}\nif l1.Val <= l2.Val {\n\tret = l1\n\tret.Next = mergeTwoLists1(l1.Next, l2)\n} else {\n\tret = l2\n\tret.Next = mergeTwoLists1(l1, l2.Next)\n}\nreturn ret", "gen": "fmt.Println(mergeTwoLists(nil, nil))\nfmt.Println(mergeTwoLists(nil, &ListNode{Val: 1}))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1}, nil))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1}, &ListNode{Val: 2}))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1, Next: &ListNode{Val: 2}}, &ListNode{Val: 1, Next: &ListNode{Val: 3}}))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}, &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}, &ListNode{Val: 1, Next: &ListNode{Val: 3}}))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}, &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: &ListNode{Val: 5}}}}))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}, &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: &ListNode{Val: 5, Next: &ListNode{Val: 6}}}}}))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &List"}
{"tgt": "a := int(math.Log10(float64(number))) + 1\nresult := 0\nfor i := 1; i <= a; i++ {\n\tresult += digit(number, i) * int(math.Pow10(a-i))\n}\nreturn result", "gen": "var n int64\nfmt.Scan(&n)\nfmt.Println(digit(n))\n}"}
{"tgt": "maxans := 0\ndp := make([]int, len(s))\nfor i := 1; i < len(s); i++ {\n\tif s[i] == \"STR\" {\n\t\tif s[i-1] == \"STR\" {\n\t\t\tif i >= 2 {\n\t\t\t\tdp[i] = dp[i-2] + 2\n\t\t\t} else {\n\t\t\t\tdp[i] = 2\n\t\t\t}\n\t\t} else if i-dp[i-1] > 0 && s[i-dp[i-1]-1] == \"STR\" {\n\t\t\tif i-dp[i-1] >= 2 {\n\t\t\t\tdp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2\n\t\t\t} else {\n\t\t\t\tdp[i] = dp[i-1] + 2\n\t\t\t}\n\t\t}\n\t}\n\tmaxans = Max(maxans, dp[i])\n}\nreturn maxans", "gen": "var s string\nvar t string\nvar res int\nfmt.Scan(&s)\nfmt.Scan(&t)\nres = Solution(s, t)\nfmt.Println(res)\n}\n"}
{"tgt": "s.lock.Lock()\ndefer s.lock.Unlock()\nl := len(s.nodes)\nif l == 0 {\n\treturn nil, errors.New(\"STR\")\n}\nnode := s.nodes[l-1]\ns.nodes = s.nodes[:l-1]\nreturn node, nil", "gen": "var s Solution\ns.Solution()\n}\n"}
{"tgt": "max1, max2, max3, min1, min2 := -1001, -1001, -1001, 1001, 1001\nfor _, v := range nums {\n\tif v > max1 {\n\t\tmax3 = max2\n\t\tmax2 = max1\n\t\tmax1 = v\n\t} else if v > max2 {\n\t\tmax3 = max2\n\t\tmax2 = v\n\t} else if v > max3 {\n\t\tmax3 = v\n\t}\n\tif v < min1 {\n\t\tmin2 = min1\n\t\tmin1 = v\n\t} else if v < min2 {\n\t\tmin2 = v\n\t}\n}\nreturn max(max1*min1*min2, max1*max2*max3)", "gen": "var a, b, c int\nfmt.Scan(&a, &b, &c)\nfmt.Println(max(a, b, c))\n}\n"}
{"tgt": "h := fnv.New64a()\n_, _ = h.Write([]byte(fmt.Sprintf(\"STR\", key)))\nhashValue := h.Sum64()\nreturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))", "gen": "var a, b int\nfmt.Scan(&a, &b)\nfmt.Println(a + b)\n}\n"}
{"tgt": "arr := make([]int, n+1, n+1)\narr[0] = 0\narr[1] = 1\nfor x := 2; x <= n; x++ {\n\tarr[x] = -1\n}\nreturn fibonacciDyamic(n, arr)", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\ta = append(a, i)\n}\nfmt.Println(a)\n}\n"}
{"tgt": "*ss = Count{\n\tolist: make([]countBucket, size),\n\thash:  make(map[string]uint32, size),\n}\nreturn ss", "gen": "var m map[string]uint32\nvar s []uint32\nm = make(map[string]uint32)\ns = make([]uint32, 100)\nfor i := 0; i < 100; i++ {\n\ts[i] = uint32(i)\n}\nm[\"a\"] = 1\nm[\"b\"] = 2\nm[\"c\"] = 3\nm[\"d\"] = 4\nm[\"e\"] = 5\nm[\"f\"] = 6\nm[\"g\"] = 7\nm[\"h\"] = 8\nm[\"i\"] = 9\nm[\"j\"] = 10\nm[\"k\"] = 11\nm[\"l\"] = 12\nm[\"m\"] = 13\nm[\"n\"] = 14\nm[\"o\"] = 15\nm[\"p\"] = 16\nm[\"q\"] = 17\nm[\"r\"] = 18\nm[\"s\"] = 19\nm[\"t\"] = 20\nm[\"u\"] = 21\nm[\"v\"] = 22\nm[\"w\"] = 23\nm[\"x\"] = 24\nm[\"y\"] = 25\nm[\"z\"] = 26\nm[\"aa\"] = 27\nm[\"bb\"] = 28\nm[\"cc\"] = 29\nm[\"dd\"] = 30\nm[\"ee\"] = 31\nm[\"ff\"] = 32\nm[\"gg\"] = 33\nm[\"hh\"] = 34\nm[\"ii\"] = 35\nm[\"jj\"] = 36\nm[\"kk\"] = 37\nm[\"ll\"] = 38\nm[\"mm\"] = 39\nm[\"nn\"] = 40\nm[\"oo\"] = 41\nm[\"pp\"] = 42\nm[\"qq"}
{"tgt": "if len(nums) == 0 {\n\treturn 0\n} else if len(nums) == 1 {\n\treturn nums[0]\n}\nmax := func(m, n int) int {\n\tif m > n {\n\t\treturn m\n\t}\n\treturn n\n}\ndp := []int{nums[0], max(nums[0], nums[1])}\nfor i := 2; i < len(nums); i++ {\n\tdp[i%2] = max(dp[(i-1)%2], nums[i]+dp[i%2])\n}\nreturn dp[(len(nums)-1)%2]", "gen": "fmt.Println(rob([]int{2, 3, 2}))\nfmt.Println(rob([]int{1, 2, 3, 1}))\nfmt.Println(rob([]int{2, 7, 9, 3, 1}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{1, 2, 3, 1}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{1, 2, 3, 1}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, 1, 2}))\nfmt.Println(rob([]int{2, 1, "}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CanHopToEnd(tc.hops); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.hops, tc.expected, result)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "n := NewNode()\ninsertWords := [...]string{\n\t\"STR\",\n\t\"STR\",\n}\ncheckWords := map[string]bool{\n\t\"STR\": false,\n\t\"STR\": false,\n\t\"STR\": true,\n}\nfor _, w := range insertWords {\n\tn.Insert(w)\n\tt.Logf(\n\t\t\"STR\",\n\t\tw,\n\t)\n}\nfor k, v := range checkWords {\n\tok := n.Find(k)\n\tif ok != v {\n\t\tt.Fatalf(\n\t\t\t\"STR\",\n\t\t\tk,\n\t\t\tmap[bool]string{true: \"STR\"}[v],\n\t\t)\n\t}\n\tt.Logf(\n\t\t\"STR\",\n\t\tk,\n\t\tmap[bool]string{true: \"STR\"}[ok],\n\t)\n}", "gen": "trie := NewNode()\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\","}
{"tgt": "if cl.Size > 0 {\n\tif places < 0 {\n\t\tmultiple := cl.Size - 1 - places/cl.Size\n\t\tplaces += multiple * cl.Size\n\t}\n\tplaces %= cl.Size\n\tif places > cl.Size/2 {\n\t\tplaces = cl.Size - places\n\t\tfor i := 0; i < places; i++ {\n\t\t\tcl.Head = cl.Head.Prev\n\t\t}\n\t} else if places == 0 {\n\t\treturn\n\t} else {\n\t\tfor i := 0; i < places; i++ {\n\t\t\tcl.Head = cl.Head.Next\n\t\t}\n\t}\n}", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "s.lock.Lock()\ndefer s.lock.Unlock()\nreturn s.len", "gen": "var m sync.Mutex\nvar x int\ndefer func() {\n\tm.Lock()\n\tx = 0\n\tdefer func() {\n\t\tm.Lock()\n\t\tx = 0\n\t\tdefer func() {\n\t\t\tm.Lock()\n\t\t\tx = 0\n\t\t\tdefer func() {\n\t\t\t\tm.Lock()\n\t\t\t\tx = 0\n\t\t\t\tdefer func() {\n\t\t\t\t\tm.Lock()\n\t\t\t\t\tx = 0\n\t\t\t\t\tdefer func() {\n\t\t\t\t\t\tm.Lock()\n\t\t\t\t\t\tx = 0\n\t\t\t\t\t\tdefer func() {\n\t\t\t\t\t\t\tm.Lock()\n\t\t\t\t\t\t\tx = 0\n\t\t\t\t\t\t\tdefer func() {\n\t\t\t\t\t\t\t\tm.Lock()\n\t\t\t\t\t\t\t\tx = 0\n\t\t\t\t\t\t\t\tdefer func() {\n\t\t\t\t\t\t\t\t\tm.Lock()\n\t\t\t\t\t\t\t\t\tx = 0\n\t\t\t\t\t\t\t\t\tdefer func() {\n\t\t\t\t\t\t\t\t\t\tm.Lock()\n\t\t\t\t\t\t\t\t\t\tx = 0\n\t\t\t\t\t\t\t\t\t\tdefer func() {\n\t\t\t\t\t\t\t\t\t\t\tm.Lock()\n\t\t\t\t\t\t\t\t\t\t\tx = 0\n\t\t\t\t\t\t\t\t\t\t\tdefer func() {\n\t\t\t\t\t\t\t\t\t\t\t\tm.Lock()\n\t\t\t\t\t\t\t\t\t\t\t\tx = 0\n\t\t\t\t\t\t\t\t\t\t\t\tdefer func() {\n\t\t\t\t\t\t\t\t\t\t\t\t\tm.Lock"}
{"tgt": "return fmt.Sprintf(\"STR\", p.Name, p.Age)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\n"}
{"tgt": "if n < 2 {\n\treturn 1\n}\nrec := make([]int, n+1)\nrec[0], rec[1] = 1, 1\nfor i := 2; i <= n; i++ {\n\trec[i] = rec[i-1] + rec[i-2]\n}\nreturn rec[n]", "gen": "var a [10]int\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 4\na[4] = 5\na[5] = 6\na[6] = 7\na[7] = 8\na[8] = 9\na[9] = 10\nfor i := 0; i < len(a); i++ {\n\ta[i] = a[i] + 1\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\ntmp := nums[0]\nmax := tmp\nfor i := 1; i < n; i++ {\n\tif tmp < 0 {\n\t\ttmp = nums[i]\n\t} else {\n\t\ttmp += nums[i]\n\t}\n\tif max < tmp {\n\t\tmax = tmp\n\t}\n}\nreturn max", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] += i\n}\nprintln(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return syscall.Getgid()", "gen": "var a int\na = 1\na = 2\na = 3\na = 4\na = 5\na = 6\na = 7\na = 8\na = 9\na = 10\na = 11\na = 12\na = 13\na = 14\na = 15\na = 16\na = 17\na = 18\na = 19\na = 20\na = 21\na = 22\na = 23\na = 24\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tarr1   []int\n\tarr2   []int\n\td      int\n\texpect int\n}{\n\t{\"STR\", []int{4, 5, 8}, []int{10, 9, 1, 8}, 2, 2},\n\t{\"STR\", []int{1, 4, 2, 3}, []int{-4, -3, 6, 10, 20, 30}, 3, 2},\n\t{\"STR\", []int{2, 1, 100, 3}, []int{-5, -2, 10, -3, 7}, 6, 1},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.arr1, c.arr2, c.d)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.arr1, c.arr2, c.d)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "if h.Count != 0 {\n\tfor i := 0; i < int(h.Cap); i++ {\n\t\thashValue := h.hash(key, uint32(i))\n\t\tif h.backets[hashValue] != nil && h.backets[hashValue].Key == key {\n\t\t\treturn h.backets[hashValue].Value, h.backets[hashValue].exist\n\t\t}\n\t}\n}\nreturn nil, false", "gen": "var m map[string]int\nm = make(map[string]int)\nm[\"a\"] = 1\nm[\"b\"] = 2\nm[\"c\"] = 3\nm[\"d\"] = 4\nm[\"e\"] = 5\nm[\"f\"] = 6\nm[\"g\"] = 7\nm[\"h\"] = 8\nm[\"i\"] = 9\nm[\"j\"] = 10\nm[\"k\"] = 11\nm[\"l\"] = 12\nm[\"m\"] = 13\nm[\"n\"] = 14\nm[\"o\"] = 15\nm[\"p\"] = 16\nm[\"q\"] = 17\nm[\"r\"] = 18\nm[\"s\"] = 19\nm[\"t\"] = 20\nm[\"u\"] = 21\nm[\"v\"] = 22\nm[\"w\"] = 23\nm[\"x\"] = 24\nm[\"y\"] = 25\nm[\"z\"] = 26\nm[\"aa\"] = 27\nm[\"bb\"] = 28\nm[\"cc\"] = 29\nm[\"dd\"] = 30\nm[\"ee\"] = 31\nm[\"ff\"] = 32\nm[\"gg\"] = 33\nm[\"hh\"] = 34\nm[\"ii\"] = 35\nm[\"jj\"] = 36\nm[\"kk\"] = 37\nm[\"ll\"] = 38\nm[\"mm\"] = 39\nm[\"nn\"] = 40\nm[\"oo\"] = 41\nm[\"pp\"] = 42\nm[\"qq\"] = 43\nm[\"rr\"] = 44\nm[\"ss\"] = 45\nm[\"tt\"] = 46\nm[\"uu\"] = 47\nm[\"vv\"] = 48\nm[\"ww\"]"}
{"tgt": "l1 := len(board)\nif l1 == 0 {\n\treturn\n}\nl2 := len(board[0])\nif l2 == 0 {\n\treturn\n}\nvisit := make([][]bool, l1)\nfor i := 0; i < l1; i++ {\n\tvisit[i] = make([]bool, l2)\n}\nfor i := 0; i < l1; i++ {\n\tfor j := 0; j < l2; j++ {\n\t\tif !visit[i][j] {\n\t\t\thelper(board, visit, i, j)\n\t\t}\n\t}\n}", "gen": "var a [3]bool\nvar b [3]bool\nvar c [3]bool\nvar d [3]bool\nvar e [3]bool\nvar f [3]bool\nvar g [3]bool\nvar h [3]bool\nvar i [3]bool\nvar j [3]bool\nvar k [3]bool\nvar l [3]bool\nvar m [3]bool\nvar n [3]bool\nvar o [3]bool\nvar p [3]bool\nvar q [3]bool\nvar r [3]bool\nvar s [3]bool\nvar t [3]bool\nvar u [3]bool\nvar v [3]bool\nvar w [3]bool\nvar x [3]bool\nvar y [3]bool\nvar z [3]bool\nvar aa [3]bool\nvar ab [3]bool\nvar ac [3]bool\nvar ad [3]bool\nvar ae [3]bool\nvar af [3]bool\nvar ag [3]bool\nvar ah [3]bool\nvar ai [3]bool\nvar aj [3]bool\nvar ak [3]bool\nvar al [3]bool\nvar am [3]bool\nvar an [3]bool\nvar ao [3]bool\nvar ap [3]bool\nvar aq [3]bool\nvar ar [3]bool\nvar as [3]bool\nvar at [3]bool\nvar au [3]bool\nvar av [3]bool\nvar aw [3]bool\nvar ax [3]bool\nvar ay [3]bool\nvar az [3]bool\nvar ba [3]bool\nvar bb [3]bool\nvar bc [3]bool\nvar bd [3]bool\nvar be [3]bool\nvar bf [3]bool\nvar bg [3]bool\nvar bh [3]bool\nvar bi [3]bool\nvar bj ["}
{"tgt": "return me[0] == \"STR\"", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nif a[0] != 1 {\n\tpanic(\"a[0] != 1\")\n}\nif a[1] != 2 {\n\tpanic(\"a[1] != 2\")\n}\nif a[2] != 3 {\n\tpanic(\"a[2] != 3\")\n}\nif a[3] != 0 {\n\tpanic(\"a[3] != 0\")\n}\nif a[4] != 0 {\n\tpanic(\"a[4] != 0\")\n}\nif a[5] != 0 {\n\tpanic(\"a[5] != 0\")\n}\nif a[6] != 0 {\n\tpanic(\"a[6] != 0\")\n}\nif a[7] != 0 {\n\tpanic(\"a[7] != 0\")\n}\nif a[8] != 0 {\n\tpanic(\"a[8] != 0\")\n}\nif a[9] != 0 {\n\tpanic(\"a[9] != 0\")\n}\nif a[10] != 0 {\n\tpanic(\"a[10] != 0\")\n}\nif a[11] != 0 {\n\tpanic(\"a[11] != 0\")\n}\nif a[12] != 0 {\n\tpanic(\"a[12] != 0\")\n}\nif a[13] != 0 {\n\tpanic(\"a[13] != 0\")\n}\nif a[14] != 0 {\n\tpanic(\"a[14] != 0\")\n}\nif a[15] != 0 {\n\tpanic(\"a[15] != 0\")\n}\nif a[1"}
{"tgt": "if len(intervals) <= 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i][0] <= intervals[j][0]\n})\nresult := make([][]int, 0)\ncur := intervals[0]\nfor i := 1; i < len(intervals); i++ {\n\tif intervals[i][0] > cur[1] {\n\t\tresult = append(result, cur)\n\t\tcur = intervals[i]\n\t} else {\n\t\tcur[1] = int(math.Max(float64(cur[1]), float64(intervals[i][1])))\n\t}\n}\nresult = append(result, cur)\nreturn result", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "return Frame{}, false", "gen": "var a [4]int\nvar b [4]int\nvar c [4]int\nvar d [4]int\nvar e [4]int\nvar f [4]int\nvar g [4]int\nvar h [4]int\nvar i [4]int\nvar j [4]int\nvar k [4]int\nvar l [4]int\nvar m [4]int\nvar n [4]int\nvar o [4]int\nvar p [4]int\nvar q [4]int\nvar r [4]int\nvar s [4]int\nvar t [4]int\nvar u [4]int\nvar v [4]int\nvar w [4]int\nvar x [4]int\nvar y [4]int\nvar z [4]int\nvar aa [4]int\nvar ab [4]int\nvar ac [4]int\nvar ad [4]int\nvar ae [4]int\nvar af [4]int\nvar ag [4]int\nvar ah [4]int\nvar ai [4]int\nvar aj [4]int\nvar ak [4]int\nvar al [4]int\nvar am [4]int\nvar an [4]int\nvar ao [4]int\nvar ap [4]int\nvar aq [4]int\nvar ar [4]int\nvar as [4]int\nvar at [4]int\nvar au [4]int\nvar av [4]int\nvar aw [4]int\nvar ax [4]int\nvar ay [4]int\nvar az [4]int\nvar aaa [4]int\nvar aab [4]int\nvar aac [4]int\nvar aad [4]int\nvar aae [4]int\nvar aaf [4]int\nvar aag [4]int\nvar aah [4]int\nvar aai [4]int\n"}
{"tgt": "dist := [200][][]int{}\nfor r := 0; r < R; r++ {\n\tfor c := 0; c < C; c++ {\n\t\td := abs(r-r0) + abs(c-c0)\n\t\tdist[d] = append(dist[d], []int{r, c})\n\t}\n}\nbegin, end := 0, 0\nfor d := 0; len(dist[d]) > 0; d++ {\n\tbegin, end = end, end+len(dist[d])\n\tcopy(res[begin:end], dist[d])\n}\nreturn res[:end]", "gen": "var a, b, c int\nfmt.Scan(&a, &b, &c)\nres := problem1030(a, b, c)\nfmt.Println(res)\n}\n"}
{"tgt": "n, err := io.Copy(h, r)\nif err != nil {\n\treturn err\n}\nif n != fSize {\n\treturn errReadSizeMismatch\n}\nreturn nil", "gen": "var r io.ReadSeeker\nvar w io.Writer\nvar err error\nvar n int64\nvar n2 int64\nvar n3 int64\nvar n4 int64\nvar n5 int64\nvar n6 int64\nvar n7 int64\nvar n8 int64\nvar n9 int64\nvar n10 int64\nvar n11 int64\nvar n12 int64\nvar n13 int64\nvar n14 int64\nvar n15 int64\nvar n16 int64\nvar n17 int64\nvar n18 int64\nvar n19 int64\nvar n20 int64\nvar n21 int64\nvar n22 int64\nvar n23 int64\nvar n24 int64\nvar n25 int64\nvar n26 int64\nvar n27 int64\nvar n28 int64\nvar n29 int64\nvar n30 int64\nvar n31 int64\nvar n32 int64\nvar n33 int64\nvar n34 int64\nvar n35 int64\nvar n36 int64\nvar n37 int64\nvar n38 int64\nvar n39 int64\nvar n40 int64\nvar n41 int64\nvar n42 int64\nvar n43 int64\nvar n44 int64\nvar n45 int64\nvar n46 int64\nvar n47 int64\nvar n48 int64\nvar n49 int64\nvar n50 int64\nvar n51 int64\nvar n52 int64\nvar n53 int64\nvar n54 int64\nvar"}
{"tgt": "if max.Sign() <= 0 {\n\tpanic(\"STR\")\n}\nn = new(big.Int)\nn.Sub(max, n.SetUint64(1))\nbitLen := n.BitLen()\nif bitLen == 0 {\n\treturn\n}\nk := (bitLen + 7) / 8\nb := uint(bitLen % 8)\nif b == 0 {\n\tb = 8\n}\nbytes := make([]byte, k)\nfor {\n\t_, err = io.ReadFull(rand, bytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbytes[0] &= uint8(int(1<<b) - 1)\n\tn.SetBytes(bytes)\n\tif n.Cmp(max) < 0 {\n\t\treturn\n\t}\n}", "gen": "var a, b, c int\nfmt.Scan(&a, &b, &c)\nif a > b {\n\ta, b = b, a\n}\nif a > c {\n\ta, c = c, a\n}\nif b > c {\n\tb, c = c, b\n}\nif a == b {\n\tfmt.Println(\"YES\")\n\treturn\n}\nif a+b == c {\n\tfmt.Println(\"YES\")\n\treturn\n}\nif a+c == b {\n\tfmt.Println(\"YES\")\n\treturn\n}\nif b+c == a {\n\tfmt.Println(\"YES\")\n\treturn\n}\nfmt.Println(\"NO\")\n}\n\n```\n\n### 2. \u6808\u4e0a\u5206\u914d\n\n```go\npackage main\n\nimport \"fmt\"\n"}
{"tgt": "s := \"STR\"\nfmt.Println(reverseString(s))", "gen": "var s string\nfmt.Scan(&s)\nreverseString(s)\nfmt.Println(s)\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tnums: []int{1, 2, 3, 1},\n\t\tk:    3,\n\t\twant: true,\n\t},\n\t{\n\t\tnums: []int{1, 0, 1, 1},\n\t\tk:    1,\n\t\twant: true,\n\t},\n\t{\n\t\tnums: []int{1, 2, 3, 1, 2, 3},\n\t\tk:    2,\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := containsNearbyDuplicate(tt.nums, tt.k)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.nums, tt.k, got, tt.want)\n\t}\n}", "gen": "fmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1}, 3))\nfmt.Println(containsNearbyDuplicate([]int{1, 0, 1, 1}, 1))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 2))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 3))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 4))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 5))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 6))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 7))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 8))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 9))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 10))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 11))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 12))\nfmt.Println(containsNearbyDuplicate([]"}
{"tgt": "for V > 0 {\n\tV--\n\tif !isDroppedLeft(heights, K) && !isDroppedRight(heights, K) {\n\t\theights[K]++\n\t}\n}\nreturn heights", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 4\nb[1] = 5\nb[2] = 6\nc[0] = 7\nc[1] = 8\nc[2] = 9\nisDroppedLeft(a, b, c)\nfmt.Println(a[0], a[1], a[2])\nfmt.Println(b[0], b[1], b[2])\nfmt.Println(c[0], c[1], c[2])\n}"}
{"tgt": "qs := []question231{\n\t{\n\t\tpara231{1},\n\t\tans231{true},\n\t},\n\t{\n\t\tpara231{16},\n\t\tans231{true},\n\t},\n\t{\n\t\tpara231{218},\n\t\tans231{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans231, q.para231\n\tfmt.Printf(\"STR\", p, isPowerOfTwo(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "m := map[string]struct{}{}\nfor _, email := range emails {\n\tn := len(email)\n\tbs := strings.Builder{}\n\tignore := false\n\tfor i := 0; i < n; i++ {\n\t\tif email[i] == '@' {\n\t\t\tbs.WriteString(email[i:])\n\t\t\tbreak\n\t\t}\n\t\tif ignore || email[i] == '.' {\n\t\t\tcontinue\n\t\t}\n\t\tif email[i] == '+' {\n\t\t\tignore = true\n\t\t\tcontinue\n\t\t}\n\t\tbs.WriteByte(email[i])\n\t}\n\tm[bs.String()] = struct{}{}\n}\nreturn len(m)", "gen": "var m map[string]struct{}\nfor i := 0; i < 1000000; i++ {\n\tm[fmt.Sprintf(\"%d\", i)] = struct{}{}\n}\nfmt.Println(m)\n}\n\n// \u7f16\u8bd1\u6c47\u7f16\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB29:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB30:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB31:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB32:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB27:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB26:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB25:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB24:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB23:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB22:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB21:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB20:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB19:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB18:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB17:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB16:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB15:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB14:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB13:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB12:\n// \u6c47\u7f16\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f.LBB11:\n// \ufffd"}
{"tgt": "cases := []struct {\n\tname   string\n\tinput1 string\n\tinput2 string\n\texpect bool\n}{\n\t{\"STR\", \"STR\", \"STR\", false},\n\t{\"STR\", \"STR\", \"STR\", false},\n\t{\"STR\", \"STR\", \"STR\", true},\n\t{\"STR\", \"STR\", \"STR\", true},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := canConstruct2(c.input1, c.input2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.input1, c.input2)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "for {\n\tswitch r := l.next(); {\n\tcase unicode.IsNumber(r):\n\tcase r == \"STR\":\n\t\tl.backup()\n\t\tl.emit(itemEnd)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase r == eof:\n\t\tl.emit(itemEnd)\n\t\treturn byteRangeSet\n\tdefault:\n\t\treturn l.error(\"STR\")\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "var res byte\nfor i := 0; i < len(s); i++ {\n\tres ^= s[i]\n}\nfor i := 0; i < len(t); i++ {\n\tres ^= t[i]\n}\nreturn res", "gen": "var a [10]byte\nvar b [10]byte\nvar c [10]byte\nvar d [10]byte\nvar e [10]byte\nvar f [10]byte\nvar g [10]byte\nvar h [10]byte\nvar i [10]byte\nvar j [10]byte\nvar k [10]byte\nvar l [10]byte\nvar m [10]byte\nvar n [10]byte\nvar o [10]byte\nvar p [10]byte\nvar q [10]byte\nvar r [10]byte\nvar s [10]byte\nvar t [10]byte\nvar u [10]byte\nvar v [10]byte\nvar w [10]byte\nvar x [10]byte\nvar y [10]byte\nvar z [10]byte\nvar aa [10]byte\nvar bb [10]byte\nvar cc [10]byte\nvar dd [10]byte\nvar ee [10]byte\nvar ff [10]byte\nvar gg [10]byte\nvar hh [10]byte\nvar ii [10]byte\nvar jj [10]byte\nvar kk [10]byte\nvar ll [10]byte\nvar mm [10]byte\nvar nn [10]byte\nvar oo [10]byte\nvar pp [10]byte\nvar qq [10]byte\nvar rr [10]byte\nvar ss [10]byte\nvar tt [10]byte\nvar uu [10]byte\nvar vv [10]byte\nvar ww [10]byte\nvar xx [10]byte\nvar yy [10]byte\nvar zz [10]byte\nvar aaa [10]byte\nvar bbb [10]"}
{"tgt": "var s int\nfor _, c := range m.cache {\n\ts += c.Expire()\n}\nreturn s", "gen": "var m = &LRUCache{\n\tmaxEntries: 3,\n\tcache:      make(map[int64]*entry),\n\torder:      list.New(),\n}\nm.Add(1, 1)\nm.Add(2, 2)\nm.Add(3, 3)\nm.Add(4, 4)\nm.Add(5, 5)\nm.Add(6, 6)\nm.Add(7, 7)\nm.Add(8, 8)\nm.Add(9, 9)\nm.Add(10, 10)\nm.Add(11, 11)\nm.Add(12, 12)\nm.Add(13, 13)\nm.Add(14, 14)\nm.Add(15, 15)\nm.Add(16, 16)\nm.Add(17, 17)\nm.Add(18, 18)\nm.Add(19, 19)\nm.Add(20, 20)\nm.Add(21, 21)\nm.Add(22, 22)\nm.Add(23, 23)\nm.Add(24, 24)\nm.Add(25, 25)\nm.Add(26, 26)\nm.Add(27, 27)\nm.Add(28, 28)\nm.Add(29, 29)\nm.Add(30, 30)\nm.Add(31, 31)\nm.Add(32, 32)\nm.Add(33, 33)\nm.Add(34, 34)\nm.Add(35, 35)\nm.Add(36, 36)\n"}
{"tgt": "if len(num) <= 1 {\n\treturn\n}\nfor i := len(num) - 1; i > 0; i-- {\n\tif num[i-1] < num[i] {\n\t\tj := len(num) - 1\n\t\tfor num[i-1] >= num[j] {\n\t\t\tj--\n\t\t}\n\t\tnum[j], num[i-1] = num[i-1], num[j]\n\t\treverse(num[i:])\n\t\tfmt.Println(num)\n\t\treturn\n\t}\n\tif i == 1 {\n\t\treturn\n\t}\n}", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar bb [3]int\nvar cc [3]int\nvar dd [3]int\nvar ee [3]int\nvar ff [3]int\nvar gg [3]int\nvar hh [3]int\nvar ii [3]int\nvar jj [3]int\nvar kk [3]int\nvar ll [3]int\nvar mm [3]int\nvar nn [3]int\nvar oo [3]int\nvar pp [3]int\nvar qq [3]int\nvar rr [3]int\nvar ss [3]int\nvar tt [3]int\nvar uu [3]int\nvar vv [3]int\nvar ww [3]int\nvar xx [3]int\nvar yy [3]int\nvar zz [3]int\nvar aaa [3]int\nvar bbb [3]int\nvar ccc [3]int\nvar ddd [3]int\nvar eee [3]int\nvar fff [3]int\nvar ggg [3]int\nvar hhh [3]"}
{"tgt": "words := map[string]struct{}{}\ncap, vowel := map[string]string{}, map[string]string{}\nfor _, word := range wordlist {\n\twords[word] = struct{}{}\n\tlower := strings.ToLower(word)\n\tif _, ok := cap[lower]; !ok {\n\t\tcap[lower] = word\n\t\tif _, ok = vowel[todev(lower)]; !ok {\n\t\t\tvowel[todev(lower)] = word\n\t\t}\n\t}\n}\nfor i, query := range queries {\n\tif _, ok := words[query]; ok {\n\t\tcontinue\n\t}\n\tlower := strings.ToLower(query)\n\tif word, ok := cap[lower]; ok {\n\t\tqueries[i] = word\n\t} else if word, ok = vowel[todev(lower)]; ok {\n\t\tqueries[i] = word\n\t} else {\n\t\tqueries[i] = \"STR\"\n\t}\n}\nreturn queries", "gen": "fmt.Println(toDev(\"a\"))\nfmt.Println(toDev(\"A\"))\nfmt.Println(toDev(\"ab\"))\nfmt.Println(toDev(\"AB\"))\nfmt.Println(toDev(\"abc\"))\nfmt.Println(toDev(\"ABC\"))\nfmt.Println(toDev(\"abcd\"))\nfmt.Println(toDev(\"ABCDE\"))\nfmt.Println(toDev(\"abcdef\"))\nfmt.Println(toDev(\"ABCDEF\"))\nfmt.Println(toDev(\"abcdefg\"))\nfmt.Println(toDev(\"ABCDEFG\"))\nfmt.Println(toDev(\"abcdefgh\"))\nfmt.Println(toDev(\"ABCDEFGH\"))\nfmt.Println(toDev(\"abcdefghi\"))\nfmt.Println(toDev(\"ABCDEFGHI\"))\nfmt.Println(toDev(\"abcdefghij\"))\nfmt.Println(toDev(\"ABCDEFGHIJ\"))\nfmt.Println(toDev(\"abcdefghijk\"))\nfmt.Println(toDev(\"ABCDEFGHIJK\"))\nfmt.Println(toDev(\"abcdefghijkl\"))\nfmt.Println(toDev(\"ABCDEFGHIJKL\"))\nfmt.Println(toDev(\"abcdefghijklm\"))\nfmt.Println(toDev(\"ABCDEFGHIJKLM\"))\nfmt.Println(toDev(\"abcdefghijklmn\"))\nfmt.Println(toDev(\"ABCDEFGHIJKLMN\"))\nfmt.Println(toDev(\"abcdefghijklmno\"))\nfmt.Println(toDev(\"ABCDEFGHIJKLMNO\"))\nfmt.Println(toDev(\"abcdefghijklmnop\"))\nfmt.Println(toDev(\"ABCDEFGHIJKLMNOP\"))\nfmt.Println(toDev(\"abcdefghijklmnopq\"))\nfmt.Println(toDev(\"ABCDEFGHIJKLMNOPQ\"))\nfmt.Println("}
{"tgt": "return c.name", "gen": "var a, b int\na, b = 1, 2\nfmt.Println(a, b)\n}\n\n// \u7f16\u8bd1\u5668\u4f1a\u628a\u8fd9\u6bb5\u4ee3\u7801\u8f6c\u6362\u6210\u5982\u4e0b\u7684\u6c47\u7f16\u4ee3\u7801\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\u6c47\u7f16\u4ee3\u7801\u7684\u4f5c\u7528\u662f\u5c06a\u548cb\u7684\u503c\u8d4b\u503c\u7ed9a\u548cb\n// \u8fd9\u6bb5\ufffd"}
{"tgt": "qs := []question984{\n\t{\n\t\tpara984{1, 2},\n\t\tans984{\"STR\"},\n\t},\n\t{\n\t\tpara984{4, 1},\n\t\tans984{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans984, q.para984\n\tfmt.Printf(\"STR\", p, strWithout3a3b(p.a, p.b))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello, world\")\n}\n"}
{"tgt": "var sum int\nfor i := start; i < end; i++ {\n\tsum += l[i]\n}\nreturn sum", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nvar sum int\nfor i = 0; i < 10; i++ {\n\tsum += a[i]\n}\nprintln(sum)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "arr := make([]bool, 1000000)\narr[1] = true\nprime := 3\ncount := 13\nvar k, tmp, localCount int\nvar str string\nfor {\n\tfor k = prime * 2; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tstr = strconv.Itoa(prime)\n\t\tif prime > 100 {\n\t\t\tlocalCount = 1\n\t\t\tfor i := 0; i < len(str)-1; i++ {\n\t\t\t\tstr = str[1:] + str[0:1]\n\t\t\t\ttmp, _ = strconv.Atoi(str)\n\t\t\t\tif tmp > prime {\n\t\t\t\t\tcontinueprimeloop\n\t\t\t\t} else if !arr[tmp] && tmp%2 != 0 {\n\t\t\t\t\tlocalCount++\n\t\t\t\t} else {\n\t\t\t\t\tcontinueprimeloop\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount += localCount\n\t\t}\n\t} else {\n\t\tbreak\n\t}\n}\nprintln(count)", "gen": "var a [1000000]bool\nfor i := 0; i < 1000000; i++ {\n\ta[i] = true\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\tpanic(\"index out of range\")\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\ta[i] = true\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\tpanic(\"index out of range\")\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\ta[i] = true\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\tpanic(\"index out of range\")\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\ta[i] = true\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t}\n}\nfor i := 0; i"}
{"tgt": "count := make(map[string]int, len(words))\nfor _, w := range words {\n\tcount[w]++\n}\nfw := make(freWords, 0, len(count))\nfor w, c := range count {\n\tfw = append(fw, &entry{\n\t\tword:      w,\n\t\tfrequence: c,\n\t})\n}\nsort.Sort(fw)\nres := make([]string, k)\nfor i := 0; i < k; i++ {\n\tres[i] = fw[i].word\n}\nreturn res", "gen": "var m = make(map[string]int)\nvar s = \"hello world\"\nfor i := 0; i < len(s); i++ {\n\tm[string(s[i])]++\n}\nvar freq = make([]entry, 0, len(m))\nfor k, v := range m {\n\tfreq = append(freq, entry{k, v})\n}\nsort.Sort(freWords(freq))\nvar res = make([]string, 0, len(freq))\nfor _, e := range freq {\n\tres = append(res, e.key)\n}\nfmt.Println(res)\n}\n"}
{"tgt": "str1 := \"STR\"\nfmt.Println(largeGroupPositions(str1))\nstr2 := \"STR\"\nfmt.Println(largeGroupPositions(str2))\nstr3 := \"STR\"\nfmt.Println(largeGroupPositions(str3))\nstr4 := \"STR\"\nfmt.Println(largeGroupPositions(str4))", "gen": "fmt.Println(largeGroupPositions(\"aaa\"))\nfmt.Println(largeGroupPositions(\"aa\"))\nfmt.Println(largeGroupPositions(\"aab\"))\nfmt.Println(largeGroupPositions(\"abcde\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\n"}
{"tgt": "list := NewCyclic()\nfillList(list, 3)\nwant := 1\ngot := list.Walk()\nif got.Val != want {\n\tt.Errorf(\"STR\", got)\n}", "gen": "list := NewCyclic(3)\nlist.Fill()\nlist.Walk()\nif list.Front().Value != 1 {\n\tt.Errorf(\"list.Front().Value = %d, want %d\", list.Front().Value, 1)\n}\n}\n\n// 0000000000000000 <main>:\n// \t0:\t55                   \tpush   %rbp\n// \t1:\t48 89 e5             \tmov    %rsp,%rbp\n// \t4:\t48 83 ec 20          \tsub    $0x20,%rsp\n// \t8:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// \tc:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n// \tf:\t48 89 c7             \tmov    %rax,%rdi\n// \t12:\te8 00 00 00 00       \tcallq  19 <main+0x19>\n// \t17:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n// \t1b:\t48 89 45 f0          \tmov    %rax,-0x10(%rbp)\n// \t1f:\t48 8b 45 f0          \tmov    -0x10(%rbp),%rax\n// \t23:\t48 89 c7             \tmov    %rax,%rdi\n// \t26:\te8 00 00 00 00       \tcallq  2d <main+0x2d>\n// \t2b:\t48 8b 45 f0          \tmov    -0x10(%rbp),%rax\n// \t2f:\t48 89 c7             "}
{"tgt": "m := make(map[int]struct{})\nfor _, num := range nums1 {\n\tm[num] = struct{}{}\n}\nnums := make([]int, 0)\nfor _, num := range nums2 {\n\tif _, ok := m[num]; ok {\n\t\tnums = append(nums, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn nums", "gen": "var m map[int]struct {\n\ta int\n\tb int\n\tc int\n}\nm = make(map[int]struct {\n\ta int\n\tb int\n\tc int\n})\nvar s []int\ns = make([]int, 0, 0)\nvar i int\nfor i = 0; i < 10; i++ {\n\tvar v struct {\n\t\ta int\n\t\tb int\n\t\tc int\n\t}\n\tv.a = i\n\tv.b = i\n\tv.c = i\n\tm[i] = v\n\ts = append(s, i)\n}\nvar j int\nfor j = 0; j < 10; j++ {\n\tvar v struct {\n\t\ta int\n\t\tb int\n\t\tc int\n\t}\n\tv = m[j]\n\tif v.a != j {\n\t\tpanic(\"bad\")\n\t}\n\tif v.b != j {\n\t\tpanic(\"bad\")\n\t}\n\tif v.c != j {\n\t\tpanic(\"bad\")\n\t}\n\tif s[j] != j {\n\t\tpanic(\"bad\")\n\t}\n}\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname __morestack runtime.morestack"}
{"tgt": "factorial := new(big.Int).MulRange(1, 100)\nbytes := factorial.Append([]byte{}, 10)\nsum := 0\nfor b := range bytes {\n\tsum += int(bytes[b] - '0')\n}\nfmt.Println(\"STR\", sum)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aaa int\nvar bbb int\nvar ccc int\nvar ddd int\nvar eee int\nvar fff int\nvar ggg int\nvar hhh int\nvar iii int\nvar jjj int\nvar kkk int\nvar lll int\nvar mmm int\nvar nnn int\nvar ooo int\nvar ppp int\nvar qqq int\nvar rrr int\nvar sss int\nvar ttt int\nvar uuu int\nvar vvv int\nvar www int\nvar xxx int\nvar yyy int\nvar zzz int\nvar aaaa int\nvar bbbb int\nvar cccc int\nvar dddd int\nvar eeee int\nvar ffff int\nvar gggg int\nvar hhhh int\nvar iiii int\nvar jjjj int\n"}
{"tgt": "qs := []question1003{\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{true},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{true},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{false},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1003, q.para1003\n\tfmt.Printf(\"STR\", p, isValid1003(p.s))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "var v *error\nreturn v", "gen": "var a int\nvar b int\na = 1\nb = 2\nif a == b {\n\tfmt.Println(\"a == b\")\n} else {\n\tfmt.Println(\"a != b\")\n}\n}\n\n<ASM>\nmovl $1,-32(%rbp)\nmovl $2,-24(%rbp)\nmovl -32(%rbp),%eax\ncmpl -24(%rbp),%eax\nsetne %al\ntestb %al,%al\njne .L10\nmovl $0,-8(%rbp)\njmp .L11\n.L10:\nmovl $1,-8(%rbp)\n.L11:\nmovl -8(%rbp),%eax\nmovl %eax,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL2:\nret\n.L9:\npushq %rbp\nmovq %rsp,%rbp\nmovq $0,-32(%rbp)\nmovq $0,-24(%rbp)\n.LBB6:\nmovq $0,-8(%rbp)\n.LBB7:\nleaq <type...1error>(%rip),%rax\nmovq %rax,-32(%rbp)\nmovq -8(%rbp),%rax\nmovq %rax,-24(%rbp)\nmovq -32(%rbp),%rax\nmovq -24(%rbp),%rdx\n.LBE7:\n.LBE6:\npopq %rbp\nret</ASM>"}
{"tgt": "m := map[string]int{}\nrets := []string{}\nfor i := 0; i <= len(s)-10; i++ {\n\tsub := string(s[i : i+10])\n\tm[sub]++\n\tif m[sub] == 2 {\n\t\trets = append(rets, sub)\n\t}\n}\nreturn rets", "gen": "m := make(map[string]int)\nm[\"a\"] = 1\nm[\"b\"] = 2\nm[\"c\"] = 3\nfmt.Println(m)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "q[i], q[j] = q[j], q[i]", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\na[1] = 1\nb[2] = 2\nc[3] = 3\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] = b[2]\na[1] = c[3]\na[1] ="}
{"tgt": "runes := []rune(s)\nlength := len(runes)\nif length <= 1 {\n\treturn s\n}\nmaxRune := runes[0:1]\nfor i := 0; i < length-1; i++ {\n\ttmpRune := findPalindrome(runes, i, i)\n\tif len(tmpRune) > len(maxRune) {\n\t\tmaxRune = tmpRune\n\t}\n\tif runes[i] == runes[i+1] {\n\t\ttmpRune = findPalindrome(runes, i, i+1)\n\t\tif len(tmpRune) > len(maxRune) {\n\t\t\tmaxRune = tmpRune\n\t\t}\n\t}\n}\nreturn string(maxRune)", "gen": "fmt.Println(findPalindrome(\"abba\"))\nfmt.Println(findPalindrome(\"abcd\"))\nfmt.Println(findPalindrome(\"abcba\"))\nfmt.Println(findPalindrome(\"abcdcba\"))\nfmt.Println(findPalindrome(\"abcdcbaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaaaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaaaaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaaaaaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaaaaaaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaaaaaaaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(findPalindrome(\"abcdcbaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(findPalindrome"}
{"tgt": "stack, j, N := []int{}, 0, len(pushed)\nfor _, x := range pushed {\n\tstack = append(stack, x)\n\tfmt.Printf(\"STR\", stack, j)\n\tfor len(stack) != 0 && j < N && stack[len(stack)-1] == popped[j] {\n\t\tstack = stack[0 : len(stack)-1]\n\t\tj++\n\t}\n\tfmt.Printf(\"STR\", stack, j)\n}\nreturn j == N", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar bb [3]int\nvar cc [3]int\nvar dd [3]int\nvar ee [3]int\nvar ff [3]int\nvar gg [3]int\nvar hh [3]int\nvar ii [3]int\nvar jj [3]int\nvar kk [3]int\nvar ll [3]int\nvar mm [3]int\nvar nn [3]int\nvar oo [3]int\nvar pp [3]int\nvar qq [3]int\nvar rr [3]int\nvar ss [3]int\nvar tt [3]int\nvar uu [3]int\nvar vv [3]int\nvar ww [3]int\nvar xx [3]int\nvar yy [3]int\nvar zz [3]int\nvar aaa [3]int\nvar bbb [3]int\nvar ccc [3]int\nvar ddd [3]int\nvar eee [3]int\nvar fff [3]int\nvar ggg [3]int\nvar hhh [3]"}
{"tgt": "return numDistinctBytes([]byte(s), []byte(t))", "gen": "fmt.Println(numDistinctBytes(\"abc\", \"bca\"))\n}\n"}
{"tgt": "return key1.(int) < key2.(int)", "gen": "var a int\nvar b int\nvar c int\nvar d int\na = 1\nb = 2\nc = 3\nd = 4\nif a == b {\n\tpanic(\"a == b\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif b == c {\n\tpanic(\"b == c\")\n}\nif a == d {\n\tpanic(\"a == d\")\n}\nif b == d {\n\tpanic(\"b == d\")\n}\nif c == d {\n\tpanic(\"c == d\")\n}\nif a == a {\n\tpanic(\"a == a\")\n}\nif b == b {\n\tpanic(\"b == b\")\n}\nif c == c {\n\tpanic(\"c == c\")\n}\nif d == d {\n\tpanic(\"d == d\")\n}\nif a == a {\n\tpanic(\"a == a\")\n}\nif b == b {\n\tpanic(\"b == b\")\n}\nif c == c {\n\tpanic(\"c == c\")\n}\nif d == d {\n\tpanic(\"d == d\")\n}\nif a == a {\n\tpanic(\"a == a\")\n}\nif b == b {\n\tpanic(\"b == b\")\n}\nif c == c {\n\tpanic(\"c == c\")\n}\nif d == d {\n\tpanic(\"d == d\")\n}\nif a == a {\n\tpanic(\"a == a\")\n}\nif b == b {\n\tpanic(\"b == b\")\n}\nif c == c {\n\tpanic(\"c == c\")\n}\nif d == d {\n\tpanic(\"d == d\")\n}\nif a == a {\n\tpanic(\"a == a\")"}
{"tgt": "return x != y", "gen": "var a float32 = 1.0\nvar b float32 = 2.0\nvar c bool\nc = a < b\nfmt.Println(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for prime := range sig(a) {\n\tif sig(b)[prime] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var m map[int64]bool\nvar s int64\nvar v bool\nfor k, _ := range m {\n\tv = m[k]\n\ts += v\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var low, mid, high int = 0, len(sorted) / 2, len(sorted)\nfor low < high {\n\tcurr := sorted[mid]\n\tswitch {\n\tcase curr == target:\n\t\treturn mid\n\tcase inRange(sorted[mid:high], target):\n\t\tlow = mid\n\t\tmid = (low + high) / 2\n\tdefault:\n\t\thigh = mid\n\t\tmid = (low + high) / 2\n\t}\n}\nreturn -1", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\tif i < 5 {\n\t\ta[i] = a[i] + 1\n\t} else {\n\t\ta[i] = a[i] - 1\n\t}\n}\nfor i = 0; i < 10; i++ {\n\tif i < 5 {\n\t\ta[i] = a[i] + 1\n\t} else {\n\t\ta[i] = a[i] - 1\n\t}\n}\nfor i = 0; i < 10; i++ {\n\tif i < 5 {\n\t\ta[i] = a[i] + 1\n\t} else {\n\t\ta[i] = a[i] - 1\n\t}\n}\nfor i = 0; i < 10; i++ {\n\tif i < 5 {\n\t\ta[i] = a[i] + 1\n\t} else {\n\t\ta[i] = a[i] - 1\n\t}\n}\nfor i = 0; i < 10; i++ {\n\tif i < 5 {\n\t\ta[i] = a[i] + 1\n\t} else {\n\t\ta[i] = a[i] - 1\n\t}\n}\nfor i = 0; i < 10; i++ {\n\tif i < 5 {\n\t\ta[i] = a[i] + 1\n\t} else {\n\t\ta[i] = a[i] - 1\n\t}\n}\nfor i = 0; i < 10; i++ {\n\tif i < 5 {\n\t\ta["}
{"tgt": "if n < sumOfProperDivisors(n) {\n\treturn true\n}\nreturn false", "gen": "var n int\nfmt.Scan(&n)\nfmt.Println(sumOfProperDivisors(n))\n}\n"}
{"tgt": "ss := []string{S}\nfor i := 0; i < len(S); i++ {\n\tif S[i] < '0' || S[i] > '9' {\n\t\tfor _, s := range ss {\n\t\t\tb := []byte(s)\n\t\t\tletterCase(b, i)\n\t\t\tss = append(ss, string(b))\n\t\t}\n\t}\n}\nreturn ss", "gen": "fmt.Println(letterCase(\"a\"))\nfmt.Println(letterCase(\"A\"))\nfmt.Println(letterCase(\"ab\"))\nfmt.Println(letterCase(\"aB\"))\nfmt.Println(letterCase(\"123\"))\nfmt.Println(letterCase(\"a123\"))\nfmt.Println(letterCase(\"A123\"))\nfmt.Println(letterCase(\"ab123\"))\nfmt.Println(letterCase(\"aB123\"))\nfmt.Println(letterCase(\"123a\"))\nfmt.Println(letterCase(\"123A\"))\nfmt.Println(letterCase(\"123ab\"))\nfmt.Println(letterCase(\"123aB\"))\nfmt.Println(letterCase(\"123A456\"))\nfmt.Println(letterCase(\"123a456\"))\nfmt.Println(letterCase(\"123A456\"))\nfmt.Println(letterCase(\"123ab456\"))\nfmt.Println(letterCase(\"123aB456\"))\nfmt.Println(letterCase(\"123A45678\"))\nfmt.Println(letterCase(\"123a45678\"))\nfmt.Println(letterCase(\"123A45678\"))\nfmt.Println(letterCase(\"123ab45678\"))\nfmt.Println(letterCase(\"123aB45678\"))\nfmt.Println(letterCase(\"123A456789\"))\nfmt.Println(letterCase(\"123a456789\"))\nfmt.Println(letterCase(\"123A456789\"))\nfmt.Println(letterCase(\"123ab456789\"))\nfmt.Println(letterCase(\"123aB456789\"))\nfmt.Println(letterCase(\"123A4567"}
{"tgt": "digits := convert(N + 1)\nbits := len(digits)\nnoRepeat := 0\nfor b := 1; b < bits; b++ {\n\tnoRepeat += 9 * count(9, b-1)\n}\nhasSeen := make(map[int]bool, 10)\nfor b := 0; b < bits; b++ {\n\td := 0\n\tif b == 0 {\n\t\td = 1\n\t}\n\tfor ; d < digits[b]; d++ {\n\t\tif !hasSeen[d] {\n\t\t\tnoRepeat += count(9-b, bits-b-1)\n\t\t}\n\t}\n\tif hasSeen[digits[b]] {\n\t\tbreak\n\t}\n\thasSeen[digits[b]] = true\n}\nreturn N - noRepeat", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar b = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar c = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar d = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar e = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar f = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar g = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar h = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar i = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar j = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar k = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar m = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar n = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar o = []int{1, 2, 3, 4, 5, 6,"}
{"tgt": "b := NewLRUCache(1000)\nfor i := 0; i < 1000; i++ {\n\tb.Set(randomString(2), \"STR\", expire)\n}\nreturn b", "gen": "c := NewLRUCache(1000)\nfor i := 0; i < 1000; i++ {\n\tc.Set(i, i)\n}\nfmt.Println(c.Get(1))\n}\n```\n\n### \u603b\u7ed3\n\n1. \u7f16\u8bd1\u5668\u4f1a\u5c06\u4e00\u4e9b\u5e38\u91cf\u66ff\u6362\u4e3a\u5e38\u91cf\u8868\u8fbe\u5f0f\uff0c\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\u8fd0\u884c\u65f6\u7684\u8ba1\u7b97\n2. \u7f16\u8bd1\u5668\u4f1a\u5c06\u4e00\u4e9b\u5e38\u91cf\u8868\u8fbe\u5f0f\u66ff\u6362\u4e3a\u5e38\u91cf\uff0c\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\u8fd0\u884c\u65f6\u7684\u8ba1\u7b97\n3. \u7f16\u8bd1\u5668\u4f1a\u5c06\u4e00\u4e9b\u5e38\u91cf\u8868\u8fbe\u5f0f\u66ff\u6362\u4e3a\u5e38\u91cf\uff0c\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\u8fd0\u884c\u65f6\u7684\u8ba1\u7b97\n4. \u7f16\u8bd1\u5668\u4f1a\u5c06\u4e00\u4e9b\u5e38\u91cf\u8868\u8fbe\u5f0f\u66ff\u6362\u4e3a\u5e38\u91cf\uff0c\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\u8fd0\u884c\u65f6\u7684\u8ba1\u7b97\n5. \u7f16\u8bd1\u5668\u4f1a\u5c06\u4e00\u4e9b\u5e38\u91cf\u8868\u8fbe\u5f0f\u66ff\u6362\u4e3a\u5e38\u91cf\uff0c\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\u8fd0\u884c\u65f6\u7684\u8ba1\u7b97\n6. \u7f16\u8bd1\u5668\u4f1a\u5c06\u4e00\u4e9b\u5e38\u91cf\u8868\u8fbe\u5f0f\u66ff\u6362\u4e3a\u5e38\u91cf\uff0c\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\u8fd0\u884c\u65f6\u7684\u8ba1\u7b97\n7. \u7f16\u8bd1\u5668\u4f1a\u5c06\u4e00\u4e9b\u5e38\u91cf\u8868\u8fbe\u5f0f\u66ff\u6362\u4e3a\u5e38\u91cf\uff0c\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\u8fd0\u884c\u65f6\u7684\u8ba1\u7b97\n8. \u7f16\u8bd1\u5668\u4f1a\u5c06\u4e00\u4e9b\u5e38\u91cf\u8868\u8fbe\u5f0f\u66ff\u6362\u4e3a\u5e38\u91cf\uff0c\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\u8fd0\u884c\u65f6\u7684\u8ba1\u7b97\n9. \u7f16\u8bd1\u5668\u4f1a\u5c06\u4e00\u4e9b\u5e38\u91cf\u8868\u8fbe\u5f0f\u66ff\u6362\u4e3a\u5e38\u91cf\uff0c\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\u8fd0\u884c\u65f6\u7684\u8ba1\u7b97\n10. \u7f16\u8bd1\u5668\u4f1a\u5c06\u4e00\u4e9b\u5e38\u91cf\u8868\u8fbe\u5f0f\u66ff\u6362\u4e3a\u5e38\u91cf\uff0c\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\u8fd0\u884c\u65f6\u7684\u8ba1\u7b97\n11. \u7f16\u8bd1\u5668\u4f1a\u5c06\u4e00\u4e9b\u5e38\u91cf\u8868\u8fbe\u5f0f\u66ff\u6362\u4e3a\u5e38\u91cf"}
{"tgt": "h := &IntMaxHeap{}\nheap.Init(h)\nheap.Push(h, 7)\nheap.Push(h, 3)\nheap.Push(h, 2)\nheap.Push(h, 1)\nheap.Push(h, 5)\nheap.Push(h, 5)\nheap.Push(h, 6)\nheap.Push(h, 7)\nfmt.Printf(\"STR\", (*h))\nfor h.Len() > 0 {\n\tfmt.Printf(\"STR\", heap.Pop(h))\n}", "gen": "var heap Solution.IntMaxHeap\nheap.Push(1)\nheap.Push(2)\nheap.Push(3)\nheap.Push(4)\nheap.Push(5)\nheap.Push(6)\nheap.Push(7)\nheap.Push(8)\nheap.Push(9)\nheap.Push(10)\nheap.Push(11)\nheap.Push(12)\nheap.Push(13)\nheap.Push(14)\nheap.Push(15)\nheap.Push(16)\nheap.Push(17)\nheap.Push(18)\nheap.Push(19)\nheap.Push(20)\nheap.Push(21)\nheap.Push(22)\nheap.Push(23)\nheap.Push(24)\nheap.Push(25)\nheap.Push(26)\nheap.Push(27)\nheap.Push(28)\nheap.Push(29)\nheap.Push(30)\nheap.Push(31)\nheap.Push(32)\nheap.Push(33)\nheap.Push(34)\nheap.Push(35)\nheap.Push(36)\nheap.Push(37)\nheap.Push(38)\nheap.Push(39)\nheap.Push(40)\nheap.Push(41)\nheap.Push(42)\nheap.Push(43)\nheap.Push(44)\nheap.Push(45)\nheap.Push(46)\nheap.Push(47)\nheap.Push(48)\nheap.Push(49)\nheap.Push(50)"}
{"tgt": "return MyCalendar{\n\tbooks: make([]seg, 0),\n}", "gen": "var s Solution\ns.Solve()\n}\n"}
{"tgt": "var buf bytes.Buffer\nbuf.WriteByte(\"STR\")\nfor i, word := range s.words {\n\tif word == 0 {\n\t\tcontinue\n\t}\n\tfor j := 0; j < 64; j++ {\n\t\tif word&(1<<uint(j)) != 0 {\n\t\t\tif buf.Len() > len(\"STR\") {\n\t\t\t\tbuf.WriteByte(\"STR\")\n\t\t\t}\n\t\t\tfmt.Fprintf(&buf, \"STR\", 64*i+j)\n\t\t}\n\t}\n}\nbuf.WriteByte(\"STR\")\nreturn buf.String()", "gen": "var buf bytes.Buffer\nbuf.WriteByte(123)\nfor i := 0; i < 64; i++ {\n\tbuf.WriteByte(byte(i))\n}\nfmt.Printf(\"%s\", buf.String())\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "matrix := [][]int{\n\t{5, 1, 9, 11},\n\t{2, 4, 8, 10},\n\t{13, 3, 6, 7},\n\t{15, 14, 12, 16},\n}\nmatrix = rotate(matrix)\nfor _, nums := range matrix {\n\tfor _, num := range nums {\n\t\tfmt.Print(num, \"STR\")\n\t}\n\tfmt.Println()\n}", "gen": "var a [4][4]int\nvar b [4][4]int\nvar c [4][4]int\nvar d [4][4]int\nvar e [4][4]int\nvar f [4][4]int\nvar g [4][4]int\nvar h [4][4]int\nvar i [4][4]int\nvar j [4][4]int\nvar k [4][4]int\nvar l [4][4]int\nvar m [4][4]int\nvar n [4][4]int\nvar o [4][4]int\nvar p [4][4]int\nvar q [4][4]int\nvar r [4][4]int\nvar s [4][4]int\nvar t [4][4]int\nvar u [4][4]int\nvar v [4][4]int\nvar w [4][4]int\nvar x [4][4]int\nvar y [4][4]int\nvar z [4][4]int\nvar aa [4][4]int\nvar bb [4][4]int\nvar cc [4][4]int\nvar dd [4][4]int\nvar ee [4][4]int\nvar ff [4][4]int\nvar gg [4][4]int\nvar hh [4][4]int\nvar ii [4][4]int\nvar jj [4][4]int\nvar kk [4][4]int\nvar ll [4][4]int\nvar mm [4][4]int\nvar nn [4][4]int\nvar oo [4][4]int\nvar pp [4][4]int\nvar qq [4][4]int\nvar rr [4][4]int\nvar ss [4][4]int\nvar tt [4][4]int\nvar uu [4][4]int\nvar vv [4][4]int\nvar ww [4][4]"}
{"tgt": "return MyQueue{\n\tlist: list.New(),\n}", "gen": "var l *z2flist.List\nl = z2flist.New()\n}\n\n<ASM>\n.LFB1:\ncmpq %fs:112,%rsp\njnb .L10\nmovl $24,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L10:\npushq %rbp\nmovq %rsp,%rbp\nsubq $16,%rsp\nmovq $0,-8(%rbp)\n.LBB4:\n.LBB5:\ncall <container..z2flist.New@PLT>\nmovq %rax,-8(%rbp)\nmovq -8(%rbp),%rax\n.LBE5:\n.LBE4:\nleave\nret</ASM>"}
{"tgt": "res := sizeOfLargestBST(tree)\nreturn res.AnsPtr", "gen": "root := &TreeNode{Val: 3}\nroot.Left = &TreeNode{Val: 2}\nroot.Right = &TreeNode{Val: 5}\nroot.Left.Left = &TreeNode{Val: 1}\nroot.Left.Right = &TreeNode{Val: 4}\nroot.Right.Right = &TreeNode{Val: 6}\nfmt.Println(sizeOfLargestBST(root))\n}\n"}
{"tgt": "sort.Ints(candidates)\nvar res [][]int\ndfs(candidates, nil, target, 0, &res)\nreturn res", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\ndfs(a[:])\nfmt.Println(a[0], a[1], a[2])\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := checkRecord(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(problem551.CheckRecord(\"PPALL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLLLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLLLLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLLLLLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLLLLLLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLLLLLLLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLLLLLLLLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLLLLLLLLLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(problem551.CheckRecord(\"PPALLLLLLLLLLLLLLLLLLLLLL\"))\nfmt"}
{"tgt": "for i := 1; i < len(arr); i++ {\n\tvalue := arr[i]\n\tj := i - 1\n\tfor j >= 0 && arr[j] > value {\n\t\tarr[j+1] = arr[j]\n\t\tj = j - 1\n\t}\n\tarr[j+1] = value\n}", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + a[i+1]\n}\nfmt.Println(a[9])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var nums []int\nvar ret bool\nnums = []int{1, 2, 3, 1}\nret = true\nif ret != containsDuplicate(nums) {\n\tt.Fatalf(\"STR\", ret)\n}\nnums = []int{1, 2, 3, 4}\nret = false\nif ret != containsDuplicate(nums) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "switch {\ncase head.Left == nil && head.Right == nil:\n\treturn head.Value\ncase head.Left != nil && head.Right != nil:\n\tleft := head.Value + MinPathSum(head.Left)\n\tright := head.Value + MinPathSum(head.Right)\n\treturn min(left, right)\ncase head.Left != nil:\n\treturn head.Value + MinPathSum(head.Left)\ndefault:\n\treturn head.Value + MinPathSum(head.Right)\n}", "gen": "fmt.Println(MinPathSum([][]int{{1, 3, 1}, {1, 5, 1}, {4, 2, 1}}))\n}\n"}
{"tgt": "sets := make([][]int, 1, 1<<uint(len(nums)))\nfor _, num := range nums {\n\tfor _, set := range sets {\n\t\ts := make([]int, len(set), len(set)+1)\n\t\tcopy(s, set)\n\t\tsets = append(sets, append(s, num))\n\t}\n}\nreturn sets", "gen": "var a [64]int\nvar b [64]int\nvar c [64]int\nvar d [64]int\nvar e [64]int\nvar f [64]int\nvar g [64]int\nvar h [64]int\nvar i [64]int\nvar j [64]int\nvar k [64]int\nvar l [64]int\nvar m [64]int\nvar n [64]int\nvar o [64]int\nvar p [64]int\nvar q [64]int\nvar r [64]int\nvar s [64]int\nvar t [64]int\nvar u [64]int\nvar v [64]int\nvar w [64]int\nvar x [64]int\nvar y [64]int\nvar z [64]int\nvar aa [64]int\nvar ab [64]int\nvar ac [64]int\nvar ad [64]int\nvar ae [64]int\nvar af [64]int\nvar ag [64]int\nvar ah [64]int\nvar ai [64]int\nvar aj [64]int\nvar ak [64]int\nvar al [64]int\nvar am [64]int\nvar an [64]int\nvar ao [64]int\nvar ap [64]int\nvar aq [64]int\nvar ar [64]int\nvar as [64]int\nvar at [64]int\nvar au [64]int\nvar av [64]int\nvar aw [64]int\nvar ax [64]int\nvar ay [64]int\nvar az [64]int\nvar ba [64]int\nvar bb [64]int\nvar bc [64]int\n"}
{"tgt": "out := 100\nif x := p33(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "p33 := 100\np34 := 100\np35 := 100\np36 := 100\np37 := 100\np38 := 100\np39 := 100\np40 := 100\np41 := 100\np42 := 100\np43 := 100\np44 := 100\np45 := 100\np46 := 100\np47 := 100\np48 := 100\np49 := 100\np50 := 100\np51 := 100\np52 := 100\np53 := 100\np54 := 100\np55 := 100\np56 := 100\np57 := 100\np58 := 100\np59 := 100\np60 := 100\np61 := 100\np62 := 100\np63 := 100\np64 := 100\np65 := 100\np66 := 100\np67 := 100\np68 := 100\np69 := 100\np70 := 100\np71 := 100\np72 := 100\np73 := 100\np74 := 100\np75 := 100\np76 := 100\np77 := 100\np78 := 100\np79 := 100\np80 := 100\np81 := 100\np82 := 100\n"}
{"tgt": "steps := countSteps([]int{0, 0}, target)\nfor _, g := range ghosts {\n\tif steps >= countSteps(g, target) {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "fmt.Println(countSteps(2, 2))\nfmt.Println(countSteps(2, 3))\nfmt.Println(countSteps(3, 2))\nfmt.Println(countSteps(3, 3))\nfmt.Println(countSteps(3, 4))\nfmt.Println(countSteps(4, 3))\nfmt.Println(countSteps(4, 4))\nfmt.Println(countSteps(4, 5))\nfmt.Println(countSteps(5, 4))\nfmt.Println(countSteps(5, 5))\nfmt.Println(countSteps(5, 6))\nfmt.Println(countSteps(6, 5))\nfmt.Println(countSteps(6, 6))\nfmt.Println(countSteps(6, 7))\nfmt.Println(countSteps(7, 6))\nfmt.Println(countSteps(7, 7))\nfmt.Println(countSteps(7, 8))\nfmt.Println(countSteps(8, 7))\nfmt.Println(countSteps(8, 8))\nfmt.Println(countSteps(8, 9))\nfmt.Println(countSteps(9, 8))\nfmt.Println(countSteps(9, 9))\nfmt.Println(countSteps(9, 10))\nfmt.Println(countSteps(10, 9))\nfmt.Println(countSteps(10, 10))\nfmt.Println(countSteps(10, 11))\nfmt.Println(countSteps(11, 10))\nfmt.Println(countSteps(11, 11))\nfmt.Println(countSteps(11, 12))\nfmt.Println(countSteps(12, 11))\nfmt.Println("}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CourseOrder(tc.prereqs); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "if nil == root || k <= 0 {\n\treturn nil\n}\nvar target *BinaryTreeNode\nif root.left != nil {\n\ttarget = kthNode(root.left, k)\n}\nif target == nil {\n\tif 1 == k {\n\t\ttarget = root\n\t} else {\n\t\tk--\n\t}\n}\nif target == nil && root.right != nil {\n\ttarget = kthNode(root.right, k)\n}\nreturn target", "gen": "var root *Node\nvar k int\nfmt.Scan(&root)\nfmt.Scan(&k)\nfmt.Println(kthNode(root, k))\n}\n"}
{"tgt": "nums := []int{0, 0, 1, 2}\nfmt.Println(dominantIndex(nums))", "gen": "fmt.Println(dominantIndex([]int{1, 2, 3, 4, 5, 6}))\n}\n"}
{"tgt": "if root == nil {\n\treturn nil\n}\nif root.Val < L {\n\treturn trimBST(root.Right, L, R)\n}\nif root.Val > R {\n\treturn trimBST(root.Left, L, R)\n}\nroot.Left = trimBST(root.Left, L, R)\nroot.Right = trimBST(root.Right, L, R)\nreturn root", "gen": "fmt.Println(trimBST(nil, 1))\nfmt.Println(trimBST(nil, 0))\nfmt.Println(trimBST(nil, -1))\nfmt.Println(trimBST(nil, -2))\nfmt.Println(trimBST(nil, -3))\nfmt.Println(trimBST(nil, -4))\nfmt.Println(trimBST(nil, -5))\nfmt.Println(trimBST(nil, -6))\nfmt.Println(trimBST(nil, -7))\nfmt.Println(trimBST(nil, -8))\nfmt.Println(trimBST(nil, -9))\nfmt.Println(trimBST(nil, -10))\nfmt.Println(trimBST(nil, -11))\nfmt.Println(trimBST(nil, -12))\nfmt.Println(trimBST(nil, -13))\nfmt.Println(trimBST(nil, -14))\nfmt.Println(trimBST(nil, -15))\nfmt.Println(trimBST(nil, -16))\nfmt.Println(trimBST(nil, -17))\nfmt.Println(trimBST(nil, -18))\nfmt.Println(trimBST(nil, -19))\nfmt.Println(trimBST(nil, -20))\nfmt.Println(trimBST(nil, -21))\nfmt.Println(trimBST(nil, -22))\nfmt.Println(trimBST(nil, -23))\nfmt.Println(trimBST(nil, -24))\nfmt.Println(trimBST(nil, -25))\nfmt.Println(trimBST(nil, -26))\nfmt.Println(trimBST(nil, -27))\nfmt.Println(trimBST(nil, -28))\n"}
{"tgt": "length := len(matrix)\nfor i := 0; 2*i < length-1; i++ {\n\tfor j := i; j < length-i-1; j++ {\n\t\tmatrix[i][j], matrix[j][length-i-1], matrix[length-i-1][length-j-1], matrix[length-j-1][i] =\n\t\t\tmatrix[length-j-1][i], matrix[i][j], matrix[j][length-i-1], matrix[length-i-1][length-j-1]\n\t}\n}", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "p = len(postorder) - 1\nidxMap = make(map[int]int)\nfor i, v := range inorder {\n\tidxMap[v] = i\n}\nreturn build(0, len(inorder)-1, postorder)", "gen": "s := Solution{\n\tp: 10,\n\tidxMap: map[int]int{\n\t\t0: 1,\n\t\t1: 2,\n\t\t2: 3,\n\t\t3: 4,\n\t\t4: 5,\n\t\t5: 6,\n\t\t6: 7,\n\t\t7: 8,\n\t\t8: 9,\n\t\t9: 10,\n\t},\n}\ns.build(0, 10)\nfmt.Println(s.idxMap)\n}\n"}
{"tgt": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Print(sum, \"STR\")", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xxx int\nvar yyy int\nvar zzz int\nvar aaa int\nvar bbb int\nvar ccc int\nvar ddd int\nvar eee int\nvar fff int\nvar ggg int\nvar hhh int\nvar iii int\nvar jjj int\nvar kkk int\nvar lll int\nvar mmm int\nvar"}
{"tgt": "qs := []question856{\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{1},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{2},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{2},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{6},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{3},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{8},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans856, q.para856\n\tfmt.Printf(\"STR\", p, scoreOfParentheses(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "const (\n\txmin, ymin, xmax, ymax = -2, -2, +2, +2\n\twidth, height          = 1024, 1024\n)\nimg := image.NewRGBA(image.Rect(0, 0, width, height))\nfor py := 0; py < height; py++ {\n\ty := float64(py)/height*(ymax-ymin) + ymin\n\tfor px := 0; px < width; px++ {\n\t\tx := float64(px)/width*(xmax-xmin) + xmin\n\t\tz := complex(x, y)\n\t\timg.Set(px, py, mandelbrot(z))\n\t}\n}\npng.Encode(os.Stdout, img)", "gen": "var width, height int\nflag.IntVar(&width, \"width\", 1024, \"width of the image\")\nflag.IntVar(&height, \"height\", 1024, \"height of the image\")\nflag.Parse()\nimg := image.NewRGBA(image.Rect(0, 0, width, height))\nfor y := 0; y < height; y++ {\n\tfor x := 0; x < width; x++ {\n\t\tz := complex(float64(x)/float64(width), float64(y)/float64(height))\n\t\timg.Set(x, y, mandelbrot(z))\n\t}\n}\npng.Encode(os.Stdout, img)\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif start, end := BusiestBuildingTimes(tc.moves); start != tc.start || end != tc.end {\n\t\tt.Errorf(\"STR\", tc.start, tc.end, start, end)\n\t}\n}", "gen": "fmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n}))\nfmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n\t{10, 11, 12},\n}))\nfmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t{13, 14, 15},\n}))\nfmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t{13, 14, 15},\n\t{16, 17, 18},\n}))\nfmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t{13, 14, 15},\n\t{16, 17, 18},\n\t{19, 20, 21},\n}))\nfmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t"}
{"tgt": "n := len(cost)\ndp := make([]int, n+1)\nfor i := 2; i <= n; i++ {\n\tdp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])\n}\nreturn dp[n]", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar b = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar c = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar d = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar e = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar f = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar g = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar h = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar i = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar j = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar k = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar m = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar n = []int"}
{"tgt": "return new(runningSchTaskList).init(tasks)", "gen": "var rt *runningSchTaskList\nrt = new(runningSchTaskList)\nrt.init(32, 24, 16)\n}\n\n<ASM>\nmovq %fs:112,%r10\nmovq %r10,%r11\nmovq %r10,%r12\nmovq %r10,%r13\nmovq %r10,%r14\nmovq %r10,%r15\nmovq %r10,%r8\nmovq %r10,%r9\nmovq %r10,%r10\nmovq %r10,%r11\nmovq %r10,%r12\nmovq %r10,%r13\nmovq %r10,%r14\nmovq %r10,%r15\nmovq %r10,%r8\nmovq %r10,%r9\nmovq %r10,%r10\nmovq %r10,%r11\nmovq %r10,%r12\nmovq %r10,%r13\nmovq %r10,%r14\nmovq %r10,%r15\nmovq %r10,%r8\nmovq %r10,%r9\nmovq %r10,%r10\nmovq %r10,%r11\nmovq %r10,%r12\nmovq %r10,%r13\nmovq %r10,%r14\nmovq %r10,%r15\nmovq %r10,%r8\nmovq %r10,%r9\nmovq %r10,%r10\nmovq %r10,%r11\nmovq %r10,%r12\nmovq %r10,%r13\nmovq %r10,%r14\nmovq %r10,%r15\nmovq %r10,%r8\nmovq %r10,%r9\nmovq %r10,%r10\nmovq %r10,%r11\n"}
{"tgt": "return area(A, B, C, D) + area(E, F, G, H) - area(max(A, E), max(B, F), min(C, G), min(D, H))", "gen": "fmt.Println(area(10, 20))\nfmt.Println(area(20, 10))\nfmt.Println(area(10, 10))\nfmt.Println(area(20, 20))\nfmt.Println(area(10, 10))\nfmt.Println(area(20, 10))\nfmt.Println(area(10, 20))\nfmt.Println(area(20, 20))\nfmt.Println(area(10, 20))\nfmt.Println(area(20, 10))\nfmt.Println(area(10, 20))\nfmt.Println(area(20, 10))\nfmt.Println(area(10, 20))\nfmt.Println(area(20, 10))\nfmt.Println(area(10, 20))\nfmt.Println(area(20, 10))\nfmt.Println(area(10, 20))\nfmt.Println(area(20, 10))\nfmt.Println(area(10, 20))\nfmt.Println(area(20, 10))\nfmt.Println(area(10, 20))\nfmt.Println(area(20, 10))\nfmt.Println(area(10, 20))\nfmt.Println(area(20, 10))\nfmt.Println(area(10, 20))\nfmt.Println(area(20, 10))\nfmt.Println(area(10, 20))\nfmt.Println(area(20, 10))\nfmt.Println(area(10, 20))\nfmt.Println(area(20, 10))\nfmt.Println(area(10, 20))\nfmt.Print"}
{"tgt": "r, err := http.Get(os.Args[1])\nif err != nil {\n\tfmt.Println(err)\n\treturn\n}\nio.Copy(os.Stdout, r.Body)\nif err := r.Body.Close(); err != nil {\n\tfmt.Println(err)\n}", "gen": "resp, err := http.Get(\"https://www.baidu.com\")\nif err != nil {\n\tpanic(err)\n}\ndefer resp.Body.Close()\nbody, err := ioutil.ReadAll(resp.Body)\nif err != nil {\n\tpanic(err)\n}\nfmt.Println(string(body))\nfmt.Println(resp.StatusCode)\n}\n```\n\n### \u6c47\u7f16\u4ee3\u7801\u89e3\u6790\n\n```\nleaq -472(%rsp),%r11\ncmpq %fs:112,%r11\njnb .L15\nmovl $472,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L15:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $424,%rsp\nmovq <8+os.Args>(%rip),%rax\ncmpq $1,%rax\njg .L5\nmovq %rax,%rsi\nmovl $1,%edi\ncall <runtime.goPanicIndex@PLT>\n.L5:\nmovq <os.Args>(%rip),%rax\naddq $16,%rax\nleaq -240(%rbp),%rcx\nmovq (%rax),%rdx\nmovq <8>(%rax),%rax\nmovq %rdx,%rsi\nmovq %rax,%rdx\nmovq %rcx,%rdi\ncall <net..z2fhttp.Get@PLT>\nmovq -240(%rbp),%rax\nmovq -232(%rbp),%rdx\nmovq %rax,-400(%rbp)\nmovq %rdx,-392(%rbp)\nmovq -224(%rbp),"}
{"tgt": "qs := []question1304{\n\t{\n\t\tpara1304{5},\n\t\tans1304{[]int{-7, -1, 1, 3, 4}},\n\t},\n\t{\n\t\tpara1304{0},\n\t\tans1304{[]int{}},\n\t},\n\t{\n\t\tpara1304{3},\n\t\tans1304{[]int{-1, 0, 1}},\n\t},\n\t{\n\t\tpara1304{1},\n\t\tans1304{[]int{0}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1304, q.para1304\n\tfmt.Printf(\"STR\", p, sumZero(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 2, 1}, []int{0, 4, 1, 3, 2}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1}, []int{0}, []int{1}},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums, c.index)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums, c.index)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := isRobotBounded(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(isRobotBounded(\"GGLLGG\"))\nfmt.Println(isRobotBounded(\"GG\"))\nfmt.Println(isRobotBounded(\"GL\"))\nfmt.Println(isRobotBounded(\"GLG\"))\nfmt.Println(isRobotBounded(\"GLGGLG\"))\nfmt.Println(isRobotBounded(\"GLGGLGGLG\"))\nfmt.Println(isRobotBounded(\"GLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGL"}
{"tgt": "seen := make(map[string]struct{})\nfor _, tier := range al {\n\tfor _, v := range tier {\n\t\tif _, ok := seen[v]; !ok {\n\t\t\tseen[v] = struct{}{}\n\t\t\tret = append(ret, v)\n\t\t}\n\t}\n}\nreturn", "gen": "var m map[string]struct{}\nfor i := 0; i < 1000000; i++ {\n\tm[fmt.Sprintf(\"%d\", i)] = struct{}{}\n}\n}\n"}
{"tgt": "return h.tasks[i].r < h.tasks[j].r", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 1\nb[1] = 2\nb[2] = 3\nc[0] = 1\nc[1] = 2\nc[2] = 3\nif a[0] == b[0] && a[1] == b[1] && a[2] == b[2] {\n\tfmt.Println(\"a == b\")\n}\nif a[0] == c[0] && a[1] == c[1] && a[2] == c[2] {\n\tfmt.Println(\"a == c\")\n}\nif b[0] == c[0] && b[1] == c[1] && b[2] == c[2] {\n\tfmt.Println(\"b == c\")\n}\nif a[0] != b[0] || a[1] != b[1] || a[2] != b[2] {\n\tfmt.Println(\"a != b\")\n}\nif a[0] != c[0] || a[1] != c[1] || a[2] != c[2] {\n\tfmt.Println(\"a != c\")\n}\nif b[0] != c[0] || b[1] != c[1] || b[2] != c[2] {\n\tfmt.Println(\"b != c\")\n}\nif a[0] < b[0] || a[1] < b[1] || a[2] < b[2] {\n\tfmt.Println(\"a < b\")\n}\nif a[0] < c[0] || a[1] < c[1] || a[2] < c[2] {\n\tfmt.Println(\"a < c\")\n}\nif b[0] < c[0]"}
{"tgt": "return xtime.Unix(int64(jt), 0)", "gen": "var t time.Time\nt.Unix()\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return RandomizedSet{\n\tl: []int{},\n\tm: make(map[int]int),\n}", "gen": "m := make(map[string]int)\nm[\"hello\"] = 10\nfmt.Println(m)\n}\n\n<ASM>\n.LFB0:\ncmpq %fs:112,%rsp\njnb .L3\nmovl $120,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L3:\npushq %rbp\nmovq %rsp,%rbp\npushq %rbx\nsubq $104,%rsp\nmovq %rdi,-104(%rbp)\nmovq $0,-96(%rbp)\nmovq $0,-88(%rbp)\nmovq $0,-80(%rbp)\nmovq $0,-72(%rbp)\n.LBB2:\n.LBB3:\ncall <runtime.makemap_small@PLT>\nmovq %rax,%rbx\nleaq <type...60x.7int>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-56(%rbp)\nmovq -56(%rbp),%rax\nmovq %rax,-48(%rbp)\nmovq $0,-40(%rbp)\nmovq $0,-32(%rbp)\nmovq -48(%rbp),%rax\nmovq -40(%rbp),%rdx\nmovq %rax,-96(%rbp)\nmovq %rdx,-88(%rbp)\nmovq -32(%rbp),%rax\nmovq %rax,-80(%rbp)\nmovq %rbx,-72(%rbp)\nmovq -104(%rbp),%rcx\nmovq -96(%rbp),%rax\nmovq -88(%rbp),%rdx\nmovq %rax,(%rcx)\nmovq %rdx,<8>(%rcx)\nmovq -80(%rbp),%rax\nmovq"}
{"tgt": "return TypeInt, nil", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nfmt.Println(a)\n}\n\n```\n\n### 2. \u6808\u5e27\n\n\u6808\u5e27\u662f\u6307\u5b58\u50a8\u5728\u6808\u4e2d\u7684\u4e00\u6bb5\u8fde\u7eed\u5185\u5b58\uff0c\u6808\u5e27\u4e2d\u5b58\u50a8\u4e86\u51fd\u6570\u7684\u53c2\u6570\u3001\u5c40\u90e8\u53d8\u91cf\u3001\u8fd4\u56de\u5730\u5740\u3001\u9884\u7559\u7a7a\u95f4\u7b49\u4fe1\u606f\u3002\n\n\u6808\u5e27\u7684\u5927\u5c0f\u662f\u4e0d\u56fa\u5b9a\u7684\uff0c\u5b83\u7684\u5927\u5c0f\u53d6\u51b3\u4e8e\u51fd\u6570\u7684\u53c2\u6570\u4e2a\u6570\u3001\u53c2\u6570\u7c7b\u578b\u3001\u5c40\u90e8\u53d8\u91cf\u4e2a\u6570\u3001\u5c40\u90e8\u53d8\u91cf\u7c7b\u578b\u7b49\u3002\n\n\u6808\u5e27\u7684\u5927\u5c0f\u662f\u5728\u7f16\u8bd1\u65f6\u786e\u5b9a\u7684\uff0c\u7f16\u8bd1\u5668\u4f1a\u6839\u636e\u51fd\u6570\u7684\u53c2\u6570\u4e2a\u6570\u3001\u53c2\u6570\u7c7b\u578b\u3001\u5c40\u90e8\u53d8\u91cf\u4e2a\u6570\u3001\u5c40\u90e8\u53d8\u91cf\u7c7b\u578b\u7b49\u4fe1\u606f\u6765\u8ba1\u7b97\u51fa\u6808\u5e27\u7684\u5927\u5c0f\u3002\n\n\u6808\u5e27\u7684\u5927\u5c0f\u662f\u5728\u7f16\u8bd1\u65f6\u786e\u5b9a\u7684\uff0c\u7f16\u8bd1\u5668\u4f1a\u6839\u636e\u51fd\u6570\u7684\u53c2\u6570\u4e2a\u6570\u3001\u53c2\u6570\u7c7b\u578b\u3001\u5c40\u90e8\u53d8\u91cf\u4e2a\u6570\u3001\u5c40\u90e8\u53d8\u91cf\u7c7b\u578b\u7b49\u4fe1\u606f\u6765\u8ba1\u7b97\u51fa\u6808\u5e27\u7684\u5927\u5c0f\u3002\n\n\u6808\u5e27\u7684\u5927\u5c0f\u662f\u5728\u7f16\u8bd1\u65f6\u786e\u5b9a\u7684\uff0c\u7f16\u8bd1\u5668\u4f1a\u6839\u636e\u51fd\u6570\u7684\u53c2\u6570\u4e2a\u6570\u3001\u53c2\u6570\u7c7b\u578b\u3001\u5c40\u90e8\u53d8\u91cf\u4e2a\u6570\u3001\u5c40\u90e8\u53d8\u91cf\u7c7b\u578b\u7b49\u4fe1\u606f\u6765\u8ba1\u7b97\u51fa\u6808\u5e27\u7684\u5927\u5c0f\u3002\n\n\u6808\u5e27\u7684\u5927\u5c0f\u662f\u5728\u7f16\u8bd1\u65f6\u786e\u5b9a\u7684\uff0c\u7f16\u8bd1\u5668\u4f1a\u6839\u636e\u51fd\u6570\u7684\u53c2\u6570\u4e2a\u6570\u3001\u53c2\u6570\u7c7b\u578b\u3001\u5c40\u90e8\u53d8\u91cf\u4e2a\u6570\u3001\u5c40\u90e8\u53d8\u91cf\u7c7b\u578b\u7b49\u4fe1\u606f\u6765\u8ba1\u7b97\u51fa\u6808\u5e27\u7684\u5927\u5c0f\u3002\n\n\u6808\u5e27\u7684\u5927\u5c0f\u662f\u5728\u7f16\u8bd1\u65f6\u786e"}
{"tgt": "return createSkyline(buildings, 0, len(buildings)-1)", "gen": "var skyline [][]int\nskyline = createSkyline([][]int{{2, 9, 10}, {3, 7, 15}, {5, 12, 12}, {15, 20, 10}, {19, 24, 8}})\nfmt.Println(skyline)\n}\n"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil && max.Right != root {\n\t\t\tmax = max.Right\n\t\t}\n\t\tif max.Right == nil {\n\t\t\tmax.Right = root\n\t\t\troot = root.Left\n\t\t} else {\n\t\t\tres = append(res, root.Val)\n\t\t\troot = root.Right\n\t\t\tmax.Right = nil\n\t\t}\n\t}\n}\nreturn res", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "_, err := os.Open(\"STR\")\nif !os.IsNotExist(err) {\n\tpanic(\"STR\")\n}\nf, err := os.Open(\"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer func() {\n\tif err := f.Close(); err != nil {\n\t\tpanic(err)\n\t}\n\t_, err := f.Read(make([]byte, 10))\n\tif err == nil {\n\t\tpanic(\"STR\")\n\t}\n}()\ndata, err := ioutil.ReadAll(f)\nif err != nil {\n\tpanic(err)\n}\nprint(string(data))", "gen": "f, err := os.Open(\"test.txt\")\nif err != nil {\n\tpanic(err)\n}\ndefer f.Close()\nb, err := ioutil.ReadAll(f)\nif err != nil {\n\tpanic(err)\n}\nfmt.Println(string(b))\n}\n\n```\n\n### \u6c47\u7f16\u4ee3\u7801\u89e3\u6790\n\n```\n.LFB0:\nleaq -584(%rsp),%r11\ncmpq %fs:112,%r11\njnb .L20\nmovl $584,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\n.LEHB0:\nret\n.L20:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $536,%rsp\n.LEHE0:\nmovb $0,-457(%rbp)\n.LBB2:\nleaq <.LC4>(%rip),%rax\nmovl $9,%edx\nleaq -160(%rbp),%rdi\nmovq %rax,%rcx\nmovq %rdx,%rbx\nmovq %rdx,%rax\nmovq %rcx,%rsi\nmovq %rax,%rdx\n.LEHB1:\ncall <os.Open@PLT>\nmovq -160(%rbp),%rax\nmovq -152(%rbp),%rdx\nmovq %rax,-448(%rbp)\nmovq %rdx,-440(%rbp)\nmovq -144(%rbp),%rax\nmovq %rax,-432(%rbp)\nmovq -448(%rbp),%rax\nmovq %rax,-56(%rbp)\nmovq -440(%"}
{"tgt": "start, total, tank := 0, 0, 0\nfor i, g := range gas {\n\ttank += g - cost[i]\n\tif tank < 0 {\n\t\tstart = i + 1\n\t\ttotal += tank\n\t\ttank = 0\n\t}\n}\nif total+tank < 0 {\n\treturn -1\n}\nreturn start", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfmt.Println(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "fmt.Println(btree.Data)", "gen": "var a, b, c int\nfmt.Println(a, b, c)\n}\n\n<ASM>\n.LFB1:\ncmpq %fs:112,%rsp\njnb .L3\nmovl $136,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L3:\npushq %rbp\nmovq %rsp,%rbp\naddq $-128,%rsp\nmovq %rdi,-120(%rbp)\nmovq -120(%rbp),%rax\nmovq <8>(%rax),%rdx\nmovq (%rax),%rax\nmovq %rax,-80(%rbp)\nmovq %rdx,-72(%rbp)\nleaq -80(%rbp),%rax\nmovq %rax,-64(%rbp)\nmovq $1,-56(%rbp)\nmovq $1,-48(%rbp)\nleaq -32(%rbp),%rax\nsubq $8,%rsp\npushq -48(%rbp)\npushq -56(%rbp)\npushq -64(%rbp)\nmovq %rax,%rdi\ncall <fmt.Println@PLT>\naddq $32,%rsp\nmovq -32(%rbp),%rax\nmovq -24(%rbp),%rdx\nmovq %rax,-112(%rbp)\nmovq %rdx,-104(%rbp)\nmovq -16(%rbp),%rax\nmovq %rax,-96(%rbp)\nleave\nret</ASM>"}
{"tgt": "n := len(num)\nres := []string{}\nvar dfs func(string, int, int, int)\ndfs = func(path string, index, result, pre int) {\n\tif index == n && result == target {\n\t\tres = append(res, path)\n\t\treturn\n\t}\n\tfor i := index; i < n; i++ {\n\t\tif num[index] == '0' && i != index {\n\t\t\treturn\n\t\t}\n\t\tcurrStr := num[index : i+1]\n\t\tcurr, _ := strconv.Atoi(currStr)\n\t\tif index == 0 {\n\t\t\tdfs(currStr, i+1, curr, curr)\n\t\t} else {\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result+curr, curr)\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result-curr, -curr)\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result-pre+pre*curr, pre*curr)\n\t\t}\n\t}\n}\ndfs(\"STR\", 0, 0, 0)\nreturn res", "gen": "fmt.Println(addOperators(\"123+567\", 1000))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: \"STR\",\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: \"STR\",\n\t},\n}\nfor _, tt := range tests {\n\tgot := defangIPaddr(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(defangIPaddr(\"1.0.0.0\"))\nfmt.Println(defangIPaddr(\"255.100.50.0\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"10.0.0.255\"))\nfmt.Println(defangIPaddr(\"172.16.10.1\"))\nfmt.Println(defangIPaddr(\"169.254.255.254\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"192.168.0"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := Base64DecodeDelegate(tc.base64); res != tc.decoded {\n\t\tt.Errorf(\"STR\", tc.decoded, res)\n\t}\n}", "gen": "fmt.Println(\"Day 382\")\nfmt.Println(\"Puzzle 1:\", puzzle1())\nfmt.Println(\"Puzzle 2:\", puzzle2())\n}\n"}
{"tgt": "qs := []question1207{\n\t{\n\t\tpara1207{[]int{1, 2, 2, 1, 1, 3}},\n\t\tans1207{true},\n\t},\n\t{\n\t\tpara1207{[]int{1, 2}},\n\t\tans1207{false},\n\t},\n\t{\n\t\tpara1207{[]int{-3, 0, 1, -3, 1, 1, 1, -3, 10, 0}},\n\t\tans1207{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1207, q.para1207\n\tfmt.Printf(\"STR\", p, uniqueOccurrences(p.arr))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "max := -1001\nmax1 := -1001\nmax2 := -1001\nmin1 := 1001\nmin2 := 1001\nfor _, n := range nums {\n\tswitch {\n\tcase n > max:\n\t\tmax2, max1, max = max1, max, n\n\tcase n > max1:\n\t\tmax2, max1 = max1, n\n\tcase n > max2:\n\t\tmax2 = n\n\t}\n\tswitch {\n\tcase n < min1:\n\t\tmin2, min1 = min1, n\n\tcase n < min2:\n\t\tmin2 = n\n\t}\n}\nreturn bigger(max1*max2, min1*min2) * max", "gen": "var a, b, c int\nfmt.Scan(&a, &b, &c)\nfmt.Println(bigger(a, b, c))\n}"}
{"tgt": "var ret float64\nvar x float64\nvar n int\nret = 0\nx = 0.00001\nn = 2147483647\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 1.0000\nx = 2\nn = 0\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 10.0000\nx = 10.0000\nn = 1\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 0.25000\nx = 2.0000\nn = -2\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "for len(w.data) > 0 && w.data[len(w.data)-1] < n {\n\tw.data = w.data[0 : len(w.data)-1]\n}\nw.data = append(w.data, n)", "gen": "var a [10]int\nvar b [10]int\na[0] = 1\nb[0] = 2\na[1] = 3\nb[1] = 4\na[2] = 5\nb[2] = 6\na[3] = 7\nb[3] = 8\na[4] = 9\nb[4] = 10\na[5] = 11\nb[5] = 12\na[6] = 13\nb[6] = 14\na[7] = 15\nb[7] = 16\na[8] = 17\nb[8] = 18\na[9] = 19\nb[9] = 20\na[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9] = b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8], b[9]\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "n := 0\ntmp := head\nfor tmp != nil {\n\tn++\n\ttmp = tmp.Next\n}\nreturn helper(&head, 0, n-1)", "gen": "var nums = []int{1, 2, 3}\nroot := sortedListToBST(nums)\nfmt.Println(root)\n}\n"}
{"tgt": "const templ = `<p>A:{{.A}}</p><p>B:{{.B}}</p>`\nt := template.Must(template.New(\"STR\").Parse(templ))\nvar data struct {\n\tA string\n\tBtemplate.HTML\n}\ndata.A = \"STR\"\ndata.B = \"STR\"\nif err := t.Execute(os.Stdout, data); err != nil {\n\tlog.Fatal(err)\n}", "gen": "t := template.New(\"\")\nt, err := t.Parse(\"<html><body>{{.}}</body></html>\")\nif err != nil {\n\tlog.Fatal(err)\n}\nvar buf bytes.Buffer\nerr = t.Execute(&buf, \"hello, world\")\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Println(buf.String())\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(A) == len(A[0]) {\n\tfor i := 0; i < len(A); i++ {\n\t\tfor j := 0; j < len(A); j++ {\n\t\t\tif i == j {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]\n\t\t}\n\t}\n\treturn A\n}\nres := make([][]int, len(A[0]))\nfor i := 0; i < len(res); i++ {\n\tres[i] = make([]int, len(A))\n\tfor j := 0; j < len(A); j++ {\n\t\tres[i][j] = A[j][i]\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "out := make(map[string]string)\nmain_pieces := strings.Split(s, sep1)\nfor _, piece := range main_pieces {\n\tminor_pieces := strings.Split(piece, sep2)\n\tout[minor_pieces[0]] = minor_pieces[1]\n}\nreturn out", "gen": "var m map[string]string\nvar s string\nvar a []string\nvar b []string\nvar c string\nvar d string\nvar e string\nvar f string\nvar g string\nvar h string\nvar i string\nvar j string\nvar k string\nvar l string\nvar m map[string]string\nvar s string\nvar a []string\nvar b []string\nvar c string\nvar d string\nvar e string\nvar f string\nvar g string\nvar h string\nvar i string\nvar j string\nvar k string\nvar l string\nvar m map[string]string\nvar s string\nvar a []string\nvar b []string\nvar c string\nvar d string\nvar e string\nvar f string\nvar g string\nvar h string\nvar i string\nvar j string\nvar k string\nvar l string\nvar m map[string]string\nvar s string\nvar a []string\nvar b []string\nvar c string\nvar d string\nvar e string\nvar f string\nvar g string\nvar h string\nvar i string\nvar j string\nvar k string\nvar l string\nvar m map[string]string\nvar s string\nvar a []string\nvar b []string\nvar c string\nvar d string\nvar e string\nvar f string\nvar g string\nvar h string\nvar i string\nvar j string\nvar k string\nvar l string\nvar m map[string]string\nvar s string\nvar a []string\nvar b []string\nvar c string\nvar d string\nvar e string\nvar f string\nvar g string\nvar h string\nvar i string\nvar j string\nvar k string\nvar l string\nvar m map[string]string\nvar s string\nvar a []string\nvar b []string\nvar c string\nvar d string\nvar e string\nvar f"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CountLargerAndSmallerBrute(tc.mat, tc.i1, tc.j1, tc.i2, tc.j2); result != tc.count {\n\t\tt.Errorf(\"STR\", tc.count, result)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "size := len(a)\nlo, hi := 0, size-1\nvar miD, miA int\nfor lo <= hi {\n\tmiD = (lo + hi) / 2\n\tmiA = size - miD - 1\n\tif a[miA] > miD {\n\t\tlo = miD + 1\n\t} else {\n\t\thi = miD - 1\n\t}\n}\nreturn lo", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfmt.Println(a[9])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "l1, l2 := []int{}, []int{}\ndfs(root1, &l1)\ndfs(root2, &l2)\nif len(l1) != len(l2) {\n\treturn false\n}\nfor i, _ := range l1 {\n\tif l1[i] != l2[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [2]int\nvar b [2]int\nvar c [2]int\nvar d [2]int\nvar e [2]int\nvar f [2]int\nvar g [2]int\nvar h [2]int\nvar i [2]int\nvar j [2]int\nvar k [2]int\nvar l [2]int\nvar m [2]int\nvar n [2]int\nvar o [2]int\nvar p [2]int\nvar q [2]int\nvar r [2]int\nvar s [2]int\nvar t [2]int\nvar u [2]int\nvar v [2]int\nvar w [2]int\nvar x [2]int\nvar y [2]int\nvar z [2]int\nvar aa [2]int\nvar ab [2]int\nvar ac [2]int\nvar ad [2]int\nvar ae [2]int\nvar af [2]int\nvar ag [2]int\nvar ah [2]int\nvar ai [2]int\nvar aj [2]int\nvar ak [2]int\nvar al [2]int\nvar am [2]int\nvar an [2]int\nvar ao [2]int\nvar ap [2]int\nvar aq [2]int\nvar ar [2]int\nvar as [2]int\nvar at [2]int\nvar au [2]int\nvar av [2]int\nvar aw [2]int\nvar ax [2]int\nvar ay [2]int\nvar az [2]int\nvar aa [2]int\nvar ab [2]int\nvar ac [2]int\nvar ad [2]int\nvar ae [2]int\nvar af [2]int\nvar ag [2]int\nvar ah [2]int\nvar ai [2]int\nvar aj [2]int\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result, err := ShortestRunnerPath(tc.elevations, tc.paths); result != tc.shortestRoute || err != tc.err {\n\t\tt.Errorf(\"STR\", tc.shortestRoute, tc.err, result, err)\n\t}\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "sLen, pLen := len(s), len(p)\ndp := make([][]bool, sLen+1)\nfor i := range dp {\n\tdp[i] = make([]bool, pLen+1)\n}\ndp[sLen][pLen] = true\nfor i := sLen; i > -1; i-- {\n\tfor j := pLen - 1; j > -1; j-- {\n\t\tfirstMatch := i < sLen && (p[j] == s[i] || p[j] == '.')\n\t\tif j+1 < pLen && p[j+1] == '*' {\n\t\t\tdp[i][j] = dp[i][j+2] || firstMatch && dp[i+1][j]\n\t\t} else {\n\t\t\tdp[i][j] = firstMatch && dp[i+1][j+1]\n\t\t}\n\t}\n}\nreturn dp[0][0]", "gen": "var a [3]bool\nvar b [3]bool\nvar c [3]bool\nvar d [3]bool\nvar e [3]bool\nvar f [3]bool\nvar g [3]bool\nvar h [3]bool\nvar i [3]bool\nvar j [3]bool\nvar k [3]bool\nvar l [3]bool\nvar m [3]bool\nvar n [3]bool\nvar o [3]bool\nvar p [3]bool\nvar q [3]bool\nvar r [3]bool\nvar s [3]bool\nvar t [3]bool\nvar u [3]bool\nvar v [3]bool\nvar w [3]bool\nvar x [3]bool\nvar y [3]bool\nvar z [3]bool\nvar aa [3]bool\nvar bb [3]bool\nvar cc [3]bool\nvar dd [3]bool\nvar ee [3]bool\nvar ff [3]bool\nvar gg [3]bool\nvar hh [3]bool\nvar ii [3]bool\nvar jj [3]bool\nvar kk [3]bool\nvar ll [3]bool\nvar mm [3]bool\nvar nn [3]bool\nvar oo [3]bool\nvar pp [3]bool\nvar qq [3]bool\nvar rr [3]bool\nvar ss [3]bool\nvar tt [3]bool\nvar uu [3]bool\nvar vv [3]bool\nvar ww [3]bool\nvar xx [3]bool\nvar yy [3]bool\nvar zz [3]bool\nvar aaa [3]bool\nvar bbb [3]bool\nvar ccc [3]bool\nvar ddd [3]bool\nvar eee [3]bool\nvar fff [3]bool\nvar ggg [3]bool\nvar hhh [3]"}
{"tgt": "sort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].End < intervals[j].End\n})\ncount := 0\ncurrent := -int(^uint(0)>>1) - 1\nfor _, interval := range intervals {\n\tif interval.Start >= current {\n\t\tcount++\n\t\tcurrent = interval.End\n\t}\n}\nreturn len(intervals) - count", "gen": "var intervals = []Interval{{1, 3}, {2, 4}, {3, 5}, {4, 6}, {5, 7}}\nvar res = MinRemoveNoOverlap(intervals)\nfmt.Println(res)\n}\n"}
{"tgt": "i := len(nums) - 2\nfor i >= 0 && nums[i] >= nums[i+1] {\n\ti--\n}\nj, k := i+1, len(nums)-1\nfor j < k {\n\tnums[j], nums[k] = nums[k], nums[j]\n\tj, k = j+1, k-1\n}\nif i >= 0 {\n\tj = i + 1\n\tfor nums[j] <= nums[i] {\n\t\tj++\n\t}\n\tnums[i], nums[j] = nums[j], nums[i]\n}", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar bb [10]int\nvar cc [10]int\nvar dd [10]int\nvar ee [10]int\nvar ff [10]int\nvar gg [10]int\nvar hh [10]int\nvar ii [10]int\nvar jj [10]int\nvar kk [10]int\nvar ll [10]int\nvar mm [10]int\nvar nn [10]int\nvar oo [10]int\nvar pp [10]int\nvar qq [10]int\nvar rr [10]int\nvar ss [10]int\nvar tt [10]int\nvar uu [10]int\nvar vv [10]int\nvar ww [10]int\nvar xx [10]int\nvar yy [10]int\nvar zz [10]int\nvar aaa [10]int\nvar bbb [10]"}
{"tgt": "denoms := make(map[int]struct{})\nfor d, way := range ways {\n\tif others := waysToProduce(d, denoms); (way == 1 && d > 0) || others == way-1 {\n\t\tdenoms[d] = struct{}{}\n\t}\n}\nres := make([]int, 0, len(denoms))\nfor k := range denoms {\n\tres = append(res, k)\n}\nsort.Ints(res)\nreturn res", "gen": "var a []int\nvar b []int\nvar c []int\na = make([]int, 0)\nb = make([]int, 0)\nc = make([]int, 0)\nfor i := 0; i < 1000000; i++ {\n\twaysToProduce(a, b, c)\n}\nfmt.Println(a[0], b[0], c[0])\n}"}
{"tgt": "return len(self.data)", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\nfor i := 0;"}
{"tgt": "var ri, gi int\nfor i, r := range letters {\n\tif r == 'R' {\n\t\tletters[i] = letters[gi]\n\t\tletters[gi] = letters[ri]\n\t\tletters[ri] = r\n\t\tgi++\n\t\tri++\n\t} else if r == 'G' {\n\t\tletters[i] = letters[gi]\n\t\tletters[gi] = r\n\t\tgi++\n\t}\n}", "gen": "var a [3][3]int\nfor i := 0; i < 3; i++ {\n\tfor j := 0; j < 3; j++ {\n\t\ta[i][j] = i + j\n\t}\n}\nfor i := 0; i < 3; i++ {\n\tfor j := 0; j < 3; j++ {\n\t\tfmt.Printf(\"%d \", a[i][j])\n\t}\n\tfmt.Printf(\"\\n\")\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "switch rand.Intn(10) {\ncase 1, 9:\n\treturn io.EOF\ncase 5:\n\treturn errors.New(\"STR\")\ndefault:\n\td.Line = \"STR\"\n\tfmt.Println(\"STR\", d.Line)\n\treturn nil\n}", "gen": "var s string\nvar i int\nfmt.Scan(&s, &i)\nif i == 0 {\n\tfmt.Println(s)\n} else if i == 1 {\n\tfmt.Println(s + \"1\")\n} else if i == 2 {\n\tfmt.Println(s + \"2\")\n} else if i == 3 {\n\tfmt.Println(s + \"3\")\n} else if i == 4 {\n\tfmt.Println(s + \"4\")\n} else if i == 5 {\n\tfmt.Println(s + \"5\")\n} else if i == 6 {\n\tfmt.Println(s + \"6\")\n} else if i == 7 {\n\tfmt.Println(s + \"7\")\n} else if i == 8 {\n\tfmt.Println(s + \"8\")\n} else if i == 9 {\n\tfmt.Println(s + \"9\")\n} else {\n\tpanic(errors.New(\"i must be between 0 and 9\"))\n}\n}\n"}
{"tgt": "return helper(root, p, q)", "gen": "helper(1, 2)\n}"}
{"tgt": "benchmark(bb, 16384, 0.1)", "gen": "benchmark()\n}\n"}
{"tgt": "this.mutex.Lock()\ndefer this.mutex.Unlock()\nif priority < 0 || priority > this.max {\n\treturn nil\n}\nreturn this.queues[priority].Peek()", "gen": "var m sync.Mutex\nvar q Queue\nvar wg sync.WaitGroup\nwg.Add(1)\ngo func() {\n\tdefer wg.Done()\n\tm.Lock()\n\tdefer m.Unlock()\n\tq.Push(1)\n\tq.Push(2)\n\tq.Push(3)\n\tq.Push(4)\n\tq.Push(5)\n\tq.Push(6)\n\tq.Push(7)\n\tq.Push(8)\n\tq.Push(9)\n\tq.Push(10)\n\tq.Push(11)\n\tq.Push(12)\n\tq.Push(13)\n\tq.Push(14)\n\tq.Push(15)\n\tq.Push(16)\n\tq.Push(17)\n\tq.Push(18)\n\tq.Push(19)\n\tq.Push(20)\n\tq.Push(21)\n\tq.Push(22)\n\tq.Push(23)\n\tq.Push(24)\n\tq.Push(25)\n\tq.Push(26)\n\tq.Push(27)\n\tq.Push(28)\n\tq.Push(29)\n\tq.Push(30)\n\tq.Push(31)\n\tq.Push(32)\n\tq.Push(33)\n\tq.Push(34)\n\tq.Push(35)\n\tq.Push(36)\n\tq.Push(37)\n\tq.Push(38)\n\tq.Push(39)\n\tq.Push(40)\n\tq.Push(41)\n\tq.Push(42)\n\tq.Push(43)\n\tq.Push(44)\n\tq"}
{"tgt": "if i < 0 || i >= itemKind(len(_itemKind_index)-1) {\n\treturn fmt.Sprintf(\"STR\", i)\n}\nreturn _itemKind_name[_itemKind_index[i]:_itemKind_index[i+1]]", "gen": "var r *httprange.Range\nr = &httprange.Range{}\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr.itemKind = 0\nr"}
{"tgt": "arr := randomSlice(0, 20, 10)\nnodeCnt := 0\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\nrotateNodes := make([]*gbtElement, 0, 0)\ngbt.InOrderWalk(gbt.Root(), func(GBTbinaryTreeIf, node interface{}) bool {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\trotateNodes = append(rotateNodes, node.(*gbtElement))\n\t}\n\treturn false\n})\nfor _, v := range rotateNodes {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\tgbt.LeftRotate(v)\n\t} else {\n\t\tgbt.RightRotate(v)\n\t}\n}\ngbt.InOrderWalk(gbt.Root(), checkGBT(t, &nodeCnt, *debug))\nif nodeCnt != len(arr) {\n\tt.Log(fmt.Sprintf(\"STR\", len(arr), nodeCnt))\n\tt.Fail()\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := InversionCountBrute(tc.input); result != tc.inversions {\n\t\tt.Errorf(\"STR\", tc.inversions, result)\n\t}\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "fmt.Println(subarrayBitwiseORs([]int{0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))", "gen": "var a = []int{1, 1, 2, 3, 3}\nvar b = []int{1, 2, 4}\nvar c = []int{1, 1, 3, 3}\nvar d = []int{1, 2, 3}\nfmt.Println(subarrayBitwiseORs(a))\nfmt.Println(subarrayBitwiseORs(b))\nfmt.Println(subarrayBitwiseORs(c))\nfmt.Println(subarrayBitwiseORs(d))\n}\n"}
{"tgt": "if nil == root {\n\treturn []int{}\n}\nlargestVals := []int{}\nchildren := []*TreeNode{root}\nfor len(children) > 0 {\n\ttmp := children[:]\n\tchildren = []*TreeNode{}\n\tlargest := -(1 << 32)\n\tfor _, child := range tmp {\n\t\tif child.Val > largest {\n\t\t\tlargest = child.Val\n\t\t}\n\t\tif nil != child.Left {\n\t\t\tchildren = append(children, child.Left)\n\t\t}\n\t\tif nil != child.Right {\n\t\t\tchildren = append(children, child.Right)\n\t\t}\n\t}\n\tlargestVals = append(largestVals, largest)\n}\nreturn largestVals", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aaa [3]int\nvar aab [3]int\nvar aac [3]int\nvar aad [3]int\nvar aae [3]int\nvar aaf [3]int\nvar aag [3]int\nvar aah [3]int\nvar aai [3]int\n"}
{"tgt": "{\n\tdata, err := json.Marshal(movies)\n\tif err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Printf(\"STR\", data)\n}\n{\n\tdata, err := json.MarshalIndent(movies, \"STR\")\n\tif err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Printf(\"STR\", data)\n\tvar titles []struct{ Title string }\n\tif err := json.Unmarshal(data, &titles); err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Println(titles)\n}", "gen": "movies := []Movie{\n\t{Title: \"Casablanca\", Year: 1942, Color: false},\n\t{Title: \"Cool Hand Luke\", Year: 1966, Color: true},\n\t{Title: \"Bullitt\", Year: 1968, Color: true},\n}\nb, err := json.Marshal(movies)\nif err != nil {\n\tlog.Fatal(err)\n}\nvar movies2 []Movie\nerr = json.Unmarshal(b, &movies2)\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Printf(\"%s\\n\", b)\nfmt.Printf(\"%s\\n\", movies2)\n}\n\n// Output:\n// [{\"Title\":\"Casablanca\",\"Year\":1942,\"Color\":false},{\"Title\":\"Cool Hand Luke\",\"Year\":1966,\"Color\":true},{\"Title\":\"Bullitt\",\"Year\":1968,\"Color\":true}]\n// [{Casablanca 1942 false} {Cool Hand Luke 1966 true} {Bullitt 1968 true}]\n\n```\n\n### 2. \u7f16\u8bd1\u5668\u4f18\u5316\n\n```go\npackage main\n\nimport (\n\"encoding/json\"\n\"fmt\"\n\"log\"\n)\n\ntype Movie struct {\nTitle string\nYear  int\nColor bool\n}\n"}
{"tgt": "if num <= 0 {\n\treturn false\n}\nif num&(num-1) != 0 {\n\treturn false\n}\nif num&0x55555555 == 0 {\n\treturn false\n}\nreturn true", "gen": "var x int\nfor i := 0; i < 1000000000; i++ {\n\tx = i\n\tif x%2 == 0 {\n\t\tx = x & 1431655765\n\t} else {\n\t\tx = x & 1431655765\n\t}\n}\nprintln(x)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "major := uint32((dev & 0x00000000000fff00) >> 8)\nmajor |= uint32((dev & 0xfffff00000000000) >> 32)\nreturn major", "gen": "var a int\na = 1\nfmt.Println(a)\n}\n\n<ASM>\n.LFB0:\ncmpq %fs:112,%rsp\njnb .L3\nmovl $8,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L3:\npushq %rbp\nmovq %rsp,%rbp\nmovq %rdi,-24(%rbp)\nmovl $0,-4(%rbp)\n.LBB2:\nmovq -24(%rbp),%rax\nandl $1048320,%eax\nshrq $8,%rax\nmovl %eax,-8(%rbp)\nmovabsq $-17592186044416,%rax\nandq -24(%rbp),%rax\nshrq $32,%rax\norl %eax,-8(%rbp)\n.LBB3:\nmovl -8(%rbp),%eax\nmovl %eax,-4(%rbp)\nmovl -4(%rbp),%eax\n.LBE3:\n.LBE2:\npopq %rbp\nret</ASM>"}
{"tgt": "t.Parallel()\nvar ba BitArray\nfor _, tc := range testcases {\n\tba.Init(tc.size)\n\tfor index, val := range tc.ones {\n\t\tif err := ba.Set(index, val); err != nil {\n\t\t\tt.Errorf(\"STR\")\n\t\t}\n\t}\n\tfor i := 0; i < tc.size; i++ {\n\t\tif val, err := ba.Get(i); err != nil {\n\t\t\tt.Errorf(\"STR\", err)\n\t\t} else if tc.ones[i] != val {\n\t\t\tt.Errorf(\"STR\", tc.ones[i], val, i)\n\t\t}\n\t}\n}", "gen": "testing.MainStart(nil, nil, nil)\ntesting.MainEnd()\n}\n"}
{"tgt": "if a == b {\n\treturn -1\n}\nif len(a) > len(b) {\n\treturn len(a)\n}\nreturn len(b)", "gen": "var a, b, c string\nvar d int\na = \"abc\"\nb = \"abc\"\nc = \"abc\"\nd = 1\nif a == b {\n\tif a == c {\n\t\tif a == d {\n\t\t\tfmt.Println(\"a == b && a == c && a == d\")\n\t\t} else {\n\t\t\tfmt.Println(\"a == b && a == c && a != d\")\n\t\t}\n\t} else {\n\t\tfmt.Println(\"a == b && a != c\")\n\t}\n} else {\n\tfmt.Println(\"a != b\")\n}\n}\n"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil {\n\t\t\tmax = max.Right\n\t\t}\n\t\tmax.Right = root\n\t\troot, root.Left = root.Left, nil\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 4\nb[1] = 5\nb[2] = 6\nc[0] = 7\nc[1] = 8\nc[2] = 9\na = append(a, b...)\na = append(a, c...)\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if a > b {\n\treturn b\n}\nreturn a", "gen": "var a, b int\nif a < b {\n\ta = b\n}\nprintln(a)\n}\n\n// 0x0000000000000000 <main>:\n// 0:\t55                   \tpush   %rbp\n// 1:\t48 89 e5             \tmov    %rsp,%rbp\n// 4:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// 8:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// c:\t48 89 7d f0          \tmov    %rdx,-0x18(%rbp)\n// f:\t48 89 75 e8          \tmov    %rsi,-0x20(%rbp)\n// 13:\t48 89 7d e0          \tmov    %rdi,-0x28(%rbp)\n// 17:\t48 89 75 d8          \tmov    %rsi,-0x30(%rbp)\n// 1b:\t48 89 7d d0          \tmov    %rdi,-0x38(%rbp)\n// 1f:\t48 89 75 c8          \tmov    %rsi,-0x40(%rbp)\n// 23:\t48 89 7d c0          \tmov    %rdi,-0x48(%rbp)\n// 27:\t48 89 75 b8          \tmov    %rsi,-0x50(%rbp)\n// 2b:\t48 89 7d b0          \tmov    %rdi,-0x58(%rbp)\n// 2f:\t48 89 75 a8          \tmov    %rsi,-0x60(%rbp)\n// 33:\t48 89 7d a0"}
{"tgt": "var buf bytes.Buffer\nif err := encode(&buf, reflect.ValueOf(v)); err != nil {\n\treturn nil, err\n}\nreturn buf.Bytes(), nil", "gen": "var buf bytes.Buffer\nbuf.WriteString(\"hello\")\nfmt.Println(buf.Bytes())\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "m := map[byte]struct{}{}\nfor i := range J {\n\tm[J[i]] = struct{}{}\n}\nres := 0\nfor i := range S {\n\tif _, ok := m[S[i]]; ok {\n\t\tres++\n\t}\n}\nreturn res", "gen": "var m map[uint8]struct{}\nvar s string\nvar i int\nvar j int\nm = make(map[uint8]struct{})\nfor i = 0; i < 1000; i++ {\n\tfor j = 0; j < 1000; j++ {\n\t\ts = string(i) + string(j)\n\t\tm[s[0]] = struct{}{}\n\t}\n}\nfmt.Println(len(m))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if numRows < 2 {\n\treturn s\n}\nmaxInterval := (numRows - 1) << 1\ninterval := maxInterval\nafter := \"STR\"\nfor i := 0; i < numRows; i++ {\n\tif numRows-1 == i {\n\t\tinterval = maxInterval\n\t}\n\tfor j, no := i, 0; j < len(s); no++ {\n\t\tafter += string(s[j])\n\t\tif i > 0 && i < numRows-1 && 1 == no&1 {\n\t\t\tj += maxInterval - interval\n\t\t\tcontinue\n\t\t}\n\t\tj += interval\n\t}\n\tinterval -= 2\n}\nreturn after", "gen": "var a [10]int\nvar b [10]int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\n"}
{"tgt": "var result []string\ndfs(s, []string{}, &result)\nreturn result", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\n"}
{"tgt": "if n < 7 {\n\treturn int64(n + 1)\n}\nans := (1 + int64(n%7)) * row(n/7)\nreturn ans", "gen": "var a [6]int\nvar i int\nfor i = 0; i < 6; i++ {\n\ta[i] = row(i)\n}\nfmt.Println(a)\n}"}
{"tgt": "if len(mat) == 0 || len(mat[0]) == 0 {\n\treturn []int{}\n}\nm, n := len(mat), len(mat[0])\nisUpping := true\nnext := func(i, j int) (int, int) {\n\tif isUpping {\n\t\ti--\n\t\tj++\n\t\tif 0 <= i && j < n {\n\t\t\treturn i, j\n\t\t}\n\t\tisUpping = false\n\t\tif i < 0 && j < n {\n\t\t\treturn 0, j\n\t\t}\n\t\treturn i + 2, j - 1\n\t}\n\ti++\n\tj--\n\tif i < m && 0 <= j {\n\t\treturn i, j\n\t}\n\tisUpping = true\n\tif i < m && j < 0 {\n\t\treturn i, 0\n\t}\n\treturn i - 1, j + 2\n}\nmn := m * n\nres := make([]int, mn)\ni, j := 0, 0\nfor k := 0; k < mn; k++ {\n\tres[k] = mat[i][j]\n\ti, j = next(i, j)\n}\nreturn res", "gen": "var a [3][3]int\nvar b [3][3]int\nvar c [3][3]int\nvar d [3][3]int\nvar e [3][3]int\nvar f [3][3]int\nvar g [3][3]int\nvar h [3][3]int\nvar i [3][3]int\nvar j [3][3]int\nvar k [3][3]int\nvar l [3][3]int\nvar m [3][3]int\nvar n [3][3]int\nvar o [3][3]int\nvar p [3][3]int\nvar q [3][3]int\nvar r [3][3]int\nvar s [3][3]int\nvar t [3][3]int\nvar u [3][3]int\nvar v [3][3]int\nvar w [3][3]int\nvar x [3][3]int\nvar y [3][3]int\nvar z [3][3]int\nvar aa [3][3]int\nvar ab [3][3]int\nvar ac [3][3]int\nvar ad [3][3]int\nvar ae [3][3]int\nvar af [3][3]int\nvar ag [3][3]int\nvar ah [3][3]int\nvar ai [3][3]int\nvar aj [3][3]int\nvar ak [3][3]int\nvar al [3][3]int\nvar am [3][3]int\nvar an [3][3]int\nvar ao [3][3]int\nvar ap [3][3]int\nvar aq [3][3]int\nvar ar [3][3]int\nvar as [3][3]int\nvar at [3][3]int\nvar au [3][3]int\nvar av [3][3]int\nvar aw [3][3]int\nvar ax [3][3]"}
{"tgt": "n := len(quality)\nworkers := make([][2]float64, n)\nfor i := 0; i < n; i++ {\n\tw, q := float64(wage[i]), float64(quality[i])\n\tworkers[i][0], workers[i][1] = w/q, q\n}\nsort.Slice(workers, func(i, j int) bool {\n\treturn workers[i][0] < workers[j][0]\n})\nres := math.MaxFloat64\nsum := 0.\nh := floatHeap{}\nfor _, w := range workers {\n\tsum += w[1]\n\theap.Push(&h, w[1])\n\tif len(h) > K {\n\t\tsum -= heap.Pop(&h).(float64)\n\t}\n\tif len(h) == K {\n\t\tres = min(res, sum*w[0])\n\t}\n}\nreturn res", "gen": "fmt.Println(mincostToHireWorkers([]int{10, 20, 5}, []int{7, 15, 20}))\n}\n"}
{"tgt": "t.Parallel()\nlfu := NewLFUCache(3)\nlfu.Set(\"STR\", \"STR\")\nlfu.Set(1, 2)\nlfu.Set(\"STR\", \"STR\")\nlfu.Get(1)\nlfu.Get(\"STR\")\nlfu.Set(100, 1)\nif result := lfu.Get(\"STR\"); result != nil {\n\tt.Errorf(\"STR\", result)\n}\nif result := lfu.Get(1); result == nil {\n\tt.Errorf(\"STR\")\n}\nif result := lfu.Get(\"STR\"); result == nil {\n\tt.Errorf(\"STR\")\n}\nif result := lfu.Get(100); result == nil {\n\tt.Errorf(\"STR\")\n}\nlfu.Set(100, \"STR\")\nif result := lfu.Get(100); result.(string) != \"STR\" {\n\tt.Errorf(\"STR\")\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "m := len(pattern)\nnext := make([]int, m)\nfor index := range next {\n\tnext[index] = -1\n}\nfor i := 1; i < m-1; i++ {\n\tj := next[i-1]\n\tfor pattern[j+1] != pattern[i] && j >= 0 {\n\t\tj = next[j]\n\t}\n\tif pattern[j+1] == pattern[i] {\n\t\tj += 1\n\t}\n\tnext[i] = j\n}\nreturn next", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := AllPossibleSubsequences(tc.input); !reflect.DeepEqual(result, tc.subseq) {\n\t\tt.Errorf(\"STR\", tc.subseq, result)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 3, 4, 2, 2}, 2},\n\t{\"STR\", []int{3, 1, 3, 4, 2}, 3},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := findDuplicate(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "cases := []struct {\n\tname    string\n\tinputs  []int\n\texpects bool\n}{\n\t{\"STR\", []int{1, 2, 3, 1}, true},\n\t{\"STR\", []int{1, 2, 3, 4}, false},\n\t{\"STR\", []int{1, 1, 1, 3, 3, 4, 3, 2, 4, 2}, true},\n}\nfor _, testcase := range cases {\n\tt.Run(testcase.name, func(t *testing.T) {\n\t\tresult := containsDuplicate(testcase.inputs)\n\t\tif !reflect.DeepEqual(result, testcase.expects) {\n\t\t\tt.Fatalf(\"STR\", testcase.expects, result, testcase.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "arr := randomSlice(0, 20, 10)\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\ncheckGBTPreOrder(t, gbt, arr)", "gen": "var t *binaryTree\nt = new(binaryTree)\nt.root = new(binaryTreeNode)\nt.root.value = 10\nt.root.left = new(binaryTreeNode)\nt.root.left.value = 20\nt.root.right = new(binaryTreeNode)\nt.root.right.value = 30\nt.root.left.left = new(binaryTreeNode)\nt.root.left.left.value = 40\nt.root.left.right = new(binaryTreeNode)\nt.root.left.right.value = 50\nt.root.right.left = new(binaryTreeNode)\nt.root.right.left.value = 60\nt.root.right.right = new(binaryTreeNode)\nt.root.right.right.value = 70\nt.root.left.left.left = new(binaryTreeNode)\nt.root.left.left.left.value = 80\nt.root.left.left.right = new(binaryTreeNode)\nt.root.left.left.right.value = 90\nt.root.left.right.left = new(binaryTreeNode)\nt.root.left.right.left.value = 100\nt.root.left.right.right = new(binaryTreeNode)\nt.root.left.right.right.value = 110\nt.root.right.left.left = new(binaryTreeNode)\nt.root.right.left.left.value = 120\nt.root.right.left.right = new(binaryTreeNode)\nt.root.right.left.right.value = 130\nt.root.right.right.left = new(binaryTreeNode)\nt.root.right.right.left.value = 140\nt.root.right.right.right = new(binaryTreeNode)\nt.root.right.right.right.value = 1"}
{"tgt": "fmt.Println(maxDistToClosest([]int{1, 0, 0, 0, 1, 0, 1}))\nfmt.Println(maxDistToClosest([]int{1, 0, 0, 0}))\nfmt.Println(maxDistToClosest([]int{0, 1}))\nfmt.Println(maxDistToClosest([]int{0, 1, 1, 1, 0, 0, 1, 0, 0}))\nfmt.Println(maxDistToClosest([]int{0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0}))", "gen": "fmt.Println(maxDistToClosest([]int{1, 2, 3, 4}))\nfmt.Println(maxDistToClosest([]int{1, 4, 2, 3}))\nfmt.Println(maxDistToClosest([]int{1, 1, 1, 1}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14"}
{"tgt": "iE := i.(*ltHeapElement)\njE := j.(*ltHeapElement)\nif iE == nil {\n\treturn jE\n}\nif jE == nil {\n\treturn iE\n}\nif h.Key(iE) < h.Key(jE) {\n\th.Swap(&iE, &jE)\n}\niE.right = h.merge(iE.right, jE).(*ltHeapElement)\nif iE.left == nil || iE.right.dist > iE.left.dist {\n\th.Swap(&iE.left, &iE.right)\n}\nif iE.right == nil {\n\tiE.dist = 0\n} else {\n\tiE.dist = iE.right.dist + 1\n}\nreturn iE", "gen": "var h go.heap.ltHeapArray\nh.Init()\nh.Push(go.heap.ltHeapElement{1})\nh.Push(go.heap.ltHeapElement{2})\nh.Push(go.heap.ltHeapElement{3})\nh.Push(go.heap.ltHeapElement{4})\nh.Push(go.heap.ltHeapElement{5})\nh.Push(go.heap.ltHeapElement{6})\nh.Push(go.heap.ltHeapElement{7})\nh.Push(go.heap.ltHeapElement{8})\nh.Push(go.heap.ltHeapElement{9})\nh.Push(go.heap.ltHeapElement{10})\nh.Push(go.heap.ltHeapElement{11})\nh.Push(go.heap.ltHeapElement{12})\nh.Push(go.heap.ltHeapElement{13})\nh.Push(go.heap.ltHeapElement{14})\nh.Push(go.heap.ltHeapElement{15})\nh.Push(go.heap.ltHeapElement{16})\nh.Push(go.heap.ltHeapElement{17})\nh.Push(go.heap.ltHeapElement{18})\nh.Push(go.heap.ltHeapElement{19})\nh.Push(go.heap.ltHeapElement{20})\nh.Push(go.heap.ltHeapElement{21})\nh.Push(go.heap.ltHeapElement{22})\nh.Push(go.heap.ltHeapElement{23})\nh.Push(go.heap.ltHeapElement{24})\nh.Push(go.heap.ltHeapElement{25})\nh.Push(go.heap.ltHeapElement{"}
{"tgt": "result := MakeMatrix(make([]float64, A.cols*A.rows), A.cols, A.rows)\nfor i := 0; i < A.rows; i++ {\n\tfor j := 0; j < A.cols; j++ {\n\t\tsum := float64(0)\n\t\tfor k := 0; k < A.cols; k++ {\n\t\t\tsum += A.GetElm(i, k) * B.GetElm(k, j)\n\t\t}\n\t\tresult.SetElm(i, j, sum)\n\t}\n}\nreturn result", "gen": "var a, b, c matrix.Matrix\na.MakeMatrix(2, 2)\nb.MakeMatrix(2, 2)\nc.MakeMatrix(2, 2)\na.SetElm(0, 0, 1)\na.SetElm(0, 1, 2)\na.SetElm(1, 0, 3)\na.SetElm(1, 1, 4)\nb.SetElm(0, 0, 5)\nb.SetElm(0, 1, 6)\nb.SetElm(1, 0, 7)\nb.SetElm(1, 1, 8)\nc.SetElm(0, 0, 9)\nc.SetElm(0, 1, 10)\nc.SetElm(1, 0, 11)\nc.SetElm(1, 1, 12)\na.Mul(&b, &c)\nfmt.Println(c.GetElm(0, 0))\nfmt.Println(c.GetElm(0, 1))\nfmt.Println(c.GetElm(1, 0))\nfmt.Println(c.GetElm(1, 1))\n}\n"}
{"tgt": "if head == nil {\n\treturn nil\n}\neven := head.Next\np, q := head, head.Next\nfor q != nil && q.Next != nil {\n\tp.Next = q.Next\n\tp = p.Next\n\tq.Next = p.Next\n\tq = q.Next\n}\np.Next = even\nreturn head", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i"}
{"tgt": "for i := 0; i < b.N; i++ {\n\thmap.HashInsert(rand.Intn(128), i)\n}", "gen": "var a, b int\na = 1\nb = 2\nvar c int\nc = a + b\nvar d int\nd = a - b\nvar e int\ne = a * b\nvar f int\nf = a / b\nvar g int\ng = a % b\nvar h int\nh = a & b\nvar i int\ni = a | b\nvar j int\nj = a ^ b\nvar k int\nk = a << b\nvar l int\nl = a >> b\nvar m int\nm = a &^ b\nvar n int\nn = a + b\nvar o int\no = a - b\nvar p int\np = a * b\nvar q int\nq = a / b\nvar r int\nr = a % b\nvar s int\ns = a & b\nvar t int\nt = a | b\nvar u int\nu = a ^ b\nvar v int\nv = a << b\nvar w int\nw = a >> b\nvar x int\nx = a &^ b\nvar y int\ny = a + b\nvar z int\nz = a - b\nvar aa int\naa = a * b\nvar ab int\nab = a / b\nvar ac int\nac = a % b\nvar ad int\nad = a & b\nvar ae int\nae = a | b\nvar af int\naf = a ^ b\nvar ag int\nag = a << b\nvar ah int\nah = a >> b\nvar ai int\nai = a &^ b\nvar aj int\naj = a + b\nvar ak int\nak = a - b\nvar al int\nal = a * b\nvar am int\nam = a / b\nvar an int\nan = a % b\nvar ao int\nao = a & b\nvar ap int\nap = a"}
{"tgt": "size := len(prices)\nif size <= 1 {\n\treturn 0\n}\nprofits := []int{}\ntemp := 0\nfor i := 1; i < size; i++ {\n\tdiff := prices[i] - prices[i-1]\n\tif temp*diff >= 0 {\n\t\ttemp += diff\n\t\tcontinue\n\t}\n\tprofits = append(profits, temp)\n\ttemp = diff\n}\nprofits = append(profits, temp)\nres := 0\nfor i := 0; i < len(profits); i++ {\n\ttemp = max(profits[:i]) + max(profits[i:])\n\tif res < temp {\n\t\tres = temp\n\t}\n}\nreturn res", "gen": "var a [10]int\nvar b [10]int\nvar c int\nfor i := 0; i < len(a); i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < len(a); i++ {\n\tc = max(a[i], b[i])\n\ta[i] = c\n\tb[i] = c\n}\nfmt.Println(a[0])\n}"}
{"tgt": "_a := a\n_b := b\nif a < 0 {\n\ta *= -1\n}\nif b < 0 {\n\tb *= -1\n}\nx0, y0 := 0, 1\nx1, y1 := 1, 0\nfor b != 0 {\n\tquotient := a / b\n\ta, b = b, divide(a, b)\n\tx1, x0 = x0-quotient*x1, x1\n\ty1, y0 = y0-quotient*y1, y1\n}\nif _a < 0 {\n\ty0 *= -1\n}\nif _b < 0 {\n\tx0 *= -1\n}\nreturn y0, x0", "gen": "var a, b int64\nfmt.Scan(&a, &b)\nfmt.Println(divide(a, b))\n}\n"}
{"tgt": "t.Run(\"STR\", func(t *testing.T) {\n\tdata := []int{1, 1, 2}\n\tgot := removeDuplicates(data)\n\twant := 2\n\tif got != want {\n\t\tt.Error(\"STR\", got, \"STR\", want)\n\t}\n})\nt.Run(\"STR\", func(t *testing.T) {\n\tdata := []int{0, 0, 1, 1, 1, 2, 2, 3, 3, 4}\n\tgot := removeDuplicates(data)\n\twant := 5\n\tif got != want {\n\t\tt.Error(\"STR\", got, \"STR\", want)\n\t}\n})", "gen": "solution := Solution{}\ntest := testing.T{}\ntest.Run(\"TestSolution..func"}
{"tgt": "if list == nil || list.Size == 0 {\n\tfmt.Println(\"STR\")\n\treturn\n}\nlist.mutex.RLock()\ndefer list.mutex.RUnlock()\nfmt.Printf(\"STR\", list.Size)\nptr := list.Head\nvar i uint\nfor i = 0; i < list.Size; i++ {\n\tfmt.Printf(\"STR\", i+1, ptr.Data)\n\tptr = ptr.Next\n}", "gen": "var s Solution\ns.Solution()\n}\n"}
{"tgt": "commonChars := make([]string, 0)\nif len(A) == 0 {\n\treturn commonChars\n}\nminFrequencies := [26]int{}\nfor i := range minFrequencies {\n\tminFrequencies[i] = math.MaxInt32\n}\nfor _, word := range A {\n\tcharFrequencies := [26]int{}\n\tfor _, char := range word {\n\t\tcharFrequencies[char-\"STR\"]++\n\t}\n\tfor i := 0; i < 26; i++ {\n\t\tminFrequencies[i] = min(minFrequencies[i], charFrequencies[i])\n\t}\n}\nfor i := 0; i < 26; i++ {\n\tfor minFrequencies[i] > 0 {\n\t\tcommonChars = append(commonChars, string(rune(i)+\"STR\"))\n\t\tminFrequencies[i]--\n\t}\n}\nreturn commonChars", "gen": "var s []byte\ns = append(s, \"hello\"...)\nfmt.Println(string(s))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return N&1 == 0", "gen": "var a bool\na = true\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\nif a {\n\ta = false\n}\n"}
{"tgt": "var head *event\nreturn MyCalendar{head: head}", "gen": "var a int\na = 0\nvar b int\nb = 0\na = b\n}\n\n<ASM>\n.LFB4:\ncmpq %fs:112,%rsp\njnb .L5\nmovl $8,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L5:\npushq %rbp\nmovq %rsp,%rbp\nmovq $0,-16(%rbp)\n.LBB4:\nmovq $0,-8(%rbp)\n.LBB5:\nmovq -8(%rbp),%rax\nmovq %rax,-16(%rbp)\nmovq -16(%rbp),%rax\n.LBE5:\n.LBE4:\npopq %rbp\nret</ASM>"}
{"tgt": "var num uint32\nvar ret int\nnum = 00000000000000000000000000001011\nret = 3\nif ret != hammingWeight(num) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "fmt.Println(hammingWeight(11))\n}\n"}
{"tgt": "if head == nil || head.Next == nil {\n\treturn head\n}\nresult := head.Next\nresult.Next, head.Next = head, head.Next.Next\nresult.Next.Next = SwapEveryTwo(result.Next.Next)\nreturn result", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nSwapEveryTwo(&a)\nfor i := 0; i < 10; i++ {\n\tfmt.Println(a[i])\n}\n}"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := AreSentencesEquivalentTransitive(tc.sentence1,\n\t\ttc.sentence2, tc.thesaurus); result != tc.expectedTransitive {\n\t\tt.Errorf(\"STR\", tcid,\n\t\t\ttc.expectedTransitive, result)\n\t}\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "m := make(map[int]int)\nfor k, v := range nums {\n\tif idx, ok := m[target-v]; ok {\n\t\treturn []int{idx, k}\n\t}\n\tm[v] = k\n}\nreturn nil", "gen": "m := make(map[int][2]int)\nm[0] = [2]int{1, 2}\nm[1] = [2]int{3, 4}\nm[2] = [2]int{5, 6}\nm[3] = [2]int{7, 8}\nm[4] = [2]int{9, 10}\nm[5] = [2]int{11, 12}\nm[6] = [2]int{13, 14}\nm[7] = [2]int{15, 16}\nm[8] = [2]int{17, 18}\nm[9] = [2]int{19, 20}\nm[10] = [2]int{21, 22}\nm[11] = [2]int{23, 24}\nm[12] = [2]int{25, 26}\nm[13] = [2]int{27, 28}\nm[14] = [2]int{29, 30}\nm[15] = [2]int{31, 32}\nm[16] = [2]int{33, 34}\nm[17] = [2]int{35, 36}\nm[18] = [2]int{37, 38}\nm[19] = [2]int{39, 40}\nm[20] = [2]int{41, 42}\nm[21] = [2]int{43, 44}\nm[22] = [2]int{45, 46}\nm[23] = [2]int{47, 48}\nm[24] = [2]int{49, 50}\nm[25"}
{"tgt": "sum := 100 * 101 / 2\nsqSum := sum * sum\nsumSq := 0\nfor i := 1; i <= 100; i++ {\n\tsumSq += i * i\n}\nfmt.Println(sqSum - sumSq)", "gen": "var a int\na = 1\nfor i := 1; i < 100; i++ {\n\ta = a * i\n}\nfmt.Println(a)\n}\n\n<ASM>\n.LFB0:\ncmpq %fs:112,%rsp\njnb .L7\nmovl $168,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L7:\npushq %rbp\nmovq %rsp,%rbp\npushq %r13\npushq %r12\nsubq $144,%rsp\nmovq $5050,-40(%rbp)\nmovq -40(%rbp),%rax\nimulq %rax,%rax\nmovq %rax,-48(%rbp)\nmovq $0,-24(%rbp)\n.LBB2:\nmovq $1,-32(%rbp)\n.LBB3:\njmp .L2\n.L6:\n.LBB4:\nnop\n.LBE4:\n.LBB5:\nmovq -32(%rbp),%rax\nimulq %rax,%rax\naddq %rax,-24(%rbp)\n.LBE5:\n.LBB6:\naddq $1,-32(%rbp)\n.L2:\n.LBE6:\ncmpq $100,-32(%rbp)\njle .L6\n.LBE3:\n.LBE2:\nleaq <int..d>(%rip),%r12\nleaq <int..d>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-136(%rbp)\nmovq -136(%rbp),%rax\nmovq -48(%rbp),%rdx\nsubq -24(%rbp),%rdx\nmovq %rdx,(%rax)\nmovq -136(%rbp"}
{"tgt": "if a > b {\n\treturn b\n}\nreturn a", "gen": "var a, b int\nif a < b {\n\ta = b\n}\nprintln(a)\n}\n\n// 0x0000000000000000 <main>:\n// 0:\t55                   \tpush   %rbp\n// 1:\t48 89 e5             \tmov    %rsp,%rbp\n// 4:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// 8:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// c:\t48 89 7d f0          \tmov    %rdx,-0x18(%rbp)\n// f:\t48 89 75 e8          \tmov    %rsi,-0x20(%rbp)\n// 13:\t48 89 7d e0          \tmov    %rdi,-0x28(%rbp)\n// 17:\t48 89 75 d8          \tmov    %rsi,-0x30(%rbp)\n// 1b:\t48 89 7d d0          \tmov    %rdi,-0x38(%rbp)\n// 1f:\t48 89 75 c8          \tmov    %rsi,-0x40(%rbp)\n// 23:\t48 89 7d c0          \tmov    %rdi,-0x48(%rbp)\n// 27:\t48 89 75 b8          \tmov    %rsi,-0x50(%rbp)\n// 2b:\t48 89 7d b0          \tmov    %rdi,-0x58(%rbp)\n// 2f:\t48 89 75 a8          \tmov    %rsi,-0x60(%rbp)\n// 33:\t48 89 7d a0"}
{"tgt": "return this.Val", "gen": "var a [4]int\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 4\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "n := len(prices)\nif 0 == n || 1 == n {\n\treturn 0\n}\nvar (\n\tres      int\n\tminPrice = prices[0]\n)\nfor i := 1; i < n; i++ {\n\tif prices[i] < prices[i-1] {\n\t\tres += prices[i-1] - minPrice\n\t\tminPrice = prices[i]\n\t}\n\tif i == n-1 {\n\t\tres += prices[i] - minPrice\n\t}\n}\nreturn res", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nvar sum int\nfor i = 0; i < 10; i++ {\n\tsum += a[i]\n}\nprintln(sum)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "bs := []byte(s)\nvar recur func(int, int) bool\nrecur = func(l, r int) bool {\n\tfor l < r {\n\t\tif bs[l] != bs[r] {\n\t\t\treturn false\n\t\t}\n\t\tl++\n\t\tr--\n\t}\n\treturn true\n}\nfor l, r := 0, len(s)-1; l < r; l, r = l+1, r-1 {\n\tif bs[l] == bs[r] {\n\t\tcontinue\n\t}\n\treturn recur(l+1, r) || recur(l, r-1)\n}\nreturn true", "gen": "fmt.Println(validPalindrome(\"abcdcba\"))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 0,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxNumberOfBalloons(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOf"}
{"tgt": "tests := [...]testType{\n\t{\n\t\twords: []string{\"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  true,\n\t},\n\t{\n\t\twords: []string{\"STR\", \"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  false,\n\t},\n\t{\n\t\twords: []string{\"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := isAlienSorted(tt.words, tt.order)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.words, got, tt.want)\n\t}\n}", "gen": "fmt.Println(isAlienSorted(\"abc\", \"abx\"))\nfmt.Println(isAlienSorted(\"abc\", \"abd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\n"}
{"tgt": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 1, 3}},\n\t\tans1051{3},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 2, 3, 4}},\n\t\tans1051{5},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{0},\n\t},\n\t{\n\t\tpara1051{[]int{5, 4, 3, 2, 1}},\n\t\tans1051{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "i := 1\ntmp := 0\nfor i < len(arr) {\n\tif arr[i] >= arr[i-1] {\n\t\ti++\n\t} else {\n\t\ttmp = arr[i]\n\t\tarr[i] = arr[i-1]\n\t\tarr[i-1] = tmp\n\t\tif i > 1 {\n\t\t\ti--\n\t\t}\n\t}\n}", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nfor i := 0; i < len(a); i++ {\n\ta[i] = a[i] + 1\n}\nfmt.Println(a[0], a[1], a[2])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if maxSize > 0 {\n\tstack := &Stack{}\n\tstack.top = nil\n\tstack.size = 0\n\tstack.maxSize = maxSize\n\treturn stack\n}\nreturn nil", "gen": "var s Stack\ns.Push(1)\ns.Push(2)\ns.Push(3)\ns.Push(4)\ns.Push(5)\ns.Push(6)\ns.Push(7)\ns.Push(8)\ns.Push(9)\ns.Push(10)\ns.Push(11)\ns.Push(12)\ns.Push(13)\ns.Push(14)\ns.Push(15)\ns.Push(16)\ns.Push(17)\ns.Push(18)\ns.Push(19)\ns.Push(20)\ns.Push(21)\ns.Push(22)\ns.Push(23)\ns.Push(24)\ns.Push(25)\ns.Push(26)\ns.Push(27)\ns.Push(28)\ns.Push(29)\ns.Push(30)\ns.Push(31)\ns.Push(32)\ns.Push(33)\ns.Push(34)\ns.Push(35)\ns.Push(36)\ns.Push(37)\ns.Push(38)\ns.Push(39)\ns.Push(40)\ns.Push(41)\ns.Push(42)\ns.Push(43)\ns.Push(44)\ns.Push(45)\ns.Push(46)\ns.Push(47)\ns.Push(48)\ns.Push(49)\ns.Push(50)\ns.Push(51)\ns.Push(52)\ns.Push(53)\ns.Push(54)\ns.Push(55)\ns.Push(56)\n"}
{"tgt": "b, _ := ioutil.ReadFile(\"STR\")\ns := strings.Replace(string(b), \"STR\", \"STR\", -1)\nnumData := strings.Split(s, \"STR\")\nfor _, n := range numData {\n\tnumber, err := strconv.Atoi(n)\n\tif err == nil {\n\t\tdata = append(data, number)\n\t}\n}", "gen": "var data [3]int\nvar line string\nvar err error\nif line, err = ioutil.ReadFile(\"input.txt\"); err != nil {\n\tpanic(err)\n}\nvar parts []string\nif parts = strings.Split(strings.Replace(line, \"\\n\", \"\", -1), \" \"); len(parts) != 3 {\n\tpanic(\"invalid input\")\n}\nvar a, b, c int\nif a, err = strconv.Atoi(parts[0]); err != nil {\n\tpanic(err)\n}\nif b, err = strconv.Atoi(parts[1]); err != nil {\n\tpanic(err)\n}\nif c, err = strconv.Atoi(parts[2]); err != nil {\n\tpanic(err)\n}\ndata[0] = a\ndata[1] = b\ndata[2] = c\nfor i := 0; i < len(data); i++ {\n\tif data[i] > data[i+1] {\n\t\tpanic(\"invalid input\")\n\t}\n}\nfmt.Println(data[0])\n}\n"}
{"tgt": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nc, res := []int{}, [][]int{}\nsort.Ints(candidates)\nfindcombinationSum(candidates, target, 0, c, &res)\nreturn res", "gen": "fmt.Println(findCombinationSum([]int{2, 3, 6, 7}, 7))\n}\n"}
{"tgt": "qs := []question786{\n\t{\n\t\tpara786{[]int{1, 2, 3, 5}, 3},\n\t\tans786{[]int{2, 5}},\n\t},\n\t{\n\t\tpara786{[]int{1, 7}, 1},\n\t\tans786{[]int{1, 7}},\n\t},\n\t{\n\t\tpara786{[]int{1, 2}, 1},\n\t\tans786{[]int{1, 2}},\n\t},\n\t{\n\t\tpara786{[]int{1, 2, 3, 5, 7}, 6},\n\t\tans786{[]int{3, 7}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans786, q.para786\n\tfmt.Printf(\"STR\", p, kthSmallestPrimeFraction(p.A, p.K))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "errObj := appError{\n\tError:      handlerError.Error(),\n\tMessage:    message,\n\tHTTPStatus: code,\n}\nError.Printf(\"STR\", handlerError)\nw.Header().Set(\"STR\", \"STR\")\nw.WriteHeader(code)\nif j, err := json.Marshal(errorResource{Data: errObj}); err == nil {\n\tw.Write(j)\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "if len(strs) == 0 {\n\treturn nil\n}\nr := make(map[string][]string)\nfor _, str := range strs {\n\tcount := make([]int, 26)\n\tfor _, b := range []byte(str) {\n\t\tcount[b-'a']++\n\t}\n\tbs := make([]byte, 26*2)\n\tfor i, c := range count {\n\t\tbs[2*i] = '#'\n\t\tbs[2*i+1] = byte(c) + '0'\n\t}\n\tkey := string(bs)\n\tr[key] = append(r[key], str)\n}\nres := make([][]string, len(r))\ni := 0\nfor _, l := range r {\n\tres[i] = l\n\ti++\n}\nreturn res", "gen": "var m map[string]string\nm = make(map[string]string)\nm[\"hello\"] = \"world\"\nfmt.Println(m)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "type Address struct {\n\tCountry string  `json:\"STR\"`\n\tPerson  *Person `json:\"STR\"`\n}\nperson := &Person{\n\tName: \"STR\",\n\tAge:  23,\n}\naddress := &Address{\n\tCountry: \"STR\",\n\tPerson:  person,\n}\ndefer func() {\n\terr := recover()\n\tif err != nil {\n\t\tfmt.Printf(\"STR\", err)\n\t\tt.Error(\"STR\")\n\t}\n}()\ns := New(address)\ns.TagName = \"STR\"\nm := s.Map()\nif m[\"STR\"] != person.String() {\n\tt.Errorf(\"STR\", person.String(), m[\"STR\"])\n}\nvs := s.Values()\nif vs[1] != person.String() {\n\tt.Errorf(\"STR\", person.String(), vs[1])\n}", "gen": "p := Person{\n\tName: \"Alice\",\n\tAge:  23,\n}\np.Map()\n}\n"}
{"tgt": "if parser.tokens_head > 0 && len(parser.tokens) == cap(parser.tokens) {\n\tif parser.tokens_head != len(parser.tokens) {\n\t\tcopy(parser.tokens, parser.tokens[parser.tokens_head:])\n\t}\n\tparser.tokens = parser.tokens[:len(parser.tokens)-parser.tokens_head]\n\tparser.tokens_head = 0\n}\nparser.tokens = append(parser.tokens, *token)\nif pos < 0 {\n\treturn\n}\ncopy(parser.tokens[parser.tokens_head+pos+1:], parser.tokens[parser.tokens_head+pos:])\nparser.tokens[parser.tokens_head+pos] = *token", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar bb [10]int\nvar cc [10]int\nvar dd [10]int\nvar ee [10]int\nvar ff [10]int\nvar gg [10]int\nvar hh [10]int\nvar ii [10]int\nvar jj [10]int\nvar kk [10]int\nvar ll [10]int\nvar mm [10]int\nvar nn [10]int\nvar oo [10]int\nvar pp [10]int\nvar qq [10]int\nvar rr [10]int\nvar ss [10]int\nvar tt [10]int\nvar uu [10]int\nvar vv [10]int\nvar ww [10]int\nvar xx [10]int\nvar yy [10]int\nvar zz [10]int\nvar aaa [10]int\nvar bbb [10]"}
{"tgt": "str := \"STR\"\nfmt.Println(longestPalindrome(str))", "gen": "fmt.Println(longestPalindrome(\"abba\"))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   5,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   0,\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   1,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   2,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   13,\n\t\twant: 4,\n\t},\n\t{\n\t\tin:   130,\n\t\twant: 15,\n\t},\n}\nfor _, tt := range tests {\n\tgot := arrangeCoins(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(arrangeCoins(5))\nfmt.Println(arrangeCoins(2))\nfmt.Println(arrangeCoins(8))\nfmt.Println(arrangeCoins(3))\nfmt.Println(arrangeCoins(0))\nfmt.Println(arrangeCoins(1))\nfmt.Println(arrangeCoins(13))\nfmt.Println(arrangeCoins(4))\nfmt.Println(arrangeCoins(130))\nfmt.Println(arrangeCoins(15))\n}\n"}
{"tgt": "return WordDictionary{}", "gen": "var a [27]int\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 4\na[4] = 5\na[5] = 6\na[6] = 7\na[7] = 8\na[8] = 9\na[9] = 10\na[10] = 11\na[11] = 12\na[12] = 13\na[13] = 14\na[14] = 15\na[15] = 16\na[16] = 17\na[17] = 18\na[18] = 19\na[19] = 20\na[20] = 21\na[21] = 22\na[22] = 23\na[23] = 24\na[24] = 25\na[25] = 26\na[26] = 27\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "tcs := []struct {\n\ts   string\n\tans bool\n}{\n\t{\n\t\t\"STR\",\n\t\tfalse,\n\t},\n\t{\n\t\t\"STR\",\n\t\ttrue,\n\t},\n\t{\n\t\t\"STR\",\n\t\tfalse,\n\t},\n\t{\n\t\t\"STR\",\n\t\ttrue,\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, tc := range tcs {\n\tfmt.Printf(\"STR\", tc, isPalindrome(tc.s))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "var drinks []Drink\ninverted := make(map[Drink][]Customer)\nfor cust, favorites := range prefs {\n\tfor _, drink := range favorites {\n\t\tinverted[drink] = append(inverted[drink], cust)\n\t}\n}\ntotalCustomers := len(prefs)\nserved := make(map[Customer]struct{}, totalCustomers)\nfor len(served) < totalCustomers {\n\tvar largest []Customer\n\tvar largestDrink Drink\n\tvar largestIncrease int\n\tfor drink, custs := range inverted {\n\t\tvar newlyServed int\n\t\tfor _, cust := range custs {\n\t\t\tif _, found := served[cust]; !found {\n\t\t\t\tnewlyServed++\n\t\t\t}\n\t\t}\n\t\tif newlyServed > largestIncrease {\n\t\t\tlargestIncrease = newlyServed\n\t\t\tlargestDrink = drink\n\t\t\tlargest = custs\n\t\t}\n\t}\n\tdelete(inverted, largestDrink)\n\tdrinks = append(drinks, largestDrink)\n\tfor _, cust := range largest {\n\t\tserved[cust] = struct{}{}\n\t}\n}\nsort.Slice(drinks, func(i, j int) bool {\n\treturn drinks[i] < drinks[j]\n})\nreturn drinks", "gen": "var b Bartender\nb.Serve()\n}\n"}
{"tgt": "wg.Add(2)\ngoincCounter(1)\ngoincCounter(2)\nwg.Wait()\nfmt.Println(\"STR\", counter)", "gen": "var wg sync.WaitGroup\nwg.Add(2)\ngo func() {\n\tcounter := 0\n\tfor i := 0; i < 1000000000; i++ {\n\t\tcounter++\n\t}\n\twg.Done()\n}()\ngo func() {\n\tcounter := 0\n\tfor i := 0; i < 1000000000; i++ {\n\t\tcounter++\n\t}\n\twg.Done()\n}()\nwg.Wait()\nfmt.Println(counter)\n}\n\n<ASM>\ncmpq %fs:112,%rsp\njnb .L17\nmovl $184,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL5:\nret\n.L17:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\nsubq $144,%rsp\nmovl $2,%esi\nleaq <main.wg>(%rip),%rdi\ncall <sync.WaitGroup.Add@PLT>\n.LBB8:\nleaq <type..struct.4.4x.5.5>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-176(%rbp)\nmovq -176(%rbp),%rax\nleaq <main.main..thunk0>(%rip),%rdx\nmovq %rax,%rsi\nmovq %rdx,%rdi\ncall <__go_go@PLT>\n.LBE8:\n.LBB9:\nleaq <type..struct.4.4x.5.5>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-168(%rbp)\nmovq -168(%rbp"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{{-1, 2, 1, -4}, {1}}, 2},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tret := threeSumClosest(c.inputs[0], c.inputs[1][0])\n\t\tif !reflect.DeepEqual(ret, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, ret, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 2}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello, world\")\n}\n"}
{"tgt": "sort.Slice(words, func(i, j int) bool {\n\tcuri := len(words[i])\n\tcurj := len(words[j])\n\tfor curi > 0 && curj > 0 {\n\t\tcuri--\n\t\tcurj--\n\t\tif words[i][curi] == words[j][curj] {\n\t\t\tcontinue\n\t\t}\n\t\tif words[i][curi] > words[j][curj] {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\treturn curi == 0\n})\nwords = append(words, \"STR\")\nres, i := 0, 1\nfor ; i < len(words); i++ {\n\tif !endWith(words[i], words[i-1]) {\n\t\tres += len(words[i-1]) + 1\n\t}\n}\nreturn res", "gen": "fmt.Println(minimumLengthEncoding(\"a\"))\nfmt.Println(minimumLengthEncoding(\"aa\"))\nfmt.Println(minimumLengthEncoding(\"aaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding"}
{"tgt": "fmt.Println(badLongestPalindrome(\"STR\"))\nfmt.Println(goodLongestPalindrome(\"STR\"))\nfmt.Println(bestLongestPalindrome(\"STR\"))", "gen": "badLongestPalindrome()\ngoodLongestPalindrome()\nbestLongestPalindrome()\n}\n"}
{"tgt": "for i := 0; i < len(A)-1; i++ {\n\tif A[i] == i {\n\t\tcontinue\n\t}\n\tif A[i] == i+1 && A[i+1] == i {\n\t\ti++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"bad\")\n\t}\n}\n}\n\n// 0000000000000000 <main>:\n// 0:\t55                   \tpush   %rbp\n// 1:\t48 89 e5             \tmov    %rsp,%rbp\n// 4:\t48 83 ec 10          \tsub    $0x10,%rsp\n// 8:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// c:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// f:\t48 89 7d f0          \tmov    %rdx,-0x10(%rbp)\n// 13:\t48 89 75 e8          \tmov    %rsi,-0x18(%rbp)\n// 17:\t48 89 7d e0          \tmov    %rdx,-0x20(%rbp)\n// 1b:\t48 89 75 d8          \tmov    %rsi,-0x28(%rbp)\n// 1f:\t48 89 7d d0          \tmov    %rdx,-0x30(%rbp)\n// 23:\t48 89 75 c8          \tmov    %rsi,-0x38(%rbp)\n// 27:\t48 89 7d c0          \tmov    %rdx,-0x40(%rbp)\n// 2b:\t48 89 75 b8          \tmov    %rsi,-0x48(%rbp)\n// 2"}
{"tgt": "hash := uint32(0)\nfor i := len(sep) - 1; i >= 0; i-- {\n\thash = hash*PrimeRK + uint32(sep[i])\n}\nvar pow, sq uint32 = 1, PrimeRK\nfor i := len(sep); i > 0; i >>= 1 {\n\tif i&1 != 0 {\n\t\tpow *= sq\n\t}\n\tsq *= sq\n}\nreturn hash, pow", "gen": "var a [10]int\nvar b int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tb += a[i]\n}\nprintln(b)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif sum := SumBSTRange(tc.root, tc.a, tc.b); sum != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, sum)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "arr := make([]bool, 105000)\narr[0], arr[1] = true, true\ncount, prime := 2, 3\nvar k int\nfor {\n\tfor k = 2 * prime; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tcount++\n\t\tif count == 10001 {\n\t\t\tprintln(prime)\n\t\t\tbreak\n\t\t}\n\t} else {\n\t\tbreak\n\t}\n}", "gen": "var a [105000]byte\na[104999] = 1\na[104998] = 1\nfor i := 0; i < 105000; i++ {\n\ta[i] = 1\n}\nfor i := 0; i < 105000; i++ {\n\ta[i] = 1\n}\nfor i := 0; i < 105000; i++ {\n\ta[i] = 1\n}\nfor i := 0; i < 105000; i++ {\n\ta[i] = 1\n}\nfor i := 0; i < 105000; i++ {\n\ta[i] = 1\n}\nfor i := 0; i < 105000; i++ {\n\ta[i] = 1\n}\nfor i := 0; i < 105000; i++ {\n\ta[i] = 1\n}\nfor i := 0; i < 105000; i++ {\n\ta[i] = 1\n}\nfor i := 0; i < 105000; i++ {\n\ta[i] = 1\n}\nfor i := 0; i < 105000; i++ {\n\ta[i] = 1\n}\nfor i := 0; i < 105000; i++ {\n\ta[i] = 1\n}\nfor i := 0; i < 105000; i++ {\n\ta[i] = 1\n}\nfor i := 0; i < 105000; i++ {\n\ta[i] = 1\n}\nfor i := 0; i < 105000;"}
{"tgt": "n1, n2 := len(nums1), len(nums2)\nif n1 > n2 {\n\tn1, n2, nums1, nums2 = n2, n1, nums2, nums1\n}\nm := make(map[int]int, n1)\nfor _, num := range nums1 {\n\tm[num]++\n}\nres := make([]int, 0, n1)\nfor _, num := range nums2 {\n\tif v, ok := m[num]; ok && v > 0 {\n\t\tres = append(res, num)\n\t\tm[num]--\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aaa [3]int\nvar aab [3]int\nvar aac [3]int\nvar aad [3]int\nvar aae [3]int\nvar aaf [3]int\nvar aag [3]int\nvar aah [3]int\nvar aai [3]int\n"}
{"tgt": "if root == nil {\n\treturn nil\n}\ns := []*TreeNode{root}\nres := [][]int{}\nzigzag := false\nfor len(s) != 0 {\n\ttmp := []*TreeNode{}\n\tl := []int{}\n\tfor i, node := range s {\n\t\tif zigzag {\n\t\t\tl = append(l, s[len(s)-i-1].Val)\n\t\t} else {\n\t\t\tl = append(l, node.Val)\n\t\t}\n\t\tif node.Left != nil {\n\t\t\ttmp = append(tmp, node.Left)\n\t\t}\n\t\tif node.Right != nil {\n\t\t\ttmp = append(tmp, node.Right)\n\t\t}\n\t}\n\tres = append(res, l)\n\ts = tmp\n\tzigzag = !zigzag\n}\nreturn res", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)", "gen": "var a int\nvar b int\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\ta++\n\t}\n\tb++\n}\nfmt.Println(a, b)\n}"}
{"tgt": "if len(str) == 0 {\n\treturn 0\n}\nvar (\n\tnum int\n\tneg bool\n)\nfor i, s := range str {\n\tif s != ' ' {\n\t\tstr = str[i:]\n\t\tbreak\n\t}\n}\nif str[0] == '+' {\n\tstr = str[1:]\n} else if str[0] == '-' {\n\tstr = str[1:]\n\tneg = true\n}\nfor _, s := range str {\n\tif s < '0' || s > '9' {\n\t\tbreak\n\t}\n\tnum = num*10 + int(s-'0')\n\tif num > 2147483648 {\n\t\tnum = 2147483648\n\t\tbreak\n\t}\n}\nif neg {\n\tnum *= -1\n} else if num > 2147483647 {\n\tnum = 2147483647\n}\nreturn num", "gen": "var s []byte\nvar i int\nfor {\n\tif len(s) == i {\n\t\tbreak\n\t}\n\tif s[i] == '+' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == '-' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == ' ' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == '0' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == '1' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == '2' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == '3' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == '4' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == '5' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == '6' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == '7' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == '8' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == '9' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == 'A' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == 'B' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == 'C' {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == 'D' {\n\t\ti++\n"}
{"tgt": "ans, m, n := []int{}, len(matrix), len(matrix[0])\nfor j := 0; j < n; j++ {\n\tmax, rowIndex := 1, 0\n\tfor i := 0; i < m; i++ {\n\t\tif matrix[i][j] > max {\n\t\t\tmax = matrix[i][j]\n\t\t\trowIndex = i\n\t\t}\n\t}\n\tif Min(matrix[rowIndex]) == max {\n\t\tans = append(ans, max)\n\t}\n}\nreturn ans", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar b = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar c = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar d = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar e = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar f = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar g = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar h = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar i = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar j = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar k = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar m = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar n = []int"}
{"tgt": "strNumber := strconv.Itoa(number)\nfor _, runeDigit := range []rune(strNumber) {\n\tdigit := int(runeDigit - '0')\n\tlist = append(list, digit)\n}\nreturn", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar"}
{"tgt": "if num == 0 {\n\treturn \"STR\"\n}\nh := []string{\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\",\n\t\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\"}\nres := \"STR\"\nfor i := 0; i < 8 && num != 0; i++ {\n\tres = h[num&15] + res\n\tnum >>= 4\n}\nreturn res", "gen": "var s string\nfor i := 0; i < 8; i++ {\n\ts += fmt.Sprintf(\"%d\", i)\n}\nfmt.Println(s)\n}\n\n// Output:\n// 01234567\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n.LFB0:\nleaq\t-408(%rsp), %r11\ncmpq\t%fs:112, %r11\njnb\t.L14\nmovl\t$408, %r10d\nmovl\t$0, %r11d\ncall\t<__morestack>\n.LVL0:\nret\n.L14:\npushq\t%rbp\nmovq\t%rsp, %rbp\npushq\t%rbx\nsubq\t$392, %rsp\nmovq\t%rdi, -392(%rbp)\nmovq\t$0, -336(%rbp)\nmovq\t$0, -328(%rbp)\n.LBB2:\n.LBB3:\ncmpq\t$0, -392(%rbp)\njne\t.L2\n.LBB4:\n.LBB5:\nleaq\t<.LC0>(%rip), %rcx\nmovl\t$1, %ebx\nmovq\t%rcx, -336(%rbp)\nmovq\t%rbx, -328(%rbp)\nmovq\t-336(%rbp), %rax\nmovq\t-328(%rbp), %rdx\njmp\t.L10\n.L2:\n.LBE5:\n.LBE4:\n.LBE3:\nleaq\t<.LC0>(%rip), %rcx\nmovq\t%rcx, -320(%rbp)\nmovq\t$1, -312(%rbp)\n"}
{"tgt": "if len(n.Exprs) == 0 {\n\treturn TypeString, nil\n}\nif len(n.Exprs) == 1 {\n\texprType, err := n.Exprs[0].Type(s)\n\tif err != nil {\n\t\treturn TypeInvalid, err\n\t}\n\tswitch exprType {\n\tcase TypeList:\n\t\treturn TypeList, nil\n\tcase TypeMap:\n\t\treturn TypeMap, nil\n\t}\n}\nfor index, expr := range n.Exprs {\n\texprType, err := expr.Type(s)\n\tif err != nil {\n\t\treturn TypeInvalid, err\n\t}\n\tif exprType == TypeList || exprType == TypeMap {\n\t\treturn TypeInvalid, fmt.Errorf(\n\t\t\t\"STR\",\n\t\t\tindex, exprType)\n\t}\n}\nreturn TypeString, nil", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "psum, min := 0, 1\nfor _, val := range nums {\n\tpsum += val\n\tif psum < min {\n\t\tmin = psum\n\t}\n}\nif min > 0 {\n\treturn min\n}\nreturn -min + 1", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nvar sum int\nfor i = 0; i < 10; i++ {\n\tsum += a[i]\n}\nprintln(sum)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "arr := make([]bool, 2000000)\narr[0], arr[1] = true, true\nsum, prime := int64(5), 3\nvar k int\nfor {\n\tfor k = 2 * prime; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tsum += int64(k)\n\t} else {\n\t\tbreak\n\t}\n}\nprintln(sum)", "gen": "var a [2000000]byte\na[1] = 1\na[2] = 1\nfor i := 0; i < 2000000; i++ {\n\ta[i] = 1\n\ta[i+1] = 1\n}\nfor i := 0; i < 2000000; i++ {\n\tif a[i] != 1 {\n\t\tpanic(i)\n\t}\n\tif a[i+1] != 1 {\n\t\tpanic(i)\n\t}\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "qs := []question693{\n\t{\n\t\tpara693{5},\n\t\tans693{true},\n\t},\n\t{\n\t\tpara693{7},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{11},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{10},\n\t\tans693{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans693, q.para693\n\tfmt.Printf(\"STR\", p, hasAlternatingBits(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "sum := 0\nfor i := 1; i <= n; i++ {\n\tsquare := i * i\n\tsum += square\n}\nreturn sum", "gen": "var a, b int\nfor i := 0; i < 1000000000; i++ {\n\ta = i\n\tb = i * i\n}\nprintln(a, b)\n}\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n.LFB0:\n.cfi_startproc\ncmpq\t%fs:112,%rsp\njnb\t.L8\nmovl\t$8,%r10d\nmovl\t$0,%r11d\ncall\t<__morestack>\n.LVL0:\nret\n.L8:\npushq\t%rbp\nmovq\t%rsp,%rbp\nmovq\t%rdi,-40(%rbp)\nmovq\t$0,-24(%rbp)\n.LBB2:\nmovq\t$0,-8(%rbp)\n.LBB3:\nmovq\t$1,-16(%rbp)\n.LBB4:\njmp\t.L2\n.L7:\n.LBB5:\nnop\n.LBE5:\n.LBB6:\nmovq\t-16(%rbp),%rax\nimulq\t%rax,%rax\nmovq\t%rax,-32(%rbp)\nmovq\t-32(%rbp),%rax\naddq\t%rax,-8(%rbp)\n.LBE6:\n.LBB7:\naddq\t$1,-16(%rbp)\n.L2:\n.LBE7:\nmovq\t-16(%rbp),%rax\ncmpq\t-40(%rbp),%rax\njle\t.L7\n.LBE4:\n.LBE3:\n.LBB8:\nmovq\t-8(%rbp),%rax\nmovq\t%rax,-24(%rbp)\nmovq\t-24(%rbp),%rax\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.nums); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "var i int\nfor j, k := 0, 0; j < len(nums); j = k {\n\tfor k < len(nums) && nums[j] == nums[k] {\n\t\tif k < j+2 {\n\t\t\tnums[i] = nums[k]\n\t\t\ti++\n\t\t}\n\t\tk++\n\t}\n}\nreturn i", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"fail\")\n\t}\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "result := make([]int, 0, len(left)+len(right))\nfor len(left) > 0 || len(right) > 0 {\n\tif len(left) == 0 {\n\t\treturn append(result, right...)\n\t}\n\tif len(right) == 0 {\n\t\treturn append(result, left...)\n\t}\n\tif left[0] <= right[0] {\n\t\tresult = append(result, left[0])\n\t\tleft = left[1:]\n\t} else {\n\t\tresult = append(result, right[0])\n\t\tright = right[1:]\n\t}\n}\nreturn result", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "if 0 == n {\n\treturn 0\n} else {\n\treturn n/5 + trailingZeroes(n/5)\n}", "gen": "fmt.Println(trailingZeroes(100))\n}\n"}
{"tgt": "n := len(s)\nuf := newUnionFind(n)\nfor _, p := range pairs {\n\tuf.connect(p[0], p[1])\n}\ngroups := make(map[int][]int, n)\nfor c, p := range uf.parent {\n\tp = uf.find(p)\n\tgroups[p] = append(groups[p], c)\n}\nbytes := []byte(s)\nres := make([]byte, n)\nfor _, g := range groups {\n\tsize := len(g)\n\ta := make([]int, size)\n\tcopy(a, g)\n\tsort.Slice(a, func(i, j int) bool {\n\t\treturn bytes[a[i]] < bytes[a[j]]\n\t})\n\tsort.Ints(g)\n\tfor i := 0; i < size; i++ {\n\t\tres[g[i]] = bytes[a[i]]\n\t}\n}\nreturn string(res)", "gen": "fmt.Println(smallestStringWithSwaps([]string{\"dc\", \"cb\", \"ab\"}, [][]int{{0, 1}, {1, 0}}))\nfmt.Println(smallestStringWithSwaps([]string{\"cba\", \"da\", \"cb\"}, [][]int{{1, 2}, {0, 1}, {1, 0}}))\nfmt.Println(smallestStringWithSwaps([]string{\"abcd\", \"cdab\", \"adcb\", \"cbda\"}, [][]int{{0, 1}, {1, 0}, {0, 2}, {2, 1}}))\nfmt.Println(smallestStringWithSwaps([]string{\"abcd\", \"cdab\", \"adcb\", \"cbda\"}, [][]int{{1, 2}, {0, 3}, {2, 1}, {0, 2}}))\nfmt.Println(smallestStringWithSwaps([]string{\"abcd\", \"cdab\", \"adcb\", \"cbda\"}, [][]int{{1, 2}, {0, 3}, {2, 1}, {0, 2}, {3, 0}}))\nfmt.Println(smallestStringWithSwaps([]string{\"abcd\", \"cdab\", \"adcb\", \"cbda\"}, [][]int{{1, 2}, {0, 3}, {2, 1}, {0, 2}, {3, 0}, {2, 0}}))\nfmt.Println(smallestStringWithSwaps([]string{\"abcd\", \"cdab\", \"adcb\", \"cbda\"}, [][]int{{1, 2}, {0, 3}, {2, 1}, {0, 2}, {3, 0}, {2, 0}, {1, 0}}))\nfmt.Println(smallestStringWithSwaps([]string{\"abcd\", \"cdab\", \"adcb\", \"cbda\"}, [][]int{{1, 2}, {0, 3}, {2, 1}, {0, 2}, {3, 0}, {2, 0}, {1, 0"}
{"tgt": "data := [][]int{\n\t{2},\n\t{3, 4},\n\t{6, 5, 7},\n\t{4, 1, 8, 3}}\nfmt.Println(minimumTotal(data))", "gen": "var a = []int{2, 3, 4, 6, 5, 7, 4, 1, 8, 3, 1, 2}\nvar b = minimumTotal(a)\nfmt.Println(b)\n}\n"}
{"tgt": "left, right, res := 0, -1, 0\nfor left < len(s) {\n\tif right+1 < len(s) && maxCost-abs(int(s[right+1]-'a')-int(t[right+1]-'a')) >= 0 {\n\t\tright++\n\t\tmaxCost -= abs(int(s[right]-'a') - int(t[right]-'a'))\n\t} else {\n\t\tres = max(res, right-left+1)\n\t\tmaxCost += abs(int(s[left]-'a') - int(t[left]-'a'))\n\t\tleft++\n\t}\n}\nreturn res", "gen": "fmt.Println(maxVowels(\"aeiouuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu"}
{"tgt": "nums := []int{}\nfor n != 0 {\n\tnums = append(nums, n%10)\n\tn /= 10\n}\nm := len(nums)\nif m < 2 {\n\treturn -1\n}\ni := 1\nfor i < m {\n\tif nums[i] < nums[i-1] {\n\t\tbreak\n\t}\n\ti++\n}\nif i == m {\n\treturn -1\n}\nj := 0\nfor j < i {\n\tif nums[j] > nums[i] {\n\t\tbreak\n\t}\n\tj++\n}\nnums[i], nums[j] = nums[j], nums[i]\nfor k := 0; k < i/2; k++ {\n\tnums[k], nums[i-k-1] = nums[i-k-1], nums[k]\n}\nres := 0\np := 1\nfor _, n := range nums {\n\tres += n * p\n\tp *= 10\n}\nif res > math.MaxInt32 {\n\treturn -1\n}\nreturn res", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nvar b [3]int\nb[0] = 1\nb[1] = 2\nb[2] = 3\nvar c [3]int\nc[0] = 1\nc[1] = 2\nc[2] = 3\nvar d [3]int\nd[0] = 1\nd[1] = 2\nd[2] = 3\nvar e [3]int\ne[0] = 1\ne[1] = 2\ne[2] = 3\nvar f [3]int\nf[0] = 1\nf[1] = 2\nf[2] = 3\nvar g [3]int\ng[0] = 1\ng[1] = 2\ng[2] = 3\nvar h [3]int\nh[0] = 1\nh[1] = 2\nh[2] = 3\nvar i [3]int\ni[0] = 1\ni[1] = 2\ni[2] = 3\nvar j [3]int\nj[0] = 1\nj[1] = 2\nj[2] = 3\nvar k [3]int\nk[0] = 1\nk[1] = 2\nk[2] = 3\nvar l [3]int\nl[0] = 1\nl[1] = 2\nl[2] = 3\nvar m [3]int\nm[0] = 1\nm[1] = 2\nm[2] = 3\nvar n [3]int\nn[0] = 1\nn[1] = 2\nn[2] = 3\nvar o [3]int\no"}
{"tgt": "x := []int{10, 20, 30, 40, 50}\nfor k, v := range x {\n\tfmt.Printf(\"STR\", k, v)\n}", "gen": "var a [5]int\nvar b [5]int\nvar c [5]int\nvar d [5]int\nvar e [5]int\nvar f [5]int\nvar g [5]int\nvar h [5]int\nvar i [5]int\nvar j [5]int\nvar k [5]int\nvar l [5]int\nvar m [5]int\nvar n [5]int\nvar o [5]int\nvar p [5]int\nvar q [5]int\nvar r [5]int\nvar s [5]int\nvar t [5]int\nvar u [5]int\nvar v [5]int\nvar w [5]int\nvar x [5]int\nvar y [5]int\nvar z [5]int\nvar aa [5]int\nvar bb [5]int\nvar cc [5]int\nvar dd [5]int\nvar ee [5]int\nvar ff [5]int\nvar gg [5]int\nvar hh [5]int\nvar ii [5]int\nvar jj [5]int\nvar kk [5]int\nvar ll [5]int\nvar mm [5]int\nvar nn [5]int\nvar oo [5]int\nvar pp [5]int\nvar qq [5]int\nvar rr [5]int\nvar ss [5]int\nvar tt [5]int\nvar uu [5]int\nvar vv [5]int\nvar ww [5]int\nvar xx [5]int\nvar yy [5]int\nvar zz [5]int\nvar aa1 [5]int\nvar bb1 [5]int\nvar cc1 [5]int\nvar dd1 [5]int\nvar ee1 [5]int\nvar ff1 [5]int\nvar gg1 [5]int\nvar hh1"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif jumps, impassable := MinimumJumps(tc.maxSteps); impassable != tc.impassable || jumps != tc.expectedJumps {\n\t\tt.Errorf(\"STR\", tc.expectedJumps, tc.impassable, jumps, impassable)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "c.bw.WriteString(\"STR\")\nc.bw.WriteByte(space)\nc.bw.WriteString(key)\nc.bw.WriteByte(space)\nc.bw.Write(strconv.AppendInt(c.numScratch[:0], int64(timeout), 10))\n_, err = c.bw.Write(crlf)\nreturn", "gen": "var buf bytes.Buffer\nvar err error\nvar n int\nvar key string\nvar value string\nvar flags int\nvar expiration int\nvar conn net.Conn\nvar c *memcache.Client\nvar item *memcache.Item\nvar items []*memcache.Item\nvar keys []string\nvar keyBytes []byte\nvar valueBytes []byte\nvar flagsBytes []byte\nvar expirationBytes []byte\nvar nBytes []byte\nvar bufBytes []byte\nvar errBytes []byte\nvar errString string\nvar errStringBytes []byte\nvar errStringBytes2 []byte\nvar errStringBytes3 []byte\nvar errStringBytes4 []byte\nvar errStringBytes5 []byte\nvar errStringBytes6 []byte\nvar errStringBytes7 []byte\nvar errStringBytes8 []byte\nvar errStringBytes9 []byte\nvar errStringBytes10 []byte\nvar errStringBytes11 []byte\nvar errStringBytes12 []byte\nvar errStringBytes13 []byte\nvar errStringBytes14 []byte\nvar errStringBytes15 []byte\nvar errStringBytes16 []byte\nvar errStringBytes17 []byte\nvar errStringBytes18 []byte\nvar errStringBytes19 []byte\nvar errStringBytes20 []byte\nvar errStringBytes21 []byte\nvar errStringBytes22 []byte\nvar errStringBytes23 []byte\nvar errStringBytes24 []byte\nvar errStringBytes25 []byte\nvar errStringBytes26 []byte\nvar errStringBytes27 []byte\nvar errStringBytes28 []byte\nvar errStringBytes29 []byte\nvar errStringBytes30 []byte\nvar errStringBytes31 []byte\nvar errStringBytes32 []byte\nvar errStringBytes33 []byte\nvar errStringBytes34 []byte\nvar errStringBytes35 []byte\nvar errStringBytes36 []byte\nvar errStringBytes37 []byte\nvar errString"}
{"tgt": "if len(s) == 0 {\n\treturn \"STR\"\n}\nstart := 0\nmaxLen := 1\nfor index := range s {\n\tl := index - maxLen\n\tend := index + 1\n\tif l >= 1 && sym(s[l-1:end]) {\n\t\tstart = l - 1\n\t\tmaxLen += 2\n\t} else if l >= 0 && sym(s[l:end]) {\n\t\tstart = l\n\t\tmaxLen += 1\n\t}\n}\nreturn s[start : start+maxLen]", "gen": "var s string\nvar i int\nfmt.Scan(&s)\nfmt.Scan(&i)\nfmt.Println(sym(s, i))\n}"}
{"tgt": "http.HandleFunc(path, func(res http.ResponseWriter, req *http.Request) {\n\terr := handleFunc(res, req)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), 500)\n\t}\n})", "gen": "http.HandleFunc(\"/\", handle)\n}"}
{"tgt": "kind := t.Kind()\nif kind >= Int && kind <= Complex128 {\n\treturn int(t.Size()) * 8\n}\npanic(TypeError{\"STR\"})", "gen": "var x int\nvar y int\nvar z int\nvar w int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\n"}
{"tgt": "println(\"STR\", len(a))", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\tprintln(a[i])\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return e.Errs[0].Error()", "gen": "var a [3]int\na[1] = 1\na[2] = 2\na[0] = a[1] + a[2]\nfmt.Println(a[0])\n}\n\n<ASM>\n.LFB1:\ncmpq %fs:112,%rsp\njnb .L1\nmovl $72,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L1:\npushq %rbp\nmovq %rsp,%rbp\nsubq $48,%rsp\nmovq %rdi,-40(%rbp)\nmovq %rsi,-32(%rbp)\nmovq -40(%rbp),%rax\nmovq (%rax),%rax\nmovq %rax,-24(%rbp)\nmovq -32(%rbp),%rax\nmovq (%rax),%rax\nmovq %rax,-16(%rbp)\nmovq -24(%rbp),%rax\nmovq %rax,-8(%rbp)\nmovq -16(%rbp),%rax\nmovq %rax,-16(%rbp)\nmovq -8(%rbp),%rax\nmovq %rax,-24(%rbp)\nmovq -16(%rbp),%rax\nmovq %rax,-32(%rbp)\nmovq -24(%rbp),%rax\nmovq %rax,-40(%rbp)\nmovq -32(%rbp),%rax\nmovq %rax,-48(%rbp)\nmovq -40(%rbp),%rax\nmovq %rax,-56(%rbp)\nmovq -48(%rbp),%rax\nmovq %rax,-64(%rbp)\nmovq -56(%rbp),%rax\nmovq %rax,-72(%rbp)\nmovq -64(%rbp),%rax\nmovq %"}
{"tgt": "stack := make([]int, 0)\nresult := make([]int, len(T))\nfor i, t := range T {\n\tfor len(stack) > 0 && T[stack[len(stack)-1]] < t {\n\t\tresult[stack[len(stack)-1]] = i - stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t}\n\tstack = append(stack, i)\n}\nfor _, i := range stack {\n\tresult[i] = 0\n}\nreturn result", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "h := new(IntArray)\nh.heapIntArrays = arr\nh.heap.binHeapArrayIf = &h.heapIntArrays\nh.BuildHeap()\nreturn h", "gen": "var a = IntArray{1, 2, 3}\na.BuildHeap()\nfmt.Println(a)\n}\n"}
{"tgt": "if n == 1 || n == 2 {\n\treturn big.NewInt(1)\n}\nif mem[n] != nil {\n\treturn mem[n]\n}\nresult := big.NewInt(0)\nresult.Add(FibonacciHelper(n-1, mem), FibonacciHelper(n-2, mem))\nmem[n] = result\nreturn result", "gen": "var n int\nfmt.Scan(&n)\nfmt.Println(Fibonacci(n))\n}\n"}
{"tgt": "coins := []int{1, 2, 5, 10, 20, 50, 100, 200}\nmemo := make(map[string]int)\nreturn findAllWays(coins, 0, n, memo)", "gen": "var m map[int]int\nm[1] = 2\nm[5] = 10\nm[10] = 20\nm[20] = 50\nm[50] = 100\nm[100] = 200\nm[8] = 8\nfmt.Println(findAllWays(m))\n}\n"}
{"tgt": "data, err := base64.StdEncoding.DecodeString(b64)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(data)", "gen": "var s = \"1234567890\"\nvar b []byte\nb = []byte(s)\nvar s1 = \"1234567890\"\nvar b1 []byte\nb1 = []byte(s1)\nvar s2 = \"1234567890\"\nvar b2 []byte\nb2 = []byte(s2)\nvar s3 = \"1234567890\"\nvar b3 []byte\nb3 = []byte(s3)\nvar s4 = \"1234567890\"\nvar b4 []byte\nb4 = []byte(s4)\nvar s5 = \"1234567890\"\nvar b5 []byte\nb5 = []byte(s5)\nvar s6 = \"1234567890\"\nvar b6 []byte\nb6 = []byte(s6)\nvar s7 = \"1234567890\"\nvar b7 []byte\nb7 = []byte(s7)\nvar s8 = \"1234567890\"\nvar b8 []byte\nb8 = []byte(s8)\nvar s9 = \"1234567890\"\nvar b9 []byte\nb9 = []byte(s9)\nvar s10 = \"1234567890\"\nvar b10 []byte\nb10 = []byte(s10)\nvar s11 = \"1234567890\"\nvar b11 []byte\nb11 = []byte(s11)\nvar s12 = \"1234567890\"\nvar b12 []byte\nb12 = []byte(s12)\nvar s13 = \"1234567890\"\nvar b13"}
{"tgt": "qs := []question322{\n\t{\n\t\tpara322{[]int{186, 419, 83, 408}, 6249},\n\t\tans322{20},\n\t},\n\t{\n\t\tpara322{[]int{1, 2147483647}, 2},\n\t\tans322{2},\n\t},\n\t{\n\t\tpara322{[]int{1, 2, 5}, 11},\n\t\tans322{3},\n\t},\n\t{\n\t\tpara322{[]int{2}, 3},\n\t\tans322{-1},\n\t},\n\t{\n\t\tpara322{[]int{1}, 0},\n\t\tans322{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans322, q.para322\n\tfmt.Printf(\"STR\", p, coinChange(p.one, p.amount))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.locs); !reflect.DeepEqual(bonuses, tc.bonuses) {\n\t\tt.Errorf(\"STR\", tc.bonuses, bonuses)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "count := uint32(0)\nfor num != 0 {\n\tcount += num & 1\n\tnum = num >> 1\n}\nreturn int(count)", "gen": "var a int\nvar b int64\na = 1\nb = 0\nfor i := 0; i < 1000000000; i++ {\n\ta = a & 1\n\tb = b >> uint64(a)\n}\nprintln(b)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var sum int\nfor _, num := range nums {\n\tsum += num\n}\nif sum%2 != 0 {\n\treturn false\n}\nc := sum / 2\nn := len(nums)\nmemo := make([]bool, c+1)\nfor i := 0; i <= c; i++ {\n\tmemo[i] = nums[0] == i\n}\nfor i := 0; i < n; i++ {\n\tfor j := c; j >= nums[i]; j-- {\n\t\tmemo[j] = memo[j] || memo[j-nums[i]]\n\t}\n}\nreturn memo[c]", "gen": "var a [10]int\nvar b [10]bool\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i%2 == 0\n}\nfor i := 0; i < 10; i++ {\n\tif b[i] {\n\t\ta[i] = 0\n\t}\n}\nfor i := 0; i < 10; i++ {\n\tif a[i] != 0 {\n\t\tpanic(\"fail\")\n\t}\n}\n}\n"}
{"tgt": "count1 := 0\nfor _, r := range S {\n\tif r == '(' {\n\t\tcount1++\n\t} else if count1 > 0 {\n\t\tcount1--\n\t}\n}\ncount2 := 0\nfor i := len(S) - 1; i >= 0; i-- {\n\tif S[i] == ')' {\n\t\tcount2++\n\t} else if count2 > 0 {\n\t\tcount2--\n\t}\n}\nreturn count1 + count2", "gen": "var s string\nvar i int\nfor i = 0; i < 10; i++ {\n\ts += \"a\"\n}\nfmt.Println(s)\n}\n\n<ASM>\n.LFB217:\ncmpq %fs:112,%rsp\njnb .L5736\nmovl $88,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL275:\nret\n.L5736:\npushq %rbp\nmovq %rsp,%rbp\npushq %r12\npushq %rbx\nsubq $64,%rsp\nmovq %rdi,%rax\nmovq %rsi,%rcx\nmovq %rcx,%rdx\nmovq %rax,-80(%rbp)\nmovq %rdx,-72(%rbp)\nmovq $0,-48(%rbp)\n.LBB4688:\nmovq $0,-24(%rbp)\n.LBB4689:\nmovl $0,-52(%rbp)\n.LBB4690:\n.LBB4691:\n.LBB4692:\nmovq -72(%rbp),%r12\nmovl $0,%eax\n.LBE4692:\njmp .L5713\n.L5734:\n.LBB4693:\nnop\n.LBE4693:\n.LBB4694:\n.LBB4695:\nmovq -72(%rbp),%rdx\ntestq %rax,%rax\njs .L5714\ncmpq %rdx,%rax\njge .L5714\nmovq -80(%rbp),%rdx\nmovq %rax,%rcx\naddq %rcx,%rdx\nmovzbl (%rdx),%edx\nmovzbl %dl,%edx\ncmpl $127,%edx\n"}
{"tgt": "for i := rangeMin; i <= rangeMax; i++ {\n\tif evenlyDivisble%i != 0 {\n\t\tevenlyDivisble = evenlyDivisble * lcm(evenlyDivisble, i)\n\t}\n\tfmt.Println(evenlyDivisble, \"STR\", i, \"STR\", evenlyDivisble/i)\n}", "gen": "var rangeMin int = 1\nvar rangeMax int = 20\nvar evenlyDivisble int = 2\nfor rangeMin <= rangeMax {\n\tif evenlyDivisble == -1 {\n\t\tevenlyDivisble = rangeMin\n\t} else if evenlyDivisble == 0 {\n\t\tevenlyDivisble = rangeMin\n\t} else {\n\t\tif rangeMin % evenlyDivisble != 0 {\n\t\t\tcontinue\n\t\t}\n\t\tevenlyDivisble = lcm(rangeMin, evenlyDivisble)\n\t}\n\tfmt.Println(rangeMin, evenlyDivisble)\n\trangeMin++\n}\n}"}
{"tgt": "log.SetFlags(0)\nvar err error\ntpl := template.New(\"STR\")\ntpl = tpl.Funcs(template.FuncMap{\n\t\"STR\": func(str string) string {\n\t\treturn strings.ToUpper(str)\n\t},\n})\ntpl, err = tpl.ParseFiles(\"STR\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nerr = tpl.ExecuteTemplate(os.Stdout, \"STR\", Page{\n\tTitle: \"STR\",\n\tBody:  \"STR\",\n})\nif err != nil {\n\tlog.Fatalln(err)\n}", "gen": "log.SetFlags(0)\nt := template.New(\"\")\nt = t.Funcs(template.FuncMap{\n\t\"f\": func(s string) string {\n\t\treturn strings.ToUpper(s)\n\t},\n})\nt, err := t.ParseFiles(\"./index.html\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nvar p = Page{Title: \"Hello, \u4e16\u754c\"}\nerr = t.ExecuteTemplate(os.Stdout, \"index.html\", p)\nif err != nil {\n\tlog.Fatalln(err)\n}\n}\n\n// \u7f16\u8bd1\u6267\u884c\n$ go build -o main main.go\n$ ./main\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Hello, \u4e16\u754c</title>\n</head>\n<body>\n    <h1>HELLO, \u4e16\u754c</h1>\n</body>\n</html>\n\n// \u6c47\u7f16\u4ee3\u7801\n$ go tool compile -S main.go\n\n// \u6c47\u7f16\u4ee3\u7801\n$ go tool compile -S main.go\n\n// \u6c47\u7f16\u4ee3\u7801\n$ go tool compile -S main.go\n\n// \u6c47\u7f16\u4ee3\u7801\n$ go tool compile -S main.go\n\n// \u6c47\u7f16\u4ee3\u7801\n$ go tool compile -S main.go\n\n// \u6c47\u7f16\u4ee3\u7801\n$ go tool compile -S main.go\n\n// \u6c47\u7f16\u4ee3\u7801\n$ go tool compile -S main.go\n\n// \u6c47\u7f16\u4ee3\u7801\n$ go tool compile -S main.go\n\n// \u6c47\u7f16\u4ee3\u7801\n$ go tool compile -S main.go\n\n// \u6c47\u7f16\u4ee3\u7801\n$ go tool compile -S main.go\n\n// \u6c47\u7f16\u4ee3\u7801\n$ go tool compile -S main.go\n\n// \u6c47\u7f16\u4ee3\u7801\n$ go tool compile -S main"}
{"tgt": "return append(ints, added...)", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 4\nb[1] = 5\nb[2] = 6\nc[0] = 7\nc[1] = 8\nc[2] = 9\ncopy(a[:], b[:])\ncopy(b[:], c[:])\ncopy(c[:], a[:])\nfmt.Println(a[0], a[1], a[2])\nfmt.Println(b[0], b[1], b[2])\nfmt.Println(c[0], c[1], c[2])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "left, right := 0, len(nums)-1\nfor left < right {\n\tmid := (left + right) / 2\n\tcount := 0\n\tfor _, num := range nums {\n\t\tif num <= mid {\n\t\t\tcount++\n\t\t}\n\t}\n\tif count > mid {\n\t\tright = mid\n\t} else {\n\t\tleft = mid + 1\n\t}\n}\nreturn left", "gen": "var a [10]int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tprintln(a[i])\n}\n}\n\n// Output:\n// 0\n// 1\n// 2\n// 3\n// 4\n// 5\n// 6\n// 7\n// 8\n// 9\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n.LFB2:\ncmpq %fs:112,%rsp\njnb .L44\nmovl $88,%r10d\nmovl $24,%r11d\ncall <__morestack>\n.LVL4:\nret\n.L44:\npushq %rbp\nmovq %rsp,%rbp\nsubq $80,%rsp\nmovq $0,-32(%rbp)\n.LBB26:\nmovq $0,-8(%rbp)\nmovq <24>(%rbp),%rax\nsubq $1,%rax\nmovq %rax,-16(%rbp)\n.LBB27:\n.LBB28:\njmp .L29\n.L43:\n.LBB29:\nnop\n.LBE29:\n.LBB30:\nmovq -8(%rbp),%rdx\nmovq -16(%rbp),%rax\naddq %rdx,%rax\nmovq %rax,%rdx\nshrq $63,%rdx\naddq %rdx,%rax\nsarq %rax\nmovq %rax,-40(%rbp)\nmovq $0,-24(%rbp)\n.LBB31:\nmovq $0,-48(%rbp)\n.LBB32:\n.LBB33:\n.LBB34:\nmovq <16>(%rbp),%rax\nmovq <24>(%rb"}
{"tgt": "var min int\ntotalPeople := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\ttotalPeople++\n\t}\n}\nif totalPeople < 2 {\n\treturn 0\n}\nmiddle := (totalPeople / 2) + (totalPeople % 2)\nindex := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\tmiddle--\n\t}\n\tif middle == 0 {\n\t\tindex = i\n\t\tbreak\n\t}\n}\nleftZero := 0\nleftZeroFound := false\nfor j := index - 1; j >= 0; j-- {\n\tif !leftZeroFound && seating[j] == 0 {\n\t\tleftZero = j\n\t\tleftZeroFound = true\n\t} else if seating[j] == 1 && j < leftZero {\n\t\tmin += abs(j - leftZero)\n\t\tleftZero--\n\t}\n}\nrightZero := 0\nrightZeroFound := false\nfor j := index + 1; j < len(seating); j++ {\n\tif !rightZeroFound && seating[j] == 0 {\n\t\trightZero = j\n\t\trightZeroFound = true\n\t} else if seating[j] == 1 && j > rightZero {\n\t\tmin += abs(j - rightZero)\n\t\trightZero++\n\t}\n}\nreturn min", "gen": "var a [3]int\nvar b [3]int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar ba int\nvar bb int\nvar bc int\nvar bd int\nvar be int\nvar bf int\nvar bg int\nvar bh int\nvar bi int\nvar bj int\nvar bk int\nvar bl int\nvar bm int\nvar bn int\nvar bo int\nvar bp int\nvar bq int\nvar br int\nvar bs int\nvar bt int\nvar bu int\nvar bv int\nvar bw int\nvar bx int\nvar by int\nvar bz int\nvar ca int\nvar cb int\nvar cc int\nvar cd int\nvar ce int\nvar cf int\nvar cg int\nvar ch int\nvar ci int\nvar cj int\nvar ck int\nvar cl int\nvar cm int\nvar cn int\nvar co int\nvar cp int\n"}
{"tgt": "targetRange := []int{-1, -1}\nfor i := 0; i < len(nums); i++ {\n\tif nums[i] == target {\n\t\ttargetRange[0] = i\n\t\tbreak\n\t}\n}\nif targetRange[0] == -1 {\n\treturn targetRange\n}\nfor j := len(nums) - 1; j >= 0; j-- {\n\tif nums[j] == target {\n\t\ttargetRange[1] = j\n\t\tbreak\n\t}\n}\nreturn targetRange", "gen": "var a [3]int\nvar b [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 4\nb[1] = 5\nb[2] = 6\ncopy(a[:], b[:])\nfmt.Println(a[0], a[1], a[2])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var tests = []struct {\n\tbefore []int\n\tafter  *ListNode\n}{\n\t{[]int{}, nil},\n\t{[]int{1}, newList(1)},\n\t{[]int{1, 2, 3, 4, 5}, newList(1, 3, 5, 2, 4)},\n\t{[]int{1, 2, 3, 4, 5, 6}, newList(1, 3, 5, 2, 4, 6)},\n\t{[]int{2, 1, 3, 5, 6, 4, 7}, newList(2, 3, 6, 7, 1, 5, 4)},\n}\nfor _, tt := range tests {\n\tafter := oddEvenList(newList(tt.before...))\n\tif reflect.DeepEqual(after, tt.after) == false {\n\t\tt.Errorf(\"STR\", newList(tt.before...), after, tt.after)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "out := 45228\nif x := p32(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "p32 := 45228\np32 = 45228\nif p32 != 45228 {\n\tt.Errorf(\"p32 = %d, want %d\", p32, 45228)\n}\n}\n\n// Test that we can handle a function call with a constant argument.\n// This is a regression test for issue 11727.\n<ASM>\n.LFB108:\ncmpq %fs:112,%rsp\njnb .L1764\nmovl $200,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL112:\nret\n.L1764:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $152,%rsp\nmovq %rdi,-168(%rbp)\nmovq $45228,-56(%rbp)\n.LBB1422:\ncall <main.p32>\nmovq %rax,-64(%rbp)\nmovq -64(%rbp),%rax\ncmpq -56(%rbp),%rax\nje .L1766\n.LBB1423:\nleaq <int..d>(%rip),%rax\nmovq %rax,-192(%rbp)\nleaq <int..d>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-152(%rbp)\nmovq -152(%rbp),%rax\nmovq -64(%rbp),%rdx\nmovq %rdx,(%rax)\nmovq -152(%rbp),%rax\nmovq %rax,-184(%rbp)\nleaq <int..d>(%rip),%r14\nlea"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SecondLargest(tc.root); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "fmt.Println(SecondLargest([]int{1, 2, 3, 4, 5}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,"}
{"tgt": "primes := [...]int{2: 1, 3: 1, 5: 1, 7: 1, 11: 1, 13: 1, 17: 1, 19: 1}\nres := 0\nfor i := L; i <= R; i++ {\n\tbits := 0\n\tfor n := i; n > 0; n >>= 1 {\n\t\tbits += n & 1\n\t}\n\tres += primes[bits]\n}\nreturn res", "gen": "var a [20]int\nvar i int\nfor i = 0; i < 20; i++ {\n\ta[i] = 1\n}\nfor i = 0; i < 20; i++ {\n\tif a[i]&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif a[i]&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif a[i]&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif a[i]&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif a[i]&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif a[i]&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif a[i]&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif a[i]&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif a[i]&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++"}
{"tgt": "qs := []question1232{\n\t{\n\t\tpara1232{[][]int{{1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6}, {6, 7}}},\n\t\tans1232{true},\n\t},\n\t{\n\t\tpara1232{[][]int{{1, 1}, {2, 2}, {3, 4}, {4, 5}, {5, 6}, {7, 7}}},\n\t\tans1232{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1232, q.para1232\n\tfmt.Printf(\"STR\", p, checkStraightLine(p.arr))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "var tests = []struct {\n\tnums    []int\n\tmissing int\n}{\n\t{[]int{1, 1}, 2},\n\t{[]int{1, 2, 0}, 3},\n\t{[]int{3, 4, -1, 1}, 2},\n\t{[]int{7, 8, 9, 11, 12}, 1},\n}\nfor _, tt := range tests {\n\tnums := make([]int, len(tt.nums))\n\tcopy(nums, tt.nums)\n\tmissing := firstMissingPositive(tt.nums)\n\tif missing != tt.missing {\n\t\tt.Errorf(\"STR\", nums, missing, tt.missing)\n\t}\n}", "gen": "fmt.Println(firstMissingPositive([]int{3, 4, -1, 1}))\nfmt.Println(firstMissingPositive([]int{1, 2, 0}))\nfmt.Println(firstMissingPositive([]int{7, 8, 9, 11}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 11}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9"}
{"tgt": "if nil == head || nil == head.Next ||\n\tm == n {\n\treturn head\n}\nstep := n - m\nvar leftTail *ListNode\np := head\nfor m > 1 {\n\tleftTail = p\n\tp = p.Next\n\tm--\n}\nq := p.Next\np.Next = nil\nmidTail := p\nfor step > 0 {\n\tr := q.Next\n\tq.Next = p\n\tp = q\n\tq = r\n\tstep--\n}\nif nil == leftTail {\n\tmidTail.Next = q\n\treturn p\n}\nleftTail.Next = p\nmidTail.Next = q\nreturn head", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "var tests = []struct {\n\ttree  *TreeNode\n\tdepth int\n}{\n\t{newTree(3, 9, 20, nil, nil, 15, 7), 2},\n\t{newTree(1, 2), 2},\n\t{newTree(1, 2, 2, 3), 2},\n\t{newTree(1, 2, 2, 3, 3, nil, nil, 4, 4), 2},\n\t{newTree(1, 2, 2, 3, nil, 3, 3, 4), 3},\n\t{newTree(1, 2, 2, nil, nil, nil, 3, 4, 4), 2},\n}\nfor _, tt := range tests {\n\tdepth := minDepth(tt.tree)\n\tif depth != tt.depth {\n\t\tt.Errorf(\"STR\", tt.tree, depth, tt.depth)\n\t}\n}", "gen": "fmt.Println(minDepth(nil))\nfmt.Println(minDepth(newTree(1)))\nfmt.Println(minDepth(newTree(2, newTree(3))))\nfmt.Println(minDepth(newTree(2, newTree(3, newTree(4)))))\nfmt.Println(minDepth(newTree(2, newTree(3, newTree(4, newTree(5))))))\nfmt.Println(minDepth(newTree(1, newTree(2))))\nfmt.Println(minDepth(newTree(1, newTree(2, newTree(3)))))\nfmt.Println(minDepth(newTree(1, newTree(2, newTree(3, newTree(4))))))\nfmt.Println(minDepth(newTree(1, newTree(2, newTree(3, newTree(4, newTree(5)))))))\nfmt.Println(minDepth(newTree(1, newTree(2, newTree(3, newTree(4, newTree(5, newTree(6))))))))\nfmt.Println(minDepth(newTree(1, newTree(2, newTree(3, newTree(4, newTree(5, newTree(6, newTree(7)))))))))\nfmt.Println(minDepth(newTree(1, newTree(2, newTree(3, newTree(4, newTree(5, newTree(6, newTree(7, newTree(8))))))))))\nfmt.Println(minDepth(newTree(1, newTree(2, newTree(3, newTree(4, newTree(5, newTree(6, newTree(7, newTree(8, newTree(9)))))))))))\nfmt.Println(minDepth(newTree(1, newTree(2, newTree(3, newTree(4, newTree(5, newTree(6, newTree(7, newTree(8, newTree(9, newTree(10))))))))))))\nfmt.Println(minDepth"}
{"tgt": "t.Parallel()\nd := NewTimeMap()\nd.Set(1, 1, 0)\nd.Set(1, 2, 2)\nif result := d.Get(1, 1); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 3); result != 2 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 5)\nif result := d.Get(1, 0); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 10); result != 1 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 0)\nd.Set(1, 2, 0)\nif result := d.Get(1, 0); result != 2 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(2, 0); result != nil {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, -1); result != nil {\n\tt.Errorf(\"STR\")\n}", "gen": "testing.M()\n}\n"}
{"tgt": "if len(steps) < 2 {\n\treturn true\n}\nfor step := 1; step <= steps[0] && step <= len(steps); step++ {\n\tif CanAdvanceToEndBrute(steps[step:]) {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "var a [10]int\nvar b int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tb = i\n\tif i == 0 {\n\t\tcontinue\n\t}\n\tif i == 1 {\n\t\tbreak\n\t}\n\tif i == 2 {\n\t\tcontinue\n\t}\n\tif i == 3 {\n\t\tbreak\n\t}\n\tif i == 4 {\n\t\tcontinue\n\t}\n\tif i == 5 {\n\t\tbreak\n\t}\n\tif i == 6 {\n\t\tcontinue\n\t}\n\tif i == 7 {\n\t\tbreak\n\t}\n\tif i == 8 {\n\t\tcontinue\n\t}\n\tif i == 9 {\n\t\tbreak\n\t}\n}\nfmt.Println(a[b])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "obj := Constructor225()\nfmt.Printf(\"STR\", obj)\nparam5 := obj.Empty()\nfmt.Printf(\"STR\", param5)\nobj.Push(2)\nfmt.Printf(\"STR\", obj)\nobj.Push(10)\nfmt.Printf(\"STR\", obj)\nparam2 := obj.Pop()\nfmt.Printf(\"STR\", param2)\nparam3 := obj.Top()\nfmt.Printf(\"STR\", param3)\nparam4 := obj.Empty()\nfmt.Printf(\"STR\", param4)", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []string\n\texpect [][]string\n}{\n\t{\"STR\", []string{\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\"},\n\t\t[][]string{\n\t\t\t{\"STR\", \"STR\", \"STR\"},\n\t\t\t{\"STR\", \"STR\"},\n\t\t\t{\"STR\"},\n\t\t},\n\t},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := groupAnagrams(c.inputs)\n\t\tfmt.Println(got)\n\t})\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "i1 := 0\ni2 := 0\nval1 := 0\nval2 := 0\nfor i1 < len(version1) || i2 < len(version2) {\n\tval1, i1 = parseSeg(version1, i1)\n\tval2, i2 = parseSeg(version2, i2)\n\tif val1 > val2 {\n\t\treturn 1\n\t}\n\tif val1 < val2 {\n\t\treturn -1\n\t}\n}\nif i1 < len(version1) {\n\treturn 1\n}\nif i2 < len(version2) {\n\treturn -1\n}\nreturn 0", "gen": "fmt.Println(parseInt(\"42\", 10))\nfmt.Println(parseInt(\"-42\", 10))\nfmt.Println(parseInt(\"4193 with words\", 10))\nfmt.Println(parseInt(\"words and 987\", 10))\nfmt.Println(parseInt(\"-91283472332\", 10))\nfmt.Println(parseInt(\"12345678901234567890\", 10))\nfmt.Println(parseInt(\"123456789012345678901234567890\", 10))\nfmt.Println(parseInt(\"1234567890123456789012345678901234567890\", 10))\nfmt.Println(parseInt(\"12345678901234567890123456789012345678901234567890\", 10))\nfmt.Println(parseInt(\"123456789012345678901234567890123456789012345678901234567890\", 10))\nfmt.Println(parseInt(\"1234567890123456789012345678901234567890123456789012345678901234567890\", 10))\nfmt.Println(parseInt(\"12345678901234567890123456789012345678"}
{"tgt": "result := make([]int, 0)\nfor i := 0; i < n; i++ {\n\tresult = append(result, nums[i])\n\tresult = append(result, nums[n+i])\n}\nreturn result", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aaa [3]int\nvar aab [3]int\nvar aac [3]int\nvar aad [3]int\nvar aae [3]int\nvar aaf [3]int\nvar aag [3]int\nvar aah [3]int\nvar aai [3]int\n"}
{"tgt": "nums := make([]byte, n)\nfor i := 0; i < n; i++ {\n\tnums[i] = byte(i) + '1'\n}\nfor i := 2; i <= k; i++ {\n\tnextPermutation60(nums)\n}\nreturn string(nums)", "gen": "fmt.Println(nextPermutation([]int{1, 2, 3}))\nfmt.Println(nextPermutation([]int{1, 3, 2}))\nfmt.Println(nextPermutation([]int{3, 2, 1}))\nfmt.Println(nextPermutation([]int{1, 1, 5}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 4, 5}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MakePalindrome(tc.input); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "ln, err := net.Listen(\"STR\", \"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"STR\", conn.RemoteAddr())\n\tio.WriteString(conn, fmt.Sprint(time.Now()))\n\tconn.Close()\n}", "gen": "var l net.Listener\nl, err := net.Listen(\"tcp\", \":8080\")\nif err != nil {\n\tpanic(err)\n}\ndefer l.Close()\nfor {\n\tconn, err := l.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tgo handleConn(conn)\n}\n}"}
{"tgt": "self.table[index].Num = value", "gen": "var a [3]int\na[1] = 1\na[2] = 2\na[3] = 3\nfmt.Println(a[1])\nfmt.Println(a[2])\nfmt.Println(a[3])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return x.(int) < y.(int)", "gen": "var a int\nvar b int\nvar c int\na = 1\nb = 2\nc = 3\nif a == b {\n\tpanic(\"a == b\")\n}\nif b == c {\n\tpanic(\"b == c\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return strings.Replace(address, \"STR\", \"STR\", -1)", "gen": "fmt.Println(strings.Replace(\"hello\", \"e\", \"a\", 3))\n}\n\n// \u7f16\u8bd1\u5668\u4f1a\u628a\u8fd9\u6bb5\u4ee3\u7801\u8f6c\u6362\u6210\u5982\u4e0b\u7684\u6c47\u7f16\u4ee3\u7801\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3\u7801\u662f\u901a\u8fc7go tool compile -S main.go \u751f\u6210\u7684\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3\u7801\u662f\u901a\u8fc7go tool compile -S main.go \u751f\u6210\u7684\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3\u7801\u662f\u901a\u8fc7go tool compile -S main.go \u751f\u6210\u7684\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3\u7801\u662f\u901a\u8fc7go tool compile -S main.go \u751f\u6210\u7684\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3\u7801\u662f\u901a\u8fc7go tool compile -S main.go \u751f\u6210\u7684\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3\u7801\u662f\u901a\u8fc7go tool compile -S main.go \u751f\u6210\u7684\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3\u7801\u662f\u901a\u8fc7go tool compile -S main.go \u751f\u6210\u7684\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3\u7801\u662f\u901a\u8fc7go tool compile -S main.go \u751f\u6210\u7684\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3\u7801\u662f\u901a\u8fc7go tool compile -S main.go \u751f\u6210\u7684\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3\u7801\u662f\u901a\u8fc7go tool compile -S main.go \u751f\u6210\u7684\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3\u7801\u662f\u901a\u8fc7go tool compile -S main.go \u751f\u6210\u7684\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3\u7801\u662f\u901a\u8fc7go tool compile -S main.go \u751f\u6210\u7684\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3\u7801\u662f\u901a\u8fc7go tool compile -S main.go \u751f\u6210\u7684\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3\u7801\u662f\u901a\u8fc7go tool compile -S main.go \u751f\u6210\u7684\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3\u7801\u662f\u901a\u8fc7go tool compile -S main.go \u751f\u6210\u7684\n// \u8fd9\u6bb5\u4ee3\u7801\u7684\u6c47\u7f16\u4ee3"}
{"tgt": "var parts []string\nvar isFile bool\nvar partStart, tabCount, maxLength int\nfor i, r := range fs {\n\tswitch {\n\tcase isNewStart(i, r, fs):\n\t\tpartStart = i\n\tcase r == '.':\n\t\tisFile = true\n\tcase r == '\\t':\n\t\ttabCount++\n\tcase r == '\\n':\n\t\tif pos := tabCount; len(parts) > pos {\n\t\t\tparts = parts[:pos]\n\t\t}\n\t\tparts = append(parts, fs[partStart:i])\n\t\tif len := len(strings.Join(parts, \"STR\")); isFile && len > maxLength {\n\t\t\tmaxLength = len\n\t\t}\n\t\tisFile = false\n\t\ttabCount = 0\n\t}\n}\nif isFile {\n\tparts = append(parts, fs[partStart:])\n}\nreturn len(strings.Join(parts, \"STR\"))", "gen": "var s []byte\nvar i int\nfor {\n\tr, _, err := stdin.ReadRune()\n\tif err != nil {\n\t\tbreak\n\t}\n\tif r == 127 {\n\t\tbreak\n\t}\n\t_, _ = decoderune(r)\n\ti, _ = isNewStart()\n\tif i == 1 {\n\t\ts = append(s, 10)\n\t} else {\n\t\ts = append(s, r)\n\t}\n}\nfmt.Println(string(s))\n}"}
{"tgt": "FprintVersion(os.Stdout)", "gen": "fmt.Println(\"Hello, playground\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "cnt := 0\nfor i := 0; cnt < n && i < len(flowerbed); i++ {\n\tif i > 0 && flowerbed[i-1] == 1 {\n\t\tcontinue\n\t}\n\tif i < len(flowerbed)-1 && flowerbed[i+1] == 1 {\n\t\tcontinue\n\t}\n\tif flowerbed[i] != 0 {\n\t\tcontinue\n\t}\n\tflowerbed[i] = 1\n\tcnt++\n\tif i < len(flowerbed)-1 {\n\t\tflowerbed[i+1] = -1\n\t}\n}\nreturn cnt >= n", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i + 1\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] - 1\n}\nif i >= 10 {\n\tpanic(\"\")\n}\nif i < 0 {\n\tpanic(\"\")\n}\nif i >= 10 {\n\tpanic(\"\")\n}\nif i < 0 {\n\tpanic(\"\")\n}\nif i >= 10 {\n\tpanic(\"\")\n}\nif i < 0 {\n\tpanic(\"\")\n}\nif i >= 10 {\n\tpanic(\"\")\n}\nif i < 0 {\n\tpanic(\"\")\n}\nif i >= 10 {\n\tpanic(\"\")\n}\nif i < 0 {\n\tpanic(\"\")\n}\nif i >= 10 {\n\tpanic(\"\")\n}\nif i < 0 {\n\tpanic(\"\")\n}\nif i >= 10 {\n\tpanic(\"\")\n}\nif i < 0 {\n\tpanic(\"\")\n}\nif i >= 10 {\n\tpanic(\"\")\n}\nif i < 0 {\n\tpanic(\"\")\n}\nif i >= 10 {\n\tpanic(\"\")\n}\nif i < 0 {\n\tpanic(\"\")\n}\nif i >= 10 {\n\tpanic(\"\")\n}\nif i < 0 {\n\tpanic(\"\")\n}\nif i >= 10 {\n\tpanic(\"\")\n}\nif i < 0 {\n\tpanic(\"\")\n}\nif i >= 10 {\n\tpan"}
{"tgt": "m := len(A)\nn := len(A[0])\nans := make([][]int, n)\nfor k := range ans {\n\tans[k] = make([]int, m)\n}\nfor r := 0; r < m; r++ {\n\tfor c := 0; c < n; c++ {\n\t\tans[c][r] = A[r][c]\n\t}\n}\nreturn ans", "gen": "var a [3]int\nvar b [4]int\nvar c [5]int\nvar d [6]int\nvar e [7]int\nvar f [8]int\nvar g [9]int\nvar h [10]int\nvar i [11]int\nvar j [12]int\nvar k [13]int\nvar l [14]int\nvar m [15]int\nvar n [16]int\nvar o [17]int\nvar p [18]int\nvar q [19]int\nvar r [20]int\nvar s [21]int\nvar t [22]int\nvar u [23]int\nvar v [24]int\nvar w [25]int\nvar x [26]int\nvar y [27]int\nvar z [28]int\nvar aa [29]int\nvar bb [30]int\nvar cc [31]int\nvar dd [32]int\nvar ee [33]int\nvar ff [34]int\nvar gg [35]int\nvar hh [36]int\nvar ii [37]int\nvar jj [38]int\nvar kk [39]int\nvar ll [40]int\nvar mm [41]int\nvar nn [42]int\nvar oo [43]int\nvar pp [44]int\nvar qq [45]int\nvar rr [46]int\nvar ss [47]int\nvar tt [48]int\nvar uu [49]int\nvar vv [50]int\nvar ww [51]int\nvar xx [52]int\nvar yy [53]int\nvar zz [54]int\nvar aaa [55]int\nvar bbb [56]int\nvar ccc ["}
{"tgt": "patternMap := make(map[string]string)\nstrMap := make(map[string]string)\nplen := len(pattern)\nstrArr := strings.Split(str, \"STR\")\npatternArr := strings.Split(pattern, \"STR\")\nif plen != len(strArr) {\n\treturn false\n}\nfor i := 0; i < plen; i++ {\n\tif _, ok := patternMap[patternArr[i]]; !ok {\n\t\tpatternMap[patternArr[i]] = strArr[i]\n\t}\n\tif _, ok := strMap[strArr[i]]; !ok {\n\t\tstrMap[strArr[i]] = patternArr[i]\n\t}\n\tif patternMap[patternArr[i]] != strArr[i] || strMap[strArr[i]] != patternArr[i] {\n\t\tfmt.Println(\"STR\", patternMap)\n\t\tfmt.Println(\"STR\", strMap)\n\t\treturn false\n\t}\n}\nfmt.Println(\"STR\", patternMap)\nfmt.Println(\"STR\", strMap)\nreturn true", "gen": "var m = make(map[string]string)\nm[\"a\"] = \"b\"\nm[\"c\"] = \"d\"\nfmt.Println(m)\nfmt.Println(m)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "nlen := len(nums)\nfor i := 0; i < nlen-2; i++ {\n\tif i != 0 && nums[i] == nums[i-1] {\n\t\tcontinue\n\t}\n\tleft, right := i+1, nlen-1\n\tfor left < right {\n\t\tsum := nums[i] + nums[left] + nums[right]\n\t\tif sum == target {\n\t\t\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tleft++\n\t\t\tright--\n\t\t} else if sum < target {\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tleft++\n\t\t} else {\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tright--\n\t\t}\n\t}\n}", "gen": "var a [4]int\nvar b [4]int\nvar c [4]int\nvar d [4]int\nvar e [4]int\nvar f [4]int\nvar g [4]int\nvar h [4]int\nvar i [4]int\nvar j [4]int\nvar k [4]int\nvar l [4]int\nvar m [4]int\nvar n [4]int\nvar o [4]int\nvar p [4]int\nvar q [4]int\nvar r [4]int\nvar s [4]int\nvar t [4]int\nvar u [4]int\nvar v [4]int\nvar w [4]int\nvar x [4]int\nvar y [4]int\nvar z [4]int\nvar aa [4]int\nvar ab [4]int\nvar ac [4]int\nvar ad [4]int\nvar ae [4]int\nvar af [4]int\nvar ag [4]int\nvar ah [4]int\nvar ai [4]int\nvar aj [4]int\nvar ak [4]int\nvar al [4]int\nvar am [4]int\nvar an [4]int\nvar ao [4]int\nvar ap [4]int\nvar aq [4]int\nvar ar [4]int\nvar as [4]int\nvar at [4]int\nvar au [4]int\nvar av [4]int\nvar aw [4]int\nvar ax [4]int\nvar ay [4]int\nvar az [4]int\nvar ba [4]int\nvar bb [4]int\nvar bc [4]int\nvar bd [4]int\nvar be [4]int\nvar bf [4]int\nvar bg [4]int\nvar bh [4]int\nvar bi [4]int\nvar bj ["}
{"tgt": "sLen, tLen := len(s), len(t)\nneed := [256]int{}\nfor i := range t {\n\tneed[t[i]]++\n}\nhas := [256]int{}\nmin := sLen + 1\nbegin, end, winBegin, winEnd, count := 0, 0, 0, 0, 0\nfor ; end < sLen; end++ {\n\tif need[s[end]] == 0 {\n\t\tcontinue\n\t}\n\tif has[s[end]] < need[s[end]] {\n\t\tcount++\n\t}\n\thas[s[end]]++\n\tif count == tLen {\n\t\tfor need[s[begin]] == 0 || has[s[begin]] > need[s[begin]] {\n\t\t\tif has[s[begin]] > need[s[begin]] {\n\t\t\t\thas[s[begin]]--\n\t\t\t}\n\t\t\tbegin++\n\t\t}\n\t\ttemp := end - begin + 1\n\t\tif min > temp {\n\t\t\tmin = temp\n\t\t\twinBegin = begin\n\t\t\twinEnd = end\n\t\t}\n\t}\n}\nif count < tLen {\n\treturn \"STR\"\n}\nreturn s[winBegin : winEnd+1]", "gen": "var s []byte\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s1 []byte\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s1 []byte\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s1 []byte\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s1 []byte\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif steps := MinimumStepsPath(tc.path); steps != tc.minimumSteps {\n\t\tt.Errorf(\"STR\", tc.minimumSteps, steps)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "n := len(cost)\ndp := make([]int, n)\ndp[0], dp[1] = cost[0], cost[1]\nfor i := 2; i < n; i++ {\n\tdp[i] = cost[i] + min(dp[i-2], dp[i-1])\n}\nreturn min(dp[n-2], dp[n-1])", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar b = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar c = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar d = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar e = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar f = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar g = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar h = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar i = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar j = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar k = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar m = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar n = []int"}
{"tgt": "qs := []question845{\n\t{\n\t\tpara845{[]int{875, 884, 239, 731, 723, 685}},\n\t\tans845{4},\n\t},\n\t{\n\t\tpara845{[]int{0, 1, 2, 3, 4, 5, 4, 3, 2, 1, 0}},\n\t\tans845{11},\n\t},\n\t{\n\t\tpara845{[]int{2, 3}},\n\t\tans845{0},\n\t},\n\t{\n\t\tpara845{[]int{2, 1, 4, 7, 3, 2, 5}},\n\t\tans845{5},\n\t},\n\t{\n\t\tpara845{[]int{2, 2, 2}},\n\t\tans845{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans845, q.para845\n\tfmt.Printf(\"STR\", p, longestMountain(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "res := make([]int, 0)\nfor i := 0; i < len(nums); i = i + 2 {\n\tfreq, val := nums[i], nums[i+1]\n\tfor j := 0; j < freq; j++ {\n\t\tres = append(res, val)\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "defer wg.Done()\nfor v := range taskQueue {\n\tfmt.Printf(\"STR\", workerId, v.Id, v.JobId)\n\tv.Run()\n\tfmt.Printf(\"STR\", workerId, v.Status, v.Id, v.JobId)\n}", "gen": "var ch chan int\nvar i int\nvar t Task\nvar r int\nvar s string\nvar p *int\nvar a [4]int\nvar b [4]string\nvar c [4]int\nvar d [4]string\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa string\nvar bb string\nvar cc string\nvar dd string\nvar ee string\nvar ff string\nvar gg string\nvar hh string\nvar ii string\nvar jj string\nvar kk string\nvar ll string\nvar mm string\nvar nn string\nvar oo string\nvar pp string\nvar qq string\nvar rr string\nvar ss string\nvar tt string\nvar uu string\nvar vv string\nvar ww string\nvar xx string\nvar yy string\nvar zz string\nvar aaa int\nvar bbb int\nvar ccc int\nvar ddd int\nvar eee int\nvar fff int\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := Reverse32Bits(tc.given); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "fmt.Println(Reverse32Bits(123456789))\nfmt.Println(Reverse32Bits(12345678))\nfmt.Println(Reverse32Bits(1234567))\nfmt.Println(Reverse32Bits(123456))\nfmt.Println(Reverse32Bits(12345))\nfmt.Println(Reverse32Bits(1234))\nfmt.Println(Reverse32Bits(123))\nfmt.Println(Reverse32Bits(12))\nfmt.Println(Reverse32Bits(1))\nfmt.Println(Reverse32Bits(0))\n}\n"}
{"tgt": "dummy := &ListNode{0, head}\nslow, fast := dummy, dummy\nfor fast.Next != nil && fast.Next.Next != nil {\n\tfast = fast.Next.Next\n\tslow = slow.Next\n}\nreturn slow.Next", "gen": "var a [2]int\na[0] = 1\na[1] = 2\nvar b [2]int\nb[0] = 3\nb[1] = 4\nvar c [2]int\nc[0] = 5\nc[1] = 6\nvar d [2]int\nd[0] = 7\nd[1] = 8\nvar e [2]int\ne[0] = 9\ne[1] = 10\nvar f [2]int\nf[0] = 11\nf[1] = 12\nvar g [2]int\ng[0] = 13\ng[1] = 14\nvar h [2]int\nh[0] = 15\nh[1] = 16\nvar i [2]int\ni[0] = 17\ni[1] = 18\nvar j [2]int\nj[0] = 19\nj[1] = 20\nvar k [2]int\nk[0] = 21\nk[1] = 22\nvar l [2]int\nl[0] = 23\nl[1] = 24\nvar m [2]int\nm[0] = 25\nm[1] = 26\nvar n [2]int\nn[0] = 27\nn[1] = 28\nvar o [2]int\no[0] = 29\no[1] = 30\nvar p [2]int\np[0] = 31\np[1] = 32\nvar q [2]int\nq[0] = 33\nq[1] = 34\nvar r [2]int\nr[0] = 35\nr[1] = 36\nvar s [2"}
{"tgt": "fmt.Println(superEggDrop(1, 2))\nfmt.Println(superEggDrop(2, 6))\nfmt.Println(superEggDrop(2, 4))", "gen": "fmt.Println(superEggDrop(2, 100))\nfmt.Println(superEggDrop(2, 500))\nfmt.Println(superEggDrop(3, 100))\nfmt.Println(superEggDrop(3, 600))\nfmt.Println(superEggDrop(4, 100))\nfmt.Println(superEggDrop(4, 500))\nfmt.Println(superEggDrop(4, 1200))\nfmt.Println(superEggDrop(5, 100))\nfmt.Println(superEggDrop(5, 300))\nfmt.Println(superEggDrop(5, 500))\nfmt.Println(superEggDrop(5, 1000))\nfmt.Println(superEggDrop(5, 1200))\nfmt.Println(superEggDrop(5, 1400))\nfmt.Println(superEggDrop(6, 100))\nfmt.Println(superEggDrop(6, 600))\nfmt.Println(superEggDrop(6, 1200))\nfmt.Println(superEggDrop(6, 1400))\nfmt.Println(superEggDrop(6, 1600))\nfmt.Println(superEggDrop(7, 100))\nfmt.Println(superEggDrop(7, 800))\nfmt.Println(superEggDrop(7, 1200))\nfmt.Println(superEggDrop(7, 1400))\nfmt.Println(superEggDrop(7, 1600))\nfmt.Println(superEggDrop(7, 1800))\nfmt.Println(superEggDrop(7, 2000))\nfmt.Println(superEggDrop(8,"}
{"tgt": "var res []int\nstack := []*preOrderTree{root}\nfor len(stack) > 0 {\n\troot = stack[0]\n\tstack = stack[1:]\n\tres = append(res, root.data)\n\tif root.left != nil {\n\t\tstack = append(stack, root.left)\n\t}\n\tif root.right != nil {\n\t\tstack = append(stack, root.right)\n\t}\n}\nreturn res", "gen": "var a [3]preOrderTree\na[0] = preOrderTree{1, nil, nil}\na[1] = preOrderTree{2, nil, nil}\na[2] = preOrderTree{3, nil, nil}\nfmt.Println(a)\n}\n"}
{"tgt": "l, r := 0, 0\nn := len(s)\nfor i := 0; i < n; i++ {\n\tif s[i] == ')' {\n\t\tl--\n\t} else {\n\t\tl++\n\t}\n\tj := n - i - 1\n\tif s[j] == '(' {\n\t\tr--\n\t} else {\n\t\tr++\n\t}\n\tif l < 0 || r < 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var s string\nvar i int\nvar b bool\ns = \"Hello, world\"\ni = 0\nb = false\nfor i < len(s) {\n\tif s[i] == 'H' {\n\t\tb = true\n\t}\n\ti++\n}\nprintln(b)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA\n\tC int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif !ok {\n\tt.Error(\"STR\")\n}", "gen": "var t TestHasZero_Nested\nt.B.i1.d = 123\nif !reflect.DeepEqual(t, TestHasZero_Nested{B: B{i1: i1{d: 123}}}) {\n\tpanic(\"not equal\")\n}\nif !reflect.DeepEqual(t, TestHasZero_Nested{B: B{i1: i1{d: 123}}}) {\n\tpanic(\"not equal\")\n}\nif !reflect.DeepEqual(t, TestHasZero_Nested{B: B{i1: i1{d: 123}}}) {\n\tpanic(\"not equal\")\n}\nif !reflect.DeepEqual(t, TestHasZero_Nested{B: B{i1: i1{d: 123}}}) {\n\tpanic(\"not equal\")\n}\nif !reflect.DeepEqual(t, TestHasZero_Nested{B: B{i1: i1{d: 123}}}) {\n\tpanic(\"not equal\")\n}\nif !reflect.DeepEqual(t, TestHasZero_Nested{B: B{i1: i1{d: 123}}}) {\n\tpanic(\"not equal\")\n}\nif !reflect.DeepEqual(t, TestHasZero_Nested{B: B{i1: i1{d: 123}}}) {\n\tpanic(\"not equal\")\n}\nif !reflect.DeepEqual(t, TestHasZero_Nested{B: B{i1: i1{d: 123}}}) {\n\tpanic(\"not equal\")\n}\nif !reflect.DeepEqual(t, TestHasZero_Nested{B: B{i1: i1{d: 123}}}) {\n\tpanic(\"not equal\")\n}\nif !reflect.DeepEqual(t, TestHasZero_Nested{B: B{i1:"}
{"tgt": "for i, row := range matrix[1:] {\n\tfor j, v := range row[1:] {\n\t\tif v != matrix[i][j] {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar aaa [10]int\nvar aab [10]int\nvar aac [10]int\n"}
{"tgt": "qs := []question28{\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{2},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{5},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{-1},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans28, q.para28\n\tfmt.Printf(\"STR\", p, strStr(p.s, p.p))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "digits := \"STR\"\nfor i := 1; i < 9999; i++ {\n\tnum := \"STR\"\n\tfor j := 1; j < 5; j++ {\n\t\tif len(num) < 9 {\n\t\t\tnum += strconv.Itoa(i * j)\n\t\t}\n\t}\n\tarr := strings.Split(num, \"STR\")\n\tsort.Strings(arr)\n\tnumSorted := strings.Join(arr, \"STR\")\n\tif numSorted == digits {\n\t\treturn num\n\t}\n}\nreturn \"STR\"", "gen": "var a int\nvar b int\nfmt.Scan(&a)\nfmt.Scan(&b)\nvar c int\nc = a * b\nvar d string\nd = strconv.Itoa(c)\nvar e []string\ne = strings.Split(d, \"\")\nsort.Strings(e)\nvar f string\nf = strings.Join(e, \"\")\nvar g int\ng, _ = strconv.Atoi(f)\nif a * b == g {\n\tfmt.Println(\"Yes\")\n} else {\n\tfmt.Println(\"No\")\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "obj := Constructor933()\nfmt.Printf(\"STR\", obj)\nparam1 := obj.Ping(1)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(100)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(3001)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(3002)\nfmt.Printf(\"STR\", param1)", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "root := new(*TreeNode)\ninsertArrayToTreeNode(root, array, 0)\nreturn *root", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar root = insertArrayToTreeNode(a, 0, len(a)-1)\nfmt.Println(root)\n}\n"}
{"tgt": "res := 0\nsort.Ints(houses)\nsort.Ints(heaters)\nm, n := len(houses), len(heaters)\nindex := sort.SearchInts(heaters, houses[0])\nfor _, house := range houses {\n\tfor index < n && house > heaters[index] {\n\t\tindex++\n\t}\n\tif index == n {\n\t\treturn max(res, houses[m-1]-heaters[index-1])\n\t}\n\tleft := math.MaxInt32\n\tif index > 0 {\n\t\tleft = house - heaters[index-1]\n\t}\n\tright := heaters[index] - house\n\tres = max(res, min(left, right))\n}\nreturn res", "gen": "fmt.Println(maxProfit([]int{7, 1, 5, 3, 6, 4}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5}))\nfmt.Println(maxProfit([]int{7, 6, 4, 3, 1}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}))\nfmt.Println(maxProfit([]"}
{"tgt": "c := Candidates(candidates)\nsort.Sort(c)\nreturn orderedCombinationSum2(c, target)", "gen": "fmt.Println(orderedCombinationSum2([]int{10, 1, 2, 7, 6, 1, 5}, 8))\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tresults := HeapsAlgorithmRecursive(tc.input)\n\tpos := 0\n\tfor result := range results {\n\t\tif !reflect.DeepEqual(result, tc.expected[pos]) {\n\t\t\tt.Errorf(\"STR\", tc.expected[pos], result)\n\t\t}\n\t\tpos++\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "for i := 1; i < len(nums); i++ {\n\tif nums[i-1] > nums[i] {\n\t\tpre := deepCopy(nums)\n\t\tpre[i-1] = pre[i]\n\t\tnext := deepCopy(nums)\n\t\tnext[i] = next[i-1]\n\t\treturn sort.IsSorted(sort.IntSlice(pre)) || sort.IsSorted(sort.IntSlice(next))\n\t}\n}\nreturn true", "gen": "var a [3]int\nvar b [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb = deepCopy(a)\nfmt.Println(a, b)\n}"}
{"tgt": "res := []int{}\nfor _, num := range nums {\n\tn := num\n\tif n < 0 {\n\t\tn *= -1\n\t}\n\tif nums[n-1] < 0 {\n\t\tres = append(res, n)\n\t} else {\n\t\tnums[n-1] *= -1\n\t}\n}\nreturn res", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\na[0] = a[0] + a[1] + a[2]\nfmt.Println(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "qs := []question1281{\n\t{\n\t\tpara1281{234},\n\t\tans1281{15},\n\t},\n\t{\n\t\tpara1281{4421},\n\t\tans1281{21},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1281, q.para1281\n\tfmt.Printf(\"STR\", p, subtractProductAndSum(p.n))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(subtractProductAndSum(234))\n}\n"}
{"tgt": "fp := float64(p)\nfa := float64(a)\nfb := (fp * (fp - 2.0*fa)) / (2.0 * (fp - fa))\nb = int(fb)\nvalid = math.Abs(fb-math.Floor(fb)) < 0.000001\nreturn", "gen": "var a, b float64\nfmt.Scan(&a, &b)\nif a > b {\n\ta, b = b, a\n}\nif a == 0 {\n\tfmt.Println(0)\n\treturn\n}\nif b == 0 {\n\tfmt.Println(1)\n\treturn\n}\nif a == 1 {\n\tfmt.Println(1)\n\treturn\n}\nif b == 1 {\n\tfmt.Println(1)\n\treturn\n}\nif a == 2 {\n\tfmt.Println(2)\n\treturn\n}\nif b == 2 {\n\tfmt.Println(2)\n\treturn\n}\nif a == 3 {\n\tfmt.Println(3)\n\treturn\n}\nif b == 3 {\n\tfmt.Println(3)\n\treturn\n}\nif a == 4 {\n\tfmt.Println(5)\n\treturn\n}\nif b == 4 {\n\tfmt.Println(5)\n\treturn\n}\nif a == 5 {\n\tfmt.Println(8)\n\treturn\n}\nif b == 5 {\n\tfmt.Println(8)\n\treturn\n}\nif a == 6 {\n\tfmt.Println(13)\n\treturn\n}\nif b == 6 {\n\tfmt.Println(13)\n\treturn\n}\nif a == 7 {\n\tfmt.Println(21)\n\treturn\n}\nif b == 7 {\n\tfmt.Println(21)\n\treturn\n}\nif a == 8 {\n\tfmt.Println(34)\n\treturn\n}\nif b == 8 {\n\tfmt.Println(34)\n\treturn\n}\nif a =="}
{"tgt": "start := -1\nlenMax := 0\ndict := [256]int{}\nfor i := range dict {\n\tdict[i] = -1\n}\nfor i, r := range s {\n\tif v := dict[r]; v > start {\n\t\tstart = v\n\t}\n\tlength := i - start\n\tif length > lenMax {\n\t\tlenMax = length\n\t}\n\tdict[r] = i\n}\nreturn lenMax", "gen": "var s []byte\nfor i := 0; i < 256; i++ {\n\ts = append(s, byte(i))\n}\nfor i := 0; i < 256; i++ {\n\ts[i] = byte(i)\n}\nfor i := 0; i < 256; i++ {\n\ts[i] = byte(i)\n}\nfor i := 0; i < 256; i++ {\n\ts[i] = byte(i)\n}\nfor i := 0; i < 256; i++ {\n\ts[i] = byte(i)\n}\nfor i := 0; i < 256; i++ {\n\ts[i] = byte(i)\n}\nfor i := 0; i < 256; i++ {\n\ts[i] = byte(i)\n}\nfor i := 0; i < 256; i++ {\n\ts[i] = byte(i)\n}\nfor i := 0; i < 256; i++ {\n\ts[i] = byte(i)\n}\nfor i := 0; i < 256; i++ {\n\ts[i] = byte(i)\n}\nfor i := 0; i < 256; i++ {\n\ts[i] = byte(i)\n}\nfor i := 0; i < 256; i++ {\n\ts[i] = byte(i)\n}\nfor i := 0; i < 256; i++ {\n\ts[i] = byte(i)\n}\nfor i := 0; i < 256; i++ {\n\ts[i] = byte(i)\n}\nfor i := 0; i < 256; i++ {\n\ts[i] = byte(i)\n"}
{"tgt": "return &skipListNode{v: v, score: score, forwards: make([]*skipListNode, level, level), level: level}", "gen": "var s []int\ns = append(s, 1)\ns = append(s, 2)\ns = append(s, 3)\ns = append(s, 4)\ns = append(s, 5)\ns = append(s, 6)\ns = append(s, 7)\ns = append(s, 8)\ns = append(s, 9)\ns = append(s, 10)\ns = append(s, 11)\ns = append(s, 12)\ns = append(s, 13)\ns = append(s, 14)\ns = append(s, 15)\ns = append(s, 16)\ns = append(s, 17)\ns = append(s, 18)\ns = append(s, 19)\ns = append(s, 20)\ns = append(s, 21)\ns = append(s, 22)\ns = append(s, 23)\ns = append(s, 24)\ns = append(s, 25)\ns = append(s, 26)\ns = append(s, 27)\ns = append(s, 28)\ns = append(s, 29)\ns = append(s, 30)\ns = append(s, 31)\ns = append(s, 32)\ns = append(s, 33)\ns = append(s, 34)\ns = append(s, 35)\ns = append(s, 36)\ns = append(s, 37)\ns = append(s, 38)\ns = append(s, 39)\ns = append(s, 40)\ns = append(s, 41)\ns = append(s, 42)"}
{"tgt": "m := [26]int{}\nfor _, b := range B {\n\tcount := counter(b)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tm[i] = count[i]\n\t\t}\n\t}\n}\nres := []string{}\nfor _, a := range A {\n\tcount := counter(a)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tcontinueL\n\t\t}\n\t}\n\tres = append(res, a)\n}\nreturn res", "gen": "var a [26]string\nvar b [26]string\nvar c [26]string\nvar d [26]string\nvar e [26]string\nvar f [26]string\nvar g [26]string\nvar h [26]string\nvar i [26]string\nvar j [26]string\nvar k [26]string\nvar l [26]string\nvar m [26]string\nvar n [26]string\nvar o [26]string\nvar p [26]string\nvar q [26]string\nvar r [26]string\nvar s [26]string\nvar t [26]string\nvar u [26]string\nvar v [26]string\nvar w [26]string\nvar x [26]string\nvar y [26]string\nvar z [26]string\nvar aa [26]string\nvar bb [26]string\nvar cc [26]string\nvar dd [26]string\nvar ee [26]string\nvar ff [26]string\nvar gg [26]string\nvar hh [26]string\nvar ii [26]string\nvar jj [26]string\nvar kk [26]string\nvar ll [26]string\nvar mm [26]string\nvar nn [26]string\nvar oo [26]string\nvar pp [26]string\nvar qq [26]string\nvar rr [26]string\nvar ss [26]string\nvar tt [26]string\nvar uu [26]string\nvar vv [26]string\nvar ww [26]string\nvar xx [26]string\nvar yy [26]string\nvar zz [26]string\nvar aaa [26]string\nvar bbb [26]"}
{"tgt": "bulls, cows := 0, 0\nnums := [10]int{}\nfor i := 0; i < len(secret); i++ {\n\ts, g := int(secret[i]-'0'), int(guess[i]-'0')\n\tif s == g {\n\t\tbulls++\n\t} else {\n\t\tif nums[s] < 0 {\n\t\t\tcows++\n\t\t}\n\t\tif nums[g] > 0 {\n\t\t\tcows++\n\t\t}\n\t\tnums[s]++\n\t\tnums[g]--\n\t}\n}\nreturn fmt.Sprintf(\"STR\", bulls, cows)", "gen": "var a [10]int\nvar b [10]int\nvar c [2]int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\n"}
{"tgt": "t.Parallel()\nfor _, l := range mathTestData {\n\tif log2Floor(l.n) != l.f || log2Ceil(l.n) != l.c {\n\t\tt.Errorf(\"STR\",\n\t\t\tl.n, l.f, l.c, log2Floor(l.n), log2Ceil(l.n))\n\t}\n}", "gen": "testing.MainStart(nil, nil, nil)\ntesting.Main(&testing.M{\n\tMatchString: matchString,\n\tBenchmark:   benchmark,\n})\n}"}
{"tgt": "bs := strings.Builder{}\nvar dfs func(*TreeNode)\ndfs = func(node *TreeNode) {\n\tif node == nil {\n\t\treturn\n\t}\n\tbs.WriteString(strconv.Itoa(node.Val))\n\tif node.Left == nil && node.Right == nil {\n\t\treturn\n\t}\n\tbs.WriteByte('(')\n\tif node.Left != nil {\n\t\tdfs(node.Left)\n\t}\n\tbs.WriteByte(')')\n\tif node.Right != nil {\n\t\tbs.WriteByte('(')\n\t\tdfs(node.Right)\n\t\tbs.WriteByte(')')\n\t}\n}\ndfs(t)\nreturn bs.String()", "gen": "fmt.Println(tree2str(nil))\n}\n"}
{"tgt": "return nil == root || isSame(root.Left, root.Right)", "gen": "var a, b int\nfmt.Scan(&a, &b)\nif a == b {\n\tfmt.Println(\"true\")\n} else {\n\tfmt.Println(\"false\")\n}\n}\n"}
{"tgt": "cases := []struct {\n\tname      string\n\tflowerbed []int\n\tn         int\n\texpect    bool\n}{\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 1, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 2, false},\n\t{\"STR\", []int{1, 0, 1, 0}, 0, true},\n\t{\"STR\", []int{0}, 1, true},\n\t{\"STR\", []int{1, 0, 1, 0, 1, 0, 1}, 1, false},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.flowerbed, c.n)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.flowerbed, c.n)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "const maxDiv = 20\ni, div := maxDiv, maxDiv-1\nfor {\n\tif i%div == 0 {\n\t\tif div > 1 {\n\t\t\tdiv--\n\t\t} else {\n\t\t\tfmt.Println(i)\n\t\t\tos.Exit(0)\n\t\t}\n\t} else {\n\t\ti += maxDiv\n\t\tdiv = maxDiv - 1\n\t}\n}", "gen": "var a int\nvar b int\nfmt.Scan(&a, &b)\nif b == 0 {\n\tpanic(\"divide by zero\")\n}\nif b < 0 {\n\ta, b = -a, -b\n}\nif a < 0 {\n\ta = -a\n\tb = -b\n}\nvar c int\nc = a / b\nvar d int\nd = a % b\nvar e int\ne = c\nvar f int\nf = d\nvar g int\ng = e\nvar h int\nh = f\nvar i int\ni = g\nvar j int\nj = h\nvar k int\nk = i\nvar l int\nl = j\nvar m int\nm = k\nvar n int\nn = l\nvar o int\no = m\nvar p int\np = n\nvar q int\nq = o\nvar r int\nr = p\nvar s int\ns = q\nvar t int\nt = r\nvar u int\nu = s\nvar v int\nv = t\nvar w int\nw = u\nvar x int\nx = v\nvar y int\ny = w\nvar z int\nz = x\nvar aa int\naa = y\nvar bb int\nbb = z\nvar cc int\ncc = aa\nvar dd int\ndd = bb\nvar ee int\nee = cc\nvar ff int\nff = dd\nvar gg int\ngg = ee\nvar hh int\nhh = ff\nvar ii int\nii = gg\nvar jj int\njj = hh\nvar kk int\nkk = ii\nvar ll int\nll = jj\nvar mm int\nmm = kk\nvar nn int\nnn = ll\nvar oo int\noo = mm\nvar"}
