{"tgt": "fmt.Println(mostCommonWord(\"STR\", []string{\"STR\", \"STR\"}))", "gen": "fmt.Println(mostCommonWord([]string{\"STR\", \"STR\", \"STR\"}, \"STR\"))\n}"}
{"tgt": "if nil == nums || len(nums) == 0 {\n\treturn\n}\ninsertPos := 0\nfor _, values := range nums {\n\tif 0 != values {\n\t\tnums[insertPos] = values\n\t\tinsertPos++\n\t}\n}\nfor insertPos < len(nums) {\n\tnums[insertPos] = 0\n\tinsertPos++\n}", "gen": "if len(nums) == 0 || len(nums) == 1 {\n\treturn\n}\nif len(nums) == 2 {\n\tnums[1], nums[0] = nums[0], nums[1]\n\treturn\n}\nfor i := 0; i < len(nums); i++ {\n\tif nums[i] == 0 {\n\t\tnums[i], nums[0] = nums[0], nums[i]\n\t\tnums[0] = 0\n\t\tfor i := 1; i < len(nums); i++ {\n\t\t\tif nums[i] == 0 {\n\t\t\t\tnums[i], nums[0] = nums[0], nums[i]\n\t\t\t\tnums[0] = 0\n\t\t\t}\n\t\t}\n\t}\n}\n}"}
{"tgt": "cases := []struct {\n\ta, b, expected int\n}{\n\t{\n\t\ta:        0,\n\t\tb:        0,\n\t\texpected: 0,\n\t},\n\t{\n\t\ta:        1,\n\t\tb:        1,\n\t\texpected: 1,\n\t},\n\t{\n\t\ta:        -1,\n\t\tb:        1,\n\t\texpected: -1,\n\t},\n\t{\n\t\ta:        1,\n\t\tb:        -1,\n\t\texpected: -1,\n\t},\n\t{\n\t\ta:        10,\n\t\tb:        2,\n\t\texpected: 2,\n\t},\n}\nfor _, c := range cases {\n\tactual := Min(c.a, c.b)\n\tif actual != c.expected {\n\t\tt.Errorf(\"STR\", c.expected, actual)\n\t}\n}", "gen": "for _, tc := range []struct{\n\ta, b, expected int\n}{\n\t{0, 0, 0},\n\t{1, 1, 1},\n\t{1, -1, -1},\n\t{10, 2, 2},\n} {\n\tif result := Min(tc.a, tc.b); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.a, tc.b, tc.expected, result)\n\t}\n}\n}"}
{"tgt": "ma := 0\nif len(heights) < 0 {\n\treturn 0\n}\nvar stack []int\nfor i := 0; i < len(heights); i++ {\n\tif i == 0 {\n\t\tstack = append(stack, heights[i])\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tcontinue\n\t}\n\tif heights[i-1] > heights[i] {\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tstack = changeStack(stack, heights[i])\n\t}\n\tstack = append(stack, heights[i])\n\tif i+1 == len(heights) {\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tcontinue\n\t}\n}\nreturn ma", "gen": "max := 0\nstack := []int{}\nfor i := 0; i < len(height); i++ {\n\tif len(stack) == 0 || height[i] > height[stack[len(stack)-1]] {\n\t\tstack = append(stack, i)\n\t} else {\n\t\th := height[stack[len(stack)-1]]\n\t\tstack = stack[:len(stack)-1]\n\t\tmax = maxArea(height, stack, h, i)\n\t}\n}\nfor len(stack) > 0 {\n\th := height[stack[len(stack)-1]]\n\tstack = stack[:len(stack)-1]\n\tmax = maxArea(height, stack, h, len(height))\n}\nreturn max\n}"}
{"tgt": "min := func(a, b int) int {\n\treturn int(math.Min(float64(a), float64(b)))\n}\ndp := make([]int, 2)\ndp[0], dp[1] = cost[0], cost[1]\nfor i := 2; i < len(cost); i++ {\n\tdp[i%2] = cost[i] + min(dp[0], dp[1])\n}\nreturn min(dp[0], dp[1])", "gen": "var f func(int) int\nf = func(i int) int {\n\tif i == 0 {\n\t\treturn 0\n\t}\n\tif i == 1 {\n\t\treturn 0\n\t}\n\treturn f(i-1) + f(i-2)\n}\nfor i := 2; i < len(cost); i++ {\n\tcost[i] = f(cost[i])\n}\nreturn f(len(cost) - 1)\n}"}
{"tgt": "temp, mask := num, 0\nfor temp > 0 {\n\tmask = mask*2 + 1\n\ttemp /= 2\n}\nreturn mask ^ num", "gen": "n := uint(0)\nfor n < x {\n\tn += n + 1\n}\nreturn x ^ n\n}"}
{"tgt": "listNode1 := &ListNode{\n\tVal: 4,\n\tNext: &ListNode{\n\t\tVal: 1,\n\t\tNext: &ListNode{\n\t\t\tVal:  4,\n\t\t\tNext: nil,\n\t\t},\n\t},\n}\nlistNode2 := &ListNode{\n\tVal: 1,\n\tNext: &ListNode{\n\t\tVal: 8,\n\t\tNext: &ListNode{\n\t\t\tVal:  4,\n\t\t\tNext: nil,\n\t\t},\n\t},\n}\ngetIntersectionNode(listNode1, listNode2)", "gen": "headA := &ListNode{Val: 1, Next: nil}\nheadB := &ListNode{Val: 4, Next: nil}\nheadA.Next = headB\nheadB.Next = headA\nheadC := &ListNode{Val: 1, Next: nil}\nheadD := &ListNode{Val: 4, Next: nil}\nheadC.Next = headD\nheadD.Next = headC\nheadE := &ListNode{Val: 1, Next: nil}\nheadF := &ListNode{Val: 4, Next: nil}\nheadE.Next = headF\nheadF.Next = headE\nheadG := &ListNode{Val: 1, Next: nil}\nheadH := &ListNode{Val: 4, Next: nil}\nheadG.Next = headH\nheadH.Next = headG\nheadI := &ListNode{Val: 1, Next: nil}\nheadJ := &ListNode{Val: 4, Next: nil}\nheadI.Next = headJ\nheadJ.Next = headI\nheadK := &ListNode{Val: 1, Next: nil}\nheadL := &ListNode{Val: 4, Next: nil}\nheadK.Next = headL\nheadL.Next = headK\nheadM := &ListNode{Val: 1, Next: nil}\nheadN := &ListNode{Val: 4, Next: nil}\nheadM.Next = headN\nheadN.Next = headM\nheadO := &ListNode{Val: 1, Next: nil}\nheadP := &ListNode{Val: 4, Next: nil}\nheadO.Next = headP\nheadP.Next = headO\nheadQ := &ListNode{Val: 1, Next: nil}\nheadR := &ListNode{Val: 4, Next: nil}\nheadQ.Next = headR\nheadR.Next = headQ\nheadS := &ListNode{Val: 1, Next"}
{"tgt": "switch {\ncase isIPv4(IP):\n\treturn \"STR\"\ncase isIPv6(IP):\n\treturn \"STR\"\ndefault:\n\treturn \"STR\"\n}", "gen": "if isIPv4(IP) {\n\treturn \"IPv4\"\n}\nif isIPv6(IP) {\n\treturn \"IPv6\"\n}\nreturn \"Neither\"\n}"}
{"tgt": "l := len(preorder)\nif l == 0 {\n\treturn nil\n}\nfor 1 < l && preorder[0] < preorder[l-1] {\n\tl--\n}\nreturn &TreeNode{\n\tVal:   preorder[0],\n\tLeft:  bstFromPreorder(preorder[1:l]),\n\tRight: bstFromPreorder(preorder[l:]),\n}", "gen": "n := len(preorder)\nif n == 0 {\n\treturn nil\n}\nif n == 1 {\n\treturn &TreeNode{Val: preorder[0]}\n}\nroot := &TreeNode{Val: preorder[0]}\nleft := bstFromPreorder(preorder[1:n-1])\nright := bstFromPreorder(preorder[n-1:])\nroot.Left = left\nroot.Right = right\nreturn root\n}"}
{"tgt": "sort.Slice(costs, func(i, j int) bool {\n\treturn abs(costs[i][0]-costs[i][1]) > abs(costs[j][0]-costs[j][1])\n})\ncost, a, b, n := 0, 0, 0, len(costs)/2\nfor _, c := range costs {\n\tif (c[0] < c[1] && a < n) || b == n {\n\t\tcost += c[0]\n\t\ta++\n\t} else {\n\t\tcost += c[1]\n\t\tb++\n\t}\n}\nreturn cost", "gen": "var res int\nvar cost [][]int\ncost = make([][]int, len(flights))\nfor i := range flights {\n\tcost[i] = flights[i]\n}\nsort.Slice(cost, func(i, j int) bool {\n\treturn cost[i][1] < cost[j][1]\n})\nfor i := 0; i < len(cost); i++ {\n\tif i < len(cost)/2 {\n\t\tres += cost[i][0]\n\t} else {\n\t\tres += cost[i][1]\n\t}\n}\nreturn res\n}"}
{"tgt": "println(\"STR\")\nprintln(\"STR\", v1)\nprintln(\"STR\", v2.x, v2.y)\nprintln(\"STR\", len(v3), cap(v3), v3[0], v3[3])\nprintln(\"STR\", len(v4), v4 == nil)\nprintln(\"STR\", len(v5), v5 == nil)\nprintln(\"STR\", v6)\nprintln(\"STR\", cap(v7), string(v7))\nprintln(uint8SliceSrc[0])\nprintln(uint8SliceDst[0])\nprintln(intSliceSrc[0])\nprintln(intSliceDst[0])", "gen": "println(\"STR\", v1, v2, v3[0], v3[1], v3[2], v4, v5, v6, v7, uint8SliceSrc[0], uint8SliceDst[0], intSliceSrc[0], intSliceDst[0])\n}"}
{"tgt": "words := strings.Fields(s)\nreturn strings.Join(reverseSlice(words), \"STR\")", "gen": "return strings.Join(reverseSlice(strings.Fields(s)), \"STR\")\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect bool\n}{\n\t{\"STR\", []int{1, 2, 2, 3}, true},\n\t{\"STR\", []int{4, 3, 3, 2}, true},\n\t{\"STR\", []int{1, 3, 2}, false},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "var solution = Solution{\n\tName: \"STR\",\n\tCases: []struct {\n\t\tInputs  []int\n\t\tExpects bool\n\t}{\n\t\t{[]int{1, 2, 2, 3}, true},\n\t\t{[]int{4, 3, 2, 1}, false},\n\t\t{[]int{1, 3, 2}, false},\n\t},\n}\nfor i, c := range solution.Cases {\n\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := solution.IsStraight(c.Inputs)\n\t\tif !reflect.DeepEqual(got, c.Expects) {\n\t\t\tt.Fatalf(\"STR\", c.Inputs, got, c.Expects)\n\t\t}\n\t})\n}\n}"}
{"tgt": "indexs := make([]int, 123)\nfor i, c := range order {\n\tindexs[c] = i\n}\nless := func(i, j int) bool {\n\tsi, sj := len(words[i]), len(words[j])\n\tfor k := 0; k < si && k < sj; k++ {\n\t\tii, ij := indexs[words[i][k]], indexs[words[j][k]]\n\t\tswitch {\n\t\tcase ii < ij:\n\t\t\treturn true\n\t\tcase ii > ij:\n\t\t\treturn false\n\t\t}\n\t}\n\treturn si <= sj\n}\nfor i := 1; i < len(words); i++ {\n\tif !less(i-1, i) {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var s []rune\nfor _, c := range word1 {\n\ts = append(s, c)\n}\nfor _, c := range word2 {\n\ts = append(s, c)\n}\nfor i := 0; i < len(s); i++ {\n\tif s[i] != word1[i] && s[i] != word2[i] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "row := len(grid)\ncol := len(grid[0])\ndp := make([][]int, row)\nfor i := 0; i < row; i++ {\n\tdp[i] = make([]int, col)\n}\ndp[0][0] = grid[0][0]\nfor i := 1; i < row; i++ {\n\tdp[i][0] = dp[i-1][0] + grid[i][0]\n}\nfor i := 1; i < col; i++ {\n\tdp[0][i] = dp[0][i-1] + grid[0][i]\n}\nfor i := 1; i < row; i++ {\n\tfor j := 1; j < col; j++ {\n\t\tdp[i][j] = Min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\t}\n}\nreturn dp[row-1][col-1]", "gen": "n := len(A)\ndp := make([][]int, n)\nfor i := 0; i < n; i++ {\n\tdp[i] = make([]int, n)\n\tdp[i][i] = A[i]\n}\nfor i := 1; i < n; i++ {\n\tfor j := 0; j < i; j++ {\n\t\tdp[i][j] = Min(dp[i-1][j], dp[i-1][j+1]) + A[i]\n\t}\n}\nfor i := n - 2; i >= 0; i-- {\n\tfor j := i + 1; j < n; j++ {\n\t\tdp[i][j] = Min(dp[i+1][j], dp[i+1][j-1]) + A[i]\n\t}\n}\nreturn dp[0][0]\n}"}
{"tgt": "fmt.Fprint(w, \"STR\")", "gen": "fmt.Fprint(w, \"STR\")\n}"}
{"tgt": "l := len(nums)\nk %= l\ns := make([]int, l)\ncopy(s, nums)\nfor i, v := range s[l-k:] {\n\tnums[i] = v\n}\nfor i, v := range s[:l-k] {\n\tnums[k+i] = v\n}", "gen": "n := len(nums)\nif n == 0 {\n\treturn nil\n}\nres := make([]int, n)\nfor i := 0; i < n; i++ {\n\tres[i] = nums[i]\n}\nfor i := 0; i < n; i++ {\n\tres[i] = nums[i]\n}\nfor i := 0; i < n; i++ {\n\tres[i] = nums[i]\n}\nreturn res\n}"}
{"tgt": "if p == nil || q == nil {\n\treturn p == q\n}\nreturn isSameTree(p.Left, q.Left) && p.Val == q.Val && isSameTree(p.Right, q.Right)", "gen": "if p == nil && q == nil {\n\treturn true\n}\nif p == nil || q == nil {\n\treturn false\n}\nreturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\n}"}
{"tgt": "for cur := t.root; cur != nil; {\n\tif cur.Key == key {\n\t\treturn cur\n\t} else if key < cur.Key {\n\t\tcur = cur.left\n\t} else {\n\t\tcur = cur.right\n\t}\n}\nreturn nil", "gen": "if root == nil {\n\treturn nil, nil\n}\nfor root != nil {\n\tif root.value == value {\n\t\treturn root, root\n\t} else if root.value < value {\n\t\troot = root.right\n\t} else {\n\t\troot = root.left\n\t}\n}\nreturn nil, nil\n}"}
{"tgt": "s := []int{}\nfor _, asteroid := range asteroids {\n\tfor len(s) != 0 && s[len(s)-1] > 0 && s[len(s)-1] < -asteroid {\n\t\ts = s[:len(s)-1]\n\t}\n\tif len(s) == 0 || asteroid > 0 || s[len(s)-1] < 0 {\n\t\ts = append(s, asteroid)\n\t} else if asteroid < 0 && s[len(s)-1] == -asteroid {\n\t\ts = s[:len(s)-1]\n\t}\n}\nreturn s", "gen": "res := []int{}\nfor _, num := range nums {\n\tif len(res) == 0 || res[len(res)-1] != num {\n\t\tres = append(res, num)\n\t} else {\n\t\tres[len(res)-1] = num\n\t}\n}\nreturn res\n}"}
{"tgt": "sum := 0\nsunday := 5\nyear := 1901\nis_leap := false\nfor year < 2001 {\n\tchecker := month_len\n\tif is_leap {\n\t\tchecker = leap_len\n\t}\n\ttally := sunday\n\tfor _, v := range checker {\n\t\tif tally == 0 {\n\t\t\tsum += 1\n\t\t}\n\t\tif tally < v {\n\t\t\tbreak\n\t\t}\n\t\tif tally >= v {\n\t\t\ttally -= v\n\t\t}\n\t}\n\tsunday += 7\n\tif is_leap && sunday >= 366 {\n\t\tyear++\n\t\tsunday = sunday % 366\n\t\tis_leap = false\n\t} else if !is_leap && sunday >= 365 {\n\t\tyear++\n\t\tsunday = sunday % 365\n\t\tif year%4 == 0 {\n\t\t\tis_leap = true\n\t\t}\n\t}\n}\nfmt.Printf(\"STR\", year, sum)", "gen": "month_len := []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}\nleap_len := []int{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}\nmonth_len_len := len(month_len)\nmonth := 5\nyear := 1901\nleap := false\nfor {\n\tif !leap {\n\t\tmonth_len = month_len\n\t} else {\n\t\tmonth_len = leap_len\n\t}\n\tfor {\n\t\tif month < month_len_len {\n\t\t\tbreak\n\t\t}\n\t\tyear += 1\n\t\tmonth -= month_len_len\n\t\tleap = !leap\n\t\tmonth_len_len = len(month_len)\n\t}\n\tif year > 2000 {\n\t\tbreak\n\t}\n\tif month == 0 {\n\t\tyear += 1\n\t\tmonth = 1\n\t\tleap = false\n\t}\n\tif year%400 == 0 || (year%4 == 0 && year%100 != 0) {\n\t\tleap = true\n\t}\n\tif year%4 == 0 && year%100 == 0 {\n\t\tmonth += 1\n\t}\n\tif year%4 == 0 && year%100 != 0 {\n\t\tmonth += 1\n\t}\n\tif year%400 == 0 {\n\t\tmonth += 1\n\t}\n\tif year%4 == 0 && year%100 == 0 {\n\t\tmonth += 1\n\t}\n\tif year%4 =="}
{"tgt": "max, winner := 0, 0\nfor i := 1; i < 1000000; i++ {\n\tterms := collatz(i)\n\tif terms > max {\n\t\tmax = terms\n\t\twinner = i\n\t}\n}\nfmt.Println(\"STR\", max, \"STR\", winner)", "gen": "max := 1\nmaxNum := 1\nfor i := 2; i < 1000000; i++ {\n\tn := collatz(i)\n\tif n > max {\n\t\tmax = n\n\t\tmaxNum = i\n\t}\n}\nfmt.Println(maxNum)\n}"}
{"tgt": "return fmt.Sprintf(\"STR\", c.FirstName, c.LastName, c.Email)", "gen": "return fmt.Sprintf(\"STR\", s.Str, s.Str2)\n}"}
{"tgt": "e.lgu = lgu\ne.mixin = mixin\ne.cluster = make(map[interface{}]*rsVEBTreeElement)\nif e.lgu > 1 {\n\te.summaryLgu = (e.lgu + 1) / 2\n\te.clusterLgu = e.lgu - e.summaryLgu\n\te.summary = new(rsVEBTreeElement).init(e.summaryLgu, e.mixin)\n} else {\n\te.summaryLgu = 0\n\te.clusterLgu = 0\n}\nreturn e", "gen": "t.root = &rsVEBTreeElement{\n\tkey:   key,\n\tvalue: value,\n}\nif t.size > 1 {\n\tt.root.parent = t.root\n\tt.root.left = t.root\n\tt.root.right = t.root\n\tt.root.left.parent = t.root\n\tt.root.right.parent = t.root\n}\nt.size++\nreturn t.root\n}"}
{"tgt": "if isValid := checkHorizontal(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkVertical(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkReachable(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkRotationallySymmetric(puzzle); !isValid {\n\treturn false\n}\nreturn true", "gen": "if checkHorizontal(board) ||\n\tcheckVertical(board) ||\n\tcheckReachable(board) ||\n\tcheckRotationallySymmetric(board) {\n\treturn false\n}\nreturn true\n}"}
{"tgt": "b.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})", "gen": "benchmarkSolution.Run(\"STR\", func(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSolution(STR)\n\t}\n})\nbenchmarkSolution.Run(\"STR\", func(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSolution(STR)\n\t}\n})\nbenchmarkSolution.Run(\"STR\", func(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSolution(STR)\n\t}\n})\nbenchmarkSolution.Run(\"STR\", func(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSolution(STR)\n\t}\n})\n}"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := SumRevLLNum(tc.first, tc.second); !equal(result, tc.sum) {\n\t\tt.Errorf(\"STR\",\n\t\t\ttcid, String(result), String(tc.sum))\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := SumRevLLNum(tc.num); !equal(res, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.num, res, tc.expected)\n\t}\n}\n}"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA `structs:\"STR\"`\n\tC  int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif ok {\n\tt.Error(\"STR\")\n}", "gen": "t.Error(\"STR\")\nif HasZero(STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR{STR"}
{"tgt": "nums := []int{1, 1, 2, 2, 3, 3}\nfmt.Println(distributeCandies(nums))\nnums2 := []int{1, 1, 2, 3}\nfmt.Println(distributeCandies(nums2))", "gen": "fmt.Println(distributeCandies([]int{1, 1, 2, 2, 3, 3}))\nfmt.Println(distributeCandies([]int{1, 1, 2, 3}))\n}"}
{"tgt": "i, j := start, len(nums)-1\nfor i < j {\n\tnums[i], nums[j] = nums[j], nums[i]\n\ti++\n\tj--\n}", "gen": "for i := 0; i < len(A); i++ {\n\tfor j := 0; j < len(B); j++ {\n\t\tA[i], B[j] = B[j], A[i]\n\t}\n}\n}"}
{"tgt": "var val int\nfor n := uint(0); num != 0; num >>= 1 {\n\tval |= (1 - (num & 1)) << n\n\tn++\n}\nreturn val", "gen": "var ans uint64\nfor i := uint64(0); i < 64; i++ {\n\tif n&1 == 1 {\n\t\tans |= 1 << i\n\t}\n\tn >>= 1\n}\nreturn ans\n}"}
{"tgt": "size := len(A)\nres := make([]int, size)\neven, odd := 0, 1\nfor _, a := range A {\n\tif a%2 == 0 {\n\t\tres[even] = a\n\t\teven += 2\n\t} else {\n\t\tres[odd] = a\n\t\todd += 2\n\t}\n}\nreturn res", "gen": "n := len(nums)\nres := make([]int, n)\ni, j := 0, 1\nfor _, num := range nums {\n\tif num&1 == 1 {\n\t\tres[i] = num\n\t\ti++\n\t} else {\n\t\tres[j] = num\n\t\tj++\n\t}\n}\nreturn res\n}"}
{"tgt": "slow, fast := head, head\nfor fast != nil && fast.Next != nil {\n\tslow = slow.Next\n\tfast = fast.Next.Next\n}\nvar prev *ListNode\nfor slow != nil {\n\tnext := slow.Next\n\tslow.Next = prev\n\tprev, slow = slow, next\n}\nfor p, q := head, prev; p != q; p, q = q, p {\n\tnext := p.Next\n\tp.Next = q\n\tp = next\n}", "gen": "head := node\nfor head.Next != nil {\n\thead = head.Next\n}\nfor head.Next != nil {\n\thead.Next = head.Next.Next\n\thead = head.Next\n}\nreturn node\n}"}
{"tgt": "for _, p := range perm6([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) {\n\tvalid := true\n\tfor _, g := range guesses {\n\t\tvar count int\n\t\tfor i := 0; i < len(p); i++ {\n\t\t\tif p[i] == g.Code[i] {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\tif count != g.Score {\n\t\t\tvalid = false\n\t\t\tbreak\n\t\t}\n\t}\n\tif valid {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "var res []int\npermute([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, 0, &res)\nfor _, r := range res {\n\tif r[0] == r[1] || r[1] == r[2] || r[2] == r[3] || r[3] == r[4] || r[4] == r[5] || r[5] == r[6] || r[6] == r[7] || r[7] == r[8] || r[8] == r[9] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "for i := 0; i < 100000; i++ {\n\tif i%300 == 0 {\n\t\tarray := GetArrayOfSize(i)\n\t\tif len(array) != i {\n\t\t\tfmt.Println(array)\n\t\t\tt.Error()\n\t\t}\n\t}\n}", "gen": "for i := 0; i < 100000; i++ {\n\tif i%300 == 0 && i != 0 {\n\t\tfmt.Println(GetArrayOfSize(i))\n\t\tt.Error()\n\t}\n}\n}"}
{"tgt": "parent := this\nfor _, ch := range prefix {\n\tif child, ok := parent.Children[ch]; ok {\n\t\tparent = child\n\t\tcontinue\n\t}\n\treturn false\n}\nreturn true", "gen": "s := []byte(str)\nfor _, c := range s {\n\tif c > 127 {\n\t\t_, _ = decoderune(s, i)\n\t\tc = s[i]\n\t}\n\tif _, ok := m[c]; ok {\n\t\ts = s[i:]\n\t\tcontinue\n\t}\n\treturn false\n}\nreturn true\n}"}
{"tgt": "sema <- struct{}{}\nb := balance\n<-sema\nreturn b", "gen": "balance <- 100\n<-sema\nreturn balance\n}"}
{"tgt": "pairs := [...][2]int{{10, 7}, {1000, 983}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p26(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "for _, tc := range []struct{\n\tin  int\n\tout int\n}{\n\t{10, 10},\n\t{7, 7},\n\t{1000, 983},\n\t{983, 983},\n} {\n\tif out := p26(tc.in); out != tc.out {\n\t\tt.Errorf(\"STR\", tc.in, tc.out, out)\n\t}\n}\n}"}
{"tgt": "for i := 0; i < n; i++ {\n\tif len(squares) != i {\n\t\tprintln(\"STR\", len(squares), \"STR\", i)\n\t}\n\tsquares[i] = i * i\n\tfor j := 0; j <= i; j++ {\n\t\tif v, ok := squares[j]; !ok || v != j*j {\n\t\t\tif !ok {\n\t\t\t\tprintln(\"STR\", j)\n\t\t\t} else {\n\t\t\t\tprintln(\"STR\", j, v)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "for i := 0; i < n; i++ {\n\tif i == 0 {\n\t\tm[i] = 1\n\t} else {\n\t\tm[i] = i * m[i-1]\n\t}\n\tfor j := 0; j < i; j++ {\n\t\tif j == 0 {\n\t\t\tif i%2 == 0 {\n\t\t\t\tfmt.Println(\"STR\", i, \"STR\", j)\n\t\t\t}\n\t\t} else {\n\t\t\tif i%2 == 0 {\n\t\t\t\tfmt.Println(\"STR\", i, \"STR\", j)\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"STR\", i, \"STR\", j)\n\t\t\t}\n\t\t}\n\t}\n}\n}"}
{"tgt": "for _, word := range words {\n\tremainNum[word] = 0\n}\nfor _, word := range words {\n\tremainNum[word]++\n}\nreturn 0", "gen": "var count int\nfor _, v := range m {\n\tcount += v\n}\nfor k, v := range m {\n\tm[k] = v + 1\n}\nreturn count\n}"}
{"tgt": "ad := admin{\n\tuser: user{\n\t\tname:  \"STR\",\n\t\temail: \"STR\",\n\t},\n\tlevel: \"STR\",\n}\nad.user.notify()\nad.notify()", "gen": "user.notify(STR, 10)\nadmin.notify(STR, 14)\nadmin.notify(STR, 5)\n}"}
{"tgt": "if !ok {\n\tpanic(\"STR\")\n}", "gen": "if !c.IsValid() {\n\tpanic(\"STR\")\n}\n}"}
{"tgt": "sum := 0\nprev := 1\ncurr := 1\nfor curr <= 4e6 {\n\tprev, curr = curr, prev+curr\n\tif curr%2 == 0 {\n\t\tsum += curr\n\t}\n}\nfmt.Println(sum)", "gen": "sum := 0\nfor i := 1; i <= 4000000; i++ {\n\tif i%2 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "dist := func(i int) int {\n\tx, y := points[i][0], points[i][1]\n\treturn x*x + y*y\n}\npartition := func(l, r int) int {\n\tpivot, pdist := l, dist(l)\n\tpoints[pivot], points[r] = points[r], points[pivot]\n\tdivider := l\n\tfor i := l; i < r; i++ {\n\t\tif dist(i) < pdist {\n\t\t\tpoints[i], points[divider] = points[divider], points[i]\n\t\t\tdivider++\n\t\t}\n\t}\n\tpoints[divider], points[r] = points[r], points[divider]\n\treturn divider\n}\nl, r := 0, len(points)-1\nfor l < r {\n\ti := partition(l, r)\n\tif i == K {\n\t\tbreak\n\t} else if i > K {\n\t\tr = i - 1\n\t} else {\n\t\tl = i + 1\n\t}\n}\nreturn points[:K]", "gen": "var (\n\tclosest = make([]int, 0, len(points))\n\ti       = 0\n\tj       = len(points) - 1\n)\nfor i <= j {\n\tif abs(points[i]-target) < abs(points[j]-target) {\n\t\tclosest = append(closest, points[i])\n\t\ti++\n\t} else {\n\t\tclosest = append(closest, points[j])\n\t\tj--\n\t}\n}\nreturn closest\n}"}
{"tgt": "if c < 0 {\n\treturn false\n}\nl, r := 0, mySqrt(c)\nfor l <= r {\n\tcur := l*l + r*r\n\tif cur < c {\n\t\tl++\n\t} else if cur > c {\n\t\tr--\n\t} else {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "if x < 0 {\n\treturn false\n}\nleft, right := 0, x\nfor left <= right {\n\tmid := left + (right-left)>>1\n\tif mid*mid < x {\n\t\tleft = mid + 1\n\t} else if mid*mid > x {\n\t\tright = mid - 1\n\t} else {\n\t\treturn true\n\t}\n}\nreturn false\n}"}
{"tgt": "n := len(edges)\nparent := make([]int, n+1)\nfor i := 0; i < n; i++ {\n\tparent[i] = i\n}\nvar i int\nvar e []int\nfor i, e = range edges {\n\tf, t := e[0], e[1]\n\tpf := find(parent, f)\n\tpt := find(parent, t)\n\tif pf == pt {\n\t\tbreak\n\t}\n\tparent[pf] = pt\n}\nreturn edges[i]", "gen": "n := len(nums)\nres := make([]int, n)\nfor i := 0; i < n; i++ {\n\tres[i] = i\n}\nfor i := 0; i < n; i++ {\n\tres[i] = find(res, i, i)\n\tres[i] = find(res, i, i+1)\n}\nreturn res\n}"}
{"tgt": "var bin strings.Builder\nfor head != nil {\n\tbin.WriteString(strconv.Itoa(head.Val))\n\thead = head.Next\n}\ni, _ := strconv.ParseInt(bin.String(), 2, 64)\nreturn int(i)", "gen": "var sb strings.Builder\nfor p := root; p != nil; p = p.Left {\n\tsb.WriteString(strconv.Itoa(p.Val))\n}\ni, _ := strconv.ParseInt(sb.String(), 64, 2)\nreturn i\n}"}
{"tgt": "if n == 0 {\n\treturn 0\n}\nreturn n/5 + trailingZeroes(n/5)", "gen": "if n == 0 {\n\treturn 0\n}\nreturn trailingZeroes(n / 5) + n/5\n}"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tpuzzle := make([][]rune, len(tc.puzzle))\n\tfor i := range puzzle {\n\t\tpuzzle[i] = []rune(tc.puzzle[i])\n\t}\n\tif result := FindWordLD(puzzle, []rune(tc.target)); result != tc.expected {\n\t\tt.Errorf(\"STR\", tcid, tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\ts := tc.s\n\twant := tc.want\n\tgot := FindWordLD(s)\n\tif got != want {\n\t\tt.Errorf(\"STR\", tc.s, got, want)\n\t}\n}\n}"}
{"tgt": "start := 0\nend := len(s) - 1\nfor start < end {\n\ts[start], s[end] = s[end], s[start]\n\tstart++\n\tend--\n}\nreturn s", "gen": "for i := 0; i < len(nums)-1; i++ {\n\tfor j := len(nums) - 1; j > i; j-- {\n\t\tif nums[i] == nums[j] {\n\t\t\tnums[j] = nums[len(nums)-1]\n\t\t\tnums = nums[:len(nums)-1]\n\t\t}\n\t}\n}\nreturn nums\n}"}
{"tgt": "if m == 0 {\n\treturn 1\n}\nswitch n {\ncase 1:\n\treturn 2\ncase 2:\n\tif m == 1 {\n\t\treturn 3\n\t}\n\treturn 4\ndefault:\n\tswitch m {\n\tcase 1:\n\t\treturn 4\n\tcase 2:\n\t\treturn 7\n\tdefault:\n\t\treturn 8\n\t}\n}", "gen": "if n == 0 {\n\treturn 1\n}\nif n == 1 {\n\treturn 2\n}\nif n == 2 {\n\treturn 3\n}\nif n == 3 {\n\treturn 4\n}\nif n == 4 {\n\treturn 7\n}\nif n == 5 {\n\treturn 8\n}\nreturn 9\n}"}
{"tgt": "last, n := 0, len(s)\nfor i := 1; i < n; i++ {\n\tif s[i-1] == s[i] {\n\t\tcontinue\n\t}\n\tfor l := 0; i+l < n; l++ {\n\t\tif s[last+l] < s[i+l] {\n\t\t\tlast = i\n\t\t\tbreak\n\t\t}\n\t\tif s[last+l] > s[i+l] {\n\t\t\tbreak\n\t\t}\n\t}\n}\nreturn s[last:]", "gen": "max := 0\nfor i := 1; i < len(s); i++ {\n\tfor j := 0; j < i; j++ {\n\t\tif s[i] == s[j] && (i-j)%2 == 0 {\n\t\t\tmax = i - j\n\t\t\tbreak\n\t\t}\n\t}\n}\nreturn max\n}"}
{"tgt": "fmt.Println(checkPerfectNumber(6))\nfmt.Println(checkPerfectNumber(28))\nfmt.Println(checkPerfectNumber(30))", "gen": "fmt.Println(checkPerfectNumber(6))\nfmt.Println(checkPerfectNumber(28))\nfmt.Println(checkPerfectNumber(30))\n}"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := EqualWithShifting(tc.A, tc.B); result != tc.expected {\n\t\tt.Errorf(\"STR\", tcid, tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := EqualWithShifting(tc.s1, tc.s2); res != tc.res {\n\t\tt.Errorf(\"STR\", tc.s1, tc.s2, tc.res, res)\n\t}\n}\n}"}
{"tgt": "s = strings.TrimSpace(s)\n_, err := strconv.ParseFloat(s, 64)\nreturn err == nil || err.(*strconv.NumError).Err != strconv.ErrSyntax", "gen": "s = strings.TrimSpace(s)\nf, err := strconv.ParseFloat(s, 64)\nreturn err == nil && f == 0\n}"}
{"tgt": "qs := []question76{\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans76, q.para76\n\tfmt.Printf(\"STR\", p, minWindow(p.s, p.p))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question76{\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\", 0},\n\t},\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\", 0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans76, q.para76\n\tfmt.Printf(\"STR\", p,STR)\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0}, 5},\n\t{\"STR\", []int{0, 0, 0, 0, 1}, []int{1, 0, 0, 0, 0}, 4},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums1, c.nums2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums1, c.nums2)\n\t\t}\n\t})\n}", "gen": "var tests = []struct {\n\tname  string\n\tnums1 []int\n\tnums2 []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3}, []int{2, 1}, 1},\n\t{\"STR\", []int{3, 2, 1}, []int{1, 2}, 3},\n\t{\"STR\", []int{0, 0, 0}, []int{1, 2, 3}, 0},\n}\nfor i, tt := range tests {\n\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := findMedianSortedArrays(tt.nums1, tt.nums2)\n\t\tif got != tt.expect {\n\t\t\tt.Errorf(\"STR\", tt.name, tt.nums1, tt.nums2, tt.expect, got)\n\t\t}\n\t})\n}\n}"}
{"tgt": "return strings.ReplaceAll(r.element.Name, \"STR\", \"\")", "gen": "return strings.ReplaceAll(s, \"STR\", \"STRSTR\")\n}"}
{"tgt": "result := Mul3And5(5)\nif result != 3 {\n\tt.Errorf(\"STR\", result, 3)\n}\nresult = Mul3And5(6)\nif result != 8 {\n\tt.Errorf(\"STR\", result, 8)\n}\nresult = Mul3And5(7)\nif result != 14 {\n\tt.Errorf(\"STR\", result, 14)\n}\nresult = Mul3And5(10)\nif result != 23 {\n\tt.Errorf(\"STR\", result, 23)\n}\nresult = Mul3And5(11)\nif result != 33 {\n\tt.Errorf(\"STR\", result, 33)\n}", "gen": "if Mul3And5(5) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(7) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(10) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(13) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(17) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(20) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(23) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(26) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(30) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(33) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(37) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(40) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(43) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(46) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(50) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(53) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5"}
{"tgt": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\", \"STR\"},\n\t\tans1108{\"STR\", \"STR\"},\n\t},\n}\nfmt.Printf(\"STR\", \"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", \"STR\")\n}\n}"}
{"tgt": "if root == nil {\n\treturn nil\n}\nif root.Key == key {\n\treturn root\n} else if root.Key < key {\n\troot = root.Right\n} else {\n\troot = root.Left\n}\nreturn Get(root, key)", "gen": "if root == nil {\n\treturn nil\n}\nif root.Value == value {\n\treturn root\n}\nif root.Value > value {\n\treturn Get(root.Left, value)\n}\nreturn Get(root.Right, value)\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1},\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1, 4, 2},\n\t\twant: 6,\n\t},\n\t{\n\t\tin:   []int{1},\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   []int{2, 1, 1, 2, 1, 3, 3, 3, 1, 3, 1, 3, 2},\n\t\twant: 7,\n\t},\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1},\n\t\twant: 2,\n\t},\n}\nfor _, tt := range tests {\n\tgot := findShortestSubArray(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "nums1 := []int{1, 2, 2, 3, 1}\nexpect1 := 2\nnums2 := []int{1, 2, 2, 3, 1, 4, 2, 3}\nexpect2 := 6\nnums3 := []int{1, 2, 2, 3, 1, 4, 2, 3, 1, 4, 2, 3}\nexpect3 := 13\nfor i := 0; i < len(nums1); i++ {\n\tgot := findShortestSubArray(nums1)\n\tif got != expect1 {\n\t\tt.Fatalf(\"STR\", expect1, got)\n\t}\n}\nfor i := 0; i < len(nums2); i++ {\n\tgot := findShortestSubArray(nums2)\n\tif got != expect2 {\n\t\tt.Fatalf(\"STR\", expect2, got)\n\t}\n}\nfor i := 0; i < len(nums3); i++ {\n\tgot := findShortestSubArray(nums3)\n\tif got != expect3 {\n\t\tt.Fatalf(\"STR\", expect3, got)\n\t}\n}\n}"}
{"tgt": "fmt.Println(runtime.GOOS, runtime.GOARCH)", "gen": "fmt.Println(\"STR\", STR)\n}"}
{"tgt": "result := make([]string, 0)\nstart := -1\nend := -1\nfor i, num := range nums {\n\tif i > 0 && num == nums[i-1]+1 {\n\t\tend = i\n\t} else {\n\t\tif i > 0 {\n\t\t\tresult = appendRanges(result, nums, start, end)\n\t\t}\n\t\tstart = i\n\t\tend = i\n\t}\n}\nif end >= 0 {\n\tresult = appendRanges(result, nums, start, end)\n}\nreturn result", "gen": "var res []string\nfor _, num := range nums {\n\tif num == -1 {\n\t\tres = appendRanges(res, -1, -1)\n\t} else {\n\t\tif num < res[len(res)-1] {\n\t\t\tres = appendRanges(res, num, num)\n\t\t} else {\n\t\t\tres[len(res)-1] = num\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "pigs := 0\nfor mypow(minutesToTest/minutesToDie+1, pigs) < buckets {\n\tpigs++\n}\nreturn pigs", "gen": "for i := 0; i < -b; i++ {\n\tif mypow(a, i) > x {\n\t\tbreak\n\t}\n}\nreturn i\n}"}
{"tgt": "qs := []question470{\n\t{\n\t\tpara470{},\n\t\tans470{2},\n\t},\n\t{\n\t\tpara470{},\n\t\tans470{0},\n\t},\n\t{\n\t\tpara470{},\n\t\tans470{1},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans470, q.para470\n\tfmt.Printf(\"STR\", p, rand10())\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"STR\")\nfor i := 0; i < len(nums); i++ {\n\tfmt.Printf(\"STR\", rand10(nums[i]))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "if s == nil {\n\treturn false\n}\nreturn isSubtree(s.Left, t) || isSameTree(s, t) || isSubtree(s.Right, t)", "gen": "if root == nil {\n\treturn false\n}\nreturn isSubtree(root, subRoot) || isSameTree(root, subRoot) || isSubtree(root.Right, subRoot)\n}"}
{"tgt": "if p := e.r; e.list != nil && p != &e.list.root {\n\treturn p\n}\nreturn nil", "gen": "if len(s.stack) > 0 {\n\treturn s.stack[len(s.stack)-1]\n}\nreturn 0\n}"}
{"tgt": "switch {\ncase one == nil && two == nil:\n\treturn nil\ncase one == nil:\n\treturn &BinaryTree{two.Val,\n\t\tMergeBinaryTrees(nil, two.Left),\n\t\tMergeBinaryTrees(nil, two.Right),\n\t}\ncase two == nil:\n\treturn &BinaryTree{one.Val,\n\t\tMergeBinaryTrees(one.Left, nil),\n\t\tMergeBinaryTrees(one.Right, nil),\n\t}\n}\nreturn &BinaryTree{one.Val + two.Val,\n\tMergeBinaryTrees(one.Left, two.Left),\n\tMergeBinaryTrees(one.Right, two.Right),\n}", "gen": "if p == nil && q == nil {\n\treturn nil\n}\nif p == nil || q == nil {\n\treturn MergeBinaryTrees(p, q)\n}\nreturn &BinaryTree{\n\tVal:   p.Val + q.Val,\n\tLeft:  MergeBinaryTrees(p.Left, q.Left),\n\tRight: MergeBinaryTrees(p.Right, q.Right),\n}\n}"}
{"tgt": "rets := make([][]int, numRows)\nif numRows == 0 {\n\treturn rets\n}\nrets[0] = []int{1}\nfor i := 1; i < numRows; i++ {\n\trets[i] = make([]int, i+1)\n\trets[i][0] = 1\n\trets[i][i] = 1\n\tfor j := 1; j < i; j++ {\n\t\trets[i][j] = rets[i-1][j-1] + rets[i-1][j]\n\t}\n}\nreturn rets", "gen": "if len(nums) == 0 {\n\treturn []int{1}\n}\nres := make([]int, len(nums)+1)\nres[0] = 1\nfor i := 1; i <= len(nums); i++ {\n\tfor j := 0; j < i; j++ {\n\t\tres[i] += res[j] * res[i-j-1]\n\t}\n}\nreturn res\n}"}
{"tgt": "i, l := 0, len(bits)-1\nfor i < l {\n\ti += bits[i] + 1\n}\nreturn i == l", "gen": "var sum int\nfor i := 0; i < len(nums)-1; i++ {\n\tsum += nums[i] + 1\n}\nreturn sum == len(nums)\n}"}
{"tgt": "fname, lname := \"STR\", \"STR\"\nage := 35\nfmt.Println(Title)\nfmt.Println(\"STR\", fname)\nfmt.Println(\"STR\", lname)\nfmt.Println(\"STR\", age)\nfmt.Println(\"STR\", Country)", "gen": "fmt.Println(\"STR\", \"STR\")\nfmt.Println(\"STR\")\nfmt.Println(STR, STR)\nfmt.Println(STR)\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR\nSTR := STR"}
{"tgt": "for i := 0; i < b.N; i++ {\n\tSum(7, 8, 10)\n}", "gen": "for i := 0; i < len(nums); i++ {\n\tSum(nums[:i+1])\n}\n}"}
{"tgt": "dec := xml.NewDecoder(os.Stdin)\nvar stack []string\nfor {\n\ttok, err := dec.Token()\n\tif err == io.EOF {\n\t\tbreak\n\t} else if err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"STR\", err)\n\t\tos.Exit(1)\n\t}\n\tswitch tok := tok.(type) {\n\tcase xml.StartElement:\n\t\tstack = append(stack, tok.Name.Local)\n\tcase xml.EndElement:\n\t\tstack = stack[:len(stack)-1]\n\tcase xml.CharData:\n\t\tif containsAll(stack, os.Args[1:]) {\n\t\t\tfmt.Printf(\"STR\", strings.Join(stack, \"STR\"), tok)\n\t\t}\n\t}\n}", "gen": "dec := xml.NewDecoder(os.Stdin)\nfor {\n\ttoken, err := dec.Token()\n\tif err == io.EOF {\n\t\tos.Exit(1)\n\t}\n\tif token == nil {\n\t\tos.Exit(1)\n\t}\n\tswitch token.(type) {\n\tcase xml.StartElement:\n\t\tif token.(xml.StartElement).Name.Local == \"STR\" {\n\t\t\treturn\n\t\t}\n\tcase xml.EndElement:\n\t\treturn\n\tcase xml.CharData:\n\t\tif containsAll(token.(xml.CharData).Copy(), os.Args) {\n\t\t\tfmt.Printf(\"STR\")\n\t\t\treturn\n\t\t}\n\t}\n}\n}"}
{"tgt": "var sentences []string\nvar start int\nspaceDelimited := strings.Split(text, \"STR\")\npossibleSentence := false\nfor i, part := range spaceDelimited {\n\trunes := []rune(part)\n\tif part == \"STR\" || !isValid(runes) {\n\t\tpossibleSentence = false\n\t\tcontinue\n\t}\n\tif runes[0] >= 'A' && runes[0] <= 'Z' {\n\t\tpossibleSentence = true\n\t\tstart = i\n\t\tcontinue\n\t}\n\tif last := runes[len(runes)-1]; last == '.' || last == '!' || last == '?' {\n\t\tif possibleSentence {\n\t\t\tsentences = append(sentences, strings.Join(spaceDelimited[start:i+1], \"STR\"))\n\t\t}\n\t}\n}\nreturn sentences", "gen": "var res []string\nfor _, s := range strings.Split(str, \",\") {\n\tif !isValid(s) {\n\t\treturn false\n\t}\n\tif len(s) == 1 {\n\t\tres = append(res, s)\n\t\tcontinue\n\t}\n\tif s[0] == '0' || s[len(s)-1] == '0' {\n\t\treturn false\n\t}\n\tif s[0] == '1' || s[len(s)-1] == '9' {\n\t\tres = append(res, s)\n\t\tcontinue\n\t}\n\tif s[0] == '2' && s[len(s)-1] == '5' {\n\t\tres = append(res, s)\n\t\tcontinue\n\t}\n\tif s[0] == '6' && s[len(s)-1] == '9' {\n\t\tres = append(res, s)\n\t\tcontinue\n\t}\n\tif s[0] == '8' && s[len(s)-1] == '9' {\n\t\tres = append(res, s)\n\t\tcontinue\n\t}\n\tif s[0] == '9' && s[len(s)-1] == '9' {\n\t\tres = append(res, s)\n\t\tcontinue\n\t}\n}\nreturn res\n}"}
{"tgt": "arr := randomSlice(0, 20, 10)\ndeleteSequence := randomSlice(0, 10, 10)\nnodeCnt := 0\nrbt := newRBT()\nfor _, v := range arr {\n\trbt.Insert(uint32(v))\n}\nfor i, v := range deleteSequence {\n\trbt.Delete(uint32(arr[v]))\n\tstop := rbt.PreOrderWalk(rbt.Root(), checkGBT(t, &nodeCnt, *debug))\n\tif stop {\n\t\treturn\n\t}\n\tif nodeCnt != len(deleteSequence)-1-i {\n\t\tt.Log(\"STR\", len(deleteSequence)-1-i, \"STR\", nodeCnt)\n\t\tt.Fail()\n\t}\n\tnodeCnt = 0\n\tif i != len(deleteSequence)-1 {\n\t\tstop = checkRBT(t, rbt)\n\t\tif stop {\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "slice1 := randomSlice(10, 20, 0)\nslice2 := randomSlice(10, 10, 0)\ntree := NewRBT()\nfor _, v := range slice1 {\n\ttree.Insert(v)\n}\nfor _, v := range slice2 {\n\ttree.Delete(v)\n\tif !checkRBT(tree) {\n\t\tt.Log(\"STR\", tree.PreOrderWalk())\n\t\tt.Fail()\n\t}\n}\nfor _, v := range slice2 {\n\ttree.Insert(v)\n\tif !checkRBT(tree) {\n\t\tt.Log(\"STR\", tree.PreOrderWalk())\n\t\tt.Fail()\n\t}\n}\n}"}
{"tgt": "ans := make([]int, len(nums))\nfor i, idx := range index {\n\tcopy(ans[idx+1:], ans[idx:])\n\tans[idx] = nums[i]\n}\nreturn ans", "gen": "res := make([]int, len(nums))\nfor i := 0; i < len(nums); i++ {\n\tres[i] = nums[i] + 1\n}\nreturn res\n}"}
{"tgt": "min, max := A[0], A[0]\nfor _, a := range A {\n\tif a < min {\n\t\tmin = a\n\t}\n\tif a > max {\n\t\tmax = a\n\t}\n}\nif max-min <= K+K {\n\treturn 0\n}\nreturn max - min - K - K", "gen": "min, max := nums[0], nums[0]\nfor _, v := range nums[1:] {\n\tif v < min {\n\t\tmin = v\n\t}\n\tif v > max {\n\t\tmax = v\n\t}\n}\nreturn max - min\n}"}
{"tgt": "left := 0\nright := len(numbers) - 1\nfor left != right {\n\tif numbers[left]+numbers[right] == target {\n\t\tbreak\n\t}\n\tif numbers[left]+numbers[right] > target {\n\t\tright--\n\t}\n\tif numbers[left]+numbers[right] < target {\n\t\tleft++\n\t}\n}\nreturn []int{left + 1, right + 1}", "gen": "left, right := 0, len(nums)-1\nfor left < right {\n\tmid := (left + right) / 2\n\tif nums[mid] < nums[right] {\n\t\tright = mid\n\t} else if nums[mid] > nums[right] {\n\t\tleft = mid + 1\n\t} else {\n\t\tright--\n\t}\n}\nreturn []int{nums[left], nums[left+1]}, 2\n}"}
{"tgt": "for a != nil && b != nil {\n\tif a.Value != b.Value {\n\t\treturn false\n\t}\n\ta = a.Next\n\tb = b.Next\n}\nreturn a == nil && b == nil", "gen": "for head1 != nil && head2 != nil {\n\tif head1.Val != head2.Val {\n\t\treturn false\n\t}\n\thead1 = head1.Next\n\thead2 = head2.Next\n}\nreturn head1 == nil && head2 == nil\n}"}
{"tgt": "return func(treebinaryTreeIf, node interface{}) bool {\n\tn := node.(*gbtElement)\n\tif !tree.IsNil(n.Left) && n.Left.Key >= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Left, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif !tree.IsNil(n.Right) && n.Right.Key <= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Right, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif debug {\n\t\tfmt.Println(n)\n\t}\n\t*nodeCnt++\n\treturn false\n}", "gen": "t := t1{\n\tt: t,\n}\nt.nodeCnt = 0\nt.debug2 = debug\nreturn t, t.nodeCnt, &t\n}"}
{"tgt": "n := len(A)\nif n == 0 {\n\treturn A\n}\nabs := func(num int) int { return int(math.Abs(float64(num))) }\nans := make([]int, n)\ni, j, k := 0, n-1, n-1\nfor i <= j {\n\tif abs(A[i]) > abs(A[j]) {\n\t\tans[k] = A[i] * A[i]\n\t\ti++\n\t} else {\n\t\tans[k] = A[j] * A[j]\n\t\tj--\n\t}\n\tk--\n}\nreturn ans", "gen": "n := len(nums)\nif n == 0 {\n\treturn nums\n}\nres := make([]int, n)\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tres[i] += nums[j]\n\t}\n}\nreturn res\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif denoms := EgyptianFractions(tc.numerator, tc.denominator); !reflect.DeepEqual(tc.denominators, denoms) {\n\t\tt.Errorf(\"STR\", tc.denominators, denoms)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tgot := EgyptianFractions(tc.n)\n\tif !reflect.DeepEqual(got, tc.want) {\n\t\tt.Errorf(\"STR\", tc.want, got)\n\t}\n}\n}"}
{"tgt": "nums1 := []int{2}\nnums2 := []int{}\nmerge(nums1, 1, nums2, 0)\nfmt.Println(nums1)", "gen": "a := []int{2, 1}\nb := []int{0}\nmerge(a, 1, b, 0)\nfmt.Println(a)\n}"}
{"tgt": "result := 0\nfor num != 0 {\n\tresult++\n\tnum = num & (num - 1)\n}\nreturn result", "gen": "var count int\nfor n != 0 {\n\tn = n & (n - 1)\n\tcount++\n}\nreturn count\n}"}
{"tgt": "qs := []question448{\n\t{\n\t\tpara448{[]int{4, 3, 2, 7, 8, 2, 3, 1}},\n\t\tans448{[]int{5, 6}},\n\t},\n\t{\n\t\tpara448{[]int{4, 3, 2, 10, 9, 2, 3, 1, 1, 1, 1}},\n\t\tans448{[]int{5, 6, 7, 8, 11}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans448, q.para448\n\tfmt.Printf(\"STR\", p, findDisappearedNumbers(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "nums1 := []int{4, 3, 2, 7, 8, 2, 3, 1}\nnums2 := []int{5, 6, 7, 8, 10, 9, 1, 1, 1, 1}\nnums3 := []int{4, 3, 2, 1}\nfmt.Printf(\"STR\", nums1)\nfmt.Printf(\"STR\", nums2)\nfmt.Printf(\"STR\", nums3)\n}"}
{"tgt": "flag.Parse()\nroots := flag.Args()\nif len(roots) == 0 {\n\troots = []string{\"STR\"}\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, root := range roots {\n\t\twalkDir(root, fileSizes)\n\t}\n\tclose(fileSizes)\n}()\nvar nfiles, nbytes int64\nfor size := range fileSizes {\n\tnfiles++\n\tnbytes += size\n}\nprintDiskUsage(nfiles, nbytes)", "gen": "flag.Parse()\nargs := flag.Args()\nif len(args) == 0 {\n\targs = []string{\"./\"}\n}\nch := make(chan int64)\ngo main.roots(args, ch)\nvar total int64\nfor i := 0; i < len(args); i++ {\n\ttotal += <-ch\n}\nprintDiskUsage(total, len(args))\n}"}
{"tgt": "return toString[t]", "gen": "return beers[beerType]\n}"}
{"tgt": "for step := len(nums) / 2; step > 0; step /= 2 {\n\tfor i := step; i < len(nums); i++ {\n\t\tfor j := i - step; j >= 0 && nums[j+step] < nums[j]; j -= step {\n\t\t\tnums[j], nums[j+step] = nums[j+step], nums[j]\n\t\t}\n\t}\n}\nreturn nums", "gen": "n := len(nums)\nk := n / 2\nfor i := 0; i < k; i++ {\n\tfor j := i + 1; j < n; j++ {\n\t\tif nums[i] > nums[j] {\n\t\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\t}\n\t}\n}\nfor i := k; i < n; i++ {\n\tfor j := 0; j < i; j++ {\n\t\tif nums[i] < nums[j] {\n\t\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\t}\n\t}\n}\nreturn nums\n}"}
{"tgt": "var tests = []struct {\n\ttree *TreeNode\n\tvals []int\n}{\n\t{newTree(1, 2, 3, nil, 5, nil, 4), []int{1, 3, 4}},\n\t{newTree(1, 2, 3, 4, 5, nil, 6, nil, 7, nil, nil, 8, nil, nil, 9, nil, nil, nil, 10), []int{1, 3, 6, 8, 9, 10}},\n}\nfor _, tt := range tests {\n\tvals := rightSideView(tt.tree)\n\tif reflect.DeepEqual(vals, tt.vals) == false {\n\t\tt.Errorf(\"STR\", tt.tree, vals, tt.vals)\n\t}\n}", "gen": "qs := []question{\n\t{\n\t\tpara1: []int{1, 2, 3},\n\t\tpara2: 4,\n\t\tans:    []int{1, 3, 4},\n\t},\n\t{\n\t\tpara1: []int{1, 2, 3, 4, 5, 6},\n\t\tpara2: 7,\n\t\tans:    []int{1, 3, 5, 7},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\troot := newTree(q.para1, q.para2)\n\tret := rightSideView(root)\n\tif !reflect.DeepEqual(ret, q.ans) {\n\t\tt.Errorf(\"STR\", q.para1, q.para2, q.ans, ret)\n\t}\n}\n}"}
{"tgt": "nodes := []int{\n\t1, 2, 3, 4, 5, 6,\n}\nedges := [][]bool{\n\t{false, true, true, false, false, false},\n\t{true, false, false, true, false, false},\n\t{true, false, false, true, false, false},\n\t{false, true, true, false, true, false},\n\t{false, false, false, true, false, true},\n\t{false, false, false, false, true, false},\n}\nstart := 1\nend := 6\nroute, _ := dfs(start, end, nodes, edges)\nfmt.Println(route)", "gen": "var res [][]int\ndfs([]int{}, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119"}
{"tgt": "if target < 0 {\n\ttarget = -target\n}\nk := 0\nfor target > 0 {\n\tk++\n\ttarget -= k\n}\nif target%2 == 0 {\n\treturn k\n}\nreturn k + 1 + k%2", "gen": "if n < 0 {\n\tn = -n\n}\nfor i := 0; n > 0; i++ {\n\tn = n - i\n}\nif n%2 == 0 {\n\treturn i\n}\nreturn i + 1\n}"}
{"tgt": "if mod == 1 {\n\treturn 0, nil\n}\nif exponent < 0 {\n\treturn -1, ErrorNegativeExponent\n}\n_, err := Multiply64BitInt(mod-1, mod-1)\nif err != nil {\n\treturn -1, err\n}\nvar result int64 = 1\nbase = base % mod\nfor exponent > 0 {\n\tif exponent%2 == 1 {\n\t\tresult = (result * base) % mod\n\t}\n\texponent = exponent >> 1\n\tbase = (base * base) % mod\n}\nreturn result, nil", "gen": "if n < 1 {\n\treturn ErrorNegativeExponent\n}\nif n == 1 {\n\treturn Modular{0, 1, 1}\n}\nif n < 0 {\n\treturn ErrorNegativeExponent\n}\nvar (\n\tresult = Modular{0, 1, 1}\n\tbase   = Modular{0, 1, 1}\n)\nfor i := uint64(0); i < n; i++ {\n\tresult = result.Multiply(base)\n}\nreturn result\n}"}
{"tgt": "for n := 0; n < 32; n++ {\n\tsquare[n] = gf2MatrixTimes(mat, mat[n])\n}", "gen": "for i := 0; i < 32; i++ {\n\tcrc[i] = gf2MatrixTimes(crc, crc[i])\n\tcrc[i] = crc[i] ^ crc[i]\n}\n}"}
{"tgt": "return n.Ns == nil", "gen": "return len(s) == 0\n}"}
{"tgt": "n := len(p)\ndestination := n * n\nsquares := make([]int, 400)\nisChecked := [401]bool{}\nsquares[0] = 1\nisChecked[1] = true\nsteps := 0\nfor len(squares) > 0 {\n\tsteps++\n\tsize := len(squares)\n\tfor j := 0; j < size; j++ {\n\t\ts := squares[j]\n\t\tfor i := 1; i <= 6; i++ {\n\t\t\tsi := s + i\n\t\t\tx, y := position(si, n)\n\t\t\tif p[x][y] != -1 {\n\t\t\t\tisChecked[si] = true\n\t\t\t\tsi = p[x][y]\n\t\t\t}\n\t\t\tif si == destination {\n\t\t\t\treturn steps\n\t\t\t}\n\t\t\tif !isChecked[si] {\n\t\t\t\tsquares = append(squares, si)\n\t\t\t\tisChecked[si] = true\n\t\t\t}\n\t\t}\n\t}\n\tsquares = squares[size:]\n}\nreturn -1", "gen": "n := len(board)\nm := len(board[0])\nvar res int\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < m; j++ {\n\t\tif board[i][j] == 'O' {\n\t\t\tres++\n\t\t\tfor k := 0; k < 4; k++ {\n\t\t\t\tx := i + dx[k]\n\t\t\t\ty := j + dy[k]\n\t\t\t\tif x < 0 || x >= n || y < 0 || y >= m || board[x][y] != 'O' {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tboard[x][y] = '1'\n\t\t\t}\n\t\t}\n\t}\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < m; j++ {\n\t\tif board[i][j] == '1' {\n\t\t\treturn -1\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "return &linkLoop{\n\tHead: &linkLoopNode{},\n}", "gen": "return &linkLoop{\n\thead: &linkLoopNode{},\n}\n}"}
{"tgt": "return bindataRead(\n\t_dataCustomersJson,\n\t\"STR\",\n)", "gen": "return dataCustomersJson\n}"}
{"tgt": "m := len(matrix)\nif m == 0 {\n\treturn 0\n}\nn := len(matrix[0])\nif n == 0 {\n\treturn 0\n}\nmaxEdge := 0\ndp := make([][]int, m+1)\nfor i := range dp {\n\tdp[i] = make([]int, n+1)\n}\nfor i := 1; i <= m; i++ {\n\tfor j := 1; j <= n; j++ {\n\t\tif matrix[i-1][j-1] == '1' {\n\t\t\tdp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))\n\t\t\tmaxEdge = max(maxEdge, dp[i][j])\n\t\t}\n\t}\n}\nreturn maxEdge * maxEdge", "gen": "n := len(A)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn A[0]\n}\nmin := A[n-1]\nmax := A[0]\nfor i := 1; i < n; i++ {\n\tif A[i] < A[i-1] {\n\t\tmin = min(min, A[i-1])\n\t\tmax = max(max, A[i])\n\t}\n}\nreturn max * max\n}"}
{"tgt": "return x * y", "gen": "return (x.R * y.R) + (x.G * y.G) + (x.B * y.B)\n}"}
{"tgt": "if len(a) != len(b) {\n\treturn false\n}\nfor i, v := range a {\n\tif v != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "if len(nums) != len(target) {\n\treturn false\n}\nfor i := 0; i < len(nums); i++ {\n\tif nums[i] != target[i] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "if len(s) <= 1 {\n\treturn s\n}\ni := getIndex(s + \"STR\" + reverse(s))\nreturn reverse(s[i:]) + s", "gen": "if len(s) == 1 {\n\treturn s\n}\nreturn reverse(reverse(s[:len(s)-1]) + s[len(s)-1:])\n}"}
{"tgt": "sorted := make([]int, 0, m+n)\np, q := 0, 0\nfor {\n\tif p == m {\n\t\tsorted = append(sorted, nums2[q:]...)\n\t\tbreak\n\t}\n\tif q == n {\n\t\tsorted = append(sorted, nums1[p:]...)\n\t\tbreak\n\t}\n\tif nums1[p] < nums2[q] {\n\t\tsorted = append(sorted, nums1[p])\n\t\tp++\n\t} else {\n\t\tsorted = append(sorted, nums2[q])\n\t\tq++\n\t}\n}\ncopy(nums1, sorted)", "gen": "res := make([]int, len(nums))\ni := 0\nfor i < len(nums) {\n\tif i == len(nums) {\n\t\tbreak\n\t}\n\tif i == len(nums)-1 {\n\t\tbreak\n\t}\n\tif nums[i] == nums[len(nums)-1] {\n\t\tbreak\n\t}\n\tif nums[i] == nums[len(nums)-1] {\n\t\tbreak\n\t}\n\tif nums[i] == nums[len(nums)-1] {\n\t\tbreak\n\t}\n\tif nums[i] == nums[len(nums)-1] {\n\t\tbreak\n\t}\n\tif nums[i] == nums[len(nums)-1] {\n\t\tbreak\n\t}\n\tif nums[i] == nums[len(nums)-1] {\n\t\tbreak\n\t}\n\tif nums[i] == nums[len(nums)-1] {\n\t\tbreak\n\t}\n\tif nums[i] == nums[len(nums)-1] {\n\t\tbreak\n\t}\n\tif nums[i] == nums[len(nums)-1] {\n\t\tbreak\n\t}\n\tif nums[i] == nums[len(nums)-1] {\n\t\tbreak\n\t}\n\tif nums[i] == nums[len(nums)-1] {\n\t\tbreak\n\t}\n\tif nums[i] == nums[len(nums)-1] {\n\t\tbreak\n\t}\n\tif nums[i] == nums[len(nums)-1] {\n\t\tbreak\n\t}\n\tif nums[i] == nums[len(nums)-1] {\n\t\tbreak\n\t}\n\tif nums["}
{"tgt": "freq := make(map[rune]int)\nfor _, r := range s {\n\tfreq[r]++\n}\ntype frequency struct {\n\tr     rune\n\tcount int\n}\nletters := make([]*frequency, 0, len(freq))\nfor letter, count := range freq {\n\tletters = append(letters, &frequency{letter, count})\n}\nsort.Slice(letters, func(i, j int) bool {\n\treturn letters[i].count > letters[j].count\n})\nvar sb strings.Builder\nfor len(letters) != 0 {\n\tif len(letters) == 1 && letters[0].count > 1 {\n\t\treturn \"STR\"\n\t}\n\tfor _, f := range letters {\n\t\tsb.WriteRune(f.r)\n\t\tf.count--\n\t}\n\tfor len(letters) != 0 && letters[len(letters)-1].count == 0 {\n\t\tletters = letters[:len(letters)-1]\n\t}\n}\nreturn sb.String()", "gen": "m := make(map[int]int)\nfor _, c := range s {\n\tm[c]++\n}\nvar res []frequency\nfor k, v := range m {\n\tif v > 1 {\n\t\tres = append(res, frequency{k, v})\n\t}\n}\nsort.Slice(res, func(i, j int) bool {\n\treturn res[i].freq < res[j].freq\n})\nvar sb strings.Builder\nfor _, f := range res {\n\tfor i := 0; i < f.freq; i++ {\n\t\tsb.WriteRune(rune(f.char))\n\t}\n}\nreturn sb.String()\n}"}
{"tgt": "n := len(A)\nfor i := n - 2; i >= 0; i-- {\n\tA[i] += A[i+1]\n}\nmem := [101][33]int{}\nvar dp func(int, int) int\ndp = func(i, m int) int {\n\tif i+2*m >= n {\n\t\treturn A[i]\n\t}\n\tif mem[i][m] > 0 {\n\t\treturn mem[i][m]\n\t}\n\tres := 0\n\tfor x := 1; x <= 2*m; x++ {\n\t\tres = max(\n\t\t\tres,\n\t\t\tA[i]-dp(i+x, max(m, x)),\n\t\t)\n\t}\n\tmem[i][m] = res\n\treturn res\n}\nreturn dp(0, 1)", "gen": "n := len(stones)\ndp := make([]int, n+1)\nfor i := n - 2; i >= 0; i-- {\n\tdp[i+1] = dp[i+2] + stones[i]\n}\nvar dfs func(i int) int\ndfs = func(i int) int {\n\tif i == n {\n\t\treturn 0\n\t}\n\tif dp[i] != 0 {\n\t\treturn dp[i]\n\t}\n\tdp[i] = -1\n\treturn dp[i]\n}\nreturn dfs(0)\n}"}
{"tgt": "if n <= 2 {\n\treturn n\n}\nvar dp [2]int\ndp[0], dp[1] = 1, 2\nfor i := 2; i < n; i++ {\n\tdp[i%2] = dp[i%2] + dp[(i-1)%2]\n}\nreturn dp[(n-1)%2]", "gen": "if n < 2 {\n\treturn n\n}\ndp := make([]int, n+1)\ndp[1] = 1\nfor i := 2; i <= n; i++ {\n\tfor j := 1; j < i; j++ {\n\t\tdp[i] += dp[j] * dp[i-j]\n\t}\n}\nreturn dp[n]\n}"}
{"tgt": "email = strings.TrimSpace(email)\nemail = strings.ToLower(email)\nh := md5.New()\nio.WriteString(h, email)\nfinalBytes := h.Sum(nil)\nfinalString := hex.EncodeToString(finalBytes)\nreturn finalString", "gen": "s = strings.TrimSpace(s)\ns = strings.ToLower(s)\nh := md5.New()\nh.Write([]byte(s))\nreturn hex.EncodeToString(h.Sum(nil))\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t}, {\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n}\nfor _, tt := range tests {\n\tgot := repeatedSubstringPattern(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "tests := []struct {\n\ts        string\n\texpected bool\n}{\n\t{\"ABAB\", true},\n\t{\"ABA\", false},\n\t{\"ABABABAB\", true},\n\t{\"ABABABABAB\", true},\n\t{\"ABABABABABAB\", true},\n\t{\"ABABABABABABAB\", true},\n\t{\"ABABABABABABABAB\", true},\n\t{\"ABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABABABABABAB"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   0x5555,\n\t\twant: 8,\n\t},\n}\nfor _, tt := range tests {\n\tgot := hammingWeight(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "for _, num := range []int{3, 2, 7, 3, 8, 1, 21845, 8, 2} {\n\tif got := hammingWeight(num); got != num {\n\t\tt.Fatalf(\"STR\", num, got)\n\t}\n}\n}"}
{"tgt": "return bindataRead(\n\t_assetsHomeCatJpg,\n\t\"STR\",\n)", "gen": "return bindataRead(STR, _assetsHomeCatJpg)\n}"}
{"tgt": "b.table = make(map[string]*entry, capacity)\nb.priorityQueue = make([]*entry, 0, capacity)\nb.lruList.Init()\nb.freeList.Init()\nheap.Init(&b.priorityQueue)\narrayOfEntries := make([]entry, capacity)\nfor i := uint(0); i < capacity; i++ {\n\te := &arrayOfEntries[i]\n\te.element.Value = e\n\te.index = -1\n\tb.freeList.PushElementBack(&e.element)\n}", "gen": "cache.lru = make(map[string]entry)\ncache.list = list.Init()\ncache.pq = priorityQueue{\n\tlist: list.Init(),\n}\ncache.pq.heap = heap.Init(&cache.pq.list)\nfor i := 0; i < cache.size; i++ {\n\tcache.lru[i] = entry{\n\t\tkey: i,\n\t}\n\tcache.pq.Push(&cache.lru[i])\n\tcache.list.PushElementBack(&cache.lru[i])\n}\n}"}
{"tgt": "list.rear = nil", "gen": "p.next = nil\n}"}
{"tgt": "h := newLinkedHeap()\nbenchmarkHeap(b, h)", "gen": "benchmarkHeap(newLinkedHeap())\n}"}
{"tgt": "close(p.work)\np.wg.Wait()", "gen": "close(c)\nwg.Wait()\n}"}
{"tgt": "res := 0\nfactor := 1\nsize := len(s)\nfor i := 0; i < size; i++ {\n\tif s[i] == '(' {\n\t\tfactor *= 2\n\t} else {\n\t\tfactor /= 2\n\t}\n\tif s[i] == '(' && s[i+1] == ')' {\n\t\tres += factor / 2\n\t}\n}\nreturn res", "gen": "var sum, count int\nfor i := 0; i < len(s); i++ {\n\tif s[i] == '(' {\n\t\tsum <<= 1\n\t} else {\n\t\tsum += sum >> 1\n\t}\n}\nreturn sum\n}"}
{"tgt": "qs := []question454{\n\t{\n\t\tpara454{[]int{1, 2}, []int{-2, -1}, []int{-1, 2}, []int{0, 2}},\n\t\tans454{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans454, q.para454\n\tfmt.Printf(\"STR\", p, fourSumCount(p.a, p.b, p.c, p.d))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question454{\n\t{\n\t\tpara454{[]int{1, 2}},\n\t\tans454{0},\n\t},\n\t{\n\t\tpara454{[]int{-2, -1}},\n\t\tans454{0},\n\t},\n\t{\n\t\tpara454{[]int{-1, 2}},\n\t\tans454{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans454, q.para454\n\tfmt.Printf(\"STR\", p, fourSumCount(p.one, p.two, p.three, p.four))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "for i := range langs {\n\tlanguage := langs[i]\n\tif strings.EqualFold(language.Lang, str) {\n\t\treturn &language\n\t}\n}\nreturn nil", "gen": "for i, l := range langs {\n\tif l == lang {\n\t\treturn l\n\t}\n}\nreturn nil\n}"}
{"tgt": "sort.Ints(houses)\nsort.Ints(heaters)\ni, ans := 0, 0\nfor _, house := range houses {\n\tfor i < len(heaters)-1 && heaters[i]+heaters[i+1] <= house*2 {\n\t\ti++\n\t}\n\tans = maxInt(ans, absInt(heaters[i]-house))\n}\nreturn ans", "gen": "sort.Ints(A)\nsort.Ints(B)\nvar res int\nfor i := 0; i < len(A); i++ {\n\tfor j := 0; j < len(B); j++ {\n\t\tif absInt(A[i]+B[j]) > res {\n\t\t\tres = absInt(A[i] + B[j])\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "return h.FromHexString(string(b))", "gen": "return Hash{}.FromHexString(string(b))\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{\n\t\t{10, 16},\n\t\t{2, 8},\n\t\t{1, 6},\n\t\t{7, 12},\n\t}, 2},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := findMinArrowShots(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "var s = Solution{\n\tname: \"STR\",\n\tinputs: [][]int{\n\t\t{10, 16},\n\t\t{2, 8},\n\t\t{7, 12},\n\t\t{2, 6},\n\t},\n\texpect: 1,\n}\nfor i := 0; i < 4; i++ {\n\tSTR := strconv.Itoa(i)\n\tt.Run(\"STR\", func(t *testing.T) {\n\t\tc1.STR(STR)\n\t})\n}\n}"}
{"tgt": "if n < 2 {\n\treturn false\n}\nfor i := 2; i < n; i++ {\n\tif n%i == 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "if n <= 1 {\n\treturn false\n}\nfor i := 2; i < n; i++ {\n\tif n%i == 0 {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{5, 3, 4, 5},\n\t\twant: true,\n\t},\n\t{\n\t\tin:   []int{2, 5, 7, 3},\n\t\twant: true,\n\t},\n}\nfor _, tt := range tests {\n\tgot := stoneGame(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var A = []int{5, 3, 4, 5, 2}\nvar B = []int{2, 5, 7, 3}\nfor i := 0; i < 2; i++ {\n\tif stoneGame(A, B) {\n\t\tt.Fatalf(\"STR\", A, B)\n\t}\n}\n}"}
{"tgt": "return self.code", "gen": "return *p\n}"}
{"tgt": "if N == 1 {\n\treturn 0\n}\nif K%2 == 1 {\n\treturn kthGrammar(N-1, (K+1)/2)\n}\nreturn opposite(kthGrammar(N-1, K/2))", "gen": "if N == 1 {\n\treturn 0\n}\nif N%2 == 0 {\n\treturn kthGrammar(N/2, k)\n}\nreturn opposite(kthGrammar(N/2, k))\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := buddyStrings(tt.a, tt.b)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.a, tt.b, got, tt.want)\n\t}\n}", "gen": "qs := []question284{\n\t{\n\t\tpara284{\"ab\", \"ba\", true},\n\t\tans284{true},\n\t},\n\t{\n\t\tpara284{\"ab\", \"ab\", false},\n\t\tans284{false},\n\t},\n\t{\n\t\tpara284{\"aa\", \"aa\", false},\n\t\tans284{false},\n\t},\n\t{\n\t\tpara284{\"aaaaaaabc\", \"aaaaaaacb\", true},\n\t\tans284{true},\n\t},\n}\nfmt.Printf(\"STR\" + string(STR))\nfor _, q := range qs {\n\t_, p := q.ans284, q.para284\n\tfmt.Printf(\"STR\" + string(STR))\n\tgot := buddyStrings(p.one, p.two)\n\tfmt.Printf(\"STR\" + string(STR))\n\tif got != p.expect {\n\t\tt.Fatalf(\"STR\", p, got, p.expect)\n\t}\n}\n}"}
{"tgt": "ope := [][]int{\n\t{2, 2},\n\t{3, 3}}\nfmt.Println(maxCount(3, 3, ope))", "gen": "fmt.Println(maxCount([]int{2, 2, 3, 3}, 3))\n}"}
{"tgt": "qs := []question274{\n\t{\n\t\tpara274{[]int{3, 6, 9, 1}},\n\t\tans274{3},\n\t},\n\t{\n\t\tpara274{[]int{1}},\n\t\tans274{1},\n\t},\n\t{\n\t\tpara274{[]int{}},\n\t\tans274{0},\n\t},\n\t{\n\t\tpara274{[]int{3, 0, 6, 1, 5}},\n\t\tans274{3},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans274, q.para274\n\tfmt.Printf(\"STR\", p, hIndex(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "var cases = []struct {\n\tcitations []int\n\texpect    int\n}{\n\t{\n\t\t[]int{3, 6, 9, 1, 4},\n\t\t3,\n\t},\n\t{\n\t\t[]int{1, 1, 1},\n\t\t1,\n\t},\n\t{\n\t\t[]int{1},\n\t\t1,\n\t},\n}\nfor _, c := range cases {\n\tfmt.Printf(\"STR\", c.expect, c.citations)\n}\n}"}
{"tgt": "sort.Strings(words)\nmp := make(map[string]bool)\nvar res string\nfor _, word := range words {\n\tsize := len(word)\n\tif size == 1 || mp[word[:size-1]] {\n\t\tif size > len(res) {\n\t\t\tres = word\n\t\t}\n\t\tmp[word] = true\n\t}\n}\nreturn res", "gen": "sort.Strings(strs)\nm := make(map[string]bool)\nfor _, s := range strs {\n\tif len(s) > 1 {\n\t\tm[s] = true\n\t}\n}\nvar maxLen int\nfor _, s := range strs {\n\tif len(s) > maxLen {\n\t\tmaxLen = len(s)\n\t}\n}\nfor _, s := range strs {\n\tif len(s) == maxLen {\n\t\tm[s] = false\n\t}\n}\nfor _, s := range strs {\n\tif m[s] {\n\t\treturn s\n\t}\n}\nreturn \"\"\n}"}
{"tgt": "longestCenter, longestLength := 0, 0\nfor i, v := range P {\n\tif v > longestLength {\n\t\tlongestLength = v\n\t\tlongestCenter = i\n\t}\n}\noffset := (longestCenter - longestLength) / 2\nreturn s[offset : offset+longestLength]", "gen": "var sum int\nfor _, v := range a {\n\tif v > sum {\n\t\tsum = v\n\t}\n}\nreturn sum + len(a) - sum\n}"}
{"tgt": "for j := 1; j <= 20; j++ {\n\tif num%j != 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "for i := 1; i <= 20; i++ {\n\tif n%i == 0 {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "n := node.(*bstElement)\nif n == nil {\n\treturn nil\n}\nif n.right != nil {\n\treturn t.Min(n.right)\n}\ncur := n\nfor cur.parent != nil && cur.parent.left != cur {\n\tcur = cur.parent\n}\nreturn cur.parent", "gen": "if bst, ok := bstElement.(*bst); ok {\n\treturn bst.Min()\n}\nfor bstElement.Right != nil {\n\tbstElement = bstElement.Right\n}\nreturn bstElement, nil\n}"}
{"tgt": "var r [][]int\nfor i := begin; i <= end; i++ {\n\tif 1 == k {\n\t\tr = append(r, []int{i})\n\t\tcontinue\n\t}\n\tsuf := comb(i+1, end, k-1)\n\tfor _, j := range suf {\n\t\tr = append(r, append([]int{i}, j...))\n\t}\n}\nreturn r", "gen": "res := [][]int{}\nfor i := 0; i < n; i++ {\n\tif i == 0 {\n\t\tres = append(res, []int{i})\n\t\tcontinue\n\t}\n\ttmp := make([]int, len(res[0]))\n\tfor j := 0; j < len(res[0]); j++ {\n\t\ttmp[j] = res[j][len(res[0])-1] + 1\n\t}\n\tres = append(res, tmp)\n}\nreturn res\n}"}
{"tgt": "b.lock.Lock()\ndefer b.lock.Unlock()\ne := b.table[key]\nif e == nil {\n\treturn nil, false\n}\nif e.expire.Before(now) {\n\tif b.ExpireGracePeriod == 0 || e.expire.Sub(now) > b.ExpireGracePeriod {\n\t\tb.removeEntry(e)\n\t}\n\treturn nil, false\n}\nb.touchEntry(e)\nreturn e.value, true", "gen": "l.mu.Lock()\ndefer l.mu.Unlock()\nif l.cache == nil {\n\treturn 0, 0, false\n}\ne, ok := l.cache[key]\nif !ok {\n\treturn 0, 0, false\n}\nif e.expiration.Before(time.Now()) {\n\tl.removeEntry(e)\n\treturn 0, 0, false\n}\nl.touchEntry(e)\nreturn e.value, e.expiration, true\n}"}
{"tgt": "if root == nil {\n\treturn 0\n}\nresult := 0\nif root.Val >= L && root.Val <= R {\n\tresult += root.Val\n}\nif root.Val >= L {\n\tresult += rangeSumBST(root.Left, L, R)\n}\nif root.Val <= R {\n\tresult += rangeSumBST(root.Right, L, R)\n}\nreturn result", "gen": "if root == nil {\n\treturn 0\n}\nvar sum int\nif root.Val >= low && root.Val <= high {\n\tsum += root.Val\n}\nif root.Val < high {\n\tsum += rangeSumBST(root.Right, low, high)\n}\nif root.Val > low {\n\tsum += rangeSumBST(root.Left, low, high)\n}\nreturn sum\n}"}
{"tgt": "if tree.root == nil {\n\treturn nil, false\n}\ncurrentNode := tree.root\nfor currentNode != nil {\n\tif i == currentNode.data {\n\t\treturn currentNode, true\n\t} else if i > currentNode.data {\n\t\tcurrentNode = currentNode.right\n\t} else if i < currentNode.data {\n\t\tcurrentNode = currentNode.left\n\t}\n}\nreturn nil, false", "gen": "if root == nil {\n\treturn 0, false\n}\nif root.Val == val {\n\treturn root, true\n}\nfor root.Val != val {\n\tif root.Val > val {\n\t\troot = root.Left\n\t} else {\n\t\troot = root.Right\n\t}\n}\nreturn root, true\n}"}
{"tgt": "length := len(nums)\nif length == 0 || length == 1 && nums[0] != target {\n\treturn []int{-1, -1}\n}\nreturn searchRangeI(nums, 0, length-1, target)", "gen": "n := len(nums)\nif n == 0 {\n\treturn []int{-1, -1}\n}\nif n == 1 {\n\tif nums[0] == target {\n\t\treturn []int{0, 0}\n\t}\n\treturn []int{-1, -1}\n}\nif nums[0] > target {\n\treturn []int{-1, -1}\n}\nif nums[n-1] < target {\n\treturn []int{-1, -1}\n}\nreturn searchRangeI(nums, target)\n}"}
{"tgt": "var (\n\tl int\n\tr = len(nums) - 1\n)\nfor l <= r {\n\tmid := l + (r-l)/2\n\tif target == nums[mid] {\n\t\treturn mid\n\t}\n\tif nums[mid] >= nums[l] && nums[mid] > nums[r] {\n\t\tif target >= nums[l] && target < nums[mid] {\n\t\t\tr = mid - 1\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t} else {\n\t\tif target > nums[mid] && target <= nums[r] {\n\t\t\tl = mid + 1\n\t\t} else {\n\t\t\tr = mid - 1\n\t\t}\n\t}\n}\nreturn -1", "gen": "left, right := 0, len(nums)-1\nfor left <= right {\n\tmid := (left + right) / 2\n\tif nums[mid] == target {\n\t\treturn mid\n\t}\n\tif nums[mid] < target {\n\t\tleft = mid + 1\n\t} else {\n\t\tright = mid - 1\n\t}\n}\nreturn -1\n}"}
{"tgt": "if squares < 3 {\n\treturn 1\n}\nif answer, ok := memo[squares]; ok {\n\treturn answer\n}\ntotal := int64(1)\nfor size := 3; size <= squares; size++ {\n\tfor start := 0; start <= squares-size; start++ {\n\t\tanswer := int64(1)\n\t\tanswer *= ways(squares - start - size - 1)\n\t\ttotal += answer\n\t}\n}\nmemo[squares] = total\nreturn total", "gen": "if n <= 2 {\n\treturn 1\n}\nif memo, ok := memo[n]; ok {\n\treturn memo\n}\nvar ways int64\nfor i := 0; i < n; i++ {\n\tways += ways(n-i-1, n)\n}\nmemo[n] = ways\nreturn ways\n}"}
{"tgt": "return &CircularBuffer{\n\tbuffer: make([]interface{}, size),\n\tsize:   size,\n\tavail:  make(chan bool, size),\n}", "gen": "return &CircularBuffer{\n\tbuffer: make([]interface{}, size),\n\tread:   0,\n\twrite:  0,\n\tsize:   size,\n\tfull:   make(chan bool),\n}\n}"}
{"tgt": "return uint32((dev >> 8) & 0xff)", "gen": "return int(b >> 8) & 0xFF\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 4,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 6,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 6,\n\t},\n}\nfor _, tt := range tests {\n\tgot := longestValidParentheses(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var testcases = []struct {\n\ts        string\n\texpected int\n}{\n\t{\"()\", 2},\n\t{\"()()\", 4},\n\t{\"()()()\", 6},\n\t{\"()()()()\", 6},\n\t{\"()()()()()\", 6},\n\t{\"()()()()()()\", 6},\n\t{\"()()()()()()()\", 6},\n\t{\"()()()()()()()()\", 6},\n\t{\"()()()()()()()()()\", 6},\n\t{\"()()()()()()()()()()\", 6},\n\t{\"()()()()()()()()()()()\", 6},\n\t{\"()()()()()()()()()()()()\", 6},\n\t{\"()()()()()()()()()()()()()\", 6},\n\t{\"()()()()()()()()()()()()()()\", 6},\n\t{\"()()()()()()()()()()()()()()()\", 6},\n\t{\"()()()()()()()()()()()()()()()()\", 6},\n\t{\"()()()()()()()()()()()()()()()()()\", 6},\n\t{\"()()()()()()()()()()()()()()()()()()\", 6},\n\t{\"()()()()()()()()()()()()()()()()()()()\", 6},\n\t{\"()()()()()()()()()()()()()()()()()()()()()\", 6},\n\t{\"()()()()()()()()()()()()()()()()()()()()()()()\", 6},\n\t{\"()()()()()()()()()()()()()()()()()()()()()()()()\", 6},\n\t{\"()()()()()()()()()()()()()()()()()()()()()()()()()\", 6},\n\t{\"()()()()()()()"}
{"tgt": "iterator := func() <-chan VertexId {\n\tch := make(chan VertexId)\n\tgo func() {\n\t\tif connected, ok := g.edges[vertex]; ok {\n\t\t\tfor VertexId, _ := range connected {\n\t\t\t\tif g.IsEdge(vertex, VertexId) {\n\t\t\t\t\tch <- VertexId\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\nreturn VerticesIterable(&vertexIterableHelper{iterFunc: iterator})", "gen": "g := &graph{\n\tvertices: vertices,\n}\nid := VertexId(id)\nreturn vertexIterableHelper{\n\tVerticesIter: func(c chan<- VertexId) {\n\t\tg.GetSuccessors(id, c)\n\t},\n}\n}"}
{"tgt": "ans := 0\nfor ; x != 0; x /= 10 {\n\tans = ans*10 + x%10\n}\nif ans < math.MinInt32 || ans > math.MaxInt32 {\n\treturn 0\n}\nreturn ans", "gen": "res := 0\nfor n > 0 {\n\tres += n\n\tn /= 10\n}\nif res < -2147483648 || res > 2147483647 {\n\treturn 0\n}\nreturn res\n}"}
{"tgt": "i, size := 0, len(s)\nss := make([]string, numRows)\nfor i < size {\n\tfor j := 0; j < numRows && i < size; j++ {\n\t\tss[j] += string(s[i])\n\t\ti++\n\t}\n\tfor j := numRows - 2; j > 0 && i < size; j-- {\n\t\tss[j] += string(s[i])\n\t\ti++\n\t}\n}\nvar ret string\nfor j := 0; j < numRows; j++ {\n\tret += ss[j]\n}\nreturn ret", "gen": "var i, j int\nvar s []string\nfor i = 0; i < len(s1); i++ {\n\ts = append(s, \"\")\n\tfor j = 0; j < len(s2); j++ {\n\t\tif s1[i] == s2[j] {\n\t\t\ts[i] += \"(\" + s2[j] + \")\"\n\t\t}\n\t}\n}\nfor i = 0; i < len(s1); i++ {\n\tfor j = 0; j < len(s2); j++ {\n\t\tif s1[i] == s2[j] {\n\t\t\ts[i] += \"(\" + s2[j] + \")\"\n\t\t}\n\t}\n}\nreturn s\n}"}
{"tgt": "sum := big.NewInt(0)\nfor i := int64(1); i <= 1000; i++ {\n\tval := big.NewInt(i)\n\tsum.Add(sum, pow(val, i))\n}\nfmt.Println(\"STR\", sum.String())", "gen": "result := big.NewInt(0)\nfor i := 1; i <= 1000; i++ {\n\tresult = result.Add(result, pow(big.NewInt(1), big.NewInt(i)))\n}\nfmt.Println(result.String())\n}"}
{"tgt": "for l, r := 0, len(A)-1; ; {\n\tm := (l + r) / 2\n\tif A[m] < A[m+1] {\n\t\tl = m\n\t} else if A[m-1] > A[m] {\n\t\tr = m\n\t} else {\n\t\treturn m\n\t}\n}", "gen": "min, max := 0, len(nums)-1\nfor min < max {\n\tmid := (min + max) / 2\n\tif nums[mid] < nums[mid+1] {\n\t\tmin = mid + 1\n\t} else {\n\t\tmax = mid\n\t}\n}\nreturn nums[min]\n}"}
{"tgt": "max := 1000\nsum := 0\nfor i := 1; i < max; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)", "gen": "max := 1000\nsum := 0\nfor i := 1; i <= max; i++ {\n\tif i%3 == 0 || i%5 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "if k < 0 || len(nums) == 0 {\n\treturn 0\n}\nvar count int\nm := make(map[int]int, len(nums))\nfor _, value := range nums {\n\tm[value]++\n}\nfor key := range m {\n\tif k == 0 && m[key] > 1 {\n\t\tcount++\n\t\tcontinue\n\t}\n\tif k > 0 && m[key+k] > 0 {\n\t\tcount++\n\t}\n}\nreturn count", "gen": "if len(nums) == 0 || len(nums)%2 == 1 {\n\treturn 0\n}\ncount := 0\nm := make(map[int]int)\nfor _, v := range nums {\n\tm[v]++\n}\nfor k, v := range m {\n\tif v == 1 {\n\t\tcount++\n\t} else {\n\t\tcount += 2\n\t\tm[k+1] = v - 1\n\t}\n}\nreturn count\n}"}
{"tgt": "parentMap, countMap := make(map[int]int), make(map[int]int)\nfor _, num := range nums {\n\tif _, exists := parentMap[num]; exists {\n\t\tcontinue\n\t}\n\tparentMap[num], countMap[num] = num, 1\n\tneighbors := [2]int{num - 1, num + 1}\n\tfor _, n := range neighbors {\n\t\tif _, exists := parentMap[n]; exists {\n\t\t\tcount1 := countMap[getParent128(n, parentMap)]\n\t\t\tcount2 := countMap[getParent128(num, parentMap)]\n\t\t\tunion128(n, num, parentMap)\n\t\t\tcountMap[getParent128(num, parentMap)] = count1 + count2\n\t\t}\n\t}\n}\nmax := 0\nfor _, count := range countMap {\n\tif count > max {\n\t\tmax = count\n\t}\n}\nreturn max", "gen": "uf := make(map[int]int)\nuf2 := make(map[int]int)\nfor _, id := range idList {\n\tuf[id] = id\n\tuf2[id] = id\n}\nfor i := 0; i < len(idList); i++ {\n\tid := idList[i]\n\tfor j := 0; j < len(idList); j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tparent1 := getParent128(uf, id)\n\t\tparent2 := getParent128(uf2, idList[j])\n\t\tuf[parent1] = parent2\n\t\tuf2[parent2] = parent1\n\t}\n}\nmax := 0\nfor _, id := range idList {\n\tif id > max {\n\t\tmax = id\n\t}\n}\nreturn max\n}"}
{"tgt": "sort.Ints(people)\nthin, fat := 0, len(people)-1\nres := 0\nfor thin <= fat {\n\tif people[thin]+people[fat] <= limit {\n\t\tthin++\n\t}\n\tfat--\n\tres++\n}\nreturn res", "gen": "sort.Ints(nums)\nleft, right := 0, len(nums)-1\nfor left < right {\n\tif nums[left]+nums[right] > target {\n\t\tright--\n\t} else {\n\t\tleft++\n\t}\n}\nreturn left\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{1, 8, 6, 2, 5, 4, 8, 3, 7},\n\t\twant: 49,\n\t},\n\t{\n\t\tin:   []int{1, 8, 6, 30, 20, 6, 9, 10, 1},\n\t\twant: 48,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxArea(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "tests := []struct {\n\theight []int\n\twant   int\n}{\n\t{\n\t\theight: []int{1, 8, 6, 2, 5, 4, 8, 3, 7},\n\t\twant:   49,\n\t},\n\t{\n\t\theight: []int{1, 8, 6, 30, 20, 6, 9, 10, 1},\n\t\twant:   48,\n\t},\n}\nfor i, tt := range tests {\n\tgot := maxArea(tt.height)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", i, tt.height, got, tt.want)\n\t}\n}\n}"}
{"tgt": "count, k := make([]int, 128), len(s)/4\nfor _, v := range s {\n\tcount[int(v)]++\n}\nleft, right, res := 0, -1, len(s)\nfor left < len(s) {\n\tif count['Q'] > k || count['W'] > k || count['E'] > k || count['R'] > k {\n\t\tif right+1 < len(s) {\n\t\t\tright++\n\t\t\tcount[s[right]]--\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t} else {\n\t\tres = min(res, right-left+1)\n\t\tcount[s[left]]++\n\t\tleft++\n\t}\n}\nreturn res", "gen": "var max int\nfor _, c := range s {\n\tif c < 'A' || c > 'Z' {\n\t\tcontinue\n\t}\n\tif c == 'Q' || c == 'E' || c == 'U' {\n\t\tmax = min(max, 1)\n\t} else if c == 'I' || c == 'O' {\n\t\tmax = min(max, 2)\n\t} else if c == 'A' || c == 'S' || c == 'T' {\n\t\tmax = min(max, 3)\n\t} else if c == 'N' || c == 'R' {\n\t\tmax = min(max, 4)\n\t} else if c == 'L' || c == 'C' || c == 'K' {\n\t\tmax = min(max, 5)\n\t} else if c == 'M' || c == 'Y' {\n\t\tmax = min(max, 6)\n\t} else if c == 'P' || c == 'B' || c == 'V' {\n\t\tmax = min(max, 7)\n\t} else if c == 'F' || c == 'W' || c == 'H' {\n\t\tmax = min(max, 8)\n\t} else if c == 'X' || c == 'G' || c == 'J' {\n\t\tmax = min(max, 9)\n\t} else if c == 'D' || c == 'Z' {\n\t\tmax = min(max, 10)\n\t}\n}\nreturn max\n}"}
{"tgt": "http.HandleFunc(\"STR\", handler)", "gen": "http.HandleFunc(\"/\", handler)\n}"}
{"tgt": "pairs := [...][2]int{{15, 26}, {1000, 1366}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p16(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "for _, v := range []int{15, 26, 1000, 1366} {\n\tif p16(v) != v {\n\t\tt.Errorf(\"STR\", v)\n\t}\n}\n}"}
{"tgt": "n := len(matrix)\nl, r := matrix[0][0], matrix[n-1][n-1]\nfor l < r {\n\tm := (l + r) / 2\n\tcount := 0\n\tfor i := 0; i < n; i++ {\n\t\tj := n - 1\n\t\tfor j >= 0 && matrix[i][j] > m {\n\t\t\tj--\n\t\t}\n\t\tcount += j + 1\n\t}\n\tif count < k {\n\t\tl = m + 1\n\t} else {\n\t\tr = m\n\t}\n}\nreturn l", "gen": "n := len(A)\nm := len(B)\nif m == 0 {\n\treturn 0\n}\nmax := A[0] + B[0]\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < m; j++ {\n\t\tif i < 0 || j < 0 || A[i] < B[j] {\n\t\t\tcontinue\n\t\t}\n\t\tif A[i]+B[j] > max {\n\t\t\tmax = A[i] + B[j]\n\t\t}\n\t}\n}\nreturn max\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tm: 3,\n\t\tn: 3,\n\t\tops: [][]int{\n\t\t\t{2, 2},\n\t\t\t{3, 3},\n\t\t},\n\t\twant: 4,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxCount(tt.m, tt.n, tt.ops)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.m, got, tt.want)\n\t}\n}", "gen": "qs := []question598{\n\t{\n\t\tpara1: []int{2, 2, 3, 3},\n\t\tpara2: 2,\n\t\tans:   2,\n\t},\n\t{\n\t\tpara1: []int{2, 2, 3, 3},\n\t\tpara2: 3,\n\t\tans:   3,\n\t},\n\t{\n\t\tpara1: []int{2, 2, 3, 3},\n\t\tpara2: 4,\n\t\tans:   2,\n\t},\n}\nfmt.Printf(\"STR\" + strconv.Itoa(i))\nfor _, q := range qs {\n\tvar ret int\n\tret = maxCount(q.para1, q.para2)\n\tif ret != q.ans {\n\t\tt.Fatalf(\"STR\", q.para1, q.para2, q.ans, ret)\n\t}\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif isPartite := IsBipartiteGraph(tc.g); isPartite != tc.isPartite {\n\t\tt.Errorf(\"STR\", tc.isPartite, isPartite)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := IsBipartiteGraph(tc.graph); res != tc.want {\n\t\tt.Errorf(\"STR\", tc.want, res)\n\t}\n}\n}"}
{"tgt": "var i int\nlength := len(nums)\nif length <= 1 {\n\treturn\n}\nfor i = length - 1; i >= 1; i-- {\n\tif nums[i] > nums[i-1] {\n\t\tbreak\n\t}\n}\nif i > 0 {\n\tsort.Ints(nums[i:])\n\tfor j := i - 1; j < length; j++ {\n\t\tif nums[j] > nums[i-1] {\n\t\t\tnums[i-1], nums[j] = nums[j], nums[i-1]\n\t\t\treturn\n\t\t}\n\t}\n}\nsort.Ints(nums)", "gen": "if len(nums) > 1 {\n\tfor i := len(nums) - 1; i > 0; i-- {\n\t\tif nums[i] < nums[i-1] {\n\t\t\tnums[i], nums[i-1] = nums[i-1], nums[i]\n\t\t\tsort.Ints(nums[i:])\n\t\t\tsort.Ints(nums[:i])\n\t\t}\n\t}\n}\n}"}
{"tgt": "return LoadUint64(&r.Reg)", "gen": "return LoadUint64(&v)\n}"}
{"tgt": "var tests = []struct {\n\tnumber int\n\ttitle  string\n}{\n\t{1, \"STR\"},\n\t{28, \"STR\"},\n\t{701, \"STR\"},\n}\nfor _, tt := range tests {\n\ttitle := convertToTitle(tt.number)\n\tif title != tt.title {\n\t\tt.Errorf(\"STR\", tt.number, title, tt.title)\n\t}\n}", "gen": "qs := []question168{\n\t{\n\t\tpara1: 1,\n\t\tpara2: \"A\",\n\t\tans:   \"A\",\n\t},\n\t{\n\t\tpara1: 28,\n\t\tpara2: \"AB\",\n\t\tans:   \"AB\",\n\t},\n\t{\n\t\tpara1: 701,\n\t\tpara2: \"ZY\",\n\t\tans:   \"ZY\",\n\t},\n}\nfmt.Printf(\"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS\", \"STR\" +\n\t\"INGS"}
{"tgt": "empty := countBucket{}\nfor i, _ := range ss.olist {\n\tdelete(ss.hash, ss.olist[i].key)\n\tss.olist[i] = empty\n}", "gen": "for i := 0; i < len(s.buckets); i++ {\n\tdelete(s.buckets, s.buckets[i].key)\n\ts.countBucket(i)\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tresult := EloGames(tc.scores, tc.kFactor, tc.matches)\n\tfor i := range result {\n\t\tresult[i] = math.Round(result[i]*tc.tolerance) / tc.tolerance\n\t}\n\tif !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tgot := EloGames(tc.games)\n\tif !reflect.DeepEqual(got, tc.want) {\n\t\tt.Errorf(\"STR\", tc.games, tc.want, got)\n\t}\n}\n}"}
{"tgt": "l.insert(e, &l.root)", "gen": "heap.insert(heap.root, element)\n}"}
{"tgt": "if root == nil {\n\treturn 0\n}\nmax := height(root.Left)\nif h := height(root.Right); h > max {\n\tmax = h\n}\nreturn max + 1", "gen": "if root == nil {\n\treturn 0\n}\nleftHeight := height(root.Left)\nrightHeight := height(root.Right)\nif rightHeight > leftHeight {\n\treturn rightHeight + 1\n}\nreturn leftHeight + 1\n}"}
{"tgt": "qs := []question598{\n\t{\n\t\tpara598{3, 3, [][]int{{2, 2}, {3, 3}}},\n\t\tans598{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans598, q.para598\n\tfmt.Printf(\"STR\", p, maxCount(p.m, p.n, p.ops))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question598{\n\t{\n\t\tpara598{[][]int{{2, 2}, {3, 3}}},\n\t\tans598{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans598, q.para598\n\tfmt.Printf(\"STR\", p, maxCount(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "var tests = []struct {\n\tnums    []int\n\ttarget  int\n\tindices []int\n}{\n\t{[]int{2, 7, 11, 15}, 9, []int{0, 1}},\n\t{[]int{2, 3, 4, 6}, 6, []int{0, 2}},\n\t{[]int{2, 3, 4, 7}, 8, nil},\n\t{nil, 8, nil},\n}\nfor _, tt := range tests {\n\tindices := twoSum(tt.nums, tt.target)\n\tif reflect.DeepEqual(indices, tt.indices) == false {\n\t\tt.Errorf(\"STR\", tt.nums, tt.target, indices, tt.indices)\n\t}\n}", "gen": "nums1 := []int{2, 7, 11, 15}\ntarget1 := 9\nnums2 := []int{0, 1, 2, 3, 4}\ntarget2 := 2\nnums3 := []int{2, 3, 4}\ntarget3 := 6\nnums4 := []int{2, 3, 4}\ntarget4 := 8\nnums5 := []int{0, 1, 2, 3, 4}\ntarget5 := 0\nnums6 := []int{0, 1, 2, 3, 4}\ntarget6 := 5\nnums7 := []int{0, 1, 2, 3, 4}\ntarget7 := 5\nnums8 := []int{0, 1, 2, 3, 4}\ntarget8 := 5\nnums9 := []int{0, 1, 2, 3, 4}\ntarget9 := 5\ntests := []struct {\n\tnums   []int\n\ttarget int\n\twant   []int\n}{\n\t{nums1, target1, []int{2, 7}},\n\t{nums2, target2, []int{0, 3}},\n\t{nums3, target3, []int{2, 3}},\n\t{nums4, target4, []int{2, 3}},\n\t{nums5, target5, []int{0, 1, 2, 3, 4}},\n\t{nums6, target6, []int{0, 1, 2, 3, 4}},\n\t{nums7, target7, []int{0, 1, 2, 3, 4}},\n\t{nums8, target8, []int{0, 1, 2, 3, 4}},\n\t{nums9, target9, []int{0, 1, 2, 3,"}
{"tgt": "if isSquare(n) {\n\treturn 1\n}\nfor n%4 == 0 {\n\tn /= 4\n}\nif n%8 == 7 {\n\treturn 4\n}\nfor i := 1; i <= mySqrt(n); i++ {\n\tif isSquare(n - i*i) {\n\t\treturn 2\n\t}\n}\nreturn 3", "gen": "if isSquare(n) {\n\treturn 1\n}\nif n%4 == 0 {\n\treturn 4\n}\nfor i := 1; i < 8; i++ {\n\tif isSquare(n-i*i) {\n\t\treturn 2\n\t}\n}\nreturn mySqrt(n)\n}"}
{"tgt": "if N < 3 {\n\treturn N\n} else if N == 3 {\n\treturn 5\n}\nmod := 1000000007\ndp := make([]int, N+1)\ndp[1], dp[2], dp[3] = 1, 2, 5\nfor i := 4; i <= N; i++ {\n\tdp[i] = 2*dp[i-1] + dp[i-3]\n\tdp[i] %= mod\n}\nreturn dp[N]", "gen": "if n < 2 {\n\treturn n\n}\nif n == 2 {\n\treturn 5\n}\nif n == 3 {\n\treturn 5\n}\ndp := make([]int, n+1)\ndp[1] = 1\ndp[2] = 5\ndp[3] = 5\nfor i := 4; i <= n; i++ {\n\tdp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % MOD\n}\nreturn dp[n]\n}"}
{"tgt": "stack := []byte{}\nfor i := range num {\n\tdigit := num[i]\n\tfor k > 0 && len(stack) > 0 && digit < stack[len(stack)-1] {\n\t\tstack = stack[:len(stack)-1]\n\t\tk--\n\t}\n\tstack = append(stack, digit)\n}\nstack = stack[:len(stack)-k]\nans := strings.TrimLeft(string(stack), \"STR\")\nif ans == \"STR\" {\n\tans = \"STR\"\n}\nreturn ans", "gen": "var res []byte\nfor _, c := range s {\n\tif c > 'Z' {\n\t\tcontinue\n\t}\n\tres = append(res, byte(c-'A'+1))\n}\nreturn strings.TrimLeft(string(res), \"1\")\n}"}
{"tgt": "if e.element.list != &b.freeList {\n\tpanic(\"STR\")\n}\nif !e.expire.IsZero() {\n\theap.Push(&b.priorityQueue, e)\n}\nb.freeList.Remove(&e.element)\nb.lruList.PushElementFront(&e.element)\nb.table[e.key] = e", "gen": "if pq.Len() == 0 {\n\tpanic(\"STR\")\n}\nif pq.Len() == 1 {\n\tpq.Remove(pq.Front())\n\tpq.PushElementFront(nil)\n\treturn\n}\npq.Remove(pq.Front())\npq.PushElementFront(nil)\n}"}
{"tgt": "in := make([]int, N)\nout := make([]int, N)\nfor _, pair := range trust {\n\tout[pair[0]-1]++\n\tin[pair[1]-1]++\n}\nfor i := 0; i < N; i++ {\n\tif in[i] == N-1 && out[i] == 0 {\n\t\treturn i + 1\n\t}\n}\nreturn -1", "gen": "var (\n\tres, res2 []int\n\ti         int\n)\nfor _, num := range nums {\n\tres = append(res, num)\n\tres2 = append(res2, num)\n}\nfor i = 0; i < len(nums); i++ {\n\tif res2[i] == 0 {\n\t\treturn -1\n\t}\n\tres2[i]--\n\tres[i]--\n}\nfor i = 0; i < len(nums); i++ {\n\tif res2[i] == 0 {\n\t\treturn -1\n\t}\n\tres2[i]--\n\tres[i]--\n}\nreturn -1\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs int\n\texpect int\n}{\n\t{\"STR\", 2, 1},\n\t{\"STR\", 3, 2},\n\t{\"STR\", 4, 3},\n\t{\"STR\", 0, 0},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "var tests = []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{2, 1}, 3},\n\t{\"STR\", []int{3, 2}, 3},\n}\nfor _, tt := range tests {\n\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(tt.inputs)\n\t\tif !reflect.DeepEqual(got, tt.expect) {\n\t\t\tt.Errorf(\"STR\", tt.expect, got)\n\t\t}\n\t})\n}\n}"}
{"tgt": "return xtime.Unix(int64(jt), 0), nil", "gen": "return Time{time.Unix(t, 0)}\n}"}
{"tgt": "if len(name) == 0 && len(typed) == 0 {\n\treturn true\n}\nif (len(name) == 0 && len(typed) != 0) || (len(name) != 0 && len(typed) == 0) {\n\treturn false\n}\nj := 0\nfor i := 0; i < len(name); i++ {\n\tif j < len(typed) && name[i] == typed[j] {\n\t\tj++\n\t\tcontinue\n\t} else {\n\t\tif i > 0 && j < len(typed) && name[i-1] == typed[j] {\n\t\t\tj++\n\t\t\ti--\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "if len(s) == 0 || len(t) == 0 {\n\treturn false\n}\nif len(s) != len(t) {\n\treturn false\n}\nif len(s) == len(t) {\n\treturn true\n}\nfor i := 0; i < len(s); i++ {\n\tfor j := 0; j < len(s); j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == t[j] {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true\n}"}
{"tgt": "var i, j, tmp int\nfor i = 1; i < len(arr); i++ {\n\ttmp = arr[i]\n\tfor j = i; j > 0 && arr[j-1] > tmp; j-- {\n\t\tarr[j] = arr[j-1]\n\t}\n\tarr[j] = tmp\n}\nreturn arr", "gen": "var i, j int\nfor i = 1; i < len(nums); i++ {\n\tj = i - 1\n\tfor j >= 0 && nums[j] > nums[i] {\n\t\tnums[j+1] = nums[j]\n\t\tj--\n\t}\n\tnums[j+1] = nums[i]\n}\nreturn nums\n}"}
{"tgt": "res = [][]string{}\nif len(s) < 1 {\n\treturn res\n}\nhelper(s, 0, []string{})\nreturn res", "gen": "res = [][]string{}\nif len(strs) == 0 {\n\treturn res\n}\nhelper(strs, 0, []string{})\nreturn res\n}"}
{"tgt": "if from == to {\n\treturn errors.New(\"STR\")\n}\nif !g.CheckVertex(from) || !g.CheckVertex(to) {\n\treturn errors.New(\"STR\")\n}\ni, _ := g.edges[from][to]\nj, _ := g.edges[to][from]\nif i > 0 || j > 0 {\n\treturn errors.New(\"STR\")\n}\ng.TouchVertex(from)\ng.TouchVertex(to)\ng.edges[from][to] = weight\nif !g.isDirected {\n\tg.edges[to][from] = weight\n}\ng.edgesCount++\nreturn nil", "gen": "if v1 == v2 {\n\treturn errors.New(\"STRONG CONNECTED\")\n}\nif !g.CheckVertex(v1) || !g.CheckVertex(v2) {\n\treturn errors.New(\"STRONG CONNECTED\")\n}\nif g.TouchVertex(v1) || g.TouchVertex(v2) {\n\treturn errors.New(\"STRONG CONNECTED\")\n}\ng.graph[v1][v2] = g.graph[v2][v1]\ng.graph[v1][v1] = 0\ng.graph[v2][v2] = 0\ng.graph[v2][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1] = 0\ng.graph[v1][v1"}
{"tgt": "i := 0\ndefer fmt.Println(\"STR\", i)\ndefer fmt.Println(\"STR\")\ndefer fmt.Println(\"STR\")\ni++\nfmt.Println(\"STR\", i)", "gen": "var res int\ndefer func() {\n\tfmt.Println(res)\n}()\nres = 0\nfor i := 0; i < 2; i++ {\n\tdefer func() {\n\t\tres++\n\t}()\n\tres = 0\n\tfor j := 0; j < 2; j++ {\n\t\tdefer func() {\n\t\t\tres++\n\t\t}()\n\t\tres = 0\n\t\tfor k := 0; k < 2; k++ {\n\t\t\tdefer func() {\n\t\t\t\tres++\n\t\t\t}()\n\t\t\tres = 0\n\t\t\tfor l := 0; l < 2; l++ {\n\t\t\t\tdefer func() {\n\t\t\t\t\tres++\n\t\t\t\t}()\n\t\t\t\tres = 0\n\t\t\t\tfor m := 0; m < 2; m++ {\n\t\t\t\t\tdefer func() {\n\t\t\t\t\t\tres++\n\t\t\t\t\t}()\n\t\t\t\t\tres = 0\n\t\t\t\t\tfor n := 0; n < 2; n++ {\n\t\t\t\t\t\tdefer func() {\n\t\t\t\t\t\t\tres++\n\t\t\t\t\t\t}()\n\t\t\t\t\t\tres = 0\n\t\t\t\t\t\tfor o := 0; o < 2; o++ {\n\t\t\t\t\t\t\tdefer func() {\n\t\t\t\t\t\t\t\tres++\n\t\t\t\t\t\t\t}()\n\t\t\t\t\t\t\tres = 0\n\t\t\t\t\t\t\tfor p := 0; p < 2; p++ {\n\t\t\t\t\t\t\t\tdefer func() {\n\t\t\t\t\t\t\t\t\tres++\n\t\t\t\t\t\t\t\t}()\n\t\t\t\t\t"}
{"tgt": "maxIndex := [26]int{}\nfor i, b := range S {\n\tmaxIndex[b-'a'] = i\n}\nbegin := 0\nend := maxIndex[S[begin]-'a']\nres := make([]int, 0, len(S))\nfor i, b := range S {\n\tif i < end {\n\t\tend = max(end, maxIndex[b-'a'])\n\t\tcontinue\n\t}\n\tres = append(res, i-begin+1)\n\tbegin = i + 1\n\tif begin < len(S) {\n\t\tend = maxIndex[S[begin]-'a']\n\t}\n}\nreturn res", "gen": "var res []int\nfor i := 0; i < len(s); i++ {\n\tif s[i] == ' ' {\n\t\tcontinue\n\t}\n\tvar cur int\n\tfor j := i; j < len(s); j++ {\n\t\tif s[j] == ' ' {\n\t\t\tbreak\n\t\t}\n\t\tcur = max(cur, int(s[j]-'a')+1)\n\t}\n\tres = append(res, cur)\n\ti = j - 1\n}\nreturn res\n}"}
{"tgt": "FirstNumber := 1\nSecondNumber := 2\nnextNumber := 0\nsum := SecondNumber\nfor nextNumber < 4000000 {\n\tnextNumber = FirstNumber + SecondNumber\n\tif nextNumber%2 == 0 {\n\t\tsum = sum + nextNumber\n\t}\n\tFirstNumber = SecondNumber\n\tSecondNumber = nextNumber\n}\nfmt.Println(\"STR\", sum, \"STR\")", "gen": "n := 1\nm := 2\nsum := 0\nfor n < 4000000 {\n\tsum += n\n\tif sum%2 == 0 {\n\t\tsum += n\n\t}\n\tn = m + n\n\tm = sum\n}\nfmt.Println(sum)\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{2},\n\t\t\t{3, 4},\n\t\t\t{6, 5, 7},\n\t\t\t{4, 1, 8, 3},\n\t\t},\n\t\t11},\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{1},\n\t\t\t{2, 3},\n\t\t},\n\t\t3},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := minimumTotal(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "var s = Solution{\n\tname: \"STR\",\n\tinputs: [][]int{\n\t\t{2, 3, 4},\n\t\t{1, 2, 3, 4},\n\t\t{6, 5, 7},\n\t},\n\texpect: 11,\n}\nfor i, c := range []struct {\n\ttestName string\n\tinputs   [][]int\n\texpect   int\n}{\n\t{\"STR\", s.inputs, s.expect},\n\t{\"STR\", s.inputs, s.expect},\n} {\n\tt.Run(c.testName, func(t *testing.T) {\n\t\tret := maxProfit(c.inputs)\n\t\tif ret != c.expect {\n\t\t\tt.Fatalf(\"STR\", c.expect, ret)\n\t\t}\n\t})\n}\n}"}
{"tgt": "timeDelta := now.Sub(r.lastTimestamp)\nreturn r.Ewma.Update(nanosec/float64(timeDelta.Nanoseconds()), now)", "gen": "return e.Update(time.Since(t))\n}"}
{"tgt": "if list.head == nil {\n\treturn false\n}\nif list.head.data == i {\n\tlist.head = list.head.next\n\treturn true\n}\ncurrent := list.head\nfor current.next != nil {\n\tif current.next.data == i {\n\t\tcurrent.next = current.next.next\n\t\treturn true\n\t}\n\tcurrent = current.next\n}\nreturn false", "gen": "if root == nil {\n\treturn false\n}\nif root.Val == val {\n\troot = root.Next\n\treturn true\n}\nfor root.Next != nil {\n\tif root.Next.Val == val {\n\t\troot.Next = root.Next.Next\n\t\treturn true\n\t}\n\troot = root.Next\n}\nreturn false\n}"}
{"tgt": "mySet := make(map[int]int, 0)\nfor _, v := range candies {\n\tmySet[v]++\n}\nif len(mySet) >= len(candies)/2 {\n\treturn len(candies) / 2\n}\nreturn len(mySet)", "gen": "m := make(map[int]int)\nfor _, v := range nums {\n\tm[v]++\n}\nvar max int\nfor _, v := range m {\n\tif v > max {\n\t\tmax = v\n\t}\n}\nreturn max\n}"}
{"tgt": "a := []float64{1, 2, 3, 4, 5, 6}\nA := MakeMatrix(a, 3, 2)\nif A.cols != 2 ||\n\tA.rows != 3 ||\n\t!FloatArrayEquals(A.Elements, a) {\n\tt.Error()\n}", "gen": "a := []float64{1, 2, 3, 4, 5, 6}\nb := MakeMatrix(2, 3, a)\nif b.Rows != 2 || b.Cols != 3 {\n\tt.Error(\"MakeMatrix failed\")\n}\nif !FloatArrayEquals(b.Data, []float64{3, 4, 5, 6, 7, 8}) {\n\tt.Error(\"MakeMatrix failed\")\n}\n}"}
{"tgt": "count := 0\nfor _, c := range word {\n\tif unicode.IsUpper(c) {\n\t\tcount++\n\t}\n}\nreturn count == 0 || count == len(word) || (count == 1 && unicode.IsUpper(rune(word[0])))", "gen": "var count int\nfor _, c := range s {\n\tif unicode.IsUpper(c) {\n\t\tcount++\n\t}\n}\nif count == 0 || count == len(s) {\n\treturn true\n}\nif count == 1 {\n\treturn unicode.IsUpper(s[0])\n}\nreturn false\n}"}
{"tgt": "p.mu.Lock()\nactive := p.active\np.mu.Unlock()\nreturn active", "gen": "self.lock.Lock()\ndefer self.lock.Unlock()\nreturn self.size\n}"}
{"tgt": "select {\ncase r, ok := <-p.resources:\n\tlog.Println(\"STR\", \"STR\")\n\tif !ok {\n\t\treturn nil, ErrPoolClosed\n\t}\n\treturn r, nil\ndefault:\n\tlog.Println(\"STR\", \"STR\")\n\treturn p.factory()\n}", "gen": "select {\ncase <-p.closed:\n\treturn ErrPoolClosed\ncase job := <-p.queue:\n\treturn job\n}\n}"}
{"tgt": "err := ioutil.WriteFile(path, []byte(content), 0755)\nif err != nil {\n\tlog.Fatal(err)\n}", "gen": "err := ioutil.WriteFile(filename, []byte(content), 0644)\nif err != nil {\n\tlog.Fatal(err)\n}\n}"}
{"tgt": "tree := New(compare)\ntree.Insert(1)\ntree.Insert(2)\ntree.Insert(3)\nfindTree := tree.Search(2)\nif findTree.node != 2 {\n\tt.Error(\"STR\")\n}\nfindNilTree := tree.Search(100)\nif findNilTree != nil {\n\tt.Error(\"STR\")\n}", "gen": "tree := New(compare)\ntree.Insert(1)\ntree.Insert(2)\ntree.Insert(3)\nif tree.Search(1) != 1 {\n\tt.Error(\"STR\", \"STR\")\n}\nif tree.Search(2) != 2 {\n\tt.Error(\"STR\", \"STR\")\n}\nif tree.Search(3) != 3 {\n\tt.Error(\"STR\", \"STR\")\n}\nif tree.Search(4) != nil {\n\tt.Error(\"STR\", \"STR\")\n}\n}"}
{"tgt": "l := new(ListNode)\nn := l\nvar extra int\nfor l1 != nil || l2 != nil {\n\tn.Next = new(ListNode)\n\tn = n.Next\n\tif l1 != nil {\n\t\textra += l1.Val\n\t\tl1 = l1.Next\n\t}\n\tif l2 != nil {\n\t\textra += l2.Val\n\t\tl2 = l2.Next\n\t}\n\tn.Val = extra % 10\n\textra /= 10\n}\nif extra > 0 {\n\tn.Next = &ListNode{Val: extra}\n}\nreturn l.Next", "gen": "var sum int\nvar node *ListNode\nfor head != nil || tail != nil {\n\tif head != nil {\n\t\tsum += head.Val\n\t\thead = head.Next\n\t}\n\tif tail != nil {\n\t\tsum += tail.Val\n\t\ttail = tail.Next\n\t}\n\tif sum > 9 {\n\t\tnode = &ListNode{sum % 10, node}\n\t\tsum /= 10\n\t}\n}\nif sum > 0 {\n\tnode = &ListNode{sum, node}\n}\nreturn node\n}"}
{"tgt": "empty := 0\nhold := -1 << 63\nfor _, p := range prices {\n\ttemp := empty\n\tempty = max(empty, hold+p)\n\thold = max(hold, temp-p-fee)\n}\nreturn empty", "gen": "max := 0\nmin := -9223372036854775808\nfor _, num := range nums {\n\tmax = maxMax(max, num)\n\tmin = minMin(min, num)\n}\nreturn max - min\n}"}
{"tgt": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"STR\", got, tt.want)\n\t\t}\n\t})\n}", "gen": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"largestOverlap() = %v, want %v\", got, tt.want)\n\t\t}\n\t})\n}\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   5,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   10,\n\t\twant: 5,\n\t},\n\t{\n\t\tin:   0,\n\t\twant: 1,\n\t},\n}\nfor _, tt := range tests {\n\tgot := bitwiseComplement(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "tests := []struct {\n\tinput  int\n\texpect int\n}{\n\t{5, 2},\n\t{7, 0},\n\t{0, 10},\n\t{5, 0},\n}\nfor _, tt := range tests {\n\tif result := bitwiseComplement(tt.input); result != tt.expect {\n\t\tt.Fatalf(\"STR\", tt.input, tt.expect, result)\n\t}\n}\n}"}
{"tgt": "syscall.Exit(code)", "gen": "syscall.Exit(0)\n}"}
{"tgt": "if len(input) == 0 {\n\treturn true\n}\nif len(input)%2 != 0 {\n\treturn false\n}\nvar stack []byte\nfor i := 0; i < len(input); i++ {\n\tif input[i] == \"STR\" || input[i] == \"STR\" || input[i] == \"STR\" {\n\t\tstack = append(stack, input[i])\n\t} else {\n\t\tif len(stack) > 0 {\n\t\t\tpair := string(stack[len(stack)-1]) + string(input[i])\n\t\t\tstack = stack[:len(stack)-1]\n\t\t\tif pair != \"STR\" && pair != \"STR\" && pair != \"STR\" {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn len(stack) == 0", "gen": "if len(s) == 0 {\n\treturn true\n}\nif s[0] == '(' || s[0] == '{' || s[0] == '[' {\n\treturn false\n}\nvar stack []byte\nfor i := 0; i < len(s); i++ {\n\tif s[i] == ')' || s[i] == '}' || s[i] == ']' {\n\t\tif len(stack) == 0 {\n\t\t\treturn false\n\t\t}\n\t\tif s[i] == ')' && stack[len(stack)-1] != '(' {\n\t\t\treturn false\n\t\t}\n\t\tif s[i] == '}' && stack[len(stack)-1] != '{' {\n\t\t\treturn false\n\t\t}\n\t\tif s[i] == ']' && stack[len(stack)-1] != '[' {\n\t\t\treturn false\n\t\t}\n\t\tstack = stack[:len(stack)-1]\n\t} else {\n\t\tstack = append(stack, s[i])\n\t}\n}\nif len(stack) == 0 {\n\treturn true\n}\nreturn false\n}"}
{"tgt": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 0},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 11},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 19},\n\t\tans1208{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s, p.t, p.maxCost))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\"},\n\t\ttrue,\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\"},\n\t\ttrue,\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\"},\n\t\ttrue,\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s1, p.s2))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{124123, 13425, 123, 65, 1, 54362, 134, 6543, 213}, 3},\n\t{\"STR\", []int{}, 0},\n\t{\"STR\", []int{4253626756, 3245876, 2345897, 23490}, 1},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{124123, 13425, 123, 65, 1, 54362, 134, 6543, 213}, 4253626756},\n\t{\"STR\", []int{4253626756, 3245876, 2345897, 23490, 1}, 4253626756},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tret := Solution(c.inputs)\n\t\tif ret != c.expect {\n\t\t\tt.Fatalf(\"STR\", c.expect, ret)\n\t\t}\n\t})\n}\n}"}
{"tgt": "if len(sorted) == 0 {\n\treturn nil\n}\nmid := len(sorted) / 2\nroot := &BST{Value: sorted[mid]}\nroot.Left = SortedSliceToBST(sorted[:mid])\nroot.Right = SortedSliceToBST(sorted[mid+1:])\nreturn root", "gen": "if len(nums) == 0 {\n\treturn nil\n}\nmid := len(nums) / 2\nleft := SortedSliceToBST(nums[:mid])\nright := SortedSliceToBST(nums[mid:])\nreturn &BST{\n\tVal:   nums[mid],\n\tLeft:  left,\n\tRight: right,\n}\n}"}
{"tgt": "negative := false\nif num < 0 {\n\tnegative = true\n\tnum = -num\n}\nbf := bytes.NewBufferString(\"STR\")\nfor num >= 7 {\n\tmod := num % 7\n\tnum /= 7\n\tbf.WriteByte(byte(mod) + 48)\n}\nbf.WriteByte(byte(num) + 48)\nif negative {\n\tbf.WriteByte('-')\n}\nbs := bf.Bytes()\nfor s, e := 0, len(bs)-1; s < e; s, e = s+1, e-1 {\n\tbs[s], bs[e] = bs[e], bs[s]\n}\nreturn string(bs)", "gen": "negative := n < 0\nn = abs(n)\nbuf := bytes.NewBufferString(\"\")\nfor n > 0 {\n\tbuf.WriteByte(byte(n%10 + '0'))\n\tn /= 10\n}\nbuf.WriteByte('-')\nfor i, j := 0, len(buf.Bytes())-1; i < j; i, j = i+1, j-1 {\n\tbuf.Bytes[i], buf.Bytes[j] = buf.Bytes[j], buf.Bytes[i]\n}\nreturn buf.String()\n}"}
{"tgt": "s = strings.ToLower(s)\ni, j := 0, len(s)-1\nfor i < j {\n\tfor i < j && !isChar(s[i]) {\n\t\ti++\n\t}\n\tfor i < j && !isChar(s[j]) {\n\t\tj--\n\t}\n\tif s[i] != s[j] {\n\t\treturn false\n\t}\n\ti++\n\tj--\n}\nreturn true", "gen": "s = strings.ToLower(s)\ni, j := 0, len(s)-1\nfor i < j {\n\tfor !isChar(s[i]) {\n\t\ti++\n\t}\n\tfor !isChar(s[j]) {\n\t\tj--\n\t}\n\tif s[i] != s[j] {\n\t\treturn false\n\t}\n\ti++\n\tj--\n}\nreturn true\n}"}
{"tgt": "n := len(nums)\ntmp := make([]int, n)\ncopy(tmp, nums)\nfor i := 0; i < n; i++ {\n\tnums[(i+k)%n] = tmp[i]\n}", "gen": "n := len(nums)\nres := make([]int, n)\nfor i := 0; i < n; i++ {\n\tres[i] = nums[i*n]\n}\nreturn res\n}"}
{"tgt": "random := rand.New(rand.NewSource(time.Now().UnixNano()))\narray := make([]int, random.Intn(100-10)+10)\nfor i := range array {\n\tarray[i] = random.Intn(100)\n}\nSortArray(array)\nfor _, value := range array {\n\tresult := ExponentialSearch(array, value)\n\tif result == -1 {\n\t\tt.Fail()\n\t}\n}", "gen": "rand.Seed(time.Now().UnixNano())\narr := make([]int, 100)\nfor i := 0; i < 100; i++ {\n\tarr[i] = rand.Intn(90)\n}\nfor i := 0; i < 100; i++ {\n\tif ExponentialSearch(arr, i) != i {\n\t\tt.Fail()\n\t}\n}\nSortArray(arr)\nfor i := 0; i < 100; i++ {\n\tif ExponentialSearch(arr, i) != i {\n\t\tt.Fail()\n\t}\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimumPartitionPalindrome(tc.input); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimumPartitionPalindrome(tc.input); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "obj := Constructor732()\nfmt.Printf(\"STR\", obj.Book(10, 20))\nfmt.Printf(\"STR\", obj.Book(50, 60))\nfmt.Printf(\"STR\", obj.Book(10, 40))\nfmt.Printf(\"STR\", obj.Book(5, 15))\nfmt.Printf(\"STR\", obj.Book(5, 10))\nfmt.Printf(\"STR\", obj.Book(25, 55))", "gen": "c := Constructor732()\nc.Book(20, 10)\nfmt.Printf(\"STR\", c.Book(60, 50))\nfmt.Printf(\"STR\", c.Book(40, 10))\nfmt.Printf(\"STR\", c.Book(15, 5))\nfmt.Printf(\"STR\", c.Book(10, 5))\nfmt.Printf(\"STR\", c.Book(55, 25))\nfmt.Printf(\"STR\", c.Book(50, 25))\n}"}
{"tgt": "if a == nil && b == nil {\n\treturn true\n}\nif len(a) != len(b) {\n\treturn false\n}\nfor i := range a {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "if len(s) == 0 || len(s) == len(t) {\n\treturn false\n}\nif len(s) == len(t) {\n\treturn true\n}\nfor i := 0; i < len(s); i++ {\n\tif s[i] != t[i] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "val := \"STR\"\nfor i := 1; i < n; i++ {\n\tvar (\n\t\tc   int\n\t\tv   byte\n\t\tstr string\n\t)\n\tfor j := 0; j < len(val); j++ {\n\t\tif val[j] == v {\n\t\t\tc++\n\t\t\tcontinue\n\t\t}\n\t\tif c != 0 {\n\t\t\tstr += string(c+'0') + string(v)\n\t\t}\n\t\tc, v = 1, val[j]\n\t}\n\tval = str + string(c+'0') + string(v)\n}\nreturn val", "gen": "var res string\nfor i := 1; i <= n; i++ {\n\tvar cnt int\n\tfor j := 0; j < len(s); j++ {\n\t\tif s[j] == '0' {\n\t\t\tcnt++\n\t\t}\n\t}\n\tres += strconv.Itoa(i) + \":\" + strconv.Itoa(cnt)\n}\nreturn res\n}"}
{"tgt": "res := 0\nif n != 0 {\n\trightMostBitInt := n & -n\n\tnextHigherSetBitInt := n + rightMostBitInt\n\td := n ^ nextHigherSetBitInt\n\td /= rightMostBitInt\n\td >>= 2\n\tres = nextHigherSetBitInt | d\n}\nreturn res", "gen": "var res int\nif n != 0 {\n\tres = (n - 1) ^ (n + 1)\n\tres = (res >> 2) ^ (res & 3)\n}\nreturn res\n}"}
{"tgt": "if len(nums) == 0 || len(nums) < k {\n\treturn make([]int, 0)\n}\nqueue := make([]int, 0, k)\nans := make([]int, len(nums)-k+1)\nfor left, right := 1-k, 0; right < len(nums); left, right = left+1, right+1 {\n\tif left > 0 && queue[0] == nums[left-1] {\n\t\tqueue = queue[1:len(queue)]\n\t}\n\tfor len(queue) != 0 && queue[len(queue)-1] < nums[right] {\n\t\tqueue = queue[:len(queue)-1]\n\t}\n\tqueue = append(queue, nums[right])\n\tif left >= 0 {\n\t\tans[left] = queue[0]\n\t}\n}\nreturn ans", "gen": "if len(nums) == 0 {\n\treturn []int{}\n}\nif len(nums) == k {\n\treturn nums\n}\nres := make([]int, 0)\nstart, end := 0, len(nums)-k\nfor start < end {\n\tif nums[start] == nums[end] {\n\t\tstart++\n\t\tend--\n\t} else if nums[start] < nums[end] {\n\t\tres = append(res, nums[start])\n\t\tstart++\n\t} else {\n\t\tend--\n\t}\n}\nreturn res\n}"}
{"tgt": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{}\n} else if n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{intervals[0]}\nfor _, cur := range intervals[1:] {\n\tprevious := res[len(res)-1]\n\tif cur.Start <= previous.End {\n\t\tend := previous.End\n\t\tif cur.End > end {\n\t\t\tend = cur.End\n\t\t}\n\t\tres = append(res[:len(res)-1], Interval{Start: previous.Start, End: end})\n\t} else {\n\t\tres = append(res, cur)\n\t}\n}\nreturn res", "gen": "if len(intervals) == 0 {\n\treturn []Interval{}\n}\nif len(intervals) == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{{intervals[0].Start, intervals[0].End}}\nfor i := 1; i < len(intervals); i++ {\n\tif res[len(res)-1].End >= intervals[i].Start {\n\t\tres[len(res)-1].End = max(res[len(res)-1].End, intervals[i].End)\n\t} else {\n\t\tres = append(res, intervals[i])\n\t}\n}\nreturn res\n}"}
{"tgt": "max := 9999\nbiggestPandigital := 0\nvar numberMultiplied int\nfor i := max; i > 0; i-- {\n\tnumberMultiplied = i\n\tfor j := 1; len(digits(numberMultiplied)) <= 9; j++ {\n\t\tnumberMultiplied = concatenMultiplication(i, j)\n\t\tif IsPandigital(numberMultiplied) && numberMultiplied > biggestPandigital {\n\t\t\tfmt.Println(numberMultiplied)\n\t\t\tbiggestPandigital = numberMultiplied\n\t\t}\n\t}\n}", "gen": "n := 9999\nfor i := 999; i > 0; i-- {\n\tp := concatenMultiplication(i, n)\n\tif IsPandigital(p) {\n\t\tfmt.Println(p)\n\t\treturn\n\t}\n}\n}"}
{"tgt": "n := len(pushed)\ns := make([]int, 0, n)\ni := 0\nfor _, x := range pushed {\n\ts = append(s, x)\n\tfor len(s) != 0 && s[len(s)-1] == popped[i] {\n\t\ts = s[:len(s)-1]\n\t\ti++\n\t}\n}\nreturn i == n", "gen": "n := len(nums)\nres := make([]int, 0)\ni := 0\nfor j := 0; j < n; j++ {\n\tres = append(res, nums[j])\n\tfor i < j && res[i] == res[j] {\n\t\ti++\n\t}\n}\nreturn len(res) == n\n}"}
{"tgt": "testCases := [][]int{\n\t{1, 2, 3, 1},\n\t{1, 0, 1, 1},\n\t{1, 2, 3, 1, 2, 3},\n}\nks := []int{3, 1, 2}\nexpected := []bool{true, true, false}\nfor index, nums := range testCases {\n\tif res := containsNearbyDuplicate(nums, ks[index]); res != expected[index] {\n\t\tt.Errorf(\"STR\", expected[index], res)\n\t}\n}", "gen": "tests := []struct {\n\tnums   []int\n\tk      int\n\texpect bool\n}{\n\t{[]int{1, 2, 3, 1}, 3, true},\n\t{[]int{1, 0, 1, 1}, 1, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 2, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 3, true},\n\t{[]int{1, 2, 3, 1, 2, 3}, 4, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 5, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 6, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 7, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 8, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 9, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 10, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 11, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 12, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 13, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 14, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 15, false},\n\t{[]int{1, 2, 3"}
{"tgt": "item := req.URL.Query().Get(\"STR\")\nif price, ok := db[item]; ok {\n\tfmt.Fprintf(w, \"STR\", price)\n} else {\n\tw.WriteHeader(http.StatusNotFound)\n\tfmt.Fprintf(w, \"STR\", item)\n}", "gen": "query := u.Query()\nvalue := query.Get(\"code\")\nif value == \"\" {\n\tfmt.Fprintf(w, \"STR\")\n} else {\n\tfmt.Fprintf(w, \"STR\", value)\n}\n}"}
{"tgt": "l, r := &maxHeap{}, &minHeap{}\nheap.Init(l)\nheap.Init(r)\nreturn MedianFinder{l, r}", "gen": "maxHeap := &maxHeap{}\nminHeap := &minHeap{}\nreturn &MedianFinder{\n\tmaxHeap: maxHeap,\n\tminHeap: minHeap,\n}\n}"}
{"tgt": "var buf [32]byte\ni := len(buf) - 1\nfor val >= 10 {\n\tbuf[i] = byte(val%10 + \"STR\")\n\ti--\n\tval /= 10\n}\nbuf[i] = byte(val + \"STR\")\nreturn string(buf[i:])", "gen": "var res string\nfor i := 31; i >= 0; i-- {\n\tres = string(res + \"01\"[i%2])\n\tn /= 2\n}\nreturn res\n}"}
{"tgt": "if len(nums1) == 0 || len(nums2) == 0 {\n\treturn []int{}\n}\nnum1Map := make(map[int]bool)\nfor i := range nums1 {\n\tnum1Map[nums1[i]] = true\n}\nnum2Map := make(map[int]bool)\nvar res []int\nfor i := range nums2 {\n\tif _, ok1 := num1Map[nums2[i]]; ok1 && !num2Map[nums2[i]] {\n\t\tnum2Map[nums2[i]] = true\n\t\tres = append(res, nums2[i])\n\t}\n}\nreturn res", "gen": "if len(nums) == 0 || len(nums) == 1 {\n\treturn []int{}\n}\nif len(nums) == 2 && nums[0] == nums[1] {\n\treturn []int{nums[0]}\n}\nm := make(map[int]bool)\nfor _, v := range nums {\n\tm[v] = true\n}\nm2 := make(map[int]bool)\nfor k, v := range m {\n\tif v {\n\t\tm2[k] = true\n\t}\n}\nres := make(map[int]bool)\nfor i := 0; i < len(nums); i++ {\n\tif _, ok := m2[i]; ok {\n\t\tres[i] = true\n\t}\n}\nreturn res\n}"}
{"tgt": "var ret [][]int\nvar nums []int\nnums = []int{-1, 0, 1, 2, -1, -4}\nret = [][]int{{-1, -1, 2}, {-1, 0, 1}}\nfor k, num := range threeSum(nums) {\n\tfor i, v := range num {\n\t\tif v != ret[k][i] {\n\t\t\tt.Fatalf(\"STR\", ret)\n\t\t}\n\t}\n}", "gen": "var res [][]int\nvar nums = []int{-1, 0, 1, -4}\nvar target = -1\nvar result = threeSum(nums, target)\nfor _, v := range result {\n\tres = append(res, v)\n}\nif len(res) != 6 {\n\tt.Fatalf(\"STR\", res)\n}\n}"}
{"tgt": "dist := make([]int, N+1)\nfor i := 0; i < len(dist); i++ {\n\tdist[i] = math.MaxInt32\n}\ndist[K] = 0\nfor i := 0; i < N; i++ {\n\tfor _, t := range times {\n\t\tu, v, w := t[0], t[1], t[2]\n\t\tif dist[u] != math.MaxInt32 && dist[v] > dist[u]+w {\n\t\t\tdist[v] = dist[u] + w\n\t\t}\n\t}\n}\nmx := 0\nfor i := 1; i <= N; i++ {\n\tif mx < dist[i] {\n\t\tmx = dist[i]\n\t}\n}\nif mx == math.MaxInt32 {\n\treturn -1\n}\nreturn mx", "gen": "dp := make([]int, n+1)\nfor i := 1; i <= n; i++ {\n\tdp[i] = 2147483647\n}\nfor i := 0; i < m; i++ {\n\tfor j := 0; j < len(nums[i]); j++ {\n\t\tdp[nums[i][j]] = 0\n\t}\n\tfor j := 1; j <= n; j++ {\n\t\tif dp[j] == 2147483647 {\n\t\t\tcontinue\n\t\t}\n\t\tif dp[j] == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif dp[j] > dp[j-1] {\n\t\t\tdp[j] = dp[j-1]\n\t\t}\n\t\tif dp[j] > dp[j+1] {\n\t\t\tdp[j] = dp[j+1]\n\t\t}\n\t}\n}\nres := 2147483647\nfor i := 0; i < n; i++ {\n\tif res > dp[i] {\n\t\tres = dp[i]\n\t}\n}\nif res == 2147483647 {\n\treturn -1\n}\nreturn res\n}"}
{"tgt": "dat, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\nnamesList := string(dat)\nnamesList = strings.Replace(namesList, \"STR\", \"STR\", -1)\nnames := strings.Split(namesList, \"STR\")\nsort.Strings(names)\nnamesScore := 0\nfor index, name := range names {\n\tnamesScore += nameScore(name) * (index + 1)\n}\nfmt.Println(namesScore)", "gen": "b, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\ns := string(b)\ns = strings.Replace(s, \"STR\", \"STR\", -1)\ns = strings.Split(s, \"STR\")\nsort.Strings(s)\nvar sum int\nfor _, v := range s {\n\tsum += nameScore(v)\n}\nfmt.Println(sum)\n}"}
{"tgt": "var matrix [][]int\nmatrix = [][]int{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 9},\n}\nrotate(matrix)", "gen": "nums1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nnums2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nrotate(nums1, 3, nums2)\n}"}
{"tgt": "curr := n\nfor _, c := range s {\n\tnext, ok := curr.children[c]\n\tif !ok {\n\t\tnext = NewNode()\n\t\tcurr.children[c] = next\n\t}\n\tcurr = next\n}\ncurr.isLeaf = true", "gen": "var (\n\tisWord bool\n\ti      int\n)\nfor _, c := range s {\n\ti = int(c)\n\tisWord = trie.nodes[i].isWord\n\ttrie.nodes[i] = NewNode()\n\ttrie.nodes[i].isWord = isWord\n}\ntrie.nodes[0].isWord = true\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.qux); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.qux, tc.expected, result)\n\t}\n}\n}"}
{"tgt": "sum := 0\nfor i := 2; i < 999999; i++ {\n\tif isSumOfFivePowerOfDigitsEqualToNumber(i) {\n\t\tsum += i\n\t}\n}\nreturn sum", "gen": "sum := 0\nfor i := 2; i < 1000000; i++ {\n\tif isSumOfFivePowerOfDigitsEqualToNumber(i) {\n\t\tsum += i\n\t}\n}\nreturn sum\n}"}
{"tgt": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nret := &ListNode{}\nif l1.Val <= l2.Val {\n\tret = l1\n\tret.Next = mergeTwoLists1(l1.Next, l2)\n} else {\n\tret = l2\n\tret.Next = mergeTwoLists1(l1, l2.Next)\n}\nreturn ret", "gen": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nif l1.Val < l2.Val {\n\tl1.Next = mergeTwoLists1(l1.Next, l2)\n\treturn l1\n}\nl2.Next = mergeTwoLists1(l1, l2.Next)\nreturn l2\n}"}
{"tgt": "a := int(math.Log10(float64(number))) + 1\nresult := 0\nfor i := 1; i <= a; i++ {\n\tresult += digit(number, i) * int(math.Pow10(a-i))\n}\nreturn result", "gen": "n := int(math.Log10(float64(n))) + 1\nsum := 0\nfor i := 1; i <= n; i++ {\n\tsum += digit(n, i) * int(math.Pow10(n-i))\n}\nreturn sum\n}"}
{"tgt": "maxans := 0\ndp := make([]int, len(s))\nfor i := 1; i < len(s); i++ {\n\tif s[i] == \"STR\" {\n\t\tif s[i-1] == \"STR\" {\n\t\t\tif i >= 2 {\n\t\t\t\tdp[i] = dp[i-2] + 2\n\t\t\t} else {\n\t\t\t\tdp[i] = 2\n\t\t\t}\n\t\t} else if i-dp[i-1] > 0 && s[i-dp[i-1]-1] == \"STR\" {\n\t\t\tif i-dp[i-1] >= 2 {\n\t\t\t\tdp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2\n\t\t\t} else {\n\t\t\t\tdp[i] = dp[i-1] + 2\n\t\t\t}\n\t\t}\n\t}\n\tmaxans = Max(maxans, dp[i])\n}\nreturn maxans", "gen": "max := 0\nfor i := 1; i < len(s); i++ {\n\tif s[i] == 'I' {\n\t\tif i > 0 && s[i-1] == 'I' {\n\t\t\ts[i] = 'X'\n\t\t\ts[i-1] = 'X'\n\t\t\ts[i-2]++\n\t\t} else {\n\t\t\ts[i] = 'X'\n\t\t\ts[i-1]++\n\t\t}\n\t} else if s[i] == 'X' {\n\t\tif i > 0 && s[i-1] == 'X' {\n\t\t\ts[i] = 'I'\n\t\t\ts[i-1] = 'I'\n\t\t\ts[i-2]++\n\t\t} else {\n\t\t\ts[i] = 'I'\n\t\t\ts[i-1]++\n\t\t}\n\t}\n\tmax = Max(max, s[i])\n}\nreturn max\n}"}
{"tgt": "s.lock.Lock()\ndefer s.lock.Unlock()\nl := len(s.nodes)\nif l == 0 {\n\treturn nil, errors.New(\"STR\")\n}\nnode := s.nodes[l-1]\ns.nodes = s.nodes[:l-1]\nreturn node, nil", "gen": "if len(head) == 0 {\n\treturn nil, errors.New(\"STR\")\n}\nhead.Lock()\ndefer head.Unlock()\nif head.Next == nil {\n\treturn nil, errors.New(\"STR\")\n}\nreturn head.Next, nil\n}"}
{"tgt": "max1, max2, max3, min1, min2 := -1001, -1001, -1001, 1001, 1001\nfor _, v := range nums {\n\tif v > max1 {\n\t\tmax3 = max2\n\t\tmax2 = max1\n\t\tmax1 = v\n\t} else if v > max2 {\n\t\tmax3 = max2\n\t\tmax2 = v\n\t} else if v > max3 {\n\t\tmax3 = v\n\t}\n\tif v < min1 {\n\t\tmin2 = min1\n\t\tmin1 = v\n\t} else if v < min2 {\n\t\tmin2 = v\n\t}\n}\nreturn max(max1*min1*min2, max1*max2*max3)", "gen": "max := -1001\nmin := -1001\nsum := 1001\nfor _, num := range nums {\n\tif num > max {\n\t\tmax = num\n\t}\n\tif num < min {\n\t\tmin = num\n\t}\n\tsum += num\n}\nreturn max * min * sum\n}"}
{"tgt": "h := fnv.New64a()\n_, _ = h.Write([]byte(fmt.Sprintf(\"STR\", key)))\nhashValue := h.Sum64()\nreturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))", "gen": "hasher := fnv.New64a()\nhasher.Write([]byte(fmt.Sprintf(\".LC52\", 2)))\nreturn hasher.Sum64() ^ uint64(hasher.Sum64())\n}"}
{"tgt": "arr := make([]int, n+1, n+1)\narr[0] = 0\narr[1] = 1\nfor x := 2; x <= n; x++ {\n\tarr[x] = -1\n}\nreturn fibonacciDyamic(n, arr)", "gen": "f := make([]int, n+2)\nf[0], f[1] = 0, 1\nfor i := 2; i <= n; i++ {\n\tf[i] = -1\n}\nreturn fibonacciDyamic(f, n)\n}"}
{"tgt": "*ss = Count{\n\tolist: make([]countBucket, size),\n\thash:  make(map[string]uint32, size),\n}\nreturn ss", "gen": "return Count{\n\tbuckets: make([]uint32, len(s)),\n\tcounts:  make(map[string]uint32, len(s)),\n}\n}"}
{"tgt": "if len(nums) == 0 {\n\treturn 0\n} else if len(nums) == 1 {\n\treturn nums[0]\n}\nmax := func(m, n int) int {\n\tif m > n {\n\t\treturn m\n\t}\n\treturn n\n}\ndp := []int{nums[0], max(nums[0], nums[1])}\nfor i := 2; i < len(nums); i++ {\n\tdp[i%2] = max(dp[(i-1)%2], nums[i]+dp[i%2])\n}\nreturn dp[(len(nums)-1)%2]", "gen": "if len(nums) == 0 {\n\treturn 0\n}\nif len(nums) == 1 {\n\treturn nums[0]\n}\nif len(nums) == 2 {\n\treturn max(nums[0], nums[1])\n}\ndp := make([]int, len(nums))\ndp[0] = nums[0]\ndp[1] = max(nums[0], nums[1])\nfor i := 2; i < len(nums); i++ {\n\tdp[i] = max(dp[i-1], dp[i-2]+nums[i])\n}\nreturn dp[len(nums)-1]\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CanHopToEnd(tc.hops); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.hops, tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := CanHopToEnd(tc.start, tc.end, tc.hops); res != tc.expected {\n\t\tt.Errorf(\"STR\", tc.start, tc.end, tc.hops, tc.expected, res)\n\t}\n}\n}"}
{"tgt": "n := NewNode()\ninsertWords := [...]string{\n\t\"STR\",\n\t\"STR\",\n}\ncheckWords := map[string]bool{\n\t\"STR\": false,\n\t\"STR\": false,\n\t\"STR\": true,\n}\nfor _, w := range insertWords {\n\tn.Insert(w)\n\tt.Logf(\n\t\t\"STR\",\n\t\tw,\n\t)\n}\nfor k, v := range checkWords {\n\tok := n.Find(k)\n\tif ok != v {\n\t\tt.Fatalf(\n\t\t\t\"STR\",\n\t\t\tk,\n\t\t\tmap[bool]string{true: \"STR\"}[v],\n\t\t)\n\t}\n\tt.Logf(\n\t\t\"STR\",\n\t\tk,\n\t\tmap[bool]string{true: \"STR\"}[ok],\n\t)\n}", "gen": "trie := NewNode()\nstrs := []string{\n\t\"STR\",\n\t\"STR\",\n\t\"STR\",\n}\nfor _, str := range strs {\n\ttrie.Insert(str, true)\n}\nfor k, v := range trie.Find(\"STR\") {\n\tif v != true {\n\t\tt.Fatalf(\"STR should be true\")\n\t}\n}\nfor k, v := range trie.Find(\"STR\") {\n\tif v != true {\n\t\tt.Fatalf(\"STR should be true\")\n\t}\n}\nfor k, v := range trie.Find(\"STR\") {\n\tif v != true {\n\t\tt.Fatalf(\"STR should be true\")\n\t}\n}\n}"}
{"tgt": "if cl.Size > 0 {\n\tif places < 0 {\n\t\tmultiple := cl.Size - 1 - places/cl.Size\n\t\tplaces += multiple * cl.Size\n\t}\n\tplaces %= cl.Size\n\tif places > cl.Size/2 {\n\t\tplaces = cl.Size - places\n\t\tfor i := 0; i < places; i++ {\n\t\t\tcl.Head = cl.Head.Prev\n\t\t}\n\t} else if places == 0 {\n\t\treturn\n\t} else {\n\t\tfor i := 0; i < places; i++ {\n\t\t\tcl.Head = cl.Head.Next\n\t\t}\n\t}\n}", "gen": "if len(this.data) <= this.head {\n\treturn this.data[this.head]\n}\nif this.head < 0 {\n\tthis.head = -this.head - 1\n\tthis.head = this.data[this.head]\n}\nif this.head < 0 {\n\tthis.head = -this.head - 1\n\tthis.head = this.data[this.head]\n}\nif this.head < 0 {\n\tthis.head = -this.head - 1\n\tthis.head = this.data[this.head]\n}\nif this.head < 0 {\n\tthis.head = -this.head - 1\n\tthis.head = this.data[this.head]\n}\nif this.head < 0 {\n\tthis.head = -this.head - 1\n\tthis.head = this.data[this.head]\n}\nif this.head < 0 {\n\tthis.head = -this.head - 1\n\tthis.head = this.data[this.head]\n}\nif this.head < 0 {\n\tthis.head = -this.head - 1\n\tthis.head = this.data[this.head]\n}\nif this.head < 0 {\n\tthis.head = -this.head - 1\n\tthis.head = this.data[this.head]\n}\nif this.head < 0 {\n\tthis.head = -this.head - 1\n\tthis.head = this.data[this.head]\n}\nif this.head < 0 {\n\tthis.head = -this.head - 1\n\tthis.head = this.data[this.head]\n}\nif this.head < 0 {\n\tthis.head = -this.head - 1\n\tthis.head = this.data[this.head]\n}\nif this.head < 0 {"}
{"tgt": "s.lock.Lock()\ndefer s.lock.Unlock()\nreturn s.len", "gen": "defer s.lock.Unlock()\nreturn s.top\n}"}
{"tgt": "return fmt.Sprintf(\"STR\", p.Name, p.Age)", "gen": "return fmt.Sprintf(\"STR\", s.ID)\n}"}
{"tgt": "if n < 2 {\n\treturn 1\n}\nrec := make([]int, n+1)\nrec[0], rec[1] = 1, 1\nfor i := 2; i <= n; i++ {\n\trec[i] = rec[i-1] + rec[i-2]\n}\nreturn rec[n]", "gen": "if n == 1 {\n\treturn 1\n}\narr := make([]int, n+1)\narr[0] = 1\narr[1] = 1\nfor i := 2; i <= n; i++ {\n\tarr[i] = arr[i-1] + arr[i-2]\n}\nreturn arr[n]\n}"}
{"tgt": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\ntmp := nums[0]\nmax := tmp\nfor i := 1; i < n; i++ {\n\tif tmp < 0 {\n\t\ttmp = nums[i]\n\t} else {\n\t\ttmp += nums[i]\n\t}\n\tif max < tmp {\n\t\tmax = tmp\n\t}\n}\nreturn max", "gen": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\nres := nums[0]\nmax := nums[0]\nfor i := 1; i < n; i++ {\n\tif i < n-1 && nums[i] < nums[i+1] {\n\t\tres += nums[i]\n\t} else {\n\t\tres += nums[i]\n\t\tmax = nums[i]\n\t}\n}\nreturn res\n}"}
{"tgt": "return syscall.Getgid()", "gen": "return syscall.Getgid()\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tarr1   []int\n\tarr2   []int\n\td      int\n\texpect int\n}{\n\t{\"STR\", []int{4, 5, 8}, []int{10, 9, 1, 8}, 2, 2},\n\t{\"STR\", []int{1, 4, 2, 3}, []int{-4, -3, 6, 10, 20, 30}, 3, 2},\n\t{\"STR\", []int{2, 1, 100, 3}, []int{-5, -2, 10, -3, 7}, 6, 1},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.arr1, c.arr2, c.d)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.arr1, c.arr2, c.d)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tarr1   []int\n\tarr2   []int\n\td      int\n\texpect int\n}{\n\t{\"STR\", []int{4, 5, 8}, []int{10, 9, 1}, 3, 2},\n\t{\"STR\", []int{1, 4, 2}, []int{10, 3, 7}, 5, 3},\n\t{\"STR\", []int{-5, -3, 6}, []int{10, 20, 30}, -2, 1},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := findTheDistanceValue(c.arr1, c.arr2, c.d)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\", c, got, c.expect)\n\t\t}\n\t})\n}\n}"}
{"tgt": "if h.Count != 0 {\n\tfor i := 0; i < int(h.Cap); i++ {\n\t\thashValue := h.hash(key, uint32(i))\n\t\tif h.backets[hashValue] != nil && h.backets[hashValue].Key == key {\n\t\t\treturn h.backets[hashValue].Value, h.backets[hashValue].exist\n\t\t}\n\t}\n}\nreturn nil, false", "gen": "if len(h.buckets) > 0 {\n\tfor i := 0; i < len(h.buckets); i++ {\n\t\tif h.buckets[i] != nil {\n\t\t\tif h.buckets[i].key.Equal(key) {\n\t\t\t\treturn h.buckets[i].value, true\n\t\t\t}\n\t\t}\n\t}\n}\nreturn nil, false\n}"}
{"tgt": "l1 := len(board)\nif l1 == 0 {\n\treturn\n}\nl2 := len(board[0])\nif l2 == 0 {\n\treturn\n}\nvisit := make([][]bool, l1)\nfor i := 0; i < l1; i++ {\n\tvisit[i] = make([]bool, l2)\n}\nfor i := 0; i < l1; i++ {\n\tfor j := 0; j < l2; j++ {\n\t\tif !visit[i][j] {\n\t\t\thelper(board, visit, i, j)\n\t\t}\n\t}\n}", "gen": "n := len(A)\nif n == 0 {\n\treturn nil\n}\nm := len(A[0])\nres := make([]bool, m)\nfor i := 0; i < m; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tif A[j][i] == '1' {\n\t\t\tres[i] = true\n\t\t\tbreak\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "return me[0] == \"STR\"", "gen": "return len(s) == 1 && s[0] == 'a'\n}"}
{"tgt": "if len(intervals) <= 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i][0] <= intervals[j][0]\n})\nresult := make([][]int, 0)\ncur := intervals[0]\nfor i := 1; i < len(intervals); i++ {\n\tif intervals[i][0] > cur[1] {\n\t\tresult = append(result, cur)\n\t\tcur = intervals[i]\n\t} else {\n\t\tcur[1] = int(math.Max(float64(cur[1]), float64(intervals[i][1])))\n\t}\n}\nresult = append(result, cur)\nreturn result", "gen": "if len(nums) == 1 {\n\treturn nums\n}\nreturn sort.Slice(nums, func(i, j int) bool {\n\treturn nums[i] < nums[j]\n})\n}"}
{"tgt": "return Frame{}, false", "gen": "return &ListNode{\n\tVal: 0,\n\tNext: nil,\n}\nreturn b\n}"}
{"tgt": "dist := [200][][]int{}\nfor r := 0; r < R; r++ {\n\tfor c := 0; c < C; c++ {\n\t\td := abs(r-r0) + abs(c-c0)\n\t\tdist[d] = append(dist[d], []int{r, c})\n\t}\n}\nbegin, end := 0, 0\nfor d := 0; len(dist[d]) > 0; d++ {\n\tbegin, end = end, end+len(dist[d])\n\tcopy(res[begin:end], dist[d])\n}\nreturn res[:end]", "gen": "var res [][]int\nfor i := 0; i < 600; i++ {\n\tfor j := 0; j < 600; j++ {\n\t\tif abs(i-j) < abs(x-j) && abs(i-j) < abs(x-y) {\n\t\t\tres = append(res, []int{i, j})\n\t\t}\n\t}\n}\nfor i := 0; i < len(res); i++ {\n\tfor j := 0; j < len(res); j++ {\n\t\tif res[i][0] == res[j][0] && res[i][1] == res[j][1] {\n\t\t\tres = append(res[:j], res[j+1:]...)\n\t\t\tj--\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "n, err := io.Copy(h, r)\nif err != nil {\n\treturn err\n}\nif n != fSize {\n\treturn errReadSizeMismatch\n}\nreturn nil", "gen": "if _, err := io.Copy(w, r); err != nil {\n\treturn err\n}\nif fSize != r.Size() {\n\treturn errReadSizeMismatch\n}\nreturn nil\n}"}
{"tgt": "if max.Sign() <= 0 {\n\tpanic(\"STR\")\n}\nn = new(big.Int)\nn.Sub(max, n.SetUint64(1))\nbitLen := n.BitLen()\nif bitLen == 0 {\n\treturn\n}\nk := (bitLen + 7) / 8\nb := uint(bitLen % 8)\nif b == 0 {\n\tb = 8\n}\nbytes := make([]byte, k)\nfor {\n\t_, err = io.ReadFull(rand, bytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbytes[0] &= uint8(int(1<<b) - 1)\n\tn.SetBytes(bytes)\n\tif n.Cmp(max) < 0 {\n\t\treturn\n\t}\n}", "gen": "if n.Sign() < 0 {\n\tpanic(\"STRCONV\")\n}\nvar (\n\tbuf = make([]byte, 8)\n\tn1  = new(big.Int).SetUint64(1)\n\tn2  = new(big.Int).Sub(n, n1)\n\tlen = n2.BitLen()\n\tb   = len / 8\n\tr   = len % 8\n)\nif r != 0 {\n\tb++\n}\n_, err := io.ReadFull(r, buf[:b])\nif err != nil {\n\treturn\n}\nn2.SetBytes(buf)\nif n2.Cmp(n) != 0 {\n\tn = n2\n}\nreturn\n}"}
{"tgt": "s := \"STR\"\nfmt.Println(reverseString(s))", "gen": "fmt.Println(reverseString(\"STR\"))\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tnums: []int{1, 2, 3, 1},\n\t\tk:    3,\n\t\twant: true,\n\t},\n\t{\n\t\tnums: []int{1, 0, 1, 1},\n\t\tk:    1,\n\t\twant: true,\n\t},\n\t{\n\t\tnums: []int{1, 2, 3, 1, 2, 3},\n\t\tk:    2,\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := containsNearbyDuplicate(tt.nums, tt.k)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.nums, tt.k, got, tt.want)\n\t}\n}", "gen": "tests := []struct {\n\tnums   []int\n\tk      int\n\texpect bool\n}{\n\t{[]int{1, 2, 3, 1}, 3, true},\n\t{[]int{1, 0, 1, 1}, 1, true},\n\t{[]int{1, 2, 3, 1, 2, 3}, 2, false},\n}\nfor _, tt := range tests {\n\tif actual := containsNearbyDuplicate(tt.nums, tt.k); actual != tt.expect {\n\t\tt.Fatalf(\"STR\", tt.nums, tt.k, tt.expect, actual)\n\t}\n}\n}"}
{"tgt": "for V > 0 {\n\tV--\n\tif !isDroppedLeft(heights, K) && !isDroppedRight(heights, K) {\n\t\theights[K]++\n\t}\n}\nreturn heights", "gen": "for i := len(heights) - 1; i >= 0; i-- {\n\tif isDroppedLeft(heights, i) {\n\t\tif isDroppedRight(heights, i) {\n\t\t\theights[i]++\n\t\t}\n\t}\n}\nreturn heights\n}"}
{"tgt": "qs := []question231{\n\t{\n\t\tpara231{1},\n\t\tans231{true},\n\t},\n\t{\n\t\tpara231{16},\n\t\tans231{true},\n\t},\n\t{\n\t\tpara231{218},\n\t\tans231{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans231, q.para231\n\tfmt.Printf(\"STR\", p, isPowerOfTwo(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question231{\n\t{\n\t\tpara231{1},\n\t\tans231{true, 1},\n\t},\n\t{\n\t\tpara231{16},\n\t\tans231{true, 16},\n\t},\n\t{\n\t\tpara231{218},\n\t\tans231{false, 0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans231, q.para231\n\tfmt.Printf(\"STR\", p, isPowerOfTwo(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "m := map[string]struct{}{}\nfor _, email := range emails {\n\tn := len(email)\n\tbs := strings.Builder{}\n\tignore := false\n\tfor i := 0; i < n; i++ {\n\t\tif email[i] == '@' {\n\t\t\tbs.WriteString(email[i:])\n\t\t\tbreak\n\t\t}\n\t\tif ignore || email[i] == '.' {\n\t\t\tcontinue\n\t\t}\n\t\tif email[i] == '+' {\n\t\t\tignore = true\n\t\t\tcontinue\n\t\t}\n\t\tbs.WriteByte(email[i])\n\t}\n\tm[bs.String()] = struct{}{}\n}\nreturn len(m)", "gen": "m := make(map[string]struct{})\nfor _, s := range strs {\n\tm[s] = struct{}{}\n}\nfor _, s := range strs {\n\tvar sb strings.Builder\n\tfor i, c := range s {\n\t\tif c == 'I' {\n\t\t\tif sb.Len() == 0 {\n\t\t\t\tsb.WriteString(\"I\")\n\t\t\t} else {\n\t\t\t\tsb.WriteByte('I')\n\t\t\t}\n\t\t} else if c == 'V' {\n\t\t\tif sb.Len() == 0 {\n\t\t\t\tsb.WriteString(\"V\")\n\t\t\t} else {\n\t\t\t\tsb.WriteByte('V')\n\t\t\t}\n\t\t} else if c == 'X' {\n\t\t\tif sb.Len() == 0 {\n\t\t\t\tsb.WriteString(\"X\")\n\t\t\t} else {\n\t\t\t\tsb.WriteByte('X')\n\t\t\t}\n\t\t} else if c == 'L' {\n\t\t\tif sb.Len() == 0 {\n\t\t\t\tsb.WriteString(\"L\")\n\t\t\t} else {\n\t\t\t\tsb.WriteByte('L')\n\t\t\t}\n\t\t} else if c == 'C' {\n\t\t\tif sb.Len() == 0 {\n\t\t\t\tsb.WriteString(\"C\")\n\t\t\t} else {\n\t\t\t\tsb.WriteByte('C')\n\t\t\t}\n\t\t} else if c == 'D' {\n\t\t\tif sb.Len() == 0 {\n\t\t\t\tsb.WriteString(\"D\")\n\t\t\t} else {\n\t\t\t\tsb.WriteByte('D')\n\t\t\t}\n\t\t} else if c == 'M' {\n\t\t\tif sb.Len() == 0 {\n\t\t\t\tsb"}
{"tgt": "cases := []struct {\n\tname   string\n\tinput1 string\n\tinput2 string\n\texpect bool\n}{\n\t{\"STR\", \"STR\", \"STR\", false},\n\t{\"STR\", \"STR\", \"STR\", false},\n\t{\"STR\", \"STR\", \"STR\", true},\n\t{\"STR\", \"STR\", \"STR\", true},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := canConstruct2(c.input1, c.input2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.input1, c.input2)\n\t\t}\n\t})\n}", "gen": "var tests = []struct {\n\tname         string\n\tinput1, input2 string\n\texpect       bool\n}{\n\t{\"STR1STR2\", \"STR1STR2\", \"STR1STR2\", true},\n\t{\"STR1STR2STR1\", \"STR1STR2STR1\", \"STR1STR2STR1\", true},\n\t{\"STR1STR2STR1STR2\", \"STR1STR2STR1\", \"STR1STR2STR1\", false},\n}\nfor _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tgot := isInterleave(tt.input1, tt.input2, tt.input1)\n\t\tif got != tt.expect {\n\t\t\tt.Errorf(\"STR\", tt.input1, tt.input2, tt.input1, tt.expect, got)\n\t\t}\n\t})\n}\n}"}
{"tgt": "for {\n\tswitch r := l.next(); {\n\tcase unicode.IsNumber(r):\n\tcase r == \"STR\":\n\t\tl.backup()\n\t\tl.emit(itemEnd)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase r == eof:\n\t\tl.emit(itemEnd)\n\t\treturn byteRangeSet\n\tdefault:\n\t\treturn l.error(\"STR\")\n\t}\n}", "gen": "for {\n\tswitch l.next() {\n\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\tl.backup()\n\t\tl.emit(byteRangeSet)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase ',':\n\t\tl.emit(byteRangeSet)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tdefault:\n\t\tl.error(fmt.Sprintf(\"unexpected character %q\", l.peek()))\n\t\treturn byteRangeSet\n\t}\n}\n}"}
{"tgt": "var res byte\nfor i := 0; i < len(s); i++ {\n\tres ^= s[i]\n}\nfor i := 0; i < len(t); i++ {\n\tres ^= t[i]\n}\nreturn res", "gen": "var res bool\nfor i := 0; i < len(s1); i++ {\n\tres = res ^ (s1[i] == s2[i])\n}\nfor i := 0; i < len(s2); i++ {\n\tres = res ^ (s1[i] == s2[i])\n}\nreturn res\n}"}
{"tgt": "var s int\nfor _, c := range m.cache {\n\ts += c.Expire()\n}\nreturn s", "gen": "var sum int\nfor _, e := range c.l.entries {\n\tc.Expire(e)\n\tsum += e.value\n}\nreturn sum\n}"}
{"tgt": "if len(num) <= 1 {\n\treturn\n}\nfor i := len(num) - 1; i > 0; i-- {\n\tif num[i-1] < num[i] {\n\t\tj := len(num) - 1\n\t\tfor num[i-1] >= num[j] {\n\t\t\tj--\n\t\t}\n\t\tnum[j], num[i-1] = num[i-1], num[j]\n\t\treverse(num[i:])\n\t\tfmt.Println(num)\n\t\treturn\n\t}\n\tif i == 1 {\n\t\treturn\n\t}\n}", "gen": "if len(nums) < 2 {\n\treturn\n}\nfor i := len(nums) - 2; i >= 0; i-- {\n\tif nums[i] > nums[i+1] {\n\t\treverse(nums, i, len(nums)-1)\n\t\tfmt.Println(nums)\n\t\treturn\n\t}\n}\n}"}
{"tgt": "words := map[string]struct{}{}\ncap, vowel := map[string]string{}, map[string]string{}\nfor _, word := range wordlist {\n\twords[word] = struct{}{}\n\tlower := strings.ToLower(word)\n\tif _, ok := cap[lower]; !ok {\n\t\tcap[lower] = word\n\t\tif _, ok = vowel[todev(lower)]; !ok {\n\t\t\tvowel[todev(lower)] = word\n\t\t}\n\t}\n}\nfor i, query := range queries {\n\tif _, ok := words[query]; ok {\n\t\tcontinue\n\t}\n\tlower := strings.ToLower(query)\n\tif word, ok := cap[lower]; ok {\n\t\tqueries[i] = word\n\t} else if word, ok = vowel[todev(lower)]; ok {\n\t\tqueries[i] = word\n\t} else {\n\t\tqueries[i] = \"STR\"\n\t}\n}\nreturn queries", "gen": "m := map[string]struct{}{}\nfor _, s := range A {\n\tm[strings.ToLower(s)] = struct{}{}\n}\nm2 := map[string]string{}\nfor _, s := range B {\n\tm2[strings.ToLower(s)] = s\n}\nfor _, s := range C {\n\tif _, ok := m[strings.ToLower(s)]; !ok {\n\t\tcontinue\n\t}\n\tif _, ok := m2[strings.ToLower(s)]; ok {\n\t\tcontinue\n\t}\n\tm2[strings.ToLower(s)] = s\n}\nreturn m2\n}"}
{"tgt": "return c.name", "gen": "return t.data, t.size\n}"}
{"tgt": "qs := []question984{\n\t{\n\t\tpara984{1, 2},\n\t\tans984{\"STR\"},\n\t},\n\t{\n\t\tpara984{4, 1},\n\t\tans984{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans984, q.para984\n\tfmt.Printf(\"STR\", p, strWithout3a3b(p.a, p.b))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question984{\n\t{\n\t\tpara984{\"STR\", \"STR\"},\n\t\tans984{\"STR\", false},\n\t},\n\t{\n\t\tpara984{\"STR\", \"STRSTR\"},\n\t\tans984{\"STR\", true},\n\t},\n\t{\n\t\tpara984{\"STR\", \"STRSTRSTR\"},\n\t\tans984{\"STR\", true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans984, q.para984\n\tfmt.Printf(\"STRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTR"}
{"tgt": "var sum int\nfor i := start; i < end; i++ {\n\tsum += l[i]\n}\nreturn sum", "gen": "sum := 0\nfor i := 0; i < len(nums); i++ {\n\tsum += nums[i]\n}\nreturn sum\n}"}
{"tgt": "arr := make([]bool, 1000000)\narr[1] = true\nprime := 3\ncount := 13\nvar k, tmp, localCount int\nvar str string\nfor {\n\tfor k = prime * 2; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tstr = strconv.Itoa(prime)\n\t\tif prime > 100 {\n\t\t\tlocalCount = 1\n\t\t\tfor i := 0; i < len(str)-1; i++ {\n\t\t\t\tstr = str[1:] + str[0:1]\n\t\t\t\ttmp, _ = strconv.Atoi(str)\n\t\t\t\tif tmp > prime {\n\t\t\t\t\tcontinueprimeloop\n\t\t\t\t} else if !arr[tmp] && tmp%2 != 0 {\n\t\t\t\t\tlocalCount++\n\t\t\t\t} else {\n\t\t\t\t\tcontinueprimeloop\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount += localCount\n\t\t}\n\t} else {\n\t\tbreak\n\t}\n}\nprintln(count)", "gen": "var res = make([]bool, 1000000)\nres[0] = true\nvar i, j int\nfor i = 1; i < 1000000; i++ {\n\tfor j = i + 1; j < 1000000; j++ {\n\t\tif res[j] {\n\t\t\tcontinue\n\t\t}\n\t\tres[j] = true\n\t\tif i%2 == 0 {\n\t\t\tvar sum int\n\t\t\tfor k := 0; k < 1000000; k++ {\n\t\t\t\tif res[k] {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tsum += k\n\t\t\t}\n\t\t\tif sum == i {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\nfor i = 0; i < 1000000; i++ {\n\tif res[i] {\n\t\tcontinue\n\t}\n\tvar sum int\n\tfor j := 0; j < 1000000; j++ {\n\t\tif res[j] {\n\t\t\tcontinue\n\t\t}\n\t\tsum += j\n\t}\n\tif sum == i {\n\t\tbreak\n\t}\n}\nprintln(i)\n}"}
{"tgt": "count := make(map[string]int, len(words))\nfor _, w := range words {\n\tcount[w]++\n}\nfw := make(freWords, 0, len(count))\nfor w, c := range count {\n\tfw = append(fw, &entry{\n\t\tword:      w,\n\t\tfrequence: c,\n\t})\n}\nsort.Sort(fw)\nres := make([]string, k)\nfor i := 0; i < k; i++ {\n\tres[i] = fw[i].word\n}\nreturn res", "gen": "m := make(map[string]int)\nfor _, word := range words {\n\tm[word]++\n}\nvar res []entry\nfor k, v := range m {\n\tres = append(res, entry{k, v})\n}\nsort.Sort(freWords(res))\nans := make([]string, len(words))\nfor i, e := range res {\n\tans[e.freq] = e.word\n\te.freq++\n}\nreturn ans\n}"}
{"tgt": "str1 := \"STR\"\nfmt.Println(largeGroupPositions(str1))\nstr2 := \"STR\"\nfmt.Println(largeGroupPositions(str2))\nstr3 := \"STR\"\nfmt.Println(largeGroupPositions(str3))\nstr4 := \"STR\"\nfmt.Println(largeGroupPositions(str4))", "gen": "fmt.Println(largeGroupPositions(\"ABA\", 3))\nfmt.Println(largeGroupPositions(\"ABAA\", 3))\nfmt.Println(largeGroupPositions(\"ABAB\", 3))\nfmt.Println(largeGroupPositions(\"ABABA\", 3))\nfmt.Println(largeGroupPositions(\"ABABAB\", 3))\nfmt.Println(largeGroupPositions(\"ABABABA\", 3))\nfmt.Println(largeGroupPositions(\"ABABABAB\", 3))\nfmt.Println(largeGroupPositions(\"ABABABABA\", 3))\nfmt.Println(largeGroupPositions(\"ABABABABAB\", 3))\nfmt.Println(largeGroupPositions(\"ABABABABABA\", 3))\nfmt.Println(largeGroupPositions(\"ABABABABABAB\", 3))\nfmt.Println(largeGroupPositions(\"ABABABABABABA\", 3))\nfmt.Println(largeGroupPositions(\"ABABABABABABAB\", 3))\nfmt.Println(largeGroupPositions(\"ABABABABABABABA\", 3))\nfmt.Println(largeGroupPositions(\"ABABABABABABABAB\", 3))\nfmt.Println(largeGroupPositions(\"ABABABABABABABABA\", 3))\nfmt.Println(largeGroupPositions(\"ABABABABABABABABAB\", 3))\nfmt.Println(largeGroupPositions(\"ABABABABABABABABABA\", 3))\nfmt.Println(largeGroupPositions(\"ABABABABABABABABABAB\", 3))\nfmt.Println(largeGroupPositions(\"ABABABABABABABABABABA\", 3))\nfmt.Println(largeGroupPositions(\"ABABABABABABABABABABAB\", 3))\nfmt.Println(largeGroupPositions(\"ABABABABABABABABABABABA\", 3))\nfmt.Print"}
{"tgt": "list := NewCyclic()\nfillList(list, 3)\nwant := 1\ngot := list.Walk()\nif got.Val != want {\n\tt.Errorf(\"STR\", got)\n}", "gen": "ll := NewCyclic()\nfillList(ll, 3)\nif ll.Walk(1) != 1 {\n\tt.Errorf(\"STR\", ll.Walk(1))\n}\n}"}
{"tgt": "m := make(map[int]struct{})\nfor _, num := range nums1 {\n\tm[num] = struct{}{}\n}\nnums := make([]int, 0)\nfor _, num := range nums2 {\n\tif _, ok := m[num]; ok {\n\t\tnums = append(nums, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn nums", "gen": "m := make(map[int]struct{})\nfor _, num := range nums {\n\tm[num] = struct{}{}\n}\nres := make([]int, 0)\nfor _, num := range nums {\n\tif _, ok := m[num]; !ok {\n\t\tres = append(res, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn res\n}"}
{"tgt": "factorial := new(big.Int).MulRange(1, 100)\nbytes := factorial.Append([]byte{}, 10)\nsum := 0\nfor b := range bytes {\n\tsum += int(bytes[b] - '0')\n}\nfmt.Println(\"STR\", sum)", "gen": "n := big.NewInt()\nn.MulRange(100, 999)\nvar s string\nfor _, c := range n.Append(nil, 10) {\n\ts += string(c)\n}\nfmt.Println(s)\n}"}
{"tgt": "qs := []question1003{\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{true},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{true},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{false},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1003, q.para1003\n\tfmt.Printf(\"STR\", p, isValid1003(p.s))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1003{\n\t{\n\t\tpara1003{\"STR\", true},\n\t\tans1003{true},\n\t},\n\t{\n\t\tpara1003{\"STRSTR\", false},\n\t\tans1003{false},\n\t},\n\t{\n\t\tpara1003{\"STRSTRSTR\", false},\n\t\tans1003{false},\n\t},\n}\nfmt.Printf(\"STRSTRSTR\")\nfor _, q := range qs {\n\t_, p := q.ans1003, q.para1003\n\tfmt.Printf(\"STRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTR"}
{"tgt": "var v *error\nreturn v", "gen": "var err error\nreturn err\n}"}
{"tgt": "m := map[string]int{}\nrets := []string{}\nfor i := 0; i <= len(s)-10; i++ {\n\tsub := string(s[i : i+10])\n\tm[sub]++\n\tif m[sub] == 2 {\n\t\trets = append(rets, sub)\n\t}\n}\nreturn rets", "gen": "m := make(map[string]int)\nvar res []string\nfor i := 0; i < len(s); i += 10 {\n\tif m[s[i:i+10]] == 2 {\n\t\tcontinue\n\t}\n\tm[s[i:i+10]]++\n\tif m[s[i:i+10]] == 2 {\n\t\tres = append(res, s[i:i+10])\n\t}\n}\nreturn res\n}"}
{"tgt": "q[i], q[j] = q[j], q[i]", "gen": "this.data[i] = this.data[j]\nthis.data[j] = v\n}"}
{"tgt": "runes := []rune(s)\nlength := len(runes)\nif length <= 1 {\n\treturn s\n}\nmaxRune := runes[0:1]\nfor i := 0; i < length-1; i++ {\n\ttmpRune := findPalindrome(runes, i, i)\n\tif len(tmpRune) > len(maxRune) {\n\t\tmaxRune = tmpRune\n\t}\n\tif runes[i] == runes[i+1] {\n\t\ttmpRune = findPalindrome(runes, i, i+1)\n\t\tif len(tmpRune) > len(maxRune) {\n\t\t\tmaxRune = tmpRune\n\t\t}\n\t}\n}\nreturn string(maxRune)", "gen": "s := []rune(str)\nif len(s) == 1 {\n\treturn str\n}\nfor i := 0; i < len(s); i++ {\n\tif i < len(s)-1 && s[i] == s[i+1] {\n\t\ti++\n\t\tcontinue\n\t}\n\tif i > 0 && s[i] == s[i-1] {\n\t\ti++\n\t\tcontinue\n\t}\n\tif len(s)-i < i {\n\t\treturn string(s[:i])\n\t}\n\tif len(s)-i > i {\n\t\treturn string(s[:i])\n\t}\n}\nreturn \"\"\n}"}
{"tgt": "stack, j, N := []int{}, 0, len(pushed)\nfor _, x := range pushed {\n\tstack = append(stack, x)\n\tfmt.Printf(\"STR\", stack, j)\n\tfor len(stack) != 0 && j < N && stack[len(stack)-1] == popped[j] {\n\t\tstack = stack[0 : len(stack)-1]\n\t\tj++\n\t}\n\tfmt.Printf(\"STR\", stack, j)\n}\nreturn j == N", "gen": "var res [][]int\nfor _, num := range nums {\n\tif len(res) == 0 || res[len(res)-1][len(res[len(res)-1])-1] == num {\n\t\tres = append(res, []int{num})\n\t} else {\n\t\tres[len(res)-1] = append(res[len(res)-1], num)\n\t}\n}\nfmt.Printf(\"STR\", res)\nfor i := 0; i < len(res); i++ {\n\tif i == len(res)-1 {\n\t\tfmt.Printf(\"STR\", res[i])\n\t} else {\n\t\tfmt.Printf(\"STR\", res[i])\n\t}\n}\nreturn len(res) == len(nums)\n}"}
{"tgt": "return numDistinctBytes([]byte(s), []byte(t))", "gen": "return numDistinctBytes([]byte(s), []byte(t))\n}"}
{"tgt": "return key1.(int) < key2.(int)", "gen": "return a == b\n}"}
{"tgt": "return x != y", "gen": "return a == b\n}"}
{"tgt": "for prime := range sig(a) {\n\tif sig(b)[prime] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "for _, v := range sig {\n\tif v == 0 {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "var low, mid, high int = 0, len(sorted) / 2, len(sorted)\nfor low < high {\n\tcurr := sorted[mid]\n\tswitch {\n\tcase curr == target:\n\t\treturn mid\n\tcase inRange(sorted[mid:high], target):\n\t\tlow = mid\n\t\tmid = (low + high) / 2\n\tdefault:\n\t\thigh = mid\n\t\tmid = (low + high) / 2\n\t}\n}\nreturn -1", "gen": "left, right := 0, len(nums)-1\nfor left < right {\n\tmid := (left + right) / 2\n\tif nums[mid] == target {\n\t\treturn mid\n\t} else if nums[mid] < target {\n\t\tleft = mid + 1\n\t} else {\n\t\tright = mid - 1\n\t}\n}\nreturn -1\n}"}
{"tgt": "if n < sumOfProperDivisors(n) {\n\treturn true\n}\nreturn false", "gen": "if sumOfProperDivisors(n) < n {\n\treturn true\n}\nreturn false\n}"}
{"tgt": "ss := []string{S}\nfor i := 0; i < len(S); i++ {\n\tif S[i] < '0' || S[i] > '9' {\n\t\tfor _, s := range ss {\n\t\t\tb := []byte(s)\n\t\t\tletterCase(b, i)\n\t\t\tss = append(ss, string(b))\n\t\t}\n\t}\n}\nreturn ss", "gen": "res := []string{}\nfor i := 0; i < len(s); i++ {\n\tif s[i] >= 'A' && s[i] <= 'Z' {\n\t\tres = append(res, letterCase(s[:i], true))\n\t} else if s[i] >= 'a' && s[i] <= 'z' {\n\t\tres = append(res, letterCase(s[:i], false))\n\t}\n}\nreturn res\n}"}
{"tgt": "digits := convert(N + 1)\nbits := len(digits)\nnoRepeat := 0\nfor b := 1; b < bits; b++ {\n\tnoRepeat += 9 * count(9, b-1)\n}\nhasSeen := make(map[int]bool, 10)\nfor b := 0; b < bits; b++ {\n\td := 0\n\tif b == 0 {\n\t\td = 1\n\t}\n\tfor ; d < digits[b]; d++ {\n\t\tif !hasSeen[d] {\n\t\t\tnoRepeat += count(9-b, bits-b-1)\n\t\t}\n\t}\n\tif hasSeen[digits[b]] {\n\t\tbreak\n\t}\n\thasSeen[digits[b]] = true\n}\nreturn N - noRepeat", "gen": "res := convert(1 + n)\ncount := 0\nfor i := 1; i <= n; i++ {\n\tcount += count(i, 9)\n\tfor j := 1; j < i; j++ {\n\t\tif res[i] != res[j] {\n\t\t\tcount += count(i-j, 9)\n\t\t}\n\t}\n}\nm := make(map[int]bool)\nfor i := 0; i < n; i++ {\n\tif m[res[i]] {\n\t\tcontinue\n\t}\n\tm[res[i]] = true\n\tfor j := 1; j < i; j++ {\n\t\tif res[i] != res[j] {\n\t\t\tcount += count(i-j, 9)\n\t\t}\n\t}\n}\nreturn n - count\n}"}
{"tgt": "b := NewLRUCache(1000)\nfor i := 0; i < 1000; i++ {\n\tb.Set(randomString(2), \"STR\", expire)\n}\nreturn b", "gen": "cache := NewLRUCache(1000)\nfor i := 0; i < 1000; i++ {\n\tcache.Set(i, randomString(2))\n}\nreturn cache\n}"}
{"tgt": "h := &IntMaxHeap{}\nheap.Init(h)\nheap.Push(h, 7)\nheap.Push(h, 3)\nheap.Push(h, 2)\nheap.Push(h, 1)\nheap.Push(h, 5)\nheap.Push(h, 5)\nheap.Push(h, 6)\nheap.Push(h, 7)\nfmt.Printf(\"STR\", (*h))\nfor h.Len() > 0 {\n\tfmt.Printf(\"STR\", heap.Pop(h))\n}", "gen": "h := &IntMaxHeap{}\nh.Init(h)\nh.Push(h, 1)\nh.Push(h, 2)\nh.Push(h, 3)\nh.Push(h, 4)\nh.Push(h, 5)\nh.Push(h, 6)\nh.Push(h, 7)\nh.Push(h, 8)\nh.Push(h, 9)\nh.Push(h, 10)\nh.Push(h, 11)\nh.Push(h, 12)\nh.Push(h, 13)\nh.Push(h, 14)\nh.Push(h, 15)\nh.Push(h, 16)\nh.Push(h, 17)\nh.Push(h, 18)\nh.Push(h, 19)\nh.Push(h, 20)\nh.Push(h, 21)\nh.Push(h, 22)\nh.Push(h, 23)\nh.Push(h, 24)\nh.Push(h, 25)\nh.Push(h, 26)\nh.Push(h, 27)\nh.Push(h, 28)\nh.Push(h, 29)\nh.Push(h, 30)\nh.Push(h, 31)\nh.Push(h, 32)\nh.Push(h, 33)\nh.Push(h, 34)\nh.Push(h, 35)\nh.Push(h, 36)\nh.Push(h, 37)\nh.Push(h, 38)\nh.Push(h, 39)\nh.Push(h, 40)\nh.Push(h, 41)"}
{"tgt": "return MyCalendar{\n\tbooks: make([]seg, 0),\n}", "gen": "return Solution{\n\tseg: make([]*SegNode, 0),\n}\n}"}
{"tgt": "var buf bytes.Buffer\nbuf.WriteByte(\"STR\")\nfor i, word := range s.words {\n\tif word == 0 {\n\t\tcontinue\n\t}\n\tfor j := 0; j < 64; j++ {\n\t\tif word&(1<<uint(j)) != 0 {\n\t\t\tif buf.Len() > len(\"STR\") {\n\t\t\t\tbuf.WriteByte(\"STR\")\n\t\t\t}\n\t\t\tfmt.Fprintf(&buf, \"STR\", 64*i+j)\n\t\t}\n\t}\n}\nbuf.WriteByte(\"STR\")\nreturn buf.String()", "gen": "var buf bytes.Buffer\nbuf.WriteByte('{')\nfor i, b := range s {\n\tif b != 0 {\n\t\tbuf.WriteByte('\"')\n\t\tbuf.WriteString(strconv.FormatInt(int64(i), 64))\n\t\tbuf.WriteByte('\"')\n\t\tbuf.WriteByte(':')\n\t\tbuf.WriteByte('\"')\n\t\tbuf.WriteString(string(b))\n\t\tbuf.WriteByte('\"')\n\t}\n}\nbuf.WriteByte('}')\nreturn buf.String()\n}"}
{"tgt": "matrix := [][]int{\n\t{5, 1, 9, 11},\n\t{2, 4, 8, 10},\n\t{13, 3, 6, 7},\n\t{15, 14, 12, 16},\n}\nmatrix = rotate(matrix)\nfor _, nums := range matrix {\n\tfor _, num := range nums {\n\t\tfmt.Print(num, \"STR\")\n\t}\n\tfmt.Println()\n}", "gen": "var nums = []int{5, 1, 9, 11, 2, 4, 8, 10, 13, 3, 6, 7, 15, 14, 12, 16}\nrotate(nums, 4)\nfor i := 0; i < len(nums); i++ {\n\tfmt.Println(nums[i])\n}\nfmt.Println()\nfor i := 0; i < len(nums); i++ {\n\tfmt.Println(nums[i])\n}\n}"}
{"tgt": "return MyQueue{\n\tlist: list.New(),\n}", "gen": "return list.New()\n}"}
{"tgt": "res := sizeOfLargestBST(tree)\nreturn res.AnsPtr", "gen": "return sizeOfLargestBST(root)\n}"}
{"tgt": "sort.Ints(candidates)\nvar res [][]int\ndfs(candidates, nil, target, 0, &res)\nreturn res", "gen": "sort.Ints(nums)\ndfs(nums, 0, 0, 0, &res)\nreturn res\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := checkRecord(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "qs := []question551{\n\t{\n\t\tpara1: \"STR\",\n\t\tpara2: \"STR\",\n\t\tans:   true,\n\t},\n\t{\n\t\tpara1: \"STR\",\n\t\tpara2: \"STR\",\n\t\tans:   true,\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans, q.para1+q.para2\n\tfmt.Printf(\"STR\", p, q.ans)\n\tif ret := checkRecord(p); ret != q.ans {\n\t\tt.Fatalf(\"STR\", p, q.ans, ret)\n\t}\n}\n}"}
{"tgt": "for i := 1; i < len(arr); i++ {\n\tvalue := arr[i]\n\tj := i - 1\n\tfor j >= 0 && arr[j] > value {\n\t\tarr[j+1] = arr[j]\n\t\tj = j - 1\n\t}\n\tarr[j+1] = value\n}", "gen": "var i int\nfor i = 1; i < len(nums); i++ {\n\tfor j := i - 1; j >= 0; j-- {\n\t\tif nums[j] < nums[i] {\n\t\t\tnums[j], nums[i] = nums[i], nums[j]\n\t\t\ti--\n\t\t}\n\t}\n}\n}"}
{"tgt": "var nums []int\nvar ret bool\nnums = []int{1, 2, 3, 1}\nret = true\nif ret != containsDuplicate(nums) {\n\tt.Fatalf(\"STR\", ret)\n}\nnums = []int{1, 2, 3, 4}\nret = false\nif ret != containsDuplicate(nums) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "cases := []struct {\n\tinput  []int\n\toutput bool\n}{\n\t{[]int{1, 2, 3, 4}, false},\n\t{[]int{1, 1, 1, 3, 3, 4, 3, 2, 4, 2}, true},\n\t{[]int{1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6}, false},\n}\nfor _, c := range cases {\n\tif containsDuplicate(c.input) != c.output {\n\t\tt.Fatalf(\"STR\", c.input, c.output)\n\t}\n}\nfor _, c := range cases {\n\tif containsDuplicate(c.input) != c.output {\n\t\tt.Fatalf(\"STR\", c.input, c.output)\n\t}\n}\n}"}
{"tgt": "switch {\ncase head.Left == nil && head.Right == nil:\n\treturn head.Value\ncase head.Left != nil && head.Right != nil:\n\tleft := head.Value + MinPathSum(head.Left)\n\tright := head.Value + MinPathSum(head.Right)\n\treturn min(left, right)\ncase head.Left != nil:\n\treturn head.Value + MinPathSum(head.Left)\ndefault:\n\treturn head.Value + MinPathSum(head.Right)\n}", "gen": "if root == nil {\n\treturn 0\n}\nif root.Left == nil {\n\treturn root.Val + MinPathSum(root.Right)\n}\nif root.Right == nil {\n\treturn root.Val + MinPathSum(root.Left)\n}\nreturn min(MinPathSum(root.Left), MinPathSum(root.Right)) + root.Val\n}"}
{"tgt": "sets := make([][]int, 1, 1<<uint(len(nums)))\nfor _, num := range nums {\n\tfor _, set := range sets {\n\t\ts := make([]int, len(set), len(set)+1)\n\t\tcopy(s, set)\n\t\tsets = append(sets, append(s, num))\n\t}\n}\nreturn sets", "gen": "var res [][]int\nfor _, num := range nums {\n\tvar tmp []int\n\tfor _, n := range res {\n\t\ttmp = append(tmp, append(n, num))\n\t}\n\tres = append(res, tmp...)\n}\nreturn res\n}"}
{"tgt": "out := 100\nif x := p33(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "if p33(100) != 100 {\n\tt.Errorf(\"STR\", 100, 100)\n}\n}"}
{"tgt": "steps := countSteps([]int{0, 0}, target)\nfor _, g := range ghosts {\n\tif steps >= countSteps(g, target) {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "steps := countSteps([][]int{{0, 1}, {1, 2}})\nif steps != 2 {\n\treturn\n}\nsteps = countSteps([][]int{{0, 1}, {1, 2}, {2, 3}})\nif steps != 3 {\n\treturn\n}\nsteps = countSteps([][]int{{0, 1}, {1, 2}, {2, 3}, {3, 4}})\nif steps != 4 {\n\treturn\n}\nreturn true\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CourseOrder(tc.prereqs); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CourseOrder(tc.courses); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.courses, tc.expected, result)\n\t}\n}\n}"}
{"tgt": "if nil == root || k <= 0 {\n\treturn nil\n}\nvar target *BinaryTreeNode\nif root.left != nil {\n\ttarget = kthNode(root.left, k)\n}\nif target == nil {\n\tif 1 == k {\n\t\ttarget = root\n\t} else {\n\t\tk--\n\t}\n}\nif target == nil && root.right != nil {\n\ttarget = kthNode(root.right, k)\n}\nreturn target", "gen": "if root == nil || k <= 0 {\n\treturn nil\n}\nif k == 1 {\n\treturn root\n}\nif root.Left != nil {\n\treturn kthNode(root.Left, k-1)\n}\nif k > 1 {\n\treturn kthNode(root.Right, k-1)\n}\nreturn root\n}"}
{"tgt": "nums := []int{0, 0, 1, 2}\nfmt.Println(dominantIndex(nums))", "gen": "fmt.Println(dominantIndex([]int{0, 1, 2, 3, 4}))\n}"}
{"tgt": "if root == nil {\n\treturn nil\n}\nif root.Val < L {\n\treturn trimBST(root.Right, L, R)\n}\nif root.Val > R {\n\treturn trimBST(root.Left, L, R)\n}\nroot.Left = trimBST(root.Left, L, R)\nroot.Right = trimBST(root.Right, L, R)\nreturn root", "gen": "if root == nil {\n\treturn nil\n}\nif root.Val < low {\n\treturn trimBST(root.Right, low, high)\n}\nif root.Val > high {\n\treturn trimBST(root.Left, low, high)\n}\nroot.Left = trimBST(root.Left, low, high)\nroot.Right = trimBST(root.Right, low, high)\nreturn root\n}"}
{"tgt": "length := len(matrix)\nfor i := 0; 2*i < length-1; i++ {\n\tfor j := i; j < length-i-1; j++ {\n\t\tmatrix[i][j], matrix[j][length-i-1], matrix[length-i-1][length-j-1], matrix[length-j-1][i] =\n\t\t\tmatrix[length-j-1][i], matrix[i][j], matrix[j][length-i-1], matrix[length-i-1][length-j-1]\n\t}\n}", "gen": "for i := 0; i < len(matrix); i++ {\n\tfor j := 0; j < len(matrix[0]); j++ {\n\t\tif matrix[i][j] == target {\n\t\t\treturn true\n\t\t}\n\t}\n}\nreturn false\n}"}
{"tgt": "p = len(postorder) - 1\nidxMap = make(map[int]int)\nfor i, v := range inorder {\n\tidxMap[v] = i\n}\nreturn build(0, len(inorder)-1, postorder)", "gen": "idxMap = make(map[int]int)\nfor i := 0; i < len(preorder); i++ {\n\tidxMap[preorder[i]] = i\n}\nreturn build(preorder, 0, len(preorder)-1)\n}"}
{"tgt": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Print(sum, \"STR\")", "gen": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif i%3 == 0 || i%5 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "qs := []question856{\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{1},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{2},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{2},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{6},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{3},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{8},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans856, q.para856\n\tfmt.Printf(\"STR\", p, scoreOfParentheses(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question856{\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{1},\n\t},\n\t{\n\t\tpara856{\"STRSTR\"},\n\t\tans856{2},\n\t},\n\t{\n\t\tpara856{\"STRSTRSTR\"},\n\t\tans856{3},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans856, q.para856\n\tfmt.Printf(\"STRSTRSTR\")\n}\nfmt.Printf(\"STRSTRSTRSTR\")\n}"}
{"tgt": "const (\n\txmin, ymin, xmax, ymax = -2, -2, +2, +2\n\twidth, height          = 1024, 1024\n)\nimg := image.NewRGBA(image.Rect(0, 0, width, height))\nfor py := 0; py < height; py++ {\n\ty := float64(py)/height*(ymax-ymin) + ymin\n\tfor px := 0; px < width; px++ {\n\t\tx := float64(px)/width*(xmax-xmin) + xmin\n\t\tz := complex(x, y)\n\t\timg.Set(px, py, mandelbrot(z))\n\t}\n}\npng.Encode(os.Stdout, img)", "gen": "bounds := image.Rect(0, 0, 1024, 1024)\nimg := image.NewRGBA(bounds)\nfor y := 0; y < 1024; y++ {\n\tfor x := 0; x < 1024; x++ {\n\t\tz := complex(float64(x)/1024, float64(y)/1024)\n\t\timg.Set(x, y, mandelbrot(z))\n\t}\n}\npng.Encode(os.Stdout, img)\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif start, end := BusiestBuildingTimes(tc.moves); start != tc.start || end != tc.end {\n\t\tt.Errorf(\"STR\", tc.start, tc.end, start, end)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := BusiestBuildingTimes(tc.in); res != tc.out {\n\t\tt.Errorf(\"STR\", tc.in, tc.out, res)\n\t}\n}\n}"}
{"tgt": "n := len(cost)\ndp := make([]int, n+1)\nfor i := 2; i <= n; i++ {\n\tdp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])\n}\nreturn dp[n]", "gen": "n := len(A)\ndp := make([]int, n+1)\ndp[1] = A[0]\nfor i := 2; i <= n; i++ {\n\tdp[i] = min(dp[i-1]+A[i-1], dp[i-2]+A[i-1]+A[i-2])\n}\nreturn dp[n]\n}"}
{"tgt": "return new(runningSchTaskList).init(tasks)", "gen": "return new(runningSchTaskList).init(tasks...)\n}"}
{"tgt": "return area(A, B, C, D) + area(E, F, G, H) - area(max(A, E), max(B, F), min(C, G), min(D, H))", "gen": "return max(area(A[i], B[i], C[i]), area(A[i], B[i], D[i])) +\n\tmax(area(A[i], C[i], D[i]), area(A[i], D[i], C[i])) +\n\tarea(B[i], C[i], D[i]) - area(A[i], B[i], C[i])\n}"}
{"tgt": "r, err := http.Get(os.Args[1])\nif err != nil {\n\tfmt.Println(err)\n\treturn\n}\nio.Copy(os.Stdout, r.Body)\nif err := r.Body.Close(); err != nil {\n\tfmt.Println(err)\n}", "gen": "resp, err := http.Get(os.Args[1])\nif err != nil {\n\tfmt.Println(err)\n} else {\n\tdefer resp.Body.Close()\n\tio.Copy(os.Stdout, resp.Body)\n}\nfmt.Println(resp.Header.Get(\"Content-Type\"))\n}"}
{"tgt": "qs := []question1304{\n\t{\n\t\tpara1304{5},\n\t\tans1304{[]int{-7, -1, 1, 3, 4}},\n\t},\n\t{\n\t\tpara1304{0},\n\t\tans1304{[]int{}},\n\t},\n\t{\n\t\tpara1304{3},\n\t\tans1304{[]int{-1, 0, 1}},\n\t},\n\t{\n\t\tpara1304{1},\n\t\tans1304{[]int{0}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1304, q.para1304\n\tfmt.Printf(\"STR\", p, sumZero(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1304{\n\t{\n\t\tpara1304{[]int{1, 3, 4, 5}},\n\t\tans1304{[]int{1, 3, 4, 5}},\n\t},\n\t{\n\t\tpara1304{[]int{1, 3, 4, 5, 0}},\n\t\tans1304{[]int{1, 3, 4, 5, 0}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1304, q.para1304\n\tfmt.Printf(\"STR\", p, sumZero(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 2, 1}, []int{0, 4, 1, 3, 2}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1}, []int{0}, []int{1}},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums, c.index)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums, c.index)\n\t\t}\n\t})\n}", "gen": "var s = Solution{\n\tname: \"STR\",\n\tnums: []int{0, 1, 2, 3, 4},\n\tindex: []int{0, 1, 2, 2, 1},\n\texpect: []int{1, 2, 3, 4, 0},\n}\nfor i := 0; i < 5; i++ {\n\ttestStr := \"STR\" + strconv.Itoa(i)\n\tt.Run(testStr, func(t *testing.T) {\n\t\ts.c1(i)\n\t})\n}\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := isRobotBounded(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "cases := []struct {\n\tcommands []string\n\texpect   bool\n}{\n\t{[]string{\"G\", \"L\", \"G\"}, true},\n\t{[]string{\"GGGGGGGG\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\","}
{"tgt": "seen := make(map[string]struct{})\nfor _, tier := range al {\n\tfor _, v := range tier {\n\t\tif _, ok := seen[v]; !ok {\n\t\t\tseen[v] = struct{}{}\n\t\t\tret = append(ret, v)\n\t\t}\n\t}\n}\nreturn", "gen": "m := make(map[string]struct{})\nfor _, s := range strs {\n\tfor _, c := range s {\n\t\tm[string(c)] = struct{}{}\n\t}\n}\nvar res []string\nfor k := range m {\n\tres = append(res, k)\n}\nreturn res\n}"}
{"tgt": "return h.tasks[i].r < h.tasks[j].r", "gen": "return s[i][j] == s[k][l]\n}"}
{"tgt": "return xtime.Unix(int64(jt), 0)", "gen": "t := time.Unix(0, t.UnixNano())\nreturn Time{t}\n}"}
{"tgt": "return RandomizedSet{\n\tl: []int{},\n\tm: make(map[int]int),\n}", "gen": "return map[int]int{}\n}"}
{"tgt": "return TypeInt, nil", "gen": "return &ListNode{\n\tVal:  val,\n\tNext: nil,\n}\n}"}
{"tgt": "return createSkyline(buildings, 0, len(buildings)-1)", "gen": "createSkyline(heights)\nreturn skyline\n}"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil && max.Right != root {\n\t\t\tmax = max.Right\n\t\t}\n\t\tif max.Right == nil {\n\t\t\tmax.Right = root\n\t\t\troot = root.Left\n\t\t} else {\n\t\t\tres = append(res, root.Val)\n\t\t\troot = root.Right\n\t\t\tmax.Right = nil\n\t\t}\n\t}\n}\nreturn res", "gen": "var res []*TreeNode\ncur := root\nfor cur != nil {\n\tif cur.Left != nil {\n\t\tres = append(res, cur.Left)\n\t}\n\tif cur.Right != nil {\n\t\tres = append(res, cur.Right)\n\t}\n\tcur = cur.Next\n}\nfor cur != nil {\n\tcur.Left = nil\n\tcur.Right = res[0]\n\tres = res[1:]\n\tcur = cur.Next\n}\nreturn root\n}"}
{"tgt": "_, err := os.Open(\"STR\")\nif !os.IsNotExist(err) {\n\tpanic(\"STR\")\n}\nf, err := os.Open(\"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer func() {\n\tif err := f.Close(); err != nil {\n\t\tpanic(err)\n\t}\n\t_, err := f.Read(make([]byte, 10))\n\tif err == nil {\n\t\tpanic(\"STR\")\n\t}\n}()\ndata, err := ioutil.ReadAll(f)\nif err != nil {\n\tpanic(err)\n}\nprint(string(data))", "gen": "file, err := os.Open(\"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer file.Close()\ncontent, err := ioutil.ReadAll(file)\nif err != nil {\n\tpanic(err)\n}\nSTR = string(content)\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR\"\nSTR = STR + \"STR"}
{"tgt": "start, total, tank := 0, 0, 0\nfor i, g := range gas {\n\ttank += g - cost[i]\n\tif tank < 0 {\n\t\tstart = i + 1\n\t\ttotal += tank\n\t\ttank = 0\n\t}\n}\nif total+tank < 0 {\n\treturn -1\n}\nreturn start", "gen": "var sum, count int\nfor _, num := range nums {\n\tsum += num\n\tif sum < 0 {\n\t\tsum = 0\n\t\tcount++\n\t}\n}\nif sum < 0 {\n\treturn -1\n}\nreturn count\n}"}
{"tgt": "fmt.Println(btree.Data)", "gen": "fmt.Println(root)\n}"}
{"tgt": "n := len(num)\nres := []string{}\nvar dfs func(string, int, int, int)\ndfs = func(path string, index, result, pre int) {\n\tif index == n && result == target {\n\t\tres = append(res, path)\n\t\treturn\n\t}\n\tfor i := index; i < n; i++ {\n\t\tif num[index] == '0' && i != index {\n\t\t\treturn\n\t\t}\n\t\tcurrStr := num[index : i+1]\n\t\tcurr, _ := strconv.Atoi(currStr)\n\t\tif index == 0 {\n\t\t\tdfs(currStr, i+1, curr, curr)\n\t\t} else {\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result+curr, curr)\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result-curr, -curr)\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result-pre+pre*curr, pre*curr)\n\t\t}\n\t}\n}\ndfs(\"STR\", 0, 0, 0)\nreturn res", "gen": "var res []string\nvar dfs func(s string, start, end int, cur string)\ndfs = func(s string, start, end int, cur string) {\n\tif start == end {\n\t\tres = append(res, cur)\n\t\treturn\n\t}\n\tfor i := start; i < end; i++ {\n\t\tif s[start] == '0' && i != start {\n\t\t\tbreak\n\t\t}\n\t\tif s[start] == '0' && i == start {\n\t\t\tdfs(s, i+1, end, cur+\"0\")\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == '0' {\n\t\t\tcontinue\n\t\t}\n\t\tdfs(s, i+1, end, cur+s[i:i+1])\n\t}\n}\ndfs(s, 0, len(s), \"\")\nreturn res\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: \"STR\",\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: \"STR\",\n\t},\n}\nfor _, tt := range tests {\n\tgot := defangIPaddr(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tif ret := defangIPaddr(p.one); ret != p.two {\n\t\tt.Fatalf(\"STR\", p.one, p.two, ret)\n\t}\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := Base64DecodeDelegate(tc.base64); res != tc.decoded {\n\t\tt.Errorf(\"STR\", tc.decoded, res)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := Base64DecodeDelegate(tc.input); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "qs := []question1207{\n\t{\n\t\tpara1207{[]int{1, 2, 2, 1, 1, 3}},\n\t\tans1207{true},\n\t},\n\t{\n\t\tpara1207{[]int{1, 2}},\n\t\tans1207{false},\n\t},\n\t{\n\t\tpara1207{[]int{-3, 0, 1, -3, 1, 1, 1, -3, 10, 0}},\n\t\tans1207{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1207, q.para1207\n\tfmt.Printf(\"STR\", p, uniqueOccurrences(p.arr))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1207{\n\t{\n\t\tpara1207{[]int{1, 2, 2, 1, 1, 3}},\n\t\tans1207{true},\n\t},\n\t{\n\t\tpara1207{[]int{1, 2, 2, 1, 1, 3}},\n\t\tans1207{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1207, q.para1207\n\tfmt.Printf(\"STR\", p, uniqueOccurrences(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "max := -1001\nmax1 := -1001\nmax2 := -1001\nmin1 := 1001\nmin2 := 1001\nfor _, n := range nums {\n\tswitch {\n\tcase n > max:\n\t\tmax2, max1, max = max1, max, n\n\tcase n > max1:\n\t\tmax2, max1 = max1, n\n\tcase n > max2:\n\t\tmax2 = n\n\t}\n\tswitch {\n\tcase n < min1:\n\t\tmin2, min1 = min1, n\n\tcase n < min2:\n\t\tmin2 = n\n\t}\n}\nreturn bigger(max1*max2, min1*min2) * max", "gen": "min, max, mid := -1001, -1001, -1001\nfor _, num := range nums {\n\tif num > max {\n\t\tmid = max\n\t\tmax = num\n\t} else if num < min {\n\t\tmid = num\n\t\tmin = num\n\t} else if num > mid {\n\t\tmid = num\n\t}\n}\nreturn bigger(min, max) * bigger(mid, mid)\n}"}
{"tgt": "var ret float64\nvar x float64\nvar n int\nret = 0\nx = 0.00001\nn = 2147483647\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 1.0000\nx = 2\nn = 0\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 10.0000\nx = 10.0000\nn = 1\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 0.25000\nx = 2.0000\nn = -2\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "var x, n float64\nx = 0\nn = 2147483647\nif myPow(x, n) != 0 {\n\tt.Fatalf(\"STR\", x, n)\n}\nx = -2\nn = 14\nif myPow(x, n) != 0 {\n\tt.Fatalf(\"STR\", x, n)\n}\nx = 0\nn = 14\nif myPow(x, n) != 0 {\n\tt.Fatalf(\"STR\", x, n)\n}\nx = 0\nn = -2\nif myPow(x, n) != 0 {\n\tt.Fatalf(\"STR\", x, n)\n}\n}"}
{"tgt": "for len(w.data) > 0 && w.data[len(w.data)-1] < n {\n\tw.data = w.data[0 : len(w.data)-1]\n}\nw.data = append(w.data, n)", "gen": "for node.Next != nil && node.Next.Val != val {\n\tnode = node.Next\n}\nif node.Next == nil {\n\treturn\n}\nnode.Next = node.Next.Next\n}"}
{"tgt": "n := 0\ntmp := head\nfor tmp != nil {\n\tn++\n\ttmp = tmp.Next\n}\nreturn helper(&head, 0, n-1)", "gen": "var i int\nhead := node\nfor head != nil {\n\ti++\n\thead = head.Next\n}\nreturn helper(i, node)\n}"}
{"tgt": "const templ = `<p>A:{{.A}}</p><p>B:{{.B}}</p>`\nt := template.Must(template.New(\"STR\").Parse(templ))\nvar data struct {\n\tA string\n\tBtemplate.HTML\n}\ndata.A = \"STR\"\ndata.B = \"STR\"\nif err := t.Execute(os.Stdout, data); err != nil {\n\tlog.Fatal(err)\n}", "gen": "t := template.Must(template.New(\"\").Parse(STR))\nt.Execute(os.Stdout, STR)\n}"}
{"tgt": "if len(A) == len(A[0]) {\n\tfor i := 0; i < len(A); i++ {\n\t\tfor j := 0; j < len(A); j++ {\n\t\t\tif i == j {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]\n\t\t}\n\t}\n\treturn A\n}\nres := make([][]int, len(A[0]))\nfor i := 0; i < len(res); i++ {\n\tres[i] = make([]int, len(A))\n\tfor j := 0; j < len(A); j++ {\n\t\tres[i][j] = A[j][i]\n\t}\n}\nreturn res", "gen": "if len(matrix) == 0 || len(matrix[0]) == 0 {\n\treturn 0\n}\nif len(matrix) == 1 {\n\treturn matrix[0][0]\n}\nfor i := 0; i < len(matrix[0]); i++ {\n\tfor j := 0; j < len(matrix); j++ {\n\t\tif matrix[j][i] == matrix[0][0] {\n\t\t\tfor k := 0; k < len(matrix[0]); k++ {\n\t\t\t\tmatrix[j][k], matrix[0][k] = matrix[0][k], matrix[j][k]\n\t\t\t}\n\t\t\tfor k := 0; k < len(matrix); k++ {\n\t\t\t\tmatrix[k][i], matrix[k][0] = matrix[k][0], matrix[k][i]\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n}\nreturn matrix[0][0]\n}"}
{"tgt": "out := make(map[string]string)\nmain_pieces := strings.Split(s, sep1)\nfor _, piece := range main_pieces {\n\tminor_pieces := strings.Split(piece, sep2)\n\tout[minor_pieces[0]] = minor_pieces[1]\n}\nreturn out", "gen": "m := make(map[string]string)\nfor _, s := range strings.Split(str, \",\") {\n\tfor _, s2 := range strings.Split(s, \"=\") {\n\t\tm[s2] = s\n\t}\n}\nreturn m\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CountLargerAndSmallerBrute(tc.mat, tc.i1, tc.j1, tc.i2, tc.j2); result != tc.count {\n\t\tt.Errorf(\"STR\", tc.count, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CountLargerAndSmallerBrute(tc.nums); result != tc.result {\n\t\tt.Errorf(\"STR\", tc.result, result)\n\t}\n}\n}"}
{"tgt": "size := len(a)\nlo, hi := 0, size-1\nvar miD, miA int\nfor lo <= hi {\n\tmiD = (lo + hi) / 2\n\tmiA = size - miD - 1\n\tif a[miA] > miD {\n\t\tlo = miD + 1\n\t} else {\n\t\thi = miD - 1\n\t}\n}\nreturn lo", "gen": "n := len(nums)\nleft, right := 0, n-1\nfor left < right {\n\tmid := (left + right) / 2\n\tif nums[mid] < nums[n-1] {\n\t\tright = mid - 1\n\t} else {\n\t\tleft = mid + 1\n\t}\n}\nreturn left\n}"}
{"tgt": "l1, l2 := []int{}, []int{}\ndfs(root1, &l1)\ndfs(root2, &l2)\nif len(l1) != len(l2) {\n\treturn false\n}\nfor i, _ := range l1 {\n\tif l1[i] != l2[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var stack1, stack2 []int\ndfs(root, &stack1, &stack2)\ndfs(root, &stack2, &stack1)\nif len(stack1) != len(stack2) {\n\treturn false\n}\nfor i := 0; i < len(stack1); i++ {\n\tif stack1[i] != stack2[i] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result, err := ShortestRunnerPath(tc.elevations, tc.paths); result != tc.shortestRoute || err != tc.err {\n\t\tt.Errorf(\"STR\", tc.shortestRoute, tc.err, result, err)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := ShortestRunnerPath(tc.grid); res != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, res)\n\t}\n}\n}"}
{"tgt": "sLen, pLen := len(s), len(p)\ndp := make([][]bool, sLen+1)\nfor i := range dp {\n\tdp[i] = make([]bool, pLen+1)\n}\ndp[sLen][pLen] = true\nfor i := sLen; i > -1; i-- {\n\tfor j := pLen - 1; j > -1; j-- {\n\t\tfirstMatch := i < sLen && (p[j] == s[i] || p[j] == '.')\n\t\tif j+1 < pLen && p[j+1] == '*' {\n\t\t\tdp[i][j] = dp[i][j+2] || firstMatch && dp[i+1][j]\n\t\t} else {\n\t\t\tdp[i][j] = firstMatch && dp[i+1][j+1]\n\t\t}\n\t}\n}\nreturn dp[0][0]", "gen": "var (\n\tres [][]bool\n\ti   int\n)\nfor i = 0; i < len(board); i++ {\n\tres = append(res, make([]bool, len(board[0])))\n}\nfor i := 0; i < len(board); i++ {\n\tfor j := 0; j < len(board[0]); j++ {\n\t\tif board[i][j] == 'Q' {\n\t\t\tres[i][j] = true\n\t\t\tfor k := 0; k < len(board); k++ {\n\t\t\t\tif k == i {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfor l := 0; l < len(board[0]); l++ {\n\t\t\t\t\tif board[k][l] == 'Q' && (abs(i-k) == abs(j-l) || i+j == k+l) {\n\t\t\t\t\t\tres[k][l] = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "sort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].End < intervals[j].End\n})\ncount := 0\ncurrent := -int(^uint(0)>>1) - 1\nfor _, interval := range intervals {\n\tif interval.Start >= current {\n\t\tcount++\n\t\tcurrent = interval.End\n\t}\n}\nreturn len(intervals) - count", "gen": "var res []Interval\nvar f func(Interval)\nf = func(i Interval) {\n\tres = append(res, i)\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nvar max int\nfor _, i := range intervals {\n\tif i.Start < max {\n\t\tcontinue\n\t}\n\tmax = i.End\n\tf(i)\n}\nreturn res\n}"}
{"tgt": "i := len(nums) - 2\nfor i >= 0 && nums[i] >= nums[i+1] {\n\ti--\n}\nj, k := i+1, len(nums)-1\nfor j < k {\n\tnums[j], nums[k] = nums[k], nums[j]\n\tj, k = j+1, k-1\n}\nif i >= 0 {\n\tj = i + 1\n\tfor nums[j] <= nums[i] {\n\t\tj++\n\t}\n\tnums[i], nums[j] = nums[j], nums[i]\n}", "gen": "n := len(nums) - 2\nfor i := n; i >= 0; i-- {\n\tfor j := i + 1; j < len(nums); j++ {\n\t\tif nums[i] > nums[j] {\n\t\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\t}\n\t}\n}\nn = len(nums) - 1\nfor i := 0; i < n; i++ {\n\tfor j := i + 1; j < n; j++ {\n\t\tif nums[i] > nums[j] {\n\t\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\t}\n\t}\n}\n}"}
{"tgt": "denoms := make(map[int]struct{})\nfor d, way := range ways {\n\tif others := waysToProduce(d, denoms); (way == 1 && d > 0) || others == way-1 {\n\t\tdenoms[d] = struct{}{}\n\t}\n}\nres := make([]int, 0, len(denoms))\nfor k := range denoms {\n\tres = append(res, k)\n}\nsort.Ints(res)\nreturn res", "gen": "ways := make(map[int]struct{})\nfor _, item := range items {\n\tways[waysToProduce(item)] = struct{}{}\n}\nres := make([]int, 0, len(ways))\nfor _, way := range ways {\n\tif way == 1 {\n\t\tres = append(res, 1)\n\t} else {\n\t\tres = append(res, way-1)\n\t}\n}\nsort.Ints(res)\nreturn res\n}"}
{"tgt": "return len(self.data)", "gen": "return len(s.data)\n}"}
{"tgt": "var ri, gi int\nfor i, r := range letters {\n\tif r == 'R' {\n\t\tletters[i] = letters[gi]\n\t\tletters[gi] = letters[ri]\n\t\tletters[ri] = r\n\t\tgi++\n\t\tri++\n\t} else if r == 'G' {\n\t\tletters[i] = letters[gi]\n\t\tletters[gi] = r\n\t\tgi++\n\t}\n}", "gen": "i, j, k := 0, 0, 0\nfor _, v := range nums {\n\tif v == 82 {\n\t\tnums[i], nums[j], nums[k] = nums[j], nums[k], nums[i]\n\t\ti++\n\t\tj++\n\t\tk++\n\t} else if v == 71 {\n\t\tnums[i], nums[j], nums[k] = nums[j], nums[k], nums[i]\n\t\ti++\n\t\tj++\n\t} else if v == 70 {\n\t\tnums[i], nums[j], nums[k] = nums[j], nums[k], nums[i]\n\t\ti++\n\t}\n}\n}"}
{"tgt": "switch rand.Intn(10) {\ncase 1, 9:\n\treturn io.EOF\ncase 5:\n\treturn errors.New(\"STR\")\ndefault:\n\td.Line = \"STR\"\n\tfmt.Println(\"STR\", d.Line)\n\treturn nil\n}", "gen": "rand.Seed(time.Now().UnixNano())\nswitch rand.Intn(10) {\ncase 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:\n\tfmt.Println(\"STR\")\ndefault:\n\treturn errors.New(\"STR\")\n}\n}"}
{"tgt": "return helper(root, p, q)", "gen": "return helper(root, sum, 0)\n}"}
{"tgt": "benchmark(bb, 16384, 0.1)", "gen": "benchmark(b, 16384, 1)\n}"}
{"tgt": "this.mutex.Lock()\ndefer this.mutex.Unlock()\nif priority < 0 || priority > this.max {\n\treturn nil\n}\nreturn this.queues[priority].Peek()", "gen": "defer q.lock.Unlock()\nif q.head == nil {\n\treturn 0, 0\n}\nif q.head.next == nil {\n\treturn 0, 0\n}\nreturn q.head.next.value, q.head.next.priority\n}"}
{"tgt": "if i < 0 || i >= itemKind(len(_itemKind_index)-1) {\n\treturn fmt.Sprintf(\"STR\", i)\n}\nreturn _itemKind_name[_itemKind_index[i]:_itemKind_index[i+1]]", "gen": "if i.kind == itemKind {\n\treturn fmt.Sprintf(\"STR%d\", i.index)\n}\nif i.index < 0 || i.index > 6 {\n\tpanic(\"STR\")\n}\nreturn fmt.Sprintf(\"STR%d\", i.index+1)\n}"}
{"tgt": "arr := randomSlice(0, 20, 10)\nnodeCnt := 0\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\nrotateNodes := make([]*gbtElement, 0, 0)\ngbt.InOrderWalk(gbt.Root(), func(GBTbinaryTreeIf, node interface{}) bool {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\trotateNodes = append(rotateNodes, node.(*gbtElement))\n\t}\n\treturn false\n})\nfor _, v := range rotateNodes {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\tgbt.LeftRotate(v)\n\t} else {\n\t\tgbt.RightRotate(v)\n\t}\n}\ngbt.InOrderWalk(gbt.Root(), checkGBT(t, &nodeCnt, *debug))\nif nodeCnt != len(arr) {\n\tt.Log(fmt.Sprintf(\"STR\", len(arr), nodeCnt))\n\tt.Fail()\n}", "gen": "slice := randomSlice(10, 20, 0)\ntree := newGBT()\nfor _, v := range slice {\n\ttree.Insert(v)\n}\nfor i, v := range slice {\n\tif tree.getRand() != nil {\n\t\tr := getRand()\n\t\tif r.Intn(2) == 1 {\n\t\t\ttree.RotateNodes(v)\n\t\t}\n\t}\n\tif debug {\n\t\tfmt.Printf(\"STR %d\", v)\n\t\tfmt.Printf(\"STR %d\", tree.root.key)\n\t}\n\tif !checkGBT(tree, v) {\n\t\tt.Log(\"STR\", \"STR\")\n\t\tt.Fail()\n\t}\n\tif tree.getRand() != nil {\n\t\tr := getRand()\n\t\tif r.Intn(2) == 1 {\n\t\t\ttree.RotateNodes(v)\n\t\t}\n\t}\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := InversionCountBrute(tc.input); result != tc.inversions {\n\t\tt.Errorf(\"STR\", tc.inversions, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := InversionCountBrute(tc.arr); res != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, res)\n\t}\n}\n}"}
{"tgt": "fmt.Println(subarrayBitwiseORs([]int{0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))", "gen": "fmt.Println(subarrayBitwiseORs([]int{0, 1, 0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1,"}
{"tgt": "if nil == root {\n\treturn []int{}\n}\nlargestVals := []int{}\nchildren := []*TreeNode{root}\nfor len(children) > 0 {\n\ttmp := children[:]\n\tchildren = []*TreeNode{}\n\tlargest := -(1 << 32)\n\tfor _, child := range tmp {\n\t\tif child.Val > largest {\n\t\t\tlargest = child.Val\n\t\t}\n\t\tif nil != child.Left {\n\t\t\tchildren = append(children, child.Left)\n\t\t}\n\t\tif nil != child.Right {\n\t\t\tchildren = append(children, child.Right)\n\t\t}\n\t}\n\tlargestVals = append(largestVals, largest)\n}\nreturn largestVals", "gen": "if root == nil {\n\treturn []int{}\n}\nvar res []int\nvar stack []*TreeNode\nstack = append(stack, root)\nfor len(stack) > 0 {\n\tnode := stack[len(stack)-1]\n\tstack = stack[:len(stack)-1]\n\tres = append(res, node.Val)\n\tif node.Left != nil {\n\t\tstack = append(stack, node.Left)\n\t}\n\tif node.Right != nil {\n\t\tstack = append(stack, node.Right)\n\t}\n}\nreturn res\n}"}
{"tgt": "{\n\tdata, err := json.Marshal(movies)\n\tif err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Printf(\"STR\", data)\n}\n{\n\tdata, err := json.MarshalIndent(movies, \"STR\")\n\tif err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Printf(\"STR\", data)\n\tvar titles []struct{ Title string }\n\tif err := json.Unmarshal(data, &titles); err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Println(titles)\n}", "gen": "var movies = []Movie{\n\t{Title: \"STRANGE LOVE\", Year: 2016},\n\t{Title: \"STRANGE LOVE\", Year: 2016},\n}\nif len(movies) == 0 {\n\tlog.Fatalf(\"STRANGE LOVE\")\n}\njson, err := json.MarshalIndent(movies, \"\", \"STRANGE LOVE\")\nif err != nil {\n\tlog.Fatalf(\"STRANGE LOVE\")\n}\nfmt.Printf(\"STRANGE LOVE\", json)\nvar movie Movie\nerr = json.Unmarshal(json, &movie)\nif err != nil {\n\tlog.Fatalf(\"STRANGE LOVE\")\n}\nfmt.Println(movie)\n}"}
{"tgt": "if num <= 0 {\n\treturn false\n}\nif num&(num-1) != 0 {\n\treturn false\n}\nif num&0x55555555 == 0 {\n\treturn false\n}\nreturn true", "gen": "if n < 0 {\n\treturn false\n}\nif n == 0 {\n\treturn false\n}\nif n&1 == 0 && n&1431655765 == 0 {\n\treturn false\n}\nreturn true\n}"}
{"tgt": "major := uint32((dev & 0x00000000000fff00) >> 8)\nmajor |= uint32((dev & 0xfffff00000000000) >> 32)\nreturn major", "gen": "return (n & 1048320) >> 8 | (n & 0xffffffff00000000) >> 32\n}"}
{"tgt": "t.Parallel()\nvar ba BitArray\nfor _, tc := range testcases {\n\tba.Init(tc.size)\n\tfor index, val := range tc.ones {\n\t\tif err := ba.Set(index, val); err != nil {\n\t\t\tt.Errorf(\"STR\")\n\t\t}\n\t}\n\tfor i := 0; i < tc.size; i++ {\n\t\tif val, err := ba.Get(i); err != nil {\n\t\t\tt.Errorf(\"STR\", err)\n\t\t} else if tc.ones[i] != val {\n\t\t\tt.Errorf(\"STR\", tc.ones[i], val, i)\n\t\t}\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tba := NewBitArray(tc.n)\n\tfor i, v := range tc.set {\n\t\tba.Set(i, v)\n\t}\n\tfor i, v := range tc.get {\n\t\tif v != ba.Get(i) {\n\t\t\tt.Errorf(\"STR\", tc.n, tc.set, tc.get, i, v, ba.Get(i))\n\t\t}\n\t}\n}\n}"}
{"tgt": "if a == b {\n\treturn -1\n}\nif len(a) > len(b) {\n\treturn len(a)\n}\nreturn len(b)", "gen": "if p == q {\n\treturn 1\n}\nif p.Val != q.Val {\n\treturn -1\n}\nif p.Left == nil && q.Left == nil {\n\treturn 1\n}\nif p.Left == nil || q.Left == nil {\n\treturn -1\n}\nreturn max(p.Left, q.Left)\n}"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil {\n\t\t\tmax = max.Right\n\t\t}\n\t\tmax.Right = root\n\t\troot, root.Left = root.Left, nil\n\t}\n}\nreturn res", "gen": "var res []*TreeNode\ncur := root\nfor cur != nil {\n\tif cur.Left == nil {\n\t\tres = append(res, cur)\n\t\tcur = cur.Right\n\t} else {\n\t\tcur = cur.Left\n\t}\n}\nfor cur = root; cur != nil; cur = cur.Right {\n\tcur.Left = nil\n}\nreturn res\n}"}
{"tgt": "if a > b {\n\treturn b\n}\nreturn a", "gen": "if a > b {\n\treturn b\n}\nreturn a\n}"}
{"tgt": "var buf bytes.Buffer\nif err := encode(&buf, reflect.ValueOf(v)); err != nil {\n\treturn nil, err\n}\nreturn buf.Bytes(), nil", "gen": "var buf bytes.Buffer\nencode(&buf, reflect.ValueOf(v))\nif buf.Len() == 0 {\n\treturn nil\n}\nreturn buf.Bytes()\n}"}
{"tgt": "m := map[byte]struct{}{}\nfor i := range J {\n\tm[J[i]] = struct{}{}\n}\nres := 0\nfor i := range S {\n\tif _, ok := m[S[i]]; ok {\n\t\tres++\n\t}\n}\nreturn res", "gen": "m := make(map[byte]struct{})\nfor _, c := range s {\n\tm[c] = struct{}{}\n}\nvar res int\nfor _, c := range t {\n\tif _, ok := m[c]; ok {\n\t\tres++\n\t}\n}\nreturn res\n}"}
{"tgt": "if numRows < 2 {\n\treturn s\n}\nmaxInterval := (numRows - 1) << 1\ninterval := maxInterval\nafter := \"STR\"\nfor i := 0; i < numRows; i++ {\n\tif numRows-1 == i {\n\t\tinterval = maxInterval\n\t}\n\tfor j, no := i, 0; j < len(s); no++ {\n\t\tafter += string(s[j])\n\t\tif i > 0 && i < numRows-1 && 1 == no&1 {\n\t\t\tj += maxInterval - interval\n\t\t\tcontinue\n\t\t}\n\t\tj += interval\n\t}\n\tinterval -= 2\n}\nreturn after", "gen": "if n == 1 {\n\treturn s\n}\nn--\nres := \"STR\"\nfor i := 0; i < n; i++ {\n\tif i == n-1 {\n\t\tres = s\n\t}\n\tfor j := 0; j < n; j++ {\n\t\tif j == i {\n\t\t\tcontinue\n\t\t}\n\t\tif j%2 == 0 {\n\t\t\tres = res + s[j]\n\t\t} else {\n\t\t\tres = res + s[j]\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "var result []string\ndfs(s, []string{}, &result)\nreturn result", "gen": "var res []string\ndfs(root, &res)\nreturn res\n}"}
{"tgt": "if n < 7 {\n\treturn int64(n + 1)\n}\nans := (1 + int64(n%7)) * row(n/7)\nreturn ans", "gen": "if n > 6 {\n\treturn n + 1\n}\nreturn row(n) * row(n)\n}"}
{"tgt": "if len(mat) == 0 || len(mat[0]) == 0 {\n\treturn []int{}\n}\nm, n := len(mat), len(mat[0])\nisUpping := true\nnext := func(i, j int) (int, int) {\n\tif isUpping {\n\t\ti--\n\t\tj++\n\t\tif 0 <= i && j < n {\n\t\t\treturn i, j\n\t\t}\n\t\tisUpping = false\n\t\tif i < 0 && j < n {\n\t\t\treturn 0, j\n\t\t}\n\t\treturn i + 2, j - 1\n\t}\n\ti++\n\tj--\n\tif i < m && 0 <= j {\n\t\treturn i, j\n\t}\n\tisUpping = true\n\tif i < m && j < 0 {\n\t\treturn i, 0\n\t}\n\treturn i - 1, j + 2\n}\nmn := m * n\nres := make([]int, mn)\ni, j := 0, 0\nfor k := 0; k < mn; k++ {\n\tres[k] = mat[i][j]\n\ti, j = next(i, j)\n}\nreturn res", "gen": "if len(matrix) == 0 || len(matrix[0]) == 0 {\n\treturn nil\n}\nif len(matrix) == 1 {\n\treturn matrix[0]\n}\nres := make([]int, len(matrix[0])*len(matrix))\ni, j := 0, 0\nfor i < len(matrix) {\n\tfor j < len(matrix[0]) {\n\t\tres[i*len(matrix[0])+j] = matrix[i][j]\n\t\tj++\n\t}\n\ti++\n\tj = 0\n}\nreturn res\n}"}
{"tgt": "n := len(quality)\nworkers := make([][2]float64, n)\nfor i := 0; i < n; i++ {\n\tw, q := float64(wage[i]), float64(quality[i])\n\tworkers[i][0], workers[i][1] = w/q, q\n}\nsort.Slice(workers, func(i, j int) bool {\n\treturn workers[i][0] < workers[j][0]\n})\nres := math.MaxFloat64\nsum := 0.\nh := floatHeap{}\nfor _, w := range workers {\n\tsum += w[1]\n\theap.Push(&h, w[1])\n\tif len(h) > K {\n\t\tsum -= heap.Pop(&h).(float64)\n\t}\n\tif len(h) == K {\n\t\tres = min(res, sum*w[0])\n\t}\n}\nreturn res", "gen": "n := len(cost)\ndp := make([]float64, n)\nfor i := 0; i < n; i++ {\n\tdp[i] = float64(cost[i]) / float64(cost[n-1])\n}\nsort.Slice(dp, func(i, j int) bool {\n\treturn dp[i] < dp[j]\n})\nmin := math.Inf(1)\nh := &floatHeap{\n\tdata: dp,\n}\nheap.Init(h)\nfor i := 0; i < n; i++ {\n\tif i >= h.Len() {\n\t\tbreak\n\t}\n\theap.Pop(h)\n\tmin = min(min, float64(h.Len())*dp[h.Len()])\n}\nreturn min\n}"}
{"tgt": "t.Parallel()\nlfu := NewLFUCache(3)\nlfu.Set(\"STR\", \"STR\")\nlfu.Set(1, 2)\nlfu.Set(\"STR\", \"STR\")\nlfu.Get(1)\nlfu.Get(\"STR\")\nlfu.Set(100, 1)\nif result := lfu.Get(\"STR\"); result != nil {\n\tt.Errorf(\"STR\", result)\n}\nif result := lfu.Get(1); result == nil {\n\tt.Errorf(\"STR\")\n}\nif result := lfu.Get(\"STR\"); result == nil {\n\tt.Errorf(\"STR\")\n}\nif result := lfu.Get(100); result == nil {\n\tt.Errorf(\"STR\")\n}\nlfu.Set(100, \"STR\")\nif result := lfu.Get(100); result.(string) != \"STR\" {\n\tt.Errorf(\"STR\")\n}", "gen": "t.Parallel()\ncache := NewLFUCache(3)\ncache.Set(\"STR\", \"STR\")\ncache.Set(\"STR\", \"STR\")\ncache.Set(\"STR\", \"STR\")\nif cache.Get(\"STR\") != \"STR\" {\n\tt.Errorf(\"STRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTR"}
{"tgt": "m := len(pattern)\nnext := make([]int, m)\nfor index := range next {\n\tnext[index] = -1\n}\nfor i := 1; i < m-1; i++ {\n\tj := next[i-1]\n\tfor pattern[j+1] != pattern[i] && j >= 0 {\n\t\tj = next[j]\n\t}\n\tif pattern[j+1] == pattern[i] {\n\t\tj += 1\n\t}\n\tnext[i] = j\n}\nreturn next", "gen": "n := len(A)\nres := make([]int, n)\nfor i := 0; i < n; i++ {\n\tres[i] = -1\n}\nfor i := 0; i < n; i++ {\n\tif A[i] == 0 {\n\t\tcontinue\n\t}\n\tfor j := i + 1; j < n; j++ {\n\t\tif A[j] == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif A[i] == A[j] {\n\t\t\tres[j] = i\n\t\t}\n\t}\n}\nfor i := 0; i < n; i++ {\n\tif res[i] == -1 {\n\t\tres[i] = n\n\t}\n}\nreturn res\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := AllPossibleSubsequences(tc.input); !reflect.DeepEqual(result, tc.subseq) {\n\t\tt.Errorf(\"STR\", tc.subseq, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := AllPossibleSubsequences(tc.input); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 3, 4, 2, 2}, 2},\n\t{\"STR\", []int{3, 1, 3, 4, 2}, 3},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := findDuplicate(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "var tests = []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 3, 4, 2, 2}, 3},\n\t{\"STR\", []int{3, 1, 3, 4, 2}, 3},\n}\nfor i, tt := range tests {\n\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(tt.inputs)\n\t\tif got != tt.expect {\n\t\t\tt.Errorf(\"STR\", tt.expect, got)\n\t\t}\n\t})\n}\n}"}
{"tgt": "cases := []struct {\n\tname    string\n\tinputs  []int\n\texpects bool\n}{\n\t{\"STR\", []int{1, 2, 3, 1}, true},\n\t{\"STR\", []int{1, 2, 3, 4}, false},\n\t{\"STR\", []int{1, 1, 1, 3, 3, 4, 3, 2, 4, 2}, true},\n}\nfor _, testcase := range cases {\n\tt.Run(testcase.name, func(t *testing.T) {\n\t\tresult := containsDuplicate(testcase.inputs)\n\t\tif !reflect.DeepEqual(result, testcase.expects) {\n\t\t\tt.Fatalf(\"STR\", testcase.expects, result, testcase.inputs)\n\t\t}\n\t})\n}", "gen": "var tests = []struct {\n\tname   string\n\tinputs []int\n\texpect bool\n}{\n\t{\"STR\", []int{1, 2, 3, 1}, true},\n\t{\"STR\", []int{1, 2, 3, 4}, false},\n\t{\"STR\", []int{1, 2, 3, 1, 2, 3, 4}, true},\n}\nfor _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tgot := containsDuplicate(tt.inputs)\n\t\tif got != tt.expect {\n\t\t\tt.Errorf(\"STR\", tt.inputs, tt.expect, got)\n\t\t}\n\t})\n}\n}"}
{"tgt": "arr := randomSlice(0, 20, 10)\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\ncheckGBTPreOrder(t, gbt, arr)", "gen": "var nodes []*Node\nnodes = randomSlice(10, 20, 0)\ntree := newGBT()\nfor _, n := range nodes {\n\ttree.Insert(n)\n}\ncheckGBTPreOrder(tree, nodes)\n}"}
{"tgt": "fmt.Println(maxDistToClosest([]int{1, 0, 0, 0, 1, 0, 1}))\nfmt.Println(maxDistToClosest([]int{1, 0, 0, 0}))\nfmt.Println(maxDistToClosest([]int{0, 1}))\nfmt.Println(maxDistToClosest([]int{0, 1, 1, 1, 0, 0, 1, 0, 0}))\nfmt.Println(maxDistToClosest([]int{0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0}))", "gen": "fmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 1"}
{"tgt": "iE := i.(*ltHeapElement)\njE := j.(*ltHeapElement)\nif iE == nil {\n\treturn jE\n}\nif jE == nil {\n\treturn iE\n}\nif h.Key(iE) < h.Key(jE) {\n\th.Swap(&iE, &jE)\n}\niE.right = h.merge(iE.right, jE).(*ltHeapElement)\nif iE.left == nil || iE.right.dist > iE.left.dist {\n\th.Swap(&iE.left, &iE.right)\n}\nif iE.right == nil {\n\tiE.dist = 0\n} else {\n\tiE.dist = iE.right.dist + 1\n}\nreturn iE", "gen": "if h.Key == nil {\n\treturn h.Key\n}\nif h.Key.Less(h.Key, h.Key) {\n\th.Key, h.Key.Parent = h.Key.Parent, h.Key\n\th.Key.Parent.Swap(h.Key)\n\th.Key.merge(h.Key)\n\th.Key.Parent.merge(h.Key.Parent)\n}\nreturn h.Key\n}"}
{"tgt": "result := MakeMatrix(make([]float64, A.cols*A.rows), A.cols, A.rows)\nfor i := 0; i < A.rows; i++ {\n\tfor j := 0; j < A.cols; j++ {\n\t\tsum := float64(0)\n\t\tfor k := 0; k < A.cols; k++ {\n\t\t\tsum += A.GetElm(i, k) * B.GetElm(k, j)\n\t\t}\n\t\tresult.SetElm(i, j, sum)\n\t}\n}\nreturn result", "gen": "m := MakeMatrix(a.Rows, a.Cols, 0)\nfor i := 0; i < a.Rows; i++ {\n\tfor j := 0; j < a.Cols; j++ {\n\t\tsum := 0.0\n\t\tfor k := 0; k < a.Cols; k++ {\n\t\t\tsum += a.GetElm(i, k) * b.GetElm(k, j)\n\t\t}\n\t\tm.SetElm(i, j, sum)\n\t}\n}\nreturn m\n}"}
{"tgt": "if head == nil {\n\treturn nil\n}\neven := head.Next\np, q := head, head.Next\nfor q != nil && q.Next != nil {\n\tp.Next = q.Next\n\tp = p.Next\n\tq.Next = p.Next\n\tq = q.Next\n}\np.Next = even\nreturn head", "gen": "if head == nil {\n\treturn 0\n}\nvar pre *ListNode\nfor head != nil {\n\thead.Next = pre\n\tpre = head\n\thead = head.Next\n}\nhead = pre\nfor head != nil {\n\thead.Next = head.Next.Next\n\thead = head.Next\n}\nreturn pre\n}"}
{"tgt": "for i := 0; i < b.N; i++ {\n\thmap.HashInsert(rand.Intn(128), i)\n}", "gen": "for i := 0; i < len(s.data); i++ {\n\ts.data[i] = []int{i, rand.Intn(128)}\n}\n}"}
{"tgt": "size := len(prices)\nif size <= 1 {\n\treturn 0\n}\nprofits := []int{}\ntemp := 0\nfor i := 1; i < size; i++ {\n\tdiff := prices[i] - prices[i-1]\n\tif temp*diff >= 0 {\n\t\ttemp += diff\n\t\tcontinue\n\t}\n\tprofits = append(profits, temp)\n\ttemp = diff\n}\nprofits = append(profits, temp)\nres := 0\nfor i := 0; i < len(profits); i++ {\n\ttemp = max(profits[:i]) + max(profits[i:])\n\tif res < temp {\n\t\tres = temp\n\t}\n}\nreturn res", "gen": "n := len(A)\nif n == 1 {\n\treturn 0\n}\nres := make([]int, 0)\nfor i := 1; i < n; i++ {\n\tres = append(res, A[i]*A[i-1])\n\tmax := max(res[i-1], res[i])\n\tif max > res[i-1] {\n\t\tres[i-1] = max\n\t} else {\n\t\tres[i] = max\n\t}\n}\nmax := 0\nfor i := 0; i < n; i++ {\n\tif max < res[i] {\n\t\tmax = res[i]\n\t}\n}\nreturn max\n}"}
{"tgt": "_a := a\n_b := b\nif a < 0 {\n\ta *= -1\n}\nif b < 0 {\n\tb *= -1\n}\nx0, y0 := 0, 1\nx1, y1 := 1, 0\nfor b != 0 {\n\tquotient := a / b\n\ta, b = b, divide(a, b)\n\tx1, x0 = x0-quotient*x1, x1\n\ty1, y0 = y0-quotient*y1, y1\n}\nif _a < 0 {\n\ty0 *= -1\n}\nif _b < 0 {\n\tx0 *= -1\n}\nreturn y0, x0", "gen": "a, b := abs(a), abs(b)\nvar x, y int\nfor b != 0 {\n\tx, y = x*b+a, x\n\ta, b = y, b\n}\nreturn x, y\n}"}
{"tgt": "t.Run(\"STR\", func(t *testing.T) {\n\tdata := []int{1, 1, 2}\n\tgot := removeDuplicates(data)\n\twant := 2\n\tif got != want {\n\t\tt.Error(\"STR\", got, \"STR\", want)\n\t}\n})\nt.Run(\"STR\", func(t *testing.T) {\n\tdata := []int{0, 0, 1, 1, 1, 2, 2, 3, 3, 4}\n\tgot := removeDuplicates(data)\n\twant := 5\n\tif got != want {\n\t\tt.Error(\"STR\", got, \"STR\", want)\n\t}\n})", "gen": "t.Run(\"STR\", func(t *testing.T) {\n\ttestSolution(t)\n})\nt.Run(\"STR\", func(t *testing.T) {\n\ttestSolution(t)\n})\n}"}
{"tgt": "if list == nil || list.Size == 0 {\n\tfmt.Println(\"STR\")\n\treturn\n}\nlist.mutex.RLock()\ndefer list.mutex.RUnlock()\nfmt.Printf(\"STR\", list.Size)\nptr := list.Head\nvar i uint\nfor i = 0; i < list.Size; i++ {\n\tfmt.Printf(\"STR\", i+1, ptr.Data)\n\tptr = ptr.Next\n}", "gen": "if q == nil {\n\tfmt.Println(\"STR\")\n\treturn\n}\nq.RLock()\ndefer q.RUnlock()\nfmt.Printf(\"STR%d\", q.head.value)\nfor i := 0; i < q.size; i++ {\n\tfmt.Printf(\"STR%d\", q.head.value)\n\tq.head = q.head.next\n}\n}"}
{"tgt": "commonChars := make([]string, 0)\nif len(A) == 0 {\n\treturn commonChars\n}\nminFrequencies := [26]int{}\nfor i := range minFrequencies {\n\tminFrequencies[i] = math.MaxInt32\n}\nfor _, word := range A {\n\tcharFrequencies := [26]int{}\n\tfor _, char := range word {\n\t\tcharFrequencies[char-\"STR\"]++\n\t}\n\tfor i := 0; i < 26; i++ {\n\t\tminFrequencies[i] = min(minFrequencies[i], charFrequencies[i])\n\t}\n}\nfor i := 0; i < 26; i++ {\n\tfor minFrequencies[i] > 0 {\n\t\tcommonChars = append(commonChars, string(rune(i)+\"STR\"))\n\t\tminFrequencies[i]--\n\t}\n}\nreturn commonChars", "gen": "if len(s) == 0 {\n\treturn s\n}\nres := make([]string, 0, len(s))\nfor i := 0; i < len(s); i++ {\n\tres = append(res, \"\")\n\tfor j := 0; j < len(s); j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tres[i] += string(s[j])\n\t}\n}\nreturn res\n}"}
{"tgt": "return N&1 == 0", "gen": "return n&1 == 0\n}"}
{"tgt": "var head *event\nreturn MyCalendar{head: head}", "gen": "return 0\n}"}
{"tgt": "var num uint32\nvar ret int\nnum = 00000000000000000000000000001011\nret = 3\nif ret != hammingWeight(num) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "var num int = 521\nvar expected int = 3\nif hammingWeight(num) != expected {\n\tt.Fatalf(\"STR\", expected)\n}\n}"}
{"tgt": "if head == nil || head.Next == nil {\n\treturn head\n}\nresult := head.Next\nresult.Next, head.Next = head, head.Next.Next\nresult.Next.Next = SwapEveryTwo(result.Next.Next)\nreturn result", "gen": "if root == nil || root.Next == nil {\n\treturn root\n}\nroot.Next.Next = root\nroot.Next = root.Next.Next\nreturn root.Next\n}"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := AreSentencesEquivalentTransitive(tc.sentence1,\n\t\ttc.sentence2, tc.thesaurus); result != tc.expectedTransitive {\n\t\tt.Errorf(\"STR\", tcid,\n\t\t\ttc.expectedTransitive, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := AreSentencesEquivalentTransitive(tc.sentence1, tc.sentence2); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.sentence1, tc.sentence2, tc.expected, result)\n\t}\n}\n}"}
{"tgt": "m := make(map[int]int)\nfor k, v := range nums {\n\tif idx, ok := m[target-v]; ok {\n\t\treturn []int{idx, k}\n\t}\n\tm[v] = k\n}\nreturn nil", "gen": "m := make(map[int]int)\nfor _, num := range nums {\n\tm[num] = nums[num]\n}\nfor i, num := range nums {\n\tif _, ok := m[i-num]; ok {\n\t\treturn []int{i, i - num}\n\t}\n\tm[num] = i\n}\nreturn nil\n}"}
{"tgt": "sum := 100 * 101 / 2\nsqSum := sum * sum\nsumSq := 0\nfor i := 1; i <= 100; i++ {\n\tsumSq += i * i\n}\nfmt.Println(sqSum - sumSq)", "gen": "sum := 5050 * 5050\ntotal := 0\nfor i := 1; i <= 100; i++ {\n\ttotal += i * i\n}\nfmt.Println(sum - total)\n}"}
{"tgt": "if a > b {\n\treturn b\n}\nreturn a", "gen": "if a > b {\n\treturn b\n}\nreturn a\n}"}
{"tgt": "return this.Val", "gen": "return self.head\n}"}
{"tgt": "n := len(prices)\nif 0 == n || 1 == n {\n\treturn 0\n}\nvar (\n\tres      int\n\tminPrice = prices[0]\n)\nfor i := 1; i < n; i++ {\n\tif prices[i] < prices[i-1] {\n\t\tres += prices[i-1] - minPrice\n\t\tminPrice = prices[i]\n\t}\n\tif i == n-1 {\n\t\tres += prices[i] - minPrice\n\t}\n}\nreturn res", "gen": "n := len(nums)\nif n == 0 || n == 1 {\n\treturn 0\n}\nsum := nums[0]\nfor i := 1; i < n; i++ {\n\tif nums[i] < nums[i-1] {\n\t\tsum += nums[i] - nums[i-1]\n\t} else {\n\t\tsum += nums[i]\n\t}\n}\nsum += nums[n-1]\nreturn sum\n}"}
{"tgt": "bs := []byte(s)\nvar recur func(int, int) bool\nrecur = func(l, r int) bool {\n\tfor l < r {\n\t\tif bs[l] != bs[r] {\n\t\t\treturn false\n\t\t}\n\t\tl++\n\t\tr--\n\t}\n\treturn true\n}\nfor l, r := 0, len(s)-1; l < r; l, r = l+1, r-1 {\n\tif bs[l] == bs[r] {\n\t\tcontinue\n\t}\n\treturn recur(l+1, r) || recur(l, r-1)\n}\nreturn true", "gen": "s := []byte(str)\nvar res bool\nfor i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\n\tif s[i] != s[j] {\n\t\tres = validPalindrome(s[:i], s[i+1:]) || validPalindrome(s[i+1:], s[j:])\n\t}\n}\nreturn res\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 0,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxNumberOfBalloons(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var tests = []struct {\n\ts        string\n\texpected int\n}{\n\t{\"STR\", 1},\n\t{\"STRSTR\", 2},\n\t{\"STRSTRSTR\", 3},\n}\nfor _, tt := range tests {\n\tif result := maxNumberOfBalloons(tt.s); result != tt.expected {\n\t\tt.Fatalf(\"STRSTRSTR\", tt.expected, result)\n\t}\n}\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\twords: []string{\"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  true,\n\t},\n\t{\n\t\twords: []string{\"STR\", \"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  false,\n\t},\n\t{\n\t\twords: []string{\"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := isAlienSorted(tt.words, tt.order)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.words, got, tt.want)\n\t}\n}", "gen": "qs := []question953{\n\t{\n\t\tpara953{\n\t\t\t[]string{\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR"}
{"tgt": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 1, 3}},\n\t\tans1051{3},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 2, 3, 4}},\n\t\tans1051{5},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{0},\n\t},\n\t{\n\t\tpara1051{[]int{5, 4, 3, 2, 1}},\n\t\tans1051{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 3}},\n\t\tans1051{true},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 4, 2, 3}},\n\t\tans1051{false},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "i := 1\ntmp := 0\nfor i < len(arr) {\n\tif arr[i] >= arr[i-1] {\n\t\ti++\n\t} else {\n\t\ttmp = arr[i]\n\t\tarr[i] = arr[i-1]\n\t\tarr[i-1] = tmp\n\t\tif i > 1 {\n\t\t\ti--\n\t\t}\n\t}\n}", "gen": "for i := 1; i < len(nums); i++ {\n\tif nums[i] < nums[i-1] {\n\t\tnums[i], nums[i-1] = nums[i-1], nums[i]\n\t\treturn\n\t}\n}\n}"}
{"tgt": "if maxSize > 0 {\n\tstack := &Stack{}\n\tstack.top = nil\n\tstack.size = 0\n\tstack.maxSize = maxSize\n\treturn stack\n}\nreturn nil", "gen": "if s != nil {\n\treturn &Stack{\n\t\tdata: s.data,\n\t}\n}\nreturn nil\n}"}
{"tgt": "b, _ := ioutil.ReadFile(\"STR\")\ns := strings.Replace(string(b), \"STR\", \"STR\", -1)\nnumData := strings.Split(s, \"STR\")\nfor _, n := range numData {\n\tnumber, err := strconv.Atoi(n)\n\tif err == nil {\n\t\tdata = append(data, number)\n\t}\n}", "gen": "data, err := ioutil.ReadFile(\"STR\")\nSTR = strings.Replace(STR, \"STR\", \"STR\", -1)\nSTR = strings.Split(STR, \"STR\")\nfor _, v := range STR {\n\tSTR, err = STR, STR.Atoi()\n\tSTR = STR\n}\nSTR = STR\n}"}
{"tgt": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nc, res := []int{}, [][]int{}\nsort.Ints(candidates)\nfindcombinationSum(candidates, target, 0, c, &res)\nreturn res", "gen": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nsort.Ints(candidates)\nreturn findcombinationSum(candidates, target, []int{}, []int{})\n}"}
{"tgt": "qs := []question786{\n\t{\n\t\tpara786{[]int{1, 2, 3, 5}, 3},\n\t\tans786{[]int{2, 5}},\n\t},\n\t{\n\t\tpara786{[]int{1, 7}, 1},\n\t\tans786{[]int{1, 7}},\n\t},\n\t{\n\t\tpara786{[]int{1, 2}, 1},\n\t\tans786{[]int{1, 2}},\n\t},\n\t{\n\t\tpara786{[]int{1, 2, 3, 5, 7}, 6},\n\t\tans786{[]int{3, 7}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans786, q.para786\n\tfmt.Printf(\"STR\", p, kthSmallestPrimeFraction(p.A, p.K))\n}\nfmt.Printf(\"STR\")", "gen": "A := [][]int{\n\t{1, 2, 3},\n\t{5, 2, 2},\n\t{1, 7},\n}\nB := [][]int{\n\t{2, 5},\n\t{2, 2},\n\t{1, 7},\n}\nfor i := 0; i < len(A); i++ {\n\tfmt.Printf(\"STR\", A[i], B[i])\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "errObj := appError{\n\tError:      handlerError.Error(),\n\tMessage:    message,\n\tHTTPStatus: code,\n}\nError.Printf(\"STR\", handlerError)\nw.Header().Set(\"STR\", \"STR\")\nw.WriteHeader(code)\nif j, err := json.Marshal(errorResource{Data: errObj}); err == nil {\n\tw.Write(j)\n}", "gen": "if err := c.Request.ParseForm(); err != nil {\n\tlog.Printf(\"ERROR: %s\", err)\n\treturn\n}\nc.Request.Header.Set(\"Content-Type\", \"application/json\")\nbody, err := json.Marshal(errorResource{\n\tMessage: err.Error(),\n})\nif err != nil {\n\tlog.Printf(\"ERROR: %s\", err)\n\treturn\n}\nc.Response.Header.Set(\"Content-Type\", \"application/json\")\nc.Response.Write(body)\n}"}
{"tgt": "if len(strs) == 0 {\n\treturn nil\n}\nr := make(map[string][]string)\nfor _, str := range strs {\n\tcount := make([]int, 26)\n\tfor _, b := range []byte(str) {\n\t\tcount[b-'a']++\n\t}\n\tbs := make([]byte, 26*2)\n\tfor i, c := range count {\n\t\tbs[2*i] = '#'\n\t\tbs[2*i+1] = byte(c) + '0'\n\t}\n\tkey := string(bs)\n\tr[key] = append(r[key], str)\n}\nres := make([][]string, len(r))\ni := 0\nfor _, l := range r {\n\tres[i] = l\n\ti++\n}\nreturn res", "gen": "if len(s) == 0 {\n\treturn s\n}\nm := make(map[string][]string)\nfor _, c := range s {\n\tm[string(c)] = append(m[string(c)], \"\")\n}\nvar res []string\nfor _, c := range s {\n\tfor i, s := range m[string(c)] {\n\t\tm[string(c)][i] = s + string(c)\n\t}\n\tfor _, s := range m[string(c)] {\n\t\tif len(s) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tres = append(res, s)\n\t}\n}\nreturn res\n}"}
{"tgt": "type Address struct {\n\tCountry string  `json:\"STR\"`\n\tPerson  *Person `json:\"STR\"`\n}\nperson := &Person{\n\tName: \"STR\",\n\tAge:  23,\n}\naddress := &Address{\n\tCountry: \"STR\",\n\tPerson:  person,\n}\ndefer func() {\n\terr := recover()\n\tif err != nil {\n\t\tfmt.Printf(\"STR\", err)\n\t\tt.Error(\"STR\")\n\t}\n}()\ns := New(address)\ns.TagName = \"STR\"\nm := s.Map()\nif m[\"STR\"] != person.String() {\n\tt.Errorf(\"STR\", person.String(), m[\"STR\"])\n}\nvs := s.Values()\nif vs[1] != person.String() {\n\tt.Errorf(\"STR\", person.String(), vs[1])\n}", "gen": "p := structs.New(\"STRUCT\", STRING(\"STRUCT\"))\nSTRUCT := STRING(\"STRUCT\")\nSTRUCT.Tag = \"STRUCT\"\nSTRUCT.STRUCT = STRING(\"STRUCT\")\nSTRUCT.STRUCT.STRUCT = STRING(\"STRUCT\")\nSTRUCT.STRUCT.STRUCT.STRUCT = STRING(\"STRUCT\")\nSTRUCT.STRUCT.STRUCT.STRUCT.STRUCT = STRING(\"STRUCT\")\nSTRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT = STRING(\"STRUCT\")\nSTRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT = STRING(\"STRUCT\")\nSTRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT = STRING(\"STRUCT\")\nSTRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT = STRING(\"STRUCT\")\nSTRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT = STRING(\"STRUCT\")\nSTRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT = STRING(\"STRUCT\")\nSTRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT = STRING(\"STRUCT\")\nSTRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRUCT.STRU"}
{"tgt": "if parser.tokens_head > 0 && len(parser.tokens) == cap(parser.tokens) {\n\tif parser.tokens_head != len(parser.tokens) {\n\t\tcopy(parser.tokens, parser.tokens[parser.tokens_head:])\n\t}\n\tparser.tokens = parser.tokens[:len(parser.tokens)-parser.tokens_head]\n\tparser.tokens_head = 0\n}\nparser.tokens = append(parser.tokens, *token)\nif pos < 0 {\n\treturn\n}\ncopy(parser.tokens[parser.tokens_head+pos+1:], parser.tokens[parser.tokens_head+pos:])\nparser.tokens[parser.tokens_head+pos] = *token", "gen": "if len(tokens) == 0 {\n\treturn\n}\nif len(tokens) == len(tokens[0]) {\n\treturn\n}\nif len(tokens) == len(tokens[0])+1 {\n\treturn\n}\ntokens = tokens[1:]\nreturn\n}"}
{"tgt": "str := \"STR\"\nfmt.Println(longestPalindrome(str))", "gen": "fmt.Println(longestPalindrome(\"STR\"))\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   5,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   0,\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   1,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   2,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   13,\n\t\twant: 4,\n\t},\n\t{\n\t\tin:   130,\n\t\twant: 15,\n\t},\n}\nfor _, tt := range tests {\n\tgot := arrangeCoins(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "tests := []struct {\n\tcoins []int\n\tresult int\n}{\n\t{[]int{5, 2, 8, 3, 0, 1, 1, 2, 13, 4, 130, 15, 130}, 130},\n}\nfor _, tt := range tests {\n\tif result := arrangeCoins(tt.coins); result != tt.result {\n\t\tt.Fatalf(\"STR\", tt.coins, tt.result, result)\n\t}\n}\n}"}
{"tgt": "return WordDictionary{}", "gen": "return &Stack{\n\tdata: make([]interface{}, 0, 27),\n}\n}"}
{"tgt": "tcs := []struct {\n\ts   string\n\tans bool\n}{\n\t{\n\t\t\"STR\",\n\t\tfalse,\n\t},\n\t{\n\t\t\"STR\",\n\t\ttrue,\n\t},\n\t{\n\t\t\"STR\",\n\t\tfalse,\n\t},\n\t{\n\t\t\"STR\",\n\t\ttrue,\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, tc := range tcs {\n\tfmt.Printf(\"STR\", tc, isPalindrome(tc.s))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question206{\n\t{\n\t\tpara206{\"STR\", false},\n\t\tans206{STR, true},\n\t},\n\t{\n\t\tpara206{\"STRSTR\", true},\n\t\tans206{STRSTR, true},\n\t},\n\t{\n\t\tpara206{\"STRSTRSTR\", false},\n\t\tans206{STRSTRSTR, true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p, ret := q.para, q.ans, false\n\tif isPalindrome(p) == ret {\n\t\tfmt.Printf(\"STRSTRSTR\")\n\t}\n}\nfmt.Printf(\"STRSTRSTRSTR\")\n}"}
{"tgt": "var drinks []Drink\ninverted := make(map[Drink][]Customer)\nfor cust, favorites := range prefs {\n\tfor _, drink := range favorites {\n\t\tinverted[drink] = append(inverted[drink], cust)\n\t}\n}\ntotalCustomers := len(prefs)\nserved := make(map[Customer]struct{}, totalCustomers)\nfor len(served) < totalCustomers {\n\tvar largest []Customer\n\tvar largestDrink Drink\n\tvar largestIncrease int\n\tfor drink, custs := range inverted {\n\t\tvar newlyServed int\n\t\tfor _, cust := range custs {\n\t\t\tif _, found := served[cust]; !found {\n\t\t\t\tnewlyServed++\n\t\t\t}\n\t\t}\n\t\tif newlyServed > largestIncrease {\n\t\t\tlargestIncrease = newlyServed\n\t\t\tlargestDrink = drink\n\t\t\tlargest = custs\n\t\t}\n\t}\n\tdelete(inverted, largestDrink)\n\tdrinks = append(drinks, largestDrink)\n\tfor _, cust := range largest {\n\t\tserved[cust] = struct{}{}\n\t}\n}\nsort.Slice(drinks, func(i, j int) bool {\n\treturn drinks[i] < drinks[j]\n})\nreturn drinks", "gen": "drinks := make(map[Drink][]Customer)\nfor _, drink := range drinks {\n\tfor _, customer := range drink.Customers {\n\t\tdrinks[drink] = append(drinks[drink], customer)\n\t}\n}\nsort.Slice(drinks, func(i, j int) bool {\n\treturn drinks[i].Customers[0].ID < drinks[j].Customers[0].ID\n})\nreturn drinks\n}"}
{"tgt": "wg.Add(2)\ngoincCounter(1)\ngoincCounter(2)\nwg.Wait()\nfmt.Println(\"STR\", counter)", "gen": "wg.Add(2)\ngo func() {\n\tcounter = 0\n\tfor i := 0; i < 1000000000; i++ {\n\t\tcounter++\n\t}\n}()\ngo func() {\n\tcounter = 0\n\tfor i := 0; i < 1000000000; i++ {\n\t\tcounter++\n\t}\n}()\nwg.Wait()\nfmt.Println(counter)\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{{-1, 2, 1, -4}, {1}}, 2},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tret := threeSumClosest(c.inputs[0], c.inputs[1][0])\n\t\tif !reflect.DeepEqual(ret, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, ret, c.inputs)\n\t\t}\n\t})\n}", "gen": "var s = Solution{\n\tSTR: \"STR\",\n\tSTRS: [][]int{\n\t\t{-1, 2, 1},\n\t},\n\tEXPECT: 1,\n}\nSTRS := []STR{\n\tSTR{STR: \"STR\", STRS: [][]int{\n\t\t{-1, 2, 1},\n\t}, EXPECT: 1},\n}\nfor _, STR := range STRS {\n\tSTR.STR.T.Run(STR.STR, STR.STRS, STR.EXPECT)\n}\n}"}
{"tgt": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 2}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 4}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 4}}},\n\t\tans1037{false},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}, {4, 4}}},\n\t\tans1037{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, p.points, p.points[0], p.points[1], p.points[2], isBoomerang(p.points))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "sort.Slice(words, func(i, j int) bool {\n\tcuri := len(words[i])\n\tcurj := len(words[j])\n\tfor curi > 0 && curj > 0 {\n\t\tcuri--\n\t\tcurj--\n\t\tif words[i][curi] == words[j][curj] {\n\t\t\tcontinue\n\t\t}\n\t\tif words[i][curi] > words[j][curj] {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\treturn curi == 0\n})\nwords = append(words, \"STR\")\nres, i := 0, 1\nfor ; i < len(words); i++ {\n\tif !endWith(words[i], words[i-1]) {\n\t\tres += len(words[i-1]) + 1\n\t}\n}\nreturn res", "gen": "var res []string\nvar i int\nfor i = 0; i < len(words); i++ {\n\tif endWith(words[i], words[i+1]) {\n\t\tres = append(res, words[i])\n\t}\n}\nreturn len(res)\n}"}
{"tgt": "fmt.Println(badLongestPalindrome(\"STR\"))\nfmt.Println(goodLongestPalindrome(\"STR\"))\nfmt.Println(bestLongestPalindrome(\"STR\"))", "gen": "fmt.Println(badLongestPalindrome(\"STR\"))\nfmt.Println(goodLongestPalindrome(\"STR\"))\nfmt.Println(bestLongestPalindrome(\"STR\"))\n}"}
{"tgt": "for i := 0; i < len(A)-1; i++ {\n\tif A[i] == i {\n\t\tcontinue\n\t}\n\tif A[i] == i+1 && A[i+1] == i {\n\t\ti++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var i int\nfor i = 0; i < len(nums)-1; i++ {\n\tif nums[i] == nums[i+1] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "hash := uint32(0)\nfor i := len(sep) - 1; i >= 0; i-- {\n\thash = hash*PrimeRK + uint32(sep[i])\n}\nvar pow, sq uint32 = 1, PrimeRK\nfor i := len(sep); i > 0; i >>= 1 {\n\tif i&1 != 0 {\n\t\tpow *= sq\n\t}\n\tsq *= sq\n}\nreturn hash, pow", "gen": "sum := 0\nfor i := len(nums) - 1; i >= 0; i-- {\n\tsum = (sum * 16777619) + nums[i]\n}\nres := 1\nfor i := len(nums) - 1; i >= 0; i-- {\n\tif (nums[i] & 1) == 1 {\n\t\tres *= 16777619\n\t}\n\tres *= 16777619\n}\nreturn res * sum\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif sum := SumBSTRange(tc.root, tc.a, tc.b); sum != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, sum)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SumBSTRange(tc.root, tc.min, tc.max); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "arr := make([]bool, 105000)\narr[0], arr[1] = true, true\ncount, prime := 2, 3\nvar k int\nfor {\n\tfor k = 2 * prime; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tcount++\n\t\tif count == 10001 {\n\t\t\tprintln(prime)\n\t\t\tbreak\n\t\t}\n\t} else {\n\t\tbreak\n\t}\n}", "gen": "var res = make([]bool, 105000)\nres[0] = true\nres[1] = true\nfor i := 2; i < 105000; i++ {\n\tfor j := 2 * i; j < 105000; j += i {\n\t\tres[j] = true\n\t}\n}\nvar count int\nfor i := 0; i < 105000; i++ {\n\tif !res[i] {\n\t\tcount++\n\t}\n}\nif count == 10001 {\n\tfmt.Println(i)\n}\n}"}
{"tgt": "n1, n2 := len(nums1), len(nums2)\nif n1 > n2 {\n\tn1, n2, nums1, nums2 = n2, n1, nums2, nums1\n}\nm := make(map[int]int, n1)\nfor _, num := range nums1 {\n\tm[num]++\n}\nres := make([]int, 0, n1)\nfor _, num := range nums2 {\n\tif v, ok := m[num]; ok && v > 0 {\n\t\tres = append(res, num)\n\t\tm[num]--\n\t}\n}\nreturn res", "gen": "n := len(nums)\nif n < 2 {\n\treturn nums\n}\nnums = nums[:n]\nm := make(map[int]int)\nfor _, v := range nums {\n\tm[v]++\n}\nres := make([]int, 0)\nfor _, v := range nums {\n\tif m[v] == 1 {\n\t\tres = append(res, v)\n\t}\n}\nreturn res\n}"}
{"tgt": "if root == nil {\n\treturn nil\n}\ns := []*TreeNode{root}\nres := [][]int{}\nzigzag := false\nfor len(s) != 0 {\n\ttmp := []*TreeNode{}\n\tl := []int{}\n\tfor i, node := range s {\n\t\tif zigzag {\n\t\t\tl = append(l, s[len(s)-i-1].Val)\n\t\t} else {\n\t\t\tl = append(l, node.Val)\n\t\t}\n\t\tif node.Left != nil {\n\t\t\ttmp = append(tmp, node.Left)\n\t\t}\n\t\tif node.Right != nil {\n\t\t\ttmp = append(tmp, node.Right)\n\t\t}\n\t}\n\tres = append(res, l)\n\ts = tmp\n\tzigzag = !zigzag\n}\nreturn res", "gen": "if len(preorder) == 0 {\n\treturn nil\n}\nvar root *TreeNode\nfor i := 0; i < len(preorder); i++ {\n\tif !visited {\n\t\troot = &TreeNode{Val: preorder[i]}\n\t\tvisited = true\n\t} else {\n\t\troot.Left = &TreeNode{Val: preorder[i]}\n\t}\n\tif preorder[i] < preorder[0] {\n\t\tvisited = false\n\t}\n}\nreturn root\n}"}
{"tgt": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)", "gen": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)\n}"}
{"tgt": "if len(str) == 0 {\n\treturn 0\n}\nvar (\n\tnum int\n\tneg bool\n)\nfor i, s := range str {\n\tif s != ' ' {\n\t\tstr = str[i:]\n\t\tbreak\n\t}\n}\nif str[0] == '+' {\n\tstr = str[1:]\n} else if str[0] == '-' {\n\tstr = str[1:]\n\tneg = true\n}\nfor _, s := range str {\n\tif s < '0' || s > '9' {\n\t\tbreak\n\t}\n\tnum = num*10 + int(s-'0')\n\tif num > 2147483648 {\n\t\tnum = 2147483648\n\t\tbreak\n\t}\n}\nif neg {\n\tnum *= -1\n} else if num > 2147483647 {\n\tnum = 2147483647\n}\nreturn num", "gen": "if len(s) == 0 {\n\treturn 0\n}\nvar sum int\nvar isNegative bool\nfor i := 0; i < len(s); i++ {\n\tif s[i] == ' ' {\n\t\tcontinue\n\t}\n\tif s[i] == '+' {\n\t\tisNegative = false\n\t} else if s[i] == '-' {\n\t\tisNegative = true\n\t} else {\n\t\tif isNegative {\n\t\t\tsum -= int(s[i] - '0')\n\t\t} else {\n\t\t\tsum += int(s[i] - '0')\n\t\t}\n\t}\n}\nif sum > 2147483647 {\n\treturn 2147483647\n}\nif sum < -2147483648 {\n\treturn -2147483648\n}\nif isNegative {\n\treturn -sum\n}\nreturn sum\n}"}
{"tgt": "ans, m, n := []int{}, len(matrix), len(matrix[0])\nfor j := 0; j < n; j++ {\n\tmax, rowIndex := 1, 0\n\tfor i := 0; i < m; i++ {\n\t\tif matrix[i][j] > max {\n\t\t\tmax = matrix[i][j]\n\t\t\trowIndex = i\n\t\t}\n\t}\n\tif Min(matrix[rowIndex]) == max {\n\t\tans = append(ans, max)\n\t}\n}\nreturn ans", "gen": "res := []int{}\nfor i := 0; i < len(nums); i++ {\n\tmin := nums[i]\n\tfor j := i + 1; j < len(nums); j++ {\n\t\tif nums[j] < min {\n\t\t\tmin = nums[j]\n\t\t}\n\t}\n\tres = append(res, min)\n}\nreturn res\n}"}
{"tgt": "strNumber := strconv.Itoa(number)\nfor _, runeDigit := range []rune(strNumber) {\n\tdigit := int(runeDigit - '0')\n\tlist = append(list, digit)\n}\nreturn", "gen": "str := strconv.Itoa(num)\nvar res []int\nfor _, r := range []rune(str) {\n\tres = append(res, int(r-'0'))\n}\nreturn res\n}"}
{"tgt": "if num == 0 {\n\treturn \"STR\"\n}\nh := []string{\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\",\n\t\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\"}\nres := \"STR\"\nfor i := 0; i < 8 && num != 0; i++ {\n\tres = h[num&15] + res\n\tnum >>= 4\n}\nreturn res", "gen": "if n == 0 {\n\treturn \"STR\"\n}\nvar res string\nfor i := 0; i < 8; i++ {\n\tres += strings.ToUpper(strconv.Itoa(n & 15))\n\tn >>= 4\n}\nreturn res\n}"}
{"tgt": "if len(n.Exprs) == 0 {\n\treturn TypeString, nil\n}\nif len(n.Exprs) == 1 {\n\texprType, err := n.Exprs[0].Type(s)\n\tif err != nil {\n\t\treturn TypeInvalid, err\n\t}\n\tswitch exprType {\n\tcase TypeList:\n\t\treturn TypeList, nil\n\tcase TypeMap:\n\t\treturn TypeMap, nil\n\t}\n}\nfor index, expr := range n.Exprs {\n\texprType, err := expr.Type(s)\n\tif err != nil {\n\t\treturn TypeInvalid, err\n\t}\n\tif exprType == TypeList || exprType == TypeMap {\n\t\treturn TypeInvalid, fmt.Errorf(\n\t\t\t\"STR\",\n\t\t\tindex, exprType)\n\t}\n}\nreturn TypeString, nil", "gen": "if len(n.Children) == 0 {\n\treturn 8, nil\n}\nif len(n.Children) == 1 {\n\treturn n.Children[0].eval()\n}\nif len(n.Children) > 128 {\n\treturn 0, fmt.Errorf(\"too many children\")\n}\nvar res int\nfor _, c := range n.Children {\n\tr, err := c.eval()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tres += r\n}\nreturn res, nil\n}"}
{"tgt": "psum, min := 0, 1\nfor _, val := range nums {\n\tpsum += val\n\tif psum < min {\n\t\tmin = psum\n\t}\n}\nif min > 0 {\n\treturn min\n}\nreturn -min + 1", "gen": "sum := 0\nmax := 1\nfor _, v := range nums {\n\tsum += v\n\tif sum > max {\n\t\tmax = sum\n\t}\n\tif sum < 0 {\n\t\tsum = 0\n\t}\n}\nif max == 0 {\n\treturn 1\n}\nreturn max\n}"}
{"tgt": "arr := make([]bool, 2000000)\narr[0], arr[1] = true, true\nsum, prime := int64(5), 3\nvar k int\nfor {\n\tfor k = 2 * prime; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tsum += int64(k)\n\t} else {\n\t\tbreak\n\t}\n}\nprintln(sum)", "gen": "var res = make([]bool, 2000000)\nres[0] = true\nres[1] = true\nfor i := 2; i < 2000000; i++ {\n\tfor j := 2 * i; j < 2000000; j += i {\n\t\tres[j] = true\n\t}\n}\nvar count int\nfor i := 0; i < 2000000; i++ {\n\tif res[i] {\n\t\tcount++\n\t}\n}\nfor i := 0; i < 2000000; i++ {\n\tif res[i] {\n\t\tcount++\n\t}\n}\nfor i := 0; i < 2000000; i++ {\n\tif res[i] {\n\t\tcount++\n\t}\n}\nfor i := 0; i < 2000000; i++ {\n\tif res[i] {\n\t\tcount++\n\t}\n}\nfor i := 0; i < 2000000; i++ {\n\tif res[i] {\n\t\tcount++\n\t}\n}\nfor i := 0; i < 2000000; i++ {\n\tif res[i] {\n\t\tcount++\n\t}\n}\nfor i := 0; i < 2000000; i++ {\n\tif res[i] {\n\t\tcount++\n\t}\n}\nfor i := 0; i < 2000000; i++ {\n\tif res[i] {\n\t\tcount++\n\t}\n}\nfor i := 0; i < 2000000; i++ {\n\tif res[i] {\n\t\tcount++\n\t}\n}"}
{"tgt": "qs := []question693{\n\t{\n\t\tpara693{5},\n\t\tans693{true},\n\t},\n\t{\n\t\tpara693{7},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{11},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{10},\n\t\tans693{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans693, q.para693\n\tfmt.Printf(\"STR\", p, hasAlternatingBits(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question693{\n\t{\n\t\tpara693{5},\n\t\tans693{true},\n\t},\n\t{\n\t\tpara693{7},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{11},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{10},\n\t\tans693{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans693, q.para693\n\tfmt.Printf(\"STR\", p, hasAlternatingBits(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "sum := 0\nfor i := 1; i <= n; i++ {\n\tsquare := i * i\n\tsum += square\n}\nreturn sum", "gen": "sum := 0\nfor i := 1; i <= n; i++ {\n\tsum += i * i\n}\nreturn sum\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.nums); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.left, tc.right); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.left, tc.right, tc.expected, result)\n\t}\n}\n}"}
{"tgt": "var i int\nfor j, k := 0, 0; j < len(nums); j = k {\n\tfor k < len(nums) && nums[j] == nums[k] {\n\t\tif k < j+2 {\n\t\t\tnums[i] = nums[k]\n\t\t\ti++\n\t\t}\n\t\tk++\n\t}\n}\nreturn i", "gen": "var i, j int\nfor i = 0; i < len(nums); i++ {\n\tfor j = i + 1; j < len(nums); j++ {\n\t\tif nums[i] > nums[j] {\n\t\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\t\ti++\n\t\t}\n\t}\n}\nreturn i\n}"}
{"tgt": "result := make([]int, 0, len(left)+len(right))\nfor len(left) > 0 || len(right) > 0 {\n\tif len(left) == 0 {\n\t\treturn append(result, right...)\n\t}\n\tif len(right) == 0 {\n\t\treturn append(result, left...)\n\t}\n\tif left[0] <= right[0] {\n\t\tresult = append(result, left[0])\n\t\tleft = left[1:]\n\t} else {\n\t\tresult = append(result, right[0])\n\t\tright = right[1:]\n\t}\n}\nreturn result", "gen": "res := make([]int, 0, len(nums))\nfor i := 0; i < len(nums); i++ {\n\tif i == 0 || nums[i] != nums[i-1] {\n\t\tres = append(res, nums[i])\n\t}\n}\nif len(nums) > 0 && nums[len(nums)-1] == nums[len(nums)-2] {\n\tres = append(res, nums[len(nums)-1])\n}\nreturn res\n}"}
{"tgt": "if 0 == n {\n\treturn 0\n} else {\n\treturn n/5 + trailingZeroes(n/5)\n}", "gen": "if n == 0 {\n\treturn 0\n}\nreturn trailingZeroes(n / 5) + n/5\n}"}
{"tgt": "n := len(s)\nuf := newUnionFind(n)\nfor _, p := range pairs {\n\tuf.connect(p[0], p[1])\n}\ngroups := make(map[int][]int, n)\nfor c, p := range uf.parent {\n\tp = uf.find(p)\n\tgroups[p] = append(groups[p], c)\n}\nbytes := []byte(s)\nres := make([]byte, n)\nfor _, g := range groups {\n\tsize := len(g)\n\ta := make([]int, size)\n\tcopy(a, g)\n\tsort.Slice(a, func(i, j int) bool {\n\t\treturn bytes[a[i]] < bytes[a[j]]\n\t})\n\tsort.Ints(g)\n\tfor i := 0; i < size; i++ {\n\t\tres[g[i]] = bytes[a[i]]\n\t}\n}\nreturn string(res)", "gen": "uf := newUnionFind(len(strs))\nfor i := 0; i < len(strs); i++ {\n\tfor j := i + 1; j < len(strs); j++ {\n\t\tif strs[i][0] == strs[j][0] {\n\t\t\tuf.connect(i, j)\n\t\t}\n\t}\n}\nm := make(map[int][]int)\nfor i := 0; i < len(strs); i++ {\n\tfor j := 0; j < len(strs); j++ {\n\t\tif uf.find(i) == uf.find(j) {\n\t\t\tm[i] = append(m[i], j)\n\t\t}\n\t}\n}\nvar res string\nfor k, v := range m {\n\tsort.Ints(v)\n\tfor _, i := range v {\n\t\tres += string(strs[i][k])\n\t}\n}\nreturn res\n}"}
{"tgt": "data := [][]int{\n\t{2},\n\t{3, 4},\n\t{6, 5, 7},\n\t{4, 1, 8, 3}}\nfmt.Println(minimumTotal(data))", "gen": "fmt.Println(minimumTotal([][]int{{2}, {3}, {4}, {6}, {5}, {7}, {4}, {1}, {8}, {3}}))\n}"}
{"tgt": "left, right, res := 0, -1, 0\nfor left < len(s) {\n\tif right+1 < len(s) && maxCost-abs(int(s[right+1]-'a')-int(t[right+1]-'a')) >= 0 {\n\t\tright++\n\t\tmaxCost -= abs(int(s[right]-'a') - int(t[right]-'a'))\n\t} else {\n\t\tres = max(res, right-left+1)\n\t\tmaxCost += abs(int(s[left]-'a') - int(t[left]-'a'))\n\t\tleft++\n\t}\n}\nreturn res", "gen": "var i, j, max int\nfor i = 0; i < len(s); i++ {\n\tif s[i] == 'I' {\n\t\tj = i + 1\n\t\tfor j < len(s) && s[j] == 'I' {\n\t\t\tj++\n\t\t}\n\t\tif j < len(s) {\n\t\t\tmax = maxInt(max, abs(i-j))\n\t\t}\n\t} else {\n\t\tmax = maxInt(max, abs(i-j))\n\t}\n}\nreturn max\n}"}
{"tgt": "nums := []int{}\nfor n != 0 {\n\tnums = append(nums, n%10)\n\tn /= 10\n}\nm := len(nums)\nif m < 2 {\n\treturn -1\n}\ni := 1\nfor i < m {\n\tif nums[i] < nums[i-1] {\n\t\tbreak\n\t}\n\ti++\n}\nif i == m {\n\treturn -1\n}\nj := 0\nfor j < i {\n\tif nums[j] > nums[i] {\n\t\tbreak\n\t}\n\tj++\n}\nnums[i], nums[j] = nums[j], nums[i]\nfor k := 0; k < i/2; k++ {\n\tnums[k], nums[i-k-1] = nums[i-k-1], nums[k]\n}\nres := 0\np := 1\nfor _, n := range nums {\n\tres += n * p\n\tp *= 10\n}\nif res > math.MaxInt32 {\n\treturn -1\n}\nreturn res", "gen": "nums := []int{}\nfor i := 0; i < len(nums); i++ {\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append(nums, i)\n\tnums = append"}
{"tgt": "x := []int{10, 20, 30, 40, 50}\nfor k, v := range x {\n\tfmt.Printf(\"STR\", k, v)\n}", "gen": "var a = []int{10, 20, 30, 40, 50}\nfor i, v := range a {\n\tfmt.Printf(\"STR\", i, v)\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif jumps, impassable := MinimumJumps(tc.maxSteps); impassable != tc.impassable || jumps != tc.expectedJumps {\n\t\tt.Errorf(\"STR\", tc.expectedJumps, tc.impassable, jumps, impassable)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := MinimumJumps(tc.input); !reflect.DeepEqual(res, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, res)\n\t}\n}\n}"}
{"tgt": "c.bw.WriteString(\"STR\")\nc.bw.WriteByte(space)\nc.bw.WriteString(key)\nc.bw.WriteByte(space)\nc.bw.Write(strconv.AppendInt(c.numScratch[:0], int64(timeout), 10))\n_, err = c.bw.Write(crlf)\nreturn", "gen": "w.WriteString(\"VALUE \")\nw.WriteString(key)\nw.WriteByte(' ')\nw.WriteString(strconv.Itoa(int(flags)))\nw.WriteString(\" \" + strconv.Itoa(len(value)))\nw.WriteString(crlf)\nw.WriteString(value)\nw.WriteString(crlf)\nreturn w.Flush()\n}"}
{"tgt": "if len(s) == 0 {\n\treturn \"STR\"\n}\nstart := 0\nmaxLen := 1\nfor index := range s {\n\tl := index - maxLen\n\tend := index + 1\n\tif l >= 1 && sym(s[l-1:end]) {\n\t\tstart = l - 1\n\t\tmaxLen += 2\n\t} else if l >= 0 && sym(s[l:end]) {\n\t\tstart = l\n\t\tmaxLen += 1\n\t}\n}\nreturn s[start : start+maxLen]", "gen": "if len(s) == 0 {\n\treturn \"STR\"\n}\nvar i, j int\nfor i = 0; i < len(s); i++ {\n\tif s[i] < 128 {\n\t\tcontinue\n\t}\n\tj = i + 1\n\tfor j < len(s) {\n\t\tif s[j] < 128 {\n\t\t\tbreak\n\t\t}\n\t\tif sym(s[i], s[j]) {\n\t\t\ti++\n\t\t}\n\t\tj++\n\t}\n}\nreturn s[:i]\n}"}
{"tgt": "http.HandleFunc(path, func(res http.ResponseWriter, req *http.Request) {\n\terr := handleFunc(res, req)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), 500)\n\t}\n})", "gen": "return http.HandleFunc(\"/\", handle)\n}"}
{"tgt": "kind := t.Kind()\nif kind >= Int && kind <= Complex128 {\n\treturn int(t.Size()) * 8\n}\npanic(TypeError{\"STR\"})", "gen": "switch t.Kind() {\ncase reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr, reflect.Float32, reflect.Float64, reflect.Complex64, reflect.Complex128, reflect.String:\n\treturn t.Size() * 8\ndefault:\n\tpanic(TypeError{STR})\n}\n}"}
{"tgt": "println(\"STR\", len(a))", "gen": "println(\"STR\", len(s))\n}"}
{"tgt": "return e.Errs[0].Error()", "gen": "return t.root.Left.Value\n}"}
{"tgt": "stack := make([]int, 0)\nresult := make([]int, len(T))\nfor i, t := range T {\n\tfor len(stack) > 0 && T[stack[len(stack)-1]] < t {\n\t\tresult[stack[len(stack)-1]] = i - stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t}\n\tstack = append(stack, i)\n}\nfor _, i := range stack {\n\tresult[i] = 0\n}\nreturn result", "gen": "res := make([]int, 0)\nfor _, num := range nums {\n\tif len(res) == 0 || res[len(res)-1] < num {\n\t\tres = append(res, num)\n\t} else {\n\t\tres[len(res)-1] = num\n\t}\n}\nfor i := 0; i < len(res); i++ {\n\tres[i] = 0\n\tfor j := 0; j < len(res); j++ {\n\t\tif res[i] < res[j] {\n\t\t\tres[i] = res[j]\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "h := new(IntArray)\nh.heapIntArrays = arr\nh.heap.binHeapArrayIf = &h.heapIntArrays\nh.BuildHeap()\nreturn h", "gen": "h := &heapIntArrays{\n\tHead:    &heapIntArrays.Head,\n\tKey:     &heapIntArrays.Key,\n\tLast:    &heapIntArrays.Last,\n\tLen:     &heapIntArrays.Len,\n\tNext:    &heapIntArrays.Next,\n\tParent:  &heapIntArrays.Parent,\n\tPrev:    &heapIntArrays.Prev,\n\tRight:   &heapIntArrays.Right,\n\tSwap:    &heapIntArrays.Swap,\n\tUnion:   &heapIntArrays.Union,\n\tValid:   &heapIntArrays.Valid,\n\tValue:   &heapIntArrays.Value,\n\tarrays:  arrays,\n}\nh.BuildHeap()\nreturn h\n}"}
{"tgt": "if n == 1 || n == 2 {\n\treturn big.NewInt(1)\n}\nif mem[n] != nil {\n\treturn mem[n]\n}\nresult := big.NewInt(0)\nresult.Add(FibonacciHelper(n-1, mem), FibonacciHelper(n-2, mem))\nmem[n] = result\nreturn result", "gen": "if n == 1 || n == 2 {\n\treturn big.NewInt(1)\n}\nif n < 0 {\n\treturn big.NewInt(0)\n}\nreturn FibonacciHelper(n-1, 1, 1)\n}"}
{"tgt": "coins := []int{1, 2, 5, 10, 20, 50, 100, 200}\nmemo := make(map[string]int)\nreturn findAllWays(coins, 0, n, memo)", "gen": "var nums = []int{1, 2, 5, 10, 20, 50, 100, 200}\nm := make(map[int]int)\nfor _, n := range nums {\n\tm[n] = 0\n}\nreturn findAllWays(m, 0)\n}"}
{"tgt": "data, err := base64.StdEncoding.DecodeString(b64)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(data)", "gen": "decoded, err := StdEncoding.DecodeString(str)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(decoded)\n}"}
{"tgt": "qs := []question322{\n\t{\n\t\tpara322{[]int{186, 419, 83, 408}, 6249},\n\t\tans322{20},\n\t},\n\t{\n\t\tpara322{[]int{1, 2147483647}, 2},\n\t\tans322{2},\n\t},\n\t{\n\t\tpara322{[]int{1, 2, 5}, 11},\n\t\tans322{3},\n\t},\n\t{\n\t\tpara322{[]int{2}, 3},\n\t\tans322{-1},\n\t},\n\t{\n\t\tpara322{[]int{1}, 0},\n\t\tans322{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans322, q.para322\n\tfmt.Printf(\"STR\", p, coinChange(p.one, p.amount))\n}\nfmt.Printf(\"STR\")", "gen": "var tests = []struct {\n\tcoins  []int\n\tamount int\n\texpect int\n}{\n\t{[]int{186, 419, 83, 408}, 20, 6249},\n\t{[]int{1, 2147483647}, 2, -1},\n\t{[]int{1, 2, 5, 11}, 3, 11},\n\t{[]int{1, 2, 3}, 1, 1},\n\t{[]int{1, 2, 3}, 2, 2},\n\t{[]int{1, 2, 3}, 3, 3},\n\t{[]int{1}, 1, 1},\n\t{[]int{1}, 2, 1},\n\t{[]int{1}, 3, 1},\n\t{[]int{1}, 4, 1},\n\t{[]int{1}, 5, 1},\n\t{[]int{1}, 6, 1},\n\t{[]int{1}, 7, 1},\n\t{[]int{1}, 8, 1},\n\t{[]int{1}, 9, 1},\n\t{[]int{1}, 10, 1},\n\t{[]int{1}, 11, 1},\n\t{[]int{1}, 12, 1},\n\t{[]int{1}, 13, 1},\n\t{[]int{1}, 14, 1},\n\t{[]int{1}, 15, 1},\n\t{[]int{1}, 16, 1},\n\t{[]int{1}, 17, 1},\n\t{[]int{1}, 18, 1},\n\t{[]int{1}, 19, 1},\n\t{[]int{1}, 20, 1},\n}\nfor _, tt :="}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.locs); !reflect.DeepEqual(bonuses, tc.bonuses) {\n\t\tt.Errorf(\"STR\", tc.bonuses, bonuses)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.input); !reflect.DeepEqual(bonuses, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, bonuses)\n\t}\n}\n}"}
{"tgt": "count := uint32(0)\nfor num != 0 {\n\tcount += num & 1\n\tnum = num >> 1\n}\nreturn int(count)", "gen": "res := 0\nfor n != 0 {\n\tres += n & 1\n\tn >>= 1\n}\nreturn res\n}"}
{"tgt": "var sum int\nfor _, num := range nums {\n\tsum += num\n}\nif sum%2 != 0 {\n\treturn false\n}\nc := sum / 2\nn := len(nums)\nmemo := make([]bool, c+1)\nfor i := 0; i <= c; i++ {\n\tmemo[i] = nums[0] == i\n}\nfor i := 0; i < n; i++ {\n\tfor j := c; j >= nums[i]; j-- {\n\t\tmemo[j] = memo[j] || memo[j-nums[i]]\n\t}\n}\nreturn memo[c]", "gen": "sum := 0\nfor _, num := range nums {\n\tsum += num\n}\nif sum%2 == 1 {\n\treturn false\n}\noddCount := sum / 2\noddCount--\nodd := make([]bool, oddCount+1)\nfor i := 0; i < len(nums); i++ {\n\tfor j := 0; j < len(nums); j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tif odd[j] && nums[i] == nums[j] {\n\t\t\todd[j] = false\n\t\t\todd[i] = false\n\t\t}\n\t}\n}\nfor i := 0; i < len(nums); i++ {\n\tif odd[i] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "count1 := 0\nfor _, r := range S {\n\tif r == '(' {\n\t\tcount1++\n\t} else if count1 > 0 {\n\t\tcount1--\n\t}\n}\ncount2 := 0\nfor i := len(S) - 1; i >= 0; i-- {\n\tif S[i] == ')' {\n\t\tcount2++\n\t} else if count2 > 0 {\n\t\tcount2--\n\t}\n}\nreturn count1 + count2", "gen": "count := 0\nfor _, c := range s {\n\tif c == '(' {\n\t\tcount++\n\t} else if c == ')' {\n\t\tif count == 0 {\n\t\t\treturn -1\n\t\t}\n\t\tcount--\n\t}\n}\nif count != 0 {\n\treturn -1\n}\nleft, right := 0, 0\nfor i := len(s) - 1; i >= 0; i-- {\n\tif s[i] == '(' {\n\t\tleft++\n\t} else if s[i] == ')' {\n\t\tif left == 0 {\n\t\t\treturn -1\n\t\t}\n\t\tleft--\n\t}\n}\nreturn left + right\n}"}
{"tgt": "for i := rangeMin; i <= rangeMax; i++ {\n\tif evenlyDivisble%i != 0 {\n\t\tevenlyDivisble = evenlyDivisble * lcm(evenlyDivisble, i)\n\t}\n\tfmt.Println(evenlyDivisble, \"STR\", i, \"STR\", evenlyDivisble/i)\n}", "gen": "for rangeMin := 2; rangeMin <= rangeMax; rangeMin++ {\n\tif evenlyDivisble%rangeMin != 0 {\n\t\tevenlyDivisble = lcm(evenlyDivisble, rangeMin)\n\t}\n}\nfmt.Println(evenlyDivisble)\nfmt.Println(evenlyDivisble)\n}"}
{"tgt": "log.SetFlags(0)\nvar err error\ntpl := template.New(\"STR\")\ntpl = tpl.Funcs(template.FuncMap{\n\t\"STR\": func(str string) string {\n\t\treturn strings.ToUpper(str)\n\t},\n})\ntpl, err = tpl.ParseFiles(\"STR\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nerr = tpl.ExecuteTemplate(os.Stdout, \"STR\", Page{\n\tTitle: \"STR\",\n\tBody:  \"STR\",\n})\nif err != nil {\n\tlog.Fatalln(err)\n}", "gen": "log.SetFlags(log.Lshortfile)\nt := template.New(\"\").Funcs(map[string]interface{}{\n\t\"STR\": STR,\n})\nt, err = t.ParseFiles(\"template.html\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nt.ExecuteTemplate(os.Stdout, \"STR\", Page{\n\tTitle: \"STR\",\n})\n}"}
{"tgt": "return append(ints, added...)", "gen": "if len(s) < len(t) {\n\ts = append(s, make([]int, len(t)-len(s))...)\n}\nreturn s\n}"}
{"tgt": "left, right := 0, len(nums)-1\nfor left < right {\n\tmid := (left + right) / 2\n\tcount := 0\n\tfor _, num := range nums {\n\t\tif num <= mid {\n\t\t\tcount++\n\t\t}\n\t}\n\tif count > mid {\n\t\tright = mid\n\t} else {\n\t\tleft = mid + 1\n\t}\n}\nreturn left", "gen": "left, right := 0, len(nums)-1\nfor left < right {\n\tmid := (left + right) / 2\n\tif nums[mid] < target {\n\t\tleft = mid + 1\n\t} else if nums[mid] > target {\n\t\tright = mid - 1\n\t} else {\n\t\tright = mid\n\t}\n}\nreturn left\n}"}
{"tgt": "var min int\ntotalPeople := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\ttotalPeople++\n\t}\n}\nif totalPeople < 2 {\n\treturn 0\n}\nmiddle := (totalPeople / 2) + (totalPeople % 2)\nindex := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\tmiddle--\n\t}\n\tif middle == 0 {\n\t\tindex = i\n\t\tbreak\n\t}\n}\nleftZero := 0\nleftZeroFound := false\nfor j := index - 1; j >= 0; j-- {\n\tif !leftZeroFound && seating[j] == 0 {\n\t\tleftZero = j\n\t\tleftZeroFound = true\n\t} else if seating[j] == 1 && j < leftZero {\n\t\tmin += abs(j - leftZero)\n\t\tleftZero--\n\t}\n}\nrightZero := 0\nrightZeroFound := false\nfor j := index + 1; j < len(seating); j++ {\n\tif !rightZeroFound && seating[j] == 0 {\n\t\trightZero = j\n\t\trightZeroFound = true\n\t} else if seating[j] == 1 && j > rightZero {\n\t\tmin += abs(j - rightZero)\n\t\trightZero++\n\t}\n}\nreturn min", "gen": "var sum, count int\nfor _, n := range nums {\n\tif n == 1 {\n\t\tcount++\n\t}\n}\nvar i, j int\nfor i = 0; i < count; i++ {\n\tfor j = 0; j < len(nums); j++ {\n\t\tif nums[j] == 1 {\n\t\t\tsum++\n\t\t}\n\t}\n\tfor j = 0; j < len(nums); j++ {\n\t\tif nums[j] == 1 {\n\t\t\tsum--\n\t\t}\n\t}\n}\nfor i = 0; i < len(nums); i++ {\n\tif nums[i] == 1 {\n\t\tsum++\n\t}\n}\nreturn sum\n}"}
{"tgt": "targetRange := []int{-1, -1}\nfor i := 0; i < len(nums); i++ {\n\tif nums[i] == target {\n\t\ttargetRange[0] = i\n\t\tbreak\n\t}\n}\nif targetRange[0] == -1 {\n\treturn targetRange\n}\nfor j := len(nums) - 1; j >= 0; j-- {\n\tif nums[j] == target {\n\t\ttargetRange[1] = j\n\t\tbreak\n\t}\n}\nreturn targetRange", "gen": "var res []int\nres = append(res, -1)\nres = append(res, -1)\nfor i := 0; i < len(nums); i++ {\n\tif nums[i] == target {\n\t\tres[1] = i\n\t\treturn res\n\t}\n}\nfor i := len(nums) - 1; i >= 0; i-- {\n\tif nums[i] == target {\n\t\tres[0] = i\n\t\treturn res\n\t}\n}\nreturn res\n}"}
{"tgt": "var tests = []struct {\n\tbefore []int\n\tafter  *ListNode\n}{\n\t{[]int{}, nil},\n\t{[]int{1}, newList(1)},\n\t{[]int{1, 2, 3, 4, 5}, newList(1, 3, 5, 2, 4)},\n\t{[]int{1, 2, 3, 4, 5, 6}, newList(1, 3, 5, 2, 4, 6)},\n\t{[]int{2, 1, 3, 5, 6, 4, 7}, newList(2, 3, 6, 7, 1, 5, 4)},\n}\nfor _, tt := range tests {\n\tafter := oddEvenList(newList(tt.before...))\n\tif reflect.DeepEqual(after, tt.after) == false {\n\t\tt.Errorf(\"STR\", newList(tt.before...), after, tt.after)\n\t}\n}", "gen": "l1 := newList([]int{1})\nl2 := newList([]int{1, 3, 5})\nl3 := newList([]int{2, 4})\nl4 := newList([]int{1, 3, 5, 2, 4})\nl5 := newList([]int{1, 3, 5, 6})\nl6 := newList([]int{2, 3, 4, 5, 6})\nl7 := newList([]int{1, 2, 3, 4, 5, 6, 7})\nl8 := newList([]int{1, 3, 5, 6, 7})\nl9 := newList([]int{1, 2, 3, 4, 5, 6, 7})\ntests := []struct {\n\tl1, l2 *ListNode\n\twant   *ListNode\n}{\n\t{l1, l2, l3},\n\t{l1, l4, l5},\n\t{l1, l6, l7},\n\t{l1, l8, l9},\n}\nfor _, tt := range tests {\n\tgot := oddEvenList(tt.l1)\n\tif !reflect.DeepEqual(got, tt.want) {\n\t\tt.Errorf(\"STR\", tt.l1, tt.l2, tt.want, got)\n\t}\n}\n}"}
{"tgt": "out := 45228\nif x := p32(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "if p32(45228) != 45228 {\n\tt.Errorf(\"STR\", 45228)\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SecondLargest(tc.root); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := SecondLargest(tc.nums); res != tc.secondLargest {\n\t\tt.Errorf(\"STR\", tc.secondLargest, res)\n\t}\n}\n}"}
{"tgt": "primes := [...]int{2: 1, 3: 1, 5: 1, 7: 1, 11: 1, 13: 1, 17: 1, 19: 1}\nres := 0\nfor i := L; i <= R; i++ {\n\tbits := 0\n\tfor n := i; n > 0; n >>= 1 {\n\t\tbits += n & 1\n\t}\n\tres += primes[bits]\n}\nreturn res", "gen": "var res int\nfor i := 0; i < 20; i++ {\n\tvar sum int\n\tfor j := 0; j < 20; j++ {\n\t\tsum += (i >> j) & 1\n\t}\n\tif sum == 0 {\n\t\tres += i\n\t}\n}\nreturn res\n}"}
{"tgt": "qs := []question1232{\n\t{\n\t\tpara1232{[][]int{{1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6}, {6, 7}}},\n\t\tans1232{true},\n\t},\n\t{\n\t\tpara1232{[][]int{{1, 1}, {2, 2}, {3, 4}, {4, 5}, {5, 6}, {7, 7}}},\n\t\tans1232{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1232, q.para1232\n\tfmt.Printf(\"STR\", p, checkStraightLine(p.arr))\n}\nfmt.Printf(\"STR\")", "gen": "var res = [][]int{\n\t{1, 2},\n\t{2, 3},\n\t{3, 4},\n\t{4, 5},\n\t{5, 6},\n\t{7, 7},\n}\nvar cases = []struct {\n\tpoints [][]int\n\texpect bool\n}{\n\t{\n\t\tpoints: [][]int{\n\t\t\t{1, 2},\n\t\t\t{2, 3},\n\t\t\t{3, 4},\n\t\t\t{4, 5},\n\t\t\t{5, 6},\n\t\t},\n\t\texpect: true,\n\t},\n\t{\n\t\tpoints: [][]int{\n\t\t\t{1, 1},\n\t\t\t{2, 2},\n\t\t\t{3, 4},\n\t\t\t{4, 5},\n\t\t\t{5, 6},\n\t\t},\n\t\texpect: false,\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, c := range cases {\n\tfmt.Printf(\"STR\", c.points, c.expect)\n\tactual := checkStraightLine(c.points)\n\tif actual != c.expect {\n\t\tt.Fatal(c.points, actual, c.expect)\n\t}\n}\n}"}
{"tgt": "var tests = []struct {\n\tnums    []int\n\tmissing int\n}{\n\t{[]int{1, 1}, 2},\n\t{[]int{1, 2, 0}, 3},\n\t{[]int{3, 4, -1, 1}, 2},\n\t{[]int{7, 8, 9, 11, 12}, 1},\n}\nfor _, tt := range tests {\n\tnums := make([]int, len(tt.nums))\n\tcopy(nums, tt.nums)\n\tmissing := firstMissingPositive(tt.nums)\n\tif missing != tt.missing {\n\t\tt.Errorf(\"STR\", nums, missing, tt.missing)\n\t}\n}", "gen": "tests := []struct {\n\tnums []int\n\texp  int\n}{\n\t{[]int{1, 2, 3}, 4},\n\t{[]int{1, 2, 3, 4}, 1},\n\t{[]int{1, 2, 3, 4, 5}, 6},\n\t{[]int{1, 2, 3, 4, 5, 6}, 7},\n\t{[]int{1, 2, 3, 4, 5, 6, 7}, 8},\n\t{[]int{1, 2, 3, 4, 5, 6, 7, 8}, 9},\n\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9}, 11},\n\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 12},\n\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}, 13},\n\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, 14},\n\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}, 15},\n\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}, 16},\n\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 1"}
{"tgt": "if nil == head || nil == head.Next ||\n\tm == n {\n\treturn head\n}\nstep := n - m\nvar leftTail *ListNode\np := head\nfor m > 1 {\n\tleftTail = p\n\tp = p.Next\n\tm--\n}\nq := p.Next\np.Next = nil\nmidTail := p\nfor step > 0 {\n\tr := q.Next\n\tq.Next = p\n\tp = q\n\tq = r\n\tstep--\n}\nif nil == leftTail {\n\tmidTail.Next = q\n\treturn p\n}\nleftTail.Next = p\nmidTail.Next = q\nreturn head", "gen": "if root == nil || root.Left == nil {\n\treturn root\n}\nif root.Val == val {\n\treturn root.Left\n}\nfor root.Val > val {\n\troot = root.Left\n\tval = root.Val\n}\nroot.Left.Right = root.Right\nroot.Right = root.Left\nreturn root\n}"}
{"tgt": "var tests = []struct {\n\ttree  *TreeNode\n\tdepth int\n}{\n\t{newTree(3, 9, 20, nil, nil, 15, 7), 2},\n\t{newTree(1, 2), 2},\n\t{newTree(1, 2, 2, 3), 2},\n\t{newTree(1, 2, 2, 3, 3, nil, nil, 4, 4), 2},\n\t{newTree(1, 2, 2, 3, nil, 3, 3, 4), 3},\n\t{newTree(1, 2, 2, nil, nil, nil, 3, 4, 4), 2},\n}\nfor _, tt := range tests {\n\tdepth := minDepth(tt.tree)\n\tif depth != tt.depth {\n\t\tt.Errorf(\"STR\", tt.tree, depth, tt.depth)\n\t}\n}", "gen": "var nodes = []*TreeNode{\n\tnewTree([]int{0}),\n\tnewTree([]int{0, 1}),\n\tnewTree([]int{0, 1, 2}),\n\tnewTree([]int{0, 1, 2, 3}),\n\tnewTree([]int{0, 1, 2, 3, 4}),\n\tnewTree([]int{0, 1, 2, 3, 4, 5}),\n\tnewTree([]int{0, 1, 2, 3, 4, 5, 6}),\n\tnewTree([]int{0, 1, 2, 3, 4, 5, 6, 7}),\n\tnewTree([]int{0, 1, 2, 3, 4, 5, 6, 7, 8}),\n}\nfor i := 0; i < len(nodes); i++ {\n\tif minDepth(nodes[i]) != i {\n\t\tt.Errorf(\"STR\", i, minDepth(nodes[i]), i)\n\t}\n}\n}"}
{"tgt": "t.Parallel()\nd := NewTimeMap()\nd.Set(1, 1, 0)\nd.Set(1, 2, 2)\nif result := d.Get(1, 1); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 3); result != 2 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 5)\nif result := d.Get(1, 0); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 10); result != 1 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 0)\nd.Set(1, 2, 0)\nif result := d.Get(1, 0); result != 2 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(2, 0); result != nil {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, -1); result != nil {\n\tt.Errorf(\"STR\")\n}", "gen": "t.Parallel()\ntm := NewTimeMap()\ntm.Set(0, 0)\ntm.Set(2, 2)\nif tm.Get(0) != 0 {\n\tt.Errorf(\"STR\", 0, 0, tm.Get(0))\n}\nif tm.Get(2) != 2 {\n\tt.Errorf(\"STR\", 2, 2, tm.Get(2))\n}\ntm.Set(1, 1)\nif tm.Get(1) != 1 {\n\tt.Errorf(\"STR\", 1, 1, tm.Get(1))\n}\ntm.Set(3, 3)\nif tm.Get(3) != 3 {\n\tt.Errorf(\"STR\", 3, 3, tm.Get(3))\n}\ntm.Set(5, 5)\nif tm.Get(5) != 5 {\n\tt.Errorf(\"STR\", 5, 5, tm.Get(5))\n}\ntm.Set(10, 10)\nif tm.Get(10) != 10 {\n\tt.Errorf(\"STR\", 10, 10, tm.Get(10))\n}\ntm.Set(0, 1)\nif tm.Get(0) != 1 {\n\tt.Errorf(\"STR\", 0, 1, tm.Get(0))\n}\ntm.Set(10, 2)\nif tm.Get(10) != 2 {\n\tt.Errorf(\"STR\", 10, 2, tm.Get(10))\n}\ntm.Set(0, 2)\nif tm.Get(0) != 2 {\n\tt.Errorf(\"STR\", 0, 2, tm.Get(0))\n}\ntm.Set(10, 1)\nif tm.Get(10) != 1 {\n\tt.Errorf(\""}
{"tgt": "if len(steps) < 2 {\n\treturn true\n}\nfor step := 1; step <= steps[0] && step <= len(steps); step++ {\n\tif CanAdvanceToEndBrute(steps[step:]) {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "if len(nums) < 2 {\n\treturn true\n}\nfor i := 1; i < len(nums); i++ {\n\tif CanAdvanceToEndBrute(nums, i) {\n\t\treturn true\n\t}\n}\nreturn false\n}"}
{"tgt": "obj := Constructor225()\nfmt.Printf(\"STR\", obj)\nparam5 := obj.Empty()\nfmt.Printf(\"STR\", param5)\nobj.Push(2)\nfmt.Printf(\"STR\", obj)\nobj.Push(10)\nfmt.Printf(\"STR\", obj)\nparam2 := obj.Pop()\nfmt.Printf(\"STR\", param2)\nparam3 := obj.Top()\nfmt.Printf(\"STR\", param3)\nparam4 := obj.Empty()\nfmt.Printf(\"STR\", param4)", "gen": "qs := Constructor225()\nfmt.Printf(\"STR\", qs)\nqs.Push(1)\nqs.Push(2)\nfmt.Printf(\"STR\", qs)\nqs.Pop()\nfmt.Printf(\"STR\", qs.Top())\nfmt.Printf(\"STR\", qs.Empty())\nfmt.Printf(\"STR\", qs)\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []string\n\texpect [][]string\n}{\n\t{\"STR\", []string{\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\"},\n\t\t[][]string{\n\t\t\t{\"STR\", \"STR\", \"STR\"},\n\t\t\t{\"STR\", \"STR\"},\n\t\t\t{\"STR\"},\n\t\t},\n\t},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := groupAnagrams(c.inputs)\n\t\tfmt.Println(got)\n\t})\n}", "gen": "var s = Solution{\n\tname: \"STR\",\n\tinputs: []string{\n\t\t\"STR\",\n\t\t\"STR\",\n\t\t\"STR\",\n\t},\n\texpect: []string{\n\t\t\"STR\",\n\t\t\"STR\",\n\t\t\"STR\",\n\t},\n}\nfor i, v := range []struct {\n\ttestName string\n\tc        func(t *testing.T, s *Solution)\n\texpect   []string\n}{\n\t{\n\t\ttestName: \"STR\",\n\t\tc:        TestSolution,\n\t\texpect:   s.expect,\n\t},\n} {\n\tt.Run(v.testName, v.c, &s)\n}\n}"}
{"tgt": "i1 := 0\ni2 := 0\nval1 := 0\nval2 := 0\nfor i1 < len(version1) || i2 < len(version2) {\n\tval1, i1 = parseSeg(version1, i1)\n\tval2, i2 = parseSeg(version2, i2)\n\tif val1 > val2 {\n\t\treturn 1\n\t}\n\tif val1 < val2 {\n\t\treturn -1\n\t}\n}\nif i1 < len(version1) {\n\treturn 1\n}\nif i2 < len(version2) {\n\treturn -1\n}\nreturn 0", "gen": "var (\n\tstart, end int\n\terr        error\n)\nfor i := 0; i < len(s); i++ {\n\tstart, end, err = parseSeg(s[i])\n\tif err != nil {\n\t\treturn 1\n\t}\n\tif start > end {\n\t\treturn 1\n\t}\n\tif start < end && start >= m && end <= n {\n\t\treturn 1\n\t}\n\tif start < end && end > n {\n\t\treturn 1\n\t}\n\tif start >= m && end <= n {\n\t\treturn 1\n\t}\n\tif start > end && start < m {\n\t\treturn 1\n\t}\n\tif start > end && end > n {\n\t\treturn 1\n\t}\n}\nif start >= m && end <= n {\n\treturn 1\n}\nif start < end && start >= m && end <= n {\n\treturn 1\n}\nif start < end && end > n {\n\treturn 1\n}\nif start >= m && end <= n {\n\treturn 1\n}\nif start > end && start < m {\n\treturn 1\n}\nif start > end && end > n {\n\treturn 1\n}\nreturn 0\n}"}
{"tgt": "result := make([]int, 0)\nfor i := 0; i < n; i++ {\n\tresult = append(result, nums[i])\n\tresult = append(result, nums[n+i])\n}\nreturn result", "gen": "res := make([]int, 0)\nfor i := 0; i < len(nums); i++ {\n\tif i < len(nums) && nums[i] != 0 {\n\t\tres = append(res, nums[i])\n\t}\n\tfor j := i + 1; j < len(nums); j++ {\n\t\tif nums[i] == nums[j] {\n\t\t\tnums[j] = 0\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "nums := make([]byte, n)\nfor i := 0; i < n; i++ {\n\tnums[i] = byte(i) + '1'\n}\nfor i := 2; i <= k; i++ {\n\tnextPermutation60(nums)\n}\nreturn string(nums)", "gen": "res := make([]byte, len(nums))\nfor i := 0; i < len(nums); i++ {\n\tres[i] = '0' + nums[i]\n}\nfor i := 0; i < len(nums); i++ {\n\tfor j := 0; j < len(nums); j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tif nums[i] < nums[j] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif j == len(nums) {\n\t\treturn string(res)\n\t}\n\tres[i], res[j] = res[j], res[i]\n}\nreturn string(res)\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MakePalindrome(tc.input); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MakePalindrome(tc.input); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "ln, err := net.Listen(\"STR\", \"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"STR\", conn.RemoteAddr())\n\tio.WriteString(conn, fmt.Sprint(time.Now()))\n\tconn.Close()\n}", "gen": "ln, err := net.Listen(\"tcp\", \"localhost:0\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfmt.Println(\"STR\")\ntime.Sleep(time.Second)\nfmt.Println(time.Now())\nln.WriteString(\"STR\")\n}"}
{"tgt": "self.table[index].Num = value", "gen": "if i < 0 || i >= len(s) {\n\treturn\n}\ns[i] = v\n}"}
{"tgt": "return x.(int) < y.(int)", "gen": "return a == b\n}"}
{"tgt": "return strings.Replace(address, \"STR\", \"STR\", -1)", "gen": "return strings.Replace(s, \"STR\", \"STR\", -1)\n}"}
{"tgt": "var parts []string\nvar isFile bool\nvar partStart, tabCount, maxLength int\nfor i, r := range fs {\n\tswitch {\n\tcase isNewStart(i, r, fs):\n\t\tpartStart = i\n\tcase r == '.':\n\t\tisFile = true\n\tcase r == '\\t':\n\t\ttabCount++\n\tcase r == '\\n':\n\t\tif pos := tabCount; len(parts) > pos {\n\t\t\tparts = parts[:pos]\n\t\t}\n\t\tparts = append(parts, fs[partStart:i])\n\t\tif len := len(strings.Join(parts, \"STR\")); isFile && len > maxLength {\n\t\t\tmaxLength = len\n\t\t}\n\t\tisFile = false\n\t\ttabCount = 0\n\t}\n}\nif isFile {\n\tparts = append(parts, fs[partStart:])\n}\nreturn len(strings.Join(parts, \"STR\"))", "gen": "var start int\nvar count int\nvar isNewStart bool\nfor i, c := range s {\n\tif c == '(' {\n\t\tstart = i\n\t\tisNewStart = true\n\t} else if c == ')' {\n\t\tif isNewStart {\n\t\t\tcount++\n\t\t} else {\n\t\t\tcount--\n\t\t}\n\t\tisNewStart = false\n\t}\n}\nif count > 0 {\n\treturn \"STR\"\n}\nvar res []string\nfor i := start; i < len(s); i++ {\n\tif s[i] == '(' {\n\t\tres = append(res, \"STR\")\n\t} else {\n\t\tres = append(res, \"STR\")\n\t\tif len(res) > 0 {\n\t\t\tres = res[:len(res)-1]\n\t\t}\n\t}\n}\nreturn strings.Join(res, \"\")\n}"}
{"tgt": "FprintVersion(os.Stdout)", "gen": "FprintVersion(os.Stdout, Version)\n}"}
{"tgt": "cnt := 0\nfor i := 0; cnt < n && i < len(flowerbed); i++ {\n\tif i > 0 && flowerbed[i-1] == 1 {\n\t\tcontinue\n\t}\n\tif i < len(flowerbed)-1 && flowerbed[i+1] == 1 {\n\t\tcontinue\n\t}\n\tif flowerbed[i] != 0 {\n\t\tcontinue\n\t}\n\tflowerbed[i] = 1\n\tcnt++\n\tif i < len(flowerbed)-1 {\n\t\tflowerbed[i+1] = -1\n\t}\n}\nreturn cnt >= n", "gen": "var count int\nfor i := 0; i < len(A); i++ {\n\tif A[i] == 1 {\n\t\tcount++\n\t}\n\tif i > 0 && A[i-1] == 1 {\n\t\tcount--\n\t}\n\tif i < len(A)-1 && A[i+1] == 1 {\n\t\tcount++\n\t}\n}\nreturn count >= K\n}"}
{"tgt": "m := len(A)\nn := len(A[0])\nans := make([][]int, n)\nfor k := range ans {\n\tans[k] = make([]int, m)\n}\nfor r := 0; r < m; r++ {\n\tfor c := 0; c < n; c++ {\n\t\tans[c][r] = A[r][c]\n\t}\n}\nreturn ans", "gen": "n := len(nums)\nres := make([][]int, n)\nfor i := 0; i < n; i++ {\n\tres[i] = make([]int, n)\n\tfor j := 0; j < n; j++ {\n\t\tres[i][j] = nums[i]\n\t}\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tres[i][j] = nums[i]\n\t}\n}\nreturn res\n}"}
{"tgt": "patternMap := make(map[string]string)\nstrMap := make(map[string]string)\nplen := len(pattern)\nstrArr := strings.Split(str, \"STR\")\npatternArr := strings.Split(pattern, \"STR\")\nif plen != len(strArr) {\n\treturn false\n}\nfor i := 0; i < plen; i++ {\n\tif _, ok := patternMap[patternArr[i]]; !ok {\n\t\tpatternMap[patternArr[i]] = strArr[i]\n\t}\n\tif _, ok := strMap[strArr[i]]; !ok {\n\t\tstrMap[strArr[i]] = patternArr[i]\n\t}\n\tif patternMap[patternArr[i]] != strArr[i] || strMap[strArr[i]] != patternArr[i] {\n\t\tfmt.Println(\"STR\", patternMap)\n\t\tfmt.Println(\"STR\", strMap)\n\t\treturn false\n\t}\n}\nfmt.Println(\"STR\", patternMap)\nfmt.Println(\"STR\", strMap)\nreturn true", "gen": "m1 := make(map[string]string)\nm2 := make(map[string]string)\ns1 := strings.Split(STR, \",\")\ns2 := strings.Split(STR, \",\")\nfor i := 0; i < len(s1); i++ {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tif m1[s1[i]] != m2[s2[i]] {\n\t\treturn false\n\t}\n\tif m1[s1[i]] == m2[s2[i]] {\n\t\tm1[s1[i]] = s2[i]\n\t\tm2[s2[i]] = s1[i]\n\t}\n}\nreturn true\n}"}
{"tgt": "nlen := len(nums)\nfor i := 0; i < nlen-2; i++ {\n\tif i != 0 && nums[i] == nums[i-1] {\n\t\tcontinue\n\t}\n\tleft, right := i+1, nlen-1\n\tfor left < right {\n\t\tsum := nums[i] + nums[left] + nums[right]\n\t\tif sum == target {\n\t\t\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tleft++\n\t\t\tright--\n\t\t} else if sum < target {\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tleft++\n\t\t} else {\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tright--\n\t\t}\n\t}\n}", "gen": "for i := 0; i < len(nums); i++ {\n\tfor j := i + 1; j < len(nums); j++ {\n\t\tif nums[i]+nums[j] == target {\n\t\t\treturn []int{i, j}\n\t\t}\n\t}\n\tfor j := len(nums) - 1; j > i; j-- {\n\t\tif nums[i]+nums[j] == target {\n\t\t\treturn []int{i, j}\n\t\t}\n\t}\n}\nreturn nil\n}"}
{"tgt": "sLen, tLen := len(s), len(t)\nneed := [256]int{}\nfor i := range t {\n\tneed[t[i]]++\n}\nhas := [256]int{}\nmin := sLen + 1\nbegin, end, winBegin, winEnd, count := 0, 0, 0, 0, 0\nfor ; end < sLen; end++ {\n\tif need[s[end]] == 0 {\n\t\tcontinue\n\t}\n\tif has[s[end]] < need[s[end]] {\n\t\tcount++\n\t}\n\thas[s[end]]++\n\tif count == tLen {\n\t\tfor need[s[begin]] == 0 || has[s[begin]] > need[s[begin]] {\n\t\t\tif has[s[begin]] > need[s[begin]] {\n\t\t\t\thas[s[begin]]--\n\t\t\t}\n\t\t\tbegin++\n\t\t}\n\t\ttemp := end - begin + 1\n\t\tif min > temp {\n\t\t\tmin = temp\n\t\t\twinBegin = begin\n\t\t\twinEnd = end\n\t\t}\n\t}\n}\nif count < tLen {\n\treturn \"STR\"\n}\nreturn s[winBegin : winEnd+1]", "gen": "n := len(s)\ndp := make([]int, n)\nfor i := range dp {\n\tdp[i] = 1\n}\nfor i := 0; i < n; i++ {\n\tif s[i] == '1' {\n\t\tcontinue\n\t}\n\tfor j := i + 1; j < n; j++ {\n\t\tif s[j] == '1' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == s[j] {\n\t\t\tdp[j] = dp[i] + 1\n\t\t}\n\t}\n}\nmax := 0\nfor i := range dp {\n\tif dp[i] > max {\n\t\tmax = dp[i]\n\t}\n}\nif max == 0 {\n\treturn \"STR\"\n}\nreturn \"STR\"[max-1 : max]\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif steps := MinimumStepsPath(tc.path); steps != tc.minimumSteps {\n\t\tt.Errorf(\"STR\", tc.minimumSteps, steps)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimumStepsPath(tc.input); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "n := len(cost)\ndp := make([]int, n)\ndp[0], dp[1] = cost[0], cost[1]\nfor i := 2; i < n; i++ {\n\tdp[i] = cost[i] + min(dp[i-2], dp[i-1])\n}\nreturn min(dp[n-2], dp[n-1])", "gen": "n := len(A)\nres := make([]int, n)\nres[0] = A[0]\nres[n-1] = A[n-1]\nfor i := 2; i < n; i++ {\n\tres[i] = min(res[i-2]+A[i], res[i-1]+A[i])\n}\nreturn res[n-2]\n}"}
{"tgt": "qs := []question845{\n\t{\n\t\tpara845{[]int{875, 884, 239, 731, 723, 685}},\n\t\tans845{4},\n\t},\n\t{\n\t\tpara845{[]int{0, 1, 2, 3, 4, 5, 4, 3, 2, 1, 0}},\n\t\tans845{11},\n\t},\n\t{\n\t\tpara845{[]int{2, 3}},\n\t\tans845{0},\n\t},\n\t{\n\t\tpara845{[]int{2, 1, 4, 7, 3, 2, 5}},\n\t\tans845{5},\n\t},\n\t{\n\t\tpara845{[]int{2, 2, 2}},\n\t\tans845{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans845, q.para845\n\tfmt.Printf(\"STR\", p, longestMountain(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question845{\n\t{\n\t\tpara845{[]int{875, 884, 239, 731, 723, 685}},\n\t\tans845{4},\n\t},\n\t{\n\t\tpara845{[]int{0, 1, 2, 3, 4, 4, 3, 2, 1, 0}},\n\t\tans845{4},\n\t},\n\t{\n\t\tpara845{[]int{2, 3, 2, 1, 0}},\n\t\tans845{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans845, q.para845\n\tfmt.Printf(\"STR\", p, longestMountain(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "res := make([]int, 0)\nfor i := 0; i < len(nums); i = i + 2 {\n\tfreq, val := nums[i], nums[i+1]\n\tfor j := 0; j < freq; j++ {\n\t\tres = append(res, val)\n\t}\n}\nreturn res", "gen": "res := make([]int, 0)\nfor i := 0; i < len(nums); i++ {\n\tfor j := i + 1; j < len(nums); j++ {\n\t\tres = append(res, nums[i]+nums[j])\n\t}\n}\nreturn res\n}"}
{"tgt": "defer wg.Done()\nfor v := range taskQueue {\n\tfmt.Printf(\"STR\", workerId, v.Id, v.JobId)\n\tv.Run()\n\tfmt.Printf(\"STR\", workerId, v.Status, v.Id, v.JobId)\n}", "gen": "var ch = make(chan int)\ndefer func() {\n\tfmt.Printf(\"STR\", ch)\n\tTask{}.Run()\n\tfmt.Printf(\"STR\", ch)\n}()\nfor {\n\tvar v, w = <-ch\n\tif v == w {\n\t\tbreak\n\t}\n\tch <- v\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := Reverse32Bits(tc.given); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := Reverse32Bits(tc.input); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "dummy := &ListNode{0, head}\nslow, fast := dummy, dummy\nfor fast.Next != nil && fast.Next.Next != nil {\n\tfast = fast.Next.Next\n\tslow = slow.Next\n}\nreturn slow.Next", "gen": "var head *ListNode\nfor head != nil && head.Next != nil && head.Next.Next != nil {\n\thead = head.Next.Next\n}\nreturn head\n}"}
{"tgt": "fmt.Println(superEggDrop(1, 2))\nfmt.Println(superEggDrop(2, 6))\nfmt.Println(superEggDrop(2, 4))", "gen": "fmt.Println(superEggDrop(2, 1, 1))\nfmt.Println(superEggDrop(6, 2, 2))\nfmt.Println(superEggDrop(4, 2, 4))\n}"}
{"tgt": "var res []int\nstack := []*preOrderTree{root}\nfor len(stack) > 0 {\n\troot = stack[0]\n\tstack = stack[1:]\n\tres = append(res, root.data)\n\tif root.left != nil {\n\t\tstack = append(stack, root.left)\n\t}\n\tif root.right != nil {\n\t\tstack = append(stack, root.right)\n\t}\n}\nreturn res", "gen": "var res []*preOrderTree\nvar stack []*preOrderTree\nfor p := root; p != nil; p = p.Right {\n\tstack = append(stack, p)\n}\nfor len(stack) > 0 {\n\tp := stack[len(stack)-1]\n\tstack = stack[:len(stack)-1]\n\tres = append(res, p)\n\tif p.Left != nil {\n\t\tstack = append(stack, p.Left)\n\t}\n\tif p.Right != nil {\n\t\tstack = append(stack, p.Right)\n\t}\n}\nreturn res\n}"}
{"tgt": "l, r := 0, 0\nn := len(s)\nfor i := 0; i < n; i++ {\n\tif s[i] == ')' {\n\t\tl--\n\t} else {\n\t\tl++\n\t}\n\tj := n - i - 1\n\tif s[j] == '(' {\n\t\tr--\n\t} else {\n\t\tr++\n\t}\n\tif l < 0 || r < 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var left, right int\nfor i := 0; i < len(s); i++ {\n\tif s[i] == '(' {\n\t\tleft++\n\t} else if s[i] == ')' {\n\t\tright++\n\t}\n}\nfor i := 0; i < len(s); i++ {\n\tif s[i] == '(' {\n\t\tleft--\n\t} else if s[i] == ')' {\n\t\tright++\n\t}\n\tif left < 0 {\n\t\tleft++\n\t} else if right < 0 {\n\t\tright++\n\t}\n}\nreturn left == 0\n}"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA\n\tC int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif !ok {\n\tt.Error(\"STR\")\n}", "gen": "var s = struct {\n\tA struct {\n\t\tB\n\t\tC int\n\t}\n\tD int\n}{\n\tA: struct {\n\t\tB\n\t\tC int\n\t}{\n\t\tB: B{},\n\t\tC: 123,\n\t},\n\tD: 123,\n}\nif !HasZero(s) {\n\tt.Error(\"STR\")\n}\n}"}
{"tgt": "for i, row := range matrix[1:] {\n\tfor j, v := range row[1:] {\n\t\tif v != matrix[i][j] {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "if len(nums) == 0 || len(nums) == 1 {\n\treturn false\n}\nif len(nums) == 2 && nums[0] == nums[1] {\n\treturn true\n}\nfor i := 0; i < len(nums)-1; i++ {\n\tfor j := len(nums) - 1; j > i; j-- {\n\t\tif nums[i] == nums[j] {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true\n}"}
{"tgt": "qs := []question28{\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{2},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{5},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{-1},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans28, q.para28\n\tfmt.Printf(\"STR\", p, strStr(p.s, p.p))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question28{\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\t0,\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\t0,\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\t0,\n\t},\n}\nfmt.Printf(\"STR\", \"STR\")\nfor _, q := range qs {\n\t_, p := q.ans28, q.para28\n\tfmt.Printf(\"STR\", \"STR\")\n}\n}"}
{"tgt": "digits := \"STR\"\nfor i := 1; i < 9999; i++ {\n\tnum := \"STR\"\n\tfor j := 1; j < 5; j++ {\n\t\tif len(num) < 9 {\n\t\t\tnum += strconv.Itoa(i * j)\n\t\t}\n\t}\n\tarr := strings.Split(num, \"STR\")\n\tsort.Strings(arr)\n\tnumSorted := strings.Join(arr, \"STR\")\n\tif numSorted == digits {\n\t\treturn num\n\t}\n}\nreturn \"STR\"", "gen": "s := \"STR\"\nfor i := 1; i < 10000; i++ {\n\ts = s + strconv.Itoa(i)\n\tss := strings.Split(s, \"STR\")\n\tsort.Strings(ss)\n\ts = strings.Join(ss, \"STR\")\n\tif s == \"STR\" {\n\t\treturn i\n\t}\n}\nreturn -1\n}"}
{"tgt": "obj := Constructor933()\nfmt.Printf(\"STR\", obj)\nparam1 := obj.Ping(1)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(100)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(3001)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(3002)\nfmt.Printf(\"STR\", param1)", "gen": "q := Constructor933()\nfmt.Printf(\"STR\", q)\nq.Ping(1)\nfmt.Printf(\"STR\", q.Ping(100))\nfmt.Printf(\"STR\", q.Ping(3001))\nfmt.Printf(\"STR\", q.Ping(3002))\n}"}
{"tgt": "root := new(*TreeNode)\ninsertArrayToTreeNode(root, array, 0)\nreturn *root", "gen": "var root *TreeNode\ninsertArrayToTreeNode(root, nums)\nreturn root\n}"}
{"tgt": "res := 0\nsort.Ints(houses)\nsort.Ints(heaters)\nm, n := len(houses), len(heaters)\nindex := sort.SearchInts(heaters, houses[0])\nfor _, house := range houses {\n\tfor index < n && house > heaters[index] {\n\t\tindex++\n\t}\n\tif index == n {\n\t\treturn max(res, houses[m-1]-heaters[index-1])\n\t}\n\tleft := math.MaxInt32\n\tif index > 0 {\n\t\tleft = house - heaters[index-1]\n\t}\n\tright := heaters[index] - house\n\tres = max(res, min(left, right))\n}\nreturn res", "gen": "sort.Ints(A)\nsort.Ints(B)\ni := sort.SearchInts(B, A[0])\nmax := A[0]\nfor i < len(B) && A[0] == B[i] {\n\tmax = max(max, A[0]-B[i])\n\ti++\n}\nif i < len(B) {\n\tmax = min(max, -B[i])\n}\nfor i < len(A) {\n\tmax = max(max, A[i]-B[len(B)-1])\n\ti++\n}\nreturn max\n}"}
{"tgt": "c := Candidates(candidates)\nsort.Sort(c)\nreturn orderedCombinationSum2(c, target)", "gen": "sort.Sort(Candidates(c))\norderedCombinationSum2(c, 0, 0, nil)\nreturn c\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tresults := HeapsAlgorithmRecursive(tc.input)\n\tpos := 0\n\tfor result := range results {\n\t\tif !reflect.DeepEqual(result, tc.expected[pos]) {\n\t\t\tt.Errorf(\"STR\", tc.expected[pos], result)\n\t\t}\n\t\tpos++\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := HeapsAlgorithmRecursive(tc.input); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "for i := 1; i < len(nums); i++ {\n\tif nums[i-1] > nums[i] {\n\t\tpre := deepCopy(nums)\n\t\tpre[i-1] = pre[i]\n\t\tnext := deepCopy(nums)\n\t\tnext[i] = next[i-1]\n\t\treturn sort.IsSorted(sort.IntSlice(pre)) || sort.IsSorted(sort.IntSlice(next))\n\t}\n}\nreturn true", "gen": "for i := 1; i < len(nums); i++ {\n\tif nums[i] < nums[i-1] {\n\t\tnums1 := deepCopy(nums)\n\t\tnums2 := deepCopy(nums)\n\t\tnums1[i] = nums[i-1]\n\t\tnums2[i-1] = nums[i]\n\t\tif !sort.IsSorted(nums1) || !sort.IsSorted(nums2) {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true\n}"}
{"tgt": "res := []int{}\nfor _, num := range nums {\n\tn := num\n\tif n < 0 {\n\t\tn *= -1\n\t}\n\tif nums[n-1] < 0 {\n\t\tres = append(res, n)\n\t} else {\n\t\tnums[n-1] *= -1\n\t}\n}\nreturn res", "gen": "res := []int{}\nfor _, num := range nums {\n\tif num < 0 {\n\t\tres = append(res, -num)\n\t}\n}\nreturn res\n}"}
{"tgt": "qs := []question1281{\n\t{\n\t\tpara1281{234},\n\t\tans1281{15},\n\t},\n\t{\n\t\tpara1281{4421},\n\t\tans1281{21},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1281, q.para1281\n\tfmt.Printf(\"STR\", p, subtractProductAndSum(p.n))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"STR\", 234, 15, 4421, 21)\nfor _, q := range nums {\n\tfmt.Printf(\"STR\", subtractProductAndSum(q))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "fp := float64(p)\nfa := float64(a)\nfb := (fp * (fp - 2.0*fa)) / (2.0 * (fp - fa))\nb = int(fb)\nvalid = math.Abs(fb-math.Floor(fb)) < 0.000001\nreturn", "gen": "x := float64(a)\ny := float64(b)\nz := (x - y) / (x + y)\nz = math.Floor(z)\nz = math.Abs(z)\nreturn int(z), z < 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}
{"tgt": "start := -1\nlenMax := 0\ndict := [256]int{}\nfor i := range dict {\n\tdict[i] = -1\n}\nfor i, r := range s {\n\tif v := dict[r]; v > start {\n\t\tstart = v\n\t}\n\tlength := i - start\n\tif length > lenMax {\n\t\tlenMax = length\n\t}\n\tdict[r] = i\n}\nreturn lenMax", "gen": "var max, count int\nfor i := 0; i < 256; i++ {\n\tcount = 0\n\tfor _, c := range s {\n\t\tif c == byte(i) {\n\t\t\tcount++\n\t\t}\n\t}\n\tif count > max {\n\t\tmax = count\n\t}\n}\nreturn max\n}"}
{"tgt": "return &skipListNode{v: v, score: score, forwards: make([]*skipListNode, level, level), level: level}", "gen": "return &skipListNode{\n\tkey:   key,\n\tvalue: value,\n}\n}"}
{"tgt": "m := [26]int{}\nfor _, b := range B {\n\tcount := counter(b)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tm[i] = count[i]\n\t\t}\n\t}\n}\nres := []string{}\nfor _, a := range A {\n\tcount := counter(a)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tcontinueL\n\t\t}\n\t}\n\tres = append(res, a)\n}\nreturn res", "gen": "var res []string\nfor _, s := range strs {\n\tres = counter(s, res)\n}\nreturn res\n}"}
{"tgt": "bulls, cows := 0, 0\nnums := [10]int{}\nfor i := 0; i < len(secret); i++ {\n\ts, g := int(secret[i]-'0'), int(guess[i]-'0')\n\tif s == g {\n\t\tbulls++\n\t} else {\n\t\tif nums[s] < 0 {\n\t\t\tcows++\n\t\t}\n\t\tif nums[g] > 0 {\n\t\t\tcows++\n\t\t}\n\t\tnums[s]++\n\t\tnums[g]--\n\t}\n}\nreturn fmt.Sprintf(\"STR\", bulls, cows)", "gen": "var (\n\tcount, count2 int\n\tstr           string\n)\nfor i := 0; i < len(s); i++ {\n\tif s[i] == '0' {\n\t\tcount++\n\t} else {\n\t\tcount2++\n\t}\n}\nreturn fmt.Sprintf(\"STR\", count, count2)\n}"}
{"tgt": "t.Parallel()\nfor _, l := range mathTestData {\n\tif log2Floor(l.n) != l.f || log2Ceil(l.n) != l.c {\n\t\tt.Errorf(\"STR\",\n\t\t\tl.n, l.f, l.c, log2Floor(l.n), log2Ceil(l.n))\n\t}\n}", "gen": "t.Parallel()\nfor _, test := range mathTestData {\n\tif got, want := log2Floor(test.n), test.floor; got != want {\n\t\tt.Errorf(\"STR\", test.n, test.floor, got, want)\n\t}\n\tif got, want := log2Ceil(test.n), test.ceil; got != want {\n\t\tt.Errorf(\"STR\", test.n, test.ceil, got, want)\n\t}\n}\n}"}
{"tgt": "bs := strings.Builder{}\nvar dfs func(*TreeNode)\ndfs = func(node *TreeNode) {\n\tif node == nil {\n\t\treturn\n\t}\n\tbs.WriteString(strconv.Itoa(node.Val))\n\tif node.Left == nil && node.Right == nil {\n\t\treturn\n\t}\n\tbs.WriteByte('(')\n\tif node.Left != nil {\n\t\tdfs(node.Left)\n\t}\n\tbs.WriteByte(')')\n\tif node.Right != nil {\n\t\tbs.WriteByte('(')\n\t\tdfs(node.Right)\n\t\tbs.WriteByte(')')\n\t}\n}\ndfs(t)\nreturn bs.String()", "gen": "var res strings.Builder\nres.WriteString(\"STR\")\nreturn res.String()\n}"}
{"tgt": "return nil == root || isSame(root.Left, root.Right)", "gen": "return isSame(root, root)\n}"}
{"tgt": "cases := []struct {\n\tname      string\n\tflowerbed []int\n\tn         int\n\texpect    bool\n}{\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 1, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 2, false},\n\t{\"STR\", []int{1, 0, 1, 0}, 0, true},\n\t{\"STR\", []int{0}, 1, true},\n\t{\"STR\", []int{1, 0, 1, 0, 1, 0, 1}, 1, false},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.flowerbed, c.n)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.flowerbed, c.n)\n\t\t}\n\t})\n}", "gen": "var tests = []struct {\n\tname   string\n\tflowerbed []int\n\tn       int\n\texpect  bool\n}{\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 1, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 2, false},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 3, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 4, false},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 5, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 6, false},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 7, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 8, false},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 9, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 10, false},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 11, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 12, false},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 13, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 14, false},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 15, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 16, false},\n\t{\"STR\", []int{"}
{"tgt": "const maxDiv = 20\ni, div := maxDiv, maxDiv-1\nfor {\n\tif i%div == 0 {\n\t\tif div > 1 {\n\t\t\tdiv--\n\t\t} else {\n\t\t\tfmt.Println(i)\n\t\t\tos.Exit(0)\n\t\t}\n\t} else {\n\t\ti += maxDiv\n\t\tdiv = maxDiv - 1\n\t}\n}", "gen": "for n > 0 {\n\tif n%20 == 0 {\n\t\tfmt.Println(n)\n\t\tos.Exit(0)\n\t}\n\tn -= 20\n}\n}"}
