{"tgt": "fmt.Println(mostCommonWord(\"STR\", []string{\"STR\", \"STR\"}))", "gen": "fmt.Println(mostCommonWord(\"Bob hit a ball, the hit ball ran up the grass. So hit the ball with the bat. That hit the ball with the bat ball!\", []string{\"ball\"}))\n}\n"}
{"tgt": "if nil == nums || len(nums) == 0 {\n\treturn\n}\ninsertPos := 0\nfor _, values := range nums {\n\tif 0 != values {\n\t\tnums[insertPos] = values\n\t\tinsertPos++\n\t}\n}\nfor insertPos < len(nums) {\n\tnums[insertPos] = 0\n\tinsertPos++\n}", "gen": "var a [10]int\nvar b [10]int\nvar c int\nfor i := 0; i < len(a); i++ {\n\tif i < len(b) {\n\t\tc = b[i]\n\t}\n\ta[i] = c\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "cases := []struct {\n\ta, b, expected int\n}{\n\t{\n\t\ta:        0,\n\t\tb:        0,\n\t\texpected: 0,\n\t},\n\t{\n\t\ta:        1,\n\t\tb:        1,\n\t\texpected: 1,\n\t},\n\t{\n\t\ta:        -1,\n\t\tb:        1,\n\t\texpected: -1,\n\t},\n\t{\n\t\ta:        1,\n\t\tb:        -1,\n\t\texpected: -1,\n\t},\n\t{\n\t\ta:        10,\n\t\tb:        2,\n\t\texpected: 2,\n\t},\n}\nfor _, c := range cases {\n\tactual := Min(c.a, c.b)\n\tif actual != c.expected {\n\t\tt.Errorf(\"STR\", c.expected, actual)\n\t}\n}", "gen": "var a [3][3]int\na[0][0] = 1\na[0][1] = 1\na[0][2] = 1\na[1][0] = -1\na[1][1] = 2\na[1][2] = -1\na[2][0] = 2\na[2][1] = 2\na[2][2] = -1\nvar b [3][3]int\nb[0][0] = 1\nb[0][1] = 1\nb[0][2] = 1\nb[1][0] = -1\nb[1][1] = 2\nb[1][2] = -1\nb[2][0] = 2\nb[2][1] = 2\nb[2][2] = -1\nvar c [3][3]int\nc[0][0] = 10\nc[0][1] = 2\nc[0][2] = 2\nc[1][0] = -1\nc[1][1] = 2\nc[1][2] = -1\nc[2][0] = 2\nc[2][1] = 2\nc[2][2] = -1\nvar d [3][3]int\nd[0][0] = 1\nd[0][1] = 1\nd[0][2] = 1\nd[1][0] = -1\nd[1][1] = 2\nd[1][2] = -1\nd[2][0] = 2\nd[2][1] = 2\nd[2][2] = -1\nvar e [3][3]int\ne[0][0] = 10\ne[0][1] = 2\ne[0][2] = 2\ne[1][0] = -1\ne[1][1] ="}
{"tgt": "ma := 0\nif len(heights) < 0 {\n\treturn 0\n}\nvar stack []int\nfor i := 0; i < len(heights); i++ {\n\tif i == 0 {\n\t\tstack = append(stack, heights[i])\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tcontinue\n\t}\n\tif heights[i-1] > heights[i] {\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tstack = changeStack(stack, heights[i])\n\t}\n\tstack = append(stack, heights[i])\n\tif i+1 == len(heights) {\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tcontinue\n\t}\n}\nreturn ma", "gen": "var a []int\nvar max int\nfor i := 0; i < len(a); i++ {\n\tif i == 0 {\n\t\tmax = a[i]\n\t} else {\n\t\tif a[i] > max {\n\t\t\tmax = a[i]\n\t\t}\n\t}\n}\nreturn max\n}\n"}
{"tgt": "min := func(a, b int) int {\n\treturn int(math.Min(float64(a), float64(b)))\n}\ndp := make([]int, 2)\ndp[0], dp[1] = cost[0], cost[1]\nfor i := 2; i < len(cost); i++ {\n\tdp[i%2] = cost[i] + min(dp[0], dp[1])\n}\nreturn min(dp[0], dp[1])", "gen": "fmt.Println(minCostClimbingStairs([]int{1, 100, 1, 1, 1, 100, 1, 1, 100, 1}))\n}\n"}
{"tgt": "temp, mask := num, 0\nfor temp > 0 {\n\tmask = mask*2 + 1\n\ttemp /= 2\n}\nreturn mask ^ num", "gen": "var a int\nvar b int\nfor i := 0; i < 1000000000; i++ {\n\ta += i\n\tb += i\n}\nif a != b {\n\tpanic(\"a != b\")\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "listNode1 := &ListNode{\n\tVal: 4,\n\tNext: &ListNode{\n\t\tVal: 1,\n\t\tNext: &ListNode{\n\t\t\tVal:  4,\n\t\t\tNext: nil,\n\t\t},\n\t},\n}\nlistNode2 := &ListNode{\n\tVal: 1,\n\tNext: &ListNode{\n\t\tVal: 8,\n\t\tNext: &ListNode{\n\t\t\tVal:  4,\n\t\t\tNext: nil,\n\t\t},\n\t},\n}\ngetIntersectionNode(listNode1, listNode2)", "gen": "intersectionNode := getIntersectionNode([]int{4, 1}, []int{1, 8, 4, 5})\nfmt.Println(intersectionNode)\n}\n"}
{"tgt": "switch {\ncase isIPv4(IP):\n\treturn \"STR\"\ncase isIPv6(IP):\n\treturn \"STR\"\ndefault:\n\treturn \"STR\"\n}", "gen": "fmt.Println(isIPv4(\"192.168.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"192.168.1.1.1.1.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4"}
{"tgt": "l := len(preorder)\nif l == 0 {\n\treturn nil\n}\nfor 1 < l && preorder[0] < preorder[l-1] {\n\tl--\n}\nreturn &TreeNode{\n\tVal:   preorder[0],\n\tLeft:  bstFromPreorder(preorder[1:l]),\n\tRight: bstFromPreorder(preorder[l:]),\n}", "gen": "preorder := []int{8, 5, 1, 7, 10, 12}\nroot := bstFromPreorder(preorder)\nfmt.Println(root)\n}\n"}
{"tgt": "sort.Slice(costs, func(i, j int) bool {\n\treturn abs(costs[i][0]-costs[i][1]) > abs(costs[j][0]-costs[j][1])\n})\ncost, a, b, n := 0, 0, 0, len(costs)/2\nfor _, c := range costs {\n\tif (c[0] < c[1] && a < n) || b == n {\n\t\tcost += c[0]\n\t\ta++\n\t} else {\n\t\tcost += c[1]\n\t\tb++\n\t}\n}\nreturn cost", "gen": "var costs = [][]int{\n\t{10, 20}, {30, 200}, {400, 50}, {30, 20},\n}\nfmt.Println(twoCitySchedCost(costs))\n}\n"}
{"tgt": "println(\"STR\")\nprintln(\"STR\", v1)\nprintln(\"STR\", v2.x, v2.y)\nprintln(\"STR\", len(v3), cap(v3), v3[0], v3[3])\nprintln(\"STR\", len(v4), v4 == nil)\nprintln(\"STR\", len(v5), v5 == nil)\nprintln(\"STR\", v6)\nprintln(\"STR\", cap(v7), string(v7))\nprintln(uint8SliceSrc[0])\nprintln(uint8SliceDst[0])\nprintln(intSliceSrc[0])\nprintln(intSliceDst[0])", "gen": "v1 := 1\nv2 := 2\nv3 := []int{1, 2, 3}\nv4 := v3[0]\nv5 := v3[1]\nv6 := v3[2]\nv7 := []byte{1, 2, 3}\nv8 := []int{1, 2, 3}\nv9 := v8[0]\nv10 := v8[1]\nv11 := v8[2]\nv12 := v7[0]\nv13 := v7[1]\nv14 := v7[2]\nv15 := v7[0]\nv16 := v7[1]\nv17 := v7[2]\nv18 := v7[0]\nv19 := v7[1]\nv20 := v7[2]\nv21 := v7[0]\nv22 := v7[1]\nv23 := v7[2]\nv24 := v7[0]\nv25 := v7[1]\nv26 := v7[2]\nv27 := v7[0]\nv28 := v7[1]\nv29 := v7[2]\nv30 := v7[0]\nv31 := v7[1]\nv32 := v7[2]\nv33 := v7[0]\nv34 := v7[1]\nv35 := v7[2]\nv36 := v7[0]\nv37 := v7[1]\nv38 := v7[2]\nv39 := v7[0]\nv40 := v7[1]\nv41 := v7[2]\nv42 := v7[0]\nv43 := v7[1]\nv44 := v7[2]\nv45 := v7[0]\nv"}
{"tgt": "words := strings.Fields(s)\nreturn strings.Join(reverseSlice(words), \"STR\")", "gen": "s := \"hello world\"\nfields := strings.Fields(s)\nreversed := reverseSlice(fields)\njoined := strings.Join(reversed, \" \")\nfmt.Println(joined)\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect bool\n}{\n\t{\"STR\", []int{1, 2, 2, 3}, true},\n\t{\"STR\", []int{4, 3, 3, 2}, true},\n\t{\"STR\", []int{1, 3, 2}, false},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "indexs := make([]int, 123)\nfor i, c := range order {\n\tindexs[c] = i\n}\nless := func(i, j int) bool {\n\tsi, sj := len(words[i]), len(words[j])\n\tfor k := 0; k < si && k < sj; k++ {\n\t\tii, ij := indexs[words[i][k]], indexs[words[j][k]]\n\t\tswitch {\n\t\tcase ii < ij:\n\t\t\treturn true\n\t\tcase ii > ij:\n\t\t\treturn false\n\t\t}\n\t}\n\treturn si <= sj\n}\nfor i := 1; i < len(words); i++ {\n\tif !less(i-1, i) {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var s1, s2 string\nfmt.Scan(&s1, &s2)\nif isAlienSorted(s1, s2) {\n\tfmt.Println(\"Yes\")\n} else {\n\tfmt.Println(\"No\")\n}\n}\n"}
{"tgt": "row := len(grid)\ncol := len(grid[0])\ndp := make([][]int, row)\nfor i := 0; i < row; i++ {\n\tdp[i] = make([]int, col)\n}\ndp[0][0] = grid[0][0]\nfor i := 1; i < row; i++ {\n\tdp[i][0] = dp[i-1][0] + grid[i][0]\n}\nfor i := 1; i < col; i++ {\n\tdp[0][i] = dp[0][i-1] + grid[0][i]\n}\nfor i := 1; i < row; i++ {\n\tfor j := 1; j < col; j++ {\n\t\tdp[i][j] = Min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\t}\n}\nreturn dp[row-1][col-1]", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar b = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar c = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar d = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar e = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar f = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar g = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar h = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar i = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar j = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar k = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar m = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar n = []int"}
{"tgt": "fmt.Fprint(w, \"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "l := len(nums)\nk %= l\ns := make([]int, l)\ncopy(s, nums)\nfor i, v := range s[l-k:] {\n\tnums[i] = v\n}\nfor i, v := range s[:l-k] {\n\tnums[k+i] = v\n}", "gen": "var a []int\nvar b int\na = make([]int, 10)\nb = 10\nfor i := 0; i < b; i++ {\n\ta[i] = i\n}\nfor i := 0; i < b; i++ {\n\ta[i] = i\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if p == nil || q == nil {\n\treturn p == q\n}\nreturn isSameTree(p.Left, q.Left) && p.Val == q.Val && isSameTree(p.Right, q.Right)", "gen": "a := &TreeNode{Val: 1}\nb := &TreeNode{Val: 1}\nif isSameTree(a, b) {\n\tfmt.Println(\"true\")\n} else {\n\tfmt.Println(\"false\")\n}\n}"}
{"tgt": "for cur := t.root; cur != nil; {\n\tif cur.Key == key {\n\t\treturn cur\n\t} else if key < cur.Key {\n\t\tcur = cur.left\n\t} else {\n\t\tcur = cur.right\n\t}\n}\nreturn nil", "gen": "var root *binaryTree.BstElement\nvar element *binaryTree.BstElement\nvar result *binaryTree.BstElement\nroot = binaryTree.NewBstElement(10)\nroot.Left = binaryTree.NewBstElement(5)\nroot.Right = binaryTree.NewBstElement(15)\nelement = binaryTree.NewBstElement(12)\nresult = binaryTree.Find(root, element)\nfmt.Println(result)\n}\n"}
{"tgt": "s := []int{}\nfor _, asteroid := range asteroids {\n\tfor len(s) != 0 && s[len(s)-1] > 0 && s[len(s)-1] < -asteroid {\n\t\ts = s[:len(s)-1]\n\t}\n\tif len(s) == 0 || asteroid > 0 || s[len(s)-1] < 0 {\n\t\ts = append(s, asteroid)\n\t} else if asteroid < 0 && s[len(s)-1] == -asteroid {\n\t\ts = s[:len(s)-1]\n\t}\n}\nreturn s", "gen": "var a [3]int\nfor i := 0; i < 3; i++ {\n\ta[i] = i\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "sum := 0\nsunday := 5\nyear := 1901\nis_leap := false\nfor year < 2001 {\n\tchecker := month_len\n\tif is_leap {\n\t\tchecker = leap_len\n\t}\n\ttally := sunday\n\tfor _, v := range checker {\n\t\tif tally == 0 {\n\t\t\tsum += 1\n\t\t}\n\t\tif tally < v {\n\t\t\tbreak\n\t\t}\n\t\tif tally >= v {\n\t\t\ttally -= v\n\t\t}\n\t}\n\tsunday += 7\n\tif is_leap && sunday >= 366 {\n\t\tyear++\n\t\tsunday = sunday % 366\n\t\tis_leap = false\n\t} else if !is_leap && sunday >= 365 {\n\t\tyear++\n\t\tsunday = sunday % 365\n\t\tif year%4 == 0 {\n\t\t\tis_leap = true\n\t\t}\n\t}\n}\nfmt.Printf(\"STR\", year, sum)", "gen": "var month_len [12]int\nvar leap_len [12]int\nmonth_len[0] = 31\nmonth_len[1] = 28\nmonth_len[2] = 31\nmonth_len[3] = 30\nmonth_len[4] = 31\nmonth_len[5] = 30\nmonth_len[6] = 31\nmonth_len[7] = 31\nmonth_len[8] = 30\nmonth_len[9] = 31\nmonth_len[10] = 30\nmonth_len[11] = 31\nleap_len[0] = 31\nleap_len[1] = 29\nleap_len[2] = 31\nleap_len[3] = 30\nleap_len[4] = 31\nleap_len[5] = 30\nleap_len[6] = 31\nleap_len[7] = 31\nleap_len[8] = 30\nleap_len[9] = 31\nleap_len[10] = 30\nleap_len[11] = 31\nvar month int\nvar day int\nmonth = 0\nday = 0\nfor {\n\tif day >= month_len[month] {\n\t\tbreak\n\t}\n\tif month == 0 {\n\t\tif day >= 365 {\n\t\t\tbreak\n\t\t}\n\t} else {\n\t\tif day >= 366 {\n\t\t\tbreak\n\t\t}\n\t}\n\tday++\n}\nfmt.Printf(\"%d %d\\n\", month, day)\n}\n"}
{"tgt": "max, winner := 0, 0\nfor i := 1; i < 1000000; i++ {\n\tterms := collatz(i)\n\tif terms > max {\n\t\tmax = terms\n\t\twinner = i\n\t}\n}\nfmt.Println(\"STR\", max, \"STR\", winner)", "gen": "var max, n int\nfor n = 1; n <= 999999; n++ {\n\tif collatz(n) > max {\n\t\tmax = collatz(n)\n\t}\n}\nfmt.Println(max)\n}"}
{"tgt": "return fmt.Sprintf(\"STR\", c.FirstName, c.LastName, c.Email)", "gen": "var s1, s2, s3 string\ns1 = \"hello\"\ns2 = \"world\"\ns3 = s1 + s2\nfmt.Println(s3)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "e.lgu = lgu\ne.mixin = mixin\ne.cluster = make(map[interface{}]*rsVEBTreeElement)\nif e.lgu > 1 {\n\te.summaryLgu = (e.lgu + 1) / 2\n\te.clusterLgu = e.lgu - e.summaryLgu\n\te.summary = new(rsVEBTreeElement).init(e.summaryLgu, e.mixin)\n} else {\n\te.summaryLgu = 0\n\te.clusterLgu = 0\n}\nreturn e", "gen": "var m map[int]int\nm = make(map[int]int)\nm[1] = 1\nm[2] = 2\nm[3] = 3\nm[4] = 4\nm[5] = 5\nm[6] = 6\nm[7] = 7\nm[8] = 8\nm[9] = 9\nm[10] = 10\nm[11] = 11\nm[12] = 12\nm[13] = 13\nm[14] = 14\nm[15] = 15\nm[16] = 16\nm[17] = 17\nm[18] = 18\nm[19] = 19\nm[20] = 20\nm[21] = 21\nm[22] = 22\nm[23] = 23\nm[24] = 24\nm[25] = 25\nm[26] = 26\nm[27] = 27\nm[28] = 28\nm[29] = 29\nm[30] = 30\nm[31] = 31\nm[32] = 32\nm[33] = 33\nm[34] = 34\nm[35] = 35\nm[36] = 36\nm[37] = 37\nm[38] = 38\nm[39] = 39\nm[40] = 40\nm[41] = 41\nm[42] = 42\nm[43] = 43\nm[44] = 44\nm[45] = 45\nm"}
{"tgt": "if isValid := checkHorizontal(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkVertical(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkReachable(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkRotationallySymmetric(puzzle); !isValid {\n\treturn false\n}\nreturn true", "gen": "fmt.Println(check([][]byte{\n\t{'A', 'B', 'C', 'E'},\n\t{'S', 'F', 'C', 'S'},\n\t{'A', 'D', 'E', 'E'},\n}))\nfmt.Println(check([][]byte{\n\t{'A', 'B', 'C', 'E'},\n\t{'S', 'F', 'C', 'S'},\n\t{'A', 'D', 'E', 'E'},\n\t{'A', 'B', 'C', 'E'},\n}))\nfmt.Println(check([][]byte{\n\t{'A', 'B', 'C', 'E'},\n\t{'S', 'F', 'C', 'S'},\n\t{'A', 'D', 'E', 'E'},\n\t{'A', 'B', 'C', 'E'},\n\t{'A', 'B', 'C', 'E'},\n}))\nfmt.Println(check([][]byte{\n\t{'A', 'B', 'C', 'E'},\n\t{'S', 'F', 'C', 'S'},\n\t{'A', 'D', 'E', 'E'},\n\t{'A', 'B', 'C', 'E'},\n\t{'A', 'B', 'C', 'E'},\n\t{'A', 'B', 'C', 'E'},\n}))\nfmt.Println(check([][]byte{\n\t{'A', 'B', 'C', 'E'},\n\t{'S', 'F', 'C', 'S'},\n\t{'A', 'D', 'E', 'E'},\n\t{'A', 'B', 'C', 'E'},\n\t{'A', 'B', 'C', 'E'},\n\t{'A', 'B', 'C', 'E'},\n\t{'A', 'B', 'C', 'E'},\n}))\nfmt.Println(check([][]byte{\n\t{'A', 'B', 'C', 'E'},\n\t{'S', 'F', 'C', 'S'},\n\t"}
{"tgt": "b.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})", "gen": "fmt.Println(\"hello, world\")\n}\n"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := SumRevLLNum(tc.first, tc.second); !equal(result, tc.sum) {\n\t\tt.Errorf(\"STR\",\n\t\t\ttcid, String(result), String(tc.sum))\n\t}\n}", "gen": "testing.MainStart(test.Benchmark, nil, nil, nil)\n}\n"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA `structs:\"STR\"`\n\tC  int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif ok {\n\tt.Error(\"STR\")\n}", "gen": "var a TestHasZero_OmitNested\na.B.i1.d = 123\nif !reflect.DeepEqual(a, TestHasZero_OmitNested{}) {\n\tt.Error(\"a should be zero\")\n}\n}\n\n// TestHasZero_OmitNested_B_i1_d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d"}
{"tgt": "nums := []int{1, 1, 2, 2, 3, 3}\nfmt.Println(distributeCandies(nums))\nnums2 := []int{1, 1, 2, 3}\nfmt.Println(distributeCandies(nums2))", "gen": "distributeCandies(1, 1, 2, 2, 3, 3)\nfmt.Println(distributeCandies(6, 6))\n}\n"}
{"tgt": "i, j := start, len(nums)-1\nfor i < j {\n\tnums[i], nums[j] = nums[j], nums[i]\n\ti++\n\tj--\n}", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "var val int\nfor n := uint(0); num != 0; num >>= 1 {\n\tval |= (1 - (num & 1)) << n\n\tn++\n}\nreturn val", "gen": "var n int\nfmt.Scan(&n)\nvar ans int64\nfor i := 0; i < n; i++ {\n\tans += 1 << uint(i)\n}\nfmt.Println(ans)\n}\n\n```\n\n### 2. \u6574\u6570\u8fd0\u7b97\n\n```go\npackage main\n\nimport \"fmt\"\n"}
{"tgt": "size := len(A)\nres := make([]int, size)\neven, odd := 0, 1\nfor _, a := range A {\n\tif a%2 == 0 {\n\t\tres[even] = a\n\t\teven += 2\n\t} else {\n\t\tres[odd] = a\n\t\todd += 2\n\t}\n}\nreturn res", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb := a[0:2]\nb[0] = 10\nb[1] = 20\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "slow, fast := head, head\nfor fast != nil && fast.Next != nil {\n\tslow = slow.Next\n\tfast = fast.Next.Next\n}\nvar prev *ListNode\nfor slow != nil {\n\tnext := slow.Next\n\tslow.Next = prev\n\tprev, slow = slow, next\n}\nfor p, q := head, prev; p != q; p, q = q, p {\n\tnext := p.Next\n\tp.Next = q\n\tp = next\n}", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + 1\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for _, p := range perm6([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) {\n\tvalid := true\n\tfor _, g := range guesses {\n\t\tvar count int\n\t\tfor i := 0; i < len(p); i++ {\n\t\t\tif p[i] == g.Code[i] {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\tif count != g.Score {\n\t\t\tvalid = false\n\t\t\tbreak\n\t\t}\n\t}\n\tif valid {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar bb [10]int\nvar cc [10]int\nvar dd [10]int\nvar ee [10]int\nvar ff [10]int\nvar gg [10]int\nvar hh [10]int\nvar ii [10]int\nvar jj [10]int\nvar kk [10]int\nvar ll [10]int\nvar mm [10]int\nvar nn [10]int\nvar oo [10]int\nvar pp [10]int\nvar qq [10]int\nvar rr [10]int\nvar ss [10]int\nvar tt [10]int\nvar uu [10]int\nvar vv [10]int\nvar ww [10]int\nvar xx [10]int\nvar yy [10]int\nvar zz [10]int\nvar aa1 [10]int\nvar bb1 [10"}
{"tgt": "for i := 0; i < 100000; i++ {\n\tif i%300 == 0 {\n\t\tarray := GetArrayOfSize(i)\n\t\tif len(array) != i {\n\t\t\tfmt.Println(array)\n\t\t\tt.Error()\n\t\t}\n\t}\n}", "gen": "var a int\nfor i := 0; i < 100000; i++ {\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tvar b []int\n\tb = make([]int, 300)\n\tvar c []int\n\tc = make([]int, 300)\n\tvar d []int\n\td = make([]int, 300)\n\tvar e int\n\te = 0\n\tvar f int\n\tf = 0\n\tvar g int\n\tg = 0\n\tvar h int\n\th = 0\n\tvar i int\n\ti = 0\n\tvar j int\n\tj = 0\n\tvar k int\n\tk = 0\n\tvar l int\n\tl = 0\n\tvar m int\n\tm = 0\n\tvar n int\n\tn = 0\n\tvar o int\n\to = 0\n\tvar p int\n\tp = 0\n\tvar q int\n\tq = 0\n\tvar r int\n\tr = 0\n\tvar s int\n\ts = 0\n\tvar t int\n\tt = 0\n\tvar u int\n\tu = 0\n\tvar v int\n\tv = 0\n\tvar w int\n\tw = 0\n\tvar x int\n\tx = 0\n\tvar y int\n\ty = 0\n\tvar z int\n\tz = 0\n\tvar aa int\n\taa = 0\n\tvar ab int\n\tab = 0\n\tvar ac int\n\tac = 0\n\tvar ad int\n\tad = 0\n\tvar ae int\n\tae = 0\n\tvar af int\n\taf = 0\n\tvar ag int\n\tag = 0\n\tvar ah int\n\t"}
{"tgt": "parent := this\nfor _, ch := range prefix {\n\tif child, ok := parent.Children[ch]; ok {\n\t\tparent = child\n\t\tcontinue\n\t}\n\treturn false\n}\nreturn true", "gen": "var s Solution\nfmt.Println(s.Trie(\"apple\"))\nfmt.Println(s.Trie(\"app\"))\nfmt.Println(s.Trie(\"a\"))\nfmt.Println(s.Trie(\"b\"))\n}\n"}
{"tgt": "sema <- struct{}{}\nb := balance\n<-sema\nreturn b", "gen": "var balance int\nvar sema chan int\nsema = make(chan int)\ngo func() {\n\tbalance = <-sema\n}()\nbalance = <-sema\n}\n"}
{"tgt": "pairs := [...][2]int{{10, 7}, {1000, 983}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p26(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var a, b int\na = 10\nb = 7\nvar c, d int\nc = 1000\nd = 983\nvar e, f int\ne = 2\nfor i := 0; i < 2; i++ {\n\tvar g, h int\n\tg = a\n\th = b\n\tvar i, j int\n\ti = c\n\tj = d\n\tvar k, l int\n\tk = e\n\tl = f\n\tvar m, n interface{}\n\tm = g\n\tn = h\n\tvar o, p interface{}\n\to = i\n\tp = j\n\tvar q, r interface{}\n\tq = k\n\tr = l\n\tvar s, t interface{}\n\ts = m\n\tt = n\n\tvar u, v interface{}\n\tu = o\n\tv = p\n\tvar w, x interface{}\n\tw = q\n\tx = r\n\tvar y, z interface{}\n\ty = s\n\tz = t\n\tvar aa, bb interface{}\n\taa = u\n\tbb = v\n\tvar cc, dd interface{}\n\tcc = w\n\tdd = x\n\tvar ee, ff interface{}\n\tee = y\n\tff = z\n\tvar gg, hh interface{}\n\tgg = aa\n\thh = bb\n\tvar ii, jj interface{}\n\tii = cc\n\tjj = dd\n\tvar kk, ll interface{}\n\tkk = ee\n\tll = ff\n\tvar mm, nn interface{}\n\tmm = gg\n\tnn = hh\n\tvar oo, pp interface{}\n\too = ii\n\tpp = jj\n\tvar qq, rr interface{}\n\tqq = kk\n\trr = ll\n\tvar ss, tt interface{}\n\tss = mm\n"}
{"tgt": "for i := 0; i < n; i++ {\n\tif len(squares) != i {\n\t\tprintln(\"STR\", len(squares), \"STR\", i)\n\t}\n\tsquares[i] = i * i\n\tfor j := 0; j <= i; j++ {\n\t\tif v, ok := squares[j]; !ok || v != j*j {\n\t\t\tif !ok {\n\t\t\t\tprintln(\"STR\", j)\n\t\t\t} else {\n\t\t\t\tprintln(\"STR\", j, v)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "var m map[int][2]int\nfor i := 0; i < 10; i++ {\n\tm[i][0] = i\n\tm[i][1] = i\n}\nfor i := 0; i < 10; i++ {\n\tif v, ok := m[i]; ok {\n\t\tfmt.Println(i, v[0], v[1])\n\t} else {\n\t\tfmt.Println(i, \"not found\")\n\t}\n}\n}\n\n// Output:\n// 0 0 0\n// 1 1 1\n// 2 2 2\n// 3 3 3\n// 4 4 4\n// 5 5 5\n// 6 6 6\n// 7 7 7\n// 8 8 8\n// 9 9 9\n\n```\n\n### 2. \u6808\u4e0a\u5206\u914d\n\n```go\npackage main\n\nimport \"fmt\"\n"}
{"tgt": "for _, word := range words {\n\tremainNum[word] = 0\n}\nfor _, word := range words {\n\tremainNum[word]++\n}\nreturn 0", "gen": "m := make(map[string]int)\nfor i := 0; i < 10; i++ {\n\tm[strconv.Itoa(i)] = i\n}\nfor i := 0; i < 10; i++ {\n\tm[strconv.Itoa(i)]++\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "ad := admin{\n\tuser: user{\n\t\tname:  \"STR\",\n\t\temail: \"STR\",\n\t},\n\tlevel: \"STR\",\n}\nad.user.notify()\nad.notify()", "gen": "user := User{\n\tName: \"John\",\n\tAge:  20,\n}\nadmin := Admin{\n\tName: \"Jane\",\n\tAge:  30,\n}\nuser.notify()\nadmin.notify()\n}\n"}
{"tgt": "if !ok {\n\tpanic(\"STR\")\n}", "gen": "var x int8 = 1\nif x == 0 {\n\tpanic(\"x is not zero\")\n}\n}\n\n// 0000000000000000 <main>:\n// \t.cfi_startproc\n// \t.cfi_personality 0x3,__gxx_personality_v0\n// \t.cfi_lsda 0x1,.LLSDA2\n// \t.cfi_loc 1 1 0\n// \t.cfi_adjust_cfa_offset 24\n// \t.cfi_offset 11,-24\n// \t.cfi_offset 10,-16\n// \t.cfi_offset 6,-8\n// \t.cfi_offset 5,-16\n// \t.cfi_offset 4,-8\n// \t.cfi_offset 3,-16\n// \t.cfi_offset 2,-8\n// \t.cfi_offset 1,-16\n// \t.cfi_offset 0,-8\n// \tpushq %rbp\n// \tmovq %rsp,%rbp\n// \tsubq $24,%rsp\n// \tmovb $1,-17(%rbp)\n// \tmovq %fs:112,%rax\n// \tmovq %rax,-8(%rbp)\n// \tmovzbl -17(%rbp),%eax\n// \ttestb %al,%al\n// \tjne .L2\n// \tmovl $40,%r10d\n// \tmovl $0,%r11d\n// \tcall <__morestack>\n// \t.L2:\n// \tmovq -8(%rbp),%rbx\n// \tleave\n// \tret\n// \t.cfi_endproc\n// \t.size main, .-main\n// \t.section .rodata\n// \t.align 8\n// \t.type <go..C2"}
{"tgt": "sum := 0\nprev := 1\ncurr := 1\nfor curr <= 4e6 {\n\tprev, curr = curr, prev+curr\n\tif curr%2 == 0 {\n\t\tsum += curr\n\t}\n}\nfmt.Println(sum)", "gen": "var a, b int\na = 1\nb = 1\nfor i := 0; i < 4000000; i++ {\n\tif i%2 == 0 {\n\t\ta += b\n\t} else {\n\t\ta = a + b\n\t}\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "dist := func(i int) int {\n\tx, y := points[i][0], points[i][1]\n\treturn x*x + y*y\n}\npartition := func(l, r int) int {\n\tpivot, pdist := l, dist(l)\n\tpoints[pivot], points[r] = points[r], points[pivot]\n\tdivider := l\n\tfor i := l; i < r; i++ {\n\t\tif dist(i) < pdist {\n\t\t\tpoints[i], points[divider] = points[divider], points[i]\n\t\t\tdivider++\n\t\t}\n\t}\n\tpoints[divider], points[r] = points[r], points[divider]\n\treturn divider\n}\nl, r := 0, len(points)-1\nfor l < r {\n\ti := partition(l, r)\n\tif i == K {\n\t\tbreak\n\t} else if i > K {\n\t\tr = i - 1\n\t} else {\n\t\tl = i + 1\n\t}\n}\nreturn points[:K]", "gen": "fmt.Println(kClosest([]int{1, 2, 3, 4, 5}, 4))\n}\n"}
{"tgt": "if c < 0 {\n\treturn false\n}\nl, r := 0, mySqrt(c)\nfor l <= r {\n\tcur := l*l + r*r\n\tif cur < c {\n\t\tl++\n\t} else if cur > c {\n\t\tr--\n\t} else {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "fmt.Println(mySqrt(8))\n}\n"}
{"tgt": "n := len(edges)\nparent := make([]int, n+1)\nfor i := 0; i < n; i++ {\n\tparent[i] = i\n}\nvar i int\nvar e []int\nfor i, e = range edges {\n\tf, t := e[0], e[1]\n\tpf := find(parent, f)\n\tpt := find(parent, t)\n\tif pf == pt {\n\t\tbreak\n\t}\n\tparent[pf] = pt\n}\nreturn edges[i]", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\ta = append(a, i)\n}\nb := make([]int, 0, 10)\nfor i := 0; i < len(a); i++ {\n\tb = append(b, find(a, i))\n}\nfmt.Println(b)\n}"}
{"tgt": "var bin strings.Builder\nfor head != nil {\n\tbin.WriteString(strconv.Itoa(head.Val))\n\thead = head.Next\n}\ni, _ := strconv.ParseInt(bin.String(), 2, 64)\nreturn int(i)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar"}
{"tgt": "if n == 0 {\n\treturn 0\n}\nreturn n/5 + trailingZeroes(n/5)", "gen": "fmt.Println(trailingZeroes(10))\n}\n"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tpuzzle := make([][]rune, len(tc.puzzle))\n\tfor i := range puzzle {\n\t\tpuzzle[i] = []rune(tc.puzzle[i])\n\t}\n\tif result := FindWordLD(puzzle, []rune(tc.target)); result != tc.expected {\n\t\tt.Errorf(\"STR\", tcid, tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(test.Benchmark, nil, nil, flag.CommandLine, nil)\n}\n"}
{"tgt": "start := 0\nend := len(s) - 1\nfor start < end {\n\ts[start], s[end] = s[end], s[start]\n\tstart++\n\tend--\n}\nreturn s", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nfor i := 0; i < len(a); i++ {\n\ta[i] = i\n\tb[i] = i\n\tc[i] = i\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = i\n\tb[i] = i\n\tc[i] = i\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if m == 0 {\n\treturn 1\n}\nswitch n {\ncase 1:\n\treturn 2\ncase 2:\n\tif m == 1 {\n\t\treturn 3\n\t}\n\treturn 4\ndefault:\n\tswitch m {\n\tcase 1:\n\t\treturn 4\n\tcase 2:\n\t\treturn 7\n\tdefault:\n\t\treturn 8\n\t}\n}", "gen": "var a int\nvar b int\na = 1\nb = 2\nvar c int\nc = 0\nif a == 1 {\n\tc = 1\n} else if a == 2 {\n\tc = 2\n} else {\n\tc = 3\n}\nif b == 1 {\n\tc = 4\n} else if b == 2 {\n\tc = 7\n} else {\n\tc = 8\n}\nfmt.Println(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "last, n := 0, len(s)\nfor i := 1; i < n; i++ {\n\tif s[i-1] == s[i] {\n\t\tcontinue\n\t}\n\tfor l := 0; i+l < n; l++ {\n\t\tif s[last+l] < s[i+l] {\n\t\t\tlast = i\n\t\t\tbreak\n\t\t}\n\t\tif s[last+l] > s[i+l] {\n\t\t\tbreak\n\t\t}\n\t}\n}\nreturn s[last:]", "gen": "var a [2]int\nvar b [2]int\nvar c int\nvar d int\na[0] = 1\na[1] = 2\nb[0] = 3\nb[1] = 4\nc = 0\nd = 0\nfor i := 0; i < len(a); i++ {\n\tfor j := 0; j < len(b); j++ {\n\t\tif a[i] > b[j] {\n\t\t\tc++\n\t\t} else if a[i] < b[j] {\n\t\t\td++\n\t\t}\n\t}\n}\nfmt.Println(c, d)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "fmt.Println(checkPerfectNumber(6))\nfmt.Println(checkPerfectNumber(28))\nfmt.Println(checkPerfectNumber(30))", "gen": "checkPerfectNumber(6)\ncheckPerfectNumber(28)\ncheckPerfectNumber(30)\n}\n"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := EqualWithShifting(tc.A, tc.B); result != tc.expected {\n\t\tt.Errorf(\"STR\", tcid, tc.expected, result)\n\t}\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "s = strings.TrimSpace(s)\n_, err := strconv.ParseFloat(s, 64)\nreturn err == nil || err.(*strconv.NumError).Err != strconv.ErrSyntax", "gen": "var s string\nvar f float64\nvar err error\ns = \" 123.456 \"\nf, err = strconv.ParseFloat(s, 64)\nif err != nil {\n\tpanic(err)\n}\nfmt.Println(f)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "qs := []question76{\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans76, q.para76\n\tfmt.Printf(\"STR\", p, minWindow(p.s, p.p))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world!\")\nreturn\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0}, 5},\n\t{\"STR\", []int{0, 0, 0, 0, 1}, []int{1, 0, 0, 0, 0}, 4},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums1, c.nums2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums1, c.nums2)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "return strings.ReplaceAll(r.element.Name, \"STR\", \"\")", "gen": "fmt.Println(strings.ReplaceAll(\"hello\", \"e\", \"a\"))\n}\n\n// \u6c47\u7f16\u4ee3\u7801\n// 1. \u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f\u4ee5 .L \u5f00\u5934\u7684\uff0c\u8fd9\u662f\u56e0\u4e3a\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\n// \u56e0\u6b64\u5728\u6c47\u7f16\u4ee3\u7801\u4e2d\uff0c\u51fd\u6570\u540d\u79f0\u4ee5 .L \u5f00\u5934\uff0c\u4ee5\u6b64\u6765\u907f\u514d\u4e0e\u5176\u4ed6\u7684\u7b26\u53f7\u540d\u79f0\u51b2\u7a81\u3002\n// 2. \u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u540e\u9762\u8ddf\u7740\u4e00\u4e2a\u6570\u5b57\uff0c\u8fd9\u4e2a\u6570\u5b57\u662f\u51fd\u6570\u7684\u5e8f\u53f7\uff0c\n// \u8fd9\u4e2a\u5e8f\u53f7\u662f\u7531\u7f16\u8bd1\u5668\u81ea\u52a8\u751f\u6210\u7684\uff0c\u7f16\u8bd1\u5668\u4f1a\u6839\u636e\u51fd\u6570\u7684\u8c03\u7528\u987a\u5e8f\u6765\u7ed9\u51fd\u6570\u7f16\u53f7\uff0c\n// \u56e0\u6b64\uff0c\u5982\u679c\u51fd\u6570 A \u8c03\u7528\u4e86\u51fd\u6570 B\uff0c\u90a3\u4e48\u51fd\u6570 A \u7684\u5e8f\u53f7\u4e00\u5b9a\u6bd4\u51fd\u6570 B \u7684\u5e8f\u53f7\u5c0f\u3002\n// 3. \u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u540e\u9762\u8ddf\u7740\u4e00\u4e2a @PLT\uff0c\u8fd9\u4e2a @PLT \u662f\u56e0\u4e3a\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\n// \u56e0\u6b64\u5728\u6c47\u7f16\u4ee3\u7801\u4e2d\uff0c\u51fd\u6570\u540d\u79f0\u4ee5 .L \u5f00\u5934\uff0c\u4ee5\u6b64\u6765\u907f\u514d\u4e0e\u5176\u4ed6\u7684\u7b26\u53f7\u540d\u79f0\u51b2\u7a81\uff0c\n// \u4f46\u662f\u5728\u6c47\u7f16\u4ee3\u7801\u4e2d\uff0c\u51fd\u6570\u540d\u79f0\u540e\u9762\u8ddf\u7740\u4e00\u4e2a @PLT\uff0c\u8fd9\u4e2a @PLT \u662f\u56e0\u4e3a\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\n// \u56e0\u6b64\u5728\u6c47\u7f16\u4ee3\u7801\u4e2d\uff0c\u51fd\u6570\u540d\u79f0\u4ee5 .L \u5f00\u5934\uff0c\u4ee5\u6b64\u6765\u907f\u514d\u4e0e\u5176\u4ed6\u7684\u7b26\u53f7\u540d\u79f0\u51b2\u7a81\uff0c\n// \u4f46\u662f\u5728\u6c47\u7f16\u4ee3\u7801\u4e2d\uff0c\u51fd\u6570\u540d\u79f0\u540e"}
{"tgt": "result := Mul3And5(5)\nif result != 3 {\n\tt.Errorf(\"STR\", result, 3)\n}\nresult = Mul3And5(6)\nif result != 8 {\n\tt.Errorf(\"STR\", result, 8)\n}\nresult = Mul3And5(7)\nif result != 14 {\n\tt.Errorf(\"STR\", result, 14)\n}\nresult = Mul3And5(10)\nif result != 23 {\n\tt.Errorf(\"STR\", result, 23)\n}\nresult = Mul3And5(11)\nif result != 33 {\n\tt.Errorf(\"STR\", result, 33)\n}", "gen": "var m Mul3And5\nif m.Mul3And5(5) != 3 {\n\tt.Errorf(\"Mul3And5(5) = %d; want 3\", m.Mul3And5(5))\n}\nif m.Mul3And5(10) != 8 {\n\tt.Errorf(\"Mul3And5(10) = %d; want 8\", m.Mul3And5(10))\n}\nif m.Mul3And5(15) != 14 {\n\tt.Errorf(\"Mul3And5(15) = %d; want 14\", m.Mul3And5(15))\n}\nif m.Mul3And5(20) != 23 {\n\tt.Errorf(\"Mul3And5(20) = %d; want 23\", m.Mul3And5(20))\n}\nif m.Mul3And5(25) != 32 {\n\tt.Errorf(\"Mul3And5(25) = %d; want 32\", m.Mul3And5(25))\n}\nif m.Mul3And5(30) != 39 {\n\tt.Errorf(\"Mul3And5(30) = %d; want 39\", m.Mul3And5(30))\n}\nif m.Mul3And5(35) != 46 {\n\tt.Errorf(\"Mul3And5(35) = %d; want 46\", m.Mul3And5(35))\n}\nif m.Mul3And5(40) != 53 {\n\tt.Errorf(\"Mul3And5(40) = %d; want 53\", m.Mul3And5(40))\n}\nif m.Mul3And5(45) != 60 {\n\tt.Errorf(\"M"}
{"tgt": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Please enter the IP address:\")\nvar IP string\nfmt.Scanf(\"%s\", &IP)\nfmt.Println(\"The defanged IP address is:\")\nfmt.Println(defangIPaddr(IP))\n}\n"}
{"tgt": "if root == nil {\n\treturn nil\n}\nif root.Key == key {\n\treturn root\n} else if root.Key < key {\n\troot = root.Right\n} else {\n\troot = root.Left\n}\nreturn Get(root, key)", "gen": "var a, b int\na = 1\nb = 2\nvar c int\nc = avl.Get(a, b)\nfmt.Println(c)\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1},\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1, 4, 2},\n\t\twant: 6,\n\t},\n\t{\n\t\tin:   []int{1},\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   []int{2, 1, 1, 2, 1, 3, 3, 3, 1, 3, 1, 3, 2},\n\t\twant: 7,\n\t},\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1},\n\t\twant: 2,\n\t},\n}\nfor _, tt := range tests {\n\tgot := findShortestSubArray(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(findShortestSubArray([]int{1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2,"}
{"tgt": "fmt.Println(runtime.GOOS, runtime.GOARCH)", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "result := make([]string, 0)\nstart := -1\nend := -1\nfor i, num := range nums {\n\tif i > 0 && num == nums[i-1]+1 {\n\t\tend = i\n\t} else {\n\t\tif i > 0 {\n\t\t\tresult = appendRanges(result, nums, start, end)\n\t\t}\n\t\tstart = i\n\t\tend = i\n\t}\n}\nif end >= 0 {\n\tresult = appendRanges(result, nums, start, end)\n}\nreturn result", "gen": "var a []int\na = append(a, 1)\na = append(a, 3)\na = append(a, 4)\na = append(a, 5)\na = append(a, 6)\na = append(a, 7)\na = append(a, 8)\na = append(a, 9)\na = append(a, 10)\na = append(a, 11)\na = append(a, 12)\na = append(a, 13)\na = append(a, 14)\na = append(a, 15)\na = append(a, 16)\na = append(a, 17)\na = append(a, 18)\na = append(a, 19)\na = append(a, 20)\na = append(a, 21)\na = append(a, 22)\na = append(a, 23)\na = append(a, 24)\na = append(a, 25)\na = append(a, 26)\na = append(a, 27)\na = append(a, 28)\na = append(a, 29)\na = append(a, 30)\na = append(a, 31)\na = append(a, 32)\na = append(a, 33)\na = append(a, 34)\na = append(a, 35)\na = append(a, 36)\na = append(a, 37)\na = append(a, 38)\na = append(a, 39)\na = append(a, 40)\na = append(a, 41)\na = append(a, 42)\na = append(a, 43"}
{"tgt": "pigs := 0\nfor mypow(minutesToTest/minutesToDie+1, pigs) < buckets {\n\tpigs++\n}\nreturn pigs", "gen": "fmt.Println(mypow(2, 10))\n}\n"}
{"tgt": "qs := []question470{\n\t{\n\t\tpara470{},\n\t\tans470{2},\n\t},\n\t{\n\t\tpara470{},\n\t\tans470{0},\n\t},\n\t{\n\t\tpara470{},\n\t\tans470{1},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans470, q.para470\n\tfmt.Printf(\"STR\", p, rand10())\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "if s == nil {\n\treturn false\n}\nreturn isSubtree(s.Left, t) || isSameTree(s, t) || isSubtree(s.Right, t)", "gen": "var a *TreeNode\nvar b *TreeNode\nvar c bool\nc = isSubtree(a, b)\nc = isSameTree(a, b)\nc = isSubtree(a, b)\nc = isSameTree(a, b)\n}\n"}
{"tgt": "if p := e.r; e.list != nil && p != &e.list.root {\n\treturn p\n}\nreturn nil", "gen": "var a [10]int\nvar b int\nb = a[10]\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "switch {\ncase one == nil && two == nil:\n\treturn nil\ncase one == nil:\n\treturn &BinaryTree{two.Val,\n\t\tMergeBinaryTrees(nil, two.Left),\n\t\tMergeBinaryTrees(nil, two.Right),\n\t}\ncase two == nil:\n\treturn &BinaryTree{one.Val,\n\t\tMergeBinaryTrees(one.Left, nil),\n\t\tMergeBinaryTrees(one.Right, nil),\n\t}\n}\nreturn &BinaryTree{one.Val + two.Val,\n\tMergeBinaryTrees(one.Left, two.Left),\n\tMergeBinaryTrees(one.Right, two.Right),\n}", "gen": "root := &BinaryTree{Val: 1}\nleft := &BinaryTree{Val: 2}\nright := &BinaryTree{Val: 3}\nroot.Left = left\nroot.Right = right\nleft.Left = &BinaryTree{Val: 4}\nleft.Right = &BinaryTree{Val: 5}\nright.Left = &BinaryTree{Val: 6}\nright.Right = &BinaryTree{Val: 7}\nfmt.Println(mergeTrees(root, &BinaryTree{Val: 8}))\n}\n"}
{"tgt": "rets := make([][]int, numRows)\nif numRows == 0 {\n\treturn rets\n}\nrets[0] = []int{1}\nfor i := 1; i < numRows; i++ {\n\trets[i] = make([]int, i+1)\n\trets[i][0] = 1\n\trets[i][i] = 1\n\tfor j := 1; j < i; j++ {\n\t\trets[i][j] = rets[i-1][j-1] + rets[i-1][j]\n\t}\n}\nreturn rets", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "i, l := 0, len(bits)-1\nfor i < l {\n\ti += bits[i] + 1\n}\nreturn i == l", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i\n}\nif a[i] != i {\n\tpanic(\"goPanicIndex\")\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "fname, lname := \"STR\", \"STR\"\nage := 35\nfmt.Println(Title)\nfmt.Println(\"STR\", fname)\nfmt.Println(\"STR\", lname)\nfmt.Println(\"STR\", age)\nfmt.Println(\"STR\", Country)", "gen": "fmt.Println(\"Hello, playground\")\nvar a int\na = 1\nvar b int\nb = 1\nfmt.Println(a, b)\nvar c int\nc = 2\nvar d int\nd = 2\nfmt.Println(c, d)\nvar e int\ne = 3\nvar f int\nf = 3\nfmt.Println(e, f)\nvar g string\ng = \"Hello, playground\"\nvar h string\nh = \"Hello, playground\"\nfmt.Println(g, h)\nvar i string\ni = \"Hello, playground\"\nvar j string\nj = \"Hello, playground\"\nfmt.Println(i, j)\nvar k int\nk = 4\nvar l int\nl = 4\nfmt.Println(k, l)\nvar m int\nm = 5\nvar n int\nn = 5\nfmt.Println(m, n)\nvar o string\no = \"Hello, playground\"\nvar p string\np = \"Hello, playground\"\nfmt.Println(o, p)\nvar q string\nq = \"Hello, playground\"\nvar r string\nr = \"Hello, playground\"\nfmt.Println(q, r)\nvar s string\ns = \"Hello, playground\"\nvar t string\nt = \"Hello, playground\"\nfmt.Println(s, t)\nvar u string\nu = \"Hello, playground\"\nvar v string\nv = \"Hello, playground\"\nfmt.Println(u, v)\nvar w string\nw = \"Hello, playground\"\nvar x string\nx = \"Hello, playground\"\nfmt.Println(w, x)\nvar y string\ny = \"Hello, playground\"\nvar z string\nz = \"Hello, playground\"\nfmt.Println("}
{"tgt": "for i := 0; i < b.N; i++ {\n\tSum(7, 8, 10)\n}", "gen": "var a int\nfor i := 0; i < 7; i++ {\n\ta += i\n}\n}\n"}
{"tgt": "dec := xml.NewDecoder(os.Stdin)\nvar stack []string\nfor {\n\ttok, err := dec.Token()\n\tif err == io.EOF {\n\t\tbreak\n\t} else if err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"STR\", err)\n\t\tos.Exit(1)\n\t}\n\tswitch tok := tok.(type) {\n\tcase xml.StartElement:\n\t\tstack = append(stack, tok.Name.Local)\n\tcase xml.EndElement:\n\t\tstack = stack[:len(stack)-1]\n\tcase xml.CharData:\n\t\tif containsAll(stack, os.Args[1:]) {\n\t\t\tfmt.Printf(\"STR\", strings.Join(stack, \"STR\"), tok)\n\t\t}\n\t}\n}", "gen": "var s string\nvar err error\ns, err = ioutil.ReadAll(os.Stdin)\nif err != nil {\n\tpanic(err)\n}\nvar decoder *xml.Decoder\ndecoder = xml.NewDecoder(strings.NewReader(s))\nvar token xml.Token\nfor {\n\ttoken, err = decoder.Token()\n\tif err != nil {\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tpanic(err)\n\t}\n\tswitch token.(type) {\n\tcase xml.StartElement:\n\t\tvar start xml.StartElement\n\t\tstart = token.(xml.StartElement)\n\t\tvar name string\n\t\tname = start.Name.Local\n\t\tvar attrs []xml.Attr\n\t\tattrs = start.Attr\n\t\tvar attrs2 []string\n\t\tfor _, attr := range attrs {\n\t\t\tattrs2 = append(attrs2, attr.Name.Local)\n\t\t}\n\t\tvar attrs3 []string\n\t\tfor _, attr := range attrs {\n\t\t\tattrs3 = append(attrs3, attr.Value)\n\t\t}\n\t\tvar attrs4 []string\n\t\tfor _, attr := range attrs {\n\t\t\tattrs4 = append(attrs4, attr.Name.Local)\n\t\t}\n\t\tvar attrs5 []string\n\t\tfor _, attr := range attrs {\n\t\t\tattrs5 = append(attrs5, attr.Value)\n\t\t}\n\t\tvar attrs6 []string\n\t\tfor _, attr := range attrs {\n\t\t\tattrs6 = append(attrs6, attr.Name.Local)\n\t\t}\n\t\tvar attrs7 []string\n\t\tfor _, attr := range attrs {\n\t\t\tattrs7 = append(attrs7, attr.Value)\n\t"}
{"tgt": "var sentences []string\nvar start int\nspaceDelimited := strings.Split(text, \"STR\")\npossibleSentence := false\nfor i, part := range spaceDelimited {\n\trunes := []rune(part)\n\tif part == \"STR\" || !isValid(runes) {\n\t\tpossibleSentence = false\n\t\tcontinue\n\t}\n\tif runes[0] >= 'A' && runes[0] <= 'Z' {\n\t\tpossibleSentence = true\n\t\tstart = i\n\t\tcontinue\n\t}\n\tif last := runes[len(runes)-1]; last == '.' || last == '!' || last == '?' {\n\t\tif possibleSentence {\n\t\t\tsentences = append(sentences, strings.Join(spaceDelimited[start:i+1], \"STR\"))\n\t\t}\n\t}\n}\nreturn sentences", "gen": "fmt.Println(isValid(\"1234567890\"))\nfmt.Println(isValid(\"12345678901234567890\"))\nfmt.Println(isValid(\"123456789012345678901234567890\"))\nfmt.Println(isValid(\"1234567890123456789012345678901234567890\"))\nfmt.Println(isValid(\"12345678901234567890123456789012345678901234567890\"))\nfmt.Println(isValid(\"123456789012345678901234567890123456789012345678901234567890\"))\nfmt.Println(isValid(\"1234567890123456789012345678901234567890123456789012345678901234567890\"))\nfmt.Println(isValid(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"))\nfmt.Println(isValid(\"1234567890123456789012345678901234567890123"}
{"tgt": "arr := randomSlice(0, 20, 10)\ndeleteSequence := randomSlice(0, 10, 10)\nnodeCnt := 0\nrbt := newRBT()\nfor _, v := range arr {\n\trbt.Insert(uint32(v))\n}\nfor i, v := range deleteSequence {\n\trbt.Delete(uint32(arr[v]))\n\tstop := rbt.PreOrderWalk(rbt.Root(), checkGBT(t, &nodeCnt, *debug))\n\tif stop {\n\t\treturn\n\t}\n\tif nodeCnt != len(deleteSequence)-1-i {\n\t\tt.Log(\"STR\", len(deleteSequence)-1-i, \"STR\", nodeCnt)\n\t\tt.Fail()\n\t}\n\tnodeCnt = 0\n\tif i != len(deleteSequence)-1 {\n\t\tstop = checkRBT(t, rbt)\n\t\tif stop {\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "var t testing.T\nvar rbt *binaryTree.RBT\nvar rbt2 *binaryTree.RBT\nvar rbt3 *binaryTree.RBT\nvar rbt4 *binaryTree.RBT\nvar rbt5 *binaryTree.RBT\nvar rbt6 *binaryTree.RBT\nvar rbt7 *binaryTree.RBT\nvar rbt8 *binaryTree.RBT\nvar rbt9 *binaryTree.RBT\nvar rbt10 *binaryTree.RBT\nvar rbt11 *binaryTree.RBT\nvar rbt12 *binaryTree.RBT\nvar rbt13 *binaryTree.RBT\nvar rbt14 *binaryTree.RBT\nvar rbt15 *binaryTree.RBT\nvar rbt16 *binaryTree.RBT\nvar rbt17 *binaryTree.RBT\nvar rbt18 *binaryTree.RBT\nvar rbt19 *binaryTree.RBT\nvar rbt20 *binaryTree.RBT\nvar rbt21 *binaryTree.RBT\nvar rbt22 *binaryTree.RBT\nvar rbt23 *binaryTree.RBT\nvar rbt24 *binaryTree.RBT\nvar rbt25 *binaryTree.RBT\nvar rbt26 *binaryTree.RBT\nvar rbt27 *binaryTree.RBT\nvar rbt28 *binaryTree.RBT\nvar rbt29 *binaryTree.RBT\nvar rbt30 *binaryTree.RBT\nvar rbt31 *binaryTree.RBT\nvar rbt32 *binaryTree.RBT\nvar rbt33 *binaryTree.RBT\nvar rbt34 *binaryTree.RBT\nvar rbt35 *binaryTree.RBT\nvar rbt36 *binaryTree.RBT"}
{"tgt": "ans := make([]int, len(nums))\nfor i, idx := range index {\n\tcopy(ans[idx+1:], ans[idx:])\n\tans[idx] = nums[i]\n}\nreturn ans", "gen": "var a [3]int\nvar b [4]int\nvar c [5]int\nvar d [6]int\nvar e [7]int\nvar f [8]int\nvar g [9]int\nvar h [10]int\nvar i [11]int\nvar j [12]int\nvar k [13]int\nvar l [14]int\nvar m [15]int\nvar n [16]int\nvar o [17]int\nvar p [18]int\nvar q [19]int\nvar r [20]int\nvar s [21]int\nvar t [22]int\nvar u [23]int\nvar v [24]int\nvar w [25]int\nvar x [26]int\nvar y [27]int\nvar z [28]int\nvar aa [29]int\nvar bb [30]int\nvar cc [31]int\nvar dd [32]int\nvar ee [33]int\nvar ff [34]int\nvar gg [35]int\nvar hh [36]int\nvar ii [37]int\nvar jj [38]int\nvar kk [39]int\nvar ll [40]int\nvar mm [41]int\nvar nn [42]int\nvar oo [43]int\nvar pp [44]int\nvar qq [45]int\nvar rr [46]int\nvar ss [47]int\nvar tt [48]int\nvar uu [49]int\nvar vv [50]int\nvar ww [51]int\nvar xx [52]int\nvar yy [53]int\nvar zz [54]int\nvar aaa [55]int\nvar bbb [56]int\nvar ccc ["}
{"tgt": "min, max := A[0], A[0]\nfor _, a := range A {\n\tif a < min {\n\t\tmin = a\n\t}\n\tif a > max {\n\t\tmax = a\n\t}\n}\nif max-min <= K+K {\n\treturn 0\n}\nreturn max - min - K - K", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i\n}\nvar j int\nfor j = 0; j < len(a); j++ {\n\tif j > i {\n\t\tbreak\n\t}\n\ta[j] = j\n}\nvar k int\nfor k = 0; k < len(a); k++ {\n\tif k > i {\n\t\tbreak\n\t}\n\ta[k] = k\n}\nvar l int\nfor l = 0; l < len(a); l++ {\n\tif l > i {\n\t\tbreak\n\t}\n\ta[l] = l\n}\nvar m int\nfor m = 0; m < len(a); m++ {\n\tif m > i {\n\t\tbreak\n\t}\n\ta[m] = m\n}\nvar n int\nfor n = 0; n < len(a); n++ {\n\tif n > i {\n\t\tbreak\n\t}\n\ta[n] = n\n}\nvar o int\nfor o = 0; o < len(a); o++ {\n\tif o > i {\n\t\tbreak\n\t}\n\ta[o] = o\n}\nvar p int\nfor p = 0; p < len(a); p++ {\n\tif p > i {\n\t\tbreak\n\t}\n\ta[p] = p\n}\nvar q int\nfor q = 0; q < len(a); q++ {\n\tif q > i {\n\t\tbreak\n\t}\n\ta[q] = q\n}\nvar r int\nfor r = 0; r < len(a); r++ {\n\tif r > i {\n\t\tbreak\n\t}\n\ta[r] = r\n"}
{"tgt": "left := 0\nright := len(numbers) - 1\nfor left != right {\n\tif numbers[left]+numbers[right] == target {\n\t\tbreak\n\t}\n\tif numbers[left]+numbers[right] > target {\n\t\tright--\n\t}\n\tif numbers[left]+numbers[right] < target {\n\t\tleft++\n\t}\n}\nreturn []int{left + 1, right + 1}", "gen": "var a [2][2]int\nvar b [2][2]int\na[0][0] = 1\na[0][1] = 2\na[1][0] = 3\na[1][1] = 4\nb = a\nfmt.Println(b[0][0], b[0][1], b[1][0], b[1][1])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for a != nil && b != nil {\n\tif a.Value != b.Value {\n\t\treturn false\n\t}\n\ta = a.Next\n\tb = b.Next\n}\nreturn a == nil && b == nil", "gen": "var a, b int\nvar c bool\na = 1\nb = 1\nc = a == b\nfmt.Println(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return func(treebinaryTreeIf, node interface{}) bool {\n\tn := node.(*gbtElement)\n\tif !tree.IsNil(n.Left) && n.Left.Key >= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Left, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif !tree.IsNil(n.Right) && n.Right.Key <= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Right, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif debug {\n\t\tfmt.Println(n)\n\t}\n\t*nodeCnt++\n\treturn false\n}", "gen": "var t1 testing.T\nvar b1 bool\nvar n1 int\nvar gbt *go.binaryTree.checkGBT\ngbt = go.binaryTree.checkGBT(t1, b1, n1)\nfmt.Println(gbt)\n}\n"}
{"tgt": "n := len(A)\nif n == 0 {\n\treturn A\n}\nabs := func(num int) int { return int(math.Abs(float64(num))) }\nans := make([]int, n)\ni, j, k := 0, n-1, n-1\nfor i <= j {\n\tif abs(A[i]) > abs(A[j]) {\n\t\tans[k] = A[i] * A[i]\n\t\ti++\n\t} else {\n\t\tans[k] = A[j] * A[j]\n\t\tj--\n\t}\n\tk--\n}\nreturn ans", "gen": "var a = Solution{1, 2, 3}\nvar b = Solution{4, 5, 6}\nvar c = Solution{7, 8, 9}\nvar d = Solution{10, 11, 12}\nvar e = Solution{13, 14, 15}\nvar f = Solution{16, 17, 18}\nvar g = Solution{19, 20, 21}\nvar h = Solution{22, 23, 24}\nvar i = Solution{25, 26, 27}\nvar j = Solution{28, 29, 30}\nvar k = Solution{31, 32, 33}\nvar l = Solution{34, 35, 36}\nvar m = Solution{37, 38, 39}\nvar n = Solution{40, 41, 42}\nvar o = Solution{43, 44, 45}\nvar p = Solution{46, 47, 48}\nvar q = Solution{49, 50, 51}\nvar r = Solution{52, 53, 54}\nvar s = Solution{55, 56, 57}\nvar t = Solution{58, 59, 60}\nvar u = Solution{61, 62, 63}\nvar v = Solution{64, 65, 66}\nvar w = Solution{67, 68, 69}\nvar x = Solution{70, 71, 72}\nvar y = Solution{73, 74, 75}\nvar z = Solution{76, 77, 78}\nvar aa = Solution{79, 80, 81}\nvar bb = Solution{82, 83, 84}\nvar cc ="}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif denoms := EgyptianFractions(tc.numerator, tc.denominator); !reflect.DeepEqual(tc.denominators, denoms) {\n\t\tt.Errorf(\"STR\", tc.denominators, denoms)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "nums1 := []int{2}\nnums2 := []int{}\nmerge(nums1, 1, nums2, 0)\nfmt.Println(nums1)", "gen": "var a [3]int\na[0] = 2\na[1] = 1\na[2] = 1\nvar b [3]int\nb[0] = 0\nb[1] = 0\nb[2] = 0\nmerge(&a, &b)\nfmt.Println(a, b)\n}"}
{"tgt": "result := 0\nfor num != 0 {\n\tresult++\n\tnum = num & (num - 1)\n}\nreturn result", "gen": "var a int\nvar b int\na = 1\nb = 0\nfor i := 0; i < a; i++ {\n\tb++\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "qs := []question448{\n\t{\n\t\tpara448{[]int{4, 3, 2, 7, 8, 2, 3, 1}},\n\t\tans448{[]int{5, 6}},\n\t},\n\t{\n\t\tpara448{[]int{4, 3, 2, 10, 9, 2, 3, 1, 1, 1, 1}},\n\t\tans448{[]int{5, 6, 7, 8, 11}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans448, q.para448\n\tfmt.Printf(\"STR\", p, findDisappearedNumbers(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "flag.Parse()\nroots := flag.Args()\nif len(roots) == 0 {\n\troots = []string{\"STR\"}\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, root := range roots {\n\t\twalkDir(root, fileSizes)\n\t}\n\tclose(fileSizes)\n}()\nvar nfiles, nbytes int64\nfor size := range fileSizes {\n\tnfiles++\n\tnbytes += size\n}\nprintDiskUsage(nfiles, nbytes)", "gen": "flag.Parse()\nargs := flag.Args()\nif len(args) != 2 {\n\tpanic(\"expected exactly two arguments\")\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, arg := range args {\n\t\tfileSizes <- getFileSize(arg)\n\t}\n\tclose(fileSizes)\n}()\nvar total int64\nfor size := range fileSizes {\n\ttotal += size\n}\nprintDiskUsage(total)\n}"}
{"tgt": "return toString[t]", "gen": "beer := Beer{\n\tName: \"Budweiser\",\n\tType: BeerType(\"lager\"),\n}\nfmt.Println(beer)\n}\n"}
{"tgt": "for step := len(nums) / 2; step > 0; step /= 2 {\n\tfor i := step; i < len(nums); i++ {\n\t\tfor j := i - step; j >= 0 && nums[j+step] < nums[j]; j -= step {\n\t\t\tnums[j], nums[j+step] = nums[j+step], nums[j]\n\t\t}\n\t}\n}\nreturn nums", "gen": "var a [3]int\nvar i int\nfor i = 0; i < 3; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 3; i++ {\n\ta[i] = a[i] + a[i+1]\n}\nfmt.Println(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var tests = []struct {\n\ttree *TreeNode\n\tvals []int\n}{\n\t{newTree(1, 2, 3, nil, 5, nil, 4), []int{1, 3, 4}},\n\t{newTree(1, 2, 3, 4, 5, nil, 6, nil, 7, nil, nil, 8, nil, nil, 9, nil, nil, nil, 10), []int{1, 3, 6, 8, 9, 10}},\n}\nfor _, tt := range tests {\n\tvals := rightSideView(tt.tree)\n\tif reflect.DeepEqual(vals, tt.vals) == false {\n\t\tt.Errorf(\"STR\", tt.tree, vals, tt.vals)\n\t}\n}", "gen": "fmt.Println(rightSideView(nil))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n}))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n\t{2, nil, nil},\n}))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n\t{2, nil, nil},\n\t{3, nil, nil},\n}))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n\t{2, nil, nil},\n\t{3, nil, nil},\n\t{4, nil, nil},\n}))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n\t{2, nil, nil},\n\t{3, nil, nil},\n\t{4, nil, nil},\n\t{5, nil, nil},\n}))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n\t{2, nil, nil},\n\t{3, nil, nil},\n\t{4, nil, nil},\n\t{5, nil, nil},\n\t{6, nil, nil},\n}))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n\t{2, nil, nil},\n\t{3, nil, nil},\n\t{4, nil, nil},\n\t{5, nil, nil},\n\t{6, nil, nil},\n\t{7, nil, nil},\n}))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n\t{2, nil, nil},\n\t{3, nil, nil},\n\t{4, nil, nil},\n\t{5, nil, nil},\n\t{6, nil, nil"}
{"tgt": "nodes := []int{\n\t1, 2, 3, 4, 5, 6,\n}\nedges := [][]bool{\n\t{false, true, true, false, false, false},\n\t{true, false, false, true, false, false},\n\t{true, false, false, true, false, false},\n\t{false, true, true, false, true, false},\n\t{false, false, false, true, false, true},\n\t{false, false, false, false, true, false},\n}\nstart := 1\nend := 6\nroute, _ := dfs(start, end, nodes, edges)\nfmt.Println(route)", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aaa [3]int\nvar aab [3]int\nvar aac [3]int\nvar aad [3]int\nvar aae [3]int\nvar aaf [3]int\nvar aag [3]int\nvar aah [3]int\nvar aai [3]int\n"}
{"tgt": "if target < 0 {\n\ttarget = -target\n}\nk := 0\nfor target > 0 {\n\tk++\n\ttarget -= k\n}\nif target%2 == 0 {\n\treturn k\n}\nreturn k + 1 + k%2", "gen": "var n int64\nfmt.Scan(&n)\nvar ans int64\nfor i := int64(0); i < n; i++ {\n\tif i&1 == 0 {\n\t\tans += i\n\t} else {\n\t\tans -= i\n\t}\n}\nfmt.Println(ans)\n}\n\n```\n\n### 2. \u5faa\u73af\n\n```go\npackage main\n\nimport \"fmt\"\n"}
{"tgt": "if mod == 1 {\n\treturn 0, nil\n}\nif exponent < 0 {\n\treturn -1, ErrorNegativeExponent\n}\n_, err := Multiply64BitInt(mod-1, mod-1)\nif err != nil {\n\treturn -1, err\n}\nvar result int64 = 1\nbase = base % mod\nfor exponent > 0 {\n\tif exponent%2 == 1 {\n\t\tresult = (result * base) % mod\n\t}\n\texponent = exponent >> 1\n\tbase = (base * base) % mod\n}\nreturn result, nil", "gen": "var a, b, c int64\na = 1\nb = 2\nc = 3\nfmt.Println(a, b, c)\n}\n"}
{"tgt": "for n := 0; n < 32; n++ {\n\tsquare[n] = gf2MatrixTimes(mat, mat[n])\n}", "gen": "var a [32]uint32\nvar b [32]uint32\nvar c uint32\nfor i := 0; i < 32; i++ {\n\ta[i] = 1\n\tb[i] = 2\n}\nc = gf2MatrixTimes(a, b)\nfmt.Println(c)\n}\n"}
{"tgt": "return n.Ns == nil", "gen": "var a [3]int\nif a[0] == 0 {\n\tpanic(\"a[0] == 0\")\n}\nif a[1] == 0 {\n\tpanic(\"a[1] == 0\")\n}\nif a[2] == 0 {\n\tpanic(\"a[2] == 0\")\n}\nif a[0] != 0 {\n\tpanic(\"a[0] != 0\")\n}\nif a[1] != 0 {\n\tpanic(\"a[1] != 0\")\n}\nif a[2] != 0 {\n\tpanic(\"a[2] != 0\")\n}\n}\n\n// 0000000000000000 <main>:\n// \t.cfi_startproc\n// \t.cfi_personality 0x3,__gxx_personality_v0\n// \t.cfi_lsda 0x1,.LLSDA0\n// \t.cfi_loc 1 1 0\n// \t.cfi_adjust_cfa_offset 48\n// \t.cfi_offset 11, -48\n// \t.cfi_offset 12, -40\n// \t.cfi_offset 13, -32\n// \t.cfi_offset 14, -24\n// \t.cfi_offset 15, -16\n// \t.cfi_offset 16, -8\n// \tpushq %rbp\n// \tmovq %rsp, %rbp\n// \tsubq $48, %rsp\n// \tmovq %rdi, -48(%rbp)\n// \tcmpq $0, -48(%rbp)\n// \tjne .L2\n// \tmovl $72, %r10d\n// \tmovl $0, %r11d\n// \tcall <__morestack>\n//"}
{"tgt": "n := len(p)\ndestination := n * n\nsquares := make([]int, 400)\nisChecked := [401]bool{}\nsquares[0] = 1\nisChecked[1] = true\nsteps := 0\nfor len(squares) > 0 {\n\tsteps++\n\tsize := len(squares)\n\tfor j := 0; j < size; j++ {\n\t\ts := squares[j]\n\t\tfor i := 1; i <= 6; i++ {\n\t\t\tsi := s + i\n\t\t\tx, y := position(si, n)\n\t\t\tif p[x][y] != -1 {\n\t\t\t\tisChecked[si] = true\n\t\t\t\tsi = p[x][y]\n\t\t\t}\n\t\t\tif si == destination {\n\t\t\t\treturn steps\n\t\t\t}\n\t\t\tif !isChecked[si] {\n\t\t\t\tsquares = append(squares, si)\n\t\t\t\tisChecked[si] = true\n\t\t\t}\n\t\t}\n\t}\n\tsquares = squares[size:]\n}\nreturn -1", "gen": "var n int\nfmt.Scan(&n)\nvar a []int\nfor i := 0; i < n; i++ {\n\ta = append(a, 0)\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tif i == j {\n\t\t\ta[i] = 1\n\t\t} else {\n\t\t\ta[i] = 0\n\t\t}\n\t}\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tif i == j {\n\t\t\ta[i] = 1\n\t\t} else {\n\t\t\ta[i] = 0\n\t\t}\n\t}\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tif i == j {\n\t\t\ta[i] = 1\n\t\t} else {\n\t\t\ta[i] = 0\n\t\t}\n\t}\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tif i == j {\n\t\t\ta[i] = 1\n\t\t} else {\n\t\t\ta[i] = 0\n\t\t}\n\t}\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tif i == j {\n\t\t\ta[i] = 1\n\t\t} else {\n\t\t\ta[i] = 0\n\t\t}\n\t}\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tif i"}
{"tgt": "return &linkLoop{\n\tHead: &linkLoopNode{},\n}", "gen": "var linkLoop *linkLoopNode\nlinkLoop = new(linkLoopNode)\nlinkLoop.linkLoopNode.next = nil\nlinkLoop.linkLoopNode.prev = nil\nlinkLoop.linkLoopNode.data = nil\nlinkLoop.linkLoop = new(linkLoop)\nlinkLoop.linkLoop.next = linkLoop.linkLoopNode\nlinkLoop.linkLoop.prev = linkLoop.linkLoopNode\nlinkLoop.linkLoop.data = nil\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return bindataRead(\n\t_dataCustomersJson,\n\t\"STR\",\n)", "gen": "var dataCustomersJson []byte\ndataCustomersJson = []byte(`./data/customers.json`)\nvar data []byte\ndata = bindataRead(dataCustomersJson, dataCustomersJson, dataCustomersJson)\nvar dataCustomersJson2 []byte\ndataCustomersJson2 = data\nvar dataCustomersJson3 []byte\ndataCustomersJson3 = dataCustomersJson2[16 : 16+len(dataCustomersJson2)]\nvar dataCustomersJson4 []byte\ndataCustomersJson4 = dataCustomersJson3[8 : 8+len(dataCustomersJson3)]\nvar dataCustomersJson5 []byte\ndataCustomersJson5 = dataCustomersJson4[go.data._dataCustomersJson : go.data._dataCustomersJson+len(dataCustomersJson4)]\nvar dataCustomersJson6 []byte\ndataCustomersJson6 = dataCustomersJson5[go.data._dataCustomersJson : go.data._dataCustomersJson+len(dataCustomersJson5)]\nvar dataCustomersJson7 []byte\ndataCustomersJson7 = dataCustomersJson6[go.data._dataCustomersJson : go.data._dataCustomersJson+len(dataCustomersJson6)]\nvar dataCustomersJson8 []byte\ndataCustomersJson8 = dataCustomersJson7[go.data._dataCustomersJson : go.data._dataCustomersJson+len(dataCustomersJson7)]\nvar dataCustomersJson9 []byte\ndataCustomersJson9 = dataCustomersJson8[go.data._dataCustomersJson : go.data._dataCustomersJson+len(dataCustomersJson8)]\nvar dataCustomersJson10 []byte\ndataCustomersJson10 = dataCustomersJson9[go.data._dataCustomersJson : go.data._dataCustomersJson+len(dataCustomersJson9)]\nvar dataCustomersJson11 []byte\ndataCustomersJson11 = dataCustomersJson10[go.data._dataCustomersJson : go.data._dataCustomersJson+len("}
{"tgt": "m := len(matrix)\nif m == 0 {\n\treturn 0\n}\nn := len(matrix[0])\nif n == 0 {\n\treturn 0\n}\nmaxEdge := 0\ndp := make([][]int, m+1)\nfor i := range dp {\n\tdp[i] = make([]int, n+1)\n}\nfor i := 1; i <= m; i++ {\n\tfor j := 1; j <= n; j++ {\n\t\tif matrix[i-1][j-1] == '1' {\n\t\t\tdp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))\n\t\t\tmaxEdge = max(maxEdge, dp[i][j])\n\t\t}\n\t}\n}\nreturn maxEdge * maxEdge", "gen": "var a []int\nvar b []int\nvar c []int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar ba int\nvar bb int\nvar bc int\nvar bd int\nvar be int\nvar bf int\nvar bg int\nvar bh int\nvar bi int\nvar bj int\nvar bk int\nvar bl int\nvar bm int\nvar bn int\nvar bo int\nvar bp int\nvar bq int\nvar br int\nvar bs int\nvar bt int\nvar bu int\nvar bv int\nvar bw int\nvar bx int\nvar by int\nvar bz int\nvar ca int\nvar cb int\nvar cc int\nvar cd int\nvar ce int\nvar cf int\nvar cg int\nvar ch int\nvar ci int\nvar cj int\nvar ck int\nvar cl int\nvar cm int\nvar cn int\nvar co int\nvar cp int\nvar cq"}
{"tgt": "return x * y", "gen": "var a float32 = 1.0\nvar b float32 = 2.0\nvar c float32 = 3.0\nvar d float32 = 4.0\nvar e float32 = 5.0\nvar f float32 = 6.0\nvar g float32 = 7.0\nvar h float32 = 8.0\nvar i float32 = 9.0\nvar j float32 = 10.0\nvar k float32 = 11.0\nvar l float32 = 12.0\nvar m float32 = 13.0\nvar n float32 = 14.0\nvar o float32 = 15.0\nvar p float32 = 16.0\nvar q float32 = 17.0\nvar r float32 = 18.0\nvar s float32 = 19.0\nvar t float32 = 20.0\nvar u float32 = 21.0\nvar v float32 = 22.0\nvar w float32 = 23.0\nvar x float32 = 24.0\nvar y float32 = 25.0\nvar z float32 = 26.0\nvar a1 float32 = 27.0\nvar b1 float32 = 28.0\nvar c1 float32 = 29.0\nvar d1 float32 = 30.0\nvar e1 float32 = 31.0\nvar f1 float32 = 32.0\nvar g1 float32 = 33.0\nvar h1 float32 = 34.0\nvar i1 float32 = 35.0\nvar j1 float32 = 36.0\nvar k1 float32 = 37.0\nvar l1 float32 = 38.0\nvar m"}
{"tgt": "if len(a) != len(b) {\n\treturn false\n}\nfor i, v := range a {\n\tif v != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [3]int\nvar b [3]int\nvar c int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 4\nb[1] = 5\nb[2] = 6\nc = a[0] + a[1] + a[2]\nif c != 6 {\n\tpanic(\"c != 6\")\n}\nc = b[0] + b[1] + b[2]\nif c != 15 {\n\tpanic(\"c != 15\")\n}\nc = a[0] + a[1] + a[2]\nif c != 6 {\n\tpanic(\"c != 6\")\n}\nc = b[0] + b[1] + b[2]\nif c != 15 {\n\tpanic(\"c != 15\")\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(s) <= 1 {\n\treturn s\n}\ni := getIndex(s + \"STR\" + reverse(s))\nreturn reverse(s[i:]) + s", "gen": "var a, b int\nfmt.Scan(&a, &b)\nif a > b {\n\ta, b = b, a\n}\nif a == 1 {\n\tfmt.Println(b)\n\treturn\n}\nvar c, d int\nc, d = reverse(a, b)\nif c > d {\n\tc, d = d, c\n}\nif c == 0 {\n\tfmt.Println(d)\n\treturn\n}\nvar e, f int\ne, f = getIndex(c, d)\nif e > f {\n\te, f = f, e\n}\nif e == 0 {\n\tfmt.Println(f)\n\treturn\n}\nvar g, h int\ng, h = reverse(e, f)\nif g > h {\n\tg, h = h, g\n}\nif g == 0 {\n\tfmt.Println(h)\n\treturn\n}\nvar i, j int\ni, j = getIndex(g, h)\nif i > j {\n\ti, j = j, i\n}\nfmt.Println(i + j)\n}"}
{"tgt": "sorted := make([]int, 0, m+n)\np, q := 0, 0\nfor {\n\tif p == m {\n\t\tsorted = append(sorted, nums2[q:]...)\n\t\tbreak\n\t}\n\tif q == n {\n\t\tsorted = append(sorted, nums1[p:]...)\n\t\tbreak\n\t}\n\tif nums1[p] < nums2[q] {\n\t\tsorted = append(sorted, nums1[p])\n\t\tp++\n\t} else {\n\t\tsorted = append(sorted, nums2[q])\n\t\tq++\n\t}\n}\ncopy(nums1, sorted)", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar bb [10]int\nvar cc [10]int\nvar dd [10]int\nvar ee [10]int\nvar ff [10]int\nvar gg [10]int\nvar hh [10]int\nvar ii [10]int\nvar jj [10]int\nvar kk [10]int\nvar ll [10]int\nvar mm [10]int\nvar nn [10]int\nvar oo [10]int\nvar pp [10]int\nvar qq [10]int\nvar rr [10]int\nvar ss [10]int\nvar tt [10]int\nvar uu [10]int\nvar vv [10]int\nvar ww [10]int\nvar xx [10]int\nvar yy [10]int\nvar zz [10]int\nvar aaa [10]int\nvar bbb [10]"}
{"tgt": "freq := make(map[rune]int)\nfor _, r := range s {\n\tfreq[r]++\n}\ntype frequency struct {\n\tr     rune\n\tcount int\n}\nletters := make([]*frequency, 0, len(freq))\nfor letter, count := range freq {\n\tletters = append(letters, &frequency{letter, count})\n}\nsort.Slice(letters, func(i, j int) bool {\n\treturn letters[i].count > letters[j].count\n})\nvar sb strings.Builder\nfor len(letters) != 0 {\n\tif len(letters) == 1 && letters[0].count > 1 {\n\t\treturn \"STR\"\n\t}\n\tfor _, f := range letters {\n\t\tsb.WriteRune(f.r)\n\t\tf.count--\n\t}\n\tfor len(letters) != 0 && letters[len(letters)-1].count == 0 {\n\t\tletters = letters[:len(letters)-1]\n\t}\n}\nreturn sb.String()", "gen": "fmt.Println(NoAdjacent([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\n}\n"}
{"tgt": "n := len(A)\nfor i := n - 2; i >= 0; i-- {\n\tA[i] += A[i+1]\n}\nmem := [101][33]int{}\nvar dp func(int, int) int\ndp = func(i, m int) int {\n\tif i+2*m >= n {\n\t\treturn A[i]\n\t}\n\tif mem[i][m] > 0 {\n\t\treturn mem[i][m]\n\t}\n\tres := 0\n\tfor x := 1; x <= 2*m; x++ {\n\t\tres = max(\n\t\t\tres,\n\t\t\tA[i]-dp(i+x, max(m, x)),\n\t\t)\n\t}\n\tmem[i][m] = res\n\treturn res\n}\nreturn dp(0, 1)", "gen": "var stones []int\nvar i int\nvar j int\nvar sum int\nvar max int\nvar tmp int\nvar tmp2 int\nvar tmp3 int\nvar tmp4 int\nvar tmp5 int\nvar tmp6 int\nvar tmp7 int\nvar tmp8 int\nvar tmp9 int\nvar tmp10 int\nvar tmp11 int\nvar tmp12 int\nvar tmp13 int\nvar tmp14 int\nvar tmp15 int\nvar tmp16 int\nvar tmp17 int\nvar tmp18 int\nvar tmp19 int\nvar tmp20 int\nvar tmp21 int\nvar tmp22 int\nvar tmp23 int\nvar tmp24 int\nvar tmp25 int\nvar tmp26 int\nvar tmp27 int\nvar tmp28 int\nvar tmp29 int\nvar tmp30 int\nvar tmp31 int\nvar tmp32 int\nvar tmp33 int\nvar tmp34 int\nvar tmp35 int\nvar tmp36 int\nvar tmp37 int\nvar tmp38 int\nvar tmp39 int\nvar tmp40 int\nvar tmp41 int\nvar tmp42 int\nvar tmp43 int\nvar tmp44 int\nvar tmp45 int\nvar tmp46 int\nvar tmp47 int\nvar tmp48 int\nvar tmp49 int\nvar tmp50 int\nvar tmp51 int\nvar tmp52 int\nvar tmp53 int\nvar tmp54 int\nvar tmp55 int\nvar tmp56 int\nvar tmp57 int\nvar tmp58 int\nvar tmp59 int\nvar tmp60 int\nvar tmp61 int\nvar tmp62 int\nvar tmp63 int\nvar tmp64 int\nvar tmp65 int\nvar tmp66 int\nvar tmp67 int\nvar tmp68 int\nvar tmp69 int\n"}
{"tgt": "if n <= 2 {\n\treturn n\n}\nvar dp [2]int\ndp[0], dp[1] = 1, 2\nfor i := 2; i < n; i++ {\n\tdp[i%2] = dp[i%2] + dp[(i-1)%2]\n}\nreturn dp[(n-1)%2]", "gen": "var a [2]int\na[0] = 1\na[1] = 2\nvar b int\nb = a[0] + a[1]\nfmt.Println(b)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "email = strings.TrimSpace(email)\nemail = strings.ToLower(email)\nh := md5.New()\nio.WriteString(h, email)\nfinalBytes := h.Sum(nil)\nfinalString := hex.EncodeToString(finalBytes)\nreturn finalString", "gen": "var s string\nvar err error\nfmt.Scan(&s)\ns = strings.TrimSpace(s)\ns = strings.ToLower(s)\nh := md5.New()\nh.Write([]byte(s))\nvar hash string\nhash, err = hex.EncodeToString(h.Sum(nil))\nif err != nil {\n\tpanic(err)\n}\nfmt.Println(hash)\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t}, {\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n}\nfor _, tt := range tests {\n\tgot := repeatedSubstringPattern(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(repeatedSubstringPattern(\"abab\"))\nfmt.Println(repeatedSubstringPattern(\"aba\"))\nfmt.Println(repeatedSubstringPattern(\"abcabcabcabc\"))\nfmt.Println(repeatedSubstringPattern(\"abcabcab\"))\nfmt.Println(repeatedSubstringPattern(\"abcabc\"))\nfmt.Println(repeatedSubstringPattern(\"abcab\"))\nfmt.Println(repeatedSubstringPattern(\"abc\"))\nfmt.Println(repeatedSubstringPattern(\"a\"))\nfmt.Println(repeatedSubstringPattern(\"\"))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   0x5555,\n\t\twant: 8,\n\t},\n}\nfor _, tt := range tests {\n\tgot := hammingWeight(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var a [4]int\na[0] = 3\na[1] = 2\na[2] = 7\na[3] = 8\nvar b [4]int\nb[0] = 1\nb[1] = 2\nb[2] = 21845\nb[3] = 8\nvar c [4]int\nc[0] = 2\nc[1] = 3\nc[2] = 8\nc[3] = 1\nvar d [4]int\nd[0] = 2\nd[1] = 3\nd[2] = 8\nd[3] = 1\nvar e [4]int\ne[0] = 2\ne[1] = 3\ne[2] = 8\ne[3] = 1\nvar f [4]int\nf[0] = 2\nf[1] = 3\nf[2] = 8\nf[3] = 1\nvar g [4]int\ng[0] = 2\ng[1] = 3\ng[2] = 8\ng[3] = 1\nvar h [4]int\nh[0] = 2\nh[1] = 3\nh[2] = 8\nh[3] = 1\nvar i [4]int\ni[0] = 2\ni[1] = 3\ni[2] = 8\ni[3] = 1\nvar j [4]int\nj[0] = 2\nj[1] = 3\nj[2] = 8\nj[3] = 1\nvar k [4]int\nk[0] = 2\nk[1] = 3\nk[2] = 8\nk[3] = 1\nvar l [4]int\nl[0"}
{"tgt": "return bindataRead(\n\t_assetsHomeCatJpg,\n\t\"STR\",\n)", "gen": "var homeCatJpg []byte\nvar homeCatJpg2 []byte\nvar homeCatJpg3 []byte\nvar homeCatJpg4 []byte\nvar homeCatJpg5 []byte\nvar homeCatJpg6 []byte\nhomeCatJpg = bindataRead(homeCatJpg, homeCatJpg2, homeCatJpg3, homeCatJpg4, homeCatJpg5, homeCatJpg6, \".\", \"assets\", \"HomeCat.jpg\")\nvar homeCatJpg7 []byte\nvar homeCatJpg8 []byte\nvar homeCatJpg9 []byte\nvar homeCatJpg10 []byte\nvar homeCatJpg11 []byte\nvar homeCatJpg12 []byte\nhomeCatJpg7 = homeCatJpg[0]\nhomeCatJpg8 = homeCatJpg[1]\nhomeCatJpg9 = homeCatJpg[2]\nhomeCatJpg10 = homeCatJpg[3]\nhomeCatJpg11 = homeCatJpg[4]\nhomeCatJpg12 = homeCatJpg[5]\nvar homeCatJpg13 []byte\nvar homeCatJpg14 []byte\nvar homeCatJpg15 []byte\nvar homeCatJpg16 []byte\nvar homeCatJpg17 []byte\nvar homeCatJpg18 []byte\nhomeCatJpg13 = homeCatJpg[6]\nhomeCatJpg14 = homeCatJpg[7]\nhomeCatJpg15 = homeCatJpg[8]\nhomeCatJpg16 = homeCatJpg[9]\nhomeCatJpg17 = homeCatJpg[10]\nhomeCatJpg18 = homeCatJpg[11]\nvar homeCatJpg19 []byte\nvar homeCatJpg20 []byte\nvar homeCatJpg21 []byte\nvar homeCatJpg22 []byte\nvar homeCatJpg23 []byte\nvar homeCatJpg24 []"}
{"tgt": "b.table = make(map[string]*entry, capacity)\nb.priorityQueue = make([]*entry, 0, capacity)\nb.lruList.Init()\nb.freeList.Init()\nheap.Init(&b.priorityQueue)\narrayOfEntries := make([]entry, capacity)\nfor i := uint(0); i < capacity; i++ {\n\te := &arrayOfEntries[i]\n\te.element.Value = e\n\te.index = -1\n\tb.freeList.PushElementBack(&e.element)\n}", "gen": "cache := New(100)\nfor i := 0; i < 100; i++ {\n\tcache.Get(i)\n}\n}\n"}
{"tgt": "list.rear = nil", "gen": "var x *int\n*x = 0\n}\n\n// Test that we can handle a function call with a memory arg.\n\n<ASM>\nmovq %rdi,-8(%rbp)\nmovq %rsi,-16(%rbp)\nmovq -8(%rbp),%rax\nmovq -16(%rbp),%rdx\nmovq %rdx,(%rax)\nmovq $0,%rax\nleave\nret</ASM>"}
{"tgt": "h := newLinkedHeap()\nbenchmarkHeap(b, h)", "gen": "heap := newLinkedHeap()\nbenchmarkHeap(heap)\n}\n"}
{"tgt": "close(p.work)\np.wg.Wait()", "gen": "var wg sync.WaitGroup\nch := make(chan int)\nwg.Add(1)\ngo func() {\n\tdefer wg.Done()\n\t<-ch\n}()\nwg.Wait()\n}\n\n// 1. \u6808\u6ea2\u51fa\n// 2. \u6808\u6ea2\u51fa\n// 3. \u6808\u6ea2\u51fa\n// 4. \u6808\u6ea2\u51fa\n// 5. \u6808\u6ea2\u51fa\n// 6. \u6808\u6ea2\u51fa\n// 7. \u6808\u6ea2\u51fa\n// 8. \u6808\u6ea2\u51fa\n// 9. \u6808\u6ea2\u51fa\n// 10. \u6808\u6ea2\u51fa\n// 11. \u6808\u6ea2\u51fa\n// 12. \u6808\u6ea2\u51fa\n// 13. \u6808\u6ea2\u51fa\n// 14. \u6808\u6ea2\u51fa\n// 15. \u6808\u6ea2\u51fa\n// 16. \u6808\u6ea2\u51fa\n// 17. \u6808\u6ea2\u51fa\n// 18. \u6808\u6ea2\u51fa\n// 19. \u6808\u6ea2\u51fa\n// 20. \u6808\u6ea2\u51fa\n// 21. \u6808\u6ea2\u51fa\n// 22. \u6808\u6ea2\u51fa\n// 23. \u6808\u6ea2\u51fa\n// 24. \u6808\u6ea2\u51fa\n// 25. \u6808\u6ea2\u51fa\n// 26. \u6808\u6ea2\u51fa\n// 27. \u6808\u6ea2\u51fa\n// 28. \u6808\u6ea2\u51fa\n// 29. \u6808\u6ea2\u51fa\n// 30. \u6808\u6ea2\u51fa\n// 31. \u6808\u6ea2\u51fa\n// 32. \u6808\u6ea2\u51fa"}
{"tgt": "res := 0\nfactor := 1\nsize := len(s)\nfor i := 0; i < size; i++ {\n\tif s[i] == '(' {\n\t\tfactor *= 2\n\t} else {\n\t\tfactor /= 2\n\t}\n\tif s[i] == '(' && s[i+1] == ')' {\n\t\tres += factor / 2\n\t}\n}\nreturn res", "gen": "var a [10]byte\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif a[i] == 40 {\n\t\tbreak\n\t}\n\tif i == len(a) {\n\t\tpanic(\"\")\n\t}\n\tif a[i] == 41 {\n\t\tbreak\n\t}\n\tif i == len(a) {\n\t\tpanic(\"\")\n\t}\n\tif i&(i-1) == 0 {\n\t\tbreak\n\t}\n\ti >>= 63\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\ti = i + i\n\t"}
{"tgt": "qs := []question454{\n\t{\n\t\tpara454{[]int{1, 2}, []int{-2, -1}, []int{-1, 2}, []int{0, 2}},\n\t\tans454{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans454, q.para454\n\tfmt.Printf(\"STR\", p, fourSumCount(p.a, p.b, p.c, p.d))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(fourSumCount([]int{1, 2}, []int{-2, -1}))\n}\n"}
{"tgt": "for i := range langs {\n\tlanguage := langs[i]\n\tif strings.EqualFold(language.Lang, str) {\n\t\treturn &language\n\t}\n}\nreturn nil", "gen": "langs := []Language{\n\t{\"Go\", \"golang\", \"golang\"},\n\t{\"Python\", \"python\", \"python\"},\n\t{\"Ruby\", \"ruby\", \"ruby\"},\n}\nvar lang Language\nfor _, l := range langs {\n\tif l.Name == \"Go\" {\n\t\tlang = l\n\t\tbreak\n\t}\n}\nif lang.Name == \"\" {\n\tpanic(\"not found\")\n}\nfmt.Println(lang)\n}\n"}
{"tgt": "sort.Ints(houses)\nsort.Ints(heaters)\ni, ans := 0, 0\nfor _, house := range houses {\n\tfor i < len(heaters)-1 && heaters[i]+heaters[i+1] <= house*2 {\n\t\ti++\n\t}\n\tans = maxInt(ans, absInt(heaters[i]-house))\n}\nreturn ans", "gen": "var a, b []int\nfmt.Scan(&a, &b)\nsort.Ints(a)\nsort.Ints(b)\nvar c int\nfor i := 0; i < len(a); i++ {\n\tfor j := 0; j < len(b); j++ {\n\t\tif a[i] == b[j] {\n\t\t\tc = maxInt(absInt(a[i]), absInt(b[j]))\n\t\t\tbreak\n\t\t}\n\t}\n}\nfmt.Println(c)\n}"}
{"tgt": "return h.FromHexString(string(b))", "gen": "var hash go.metainfo.Hash\nhash.FromHexString(\"1234567890123456789012345678901234567890\")\nfmt.Println(hash)\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{\n\t\t{10, 16},\n\t\t{2, 8},\n\t\t{1, 6},\n\t\t{7, 12},\n\t}, 2},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := findMinArrowShots(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "if n < 2 {\n\treturn false\n}\nfor i := 2; i < n; i++ {\n\tif n%i == 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var n int\nfmt.Scan(&n)\nif n > 1 {\n\tif n % 2 == 0 {\n\t\tfmt.Println(0)\n\t} else {\n\t\tfmt.Println(1)\n\t}\n} else {\n\tfmt.Println(0)\n}\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{5, 3, 4, 5},\n\t\twant: true,\n\t},\n\t{\n\t\tin:   []int{2, 5, 7, 3},\n\t\twant: true,\n\t},\n}\nfor _, tt := range tests {\n\tgot := stoneGame(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "stoneGame([]int{5, 3, 4, 5})\nstoneGame([]int{2, 5, 7, 3})\n}\n"}
{"tgt": "return self.code", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if N == 1 {\n\treturn 0\n}\nif K%2 == 1 {\n\treturn kthGrammar(N-1, (K+1)/2)\n}\nreturn opposite(kthGrammar(N-1, K/2))", "gen": "fmt.Println(kthGrammar(1, 1))\nfmt.Println(kthGrammar(2, 1))\nfmt.Println(kthGrammar(2, 2))\nfmt.Println(kthGrammar(3, 1))\nfmt.Println(kthGrammar(3, 2))\nfmt.Println(kthGrammar(3, 3))\nfmt.Println(kthGrammar(4, 1))\nfmt.Println(kthGrammar(4, 2))\nfmt.Println(kthGrammar(4, 3))\nfmt.Println(kthGrammar(4, 4))\nfmt.Println(kthGrammar(5, 1))\nfmt.Println(kthGrammar(5, 2))\nfmt.Println(kthGrammar(5, 3))\nfmt.Println(kthGrammar(5, 4))\nfmt.Println(kthGrammar(5, 5))\nfmt.Println(kthGrammar(6, 1))\nfmt.Println(kthGrammar(6, 2))\nfmt.Println(kthGrammar(6, 3))\nfmt.Println(kthGrammar(6, 4))\nfmt.Println(kthGrammar(6, 5))\nfmt.Println(kthGrammar(6, 6))\nfmt.Println(kthGrammar(7, 1))\nfmt.Println(kthGrammar(7, 2))\nfmt.Println(kthGrammar(7, 3))\nfmt.Println(kthGrammar(7, 4))\nfmt.Println(kthGrammar(7, 5))\nfmt.Println(kthGrammar(7, 6))\nfmt.Println(kthGrammar(7,"}
{"tgt": "tests := [...]testType{\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := buddyStrings(tt.a, tt.b)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.a, tt.b, got, tt.want)\n\t}\n}", "gen": "buddyStrings(\"ab\", \"ba\")\n}\n"}
{"tgt": "ope := [][]int{\n\t{2, 2},\n\t{3, 3}}\nfmt.Println(maxCount(3, 3, ope))", "gen": "var a = [5]int{2, 2, 3, 3, 2}\nvar maxCount int\nmaxCount = maxCount(a)\nfmt.Println(maxCount)\n}\n"}
{"tgt": "qs := []question274{\n\t{\n\t\tpara274{[]int{3, 6, 9, 1}},\n\t\tans274{3},\n\t},\n\t{\n\t\tpara274{[]int{1}},\n\t\tans274{1},\n\t},\n\t{\n\t\tpara274{[]int{}},\n\t\tans274{0},\n\t},\n\t{\n\t\tpara274{[]int{3, 0, 6, 1, 5}},\n\t\tans274{3},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans274, q.para274\n\tfmt.Printf(\"STR\", p, hIndex(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello, world\")\n}\n"}
{"tgt": "sort.Strings(words)\nmp := make(map[string]bool)\nvar res string\nfor _, word := range words {\n\tsize := len(word)\n\tif size == 1 || mp[word[:size-1]] {\n\t\tif size > len(res) {\n\t\t\tres = word\n\t\t}\n\t\tmp[word] = true\n\t}\n}\nreturn res", "gen": "var a []string\nvar b []string\nvar c map[string]bool\nsort.Strings(a)\nsort.Strings(b)\nc = make(map[string]bool)\nfor i := 0; i < len(a); i++ {\n\tif c[a[i]] {\n\t\tc[a[i]] = true\n\t}\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "longestCenter, longestLength := 0, 0\nfor i, v := range P {\n\tif v > longestLength {\n\t\tlongestLength = v\n\t\tlongestCenter = i\n\t}\n}\noffset := (longestCenter - longestLength) / 2\nreturn s[offset : offset+longestLength]", "gen": "var a [10]int\nvar b [10]int\nvar c int\nvar d int\nfor i := 0; i < len(a); i++ {\n\tc = a[i]\n\td = b[i]\n}\nfmt.Println(c, d)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for j := 1; j <= 20; j++ {\n\tif num%j != 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a int\nfor i := 0; i < 20; i++ {\n\tif i == 0 {\n\t\ta = 1 / i\n\t} else if i == 1 {\n\t\ta = 1\n\t} else {\n\t\ta = a / i\n\t}\n\tif a == 0 {\n\t\tbreak\n\t}\n}\nif a == 0 {\n\tpanic(\"divide by zero\")\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "n := node.(*bstElement)\nif n == nil {\n\treturn nil\n}\nif n.right != nil {\n\treturn t.Min(n.right)\n}\ncur := n\nfor cur.parent != nil && cur.parent.left != cur {\n\tcur = cur.parent\n}\nreturn cur.parent", "gen": "var bst *BST\nbst = NewBST()\nbst.Insert(10)\nbst.Insert(20)\nbst.Insert(30)\nbst.Insert(40)\nbst.Insert(50)\nbst.Insert(60)\nbst.Insert(70)\nbst.Insert(80)\nbst.Insert(90)\nbst.Insert(100)\nbst.Insert(110)\nbst.Insert(120)\nbst.Insert(130)\nbst.Insert(140)\nbst.Insert(150)\nbst.Insert(160)\nbst.Insert(170)\nbst.Insert(180)\nbst.Insert(190)\nbst.Insert(200)\nbst.Insert(210)\nbst.Insert(220)\nbst.Insert(230)\nbst.Insert(240)\nbst.Insert(250)\nbst.Insert(260)\nbst.Insert(270)\nbst.Insert(280)\nbst.Insert(290)\nbst.Insert(300)\nbst.Insert(310)\nbst.Insert(320)\nbst.Insert(330)\nbst.Insert(340)\nbst.Insert(350)\nbst.Insert(360)\nbst.Insert(370)\nbst.Insert(380)\nbst.Insert(390)\nbst.Insert(400)\nbst.Insert(410)\nbst.Insert(420)\nbst.Insert(430)\nbst.Insert(440)\nbst.Insert(450)\nbst.Insert(460)\nbst.Insert(470)\nbst.Insert(480)\nbst.Insert(490)\nbst."}
{"tgt": "var r [][]int\nfor i := begin; i <= end; i++ {\n\tif 1 == k {\n\t\tr = append(r, []int{i})\n\t\tcontinue\n\t}\n\tsuf := comb(i+1, end, k-1)\n\tfor _, j := range suf {\n\t\tr = append(r, append([]int{i}, j...))\n\t}\n}\nreturn r", "gen": "var a, b, c int\nvar comb func(a, b, c int) [][]int\ncomb = func(a, b, c int) [][]int {\n\tvar comb [][]int\n\tif a == 1 {\n\t\tcomb = append(comb, []int{1, 1})\n\t\treturn comb\n\t}\n\tfor i := 1; i <= a; i++ {\n\t\tfor j := 1; j <= b; j++ {\n\t\t\tfor k := 1; k <= c; k++ {\n\t\t\t\tif i+j+k == a+b+c {\n\t\t\t\t\tcomb = append(comb, []int{i, j, k})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn comb\n}\nfmt.Println(comb(a, b, c))\n}\n"}
{"tgt": "b.lock.Lock()\ndefer b.lock.Unlock()\ne := b.table[key]\nif e == nil {\n\treturn nil, false\n}\nif e.expire.Before(now) {\n\tif b.ExpireGracePeriod == 0 || e.expire.Sub(now) > b.ExpireGracePeriod {\n\t\tb.removeEntry(e)\n\t}\n\treturn nil, false\n}\nb.touchEntry(e)\nreturn e.value, true", "gen": "var m sync.Mutex\nvar c = NewLRUCache(100)\nm.Lock()\nc.Get(\"a\")\nc.Get(\"b\")\nc.Get(\"c\")\nc.Get(\"d\")\nc.Get(\"e\")\nc.Get(\"f\")\nc.Get(\"g\")\nc.Get(\"h\")\nc.Get(\"i\")\nc.Get(\"j\")\nc.Get(\"k\")\nc.Get(\"l\")\nc.Get(\"m\")\nc.Get(\"n\")\nc.Get(\"o\")\nc.Get(\"p\")\nc.Get(\"q\")\nc.Get(\"r\")\nc.Get(\"s\")\nc.Get(\"t\")\nc.Get(\"u\")\nc.Get(\"v\")\nc.Get(\"w\")\nc.Get(\"x\")\nc.Get(\"y\")\nc.Get(\"z\")\nm.Unlock()\n}\n"}
{"tgt": "if root == nil {\n\treturn 0\n}\nresult := 0\nif root.Val >= L && root.Val <= R {\n\tresult += root.Val\n}\nif root.Val >= L {\n\tresult += rangeSumBST(root.Left, L, R)\n}\nif root.Val <= R {\n\tresult += rangeSumBST(root.Right, L, R)\n}\nreturn result", "gen": "fmt.Println(rangeSumBST(nil, 1))\nfmt.Println(rangeSumBST([]int{10}, 1))\nfmt.Println(rangeSumBST([]int{10, 5}, 7))\nfmt.Println(rangeSumBST([]int{10, 5}, 12))\nfmt.Println(rangeSumBST([]int{10, 5}, 11))\nfmt.Println(rangeSumBST([]int{10, 5}, 10))\nfmt.Println(rangeSumBST([]int{10, 5}, 5))\nfmt.Println(rangeSumBST([]int{10, 5}, 4))\nfmt.Println(rangeSumBST([]int{10, 5}, 3))\nfmt.Println(rangeSumBST([]int{10, 5}, 2))\nfmt.Println(rangeSumBST([]int{10, 5}, 1))\nfmt.Println(rangeSumBST([]int{10, 5}, 0))\nfmt.Println(rangeSumBST([]int{10, 5}, -1))\nfmt.Println(rangeSumBST([]int{10, 5}, -2))\nfmt.Println(rangeSumBST([]int{10, 5}, -3))\nfmt.Println(rangeSumBST([]int{10, 5}, -4))\nfmt.Println(rangeSumBST([]int{10, 5}, -5))\nfmt.Println(rangeSumBST([]int{10, 5}, -6))\nfmt.Println(rangeSumBST([]int{10, 5}, -7))\nfmt.Println(rangeSumBST([]int{10, 5}, -8))\nfmt.Println(rangeSumBST([]int{10, 5}, -9))\nfmt."}
{"tgt": "if tree.root == nil {\n\treturn nil, false\n}\ncurrentNode := tree.root\nfor currentNode != nil {\n\tif i == currentNode.data {\n\t\treturn currentNode, true\n\t} else if i > currentNode.data {\n\t\tcurrentNode = currentNode.right\n\t} else if i < currentNode.data {\n\t\tcurrentNode = currentNode.left\n\t}\n}\nreturn nil, false", "gen": "var a, b int\na = 1\nb = 2\nvar c int\nvar d bool\nc, d = f(a, b)\nfmt.Println(c, d)\n}\n"}
{"tgt": "length := len(nums)\nif length == 0 || length == 1 && nums[0] != target {\n\treturn []int{-1, -1}\n}\nreturn searchRangeI(nums, 0, length-1, target)", "gen": "var nums = []int{2, 5, 6, 0, 0, 1, 2}\nvar target = 3\nvar result = searchRange(nums, target)\nfmt.Println(result)\n}\n"}
{"tgt": "var (\n\tl int\n\tr = len(nums) - 1\n)\nfor l <= r {\n\tmid := l + (r-l)/2\n\tif target == nums[mid] {\n\t\treturn mid\n\t}\n\tif nums[mid] >= nums[l] && nums[mid] > nums[r] {\n\t\tif target >= nums[l] && target < nums[mid] {\n\t\t\tr = mid - 1\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t} else {\n\t\tif target > nums[mid] && target <= nums[r] {\n\t\t\tl = mid + 1\n\t\t} else {\n\t\t\tr = mid - 1\n\t\t}\n\t}\n}\nreturn -1", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif i < len(a) {\n\t\tif i < len(a) {\n\t\t\tif i < len(a) {\n\t\t\t\tif i < len(a) {\n\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len("}
{"tgt": "if squares < 3 {\n\treturn 1\n}\nif answer, ok := memo[squares]; ok {\n\treturn answer\n}\ntotal := int64(1)\nfor size := 3; size <= squares; size++ {\n\tfor start := 0; start <= squares-size; start++ {\n\t\tanswer := int64(1)\n\t\tanswer *= ways(squares - start - size - 1)\n\t\ttotal += answer\n\t}\n}\nmemo[squares] = total\nreturn total", "gen": "var n int\nfmt.Scan(&n)\nmemo := make(map[int][2]int64)\nfmt.Println(ways(n, memo))\n}\n"}
{"tgt": "return &CircularBuffer{\n\tbuffer: make([]interface{}, size),\n\tsize:   size,\n\tavail:  make(chan bool, size),\n}", "gen": "var c chan bool\nvar b []interface{}\nvar a CircularBuffer\nc = make(chan bool)\nb = make([]interface{}, 0)\na = CircularBuffer{}\na.data = make([]interface{}, 0)\na.head = 0\na.tail = 0\na.len = 0\na.cap = 0\na.ch = c\na.buf = b\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return uint32((dev >> 8) & 0xff)", "gen": "var a int\na = 0\na >>= 8\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 4,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 6,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 6,\n\t},\n}\nfor _, tt := range tests {\n\tgot := longestValidParentheses(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(longestValidParentheses(\"(()\"))\nfmt.Println(longestValidParentheses(\")()())\"))\nfmt.Println(longestValidParentheses(\"()(()\"))\nfmt.Println(longestValidParentheses(\")()()\"))\nfmt.Println(longestValidParentheses(\"()\"))\nfmt.Println(longestValidParentheses(\"()()\"))\nfmt.Println(longestValidParentheses(\"()()()\"))\nfmt.Println(longestValidParentheses(\"()(()\"))\nfmt.Println(longestValidParentheses(\"()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()()()()()\"))\nfmt.Println("}
{"tgt": "iterator := func() <-chan VertexId {\n\tch := make(chan VertexId)\n\tgo func() {\n\t\tif connected, ok := g.edges[vertex]; ok {\n\t\t\tfor VertexId, _ := range connected {\n\t\t\t\tif g.IsEdge(vertex, VertexId) {\n\t\t\t\t\tch <- VertexId\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\nreturn VerticesIterable(&vertexIterableHelper{iterFunc: iterator})", "gen": "g := NewGraph()\nv1 := g.AddVertex(1)\nv2 := g.AddVertex(2)\ng.AddEdge(v1, v2)\nfmt.Println(g)\n}\n"}
{"tgt": "ans := 0\nfor ; x != 0; x /= 10 {\n\tans = ans*10 + x%10\n}\nif ans < math.MinInt32 || ans > math.MaxInt32 {\n\treturn 0\n}\nreturn ans", "gen": "var a int64\nvar b int64\na = 0\nb = 0\nfor {\n\tif b == 0 {\n\t\tbreak\n\t}\n\tb = (b * 7) >> 2\n\ta = (a * 7) >> 2\n\ta = a - b\n\ta = a - (a >> 63)\n\ta = (a * 7) >> 2\n\ta = a - (a >> 63)\n\ta = a - (a >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> 2)\n\tb = b - (b >> "}
{"tgt": "i, size := 0, len(s)\nss := make([]string, numRows)\nfor i < size {\n\tfor j := 0; j < numRows && i < size; j++ {\n\t\tss[j] += string(s[i])\n\t\ti++\n\t}\n\tfor j := numRows - 2; j > 0 && i < size; j-- {\n\t\tss[j] += string(s[i])\n\t\ti++\n\t}\n}\nvar ret string\nfor j := 0; j < numRows; j++ {\n\tret += ss[j]\n}\nreturn ret", "gen": "var s []string\nfor i := 0; i < 10; i++ {\n\ts = append(s, strconv.Itoa(i))\n}\nfor i := 0; i < len(s); i++ {\n\tfmt.Println(s[i])\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "sum := big.NewInt(0)\nfor i := int64(1); i <= 1000; i++ {\n\tval := big.NewInt(i)\n\tsum.Add(sum, pow(val, i))\n}\nfmt.Println(\"STR\", sum.String())", "gen": "var a big.Int\na.SetInt64(1)\nfor i := 0; i < 1000; i++ {\n\ta.Add(&a, &a)\n}\nfmt.Println(a.String())\n}"}
{"tgt": "for l, r := 0, len(A)-1; ; {\n\tm := (l + r) / 2\n\tif A[m] < A[m+1] {\n\t\tl = m\n\t} else if A[m-1] > A[m] {\n\t\tr = m\n\t} else {\n\t\treturn m\n\t}\n}", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif i < len(a) {\n\t\tif i < len(a) {\n\t\t\tif i < len(a) {\n\t\t\t\tif i < len(a) {\n\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len("}
{"tgt": "max := 1000\nsum := 0\nfor i := 1; i < max; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)", "gen": "var a int\nvar b int\nvar c int\nfor i := 1; i < 1000; i++ {\n\tif i%3 == 0 {\n\t\ta += i\n\t}\n\tif i%5 == 0 {\n\t\tb += i\n\t}\n\tif i%3 == 0 && i%5 == 0 {\n\t\tc += i\n\t}\n}\nfmt.Println(a, b, c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if k < 0 || len(nums) == 0 {\n\treturn 0\n}\nvar count int\nm := make(map[int]int, len(nums))\nfor _, value := range nums {\n\tm[value]++\n}\nfor key := range m {\n\tif k == 0 && m[key] > 1 {\n\t\tcount++\n\t\tcontinue\n\t}\n\tif k > 0 && m[key+k] > 0 {\n\t\tcount++\n\t}\n}\nreturn count", "gen": "var m map[int][2]int\nvar i int\nvar j int\nvar k int\nvar v [2]int\nvar ok bool\nvar v0 int\nvar v1 int\nvar v2 int\nvar v3 int\nvar v4 int\nvar v5 int\nvar v6 int\nvar v7 int\nvar v8 int\nvar v9 int\nvar v10 int\nvar v11 int\nvar v12 int\nvar v13 int\nvar v14 int\nvar v15 int\nvar v16 int\nvar v17 int\nvar v18 int\nvar v19 int\nvar v20 int\nvar v21 int\nvar v22 int\nvar v23 int\nvar v24 int\nvar v25 int\nvar v26 int\nvar v27 int\nvar v28 int\nvar v29 int\nvar v30 int\nvar v31 int\nvar v32 int\nvar v33 int\nvar v34 int\nvar v35 int\nvar v36 int\nvar v37 int\nvar v38 int\nvar v39 int\nvar v40 int\nvar v41 int\nvar v42 int\nvar v43 int\nvar v44 int\nvar v45 int\nvar v46 int\nvar v47 int\nvar v48 int\nvar v49 int\nvar v50 int\nvar v51 int\nvar v52 int\nvar v53 int\nvar v54 int\nvar v55 int\nvar v56 int\nvar v57 int\nvar v58 int\nvar v59 int\nvar v60 int\nvar v61 int\nvar v62 int\nvar v63 int\nvar v64 int\nvar v65 int\nvar v66 int\nvar"}
{"tgt": "parentMap, countMap := make(map[int]int), make(map[int]int)\nfor _, num := range nums {\n\tif _, exists := parentMap[num]; exists {\n\t\tcontinue\n\t}\n\tparentMap[num], countMap[num] = num, 1\n\tneighbors := [2]int{num - 1, num + 1}\n\tfor _, n := range neighbors {\n\t\tif _, exists := parentMap[n]; exists {\n\t\t\tcount1 := countMap[getParent128(n, parentMap)]\n\t\t\tcount2 := countMap[getParent128(num, parentMap)]\n\t\t\tunion128(n, num, parentMap)\n\t\t\tcountMap[getParent128(num, parentMap)] = count1 + count2\n\t\t}\n\t}\n}\nmax := 0\nfor _, count := range countMap {\n\tif count > max {\n\t\tmax = count\n\t}\n}\nreturn max", "gen": "var a, b, c int\nfmt.Scan(&a, &b, &c)\nfmt.Println(getParent(a, b, c))\n}\n"}
{"tgt": "sort.Ints(people)\nthin, fat := 0, len(people)-1\nres := 0\nfor thin <= fat {\n\tif people[thin]+people[fat] <= limit {\n\t\tthin++\n\t}\n\tfat--\n\tres++\n}\nreturn res", "gen": "var a []int\nsort.Ints(a)\nfmt.Println(a[0])\n}\n\n<ASM>\n.LFB1:\ncmpq %fs:112,%rsp\njnb .L1\nmovl $56,%r10d\nmovl $24,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L1:\npushq %rbp\nmovq %rsp,%rbp\nsubq $48,%rsp\nmovq %rdi,-40(%rbp)\nmovq $0,-32(%rbp)\n.LBB10:\nsubq $8,%rsp\npushq <32>(%rbp)\npushq <24>(%rbp)\npushq <16>(%rbp)\ncall <sort.Ints@PLT>\naddq $32,%rsp\nmovq $0,-8(%rbp)\nmovq <24>(%rbp),%rax\nsubq $1,%rax\nmovq %rax,-16(%rbp)\nmovq $0,-24(%rbp)\n.LBB11:\n.LBB12:\njmp .L2\n.L10:\n.LBB13:\nnop\n.LBE13:\n.LBB14:\n.LBB15:\nmovq <24>(%rbp),%rax\ncmpq $0,-8(%rbp)\njs .L3\ncmpq %rax,-8(%rbp)\njl .L11\n.L3:\nmovq -8(%rbp),%rdx\nmovq %rax,%rsi\nmovq %rdx,%rdi\ncall <runtime.goPanicIndex@PLT>\n.L11:\nmovq <24>(%rbp),%rax\ncmpq $0,-16(%rbp)\njs .L5\ncmpq %rax,-16(%rbp)\njl .L12\n.L5:\nmovq -16(%rbp),"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{1, 8, 6, 2, 5, 4, 8, 3, 7},\n\t\twant: 49,\n\t},\n\t{\n\t\tin:   []int{1, 8, 6, 30, 20, 6, 9, 10, 1},\n\t\twant: 48,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxArea(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(maxArea([]int{1, 8, 6, 2, 5, 4, 8, 3, 7}))\nfmt.Println(maxArea([]int{1, 1}))\nfmt.Println(maxArea([]int{4, 3, 2, 1, 4}))\nfmt.Println(maxArea([]int{1, 2, 1}))\nfmt.Println(maxArea([]int{2, 1}))\nfmt.Println(maxArea([]int{1, 2}))\nfmt.Println(maxArea([]int{1}))\nfmt.Println(maxArea([]int{}))\n}\n"}
{"tgt": "count, k := make([]int, 128), len(s)/4\nfor _, v := range s {\n\tcount[int(v)]++\n}\nleft, right, res := 0, -1, len(s)\nfor left < len(s) {\n\tif count['Q'] > k || count['W'] > k || count['E'] > k || count['R'] > k {\n\t\tif right+1 < len(s) {\n\t\t\tright++\n\t\t\tcount[s[right]]--\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t} else {\n\t\tres = min(res, right-left+1)\n\t\tcount[s[left]]++\n\t\tleft++\n\t}\n}\nreturn res", "gen": "var s string\nvar t string\nvar res int\nres = min(len(s), len(t))\nreturn\n}"}
{"tgt": "http.HandleFunc(\"STR\", handler)", "gen": "http.HandleFunc(\"/\", handler)\n}\n"}
{"tgt": "pairs := [...][2]int{{15, 26}, {1000, 1366}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p16(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var p16 [2]int\np16[0] = 15\np16[1] = 26\nvar p1000 [2]int\np1000[0] = 1366\np1000[1] = 1000\nvar p1 [2]int\np1[0] = 15\np1[1] = 26\nvar p2 [2]int\np2[0] = 1366\np2[1] = 1000\nvar p3 [2]int\np3[0] = 15\np3[1] = 26\nvar p4 [2]int\np4[0] = 1366\np4[1] = 1000\nvar p5 [2]int\np5[0] = 15\np5[1] = 26\nvar p6 [2]int\np6[0] = 1366\np6[1] = 1000\nvar p7 [2]int\np7[0] = 15\np7[1] = 26\nvar p8 [2]int\np8[0] = 1366\np8[1] = 1000\nvar p9 [2]int\np9[0] = 15\np9[1] = 26\nvar p10 [2]int\np10[0] = 1366\np10[1] = 1000\nvar p11 [2]int\np11[0] = 15\np11[1] = 26\nvar p12 [2]int\np12[0] = 1366\np12[1] = 1000\nvar p13 [2]int\np13[0]"}
{"tgt": "n := len(matrix)\nl, r := matrix[0][0], matrix[n-1][n-1]\nfor l < r {\n\tm := (l + r) / 2\n\tcount := 0\n\tfor i := 0; i < n; i++ {\n\t\tj := n - 1\n\t\tfor j >= 0 && matrix[i][j] > m {\n\t\t\tj--\n\t\t}\n\t\tcount += j + 1\n\t}\n\tif count < k {\n\t\tl = m + 1\n\t} else {\n\t\tr = m\n\t}\n}\nreturn l", "gen": "var a [3]int\nvar b [3]int\nvar c int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 4\nb[1] = 5\nb[2] = 6\nc = a[0] + a[1] + a[2] + b[0] + b[1] + b[2]\nfmt.Println(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tm: 3,\n\t\tn: 3,\n\t\tops: [][]int{\n\t\t\t{2, 2},\n\t\t\t{3, 3},\n\t\t},\n\t\twant: 4,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxCount(tt.m, tt.n, tt.ops)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.m, got, tt.want)\n\t}\n}", "gen": "fmt.Println(maxCount(2, 2, 3, 3))\nfmt.Println(maxCount(2, 2, 3, 3, 4, 4))\nfmt.Println(maxCount(2, 2, 3, 3, 4, 4, 2, 2))\nfmt.Println(maxCount(2, 2, 3, 3, 4, 4, 2, 2, 2, 2))\nfmt.Println(maxCount(2, 2, 3, 3, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif isPartite := IsBipartiteGraph(tc.g); isPartite != tc.isPartite {\n\t\tt.Errorf(\"STR\", tc.isPartite, isPartite)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "var i int\nlength := len(nums)\nif length <= 1 {\n\treturn\n}\nfor i = length - 1; i >= 1; i-- {\n\tif nums[i] > nums[i-1] {\n\t\tbreak\n\t}\n}\nif i > 0 {\n\tsort.Ints(nums[i:])\n\tfor j := i - 1; j < length; j++ {\n\t\tif nums[j] > nums[i-1] {\n\t\t\tnums[i-1], nums[j] = nums[j], nums[i-1]\n\t\t\treturn\n\t\t}\n\t}\n}\nsort.Ints(nums)", "gen": "var a []int\na = append(a, 1)\na = append(a, 2)\na = append(a, 3)\na = append(a, 4)\na = append(a, 5)\na = append(a, 6)\na = append(a, 7)\na = append(a, 8)\na = append(a, 9)\na = append(a, 10)\na = append(a, 11)\na = append(a, 12)\na = append(a, 13)\na = append(a, 14)\na = append(a, 15)\na = append(a, 16)\na = append(a, 17)\na = append(a, 18)\na = append(a, 19)\na = append(a, 20)\na = append(a, 21)\na = append(a, 22)\na = append(a, 23)\na = append(a, 24)\na = append(a, 25)\na = append(a, 26)\na = append(a, 27)\na = append(a, 28)\na = append(a, 29)\na = append(a, 30)\na = append(a, 31)\na = append(a, 32)\na = append(a, 33)\na = append(a, 34)\na = append(a, 35)\na = append(a, 36)\na = append(a, 37)\na = append(a, 38)\na = append(a, 39)\na = append(a, 40)\na = append(a, 41)\na = append(a, 42)"}
{"tgt": "return LoadUint64(&r.Reg)", "gen": "var x uint64\nx = 0\nif x == 0 {\n\tpanic(\"\")\n}\n}\n\n<ASM>\nmovq %rdi,-24(%rbp)\nmovq $0,-8(%rbp)\n.LBB34:\n.LBB35:\ncmpq $0,-24(%rbp)\njne .L107\ncall <runtime.panicmem@PLT>\n.L107:\nmovq -24(%rbp),%rax\nmovq %rax,-8(%rbp)\nmovq -8(%rbp),%rax\n.LBE35:\n.LBE34:\nleave\nret</ASM>"}
{"tgt": "var tests = []struct {\n\tnumber int\n\ttitle  string\n}{\n\t{1, \"STR\"},\n\t{28, \"STR\"},\n\t{701, \"STR\"},\n}\nfor _, tt := range tests {\n\ttitle := convertToTitle(tt.number)\n\tif title != tt.title {\n\t\tt.Errorf(\"STR\", tt.number, title, tt.title)\n\t}\n}", "gen": "fmt.Println(convertToTitle(1))\nfmt.Println(convertToTitle(28))\nfmt.Println(convertToTitle(701))\nfmt.Println(convertToTitle(2147483647))\n}\n"}
{"tgt": "empty := countBucket{}\nfor i, _ := range ss.olist {\n\tdelete(ss.hash, ss.olist[i].key)\n\tss.olist[i] = empty\n}", "gen": "var m map[string]uint32\nm = make(map[string]uint32)\nm[\"a\"] = 1\nm[\"b\"] = 2\nm[\"c\"] = 3\nm[\"d\"] = 4\nm[\"e\"] = 5\nm[\"f\"] = 6\nm[\"g\"] = 7\nm[\"h\"] = 8\nm[\"i\"] = 9\nm[\"j\"] = 10\nm[\"k\"] = 11\nm[\"l\"] = 12\nm[\"m\"] = 13\nm[\"n\"] = 14\nm[\"o\"] = 15\nm[\"p\"] = 16\nm[\"q\"] = 17\nm[\"r\"] = 18\nm[\"s\"] = 19\nm[\"t\"] = 20\nm[\"u\"] = 21\nm[\"v\"] = 22\nm[\"w\"] = 23\nm[\"x\"] = 24\nm[\"y\"] = 25\nm[\"z\"] = 26\nvar i int\nfor i = 0; i < 26; i++ {\n\tdelete(m, string(i+'a'))\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tresult := EloGames(tc.scores, tc.kFactor, tc.matches)\n\tfor i := range result {\n\t\tresult[i] = math.Round(result[i]*tc.tolerance) / tc.tolerance\n\t}\n\tif !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "l.insert(e, &l.root)", "gen": "var h *FibHeap\nh = NewFibHeap()\nh.Insert(10)\n}\n\n// \u6808\u4e0a\u5206\u914d"}
{"tgt": "if root == nil {\n\treturn 0\n}\nmax := height(root.Left)\nif h := height(root.Right); h > max {\n\tmax = h\n}\nreturn max + 1", "gen": "root := &TreeNode{Val: 1, Left: &TreeNode{Val: 2}, Right: &TreeNode{Val: 3}}\nfmt.Println(maxDepth(root))\n}\n"}
{"tgt": "qs := []question598{\n\t{\n\t\tpara598{3, 3, [][]int{{2, 2}, {3, 3}}},\n\t\tans598{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans598, q.para598\n\tfmt.Printf(\"STR\", p, maxCount(p.m, p.n, p.ops))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "var tests = []struct {\n\tnums    []int\n\ttarget  int\n\tindices []int\n}{\n\t{[]int{2, 7, 11, 15}, 9, []int{0, 1}},\n\t{[]int{2, 3, 4, 6}, 6, []int{0, 2}},\n\t{[]int{2, 3, 4, 7}, 8, nil},\n\t{nil, 8, nil},\n}\nfor _, tt := range tests {\n\tindices := twoSum(tt.nums, tt.target)\n\tif reflect.DeepEqual(indices, tt.indices) == false {\n\t\tt.Errorf(\"STR\", tt.nums, tt.target, indices, tt.indices)\n\t}\n}", "gen": "fmt.Println(twoSum([]int{2, 7, 11, 15}, 9))\nfmt.Println(twoSum([]int{3, 2, 4}, 6))\nfmt.Println(twoSum([]int{3, 3}, 6))\n}\n"}
{"tgt": "if isSquare(n) {\n\treturn 1\n}\nfor n%4 == 0 {\n\tn /= 4\n}\nif n%8 == 7 {\n\treturn 4\n}\nfor i := 1; i <= mySqrt(n); i++ {\n\tif isSquare(n - i*i) {\n\t\treturn 2\n\t}\n}\nreturn 3", "gen": "fmt.Println(mySqrt(8))\n}\n"}
{"tgt": "if N < 3 {\n\treturn N\n} else if N == 3 {\n\treturn 5\n}\nmod := 1000000007\ndp := make([]int, N+1)\ndp[1], dp[2], dp[3] = 1, 2, 5\nfor i := 4; i <= N; i++ {\n\tdp[i] = 2*dp[i-1] + dp[i-3]\n\tdp[i] %= mod\n}\nreturn dp[N]", "gen": "var a []int\na = make([]int, 2)\na[0] = 1\na[1] = 2\na[2] = 5\na[3] = 1000000007\na[4] = 1\na[5] = 2\na[6] = 5\na[7] = 1000000007\na[8] = 1\na[9] = 2\na[10] = 5\na[11] = 1000000007\na[12] = 1\na[13] = 2\na[14] = 5\na[15] = 1000000007\na[16] = 1\na[17] = 2\na[18] = 5\na[19] = 1000000007\na[20] = 1\na[21] = 2\na[22] = 5\na[23] = 1000000007\na[24] = 1\na[25] = 2\na[26] = 5\na[27] = 1000000007\na[28] = 1\na[29] = 2\na[30] = 5\na[31] = 1000000007\na[32] = 1\na[33] = 2\na[34] = 5\na[35] = 1000000007\na[36] = 1\na[37] = 2\na[38] = 5\na[39] = 1000000007\na"}
{"tgt": "stack := []byte{}\nfor i := range num {\n\tdigit := num[i]\n\tfor k > 0 && len(stack) > 0 && digit < stack[len(stack)-1] {\n\t\tstack = stack[:len(stack)-1]\n\t\tk--\n\t}\n\tstack = append(stack, digit)\n}\nstack = stack[:len(stack)-k]\nans := strings.TrimLeft(string(stack), \"STR\")\nif ans == \"STR\" {\n\tans = \"STR\"\n}\nreturn ans", "gen": "var s []byte\nfor {\n\tr, _, err := bufio.NewReader(os.Stdin).ReadRune()\n\tif err != nil {\n\t\tbreak\n\t}\n\tif r == 127 {\n\t\tbreak\n\t}\n\ts = append(s, byte(r))\n}\nif len(s) == 0 {\n\tfmt.Println(\"\")\n\treturn\n}\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns = s[:len(s)-1]\ns ="}
{"tgt": "if e.element.list != &b.freeList {\n\tpanic(\"STR\")\n}\nif !e.expire.IsZero() {\n\theap.Push(&b.priorityQueue, e)\n}\nb.freeList.Remove(&e.element)\nb.lruList.PushElementFront(&e.element)\nb.table[e.key] = e", "gen": "var m = New(100)\nm.Set(\"a\", 1)\nm.Set(\"b\", 2)\nm.Set(\"c\", 3)\nm.Set(\"d\", 4)\nm.Set(\"e\", 5)\nm.Set(\"f\", 6)\nm.Set(\"g\", 7)\nm.Set(\"h\", 8)\nm.Set(\"i\", 9)\nm.Set(\"j\", 10)\nm.Set(\"k\", 11)\nm.Set(\"l\", 12)\nm.Set(\"m\", 13)\nm.Set(\"n\", 14)\nm.Set(\"o\", 15)\nm.Set(\"p\", 16)\nm.Set(\"q\", 17)\nm.Set(\"r\", 18)\nm.Set(\"s\", 19)\nm.Set(\"t\", 20)\nm.Set(\"u\", 21)\nm.Set(\"v\", 22)\nm.Set(\"w\", 23)\nm.Set(\"x\", 24)\nm.Set(\"y\", 25)\nm.Set(\"z\", 26)\nm.Set(\"aa\", 27)\nm.Set(\"bb\", 28)\nm.Set(\"cc\", 29)\nm.Set(\"dd\", 30)\nm.Set(\"ee\", 31)\nm.Set(\"ff\", 32)\nm.Set(\"gg\", 33)\nm.Set(\"hh\", 34)\nm.Set(\"ii\", 35)\nm.Set(\"jj\", 36)\nm.Set(\"kk\", 37)\nm.Set(\"ll\", 38)\nm.Set(\"mm\", 39)\nm.Set(\"nn\", 40)\nm.Set(\"oo\", 41)\nm.Set(\""}
{"tgt": "in := make([]int, N)\nout := make([]int, N)\nfor _, pair := range trust {\n\tout[pair[0]-1]++\n\tin[pair[1]-1]++\n}\nfor i := 0; i < N; i++ {\n\tif in[i] == N-1 && out[i] == 0 {\n\t\treturn i + 1\n\t}\n}\nreturn -1", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar bb [3]int\nvar cc [3]int\nvar dd [3]int\nvar ee [3]int\nvar ff [3]int\nvar gg [3]int\nvar hh [3]int\nvar ii [3]int\nvar jj [3]int\nvar kk [3]int\nvar ll [3]int\nvar mm [3]int\nvar nn [3]int\nvar oo [3]int\nvar pp [3]int\nvar qq [3]int\nvar rr [3]int\nvar ss [3]int\nvar tt [3]int\nvar uu [3]int\nvar vv [3]int\nvar ww [3]int\nvar xx [3]int\nvar yy [3]int\nvar zz [3]int\nvar aaa [3]int\nvar bbb [3]int\nvar ccc [3]int\nvar ddd [3]int\nvar eee [3]int\nvar fff [3]int\nvar ggg [3]int\nvar hhh [3]"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs int\n\texpect int\n}{\n\t{\"STR\", 2, 1},\n\t{\"STR\", 3, 2},\n\t{\"STR\", 4, 3},\n\t{\"STR\", 0, 0},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.TestSolution()\n}\n"}
{"tgt": "return xtime.Unix(int64(jt), 0), nil", "gen": "var t time.Time\nt = time.Unix(0, 0)\nvar t2 time.Time\nt2 = time.Unix(0, 0)\nvar t3 time.Time\nt3 = time.Unix(0, 0)\nvar t4 time.Time\nt4 = time.Unix(0, 0)\nvar t5 time.Time\nt5 = time.Unix(0, 0)\nvar t6 time.Time\nt6 = time.Unix(0, 0)\nvar t7 time.Time\nt7 = time.Unix(0, 0)\nvar t8 time.Time\nt8 = time.Unix(0, 0)\nvar t9 time.Time\nt9 = time.Unix(0, 0)\nvar t10 time.Time\nt10 = time.Unix(0, 0)\nvar t11 time.Time\nt11 = time.Unix(0, 0)\nvar t12 time.Time\nt12 = time.Unix(0, 0)\nvar t13 time.Time\nt13 = time.Unix(0, 0)\nvar t14 time.Time\nt14 = time.Unix(0, 0)\nvar t15 time.Time\nt15 = time.Unix(0, 0)\nvar t16 time.Time\nt16 = time.Unix(0, 0)\nvar t17 time.Time\nt17 = time.Unix(0, 0)\nvar t18 time.Time\nt18 = time.Unix(0, 0)\nvar t19 time.Time\nt19 = time.Unix(0, 0)\nvar t20 time.Time\nt20 = time.Unix(0, 0)\nvar t21 time.Time\nt21 = time.Unix(0"}
{"tgt": "if len(name) == 0 && len(typed) == 0 {\n\treturn true\n}\nif (len(name) == 0 && len(typed) != 0) || (len(name) != 0 && len(typed) == 0) {\n\treturn false\n}\nj := 0\nfor i := 0; i < len(name); i++ {\n\tif j < len(typed) && name[i] == typed[j] {\n\t\tj++\n\t\tcontinue\n\t} else {\n\t\tif i > 0 && j < len(typed) && name[i-1] == typed[j] {\n\t\t\tj++\n\t\t\ti--\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "var a [2]int\nvar b [2]int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar ba int\nvar bb int\nvar bc int\nvar bd int\nvar be int\nvar bf int\nvar bg int\nvar bh int\nvar bi int\nvar bj int\nvar bk int\nvar bl int\nvar bm int\nvar bn int\nvar bo int\nvar bp int\nvar bq int\nvar br int\nvar bs int\nvar bt int\nvar bu int\nvar bv int\nvar bw int\nvar bx int\nvar by int\nvar bz int\nvar ca int\nvar cb int\nvar cc int\nvar cd int\nvar ce int\nvar cf int\nvar cg int\nvar ch int\nvar ci int\nvar cj int\nvar ck int\nvar cl int\nvar cm int\nvar cn int\nvar co int\nvar cp int\n"}
{"tgt": "var i, j, tmp int\nfor i = 1; i < len(arr); i++ {\n\ttmp = arr[i]\n\tfor j = i; j > 0 && arr[j-1] > tmp; j-- {\n\t\tarr[j] = arr[j-1]\n\t}\n\tarr[j] = tmp\n}\nreturn arr", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\na[0] = 1\nb[0] = 1\nc[0] = 1\nfor i := 1; i < len(a); i++ {\n\ta[i] = a[i-1] + b[i-1]\n\tb[i] = a[i-1] + c[i-1]\n\tc[i] = b[i-1] + c[i-1]\n}\nfmt.Println(a[len(a)-1], b[len(b)-1], c[len(c)-1])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "res = [][]string{}\nif len(s) < 1 {\n\treturn res\n}\nhelper(s, 0, []string{})\nreturn res", "gen": "var res string\nres = \"hello\"\nfmt.Println(res)\n}"}
{"tgt": "if from == to {\n\treturn errors.New(\"STR\")\n}\nif !g.CheckVertex(from) || !g.CheckVertex(to) {\n\treturn errors.New(\"STR\")\n}\ni, _ := g.edges[from][to]\nj, _ := g.edges[to][from]\nif i > 0 || j > 0 {\n\treturn errors.New(\"STR\")\n}\ng.TouchVertex(from)\ng.TouchVertex(to)\ng.edges[from][to] = weight\nif !g.isDirected {\n\tg.edges[to][from] = weight\n}\ng.edgesCount++\nreturn nil", "gen": "g := graph.New()\ng.AddVertex(1)\ng.AddVertex(2)\ng.AddVertex(3)\ng.AddVertex(4)\ng.AddVertex(5)\ng.AddVertex(6)\ng.AddVertex(7)\ng.AddVertex(8)\ng.AddVertex(9)\ng.AddVertex(10)\ng.AddVertex(11)\ng.AddVertex(12)\ng.AddVertex(13)\ng.AddVertex(14)\ng.AddVertex(15)\ng.AddVertex(16)\ng.AddVertex(17)\ng.AddVertex(18)\ng.AddVertex(19)\ng.AddVertex(20)\ng.AddVertex(21)\ng.AddVertex(22)\ng.AddVertex(23)\ng.AddVertex(24)\ng.AddVertex(25)\ng.AddVertex(26)\ng.AddVertex(27)\ng.AddVertex(28)\ng.AddVertex(29)\ng.AddVertex(30)\ng.AddVertex(31)\ng.AddVertex(32)\ng.AddVertex(33)\ng.AddVertex(34)\ng.AddVertex(35)\ng.AddVertex(36)\ng.AddVertex(37)\ng.AddVertex(38)\ng.AddVertex(39)\ng.AddVertex(40)\ng.AddVertex(41)\ng.AddVertex(42)\ng.AddVertex(43)\ng.AddVertex(44)\ng.AddVertex(45)\ng.AddVertex(46)\ng.AddVertex(47)\ng.AddVertex(48)\ng.AddVertex(49)\ng.AddVertex(50)\n"}
{"tgt": "i := 0\ndefer fmt.Println(\"STR\", i)\ndefer fmt.Println(\"STR\")\ndefer fmt.Println(\"STR\")\ni++\nfmt.Println(\"STR\", i)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\n"}
{"tgt": "maxIndex := [26]int{}\nfor i, b := range S {\n\tmaxIndex[b-'a'] = i\n}\nbegin := 0\nend := maxIndex[S[begin]-'a']\nres := make([]int, 0, len(S))\nfor i, b := range S {\n\tif i < end {\n\t\tend = max(end, maxIndex[b-'a'])\n\t\tcontinue\n\t}\n\tres = append(res, i-begin+1)\n\tbegin = i + 1\n\tif begin < len(S) {\n\t\tend = maxIndex[S[begin]-'a']\n\t}\n}\nreturn res", "gen": "var s string\nvar t []int\nfmt.Scan(&s)\nfor _, r := range s {\n\tif r == ' ' {\n\t\tcontinue\n\t}\n\tif r < 'a' {\n\t\tpanic(\"invalid input\")\n\t}\n\tif r > 'z' {\n\t\tpanic(\"invalid input\")\n\t}\n\tt = append(t, int(r-'a'))\n}\nif len(t) == 0 {\n\tpanic(\"invalid input\")\n}\nif len(t) == 1 {\n\tfmt.Println(t[0])\n\treturn\n}\nvar max int\nfor i := 0; i < len(t)-1; i++ {\n\tif t[i] > t[i+1] {\n\t\tmax = max(max, t[i])\n\t} else {\n\t\tmax = max(max, t[i+1])\n\t}\n}\nfmt.Println(max)\n}"}
{"tgt": "FirstNumber := 1\nSecondNumber := 2\nnextNumber := 0\nsum := SecondNumber\nfor nextNumber < 4000000 {\n\tnextNumber = FirstNumber + SecondNumber\n\tif nextNumber%2 == 0 {\n\t\tsum = sum + nextNumber\n\t}\n\tFirstNumber = SecondNumber\n\tSecondNumber = nextNumber\n}\nfmt.Println(\"STR\", sum, \"STR\")", "gen": "var a, b int\nfor i := 0; i < 4000000; i++ {\n\ta, b = b, a+b\n\tif i%2 == 0 {\n\t\ta = a + b\n\t}\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{2},\n\t\t\t{3, 4},\n\t\t\t{6, 5, 7},\n\t\t\t{4, 1, 8, 3},\n\t\t},\n\t\t11},\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{1},\n\t\t\t{2, 3},\n\t\t},\n\t\t3},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := minimumTotal(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "timeDelta := now.Sub(r.lastTimestamp)\nreturn r.Ewma.Update(nanosec/float64(timeDelta.Nanoseconds()), now)", "gen": "var ewma ewma.Ewma\nvar start time.Time\nvar duration time.Duration\nvar elapsed time.Duration\nvar t time.Time\nvar d time.Duration\nvar ewma2 ewma.Ewma\nvar start2 time.Time\nvar duration2 time.Duration\nvar elapsed2 time.Duration\nvar t2 time.Time\nvar d2 time.Duration\nvar ewma3 ewma.Ewma\nvar start3 time.Time\nvar duration3 time.Duration\nvar elapsed3 time.Duration\nvar t3 time.Time\nvar d3 time.Duration\nvar ewma4 ewma.Ewma\nvar start4 time.Time\nvar duration4 time.Duration\nvar elapsed4 time.Duration\nvar t4 time.Time\nvar d4 time.Duration\nvar ewma5 ewma.Ewma\nvar start5 time.Time\nvar duration5 time.Duration\nvar elapsed5 time.Duration\nvar t5 time.Time\nvar d5 time.Duration\nvar ewma6 ewma.Ewma\nvar start6 time.Time\nvar duration6 time.Duration\nvar elapsed6 time.Duration\nvar t6 time.Time\nvar d6 time.Duration\nvar ewma7 ewma.Ewma\nvar start7 time.Time\nvar duration7 time.Duration\nvar elapsed7 time.Duration\nvar t7 time.Time\nvar d7 time.Duration\nvar ewma8 ewma.Ewma\nvar start8 time.Time\nvar duration8 time.Duration\nvar elapsed8 time.Duration\nvar t8 time.Time\nvar d8 time.Duration\nvar ewma9 ewma.Ewma\nvar start9 time.Time\nvar duration9 time.Duration\nvar elapsed9 time.Duration\nvar t9 time.Time\nvar d9 time.Duration\nvar ewma10 ewma."}
{"tgt": "if list.head == nil {\n\treturn false\n}\nif list.head.data == i {\n\tlist.head = list.head.next\n\treturn true\n}\ncurrent := list.head\nfor current.next != nil {\n\tif current.next.data == i {\n\t\tcurrent.next = current.next.next\n\t\treturn true\n\t}\n\tcurrent = current.next\n}\nreturn false", "gen": "var a [10]int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar ba int\nvar bb int\nvar bc int\nvar bd int\nvar be int\nvar bf int\nvar bg int\nvar bh int\nvar bi int\nvar bj int\nvar bk int\nvar bl int\nvar bm int\nvar bn int\nvar bo int\nvar bp int\nvar bq int\nvar br int\nvar bs int\nvar bt int\nvar bu int\nvar bv int\nvar bw int\nvar bx int\nvar by int\nvar bz int\nvar ca int\nvar cb int\nvar cc int\nvar cd int\nvar ce int\nvar cf int\nvar cg int\nvar ch int\nvar ci int\nvar cj int\nvar ck int\nvar cl int\nvar cm int\nvar cn int\nvar co int\nvar cp int\nvar c"}
{"tgt": "mySet := make(map[int]int, 0)\nfor _, v := range candies {\n\tmySet[v]++\n}\nif len(mySet) >= len(candies)/2 {\n\treturn len(candies) / 2\n}\nreturn len(mySet)", "gen": "m := make(map[int]int)\nfor i := 0; i < 100; i++ {\n\tm[i] = i + 1\n}\nfmt.Println(m[99])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "a := []float64{1, 2, 3, 4, 5, 6}\nA := MakeMatrix(a, 3, 2)\nif A.cols != 2 ||\n\tA.rows != 3 ||\n\t!FloatArrayEquals(A.Elements, a) {\n\tt.Error()\n}", "gen": "var a = matrix.MakeMatrix(2, 3, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0)\nif !matrix.FloatArrayEquals(a.Get(2, 3), 1.0, 2.0, 3.0) {\n\tt.Error(\"a.Get(2, 3) != [1.0, 2.0, 3.0]\")\n}\nif a.Get(2, 3)[0] != 1.0 {\n\tt.Error(\"a.Get(2, 3)[0] != 1.0\")\n}\nif a.Get(2, 3)[1] != 2.0 {\n\tt.Error(\"a.Get(2, 3)[1] != 2.0\")\n}\nif a.Get(2, 3)[2] != 3.0 {\n\tt.Error(\"a.Get(2, 3)[2] != 3.0\")\n}\nif a.Get(2, 3)[3] != 4.0 {\n\tt.Error(\"a.Get(2, 3)[3] != 4.0\")\n}\nif a.Get(2, 3)[4] != 5.0 {\n\tt.Error(\"a.Get(2, 3)[4] != 5.0\")\n}\nif a.Get(2, 3)[5] != 6.0 {\n\tt.Error(\"a.Get(2, 3)[5] != 6.0\")\n}\nif a.Get(2, 3)[6] != 7.0 {\n\tt.Error(\"a.Get(2, 3)[6] != 7.0\")\n}\nif a.Get(2, 3)[7] != 8.0 {\n\tt.Error(\"a.Get(2, 3)[7] != 8.0\")\n}\nif a.Get(2,"}
{"tgt": "count := 0\nfor _, c := range word {\n\tif unicode.IsUpper(c) {\n\t\tcount++\n\t}\n}\nreturn count == 0 || count == len(word) || (count == 1 && unicode.IsUpper(rune(word[0])))", "gen": "var s string\nvar c int\nvar u bool\nfor i := 0; i < len(s); i++ {\n\tif i == 0 {\n\t\tu = unicode.IsUpper(s[i])\n\t}\n\tif s[i] == 127 {\n\t\tpanic(\"\")\n\t}\n\tc, _ = utf8.DecodeRuneInString(s[i:])\n\tif c == 127 {\n\t\tpanic(\"\")\n\t}\n\tif unicode.IsUpper(s[i]) {\n\t\tu = true\n\t}\n}\nif len(s) == 0 {\n\treturn\n}\nif len(s) == 1 {\n\tif unicode.IsUpper(s[0]) {\n\t\tu = true\n\t}\n\treturn\n}\nif s[0] == 127 {\n\tpanic(\"\")\n}\nif s[len(s)-1] == 127 {\n\tpanic(\"\")\n}\nif unicode.IsUpper(s[0]) {\n\tu = true\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "p.mu.Lock()\nactive := p.active\np.mu.Unlock()\nreturn active", "gen": "var m sync.Mutex\nvar x int\nm.Lock()\nx = 44\nm.Unlock()\nreturn x\n}\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 44\n// \tm.Unlock()\n// \treturn x\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 44\n// \tm.Unlock()\n// \treturn x\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 44\n// \tm.Unlock()\n// \treturn x\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 44\n// \tm.Unlock()\n// \treturn x\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 44\n// \tm.Unlock()\n// \treturn x\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 44\n// \tm.Unlock()\n// \treturn x\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 44\n// \tm.Unlock()\n// \treturn x\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 4"}
{"tgt": "select {\ncase r, ok := <-p.resources:\n\tlog.Println(\"STR\", \"STR\")\n\tif !ok {\n\t\treturn nil, ErrPoolClosed\n\t}\n\treturn r, nil\ndefault:\n\tlog.Println(\"STR\", \"STR\")\n\treturn p.factory()\n}", "gen": "var ch chan int\nvar i int\nvar j int\nvar k int\nvar v int\nvar err error\nch = make(chan int, 2)\ni = 0\nj = 0\nk = 0\nv = 0\nerr = nil\nselect {\ncase ch <- i:\n\tj = 0\n\tk = 0\n\tv = 0\n\terr = nil\ncase ch <- j:\n\tk = 0\n\tv = 0\n\terr = nil\ncase ch <- k:\n\tv = 0\n\terr = nil\ndefault:\n\tv = 0\n\terr = nil\n}\nlog.Println(v, err)\nselect {\ncase ch <- i:\n\tj = 0\n\tk = 0\n\tv = 0\n\terr = nil\ncase ch <- j:\n\tk = 0\n\tv = 0\n\terr = nil\ncase ch <- k:\n\tv = 0\n\terr = nil\ndefault:\n\tv = 0\n\terr = nil\n}\nlog.Println(v, err)\nselect {\ncase ch <- i:\n\tj = 0\n\tk = 0\n\tv = 0\n\terr = nil\ncase ch <- j:\n\tk = 0\n\tv = 0\n\terr = nil\ncase ch <- k:\n\tv = 0\n\terr = nil\ndefault:\n\tv = 0\n\terr = nil\n}\nlog.Println(v, err)\nselect {\ncase ch <- i:\n\tj = 0\n\tk = 0\n\tv = 0\n\terr = nil\ncase ch <- j:\n\tk = 0\n\tv = 0\n\terr = nil\ncase ch <- k:\n\tv = 0\n"}
{"tgt": "err := ioutil.WriteFile(path, []byte(content), 0755)\nif err != nil {\n\tlog.Fatal(err)\n}", "gen": "var s string\nvar b []byte\nvar err error\ns = \"hello\"\nb = []byte(s)\nerr = ioutil.WriteFile(\"hello.txt\", b, 0644)\nif err != nil {\n\tlog.Fatal(err)\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "tree := New(compare)\ntree.Insert(1)\ntree.Insert(2)\ntree.Insert(3)\nfindTree := tree.Search(2)\nif findTree.node != 2 {\n\tt.Error(\"STR\")\n}\nfindNilTree := tree.Search(100)\nif findNilTree != nil {\n\tt.Error(\"STR\")\n}", "gen": "tree := New()\ntree.Insert(1)\ntree.Insert(2)\ntree.Insert(3)\nif tree.Search(1) != 1 {\n\tt.Error(\"1 should be 1\")\n}\nif tree.Search(2) != 2 {\n\tt.Error(\"2 should be 2\")\n}\nif tree.Search(3) != 3 {\n\tt.Error(\"3 should be 3\")\n}\nif tree.Search(4) != nil {\n\tt.Error(\"4 should be nil\")\n}\n}\n"}
{"tgt": "l := new(ListNode)\nn := l\nvar extra int\nfor l1 != nil || l2 != nil {\n\tn.Next = new(ListNode)\n\tn = n.Next\n\tif l1 != nil {\n\t\textra += l1.Val\n\t\tl1 = l1.Next\n\t}\n\tif l2 != nil {\n\t\textra += l2.Val\n\t\tl2 = l2.Next\n\t}\n\tn.Val = extra % 10\n\textra /= 10\n}\nif extra > 0 {\n\tn.Next = &ListNode{Val: extra}\n}\nreturn l.Next", "gen": "fmt.Println(addTwoNumbers(\n\t&go.leetcode.ListNode{Val: 2, Next: &go.leetcode.ListNode{Val: 4, Next: &go.leetcode.ListNode{Val: 3}}},\n\t&go.leetcode.ListNode{Val: 5, Next: &go.leetcode.ListNode{Val: 6, Next: &go.leetcode.ListNode{Val: 4}}},\n))\n}\n"}
{"tgt": "empty := 0\nhold := -1 << 63\nfor _, p := range prices {\n\ttemp := empty\n\tempty = max(empty, hold+p)\n\thold = max(hold, temp-p-fee)\n}\nreturn empty", "gen": "var a, b, c int\na = 0\nb = 0\nc = 0\nfor i := 0; i < len(arr); i++ {\n\tif i == 0 {\n\t\ta = max(arr[i], arr[i+1])\n\t\tc = max(a, b)\n\t} else if i == len(arr)-1 {\n\t\tb = max(arr[i], arr[i-1])\n\t\tc = max(a, b)\n\t} else {\n\t\ta = max(arr[i], arr[i+1])\n\t\tb = max(arr[i], arr[i-1])\n\t\tc = max(a, b)\n\t}\n}\nfmt.Println(c)\n}\n"}
{"tgt": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"STR\", got, tt.want)\n\t\t}\n\t})\n}", "gen": "tests := []struct {\n\tname string\n\targs args\n\twant int\n}{\n\t{\"\", args{\"abcde\", \"cdefg\"}, 2},\n\t{\"\", args{\"abcd\", \"cdab\"}, 4},\n\t{\"\", args{\"abc\", \"abc\"}, 3},\n\t{\"\", args{\"ab\", \"ab\"}, 3},\n\t{\"\", args{\"a\", \"a\"}, 3},\n\t{\"\", args{\"\", \"\"}, 0},\n\t{\"\", args{\"abc\", \"def\"}, 0},\n\t{\"\", args{\"abc\", \"abc\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},\n\t{\"\", args{\"abc\", \"abcd\"}, 3},"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   5,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   10,\n\t\twant: 5,\n\t},\n\t{\n\t\tin:   0,\n\t\twant: 1,\n\t},\n}\nfor _, tt := range tests {\n\tgot := bitwiseComplement(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var a, b, c, d int\na = 5\nb = 2\nc = 7\nd = 0\na = 10\nb = 5\nc = 0\nd = 1\nvar e, f int\ne = 4\nf = 0\nfor i := 0; i < 4; i++ {\n\tif i == 3 {\n\t\tbreak\n\t}\n\te = 4\n\tf = 0\n\tvar g, h int\n\tg = a\n\th = b\n\ta = c\n\tb = d\n\tc = e\n\td = f\n\te = g\n\tf = h\n}\nvar i, j int\ni = 0\nj = 1\nvar k int\nk = 2\nvar l int\nl = 3\nvar m int\nm = 4\nvar n int\nn = 5\nvar o int\no = 6\nvar p int\np = 7\nvar q int\nq = 8\nvar r int\nr = 9\nvar s int\ns = 10\nvar t int\nt = 11\nvar u int\nu = 12\nvar v int\nv = 13\nvar w int\nw = 14\nvar x int\nx = 15\nvar y int\ny = 16\nvar z int\nz = 17\nvar aa int\naa = 18\nvar bb int\nbb = 19\nvar cc int\ncc = 20\nvar dd int\ndd = 21\nvar ee int\nee = 22\nvar ff int\nff = 23\nvar gg int\ngg = 24\nvar hh int\nhh = 25\nvar ii int\nii = 26\n"}
{"tgt": "syscall.Exit(code)", "gen": "runtime.GOMAXPROCS(1)\ngo func() {\n\truntime.GOMAXPROCS(1)\n\tfor {\n\t\truntime.GOMAXPROCS(1)\n\t}\n}()\nruntime.GOMAXPROCS(1)\nfor {\n\truntime.GOMAXPROCS(1)\n}\n}\n"}
{"tgt": "if len(input) == 0 {\n\treturn true\n}\nif len(input)%2 != 0 {\n\treturn false\n}\nvar stack []byte\nfor i := 0; i < len(input); i++ {\n\tif input[i] == \"STR\" || input[i] == \"STR\" || input[i] == \"STR\" {\n\t\tstack = append(stack, input[i])\n\t} else {\n\t\tif len(stack) > 0 {\n\t\t\tpair := string(stack[len(stack)-1]) + string(input[i])\n\t\t\tstack = stack[:len(stack)-1]\n\t\t\tif pair != \"STR\" && pair != \"STR\" && pair != \"STR\" {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn len(stack) == 0", "gen": "var a []byte\nvar b []byte\nvar c bool\nvar d bool\nvar e bool\nvar f bool\nvar g bool\nvar h bool\nvar i bool\nvar j bool\nvar k bool\nvar l bool\nvar m bool\nvar n bool\nvar o bool\nvar p bool\nvar q bool\nvar r bool\nvar s bool\nvar t bool\nvar u bool\nvar v bool\nvar w bool\nvar x bool\nvar y bool\nvar z bool\nvar aa bool\nvar ab bool\nvar ac bool\nvar ad bool\nvar ae bool\nvar af bool\nvar ag bool\nvar ah bool\nvar ai bool\nvar aj bool\nvar ak bool\nvar al bool\nvar am bool\nvar an bool\nvar ao bool\nvar ap bool\nvar aq bool\nvar ar bool\nvar as bool\nvar at bool\nvar au bool\nvar av bool\nvar aw bool\nvar ax bool\nvar ay bool\nvar az bool\nvar ba bool\nvar bb bool\nvar bc bool\nvar bd bool\nvar be bool\nvar bf bool\nvar bg bool\nvar bh bool\nvar bi bool\nvar bj bool\nvar bk bool\nvar bl bool\nvar bm bool\nvar bn bool\nvar bo bool\nvar bp bool\nvar bq bool\nvar br bool\nvar bs bool\nvar bt bool\nvar bu bool\nvar bv bool\nvar bw bool\nvar bx bool\nvar by bool\nvar bz bool\nvar ca bool\nvar cb bool\nvar cc bool\nvar cd bool\nvar ce bool\nvar cf bool\nvar cg bool\nvar ch bool\nvar ci bool\nvar cj bool\nvar ck bool\nvar cl bool\nvar cm bool\nvar cn bool\nvar co bool\nvar cp bool\nvar cq bool"}
{"tgt": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 0},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 11},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 19},\n\t\tans1208{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s, p.t, p.maxCost))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{124123, 13425, 123, 65, 1, 54362, 134, 6543, 213}, 3},\n\t{\"STR\", []int{}, 0},\n\t{\"STR\", []int{4253626756, 3245876, 2345897, 23490}, 1},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "if len(sorted) == 0 {\n\treturn nil\n}\nmid := len(sorted) / 2\nroot := &BST{Value: sorted[mid]}\nroot.Left = SortedSliceToBST(sorted[:mid])\nroot.Right = SortedSliceToBST(sorted[mid+1:])\nreturn root", "gen": "var a []int\na = append(a, 1)\na = append(a, 2)\na = append(a, 3)\na = append(a, 4)\na = append(a, 5)\na = append(a, 6)\na = append(a, 7)\na = append(a, 8)\na = append(a, 9)\na = append(a, 10)\na = append(a, 11)\na = append(a, 12)\na = append(a, 13)\na = append(a, 14)\na = append(a, 15)\na = append(a, 16)\na = append(a, 17)\na = append(a, 18)\na = append(a, 19)\na = append(a, 20)\na = append(a, 21)\na = append(a, 22)\na = append(a, 23)\na = append(a, 24)\na = append(a, 25)\na = append(a, 26)\na = append(a, 27)\na = append(a, 28)\na = append(a, 29)\na = append(a, 30)\na = append(a, 31)\na = append(a, 32)\na = append(a, 33)\na = append(a, 34)\na = append(a, 35)\na = append(a, 36)\na = append(a, 37)\na = append(a, 38)\na = append(a, 39)\na = append(a, 40)\na = append(a, 41)\na = append(a, 42)"}
{"tgt": "negative := false\nif num < 0 {\n\tnegative = true\n\tnum = -num\n}\nbf := bytes.NewBufferString(\"STR\")\nfor num >= 7 {\n\tmod := num % 7\n\tnum /= 7\n\tbf.WriteByte(byte(mod) + 48)\n}\nbf.WriteByte(byte(num) + 48)\nif negative {\n\tbf.WriteByte('-')\n}\nbs := bf.Bytes()\nfor s, e := 0, len(bs)-1; s < e; s, e = s+1, e-1 {\n\tbs[s], bs[e] = bs[e], bs[s]\n}\nreturn string(bs)", "gen": "var s string\nfor i := 0; i < 6; i++ {\n\tif i == 0 {\n\t\ts += \"a\"\n\t} else {\n\t\ts += \"b\"\n\t}\n}\ns += \"c\"\nfmt.Println(s)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "s = strings.ToLower(s)\ni, j := 0, len(s)-1\nfor i < j {\n\tfor i < j && !isChar(s[i]) {\n\t\ti++\n\t}\n\tfor i < j && !isChar(s[j]) {\n\t\tj--\n\t}\n\tif s[i] != s[j] {\n\t\treturn false\n\t}\n\ti++\n\tj--\n}\nreturn true", "gen": "fmt.Println(isAnagram(\"a\", \"a\"))\nfmt.Println(isAnagram(\"anagram\", \"nagaram\"))\nfmt.Println(isAnagram(\"rat\", \"car\"))\nfmt.Println(isAnagram(\"\", \"\"))\nfmt.Println(isAnagram(\"\", \"a\"))\nfmt.Println(isAnagram(\"a\", \"\"))\nfmt.Println(isAnagram(\"a\", \"b\"))\nfmt.Println(isAnagram(\"ab\", \"a\"))\nfmt.Println(isAnagram(\"ab\", \"b\"))\nfmt.Println(isAnagram(\"ab\", \"ab\"))\nfmt.Println(isAnagram(\"ab\", \"ba\"))\nfmt.Println(isAnagram(\"ab\", \"ac\"))\nfmt.Println(isAnagram(\"ab\", \"ad\"))\nfmt.Println(isAnagram(\"ab\", \"ae\"))\nfmt.Println(isAnagram(\"ab\", \"af\"))\nfmt.Println(isAnagram(\"ab\", \"ag\"))\nfmt.Println(isAnagram(\"ab\", \"ah\"))\nfmt.Println(isAnagram(\"ab\", \"ai\"))\nfmt.Println(isAnagram(\"ab\", \"aj\"))\nfmt.Println(isAnagram(\"ab\", \"ak\"))\nfmt.Println(isAnagram(\"ab\", \"al\"))\nfmt.Println(isAnagram(\"ab\", \"am\"))\nfmt.Println(isAnagram(\"ab\", \"an\"))\nfmt.Println(isAnagram(\"ab\", \"ao\"))\nfmt.Println(isAnagram(\"ab\", \"ap\"))\nfmt.Println(isAnagram(\"ab\", \"aq\"))\nfmt.Println(isAnagram(\"ab\", \"ar\"))\nfmt.Println(isAnagram(\"ab\", \"as\"))\nfmt.Println(isAnagram(\"ab\", \"at\"))\nfmt.Println(isAnagram(\"ab\", \"au\"))\nfmt.Println(isAnagram(\"ab\", \"av\"))\nfmt.Print"}
{"tgt": "n := len(nums)\ntmp := make([]int, n)\ncopy(tmp, nums)\nfor i := 0; i < n; i++ {\n\tnums[(i+k)%n] = tmp[i]\n}", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\ta = append(a, i)\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "random := rand.New(rand.NewSource(time.Now().UnixNano()))\narray := make([]int, random.Intn(100-10)+10)\nfor i := range array {\n\tarray[i] = random.Intn(100)\n}\nSortArray(array)\nfor _, value := range array {\n\tresult := ExponentialSearch(array, value)\n\tif result == -1 {\n\t\tt.Fail()\n\t}\n}", "gen": "var t time.Time\nvar rnd *math_rand.Rand\nvar rndSource int64\nvar rndInt int\nvar rndInt2 int\nvar rndInt3 int\nvar rndInt4 int\nvar rndInt5 int\nvar rndInt6 int\nvar rndInt7 int\nvar rndInt8 int\nvar rndInt9 int\nvar rndInt10 int\nvar rndInt11 int\nvar rndInt12 int\nvar rndInt13 int\nvar rndInt14 int\nvar rndInt15 int\nvar rndInt16 int\nvar rndInt17 int\nvar rndInt18 int\nvar rndInt19 int\nvar rndInt20 int\nvar rndInt21 int\nvar rndInt22 int\nvar rndInt23 int\nvar rndInt24 int\nvar rndInt25 int\nvar rndInt26 int\nvar rndInt27 int\nvar rndInt28 int\nvar rndInt29 int\nvar rndInt30 int\nvar rndInt31 int\nvar rndInt32 int\nvar rndInt33 int\nvar rndInt34 int\nvar rndInt35 int\nvar rndInt36 int\nvar rndInt37 int\nvar rndInt38 int\nvar rndInt39 int\nvar rndInt40 int\nvar rndInt41 int\nvar rndInt42 int\nvar rndInt43 int\nvar rndInt44 int\nvar rndInt45 int\nvar rndInt46 int\nvar rndInt47 int\nvar rndInt48 int\nvar rndInt49 int\nvar rndInt50 int\nvar rndInt51 int\nvar rndInt52 int\nvar rndInt53 int\nvar rndInt"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimumPartitionPalindrome(tc.input); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "fmt.Println(\"Day 181\")\nfmt.Println(\"Puzzle 1:\", puzzle1())\nfmt.Println(\"Puzzle 2:\", puzzle2())\n}\n"}
{"tgt": "obj := Constructor732()\nfmt.Printf(\"STR\", obj.Book(10, 20))\nfmt.Printf(\"STR\", obj.Book(50, 60))\nfmt.Printf(\"STR\", obj.Book(10, 40))\nfmt.Printf(\"STR\", obj.Book(5, 15))\nfmt.Printf(\"STR\", obj.Book(5, 10))\nfmt.Printf(\"STR\", obj.Book(25, 55))", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "if a == nil && b == nil {\n\treturn true\n}\nif len(a) != len(b) {\n\treturn false\n}\nfor i := range a {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nvar b [10]int\nvar c int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tif a[i] != b[i] {\n\t\tc = 0\n\t\tbreak\n\t}\n\tc = 1\n}\nif c == 0 {\n\tpanic(\"not equal\")\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "val := \"STR\"\nfor i := 1; i < n; i++ {\n\tvar (\n\t\tc   int\n\t\tv   byte\n\t\tstr string\n\t)\n\tfor j := 0; j < len(val); j++ {\n\t\tif val[j] == v {\n\t\t\tc++\n\t\t\tcontinue\n\t\t}\n\t\tif c != 0 {\n\t\t\tstr += string(c+'0') + string(v)\n\t\t}\n\t\tc, v = 1, val[j]\n\t}\n\tval = str + string(c+'0') + string(v)\n}\nreturn val", "gen": "var a [10]int\nvar b [10]byte\nvar c int\nvar d byte\nfor i := 0; i < 10; i++ {\n\tc = a[i]\n\td = b[i]\n\tif c != d {\n\t\tpanic(\"\")\n\t}\n}\n}\n\n// func main() {\n// \tvar a [10]int\n// \tvar b [10]byte\n// \tvar c int\n// \tvar d byte\n// \tfor i := 0; i < 10; i++ {\n// \t\tc = a[i]\n// \t\td = b[i]\n// \t\tif c != d {\n// \t\t\tpanic(\"\")\n// \t\t}\n// \t}\n// }\n\n// func main() {\n// \tvar a [10]int\n// \tvar b [10]byte\n// \tvar c int\n// \tvar d byte\n// \tfor i := 0; i < 10; i++ {\n// \t\tc = a[i]\n// \t\td = b[i]\n// \t\tif c != d {\n// \t\t\tpanic(\"\")\n// \t\t}\n// \t}\n// }\n\n// func main() {\n// \tvar a [10]int\n// \tvar b [10]byte\n// \tvar c int\n// \tvar d byte\n// \tfor i := 0; i < 10; i++ {\n// \t\tc = a[i]\n// \t\td = b[i]\n// \t\tif c != d {\n// \t\t\tpanic(\"\")\n// \t\t}\n// \t}\n// }\n\n// func main() {\n// \tvar a [10]int\n// \tvar b [10]byte\n// \tvar c int\n// \tvar d byte\n// \tfor i := 0; i < 10;"}
{"tgt": "res := 0\nif n != 0 {\n\trightMostBitInt := n & -n\n\tnextHigherSetBitInt := n + rightMostBitInt\n\td := n ^ nextHigherSetBitInt\n\td /= rightMostBitInt\n\td >>= 2\n\tres = nextHigherSetBitInt | d\n}\nreturn res", "gen": "var a int\nvar b int\na = -1\nb = -1\nif a < 0 {\n\tb = a / -1\n}\nfmt.Println(b)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(nums) == 0 || len(nums) < k {\n\treturn make([]int, 0)\n}\nqueue := make([]int, 0, k)\nans := make([]int, len(nums)-k+1)\nfor left, right := 1-k, 0; right < len(nums); left, right = left+1, right+1 {\n\tif left > 0 && queue[0] == nums[left-1] {\n\t\tqueue = queue[1:len(queue)]\n\t}\n\tfor len(queue) != 0 && queue[len(queue)-1] < nums[right] {\n\t\tqueue = queue[:len(queue)-1]\n\t}\n\tqueue = append(queue, nums[right])\n\tif left >= 0 {\n\t\tans[left] = queue[0]\n\t}\n}\nreturn ans", "gen": "var a []int\nvar b []int\nvar c []int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar ba int\nvar bb int\nvar bc int\nvar bd int\nvar be int\nvar bf int\nvar bg int\nvar bh int\nvar bi int\nvar bj int\nvar bk int\nvar bl int\nvar bm int\nvar bn int\nvar bo int\nvar bp int\nvar bq int\nvar br int\nvar bs int\nvar bt int\nvar bu int\nvar bv int\nvar bw int\nvar bx int\nvar by int\nvar bz int\nvar ca int\nvar cb int\nvar cc int\nvar cd int\nvar ce int\nvar cf int\nvar cg int\nvar ch int\nvar ci int\nvar cj int\nvar ck int\nvar cl int\nvar cm int\nvar cn int\nvar co int\nvar cp int\nvar cq"}
{"tgt": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{}\n} else if n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{intervals[0]}\nfor _, cur := range intervals[1:] {\n\tprevious := res[len(res)-1]\n\tif cur.Start <= previous.End {\n\t\tend := previous.End\n\t\tif cur.End > end {\n\t\t\tend = cur.End\n\t\t}\n\t\tres = append(res[:len(res)-1], Interval{Start: previous.Start, End: end})\n\t} else {\n\t\tres = append(res, cur)\n\t}\n}\nreturn res", "gen": "fmt.Println(merge([]Interval{{1, 3}, {2, 6}, {8, 10}, {15, 18}}))\n}\n"}
{"tgt": "max := 9999\nbiggestPandigital := 0\nvar numberMultiplied int\nfor i := max; i > 0; i-- {\n\tnumberMultiplied = i\n\tfor j := 1; len(digits(numberMultiplied)) <= 9; j++ {\n\t\tnumberMultiplied = concatenMultiplication(i, j)\n\t\tif IsPandigital(numberMultiplied) && numberMultiplied > biggestPandigital {\n\t\t\tfmt.Println(numberMultiplied)\n\t\t\tbiggestPandigital = numberMultiplied\n\t\t}\n\t}\n}", "gen": "var pandigital []int\nfor i := 1; i < 10000; i++ {\n\tif IsPandigital(i) {\n\t\tpandigital = append(pandigital, i)\n\t}\n}\nfor _, i := range pandigital {\n\tif IsPandigital(i * i) {\n\t\tfmt.Println(i, i*i)\n\t}\n}\n}"}
{"tgt": "n := len(pushed)\ns := make([]int, 0, n)\ni := 0\nfor _, x := range pushed {\n\ts = append(s, x)\n\tfor len(s) != 0 && s[len(s)-1] == popped[i] {\n\t\ts = s[:len(s)-1]\n\t\ti++\n\t}\n}\nreturn i == n", "gen": "var a []int\nvar b []int\nvar c []int\nvar d int\nfor i := 0; i < 10; i++ {\n\tif i == 0 {\n\t\ta = make([]int, 0, 10)\n\t\tb = make([]int, 0, 10)\n\t\tc = make([]int, 0, 10)\n\t\td = 0\n\t}\n\ta = append(a, i)\n\tb = append(b, i)\n\tc = append(c, i)\n\td += i\n}\nif len(a) != 10 {\n\tpanic(\"len(a) != 10\")\n}\nif len(b) != 10 {\n\tpanic(\"len(b) != 10\")\n}\nif len(c) != 10 {\n\tpanic(\"len(c) != 10\")\n}\nif d != 45 {\n\tpanic(\"d != 45\")\n}\nif a[0] != 0 {\n\tpanic(\"a[0] != 0\")\n}\nif a[1] != 1 {\n\tpanic(\"a[1] != 1\")\n}\nif a[2] != 2 {\n\tpanic(\"a[2] != 2\")\n}\nif a[3] != 3 {\n\tpanic(\"a[3] != 3\")\n}\nif a[4] != 4 {\n\tpanic(\"a[4] != 4\")\n}\nif a[5] != 5 {\n\tpanic(\"a[5] != 5\")\n}\nif a[6] != 6 {\n\tpanic(\"a[6] != 6\")\n}\nif a[7] != 7 {\n\tpanic(\"a[7] != 7\")\n}\nif a[8"}
{"tgt": "testCases := [][]int{\n\t{1, 2, 3, 1},\n\t{1, 0, 1, 1},\n\t{1, 2, 3, 1, 2, 3},\n}\nks := []int{3, 1, 2}\nexpected := []bool{true, true, false}\nfor index, nums := range testCases {\n\tif res := containsNearbyDuplicate(nums, ks[index]); res != expected[index] {\n\t\tt.Errorf(\"STR\", expected[index], res)\n\t}\n}", "gen": "var a [4]int\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 1\na[4] = 1\na[5] = 2\na[6] = 3\na[7] = 1\na[8] = 2\na[9] = 3\na[10] = 1\na[11] = 2\na[12] = 3\na[13] = 1\na[14] = 2\na[15] = 3\na[16] = 1\na[17] = 2\na[18] = 3\na[19] = 1\na[20] = 2\na[21] = 3\na[22] = 1\na[23] = 2\na[24] = 3\na[25] = 1\na[26] = 2\na[27] = 3\na[28] = 1\na[29] = 2\na[30] = 3\na[31] = 1\na[32] = 2\na[33] = 3\na[34] = 1\na[35] = 2\na[36] = 3\na[37] = 1\na[38] = 2\na[39] = 3\na[40] = 1\na[41] = 2\na[42] = 3\na[43] = 1\na[44] = 2\na[45] = 3\na[46] = 1\na[47] = 2\na[48] = 3\na[49] = 1\na"}
{"tgt": "item := req.URL.Query().Get(\"STR\")\nif price, ok := db[item]; ok {\n\tfmt.Fprintf(w, \"STR\", price)\n} else {\n\tw.WriteHeader(http.StatusNotFound)\n\tfmt.Fprintf(w, \"STR\", item)\n}", "gen": "url := \"http://www.baidu.com\"\nresp, err := http.Get(url)\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer resp.Body.Close()\nbody, err := ioutil.ReadAll(resp.Body)\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Println(string(body))\n}\n```\n\n### \u6c47\u7f16\u4ee3\u7801\u89e3\u6790\n\n```\n.LVL2:\nret\n.L29:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $392,%rsp\nmovq %rdi,-328(%rbp)\nmovq %rsi,%rax\nmovq %rdx,%rsi\nmovq %rsi,%rdx\nmovq %rax,-352(%rbp)\nmovq %rdx,-344(%rbp)\nmovq %rcx,-336(%rbp)\nmovq -328(%rbp),%rax\nmovq %rax,-56(%rbp)\n.LBB19:\nmovq -336(%rbp),%rax\nmovq <16>(%rax),%rax\nmovq %rax,%rdi\ncall <net..z2furl.URL.Query@PLT>\nmovq %rax,%rdi\nleaq <.LC37>(%rip),%r12\nmovl $4,%r13d\nmovq %r12,%rcx\nmovq %r13,%rbx\nmovq %r12,%rax\nmovq %r13,%rdx\nmovq %rdx,%rax\nmovq %rcx,%rsi\nmovq %rax,%rdx\ncall <net..z2furl.Values.Get@PLT>\nmovq %rax,-320"}
{"tgt": "l, r := &maxHeap{}, &minHeap{}\nheap.Init(l)\nheap.Init(r)\nreturn MedianFinder{l, r}", "gen": "maxHeap := &MaxHeap{}\nminHeap := &MinHeap{}\nmaxHeap.Init(maxHeap, minHeap)\nminHeap.Init(maxHeap, minHeap)\nmaxHeap.Push(1)\nmaxHeap.Push(2)\nmaxHeap.Push(3)\nmaxHeap.Push(4)\nmaxHeap.Push(5)\nmaxHeap.Push(6)\nmaxHeap.Push(7)\nmaxHeap.Push(8)\nmaxHeap.Push(9)\nmaxHeap.Push(10)\nmaxHeap.Push(11)\nmaxHeap.Push(12)\nmaxHeap.Push(13)\nmaxHeap.Push(14)\nmaxHeap.Push(15)\nmaxHeap.Push(16)\nmaxHeap.Push(17)\nmaxHeap.Push(18)\nmaxHeap.Push(19)\nmaxHeap.Push(20)\nmaxHeap.Push(21)\nmaxHeap.Push(22)\nmaxHeap.Push(23)\nmaxHeap.Push(24)\nmaxHeap.Push(25)\nmaxHeap.Push(26)\nmaxHeap.Push(27)\nmaxHeap.Push(28)\nmaxHeap.Push(29)\nmaxHeap.Push(30)\nmaxHeap.Push(31)\nmaxHeap.Push(32)\nmaxHeap.Push(33)\nmaxHeap.Push(34)\nmaxHeap.Push(35)\nmaxHeap.Push(36)\nmaxHeap.Push(37)\nmaxHeap.Push(38)\nmaxHeap.Push(39)\nmaxHeap.Push(40)\nmaxHeap.Push(41)\nmaxHeap"}
{"tgt": "var buf [32]byte\ni := len(buf) - 1\nfor val >= 10 {\n\tbuf[i] = byte(val%10 + \"STR\")\n\ti--\n\tval /= 10\n}\nbuf[i] = byte(val + \"STR\")\nreturn string(buf[i:])", "gen": "var s []byte\nfor i := 0; i < 10; i++ {\n\ts = append(s, byte(i))\n}\nfmt.Println(string(s))\n}\n\n// \u7f16\u8bd1\u5668\u4f18\u5316"}
{"tgt": "if len(nums1) == 0 || len(nums2) == 0 {\n\treturn []int{}\n}\nnum1Map := make(map[int]bool)\nfor i := range nums1 {\n\tnum1Map[nums1[i]] = true\n}\nnum2Map := make(map[int]bool)\nvar res []int\nfor i := range nums2 {\n\tif _, ok1 := num1Map[nums2[i]]; ok1 && !num2Map[nums2[i]] {\n\t\tnum2Map[nums2[i]] = true\n\t\tres = append(res, nums2[i])\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "var ret [][]int\nvar nums []int\nnums = []int{-1, 0, 1, 2, -1, -4}\nret = [][]int{{-1, -1, 2}, {-1, 0, 1}}\nfor k, num := range threeSum(nums) {\n\tfor i, v := range num {\n\t\tif v != ret[k][i] {\n\t\t\tt.Fatalf(\"STR\", ret)\n\t\t}\n\t}\n}", "gen": "fmt.Println(threeSum([]int{0, 0, 0}))\n}\n"}
{"tgt": "dist := make([]int, N+1)\nfor i := 0; i < len(dist); i++ {\n\tdist[i] = math.MaxInt32\n}\ndist[K] = 0\nfor i := 0; i < N; i++ {\n\tfor _, t := range times {\n\t\tu, v, w := t[0], t[1], t[2]\n\t\tif dist[u] != math.MaxInt32 && dist[v] > dist[u]+w {\n\t\t\tdist[v] = dist[u] + w\n\t\t}\n\t}\n}\nmx := 0\nfor i := 1; i <= N; i++ {\n\tif mx < dist[i] {\n\t\tmx = dist[i]\n\t}\n}\nif mx == math.MaxInt32 {\n\treturn -1\n}\nreturn mx", "gen": "var a [10]int\nvar b [10]int\nvar c int\nfor i := 0; i < len(a); i++ {\n\ta[i] = i + 1\n}\nfor i := 0; i < len(b); i++ {\n\tb[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\tc = a[i]\n\tif i < len(b) {\n\t\tb[i] = c\n\t}\n}\nfmt.Println(b)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "dat, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\nnamesList := string(dat)\nnamesList = strings.Replace(namesList, \"STR\", \"STR\", -1)\nnames := strings.Split(namesList, \"STR\")\nsort.Strings(names)\nnamesScore := 0\nfor index, name := range names {\n\tnamesScore += nameScore(name) * (index + 1)\n}\nfmt.Println(namesScore)", "gen": "var s string\nvar err error\ns, err = ioutil.ReadFile(\"names.txt\")\nif err != nil {\n\tpanic(err)\n}\nvar names []string\nnames = strings.Split(s, \"\\n\")\nsort.Strings(names)\nvar nameScores []int\nfor _, name := range names {\n\tnameScores = append(nameScores, nameScore(name))\n}\nvar sum int\nfor _, score := range nameScores {\n\tsum += score\n}\nfmt.Println(sum)\n}"}
{"tgt": "var matrix [][]int\nmatrix = [][]int{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 9},\n}\nrotate(matrix)", "gen": "rotate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}, 3)\n}\n"}
{"tgt": "curr := n\nfor _, c := range s {\n\tnext, ok := curr.children[c]\n\tif !ok {\n\t\tnext = NewNode()\n\t\tcurr.children[c] = next\n\t}\n\tcurr = next\n}\ncurr.isLeaf = true", "gen": "var m map[int32]Node\nvar i int32\nvar c byte\nfor i = 0; i < 100; i++ {\n\tc, _ = utf8.DecodeRune([]byte(\"abc\"))\n\tif _, ok := m[i]; !ok {\n\t\tm[i] = NewNode()\n\t}\n\tm[i].Children[c] = nil\n}\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "sum := 0\nfor i := 2; i < 999999; i++ {\n\tif isSumOfFivePowerOfDigitsEqualToNumber(i) {\n\t\tsum += i\n\t}\n}\nreturn sum", "gen": "var sum int\nfor i := 0; i < 999999; i++ {\n\tif isSumOfFivePowerOfDigitsEqualToNumber(i) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}\n"}
{"tgt": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nret := &ListNode{}\nif l1.Val <= l2.Val {\n\tret = l1\n\tret.Next = mergeTwoLists1(l1.Next, l2)\n} else {\n\tret = l2\n\tret.Next = mergeTwoLists1(l1, l2.Next)\n}\nreturn ret", "gen": "fmt.Println(mergeTwoLists(nil, nil))\nfmt.Println(mergeTwoLists(nil, &ListNode{Val: 1}))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1}, nil))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1}, &ListNode{Val: 2}))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1, Next: &ListNode{Val: 2}}, &ListNode{Val: 1, Next: &ListNode{Val: 3}}))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}, &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}, &ListNode{Val: 1, Next: &ListNode{Val: 3}}))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}, &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: &ListNode{Val: 5}}}}))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}, &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: &ListNode{Val: 5, Next: &ListNode{Val: 6}}}}}))\nfmt.Println(mergeTwoLists(&ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &List"}
{"tgt": "a := int(math.Log10(float64(number))) + 1\nresult := 0\nfor i := 1; i <= a; i++ {\n\tresult += digit(number, i) * int(math.Pow10(a-i))\n}\nreturn result", "gen": "var n int64\nfmt.Scan(&n)\nfmt.Println(digit(n))\n}\n"}
{"tgt": "maxans := 0\ndp := make([]int, len(s))\nfor i := 1; i < len(s); i++ {\n\tif s[i] == \"STR\" {\n\t\tif s[i-1] == \"STR\" {\n\t\t\tif i >= 2 {\n\t\t\t\tdp[i] = dp[i-2] + 2\n\t\t\t} else {\n\t\t\t\tdp[i] = 2\n\t\t\t}\n\t\t} else if i-dp[i-1] > 0 && s[i-dp[i-1]-1] == \"STR\" {\n\t\t\tif i-dp[i-1] >= 2 {\n\t\t\t\tdp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2\n\t\t\t} else {\n\t\t\t\tdp[i] = dp[i-1] + 2\n\t\t\t}\n\t\t}\n\t}\n\tmaxans = Max(maxans, dp[i])\n}\nreturn maxans", "gen": "var s string\nvar t int\nfmt.Scan(&s)\nfor _, v := range s {\n\tif v == 'A' {\n\t\tt++\n\t}\n}\nfmt.Println(t)\n}\n"}
{"tgt": "s.lock.Lock()\ndefer s.lock.Unlock()\nl := len(s.nodes)\nif l == 0 {\n\treturn nil, errors.New(\"STR\")\n}\nnode := s.nodes[l-1]\ns.nodes = s.nodes[:l-1]\nreturn node, nil", "gen": "var s Solution\ns.thunk1()\n}\n"}
{"tgt": "max1, max2, max3, min1, min2 := -1001, -1001, -1001, 1001, 1001\nfor _, v := range nums {\n\tif v > max1 {\n\t\tmax3 = max2\n\t\tmax2 = max1\n\t\tmax1 = v\n\t} else if v > max2 {\n\t\tmax3 = max2\n\t\tmax2 = v\n\t} else if v > max3 {\n\t\tmax3 = v\n\t}\n\tif v < min1 {\n\t\tmin2 = min1\n\t\tmin1 = v\n\t} else if v < min2 {\n\t\tmin2 = v\n\t}\n}\nreturn max(max1*min1*min2, max1*max2*max3)", "gen": "var a, b, c int\nfmt.Scan(&a, &b, &c)\nfmt.Println(max(a, b, c))\n}"}
{"tgt": "h := fnv.New64a()\n_, _ = h.Write([]byte(fmt.Sprintf(\"STR\", key)))\nhashValue := h.Sum64()\nreturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))", "gen": "var a, b int\nfmt.Scanf(\"%d %d\", &a, &b)\nif a > b {\n\ta, b = b, a\n}\nif a == 0 {\n\tfmt.Println(b)\n\treturn\n}\nif a == 1 {\n\tfmt.Println(b + 1)\n\treturn\n}\nif a == 2 {\n\tfmt.Println(b + 2)\n\treturn\n}\nif a == 3 {\n\tfmt.Println(b + 3)\n\treturn\n}\nif a == 4 {\n\tfmt.Println(b + 4)\n\treturn\n}\nif a == 5 {\n\tfmt.Println(b + 5)\n\treturn\n}\nif a == 6 {\n\tfmt.Println(b + 6)\n\treturn\n}\nif a == 7 {\n\tfmt.Println(b + 7)\n\treturn\n}\nif a == 8 {\n\tfmt.Println(b + 8)\n\treturn\n}\nif a == 9 {\n\tfmt.Println(b + 9)\n\treturn\n}\nif a == 10 {\n\tfmt.Println(b + 10)\n\treturn\n}\nif a == 11 {\n\tfmt.Println(b + 11)\n\treturn\n}\nif a == 12 {\n\tfmt.Println(b + 12)\n\treturn\n}\nif a == 13 {\n\tfmt.Println(b + 13)\n\treturn\n}\nif a == 14 {\n\tfmt.Println(b + 14)\n\treturn\n}\nif a == 15 {\n\tfmt.Println(b + 15)\n\treturn\n}"}
{"tgt": "arr := make([]int, n+1, n+1)\narr[0] = 0\narr[1] = 1\nfor x := 2; x <= n; x++ {\n\tarr[x] = -1\n}\nreturn fibonacciDyamic(n, arr)", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\ta = append(a, 1)\n\ta[i] = 1\n\ta[i+1] = 1\n}\nfmt.Println(a[0])\n}\n"}
{"tgt": "*ss = Count{\n\tolist: make([]countBucket, size),\n\thash:  make(map[string]uint32, size),\n}\nreturn ss", "gen": "var m map[string]uint32\nvar s []uint32\nm = make(map[string]uint32)\ns = make([]uint32, 0, 10)\nm[\"a\"] = 1\nm[\"b\"] = 2\nm[\"c\"] = 3\nm[\"d\"] = 4\nm[\"e\"] = 5\nm[\"f\"] = 6\nm[\"g\"] = 7\nm[\"h\"] = 8\nm[\"i\"] = 9\nm[\"j\"] = 10\ns = append(s, m[\"a\"])\ns = append(s, m[\"b\"])\ns = append(s, m[\"c\"])\ns = append(s, m[\"d\"])\ns = append(s, m[\"e\"])\ns = append(s, m[\"f\"])\ns = append(s, m[\"g\"])\ns = append(s, m[\"h\"])\ns = append(s, m[\"i\"])\ns = append(s, m[\"j\"])\nfmt.Println(s)\n}\n"}
{"tgt": "if len(nums) == 0 {\n\treturn 0\n} else if len(nums) == 1 {\n\treturn nums[0]\n}\nmax := func(m, n int) int {\n\tif m > n {\n\t\treturn m\n\t}\n\treturn n\n}\ndp := []int{nums[0], max(nums[0], nums[1])}\nfor i := 2; i < len(nums); i++ {\n\tdp[i%2] = max(dp[(i-1)%2], nums[i]+dp[i%2])\n}\nreturn dp[(len(nums)-1)%2]", "gen": "fmt.Println(rob([]int{2, 3, 2}))\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CanHopToEnd(tc.hops); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.hops, tc.expected, result)\n\t}\n}", "gen": "fmt.Println(CanHopToEnd([]int{2, 0, 1, 0}))\nfmt.Println(CanHopToEnd([]int{2, 0, 1, 0, 1}))\nfmt.Println(CanHopToEnd([]int{2, 0, 1, 0, 1, 0}))\nfmt.Println(CanHopToEnd([]int{2, 0, 1, 0, 1, 0, 1}))\nfmt.Println(CanHopToEnd([]int{2, 0, 1, 0, 1, 0, 1, 0}))\nfmt.Println(CanHopToEnd([]int{2, 0, 1, 0, 1, 0, 1, 0, 1}))\nfmt.Println(CanHopToEnd([]int{2, 0, 1, 0, 1, 0, 1, 0, 1, 0}))\nfmt.Println(CanHopToEnd([]int{2, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1}))\nfmt.Println(CanHopToEnd([]int{2, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0}))\nfmt.Println(CanHopToEnd([]int{2, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1}))\nfmt.Println(CanHopToEnd([]int{2, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0}))\nfmt.Println(CanHopToEnd([]int{2, 0, 1, 0, 1, 0, 1, 0,"}
{"tgt": "n := NewNode()\ninsertWords := [...]string{\n\t\"STR\",\n\t\"STR\",\n}\ncheckWords := map[string]bool{\n\t\"STR\": false,\n\t\"STR\": false,\n\t\"STR\": true,\n}\nfor _, w := range insertWords {\n\tn.Insert(w)\n\tt.Logf(\n\t\t\"STR\",\n\t\tw,\n\t)\n}\nfor k, v := range checkWords {\n\tok := n.Find(k)\n\tif ok != v {\n\t\tt.Fatalf(\n\t\t\t\"STR\",\n\t\t\tk,\n\t\t\tmap[bool]string{true: \"STR\"}[v],\n\t\t)\n\t}\n\tt.Logf(\n\t\t\"STR\",\n\t\tk,\n\t\tmap[bool]string{true: \"STR\"}[ok],\n\t)\n}", "gen": "trie := NewNode()\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\", false)\ntrie.Insert(\"world\", false)\ntrie.Insert(\"hello\", true)\ntrie.Insert(\"world\", true)\ntrie.Insert(\"hello\","}
{"tgt": "if cl.Size > 0 {\n\tif places < 0 {\n\t\tmultiple := cl.Size - 1 - places/cl.Size\n\t\tplaces += multiple * cl.Size\n\t}\n\tplaces %= cl.Size\n\tif places > cl.Size/2 {\n\t\tplaces = cl.Size - places\n\t\tfor i := 0; i < places; i++ {\n\t\t\tcl.Head = cl.Head.Prev\n\t\t}\n\t} else if places == 0 {\n\t\treturn\n\t} else {\n\t\tfor i := 0; i < places; i++ {\n\t\t\tcl.Head = cl.Head.Next\n\t\t}\n\t}\n}", "gen": "var a [10]int\nvar b int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i := 0; i < 10; i++ {\n\tb += a[i]\n}\nprintln(b)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "s.lock.Lock()\ndefer s.lock.Unlock()\nreturn s.len", "gen": "var m sync.Mutex\nvar x int\nm.Lock()\ndefer m.Unlock()\ndefer func() {\n\tif recover() != nil {\n\t\tx = 1\n\t}\n}()\nif x == 0 {\n\tx = 1\n}\nreturn\n}\n\n// DWARF DIE: 128\n\nvoid main()\n{\n  <BB#0:>;\n  <BB#1:>;\n  <BB#2:>;\n  <BB#3:>;\n  <BB#4:>;\n  <BB#5:>;\n  <BB#6:>;\n  <BB#7:>;\n  <BB#8:>;\n  <BB#9:>;\n  <BB#10:>;\n  <BB#11:>;\n  <BB#12:>;\n  <BB#13:>;\n  <BB#14:>;\n  <BB#15:>;\n  <BB#16:>;\n  <BB#17:>;\n  <BB#18:>;\n  <BB#19:>;\n  <BB#20:>;\n  <BB#21:>;\n  <BB#22:>;\n  <BB#23:>;\n  <BB#24:>;\n  <BB#25:>;\n  <BB#26:>;\n  <BB#27:>;\n  <BB#28:>;\n  <BB#29:>;\n  <BB#30:>;\n  <BB#31:>;\n  <BB#32:>;\n  <BB#33:>;\n  <BB#34:>;\n  <BB#35:>;\n  <BB#36:>;\n  <BB#37:>;\n  <BB#38:>;\n  <BB#39:>;\n  <BB#40:>;\n  <BB#41:>;\n  <BB#42:>;\n  <BB#43:>;\n  <BB#44:>;\n"}
{"tgt": "return fmt.Sprintf(\"STR\", p.Name, p.Age)", "gen": "var a int\nvar b int\nvar c int\nvar d string\nvar e string\nvar f string\nvar g string\nvar h string\nvar i string\nvar j string\nvar k string\nvar l string\nvar m string\nvar n string\nvar o string\nvar p string\nvar q string\nvar r string\nvar s string\nvar t string\nvar u string\nvar v string\nvar w string\nvar x string\nvar y string\nvar z string\nvar aa string\nvar ab string\nvar ac string\nvar ad string\nvar ae string\nvar af string\nvar ag string\nvar ah string\nvar ai string\nvar aj string\nvar ak string\nvar al string\nvar am string\nvar an string\nvar ao string\nvar ap string\nvar aq string\nvar ar string\nvar as string\nvar at string\nvar au string\nvar av string\nvar aw string\nvar ax string\nvar ay string\nvar az string\nvar aa string\nvar ab string\nvar ac string\nvar ad string\nvar ae string\nvar af string\nvar ag string\nvar ah string\nvar ai string\nvar aj string\nvar ak string\nvar al string\nvar am string\nvar an string\nvar ao string\nvar ap string\nvar aq string\nvar ar string\nvar as string\nvar at string\nvar au string\nvar av string\nvar aw string\nvar ax string\nvar ay string\nvar az string\nvar aa string\nvar ab string\nvar ac string\nvar ad string\nvar ae string\nvar af string\nvar ag string\nvar ah string\nvar ai string\nvar aj string\nvar ak string\nvar al string\nvar am string\nvar an string\nvar ao string\nvar ap string\nvar aq string\nvar ar string\nvar as string\nvar at string\nvar au string"}
{"tgt": "if n < 2 {\n\treturn 1\n}\nrec := make([]int, n+1)\nrec[0], rec[1] = 1, 1\nfor i := 2; i <= n; i++ {\n\trec[i] = rec[i-1] + rec[i-2]\n}\nreturn rec[n]", "gen": "var a [10]int\na[0] = 1\nfor i := 1; i < len(a); i++ {\n\ta[i] = 1\n}\nfmt.Println(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\ntmp := nums[0]\nmax := tmp\nfor i := 1; i < n; i++ {\n\tif tmp < 0 {\n\t\ttmp = nums[i]\n\t} else {\n\t\ttmp += nums[i]\n\t}\n\tif max < tmp {\n\t\tmax = tmp\n\t}\n}\nreturn max", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i\n}\nfor i = 0; i < len(a); i++ {\n\ta[i] += a[i]\n}\nfmt.Println(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return syscall.Getgid()", "gen": "gid := syscall.Getgid()\nfmt.Println(gid)\n}\n\n// \u7f16\u8bd1\u5668\u4f1a\u628a\u4e0a\u9762\u7684\u4ee3\u7801\u8f6c\u6362\u6210\u4e0b\u9762\u7684\u4ee3\u7801"}
{"tgt": "cases := []struct {\n\tname   string\n\tarr1   []int\n\tarr2   []int\n\td      int\n\texpect int\n}{\n\t{\"STR\", []int{4, 5, 8}, []int{10, 9, 1, 8}, 2, 2},\n\t{\"STR\", []int{1, 4, 2, 3}, []int{-4, -3, 6, 10, 20, 30}, 3, 2},\n\t{\"STR\", []int{2, 1, 100, 3}, []int{-5, -2, 10, -3, 7}, 6, 1},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.arr1, c.arr2, c.d)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.arr1, c.arr2, c.d)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.TestSolution()\n}\n"}
{"tgt": "if h.Count != 0 {\n\tfor i := 0; i < int(h.Cap); i++ {\n\t\thashValue := h.hash(key, uint32(i))\n\t\tif h.backets[hashValue] != nil && h.backets[hashValue].Key == key {\n\t\t\treturn h.backets[hashValue].Value, h.backets[hashValue].exist\n\t\t}\n\t}\n}\nreturn nil, false", "gen": "var m map[string]string\nm = make(map[string]string)\nm[\"a\"] = \"b\"\nm[\"c\"] = \"d\"\nm[\"e\"] = \"f\"\nm[\"g\"] = \"h\"\nm[\"i\"] = \"j\"\nm[\"k\"] = \"l\"\nm[\"m\"] = \"n\"\nm[\"o\"] = \"p\"\nm[\"q\"] = \"r\"\nm[\"s\"] = \"t\"\nm[\"u\"] = \"v\"\nm[\"w\"] = \"x\"\nm[\"y\"] = \"z\"\nm[\"a\"] = \"b\"\nm[\"c\"] = \"d\"\nm[\"e\"] = \"f\"\nm[\"g\"] = \"h\"\nm[\"i\"] = \"j\"\nm[\"k\"] = \"l\"\nm[\"m\"] = \"n\"\nm[\"o\"] = \"p\"\nm[\"q\"] = \"r\"\nm[\"s\"] = \"t\"\nm[\"u\"] = \"v\"\nm[\"w\"] = \"x\"\nm[\"y\"] = \"z\"\nm[\"a\"] = \"b\"\nm[\"c\"] = \"d\"\nm[\"e\"] = \"f\"\nm[\"g\"] = \"h\"\nm[\"i\"] = \"j\"\nm[\"k\"] = \"l\"\nm[\"m\"] = \"n\"\nm[\"o\"] = \"p\"\nm[\"q\"] = \"r\"\nm[\"s\"] = \"t\"\nm[\"u\"] = \"v\"\nm[\"w\"] = \"x\"\nm[\"y\"] = \"z\"\nm[\"a\"] = \"b\"\nm[\"c\"] = \"d\"\nm[\"e\"] = \"f\"\nm[\"g\"] = \"h\"\nm[\"i\"] = \"j\"\nm[\"k\"] = \"l\"\nm[\"m\"] = \"n\"\nm[\"o\"] = \"p\"\nm[\"q\"] = \"r\""}
{"tgt": "l1 := len(board)\nif l1 == 0 {\n\treturn\n}\nl2 := len(board[0])\nif l2 == 0 {\n\treturn\n}\nvisit := make([][]bool, l1)\nfor i := 0; i < l1; i++ {\n\tvisit[i] = make([]bool, l2)\n}\nfor i := 0; i < l1; i++ {\n\tfor j := 0; j < l2; j++ {\n\t\tif !visit[i][j] {\n\t\t\thelper(board, visit, i, j)\n\t\t}\n\t}\n}", "gen": "var a [2]bool\nvar b [3]bool\nvar c [4]bool\nvar d [5]bool\nvar e [6]bool\nvar f [7]bool\nvar g [8]bool\nvar h [9]bool\nvar i [10]bool\nvar j [11]bool\nvar k [12]bool\nvar l [13]bool\nvar m [14]bool\nvar n [15]bool\nvar o [16]bool\nvar p [17]bool\nvar q [18]bool\nvar r [19]bool\nvar s [20]bool\nvar t [21]bool\nvar u [22]bool\nvar v [23]bool\nvar w [24]bool\nvar x [25]bool\nvar y [26]bool\nvar z [27]bool\nvar aa [28]bool\nvar ab [29]bool\nvar ac [30]bool\nvar ad [31]bool\nvar ae [32]bool\nvar af [33]bool\nvar ag [34]bool\nvar ah [35]bool\nvar ai [36]bool\nvar aj [37]bool\nvar ak [38]bool\nvar al [39]bool\nvar am [40]bool\nvar an [41]bool\nvar ao [42]bool\nvar ap [43]bool\nvar aq [44]bool\nvar ar [45]bool\nvar as [46]bool\nvar at [47]bool\nvar au [48]bool\nvar av [49]bool\nvar aw [50]bool\nvar ax [51]bool\nvar ay [52]bool\nvar az [53]bool\nvar ba [54]bool\nvar bb [55]bool\nvar bc [56]bool\nvar bd [57]bool"}
{"tgt": "return me[0] == \"STR\"", "gen": "var a [3]int\nif a[1] == 1 {\n\tprintln(\"ok\")\n}\n}\n\n// func main() {\n// \tvar a [3]int\n// \tif a[1] == 1 {\n// \t\tprintln(\"ok\")\n// \t}\n// }\n// \n// func main() {\n// \tvar a [3]int\n// \tif a[1] == 1 {\n// \t\tprintln(\"ok\")\n// \t}\n// }\n// \n// func main() {\n// \tvar a [3]int\n// \tif a[1] == 1 {\n// \t\tprintln(\"ok\")\n// \t}\n// }\n// \n// func main() {\n// \tvar a [3]int\n// \tif a[1] == 1 {\n// \t\tprintln(\"ok\")\n// \t}\n// }\n// \n// func main() {\n// \tvar a [3]int\n// \tif a[1] == 1 {\n// \t\tprintln(\"ok\")\n// \t}\n// }\n// \n// func main() {\n// \tvar a [3]int\n// \tif a[1] == 1 {\n// \t\tprintln(\"ok\")\n// \t}\n// }\n// \n// func main() {\n// \tvar a [3]int\n// \tif a[1] == 1 {\n// \t\tprintln(\"ok\")\n// \t}\n// }\n// \n// func main() {\n// \tvar a [3]int\n// \tif a[1] == 1 {\n// \t\tprintln(\"ok\")\n// \t}\n// }\n// \n// func main() {\n// \tvar a [3]int\n// \tif a[1] == 1 {\n// \t\tprintln(\"ok\")\n// \t}\n// }\n// \n// func main() {\n// \tvar a [3]int\n// \tif a[1] == 1"}
{"tgt": "if len(intervals) <= 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i][0] <= intervals[j][0]\n})\nresult := make([][]int, 0)\ncur := intervals[0]\nfor i := 1; i < len(intervals); i++ {\n\tif intervals[i][0] > cur[1] {\n\t\tresult = append(result, cur)\n\t\tcur = intervals[i]\n\t} else {\n\t\tcur[1] = int(math.Max(float64(cur[1]), float64(intervals[i][1])))\n\t}\n}\nresult = append(result, cur)\nreturn result", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "return Frame{}, false", "gen": "var a [4]int\nvar b [4]int\nvar c [4]int\nvar d [4]int\nvar e [4]int\nvar f [4]int\nvar g [4]int\nvar h [4]int\nvar i [4]int\nvar j [4]int\nvar k [4]int\nvar l [4]int\nvar m [4]int\nvar n [4]int\nvar o [4]int\nvar p [4]int\nvar q [4]int\nvar r [4]int\nvar s [4]int\nvar t [4]int\nvar u [4]int\nvar v [4]int\nvar w [4]int\nvar x [4]int\nvar y [4]int\nvar z [4]int\nvar a1 [4]int\nvar b1 [4]int\nvar c1 [4]int\nvar d1 [4]int\nvar e1 [4]int\nvar f1 [4]int\nvar g1 [4]int\nvar h1 [4]int\nvar i1 [4]int\nvar j1 [4]int\nvar k1 [4]int\nvar l1 [4]int\nvar m1 [4]int\nvar n1 [4]int\nvar o1 [4]int\nvar p1 [4]int\nvar q1 [4]int\nvar r1 [4]int\nvar s1 [4]int\nvar t1 [4]int\nvar u1 [4]int\nvar v1 [4]int\nvar w1 [4]int\nvar x1 [4]int\nvar y1 [4]int\nvar z1 [4]int\nvar a2 [4]int\nvar b2 [4]int\nvar c2 [4]int\nvar d2 [4]int\nvar e2 [4]int\nvar f2 [4]int\nvar g2"}
{"tgt": "dist := [200][][]int{}\nfor r := 0; r < R; r++ {\n\tfor c := 0; c < C; c++ {\n\t\td := abs(r-r0) + abs(c-c0)\n\t\tdist[d] = append(dist[d], []int{r, c})\n\t}\n}\nbegin, end := 0, 0\nfor d := 0; len(dist[d]) > 0; d++ {\n\tbegin, end = end, end+len(dist[d])\n\tcopy(res[begin:end], dist[d])\n}\nreturn res[:end]", "gen": "var a, b, c int\nfmt.Scan(&a, &b, &c)\nres := abs(a - b) + abs(b - c) + abs(c - a)\nfmt.Println(res)\n}"}
{"tgt": "n, err := io.Copy(h, r)\nif err != nil {\n\treturn err\n}\nif n != fSize {\n\treturn errReadSizeMismatch\n}\nreturn nil", "gen": "var r io.ReadSeeker\nvar w io.Writer\nvar err error\nvar n int64\nvar n2 int64\nvar n3 int64\nn, n2, n3, err = io.Copy(w, r)\nif err != nil {\n\tpanic(err)\n}\n}\n"}
{"tgt": "if max.Sign() <= 0 {\n\tpanic(\"STR\")\n}\nn = new(big.Int)\nn.Sub(max, n.SetUint64(1))\nbitLen := n.BitLen()\nif bitLen == 0 {\n\treturn\n}\nk := (bitLen + 7) / 8\nb := uint(bitLen % 8)\nif b == 0 {\n\tb = 8\n}\nbytes := make([]byte, k)\nfor {\n\t_, err = io.ReadFull(rand, bytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbytes[0] &= uint8(int(1<<b) - 1)\n\tn.SetBytes(bytes)\n\tif n.Cmp(max) < 0 {\n\t\treturn\n\t}\n}", "gen": "var a, b, c int64\nfmt.Scan(&a, &b, &c)\nif a > b {\n\ta, b = b, a\n}\nif a > c {\n\ta, c = c, a\n}\nif b > c {\n\tb, c = c, b\n}\nif a == b {\n\tfmt.Println(a)\n\treturn\n}\nif a == c {\n\tfmt.Println(b)\n\treturn\n}\nif b == c {\n\tfmt.Println(a)\n\treturn\n}\nif a > b {\n\tif a > c {\n\t\tfmt.Println(a)\n\t\treturn\n\t}\n\tif b > c {\n\t\tfmt.Println(b)\n\t\treturn\n\t}\n}\nif b > a {\n\tif b > c {\n\t\tfmt.Println(b)\n\t\treturn\n\t}\n\tif a > c {\n\t\tfmt.Println(a)\n\t\treturn\n\t}\n}\nif c > a {\n\tif c > b {\n\t\tfmt.Println(c)\n\t\treturn\n\t}\n\tif a > b {\n\t\tfmt.Println(a)\n\t\treturn\n\t}\n}\nif c > b {\n\tif c > a {\n\t\tfmt.Println(c)\n\t\treturn\n\t}\n\tif b > a {\n\t\tfmt.Println(b)\n\t\treturn\n\t}\n}\n}\n"}
{"tgt": "s := \"STR\"\nfmt.Println(reverseString(s))", "gen": "var s string\nreverseString(&s)\nfmt.Println(s)\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tnums: []int{1, 2, 3, 1},\n\t\tk:    3,\n\t\twant: true,\n\t},\n\t{\n\t\tnums: []int{1, 0, 1, 1},\n\t\tk:    1,\n\t\twant: true,\n\t},\n\t{\n\t\tnums: []int{1, 2, 3, 1, 2, 3},\n\t\tk:    2,\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := containsNearbyDuplicate(tt.nums, tt.k)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.nums, tt.k, got, tt.want)\n\t}\n}", "gen": "fmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1}, 3))\nfmt.Println(containsNearbyDuplicate([]int{1, 0, 1, 1}, 1))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 2))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 3))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 4))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 5))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 6))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 7))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 8))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 9))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 10))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 11))\nfmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1, 2, 3}, 12))\nfmt.Println(containsNearbyDuplicate([]"}
{"tgt": "for V > 0 {\n\tV--\n\tif !isDroppedLeft(heights, K) && !isDroppedRight(heights, K) {\n\t\theights[K]++\n\t}\n}\nreturn heights", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar i int\nvar j int\nvar k int\nfor i = 0; i < 3; i++ {\n\tfor j = 0; j < 3; j++ {\n\t\tfor k = 0; k < 3; k++ {\n\t\t\tif isDroppedLeft(i, j, k) {\n\t\t\t\tif isDroppedRight(i, j, k) {\n\t\t\t\t\ta[i] = b[j]\n\t\t\t\t\tb[j] = c[k]\n\t\t\t\t\tc[k] = a[i]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nfmt.Println(a[0], a[1], a[2])\nfmt.Println(b[0], b[1], b[2])\nfmt.Println(c[0], c[1], c[2])\n}"}
{"tgt": "qs := []question231{\n\t{\n\t\tpara231{1},\n\t\tans231{true},\n\t},\n\t{\n\t\tpara231{16},\n\t\tans231{true},\n\t},\n\t{\n\t\tpara231{218},\n\t\tans231{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans231, q.para231\n\tfmt.Printf(\"STR\", p, isPowerOfTwo(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(isPowerOfTwo(1))\nfmt.Println(isPowerOfTwo(16))\nfmt.Println(isPowerOfTwo(218))\nfmt.Println(isPowerOfTwo(219))\nfmt.Println(isPowerOfTwo(220))\nfmt.Println(isPowerOfTwo(221))\nfmt.Println(isPowerOfTwo(222))\nfmt.Println(isPowerOfTwo(223))\nfmt.Println(isPowerOfTwo(224))\nfmt.Println(isPowerOfTwo(225))\nfmt.Println(isPowerOfTwo(226))\nfmt.Println(isPowerOfTwo(227))\nfmt.Println(isPowerOfTwo(228))\nfmt.Println(isPowerOfTwo(229))\nfmt.Println(isPowerOfTwo(230))\nfmt.Println(isPowerOfTwo(231))\nfmt.Println(isPowerOfTwo(232))\nfmt.Println(isPowerOfTwo(233))\nfmt.Println(isPowerOfTwo(234))\nfmt.Println(isPowerOfTwo(235))\nfmt.Println(isPowerOfTwo(236))\nfmt.Println(isPowerOfTwo(237))\nfmt.Println(isPowerOfTwo(238))\nfmt.Println(isPowerOfTwo(239))\nfmt.Println(isPowerOfTwo(240))\nfmt.Println(isPowerOfTwo(241))\nfmt.Println(isPowerOfTwo(242))\nfmt.Println(isPowerOfTwo(243))\nfmt.Println(isPowerOfTwo(244))\nfmt.Println(isPowerOfTwo(245))\nfmt.Println(isPowerOfTwo(246))\nfmt.Println(is"}
{"tgt": "m := map[string]struct{}{}\nfor _, email := range emails {\n\tn := len(email)\n\tbs := strings.Builder{}\n\tignore := false\n\tfor i := 0; i < n; i++ {\n\t\tif email[i] == '@' {\n\t\t\tbs.WriteString(email[i:])\n\t\t\tbreak\n\t\t}\n\t\tif ignore || email[i] == '.' {\n\t\t\tcontinue\n\t\t}\n\t\tif email[i] == '+' {\n\t\t\tignore = true\n\t\t\tcontinue\n\t\t}\n\t\tbs.WriteByte(email[i])\n\t}\n\tm[bs.String()] = struct{}{}\n}\nreturn len(m)", "gen": "m := make(map[string]struct{})\nfor i := 0; i < 16; i++ {\n\tm[fmt.Sprintf(\"%d\", i)] = struct{}{}\n}\nfmt.Println(len(m))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinput1 string\n\tinput2 string\n\texpect bool\n}{\n\t{\"STR\", \"STR\", \"STR\", false},\n\t{\"STR\", \"STR\", \"STR\", false},\n\t{\"STR\", \"STR\", \"STR\", true},\n\t{\"STR\", \"STR\", \"STR\", true},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := canConstruct2(c.input1, c.input2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.input1, c.input2)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.TestSolution2()\n}\n"}
{"tgt": "for {\n\tswitch r := l.next(); {\n\tcase unicode.IsNumber(r):\n\tcase r == \"STR\":\n\t\tl.backup()\n\t\tl.emit(itemEnd)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase r == eof:\n\t\tl.emit(itemEnd)\n\t\treturn byteRangeSet\n\tdefault:\n\t\treturn l.error(\"STR\")\n\t}\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "var res byte\nfor i := 0; i < len(s); i++ {\n\tres ^= s[i]\n}\nfor i := 0; i < len(t); i++ {\n\tres ^= t[i]\n}\nreturn res", "gen": "var a [10]byte\nvar b [10]byte\nvar c [10]byte\nvar d [10]byte\nvar e [10]byte\nvar f [10]byte\nvar g [10]byte\nvar h [10]byte\nvar i [10]byte\nvar j [10]byte\nvar k [10]byte\nvar l [10]byte\nvar m [10]byte\nvar n [10]byte\nvar o [10]byte\nvar p [10]byte\nvar q [10]byte\nvar r [10]byte\nvar s [10]byte\nvar t [10]byte\nvar u [10]byte\nvar v [10]byte\nvar w [10]byte\nvar x [10]byte\nvar y [10]byte\nvar z [10]byte\nvar aa [10]byte\nvar bb [10]byte\nvar cc [10]byte\nvar dd [10]byte\nvar ee [10]byte\nvar ff [10]byte\nvar gg [10]byte\nvar hh [10]byte\nvar ii [10]byte\nvar jj [10]byte\nvar kk [10]byte\nvar ll [10]byte\nvar mm [10]byte\nvar nn [10]byte\nvar oo [10]byte\nvar pp [10]byte\nvar qq [10]byte\nvar rr [10]byte\nvar ss [10]byte\nvar tt [10]byte\nvar uu [10]byte\nvar vv [10]byte\nvar ww [10]byte\nvar xx [10]byte\nvar yy [10]byte\nvar zz [10]byte\nvar aaa [10]byte\nvar bbb [10]"}
{"tgt": "var s int\nfor _, c := range m.cache {\n\ts += c.Expire()\n}\nreturn s", "gen": "var c LRUCache\nc.Add(1, 1)\nc.Add(2, 2)\nc.Add(3, 3)\nc.Add(4, 4)\nc.Add(5, 5)\nc.Add(6, 6)\nc.Add(7, 7)\nc.Add(8, 8)\nc.Add(9, 9)\nc.Add(10, 10)\nc.Add(11, 11)\nc.Add(12, 12)\nc.Add(13, 13)\nc.Add(14, 14)\nc.Add(15, 15)\nc.Add(16, 16)\nc.Add(17, 17)\nc.Add(18, 18)\nc.Add(19, 19)\nc.Add(20, 20)\nc.Add(21, 21)\nc.Add(22, 22)\nc.Add(23, 23)\nc.Add(24, 24)\nc.Add(25, 25)\nc.Add(26, 26)\nc.Add(27, 27)\nc.Add(28, 28)\nc.Add(29, 29)\nc.Add(30, 30)\nc.Add(31, 31)\nc.Add(32, 32)\nc.Add(33, 33)\nc.Add(34, 34)\nc.Add(35, 35)\nc.Add(36, 36)\nc.Add(37, 37)\nc.Add(38, 38)\nc.Add(39, 39)\nc.Add"}
{"tgt": "if len(num) <= 1 {\n\treturn\n}\nfor i := len(num) - 1; i > 0; i-- {\n\tif num[i-1] < num[i] {\n\t\tj := len(num) - 1\n\t\tfor num[i-1] >= num[j] {\n\t\t\tj--\n\t\t}\n\t\tnum[j], num[i-1] = num[i-1], num[j]\n\t\treverse(num[i:])\n\t\tfmt.Println(num)\n\t\treturn\n\t}\n\tif i == 1 {\n\t\treturn\n\t}\n}", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar bb [3]int\nvar cc [3]int\nvar dd [3]int\nvar ee [3]int\nvar ff [3]int\nvar gg [3]int\nvar hh [3]int\nvar ii [3]int\nvar jj [3]int\nvar kk [3]int\nvar ll [3]int\nvar mm [3]int\nvar nn [3]int\nvar oo [3]int\nvar pp [3]int\nvar qq [3]int\nvar rr [3]int\nvar ss [3]int\nvar tt [3]int\nvar uu [3]int\nvar vv [3]int\nvar ww [3]int\nvar xx [3]int\nvar yy [3]int\nvar zz [3]int\nvar aa1 [3]int\nvar bb1 [3]int\nvar cc1 [3]int\nvar dd1 [3]int\nvar ee1 [3]int\nvar ff1 [3]int\nvar gg1 [3]int\nvar hh1"}
{"tgt": "words := map[string]struct{}{}\ncap, vowel := map[string]string{}, map[string]string{}\nfor _, word := range wordlist {\n\twords[word] = struct{}{}\n\tlower := strings.ToLower(word)\n\tif _, ok := cap[lower]; !ok {\n\t\tcap[lower] = word\n\t\tif _, ok = vowel[todev(lower)]; !ok {\n\t\t\tvowel[todev(lower)] = word\n\t\t}\n\t}\n}\nfor i, query := range queries {\n\tif _, ok := words[query]; ok {\n\t\tcontinue\n\t}\n\tlower := strings.ToLower(query)\n\tif word, ok := cap[lower]; ok {\n\t\tqueries[i] = word\n\t} else if word, ok = vowel[todev(lower)]; ok {\n\t\tqueries[i] = word\n\t} else {\n\t\tqueries[i] = \"STR\"\n\t}\n}\nreturn queries", "gen": "fmt.Println(toDev(\"a\"))\nfmt.Println(toDev(\"A\"))\nfmt.Println(toDev(\"ab\"))\nfmt.Println(toDev(\"AB\"))\nfmt.Println(toDev(\"abc\"))\nfmt.Println(toDev(\"ABC\"))\nfmt.Println(toDev(\"abcd\"))\nfmt.Println(toDev(\"ABCDE\"))\nfmt.Println(toDev(\"abcdef\"))\nfmt.Println(toDev(\"ABCDEF\"))\nfmt.Println(toDev(\"abcdefg\"))\nfmt.Println(toDev(\"ABCDEFG\"))\nfmt.Println(toDev(\"abcdefgh\"))\nfmt.Println(toDev(\"ABCDEFGH\"))\nfmt.Println(toDev(\"abcdefghi\"))\nfmt.Println(toDev(\"ABCDEFGHI\"))\nfmt.Println(toDev(\"abcdefghij\"))\nfmt.Println(toDev(\"ABCDEFGHIJ\"))\nfmt.Println(toDev(\"abcdefghijk\"))\nfmt.Println(toDev(\"ABCDEFGHIJK\"))\nfmt.Println(toDev(\"abcdefghijkl\"))\nfmt.Println(toDev(\"ABCDEFGHIJKL\"))\nfmt.Println(toDev(\"abcdefghijklm\"))\nfmt.Println(toDev(\"ABCDEFGHIJKLM\"))\nfmt.Println(toDev(\"abcdefghijklmn\"))\nfmt.Println(toDev(\"ABCDEFGHIJKLMN\"))\nfmt.Println(toDev(\"abcdefghijklmno\"))\nfmt.Println(toDev(\"ABCDEFGHIJKLMNO\"))\nfmt.Println(toDev(\"abcdefghijklmnop\"))\nfmt.Println(toDev(\"ABCDEFGHIJKLMNOP\"))\nfmt.Println(toDev(\"abcdefghijklmnopq\"))\nfmt.Println(toDev(\"ABCDEFGHIJKLMNOPQ\"))\nfmt.Println("}
{"tgt": "return c.name", "gen": "var a, b int\na, b = 1, 2\nfmt.Println(a, b)\n}\n\n// \u7f16\u8bd1\u5668\u4f1a\u628a\u8fd9\u6bb5\u4ee3\u7801\u8f6c\u6362\u6210\n// \tmovq $1, -16(%rbp)\n// \tmovq $2, -8(%rbp)\n// \tmovq -16(%rbp), %rax\n// \tmovq -8(%rbp), %rdx\n// \tmovq %rax, -24(%rbp)\n// \tmovq %rdx, -16(%rbp)\n// \tmovq -24(%rbp), %rax\n// \tmovq -16(%rbp), %rdx\n// \tmovq %rax, -8(%rbp)\n// \tmovq -8(%rbp), %rax\n// \tmovq %rax, %rdx\n// \tmovq %rdx, %rsp\n// \tpopq %rbp\n// \tret\n\n// \u6c47\u7f16\u4ee3\u7801\u4e2d\u7684 <32>(%rax) \u8868\u793a rax \u5bc4\u5b58\u5668\u7684\u7b2c 32 \u4f4d\n// \u6c47\u7f16\u4ee3\u7801\u4e2d\u7684 <24>(%rax) \u8868\u793a rax \u5bc4\u5b58\u5668\u7684\u7b2c 24 \u4f4d\n// \u6c47\u7f16\u4ee3\u7801\u4e2d\u7684 <16>(%rax) \u8868\u793a rax \u5bc4\u5b58\u5668\u7684\u7b2c 16 \u4f4d\n// \u6c47\u7f16\u4ee3\u7801\u4e2d\u7684 <8>(%rax) \u8868\u793a rax \u5bc4\u5b58\u5668\u7684\u7b2c 8 \u4f4d\n// \u6c47\u7f16\u4ee3\u7801\u4e2d\u7684 <0>(%rax) \u8868\u793a rax \u5bc4\u5b58\u5668\u7684\u7b2c 0 \u4f4d\n\n// \u6c47\u7f16\u4ee3\u7801\u4e2d\u7684 <16>(%rdx) \u8868\u793a rdx \u5bc4\u5b58\u5668\u7684\u7b2c 16 \u4f4d\n// \u6c47\u7f16\u4ee3\u7801\u4e2d\u7684 <8>(%rdx) \u8868\u793a rdx \u5bc4\u5b58\u5668\u7684\u7b2c"}
{"tgt": "qs := []question984{\n\t{\n\t\tpara984{1, 2},\n\t\tans984{\"STR\"},\n\t},\n\t{\n\t\tpara984{4, 1},\n\t\tans984{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans984, q.para984\n\tfmt.Printf(\"STR\", p, strWithout3a3b(p.a, p.b))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(strWithout3a3b(1))\nfmt.Println(strWithout3a3b(2))\nfmt.Println(strWithout3a3b(3))\nfmt.Println(strWithout3a3b(4))\nfmt.Println(strWithout3a3b(5))\nfmt.Println(strWithout3a3b(6))\nfmt.Println(strWithout3a3b(7))\nfmt.Println(strWithout3a3b(8))\nfmt.Println(strWithout3a3b(9))\nfmt.Println(strWithout3a3b(10))\nfmt.Println(strWithout3a3b(11))\nfmt.Println(strWithout3a3b(12))\nfmt.Println(strWithout3a3b(13))\nfmt.Println(strWithout3a3b(14))\nfmt.Println(strWithout3a3b(15))\nfmt.Println(strWithout3a3b(16))\nfmt.Println(strWithout3a3b(17))\nfmt.Println(strWithout3a3b(18))\nfmt.Println(strWithout3a3b(19))\nfmt.Println(strWithout3a3b(20))\nfmt.Println(strWithout3a3b(21))\nfmt.Println(strWithout3a3b(22))\nfmt.Println(strWithout3a3b(23))\nfmt.Println(strWithout3a3b(24))\nfmt.Println(strWithout3a3b(25))\nfmt.Println(strWithout3a3b(26))\nfmt.Println(strWithout3a3b(27))\nfmt.Println(strWithout3a3b(28))\nfmt.Println"}
{"tgt": "var sum int\nfor i := start; i < end; i++ {\n\tsum += l[i]\n}\nreturn sum", "gen": "var a [10]int\nvar sum int\nfor i := 0; i < len(a); i++ {\n\tsum += a[i]\n}\nfmt.Println(sum)\n}\n\n// \u7f16\u8bd1\u5668\u4f18\u5316"}
{"tgt": "arr := make([]bool, 1000000)\narr[1] = true\nprime := 3\ncount := 13\nvar k, tmp, localCount int\nvar str string\nfor {\n\tfor k = prime * 2; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tstr = strconv.Itoa(prime)\n\t\tif prime > 100 {\n\t\t\tlocalCount = 1\n\t\t\tfor i := 0; i < len(str)-1; i++ {\n\t\t\t\tstr = str[1:] + str[0:1]\n\t\t\t\ttmp, _ = strconv.Atoi(str)\n\t\t\t\tif tmp > prime {\n\t\t\t\t\tcontinueprimeloop\n\t\t\t\t} else if !arr[tmp] && tmp%2 != 0 {\n\t\t\t\t\tlocalCount++\n\t\t\t\t} else {\n\t\t\t\t\tcontinueprimeloop\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount += localCount\n\t\t}\n\t} else {\n\t\tbreak\n\t}\n}\nprintln(count)", "gen": "var a [1000000]bool\nfor i := 0; i < 1000000; i++ {\n\ta[i] = true\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t}\n}\nfor i := 0; i < 1000000; i++"}
{"tgt": "count := make(map[string]int, len(words))\nfor _, w := range words {\n\tcount[w]++\n}\nfw := make(freWords, 0, len(count))\nfor w, c := range count {\n\tfw = append(fw, &entry{\n\t\tword:      w,\n\t\tfrequence: c,\n\t})\n}\nsort.Sort(fw)\nres := make([]string, k)\nfor i := 0; i < k; i++ {\n\tres[i] = fw[i].word\n}\nreturn res", "gen": "var m = make(map[string]int)\nvar s = \"hello world\"\nfor i := 0; i < len(s); i++ {\n\tm[string(s[i])]++\n}\nvar freq = make([]entry, 0, len(m))\nfor k, v := range m {\n\tfreq = append(freq, entry{k, v})\n}\nsort.Sort(freWords(freq))\nvar res = make([]string, 0, len(freq))\nfor _, e := range freq {\n\tres = append(res, e.key)\n}\nfmt.Println(res)\n}\n\ntype entry struct {\nkey   string\nvalue int\n}\n\ntype freWords []entry\n"}
{"tgt": "str1 := \"STR\"\nfmt.Println(largeGroupPositions(str1))\nstr2 := \"STR\"\nfmt.Println(largeGroupPositions(str2))\nstr3 := \"STR\"\nfmt.Println(largeGroupPositions(str3))\nstr4 := \"STR\"\nfmt.Println(largeGroupPositions(str4))", "gen": "fmt.Println(largeGroupPositions(\"aaa\"))\nfmt.Println(largeGroupPositions(\"aa\"))\nfmt.Println(largeGroupPositions(\"aab\"))\nfmt.Println(largeGroupPositions(\"abcde\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\n}\n"}
{"tgt": "list := NewCyclic()\nfillList(list, 3)\nwant := 1\ngot := list.Walk()\nif got.Val != want {\n\tt.Errorf(\"STR\", got)\n}", "gen": "list := NewCyclic(3)\nlist.Fill()\nif list.Walk() != 1 {\n\tt.Errorf(\"Walk() = %d, want 1\", list.Walk())\n}\n}\n"}
{"tgt": "m := make(map[int]struct{})\nfor _, num := range nums1 {\n\tm[num] = struct{}{}\n}\nnums := make([]int, 0)\nfor _, num := range nums2 {\n\tif _, ok := m[num]; ok {\n\t\tnums = append(nums, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn nums", "gen": "m := make(map[int]struct{})\nfor i := 0; i < 1000000; i++ {\n\tm[i] = struct{}{}\n}\ns := make([]int, 0, 1000000)\nfor k := range m {\n\ts = append(s, k)\n}\nprintln(len(s))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "factorial := new(big.Int).MulRange(1, 100)\nbytes := factorial.Append([]byte{}, 10)\nsum := 0\nfor b := range bytes {\n\tsum += int(bytes[b] - '0')\n}\nfmt.Println(\"STR\", sum)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a1 int\nvar b1 int\nvar c1 int\nvar d1 int\nvar e1 int\nvar f1 int\nvar g1 int\nvar h1 int\nvar i1 int\nvar j1 int\nvar k1 int\nvar l1 int\nvar m1 int\nvar n1 int\nvar o1 int\nvar p1 int\nvar q1 int\nvar r1 int\nvar s1 int\nvar t1 int\nvar u1 int\nvar v1 int\nvar w1 int\nvar x1 int\nvar y1 int\nvar z1 int\nvar a2 int\nvar b2 int\nvar c2 int\nvar d2 int\nvar e2 int\nvar f2 int\nvar g2 int\nvar h2 int\nvar i2 int\nvar j2 int\nvar k2 int\nvar l2 int\nvar m2 int\nvar n2 int\nvar o2 int\nvar p2 int\nvar q2 int\nvar r2 int\nvar s2 int\nvar t2 int\nvar u2 int\nvar v2 int\nvar w2 int\nvar x2 int\nvar y2 int\nvar z2 int\nvar a3 int\nvar b3 int\nvar c3 int\nvar d3 int\nvar e3 int\nvar f3 int\nvar g3 int\nvar h3 int\nvar i3 int\nvar j3"}
{"tgt": "qs := []question1003{\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{true},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{true},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{false},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1003, q.para1003\n\tfmt.Printf(\"STR\", p, isValid1003(p.s))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "var v *error\nreturn v", "gen": "var err error\nif err != nil {\n\treturn\n}\n}\n"}
{"tgt": "m := map[string]int{}\nrets := []string{}\nfor i := 0; i <= len(s)-10; i++ {\n\tsub := string(s[i : i+10])\n\tm[sub]++\n\tif m[sub] == 2 {\n\t\trets = append(rets, sub)\n\t}\n}\nreturn rets", "gen": "m := make(map[string]int)\nm[\"a\"] = 1\nm[\"b\"] = 2\nm[\"c\"] = 3\nm[\"d\"] = 4\nm[\"e\"] = 5\nm[\"f\"] = 6\nm[\"g\"] = 7\nm[\"h\"] = 8\nm[\"i\"] = 9\nm[\"j\"] = 10\nm[\"k\"] = 11\nm[\"l\"] = 12\nm[\"m\"] = 13\nm[\"n\"] = 14\nm[\"o\"] = 15\nm[\"p\"] = 16\nm[\"q\"] = 17\nm[\"r\"] = 18\nm[\"s\"] = 19\nm[\"t\"] = 20\nm[\"u\"] = 21\nm[\"v\"] = 22\nm[\"w\"] = 23\nm[\"x\"] = 24\nm[\"y\"] = 25\nm[\"z\"] = 26\nfmt.Println(m)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "q[i], q[j] = q[j], q[i]", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 4\nb[1] = 5\nb[2] = 6\nc[0] = 7\nc[1] = 8\nc[2] = 9\na[0], a[1], a[2] = b[0], b[1], b[2]\na[0], a[1], a[2] = c[0], c[1], c[2]\nfmt.Println(a[0], a[1], a[2])\n}\n\n// Output:\n// 4 5 6\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```"}
{"tgt": "runes := []rune(s)\nlength := len(runes)\nif length <= 1 {\n\treturn s\n}\nmaxRune := runes[0:1]\nfor i := 0; i < length-1; i++ {\n\ttmpRune := findPalindrome(runes, i, i)\n\tif len(tmpRune) > len(maxRune) {\n\t\tmaxRune = tmpRune\n\t}\n\tif runes[i] == runes[i+1] {\n\t\ttmpRune = findPalindrome(runes, i, i+1)\n\t\tif len(tmpRune) > len(maxRune) {\n\t\t\tmaxRune = tmpRune\n\t\t}\n\t}\n}\nreturn string(maxRune)", "gen": "s := \"abccba\"\nresult := findPalindrome(s)\nfmt.Println(result)\n}\n"}
{"tgt": "stack, j, N := []int{}, 0, len(pushed)\nfor _, x := range pushed {\n\tstack = append(stack, x)\n\tfmt.Printf(\"STR\", stack, j)\n\tfor len(stack) != 0 && j < N && stack[len(stack)-1] == popped[j] {\n\t\tstack = stack[0 : len(stack)-1]\n\t\tj++\n\t}\n\tfmt.Printf(\"STR\", stack, j)\n}\nreturn j == N", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar bb [3]int\nvar cc [3]int\nvar dd [3]int\nvar ee [3]int\nvar ff [3]int\nvar gg [3]int\nvar hh [3]int\nvar ii [3]int\nvar jj [3]int\nvar kk [3]int\nvar ll [3]int\nvar mm [3]int\nvar nn [3]int\nvar oo [3]int\nvar pp [3]int\nvar qq [3]int\nvar rr [3]int\nvar ss [3]int\nvar tt [3]int\nvar uu [3]int\nvar vv [3]int\nvar ww [3]int\nvar xx [3]int\nvar yy [3]int\nvar zz [3]int\nvar aa1 [3]int\nvar bb1 [3]int\nvar cc1 [3]int\nvar dd1 [3]int\nvar ee1 [3]int\nvar ff1 [3]int\nvar gg1 [3]int\nvar hh1"}
{"tgt": "return numDistinctBytes([]byte(s), []byte(t))", "gen": "fmt.Println(numDistinctBytes(\"abc\", \"bca\"))\n}\n"}
{"tgt": "return key1.(int) < key2.(int)", "gen": "var a int\nvar b int\nvar c int\nvar d int\na = 1\nb = 2\nc = 3\nd = 4\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == d {\n\tpanic(\"c == d\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif b == d {\n\tpanic(\"b == d\")\n}\nif a == d {\n\tpanic(\"a == d\")\n}\nif b == c {\n\tpanic(\"b == c\")\n}\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == d {\n\tpanic(\"c == d\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif b == d {\n\tpanic(\"b == d\")\n}\nif a == d {\n\tpanic(\"a == d\")\n}\nif b == c {\n\tpanic(\"b == c\")\n}\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == d {\n\tpanic(\"c == d\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif b == d {\n\tpanic(\"b == d\")\n}\nif a == d {\n\tpanic(\"a == d\")\n}\nif b == c {\n\tpanic(\"b == c\")\n}\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == d {\n\tpanic(\"c == d\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif b == d {\n\tpanic(\"b == d\")\n}\nif a == d {\n\tpanic(\"a == d\")"}
{"tgt": "return x != y", "gen": "var a float32 = 1.0\nvar b float32 = 2.0\nvar c bool\nc = a < b\nfmt.Println(c)\n}\n\n// 0x0000000000000000 <main>:\n// 0:\t55                   \tpush   %rbp\n// 1:\t48 89 e5             \tmov    %rsp,%rbp\n// 4:\t48 8d 45 f0          \tlea    -16(%rbp),%rsp\n// 8:\tc7 45 fc 00 00 00 00 \tmovl   $0,-4(%rbp)\n// d:\tc7 45 f8 3f 80 00 00 \tmovl   $10000000,-8(%rbp)\n// 16:\tc7 45 f4 3f 80 00 00 \tmovl   $10000000,-12(%rbp)\n// 24:\tc7 45 f0 3f 80 00 00 \tmovl   $10000000,-16(%rbp)\n// 32:\tc7 45 f4 3f 80 00 00 \tmovl   $10000000,-20(%rbp)\n// 40:\tc7 45 f8 3f 80 00 00 \tmovl   $10000000,-24(%rbp)\n// 48:\tc7 45 fc 3f 80 00 00 \tmovl   $10000000,-28(%rbp)\n// 56:\tc7 45 f0 3f 80 00 00 \tmovl   $10000000,-32"}
{"tgt": "for prime := range sig(a) {\n\tif sig(b)[prime] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var m map[int64]bool\nvar s int64\nvar v bool\nfor k := range m {\n\tv = m[k]\n\ts = k\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var low, mid, high int = 0, len(sorted) / 2, len(sorted)\nfor low < high {\n\tcurr := sorted[mid]\n\tswitch {\n\tcase curr == target:\n\t\treturn mid\n\tcase inRange(sorted[mid:high], target):\n\t\tlow = mid\n\t\tmid = (low + high) / 2\n\tdefault:\n\t\thigh = mid\n\t\tmid = (low + high) / 2\n\t}\n}\nreturn -1", "gen": "var a []int\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tif i < len(a) {\n\t\tif i >= 0 {\n\t\t\tif i < len(a) {\n\t\t\t\tif i < len(a) {\n\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n"}
{"tgt": "if n < sumOfProperDivisors(n) {\n\treturn true\n}\nreturn false", "gen": "var n int\nfmt.Scan(&n)\nif sumOfProperDivisors(n) == n {\n\tfmt.Println(\"Yes\")\n} else {\n\tfmt.Println(\"No\")\n}\n}\n"}
{"tgt": "ss := []string{S}\nfor i := 0; i < len(S); i++ {\n\tif S[i] < '0' || S[i] > '9' {\n\t\tfor _, s := range ss {\n\t\t\tb := []byte(s)\n\t\t\tletterCase(b, i)\n\t\t\tss = append(ss, string(b))\n\t\t}\n\t}\n}\nreturn ss", "gen": "fmt.Println(letterCase(\"a\"))\nfmt.Println(letterCase(\"A\"))\nfmt.Println(letterCase(\"1\"))\nfmt.Println(letterCase(\"\"))\nfmt.Println(letterCase(\" \"))\nfmt.Println(letterCase(\"  \"))\nfmt.Println(letterCase(\"a \"))\nfmt.Println(letterCase(\"a b\"))\nfmt.Println(letterCase(\"a b c\"))\nfmt.Println(letterCase(\"a b c d\"))\nfmt.Println(letterCase(\"a b c d e\"))\nfmt.Println(letterCase(\"a b c d e f\"))\nfmt.Println(letterCase(\"a b c d e f g\"))\nfmt.Println(letterCase(\"a b c d e f g h\"))\nfmt.Println(letterCase(\"a b c d e f g h i\"))\nfmt.Println(letterCase(\"a b c d e f g h i j\"))\nfmt.Println(letterCase(\"a b c d e f g h i j k\"))\nfmt.Println(letterCase(\"a b c d e f g h i j k l\"))\nfmt.Println(letterCase(\"a b c d e f g h i j k l m\"))\nfmt.Println(letterCase(\"a b c d e f g h i j k l m n\"))\nfmt.Println(letterCase(\"a b c d e f g h i j k l m n o\"))\nfmt.Println(letterCase(\"a b c d e f g h i j k l m n o p\"))\nfmt.Println(letterCase(\"a b c d e f g h i j k l m n o p q\"))\nfmt.Println(letterCase(\"a b c d e f g h i j k l m n o p q r\"))\nfmt.Println(letterCase(\"a b c d e f g h i j k l m n o p q r s\"))\nfmt.Println(letterCase(\"a b c d e f g h i j k l m n o p q r s"}
{"tgt": "digits := convert(N + 1)\nbits := len(digits)\nnoRepeat := 0\nfor b := 1; b < bits; b++ {\n\tnoRepeat += 9 * count(9, b-1)\n}\nhasSeen := make(map[int]bool, 10)\nfor b := 0; b < bits; b++ {\n\td := 0\n\tif b == 0 {\n\t\td = 1\n\t}\n\tfor ; d < digits[b]; d++ {\n\t\tif !hasSeen[d] {\n\t\t\tnoRepeat += count(9-b, bits-b-1)\n\t\t}\n\t}\n\tif hasSeen[digits[b]] {\n\t\tbreak\n\t}\n\thasSeen[digits[b]] = true\n}\nreturn N - noRepeat", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar A int\nvar B int\nvar C int\nvar D int\nvar E int\nvar F int\nvar G int\nvar H int\nvar I int\nvar J int\nvar K int\nvar L int\nvar M int\nvar N int\nvar O int\nvar P int\nvar Q int\nvar R int\nvar S int\nvar T int\nvar U int\nvar V int\nvar W int\nvar X int\nvar Y int\nvar Z int\nvar AA int\nvar BB int\nvar CC int\nvar DD int\nvar EE int\nvar FF int\nvar GG int\nvar HH int\nvar II int\nvar JJ int\nvar KK int\nvar LL int\nvar MM int\nvar NN int\nvar OO int\nvar PP int\nvar QQ int\nvar RR int\nvar SS int\nvar TT int\nvar UU int\nvar VV int\nvar WW int\nvar XX int\nvar YY int\nvar ZZ int\nvar AAA int\nvar BBB int\nvar CCC int\nvar DDD int\nvar EEE int\nvar FFF int\nvar GGG int\nvar HHH int\nvar III int\nvar JJJ int\nvar KKK int\nvar LLL int\nvar MMM int\nvar NNN int\nvar OOO int\n"}
{"tgt": "b := NewLRUCache(1000)\nfor i := 0; i < 1000; i++ {\n\tb.Set(randomString(2), \"STR\", expire)\n}\nreturn b", "gen": "c := lrucache.NewLRUCache(1000)\nfor i := 0; i < 1000; i++ {\n\tc.Set(i, i)\n}\nreturn c\n}\n"}
{"tgt": "h := &IntMaxHeap{}\nheap.Init(h)\nheap.Push(h, 7)\nheap.Push(h, 3)\nheap.Push(h, 2)\nheap.Push(h, 1)\nheap.Push(h, 5)\nheap.Push(h, 5)\nheap.Push(h, 6)\nheap.Push(h, 7)\nfmt.Printf(\"STR\", (*h))\nfor h.Len() > 0 {\n\tfmt.Printf(\"STR\", heap.Pop(h))\n}", "gen": "var heap Solution.IntMaxHeap\nheap.Init()\nheap.Push(1)\nheap.Push(2)\nheap.Push(3)\nfmt.Printf(\"%d %d %d\\n\", heap.Len(), heap.Less(0, 1), heap.Swap(0, 1))\nheap.Pop()\nfmt.Printf(\"%d %d %d\\n\", heap.Len(), heap.Less(0, 1), heap.Swap(0, 1))\nheap.Push(4)\nfmt.Printf(\"%d %d %d\\n\", heap.Len(), heap.Less(0, 1), heap.Swap(0, 1))\nheap.Pop()\nheap.Pop()\nheap.Pop()\nheap.Pop()\nfmt.Printf(\"%d %d %d\\n\", heap.Len(), heap.Less(0, 1), heap.Swap(0, 1))\nheap.Push(5)\nheap.Push(6)\nheap.Push(7)\nheap.Push(8)\nheap.Push(9)\nheap.Push(10)\nheap.Push(11)\nheap.Push(12)\nheap.Push(13)\nheap.Push(14)\nheap.Push(15)\nheap.Push(16)\nheap.Push(17)\nheap.Push(18)\nheap.Push(19)\nheap.Push(20)\nheap.Push(21)\nheap.Push(22)\nheap.Push(23)\nheap.Push(24)\nheap.Push(25)\nheap.Push(26)\nheap.Push(27)\nheap.Push(28)\nheap.Push(29)\nheap.Push(30)\n"}
{"tgt": "return MyCalendar{\n\tbooks: make([]seg, 0),\n}", "gen": "var s Solution\ns.Solve()\n}\n"}
{"tgt": "var buf bytes.Buffer\nbuf.WriteByte(\"STR\")\nfor i, word := range s.words {\n\tif word == 0 {\n\t\tcontinue\n\t}\n\tfor j := 0; j < 64; j++ {\n\t\tif word&(1<<uint(j)) != 0 {\n\t\t\tif buf.Len() > len(\"STR\") {\n\t\t\t\tbuf.WriteByte(\"STR\")\n\t\t\t}\n\t\t\tfmt.Fprintf(&buf, \"STR\", 64*i+j)\n\t\t}\n\t}\n}\nbuf.WriteByte(\"STR\")\nreturn buf.String()", "gen": "var buf bytes.Buffer\nbuf.WriteByte(123)\nfor i := 0; i < 64; i++ {\n\tbuf.WriteByte(byte(i))\n}\nfmt.Printf(\"%s\", buf.String())\n}\n"}
{"tgt": "matrix := [][]int{\n\t{5, 1, 9, 11},\n\t{2, 4, 8, 10},\n\t{13, 3, 6, 7},\n\t{15, 14, 12, 16},\n}\nmatrix = rotate(matrix)\nfor _, nums := range matrix {\n\tfor _, num := range nums {\n\t\tfmt.Print(num, \"STR\")\n\t}\n\tfmt.Println()\n}", "gen": "var a [5]int\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 4\na[4] = 5\nvar b [5]int\nb[0] = 6\nb[1] = 7\nb[2] = 8\nb[3] = 9\nb[4] = 10\nvar c [5]int\nc[0] = 11\nc[1] = 12\nc[2] = 13\nc[3] = 14\nc[4] = 15\nvar d [5]int\nd[0] = 16\nd[1] = 17\nd[2] = 18\nd[3] = 19\nd[4] = 20\nrotate(&a, &b, &c, &d)\nfmt.Println(a[0], a[1], a[2], a[3], a[4])\nfmt.Println(b[0], b[1], b[2], b[3], b[4])\nfmt.Println(c[0], c[1], c[2], c[3], c[4])\nfmt.Println(d[0], d[1], d[2], d[3], d[4])\n}"}
{"tgt": "return MyQueue{\n\tlist: list.New(),\n}", "gen": "var l *z2flist.List\nl = z2flist.New()\n}\n\n<ASM>\n.LFB1:\ncmpq %fs:112,%rsp\njnb .L2\nmovl $24,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L2:\npushq %rbp\nmovq %rsp,%rbp\nsubq $16,%rsp\nmovq $0,-8(%rbp)\n.LBB4:\n.LBB5:\ncall <container..z2flist.New@PLT>\nmovq %rax,-8(%rbp)\nmovq -8(%rbp),%rax\n.LBE5:\n.LBE4:\nleave\nret</ASM>"}
{"tgt": "res := sizeOfLargestBST(tree)\nreturn res.AnsPtr", "gen": "root := &TreeNode{Val: 3}\nroot.Left = &TreeNode{Val: 2}\nroot.Right = &TreeNode{Val: 5}\nroot.Left.Left = &TreeNode{Val: 1}\nroot.Left.Right = &TreeNode{Val: 4}\nroot.Right.Right = &TreeNode{Val: 6}\nfmt.Println(sizeOfLargestBST(root))\n}\n"}
{"tgt": "sort.Ints(candidates)\nvar res [][]int\ndfs(candidates, nil, target, 0, &res)\nreturn res", "gen": "var a []int\nsort.Ints(a)\ndfs(a, 0, 0, 0)\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := checkRecord(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(checkRecord(\"PPALL\"))\nfmt.Println(checkRecord(\"PPALLL\"))\nfmt.Println(checkRecord(\"PPALLLL\"))\nfmt.Println(checkRecord(\"PPALLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(check"}
{"tgt": "for i := 1; i < len(arr); i++ {\n\tvalue := arr[i]\n\tj := i - 1\n\tfor j >= 0 && arr[j] > value {\n\t\tarr[j+1] = arr[j]\n\t\tj = j - 1\n\t}\n\tarr[j+1] = value\n}", "gen": "var a [10]int\nfor i := 0; i < len(a); i++ {\n\ta[i] = i\n}\nfor i := len(a) - 1; i >= 0; i-- {\n\ta[i] = a[i] + a[i+1]\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var nums []int\nvar ret bool\nnums = []int{1, 2, 3, 1}\nret = true\nif ret != containsDuplicate(nums) {\n\tt.Fatalf(\"STR\", ret)\n}\nnums = []int{1, 2, 3, 4}\nret = false\nif ret != containsDuplicate(nums) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "fmt.Println(containsDuplicate([]int{1, 2, 3, 1}))\nfmt.Println(containsDuplicate([]int{1, 2, 3, 4}))\n}\n"}
{"tgt": "switch {\ncase head.Left == nil && head.Right == nil:\n\treturn head.Value\ncase head.Left != nil && head.Right != nil:\n\tleft := head.Value + MinPathSum(head.Left)\n\tright := head.Value + MinPathSum(head.Right)\n\treturn min(left, right)\ncase head.Left != nil:\n\treturn head.Value + MinPathSum(head.Left)\ndefault:\n\treturn head.Value + MinPathSum(head.Right)\n}", "gen": "fmt.Println(minPathSum([][]int{{1, 3, 1}, {1, 5, 1}, {4, 2, 1}}))\n}\n"}
{"tgt": "sets := make([][]int, 1, 1<<uint(len(nums)))\nfor _, num := range nums {\n\tfor _, set := range sets {\n\t\ts := make([]int, len(set), len(set)+1)\n\t\tcopy(s, set)\n\t\tsets = append(sets, append(s, num))\n\t}\n}\nreturn sets", "gen": "var a [64]int\nvar b [64]int\nvar c [64]int\nvar d [64]int\nvar e [64]int\nvar f [64]int\nvar g [64]int\nvar h [64]int\nvar i [64]int\nvar j [64]int\nvar k [64]int\nvar l [64]int\nvar m [64]int\nvar n [64]int\nvar o [64]int\nvar p [64]int\nvar q [64]int\nvar r [64]int\nvar s [64]int\nvar t [64]int\nvar u [64]int\nvar v [64]int\nvar w [64]int\nvar x [64]int\nvar y [64]int\nvar z [64]int\nvar aa [64]int\nvar ab [64]int\nvar ac [64]int\nvar ad [64]int\nvar ae [64]int\nvar af [64]int\nvar ag [64]int\nvar ah [64]int\nvar ai [64]int\nvar aj [64]int\nvar ak [64]int\nvar al [64]int\nvar am [64]int\nvar an [64]int\nvar ao [64]int\nvar ap [64]int\nvar aq [64]int\nvar ar [64]int\nvar as [64]int\nvar at [64]int\nvar au [64]int\nvar av [64]int\nvar aw [64]int\nvar ax [64]int\nvar ay [64]int\nvar az [64]int\nvar ba [64]int\nvar bb [64]int\nvar bc [64]int\n"}
{"tgt": "out := 100\nif x := p33(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "p33 := 100\nif p33 != 100 {\n\tvar p34 interface{}\n\tp34 = p33\n\tvar p35 interface{}\n\tp35 = p34\n\tvar p36 interface{}\n\tp36 = p35\n\ttesting.T.Errorf(0, 24, \"p33 != 100\", p34, p35, p36)\n}\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DWARF DIE: 112\n\nreturn 0\n}\n\n// DW"}
{"tgt": "steps := countSteps([]int{0, 0}, target)\nfor _, g := range ghosts {\n\tif steps >= countSteps(g, target) {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "fmt.Println(countSteps(2, 2))\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CourseOrder(tc.prereqs); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "if nil == root || k <= 0 {\n\treturn nil\n}\nvar target *BinaryTreeNode\nif root.left != nil {\n\ttarget = kthNode(root.left, k)\n}\nif target == nil {\n\tif 1 == k {\n\t\ttarget = root\n\t} else {\n\t\tk--\n\t}\n}\nif target == nil && root.right != nil {\n\ttarget = kthNode(root.right, k)\n}\nreturn target", "gen": "var root *Node\nvar k int\nfmt.Scan(&root)\nfmt.Scan(&k)\nfmt.Println(kthNode(root, k))\n}\n"}
{"tgt": "nums := []int{0, 0, 1, 2}\nfmt.Println(dominantIndex(nums))", "gen": "fmt.Println(dominantIndex([]int{1, 2, 3, 4, 5, 6}))\n}\n"}
{"tgt": "if root == nil {\n\treturn nil\n}\nif root.Val < L {\n\treturn trimBST(root.Right, L, R)\n}\nif root.Val > R {\n\treturn trimBST(root.Left, L, R)\n}\nroot.Left = trimBST(root.Left, L, R)\nroot.Right = trimBST(root.Right, L, R)\nreturn root", "gen": "fmt.Println(trimBST(nil, 1))\nfmt.Println(trimBST(nil, 0))\nfmt.Println(trimBST(nil, -1))\nfmt.Println(trimBST(nil, -2))\nfmt.Println(trimBST(nil, -3))\nfmt.Println(trimBST(nil, -4))\nfmt.Println(trimBST(nil, -5))\nfmt.Println(trimBST(nil, -6))\nfmt.Println(trimBST(nil, -7))\nfmt.Println(trimBST(nil, -8))\nfmt.Println(trimBST(nil, -9))\nfmt.Println(trimBST(nil, -10))\nfmt.Println(trimBST(nil, -11))\nfmt.Println(trimBST(nil, -12))\nfmt.Println(trimBST(nil, -13))\nfmt.Println(trimBST(nil, -14))\nfmt.Println(trimBST(nil, -15))\nfmt.Println(trimBST(nil, -16))\nfmt.Println(trimBST(nil, -17))\nfmt.Println(trimBST(nil, -18))\nfmt.Println(trimBST(nil, -19))\nfmt.Println(trimBST(nil, -20))\nfmt.Println(trimBST(nil, -21))\nfmt.Println(trimBST(nil, -22))\nfmt.Println(trimBST(nil, -23))\nfmt.Println(trimBST(nil, -24))\nfmt.Println(trimBST(nil, -25))\nfmt.Println(trimBST(nil, -26))\nfmt.Println(trimBST(nil, -27))\nfmt.Println(trimBST(nil, -28))\n"}
{"tgt": "length := len(matrix)\nfor i := 0; 2*i < length-1; i++ {\n\tfor j := i; j < length-i-1; j++ {\n\t\tmatrix[i][j], matrix[j][length-i-1], matrix[length-i-1][length-j-1], matrix[length-j-1][i] =\n\t\t\tmatrix[length-j-1][i], matrix[i][j], matrix[j][length-i-1], matrix[length-i-1][length-j-1]\n\t}\n}", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "p = len(postorder) - 1\nidxMap = make(map[int]int)\nfor i, v := range inorder {\n\tidxMap[v] = i\n}\nreturn build(0, len(inorder)-1, postorder)", "gen": "s := Solution{\n\tp: 2,\n}\ns.build(1, 2)\nfmt.Println(s.idxMap)\n}\n"}
{"tgt": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Print(sum, \"STR\")", "gen": "var a int\nfor i := 0; i < 1000; i++ {\n\tif i%3 == 0 {\n\t\ta += i\n\t} else if i%2 == 0 {\n\t\ta += i\n\t}\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "qs := []question856{\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{1},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{2},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{2},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{6},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{3},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{8},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans856, q.para856\n\tfmt.Printf(\"STR\", p, scoreOfParentheses(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "const (\n\txmin, ymin, xmax, ymax = -2, -2, +2, +2\n\twidth, height          = 1024, 1024\n)\nimg := image.NewRGBA(image.Rect(0, 0, width, height))\nfor py := 0; py < height; py++ {\n\ty := float64(py)/height*(ymax-ymin) + ymin\n\tfor px := 0; px < width; px++ {\n\t\tx := float64(px)/width*(xmax-xmin) + xmin\n\t\tz := complex(x, y)\n\t\timg.Set(px, py, mandelbrot(z))\n\t}\n}\npng.Encode(os.Stdout, img)", "gen": "var width, height int\nfmt.Scan(&width, &height)\nimg := image.NewRGBA(image.Rect(0, 0, width, height))\nfor y := 0; y < height; y++ {\n\tfor x := 0; x < width; x++ {\n\t\tz := complex(float64(x)/float64(width), float64(y)/float64(height))\n\t\timg.Set(x, y, mandelbrot(z))\n\t}\n}\npng.Encode(os.Stdout, img)\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif start, end := BusiestBuildingTimes(tc.moves); start != tc.start || end != tc.end {\n\t\tt.Errorf(\"STR\", tc.start, tc.end, start, end)\n\t}\n}", "gen": "fmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n}))\nfmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n\t{10, 11, 12},\n}))\nfmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t{13, 14, 15},\n}))\nfmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t{13, 14, 15},\n\t{16, 17, 18},\n}))\nfmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t{13, 14, 15},\n\t{16, 17, 18},\n\t{19, 20, 21},\n}))\nfmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t"}
{"tgt": "n := len(cost)\ndp := make([]int, n+1)\nfor i := 2; i <= n; i++ {\n\tdp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])\n}\nreturn dp[n]", "gen": "var nums = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar k = 4\nvar result = min(nums, k)\nfmt.Println(result)\n}\n"}
{"tgt": "return new(runningSchTaskList).init(tasks)", "gen": "var rt *runningSchTaskList\nrt = new(runningSchTaskList)\nrt.init(32, 24, 16)\n}\n\n<ASM>\nmovq -8(%rbp),%rax\nmovq %rax,%rdi\ncall <runtime.newobject@PLT>\nsubq $8,%rsp\npushq <32>(%rbp)\npushq <24>(%rbp)\npushq <16>(%rbp)\nmovq %rax,%rdi\ncall <go.greedy.runningSchTaskList.init>\naddq $32,%rsp\nmovq %rax,-8(%rbp)\nmovq -8(%rbp),%rax\nleave\nret</ASM>"}
{"tgt": "return area(A, B, C, D) + area(E, F, G, H) - area(max(A, E), max(B, F), min(C, G), min(D, H))", "gen": "fmt.Println(area(10, 20))\nfmt.Println(area(20, 10))\nfmt.Println(area(10, 10))\nfmt.Println(area(20, 20))\nfmt.Println(area(100, 200))\nfmt.Println(area(200, 100))\nfmt.Println(area(100, 100))\nfmt.Println(area(200, 200))\nfmt.Println(area(1000, 2000))\nfmt.Println(area(2000, 1000))\nfmt.Println(area(1000, 1000))\nfmt.Println(area(2000, 2000))\nfmt.Println(area(10000, 20000))\nfmt.Println(area(20000, 10000))\nfmt.Println(area(10000, 10000))\nfmt.Println(area(20000, 20000))\nfmt.Println(area(100000, 200000))\nfmt.Println(area(200000, 100000))\nfmt.Println(area(100000, 100000))\nfmt.Println(area(200000, 200000))\nfmt.Println(area(1000000, 2000000))\nfmt.Println(area(2000000, 1000000))\nfmt.Println(area(1000000, 1000000))\nfmt.Println(area(2000000, 20000"}
{"tgt": "r, err := http.Get(os.Args[1])\nif err != nil {\n\tfmt.Println(err)\n\treturn\n}\nio.Copy(os.Stdout, r.Body)\nif err := r.Body.Close(); err != nil {\n\tfmt.Println(err)\n}", "gen": "resp, err := http.Get(os.Args[1])\nif err != nil {\n\tpanic(err)\n}\ndefer resp.Body.Close()\nbody, err := ioutil.ReadAll(resp.Body)\nif err != nil {\n\tpanic(err)\n}\nfmt.Println(string(body))\nfmt.Println(resp.StatusCode)\n}\n"}
{"tgt": "qs := []question1304{\n\t{\n\t\tpara1304{5},\n\t\tans1304{[]int{-7, -1, 1, 3, 4}},\n\t},\n\t{\n\t\tpara1304{0},\n\t\tans1304{[]int{}},\n\t},\n\t{\n\t\tpara1304{3},\n\t\tans1304{[]int{-1, 0, 1}},\n\t},\n\t{\n\t\tpara1304{1},\n\t\tans1304{[]int{0}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1304, q.para1304\n\tfmt.Printf(\"STR\", p, sumZero(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(sumZero(5))\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 2, 1}, []int{0, 4, 1, 3, 2}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1}, []int{0}, []int{1}},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums, c.index)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums, c.index)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.nums = []int{1, 2, 3, 4}\nsolution.index = 0\nsolution.expect = 5\nsolution.name = \"TestSolution\"\nsolution.TestSolution()\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := isRobotBounded(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(isRobotBounded(\"GGLLGG\"))\nfmt.Println(isRobotBounded(\"GG\"))\nfmt.Println(isRobotBounded(\"GL\"))\nfmt.Println(isRobotBounded(\"GLG\"))\nfmt.Println(isRobotBounded(\"GLGGLG\"))\nfmt.Println(isRobotBounded(\"GLGGLGGLG\"))\nfmt.Println(isRobotBounded(\"GLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGL"}
{"tgt": "seen := make(map[string]struct{})\nfor _, tier := range al {\n\tfor _, v := range tier {\n\t\tif _, ok := seen[v]; !ok {\n\t\t\tseen[v] = struct{}{}\n\t\t\tret = append(ret, v)\n\t\t}\n\t}\n}\nreturn", "gen": "var m map[string]struct {\n\ta int\n\tb int\n\tc int\n}\nm = make(map[string]struct {\n\ta int\n\tb int\n\tc int\n})\nfor i := 0; i < 1000000; i++ {\n\tm[strconv.Itoa(i)] = struct {\n\t\ta int\n\t\tb int\n\t\tc int\n\t}{i, i, i}\n}\nfmt.Println(m)\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return h.tasks[i].r < h.tasks[j].r", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "return xtime.Unix(int64(jt), 0)", "gen": "var t time.Time\nvar t2 time.Time\nvar t3 time.Time\nt = time.Now()\nt2 = time.Unix(0, 0)\nt3 = time.Unix(0, 0)\n*t = t2\n*t = t3\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return RandomizedSet{\n\tl: []int{},\n\tm: make(map[int]int),\n}", "gen": "m := make(map[string]int)\nm[\"hello\"] = 10\n}\n\n<ASM>\n.LFB1:\ncmpq %fs:112,%rsp\njnb .L2\nmovl $120,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L2:\npushq %rbp\nmovq %rsp,%rbp\npushq %rbx\nsubq $104,%rsp\nmovq %rdi,-104(%rbp)\nmovq $0,-96(%rbp)\nmovq $0,-88(%rbp)\nmovq $0,-80(%rbp)\nmovq $0,-72(%rbp)\n.LBB4:\n.LBB5:\ncall <runtime.makemap_small@PLT>\nmovq %rax,%rbx\nleaq <type...60x.7int>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-56(%rbp)\nmovq -56(%rbp),%rax\nmovq %rax,-48(%rbp)\nmovq $0,-40(%rbp)\nmovq $0,-32(%rbp)\nmovq -48(%rbp),%rax\nmovq -40(%rbp),%rdx\nmovq %rax,-96(%rbp)\nmovq %rdx,-88(%rbp)\nmovq -32(%rbp),%rax\nmovq %rax,-80(%rbp)\nmovq %rbx,-72(%rbp)\nmovq -104(%rbp),%rcx\nmovq -96(%rbp),%rax\nmovq -88(%rbp),%rdx\nmovq %rax,(%rcx)\nmovq %rdx,<8>(%rcx)\nmovq -80(%rbp),%rax\nmovq -72(%rbp),%rd"}
{"tgt": "return TypeInt, nil", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nfmt.Println(a)\n}\n\n// 0000000000000000 <main>:\n// \t.cfi_startproc\n// \t.cfi_personality 0x3,__gxx_personality_v0\n// \t.cfi_lsda 0x1,.LLSDA268\n// \t.cfi_loc 1 0 0\n// \t.cfi_adjust_cfa_offset 48\n// \t.cfi_offset 11, -48\n// \t.cfi_offset 12, -40\n// \t.cfi_offset 13, -32\n// \t.cfi_offset 14, -24\n// \t.cfi_offset 15, -16\n// \tpushq %rbp\n// \tmovq %rsp, %rbp\n// \tsubq $48, %rsp\n// \tmovq %rdi, -56(%rbp)\n// \tmovq %rsi, -64(%rbp)\n// \tmovq %rdx, -72(%rbp)\n// \tmovl $0, -4(%rbp)\n// \tmovq $0, -48(%rbp)\n// \tmovq $0, -40(%rbp)\n// \tmovl $16, %eax\n// \tmovl $0, %r8d\n// \tmovl $0, %r9d\n// \tmovl %eax, -4(%rbp)\n// \tmovq %r8, -48(%rbp)\n// \tmovq %r9, -40(%rbp)\n// \tmovl -4(%rbp), %eax\n// \tmovl %eax, -32(%rbp)\n// \tmovq -48(%"}
{"tgt": "return createSkyline(buildings, 0, len(buildings)-1)", "gen": "var buildings [][]int\nbuildings = [][]int{{2, 9, 10}, {3, 7, 15}, {5, 12, 12}, {15, 20, 10}, {19, 24, 8}}\nfmt.Println(getSkyline(buildings))\n}\n"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil && max.Right != root {\n\t\t\tmax = max.Right\n\t\t}\n\t\tif max.Right == nil {\n\t\t\tmax.Right = root\n\t\t\troot = root.Left\n\t\t} else {\n\t\t\tres = append(res, root.Val)\n\t\t\troot = root.Right\n\t\t\tmax.Right = nil\n\t\t}\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "_, err := os.Open(\"STR\")\nif !os.IsNotExist(err) {\n\tpanic(\"STR\")\n}\nf, err := os.Open(\"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer func() {\n\tif err := f.Close(); err != nil {\n\t\tpanic(err)\n\t}\n\t_, err := f.Read(make([]byte, 10))\n\tif err == nil {\n\t\tpanic(\"STR\")\n\t}\n}()\ndata, err := ioutil.ReadAll(f)\nif err != nil {\n\tpanic(err)\n}\nprint(string(data))", "gen": "f, err := os.Open(\"./test.txt\")\nif err != nil {\n\tpanic(err)\n}\ndefer f.Close()\nb, err := ioutil.ReadAll(f)\nif err != nil {\n\tpanic(err)\n}\nfmt.Println(string(b))\n}\n```\n\n### \u6c47\u7f16\u4ee3\u7801\u89e3\u6790\n\n```\n.LFB0:\nleaq -584(%rsp),%r11\ncmpq %fs:112,%r11\njnb .L20\nmovl $584,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\n.LEHB0:\nret\n.L20:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $536,%rsp\n.LEHE0:\nmovb $0,-457(%rbp)\n.LBB2:\nleaq <.LC4>(%rip),%rax\nmovl $9,%edx\nleaq -160(%rbp),%rdi\nmovq %rax,%rcx\nmovq %rdx,%rbx\nmovq %rdx,%rax\nmovq %rcx,%rsi\nmovq %rax,%rdx\n.LEHB1:\ncall <os.Open@PLT>\nmovq -160(%rbp),%rax\nmovq -152(%rbp),%rdx\nmovq %rax,-448(%rbp)\nmovq %rdx,-440(%rbp)\nmovq -144(%rbp),%rax\nmovq %rax,-432(%rbp)\nmovq -448(%rbp),%rax\nmovq %rax,-56(%rbp)\nmovq -440(%"}
{"tgt": "start, total, tank := 0, 0, 0\nfor i, g := range gas {\n\ttank += g - cost[i]\n\tif tank < 0 {\n\t\tstart = i + 1\n\t\ttotal += tank\n\t\ttank = 0\n\t}\n}\nif total+tank < 0 {\n\treturn -1\n}\nreturn start", "gen": "var a [3]int\nvar b [4]int\nvar c [5]int\nvar d int\nvar e int\nvar f int\nvar g int\nfor i := 0; i < len(a); i++ {\n\tif i < len(a) {\n\t\td = a[i]\n\t\te = b[i]\n\t\tf = c[i]\n\t} else {\n\t\tpanic(\"index out of range\")\n\t}\n\tg = d + e + f\n}\nprintln(g)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "fmt.Println(btree.Data)", "gen": "var a, b, c int\nfmt.Println(a, b, c)\n}\n\n<ASM>\n.LFB1:\ncmpq %fs:112,%rsp\njnb .L3\nmovl $136,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L3:\npushq %rbp\nmovq %rsp,%rbp\naddq $-128,%rsp\nmovq %rdi,-120(%rbp)\nmovq -120(%rbp),%rax\nmovq <8>(%rax),%rdx\nmovq (%rax),%rax\nmovq %rax,-80(%rbp)\nmovq %rdx,-72(%rbp)\nleaq -80(%rbp),%rax\nmovq %rax,-64(%rbp)\nmovq $1,-56(%rbp)\nmovq $1,-48(%rbp)\nleaq -32(%rbp),%rax\nsubq $8,%rsp\npushq -48(%rbp)\npushq -56(%rbp)\npushq -64(%rbp)\nmovq %rax,%rdi\ncall <fmt.Println@PLT>\naddq $32,%rsp\nmovq -32(%rbp),%rax\nmovq -24(%rbp),%rdx\nmovq %rax,-112(%rbp)\nmovq %rdx,-104(%rbp)\nmovq -16(%rbp),%rax\nmovq %rax,-96(%rbp)\nleave\nret</ASM>"}
{"tgt": "n := len(num)\nres := []string{}\nvar dfs func(string, int, int, int)\ndfs = func(path string, index, result, pre int) {\n\tif index == n && result == target {\n\t\tres = append(res, path)\n\t\treturn\n\t}\n\tfor i := index; i < n; i++ {\n\t\tif num[index] == '0' && i != index {\n\t\t\treturn\n\t\t}\n\t\tcurrStr := num[index : i+1]\n\t\tcurr, _ := strconv.Atoi(currStr)\n\t\tif index == 0 {\n\t\t\tdfs(currStr, i+1, curr, curr)\n\t\t} else {\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result+curr, curr)\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result-curr, -curr)\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result-pre+pre*curr, pre*curr)\n\t\t}\n\t}\n}\ndfs(\"STR\", 0, 0, 0)\nreturn res", "gen": "fmt.Println(addOperators(\"123+5\", 9))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: \"STR\",\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: \"STR\",\n\t},\n}\nfor _, tt := range tests {\n\tgot := defangIPaddr(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(defangIPaddr(\"1.1.1.1\"))\nfmt.Println(defangIPaddr(\"255.100.50.0\"))\nfmt.Println(defangIPaddr(\"0.0.0.0\"))\nfmt.Println(defangIPaddr(\"10.0.0.255\"))\nfmt.Println(defangIPaddr(\"172.16.10.1\"))\nfmt.Println(defangIPaddr(\"192.168.0.1\"))\nfmt.Println(defangIPaddr(\"192.168.0.255\"))\nfmt.Println(defangIPaddr(\"192.168.255.255\"))\nfmt.Println(defangIPaddr(\"192.168.255.254\"))\nfmt.Println(defangIPaddr(\"192.168.255.253\"))\nfmt.Println(defangIPaddr(\"192.168.255.252\"))\nfmt.Println(defangIPaddr(\"192.168.255.251\"))\nfmt.Println(defangIPaddr(\"192.168.255.250\"))\nfmt.Println(defangIPaddr(\"192.168.255.249\"))\nfmt.Println(defangIPaddr(\"192.168.255.248\"))\nfmt.Println(defangIPaddr(\"192.168.255.247\"))\nfmt.Println(defangIPaddr(\"192.168.255.246\"))\nfmt.Println(defangIPaddr(\"192.168.255.245\"))\nfmt.Println(defangIPaddr(\"192.168.255.244\"))\nfmt"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := Base64DecodeDelegate(tc.base64); res != tc.decoded {\n\t\tt.Errorf(\"STR\", tc.decoded, res)\n\t}\n}", "gen": "fmt.Println(\"Day 382\")\nfmt.Println(\"Puzzle 1:\", puzzle1())\nfmt.Println(\"Puzzle 2:\", puzzle2())\n}\n"}
{"tgt": "qs := []question1207{\n\t{\n\t\tpara1207{[]int{1, 2, 2, 1, 1, 3}},\n\t\tans1207{true},\n\t},\n\t{\n\t\tpara1207{[]int{1, 2}},\n\t\tans1207{false},\n\t},\n\t{\n\t\tpara1207{[]int{-3, 0, 1, -3, 1, 1, 1, -3, 10, 0}},\n\t\tans1207{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1207, q.para1207\n\tfmt.Printf(\"STR\", p, uniqueOccurrences(p.arr))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(uniqueOccurrences([]int{1, 2, 2, 1, 1, 3, 3}))\nfmt.Println(uniqueOccurrences([]int{1, 1, 2, 2, 2, 3, 3}))\nfmt.Println(uniqueOccurrences([]int{1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,"}
{"tgt": "max := -1001\nmax1 := -1001\nmax2 := -1001\nmin1 := 1001\nmin2 := 1001\nfor _, n := range nums {\n\tswitch {\n\tcase n > max:\n\t\tmax2, max1, max = max1, max, n\n\tcase n > max1:\n\t\tmax2, max1 = max1, n\n\tcase n > max2:\n\t\tmax2 = n\n\t}\n\tswitch {\n\tcase n < min1:\n\t\tmin2, min1 = min1, n\n\tcase n < min2:\n\t\tmin2 = n\n\t}\n}\nreturn bigger(max1*max2, min1*min2) * max", "gen": "var a, b, c int\nfmt.Scan(&a, &b, &c)\nfmt.Println(bigger(a, b, c))\n}"}
{"tgt": "var ret float64\nvar x float64\nvar n int\nret = 0\nx = 0.00001\nn = 2147483647\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 1.0000\nx = 2\nn = 0\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 10.0000\nx = 10.0000\nn = 1\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 0.25000\nx = 2.0000\nn = -2\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "fmt.Println(myPow(2.0, 3))\nfmt.Println(myPow(2.0, -2))\nfmt.Println(myPow(0.00001, 2147483647))\n}\n"}
{"tgt": "for len(w.data) > 0 && w.data[len(w.data)-1] < n {\n\tw.data = w.data[0 : len(w.data)-1]\n}\nw.data = append(w.data, n)", "gen": "var a [10]int\nvar b [10]int\na[0] = 1\nb[0] = 2\na[1] = 3\nb[1] = 4\na[2] = 5\nb[2] = 6\na[3] = 7\nb[3] = 8\na[4] = 9\nb[4] = 10\na[5] = 11\nb[5] = 12\na[6] = 13\nb[6] = 14\na[7] = 15\nb[7] = 16\na[8] = 17\nb[8] = 18\na[9] = 19\nb[9] = 20\na[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9] = b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8], b[9]\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "n := 0\ntmp := head\nfor tmp != nil {\n\tn++\n\ttmp = tmp.Next\n}\nreturn helper(&head, 0, n-1)", "gen": "list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nroot := helper(list)\nfmt.Println(root)\n}\n"}
{"tgt": "const templ = `<p>A:{{.A}}</p><p>B:{{.B}}</p>`\nt := template.Must(template.New(\"STR\").Parse(templ))\nvar data struct {\n\tA string\n\tBtemplate.HTML\n}\ndata.A = \"STR\"\ndata.B = \"STR\"\nif err := t.Execute(os.Stdout, data); err != nil {\n\tlog.Fatal(err)\n}", "gen": "t := template.New(\"\")\nt, err := t.Parse(\"<html><body>{{.}}</body></html>\")\nif err != nil {\n\tlog.Fatal(err)\n}\nt.Execute(os.Stdout, \"hello, world\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(A) == len(A[0]) {\n\tfor i := 0; i < len(A); i++ {\n\t\tfor j := 0; j < len(A); j++ {\n\t\t\tif i == j {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]\n\t\t}\n\t}\n\treturn A\n}\nres := make([][]int, len(A[0]))\nfor i := 0; i < len(res); i++ {\n\tres[i] = make([]int, len(A))\n\tfor j := 0; j < len(A); j++ {\n\t\tres[i][j] = A[j][i]\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar bb [3]int\nvar cc [3]int\nvar dd [3]int\nvar ee [3]int\nvar ff [3]int\nvar gg [3]int\nvar hh [3]int\nvar ii [3]int\nvar jj [3]int\nvar kk [3]int\nvar ll [3]int\nvar mm [3]int\nvar nn [3]int\nvar oo [3]int\nvar pp [3]int\nvar qq [3]int\nvar rr [3]int\nvar ss [3]int\nvar tt [3]int\nvar uu [3]int\nvar vv [3]int\nvar ww [3]int\nvar xx [3]int\nvar yy [3]int\nvar zz [3]int\nvar aaa [3]int\nvar bbb [3]int\nvar ccc [3]int\nvar ddd [3]int\nvar eee [3]int\nvar fff [3]int\nvar ggg [3]int\nvar hhh [3]"}
{"tgt": "out := make(map[string]string)\nmain_pieces := strings.Split(s, sep1)\nfor _, piece := range main_pieces {\n\tminor_pieces := strings.Split(piece, sep2)\n\tout[minor_pieces[0]] = minor_pieces[1]\n}\nreturn out", "gen": "var m map[string]string\nvar s string\nvar a []string\nvar b []string\nvar c string\nvar d string\nvar e string\nvar f string\nvar g string\nvar h string\nvar i string\nvar j string\nvar k string\nvar l string\nvar m map[string]string\nvar s string\nvar a []string\nvar b []string\nvar c string\nvar d string\nvar e string\nvar f string\nvar g string\nvar h string\nvar i string\nvar j string\nvar k string\nvar l string\nvar m map[string]string\nvar s string\nvar a []string\nvar b []string\nvar c string\nvar d string\nvar e string\nvar f string\nvar g string\nvar h string\nvar i string\nvar j string\nvar k string\nvar l string\nvar m map[string]string\nvar s string\nvar a []string\nvar b []string\nvar c string\nvar d string\nvar e string\nvar f string\nvar g string\nvar h string\nvar i string\nvar j string\nvar k string\nvar l string\nvar m map[string]string\nvar s string\nvar a []string\nvar b []string\nvar c string\nvar d string\nvar e string\nvar f string\nvar g string\nvar h string\nvar i string\nvar j string\nvar k string\nvar l string\nvar m map[string]string\nvar s string\nvar a []string\nvar b []string\nvar c string\nvar d string\nvar e string\nvar f string\nvar g string\nvar h string\nvar i string\nvar j string\nvar k string\nvar l string\nvar m map[string]string\nvar s string\nvar a []string\nvar b []string\nvar c string\nvar d string\nvar e string\nvar f"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CountLargerAndSmallerBrute(tc.mat, tc.i1, tc.j1, tc.i2, tc.j2); result != tc.count {\n\t\tt.Errorf(\"STR\", tc.count, result)\n\t}\n}", "gen": "fmt.Println(CountLargerAndSmallerBrute([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 5))\nfmt.Println(CountLargerAndSmallerBrute([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 10))\nfmt.Println(CountLargerAndSmallerBrute([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 11))\nfmt.Println(CountLargerAndSmallerBrute([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 12))\nfmt.Println(CountLargerAndSmallerBrute([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 13))\nfmt.Println(CountLargerAndSmallerBrute([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 14))\nfmt.Println(CountLargerAndSmallerBrute([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 15))\nfmt.Println(CountLargerAndSmallerBrute([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 16))\nfmt.Println(CountLargerAndSmallerBrute([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 17))\nfmt.Println(CountLargerAndSmallerBrute([]int{1, 2, "}
{"tgt": "size := len(a)\nlo, hi := 0, size-1\nvar miD, miA int\nfor lo <= hi {\n\tmiD = (lo + hi) / 2\n\tmiA = size - miD - 1\n\tif a[miA] > miD {\n\t\tlo = miD + 1\n\t} else {\n\t\thi = miD - 1\n\t}\n}\nreturn lo", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i\n}\nfmt.Println(a[i])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "l1, l2 := []int{}, []int{}\ndfs(root1, &l1)\ndfs(root2, &l2)\nif len(l1) != len(l2) {\n\treturn false\n}\nfor i, _ := range l1 {\n\tif l1[i] != l2[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [2]int\nvar b [2]int\nvar c [2]int\nvar d [2]int\nvar e [2]int\nvar f [2]int\nvar g [2]int\nvar h [2]int\nvar i [2]int\nvar j [2]int\nvar k [2]int\nvar l [2]int\nvar m [2]int\nvar n [2]int\nvar o [2]int\nvar p [2]int\nvar q [2]int\nvar r [2]int\nvar s [2]int\nvar t [2]int\nvar u [2]int\nvar v [2]int\nvar w [2]int\nvar x [2]int\nvar y [2]int\nvar z [2]int\nvar aa [2]int\nvar ab [2]int\nvar ac [2]int\nvar ad [2]int\nvar ae [2]int\nvar af [2]int\nvar ag [2]int\nvar ah [2]int\nvar ai [2]int\nvar aj [2]int\nvar ak [2]int\nvar al [2]int\nvar am [2]int\nvar an [2]int\nvar ao [2]int\nvar ap [2]int\nvar aq [2]int\nvar ar [2]int\nvar as [2]int\nvar at [2]int\nvar au [2]int\nvar av [2]int\nvar aw [2]int\nvar ax [2]int\nvar ay [2]int\nvar az [2]int\nvar aa [2]int\nvar ab [2]int\nvar ac [2]int\nvar ad [2]int\nvar ae [2]int\nvar af [2]int\nvar ag [2]int\nvar ah [2]int\nvar ai [2]int\nvar aj [2]int\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result, err := ShortestRunnerPath(tc.elevations, tc.paths); result != tc.shortestRoute || err != tc.err {\n\t\tt.Errorf(\"STR\", tc.shortestRoute, tc.err, result, err)\n\t}\n}", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "sLen, pLen := len(s), len(p)\ndp := make([][]bool, sLen+1)\nfor i := range dp {\n\tdp[i] = make([]bool, pLen+1)\n}\ndp[sLen][pLen] = true\nfor i := sLen; i > -1; i-- {\n\tfor j := pLen - 1; j > -1; j-- {\n\t\tfirstMatch := i < sLen && (p[j] == s[i] || p[j] == '.')\n\t\tif j+1 < pLen && p[j+1] == '*' {\n\t\t\tdp[i][j] = dp[i][j+2] || firstMatch && dp[i+1][j]\n\t\t} else {\n\t\t\tdp[i][j] = firstMatch && dp[i+1][j+1]\n\t\t}\n\t}\n}\nreturn dp[0][0]", "gen": "var a []bool\nvar b []bool\nvar c []bool\nvar d bool\na = make([]bool, 1)\nb = make([]bool, 1)\nc = make([]bool, 1)\nd = false\nfor i := 0; i < 1; i++ {\n\ta[i] = false\n}\nfor i := 0; i < 1; i++ {\n\tb[i] = false\n}\nfor i := 0; i < 1; i++ {\n\tc[i] = false\n}\nfor i := 0; i < 1; i++ {\n\tif c[i] {\n\t\td = true\n\t}\n}\nif d {\n\ta[0] = true\n}\nfor i := 0; i < 1; i++ {\n\tif b[i] {\n\t\ta[i] = true\n\t}\n}\nfor i := 0; i < 1; i++ {\n\tif a[i] {\n\t\tc[i] = true\n\t}\n}\nfor i := 0; i < 1; i++ {\n\tif c[i] {\n\t\tb[i] = true\n\t}\n}\nfor i := 0; i < 1; i++ {\n\tif b[i] {\n\t\ta[i] = true\n\t}\n}\nfor i := 0; i < 1; i++ {\n\tif a[i] {\n\t\tc[i] = true\n\t}\n}\nfor i := 0; i < 1; i++ {\n\tif c[i] {\n\t\tb[i] = true\n\t}\n}\nfor i := 0; i < 1; i++ {\n\tif b[i] {\n\t\ta[i] = true\n\t}\n}\nfor"}
{"tgt": "sort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].End < intervals[j].End\n})\ncount := 0\ncurrent := -int(^uint(0)>>1) - 1\nfor _, interval := range intervals {\n\tif interval.Start >= current {\n\t\tcount++\n\t\tcurrent = interval.End\n\t}\n}\nreturn len(intervals) - count", "gen": "intervals := []Interval{{1, 2}, {2, 3}, {3, 4}, {1, 3}}\nfmt.Println(minRemoveToMakeValid(intervals))\n}\n"}
{"tgt": "i := len(nums) - 2\nfor i >= 0 && nums[i] >= nums[i+1] {\n\ti--\n}\nj, k := i+1, len(nums)-1\nfor j < k {\n\tnums[j], nums[k] = nums[k], nums[j]\n\tj, k = j+1, k-1\n}\nif i >= 0 {\n\tj = i + 1\n\tfor nums[j] <= nums[i] {\n\t\tj++\n\t}\n\tnums[i], nums[j] = nums[j], nums[i]\n}", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar bb [10]int\nvar cc [10]int\nvar dd [10]int\nvar ee [10]int\nvar ff [10]int\nvar gg [10]int\nvar hh [10]int\nvar ii [10]int\nvar jj [10]int\nvar kk [10]int\nvar ll [10]int\nvar mm [10]int\nvar nn [10]int\nvar oo [10]int\nvar pp [10]int\nvar qq [10]int\nvar rr [10]int\nvar ss [10]int\nvar tt [10]int\nvar uu [10]int\nvar vv [10]int\nvar ww [10]int\nvar xx [10]int\nvar yy [10]int\nvar zz [10]int\nvar aaa [10]int\nvar bbb [10]"}
{"tgt": "denoms := make(map[int]struct{})\nfor d, way := range ways {\n\tif others := waysToProduce(d, denoms); (way == 1 && d > 0) || others == way-1 {\n\t\tdenoms[d] = struct{}{}\n\t}\n}\nres := make([]int, 0, len(denoms))\nfor k := range denoms {\n\tres = append(res, k)\n}\nsort.Ints(res)\nreturn res", "gen": "var a, b, c int\nfmt.Scan(&a, &b, &c)\nfmt.Println(waysToProduce(a, b, c))\n}\n"}
{"tgt": "return len(self.data)", "gen": "var a int\na = 0\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var ri, gi int\nfor i, r := range letters {\n\tif r == 'R' {\n\t\tletters[i] = letters[gi]\n\t\tletters[gi] = letters[ri]\n\t\tletters[ri] = r\n\t\tgi++\n\t\tri++\n\t} else if r == 'G' {\n\t\tletters[i] = letters[gi]\n\t\tletters[gi] = r\n\t\tgi++\n\t}\n}", "gen": "var a [3][3]int\nvar i int\nfor i = 0; i < 3; i++ {\n\ta[i][0] = i\n\ta[i][1] = i + 1\n\ta[i][2] = i + 2\n}\nfor i = 0; i < 3; i++ {\n\tif i == 2 {\n\t\tbreak\n\t}\n\tfmt.Println(a[i][0], a[i][1], a[i][2])\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "switch rand.Intn(10) {\ncase 1, 9:\n\treturn io.EOF\ncase 5:\n\treturn errors.New(\"STR\")\ndefault:\n\td.Line = \"STR\"\n\tfmt.Println(\"STR\", d.Line)\n\treturn nil\n}", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar"}
{"tgt": "return helper(root, p, q)", "gen": "var a, b, c int\na = 1\nb = 2\nc = helper(a, b)\nfmt.Println(c)\n}"}
{"tgt": "benchmark(bb, 16384, 0.1)", "gen": "benchmark()\n}\n"}
{"tgt": "this.mutex.Lock()\ndefer this.mutex.Unlock()\nif priority < 0 || priority > this.max {\n\treturn nil\n}\nreturn this.queues[priority].Peek()", "gen": "var m sync.Mutex\nvar q Queue\nvar i int\nm.Lock()\ndefer m.Unlock()\nif q.Len() == 0 {\n\ti = 0\n} else {\n\tif q.Len() > 0 {\n\t\tif q.Len() > 0 {\n\t\t\ti = 0\n\t\t} else {\n\t\t\ti = 0\n\t\t}\n\t} else {\n\t\ti = 0\n\t}\n}\nif i == 0 {\n\ti = 0\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if i < 0 || i >= itemKind(len(_itemKind_index)-1) {\n\treturn fmt.Sprintf(\"STR\", i)\n}\nreturn _itemKind_name[_itemKind_index[i]:_itemKind_index[i+1]]", "gen": "var r *httprange.Range\nr = &httprange.Range{}\nr.itemKind = httprange.itemKind{\n\t0: 0,\n}\nr.itemKind[0] = 0\nr.itemKind[1] = 0\nfmt.Printf(\"%d %d\", r.itemKind[0], r.itemKind[1])\n}\n\n// Output:\n// 0 0\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n<ASM>\n.LFB50:\ncmpq %fs:112,%rsp\njnb .L700\nmovl $152,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL59:\nret\n.L700:\npushq %rbp\nmovq %rsp,%rbp\npushq %r15\npushq %r14\npushq %r13\npushq %r12\npushq %rbx\nsubq $104,%rsp\nmovq %rdi,-136(%rbp)\ncmpq $0,-136(%rbp)\njne .L685\ncall <runtime.panicmem@PLT>\n.L685:\nmovq -136(%rbp),%rax\nmovq (%rax),%rax\nmovq %rax,-56(%rbp)\nmovq $0,-128(%rbp)\nmovq $0,-120(%rbp)\n.LBB654:\n.LBB655:\n.LBB656:\nmovq -56(%rbp),%rax\nshrq $63,%rax\nmovl %eax,%edx\nxorl $1,%edx\ntestb %dl,%dl\nje .L686\n.LBB657:\ncmpq $5,-56(%rbp)\nsetg %al\n.L686:\n.LBE65"}
{"tgt": "arr := randomSlice(0, 20, 10)\nnodeCnt := 0\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\nrotateNodes := make([]*gbtElement, 0, 0)\ngbt.InOrderWalk(gbt.Root(), func(GBTbinaryTreeIf, node interface{}) bool {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\trotateNodes = append(rotateNodes, node.(*gbtElement))\n\t}\n\treturn false\n})\nfor _, v := range rotateNodes {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\tgbt.LeftRotate(v)\n\t} else {\n\t\tgbt.RightRotate(v)\n\t}\n}\ngbt.InOrderWalk(gbt.Root(), checkGBT(t, &nodeCnt, *debug))\nif nodeCnt != len(arr) {\n\tt.Log(fmt.Sprintf(\"STR\", len(arr), nodeCnt))\n\tt.Fail()\n}", "gen": "var t testing.T\nvar bt *binaryTree.GBT\nvar rndSlice []int\nvar rndSlice2 []int\nvar rndSlice3 []int\nvar rndSlice4 []int\nvar rndSlice5 []int\nvar rndSlice6 []int\nvar rndSlice7 []int\nvar rndSlice8 []int\nvar rndSlice9 []int\nvar rndSlice10 []int\nvar rndSlice11 []int\nvar rndSlice12 []int\nvar rndSlice13 []int\nvar rndSlice14 []int\nvar rndSlice15 []int\nvar rndSlice16 []int\nvar rndSlice17 []int\nvar rndSlice18 []int\nvar rndSlice19 []int\nvar rndSlice20 []int\nvar rndSlice21 []int\nvar rndSlice22 []int\nvar rndSlice23 []int\nvar rndSlice24 []int\nvar rndSlice25 []int\nvar rndSlice26 []int\nvar rndSlice27 []int\nvar rndSlice28 []int\nvar rndSlice29 []int\nvar rndSlice30 []int\nvar rndSlice31 []int\nvar rndSlice32 []int\nvar rndSlice33 []int\nvar rndSlice34 []int\nvar rndSlice35 []int\nvar rndSlice36 []int\nvar rndSlice37 []int\nvar rndSlice38 []int\nvar rndSlice39 []int\nvar rndSlice40 []int\nvar rndSlice41 []int\nvar rndSlice42 []int\nvar rndSlice43 []int\nvar rndSlice44 []int\nvar rndSlice45"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := InversionCountBrute(tc.input); result != tc.inversions {\n\t\tt.Errorf(\"STR\", tc.inversions, result)\n\t}\n}", "gen": "fmt.Println(InversionCountBrute([]int{1, 2, 3, 4, 5, 6, 7, 8}))\nfmt.Println(InversionCountBrute([]int{1, 2, 3, 4, 5, 6, 7}))\nfmt.Println(InversionCountBrute([]int{1, 2, 3, 4, 5, 6}))\nfmt.Println(InversionCountBrute([]int{1, 2, 3, 4, 5}))\nfmt.Println(InversionCountBrute([]int{1, 2, 3, 4}))\nfmt.Println(InversionCountBrute([]int{1, 2, 3}))\nfmt.Println(InversionCountBrute([]int{1, 2}))\nfmt.Println(InversionCountBrute([]int{1}))\nfmt.Println(InversionCountBrute([]int{}))\n}\n"}
{"tgt": "fmt.Println(subarrayBitwiseORs([]int{0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))", "gen": "var a = []int{1, 1, 2, 3, 3}\nvar b = []int{1, 2, 3}\nvar c = []int{1, 1, 2, 3, 3}\nvar d = []int{1, 2, 3}\nvar e = []int{1, 1, 2, 3, 3}\nvar f = []int{1, 2, 3}\nvar g = []int{1, 1, 2, 3, 3}\nvar h = []int{1, 2, 3}\nvar i = []int{1, 1, 2, 3, 3}\nvar j = []int{1, 2, 3}\nvar k = []int{1, 1, 2, 3, 3}\nvar l = []int{1, 2, 3}\nvar m = []int{1, 1, 2, 3, 3}\nvar n = []int{1, 2, 3}\nvar o = []int{1, 1, 2, 3, 3}\nvar p = []int{1, 2, 3}\nvar q = []int{1, 1, 2, 3, 3}\nvar r = []int{1, 2, 3}\nvar s = []int{1, 1, 2, 3, 3}\nvar t = []int{1, 2, 3}\nvar u = []int{1, 1, 2, 3, 3}\nvar v = []int{1, 2, 3}\nvar w = []int{1, 1, 2, 3, 3}\nvar x = []int{1, 2, 3}\nvar y = []int{1, 1, 2, 3, 3}\nvar z = []int{1, 2, 3}\nvar aa = []int"}
{"tgt": "if nil == root {\n\treturn []int{}\n}\nlargestVals := []int{}\nchildren := []*TreeNode{root}\nfor len(children) > 0 {\n\ttmp := children[:]\n\tchildren = []*TreeNode{}\n\tlargest := -(1 << 32)\n\tfor _, child := range tmp {\n\t\tif child.Val > largest {\n\t\t\tlargest = child.Val\n\t\t}\n\t\tif nil != child.Left {\n\t\t\tchildren = append(children, child.Left)\n\t\t}\n\t\tif nil != child.Right {\n\t\t\tchildren = append(children, child.Right)\n\t\t}\n\t}\n\tlargestVals = append(largestVals, largest)\n}\nreturn largestVals", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aaa [3]int\nvar aab [3]int\nvar aac [3]int\nvar aad [3]int\nvar aae [3]int\nvar aaf [3]int\nvar aag [3]int\nvar aah [3]int\nvar aai [3]int\n"}
{"tgt": "{\n\tdata, err := json.Marshal(movies)\n\tif err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Printf(\"STR\", data)\n}\n{\n\tdata, err := json.MarshalIndent(movies, \"STR\")\n\tif err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Printf(\"STR\", data)\n\tvar titles []struct{ Title string }\n\tif err := json.Unmarshal(data, &titles); err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Println(titles)\n}", "gen": "var movies = []Movie{\n\t{Title: \"Casablanca\", Year: 1942, Color: false},\n\t{Title: \"Cool Hand Luke\", Year: 1966, Color: true},\n\t{Title: \"Bullitt\", Year: 1968, Color: true},\n}\n\nb, err := json.Marshal(movies)\nif err != nil {\n\tlog.Fatal(err)\n}\nvar p []byte\nerr = json.Unmarshal(b, &p)\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Printf(\"%s\\n\", p)\n}\n"}
{"tgt": "if num <= 0 {\n\treturn false\n}\nif num&(num-1) != 0 {\n\treturn false\n}\nif num&0x55555555 == 0 {\n\treturn false\n}\nreturn true", "gen": "var x int\nif x > 0 {\n\tx = 0\n}\nif x < 0 {\n\tx = 0\n}\nif x == 0 {\n\tx = 0\n}\nif x > 0 {\n\tx = 0\n}\nif x < 0 {\n\tx = 0\n}\nif x == 0 {\n\tx = 0\n}\nif x > 0 {\n\tx = 0\n}\nif x < 0 {\n\tx = 0\n}\nif x == 0 {\n\tx = 0\n}\nif x > 0 {\n\tx = 0\n}\nif x < 0 {\n\tx = 0\n}\nif x == 0 {\n\tx = 0\n}\nif x > 0 {\n\tx = 0\n}\nif x < 0 {\n\tx = 0\n}\nif x == 0 {\n\tx = 0\n}\nif x > 0 {\n\tx = 0\n}\nif x < 0 {\n\tx = 0\n}\nif x == 0 {\n\tx = 0\n}\nif x > 0 {\n\tx = 0\n}\nif x < 0 {\n\tx = 0\n}\nif x == 0 {\n\tx = 0\n}\nif x > 0 {\n\tx = 0\n}\nif x < 0 {\n\tx = 0\n}\nif x == 0 {\n\tx = 0\n}\nif x > 0 {\n\tx = 0\n}\nif x < 0 {\n\tx = 0\n}\nif x == 0 {\n\tx = 0\n}\nif x > 0 {\n"}
{"tgt": "major := uint32((dev & 0x00000000000fff00) >> 8)\nmajor |= uint32((dev & 0xfffff00000000000) >> 32)\nreturn major", "gen": "var a int\na = 0\na = a & 1048320\na = a >> 8\na = a & 17592186044416\na = a >> 32\na = a | a\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "t.Parallel()\nvar ba BitArray\nfor _, tc := range testcases {\n\tba.Init(tc.size)\n\tfor index, val := range tc.ones {\n\t\tif err := ba.Set(index, val); err != nil {\n\t\t\tt.Errorf(\"STR\")\n\t\t}\n\t}\n\tfor i := 0; i < tc.size; i++ {\n\t\tif val, err := ba.Get(i); err != nil {\n\t\t\tt.Errorf(\"STR\", err)\n\t\t} else if tc.ones[i] != val {\n\t\t\tt.Errorf(\"STR\", tc.ones[i], val, i)\n\t\t}\n\t}\n}", "gen": "testing.Init()\nos.Exit(maintest.RunTests())\n}\n"}
{"tgt": "if a == b {\n\treturn -1\n}\nif len(a) > len(b) {\n\treturn len(a)\n}\nreturn len(b)", "gen": "var a, b, c string\nvar d int\nif a == b {\n\tif c == a {\n\t\td = 1\n\t} else {\n\t\td = 0\n\t}\n} else {\n\tif c == a {\n\t\td = -1\n\t} else {\n\t\tif a < b {\n\t\t\td = -1\n\t\t} else {\n\t\t\td = 1\n\t\t}\n\t}\n}\nfmt.Println(d)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil {\n\t\t\tmax = max.Right\n\t\t}\n\t\tmax.Right = root\n\t\troot, root.Left = root.Left, nil\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aaa [3]int\nvar aab [3]int\nvar aac [3]int\nvar aad [3]int\nvar aae [3]int\nvar aaf [3]int\nvar aag [3]int\nvar aah [3]int\nvar aai [3]int\n"}
{"tgt": "if a > b {\n\treturn b\n}\nreturn a", "gen": "var a, b int\nif a < b {\n\ta = b\n}\nfmt.Println(a)\n}\n\n// 0x0000000000000000 <main>:\n// 0:\t55                   \tpush   %rbp\n// 1:\t48 89 e5             \tmov    %rsp,%rbp\n// 4:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// 8:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// c:\t48 89 c7             \tmov    %rax,%rdi\n// f:\te8 00 00 00 00       \tcallq  10 <main+0x10>\n// 14:\t48 8b 45 f0          \tmov    -0x10(%rbp),%rax\n// 18:\t48 89 c7             \tmov    %rax,%rdi\n// 1b:\te8 00 00 00 00       \tcallq  1f <main+0x1f>\n// 20:\t48 89 45 f8          \tmov    %rax,-0x8(%rbp)\n// 24:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n// 28:\t48 89 c7             \tmov    %rax,%rdi\n// 2b:\te8 00 00 00 00       \tcallq  2f <main+0x2f>\n// 30:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n// 34:\t48 89 c2             \tmov    %rax,%rdx\n// 37:\t48 8"}
{"tgt": "var buf bytes.Buffer\nif err := encode(&buf, reflect.ValueOf(v)); err != nil {\n\treturn nil, err\n}\nreturn buf.Bytes(), nil", "gen": "var buf bytes.Buffer\nbuf.Write([]byte(\"hello\"))\nfmt.Println(buf.Bytes())\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "m := map[byte]struct{}{}\nfor i := range J {\n\tm[J[i]] = struct{}{}\n}\nres := 0\nfor i := range S {\n\tif _, ok := m[S[i]]; ok {\n\t\tres++\n\t}\n}\nreturn res", "gen": "var m map[uint8]struct{}\nvar s string\nvar i int\nvar j int\nm = make(map[uint8]struct{})\nfor i = 0; i < 2; i++ {\n\tfor j = 0; j < 2; j++ {\n\t\tvar c uint8\n\t\tvar r rune\n\t\tc = uint8(i)\n\t\tr = rune(j)\n\t\tm[c] = struct{}{}\n\t}\n}\ns = string(m)\ni = len(s)\nj = 0\nfor j < i {\n\tvar c uint8\n\tvar r rune\n\tc = uint8(s[j])\n\tr, _ = utf8.DecodeRuneInString(s[j:])\n\tj++\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if numRows < 2 {\n\treturn s\n}\nmaxInterval := (numRows - 1) << 1\ninterval := maxInterval\nafter := \"STR\"\nfor i := 0; i < numRows; i++ {\n\tif numRows-1 == i {\n\t\tinterval = maxInterval\n\t}\n\tfor j, no := i, 0; j < len(s); no++ {\n\t\tafter += string(s[j])\n\t\tif i > 0 && i < numRows-1 && 1 == no&1 {\n\t\t\tj += maxInterval - interval\n\t\t\tcontinue\n\t\t}\n\t\tj += interval\n\t}\n\tinterval -= 2\n}\nreturn after", "gen": "var a [10]int\nvar b [10]int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\n"}
{"tgt": "var result []string\ndfs(s, []string{}, &result)\nreturn result", "gen": "var nums = []int{1, 2, 3}\nvar result []int\ndfs(&result, nums, 0)\nfmt.Println(result)\n}\n"}
{"tgt": "if n < 7 {\n\treturn int64(n + 1)\n}\nans := (1 + int64(n%7)) * row(n/7)\nreturn ans", "gen": "var a int\nfor i := 0; i < 6; i++ {\n\ta = row(i)\n}\nfmt.Println(a)\n}"}
{"tgt": "if len(mat) == 0 || len(mat[0]) == 0 {\n\treturn []int{}\n}\nm, n := len(mat), len(mat[0])\nisUpping := true\nnext := func(i, j int) (int, int) {\n\tif isUpping {\n\t\ti--\n\t\tj++\n\t\tif 0 <= i && j < n {\n\t\t\treturn i, j\n\t\t}\n\t\tisUpping = false\n\t\tif i < 0 && j < n {\n\t\t\treturn 0, j\n\t\t}\n\t\treturn i + 2, j - 1\n\t}\n\ti++\n\tj--\n\tif i < m && 0 <= j {\n\t\treturn i, j\n\t}\n\tisUpping = true\n\tif i < m && j < 0 {\n\t\treturn i, 0\n\t}\n\treturn i - 1, j + 2\n}\nmn := m * n\nres := make([]int, mn)\ni, j := 0, 0\nfor k := 0; k < mn; k++ {\n\tres[k] = mat[i][j]\n\ti, j = next(i, j)\n}\nreturn res", "gen": "var a [3][3]int\nvar b [3][3]int\nvar c [3][3]int\nvar d [3][3]int\nvar e [3][3]int\nvar f [3][3]int\nvar g [3][3]int\nvar h [3][3]int\nvar i [3][3]int\nvar j [3][3]int\nvar k [3][3]int\nvar l [3][3]int\nvar m [3][3]int\nvar n [3][3]int\nvar o [3][3]int\nvar p [3][3]int\nvar q [3][3]int\nvar r [3][3]int\nvar s [3][3]int\nvar t [3][3]int\nvar u [3][3]int\nvar v [3][3]int\nvar w [3][3]int\nvar x [3][3]int\nvar y [3][3]int\nvar z [3][3]int\nvar aa [3][3]int\nvar ab [3][3]int\nvar ac [3][3]int\nvar ad [3][3]int\nvar ae [3][3]int\nvar af [3][3]int\nvar ag [3][3]int\nvar ah [3][3]int\nvar ai [3][3]int\nvar aj [3][3]int\nvar ak [3][3]int\nvar al [3][3]int\nvar am [3][3]int\nvar an [3][3]int\nvar ao [3][3]int\nvar ap [3][3]int\nvar aq [3][3]int\nvar ar [3][3]int\nvar as [3][3]int\nvar at [3][3]int\nvar au [3][3]int\nvar av [3][3]int\nvar aw [3][3]int\nvar ax [3][3]"}
{"tgt": "n := len(quality)\nworkers := make([][2]float64, n)\nfor i := 0; i < n; i++ {\n\tw, q := float64(wage[i]), float64(quality[i])\n\tworkers[i][0], workers[i][1] = w/q, q\n}\nsort.Slice(workers, func(i, j int) bool {\n\treturn workers[i][0] < workers[j][0]\n})\nres := math.MaxFloat64\nsum := 0.\nh := floatHeap{}\nfor _, w := range workers {\n\tsum += w[1]\n\theap.Push(&h, w[1])\n\tif len(h) > K {\n\t\tsum -= heap.Pop(&h).(float64)\n\t}\n\tif len(h) == K {\n\t\tres = min(res, sum*w[0])\n\t}\n}\nreturn res", "gen": "fmt.Println(mincostToHireWorkers([]int{10, 20, 5}, []int{7, 15, 20}))\n}\n"}
{"tgt": "t.Parallel()\nlfu := NewLFUCache(3)\nlfu.Set(\"STR\", \"STR\")\nlfu.Set(1, 2)\nlfu.Set(\"STR\", \"STR\")\nlfu.Get(1)\nlfu.Get(\"STR\")\nlfu.Set(100, 1)\nif result := lfu.Get(\"STR\"); result != nil {\n\tt.Errorf(\"STR\", result)\n}\nif result := lfu.Get(1); result == nil {\n\tt.Errorf(\"STR\")\n}\nif result := lfu.Get(\"STR\"); result == nil {\n\tt.Errorf(\"STR\")\n}\nif result := lfu.Get(100); result == nil {\n\tt.Errorf(\"STR\")\n}\nlfu.Set(100, \"STR\")\nif result := lfu.Get(100); result.(string) != \"STR\" {\n\tt.Errorf(\"STR\")\n}", "gen": "testing.Init()\nos.Exit(maintest.RunTests())\n}\n"}
{"tgt": "m := len(pattern)\nnext := make([]int, m)\nfor index := range next {\n\tnext[index] = -1\n}\nfor i := 1; i < m-1; i++ {\n\tj := next[i-1]\n\tfor pattern[j+1] != pattern[i] && j >= 0 {\n\t\tj = next[j]\n\t}\n\tif pattern[j+1] == pattern[i] {\n\t\tj += 1\n\t}\n\tnext[i] = j\n}\nreturn next", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar i int\nvar j int\nvar k int\nfor i = 0; i < len(a); i++ {\n\tif j < len(b) {\n\t\tif k < len(c) {\n\t\t\tif a[i] == b[j] {\n\t\t\t\tc[k] = a[i]\n\t\t\t\tk++\n\t\t\t}\n\t\t\tj++\n\t\t}\n\t}\n}\nfmt.Println(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := AllPossibleSubsequences(tc.input); !reflect.DeepEqual(result, tc.subseq) {\n\t\tt.Errorf(\"STR\", tc.subseq, result)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 3, 4, 2, 2}, 2},\n\t{\"STR\", []int{3, 1, 3, 4, 2}, 3},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := findDuplicate(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "cases := []struct {\n\tname    string\n\tinputs  []int\n\texpects bool\n}{\n\t{\"STR\", []int{1, 2, 3, 1}, true},\n\t{\"STR\", []int{1, 2, 3, 4}, false},\n\t{\"STR\", []int{1, 1, 1, 3, 3, 4, 3, 2, 4, 2}, true},\n}\nfor _, testcase := range cases {\n\tt.Run(testcase.name, func(t *testing.T) {\n\t\tresult := containsDuplicate(testcase.inputs)\n\t\tif !reflect.DeepEqual(result, testcase.expects) {\n\t\t\tt.Fatalf(\"STR\", testcase.expects, result, testcase.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "arr := randomSlice(0, 20, 10)\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\ncheckGBTPreOrder(t, gbt, arr)", "gen": "var t *binaryTree\nvar s []int\ns = randomSlice(10, 20)\nt = newGBT(s)\nvar i int\nfor i = 0; i < len(s); i++ {\n\tif t.root == nil {\n\t\tbreak\n\t}\n\tif t.root.left != nil {\n\t\tif t.root.left.value != s[i] {\n\t\t\tpanic(\"goPanicIndex\")\n\t\t}\n\t}\n\tif t.root.right != nil {\n\t\tif t.root.right.value != s[i] {\n\t\t\tpanic(\"goPanicIndex\")\n\t\t}\n\t}\n\tt.root = t.root.left\n}\nif i != len(s) {\n\tpanic(\"goPanicIndex\")\n}\nif t.root != nil {\n\tpanic(\"goPanicIndex\")\n}\n}"}
{"tgt": "fmt.Println(maxDistToClosest([]int{1, 0, 0, 0, 1, 0, 1}))\nfmt.Println(maxDistToClosest([]int{1, 0, 0, 0}))\nfmt.Println(maxDistToClosest([]int{0, 1}))\nfmt.Println(maxDistToClosest([]int{0, 1, 1, 1, 0, 0, 1, 0, 0}))\nfmt.Println(maxDistToClosest([]int{0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0}))", "gen": "fmt.Println(maxDistToClosest([]int{1, 2, 3, 4}))\nfmt.Println(maxDistToClosest([]int{1, 4, 2, 3}))\nfmt.Println(maxDistToClosest([]int{1, 1, 1, 1}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, "}
{"tgt": "iE := i.(*ltHeapElement)\njE := j.(*ltHeapElement)\nif iE == nil {\n\treturn jE\n}\nif jE == nil {\n\treturn iE\n}\nif h.Key(iE) < h.Key(jE) {\n\th.Swap(&iE, &jE)\n}\niE.right = h.merge(iE.right, jE).(*ltHeapElement)\nif iE.left == nil || iE.right.dist > iE.left.dist {\n\th.Swap(&iE.left, &iE.right)\n}\nif iE.right == nil {\n\tiE.dist = 0\n} else {\n\tiE.dist = iE.right.dist + 1\n}\nreturn iE", "gen": "var h ltHeapArray\nh.Init()\nh.Push(1)\nh.Push(2)\nh.Push(3)\nh.Push(4)\nh.Push(5)\nh.Push(6)\nh.Push(7)\nh.Push(8)\nh.Push(9)\nh.Push(10)\nh.Push(11)\nh.Push(12)\nh.Push(13)\nh.Push(14)\nh.Push(15)\nh.Push(16)\nh.Push(17)\nh.Push(18)\nh.Push(19)\nh.Push(20)\nh.Push(21)\nh.Push(22)\nh.Push(23)\nh.Push(24)\nh.Push(25)\nh.Push(26)\nh.Push(27)\nh.Push(28)\nh.Push(29)\nh.Push(30)\nh.Push(31)\nh.Push(32)\nh.Push(33)\nh.Push(34)\nh.Push(35)\nh.Push(36)\nh.Push(37)\nh.Push(38)\nh.Push(39)\nh.Push(40)\nh.Push(41)\nh.Push(42)\nh.Push(43)\nh.Push(44)\nh.Push(45)\nh.Push(46)\nh.Push(47)\nh.Push(48)\nh.Push(49)\nh.Push(50)\nh.Push(51)\nh.Push(52)\nh.Push(53)\nh.Push(54)\nh.Push(55)"}
{"tgt": "result := MakeMatrix(make([]float64, A.cols*A.rows), A.cols, A.rows)\nfor i := 0; i < A.rows; i++ {\n\tfor j := 0; j < A.cols; j++ {\n\t\tsum := float64(0)\n\t\tfor k := 0; k < A.cols; k++ {\n\t\t\tsum += A.GetElm(i, k) * B.GetElm(k, j)\n\t\t}\n\t\tresult.SetElm(i, j, sum)\n\t}\n}\nreturn result", "gen": "var a, b matrix.Matrix\na = matrix.MakeMatrix(2, 2, []float64{1, 2, 3, 4})\nb = matrix.MakeMatrix(2, 2, []float64{1, 2, 3, 4})\nc := a.Mul(&b)\nfmt.Println(c)\n}\n"}
{"tgt": "if head == nil {\n\treturn nil\n}\neven := head.Next\np, q := head, head.Next\nfor q != nil && q.Next != nil {\n\tp.Next = q.Next\n\tp = p.Next\n\tq.Next = p.Next\n\tq = q.Next\n}\np.Next = even\nreturn head", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\ta[i] = a[i] + a[i+1]\n}\nprintln(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for i := 0; i < b.N; i++ {\n\thmap.HashInsert(rand.Intn(128), i)\n}", "gen": "var a, b int\nfor i := 0; i < 128; i++ {\n\ta = rand.Intn(256)\n\tb = rand.Intn(256)\n\tc := &struct {\n\t\ta, b int\n\t}{a, b}\n\td := &struct {\n\t\ta, b int\n\t}{a, b}\n\te := &struct {\n\t\ta, b int\n\t}{a, b}\n\tf := &struct {\n\t\ta, b int\n\t}{a, b}\n\tg := &struct {\n\t\ta, b int\n\t}{a, b}\n\th := &struct {\n\t\ta, b int\n\t}{a, b}\n\ti := &struct {\n\t\ta, b int\n\t}{a, b}\n\tj := &struct {\n\t\ta, b int\n\t}{a, b}\n\tk := &struct {\n\t\ta, b int\n\t}{a, b}\n\tl := &struct {\n\t\ta, b int\n\t}{a, b}\n\tm := &struct {\n\t\ta, b int\n\t}{a, b}\n\tn := &struct {\n\t\ta, b int\n\t}{a, b}\n\to := &struct {\n\t\ta, b int\n\t}{a, b}\n\tp := &struct {\n\t\ta, b int\n\t}{a, b}\n\tq := &struct {\n\t\ta, b int\n\t}{a, b}\n\tr := &struct {\n\t\ta, b int\n\t}{a, b}\n\ts := &struct {\n\t\ta, b int\n\t}{a, b}\n\tt := &struct {\n\t\ta, b int\n\t}{a, b}\n\tu := &struct {\n\t\ta, b int"}
{"tgt": "size := len(prices)\nif size <= 1 {\n\treturn 0\n}\nprofits := []int{}\ntemp := 0\nfor i := 1; i < size; i++ {\n\tdiff := prices[i] - prices[i-1]\n\tif temp*diff >= 0 {\n\t\ttemp += diff\n\t\tcontinue\n\t}\n\tprofits = append(profits, temp)\n\ttemp = diff\n}\nprofits = append(profits, temp)\nres := 0\nfor i := 0; i < len(profits); i++ {\n\ttemp = max(profits[:i]) + max(profits[i:])\n\tif res < temp {\n\t\tres = temp\n\t}\n}\nreturn res", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\ta = append(a, i)\n}\nvar max int\nfor i := 0; i < len(a); i++ {\n\tfor j := i + 1; j < len(a); j++ {\n\t\tif a[i] > a[j] {\n\t\t\tmax = a[i]\n\t\t} else {\n\t\t\tmax = a[j]\n\t\t}\n\t\ta[i], a[j] = max, a[i]\n\t}\n}\nfmt.Println(a)\n}\n"}
{"tgt": "_a := a\n_b := b\nif a < 0 {\n\ta *= -1\n}\nif b < 0 {\n\tb *= -1\n}\nx0, y0 := 0, 1\nx1, y1 := 1, 0\nfor b != 0 {\n\tquotient := a / b\n\ta, b = b, divide(a, b)\n\tx1, x0 = x0-quotient*x1, x1\n\ty1, y0 = y0-quotient*y1, y1\n}\nif _a < 0 {\n\ty0 *= -1\n}\nif _b < 0 {\n\tx0 *= -1\n}\nreturn y0, x0", "gen": "var a, b int64\nfmt.Scan(&a, &b)\nif a < 0 {\n\ta = -a\n}\nif b < 0 {\n\tb = -b\n}\nfor a != 0 {\n\tc := a % b\n\ta = b\n\tb = c\n}\nfmt.Println(b)\n}\n"}
{"tgt": "t.Run(\"STR\", func(t *testing.T) {\n\tdata := []int{1, 1, 2}\n\tgot := removeDuplicates(data)\n\twant := 2\n\tif got != want {\n\t\tt.Error(\"STR\", got, \"STR\", want)\n\t}\n})\nt.Run(\"STR\", func(t *testing.T) {\n\tdata := []int{0, 0, 1, 1, 1, 2, 2, 3, 3, 4}\n\tgot := removeDuplicates(data)\n\twant := 5\n\tif got != want {\n\t\tt.Error(\"STR\", got, \"STR\", want)\n\t}\n})", "gen": "solution := Solution{}\ntest := testing.T{}\ntest.Run(\"TestSolution..func"}
{"tgt": "if list == nil || list.Size == 0 {\n\tfmt.Println(\"STR\")\n\treturn\n}\nlist.mutex.RLock()\ndefer list.mutex.RUnlock()\nfmt.Printf(\"STR\", list.Size)\nptr := list.Head\nvar i uint\nfor i = 0; i < list.Size; i++ {\n\tfmt.Printf(\"STR\", i+1, ptr.Data)\n\tptr = ptr.Next\n}", "gen": "var s Solution\ns.go()\n}\n"}
{"tgt": "commonChars := make([]string, 0)\nif len(A) == 0 {\n\treturn commonChars\n}\nminFrequencies := [26]int{}\nfor i := range minFrequencies {\n\tminFrequencies[i] = math.MaxInt32\n}\nfor _, word := range A {\n\tcharFrequencies := [26]int{}\n\tfor _, char := range word {\n\t\tcharFrequencies[char-\"STR\"]++\n\t}\n\tfor i := 0; i < 26; i++ {\n\t\tminFrequencies[i] = min(minFrequencies[i], charFrequencies[i])\n\t}\n}\nfor i := 0; i < 26; i++ {\n\tfor minFrequencies[i] > 0 {\n\t\tcommonChars = append(commonChars, string(rune(i)+\"STR\"))\n\t\tminFrequencies[i]--\n\t}\n}\nreturn commonChars", "gen": "var s []byte\ns = append(s, \"hello\"...)\nfmt.Println(s)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return N&1 == 0", "gen": "var a bool\na = false\nif a {\n\ta = true\n}\nfmt.Println(a)\n}\n\n// 0x0000000000000000 <main>:\n// 0:\t55                   \tpush   %rbp\n// 1:\t48 89 e5             \tmov    %rsp,%rbp\n// 4:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// 8:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// c:\t48 89 7d f0          \tmov    %rdx,-0x18(%rbp)\n// f:\t48 89 75 e8          \tmov    %rsi,-0x20(%rbp)\n// 13:\t48 89 7d e0          \tmov    %rdx,-0x28(%rbp)\n// 17:\t48 89 75 d8          \tmov    %rsi,-0x30(%rbp)\n// 1b:\t48 89 7d d0          \tmov    %rdx,-0x38(%rbp)\n// 1f:\t48 89 75 c8          \tmov    %rsi,-0x40(%rbp)\n// 23:\t48 89 7d c0          \tmov    %rdx,-0x48(%rbp)\n// 27:\t48 89 75 b8          \tmov    %rsi,-0x50(%rbp)\n// 2b:\t48 89 7d b0          \tmov    %rdx,-0x58(%rbp)\n// 2f:\t48 89 75 a8          \tmov    %rsi,-0x60(%rbp)\n// 33:\t48 89 "}
{"tgt": "var head *event\nreturn MyCalendar{head: head}", "gen": "var a int\na = 0\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var num uint32\nvar ret int\nnum = 00000000000000000000000000001011\nret = 3\nif ret != hammingWeight(num) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "fmt.Println(hammingWeight(521))\n}\n"}
{"tgt": "if head == nil || head.Next == nil {\n\treturn head\n}\nresult := head.Next\nresult.Next, head.Next = head, head.Next.Next\nresult.Next.Next = SwapEveryTwo(result.Next.Next)\nreturn result", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\ta = append(a, i)\n}\nSwapEveryTwo(a)\nfmt.Println(a)\n}"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := AreSentencesEquivalentTransitive(tc.sentence1,\n\t\ttc.sentence2, tc.thesaurus); result != tc.expectedTransitive {\n\t\tt.Errorf(\"STR\", tcid,\n\t\t\ttc.expectedTransitive, result)\n\t}\n}", "gen": "fmt.Println(\"Day 345. Go\")\nfmt.Println(\"==========================\")\nfmt.Println()\n\ntestcases := []struct {\n\tsentence1 string\n\tsentence2 string\n\texpected  bool\n}{\n\t{\"I am a student\", \"I am a student\", true},\n\t{\"I am a student\", \"I am a student.\", true},\n\t{\"I am a student.\", \"I am a student\", true},\n\t{\"I am a student.\", \"I am a student.\", true},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", true},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I am a student.\", false},\n\t{\"I am a student.\", \"I"}
{"tgt": "m := make(map[int]int)\nfor k, v := range nums {\n\tif idx, ok := m[target-v]; ok {\n\t\treturn []int{idx, k}\n\t}\n\tm[v] = k\n}\nreturn nil", "gen": "m := make(map[int][2]int)\nfor i := 0; i < 10; i++ {\n\tif _, ok := m[i]; !ok {\n\t\tm[i] = [2]int{i, i}\n\t}\n}\n}\n\n// 0000000000000000 <main>:\n// \t.file 1 \"test.go\"\n// \t.loc 1 1 0\n// \t.loc 1 1 10\n// \t.cfi_startproc\n// \t.loc 1 1 0\n// \tpushq %rbp\n// \tmovq %rsp, %rbp\n// \tsubq $152, %rsp\n// \tmovq %rdi, -168(%rbp)\n// \tmovq %rsi, -176(%rbp)\n// \tmovq $0, -160(%rbp)\n// \tmovq $0, -152(%rbp)\n// \tmovq $0, -144(%rbp)\n// \t.loc 1 1 10\n// \tcall <runtime.makemap_small@PLT>\n// \tmovq %rax, -40(%rbp)\n// \t.loc 1 1 10\n// \tmovq $0, -48(%rbp)\n// \tmovq $0, -56(%rbp)\n// \t.loc 1 1 10\n// \tmovq $0, -64(%rbp)\n// \tmovb $0, -65(%rbp)\n// \t.loc 1 1 10\n// \tmovq <16>(%rbp), %rax\n// \tmovq <24>(%rbp), %rdx\n// \tmovq %rax, -128(%rbp)\n// \tmovq %rdx, -120(%rbp)\n//"}
{"tgt": "sum := 100 * 101 / 2\nsqSum := sum * sum\nsumSq := 0\nfor i := 1; i <= 100; i++ {\n\tsumSq += i * i\n}\nfmt.Println(sqSum - sumSq)", "gen": "var a int\na = 5050\nvar b int\nb = 0\nfor i := 1; i <= 100; i++ {\n\tb += i\n}\nvar c int\nc = a * b\nvar d int\nd = 0\nfor i := 1; i <= 100; i++ {\n\td += i\n}\nvar e int\ne = c - d\nvar f int\nf = 1\nvar g int\ng = 1\nfor i := 1; i <= 100; i++ {\n\tf *= i\n}\nvar h int\nh = f\nvar i int\ni = 1\nfor i <= 100 {\n\th += i\n\ti++\n}\nvar j int\nj = 1\nfor j <= 100 {\n\tfmt.Println(j, h)\n\tj++\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if a > b {\n\treturn b\n}\nreturn a", "gen": "var a, b int\nif a < b {\n\ta = b\n}\nfmt.Println(a)\n}\n\n// 0x0000000000000000 <main>:\n// 0:\t55                   \tpush   %rbp\n// 1:\t48 89 e5             \tmov    %rsp,%rbp\n// 4:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// 8:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// c:\t48 89 c7             \tmov    %rax,%rdi\n// f:\te8 00 00 00 00       \tcallq  10 <main+0x10>\n// 14:\t48 8b 45 f0          \tmov    -0x10(%rbp),%rax\n// 18:\t48 89 c7             \tmov    %rax,%rdi\n// 1b:\te8 00 00 00 00       \tcallq  1f <main+0x1f>\n// 20:\t48 89 45 f8          \tmov    %rax,-0x8(%rbp)\n// 24:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n// 28:\t48 89 c7             \tmov    %rax,%rdi\n// 2b:\te8 00 00 00 00       \tcallq  2f <main+0x2f>\n// 30:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n// 34:\t48 89 c2             \tmov    %rax,%rdx\n// 37:\t48 8"}
{"tgt": "return this.Val", "gen": "var a [4]int\nvar b [4]int\na[0] = 1\nb[0] = 2\na[1] = 3\nb[1] = 4\na[2] = 5\nb[2] = 6\na[3] = 7\nb[3] = 8\nvar c int\nc = a[0] + a[1] + a[2] + a[3]\nc = b[0] + b[1] + b[2] + b[3]\nfmt.Println(c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "n := len(prices)\nif 0 == n || 1 == n {\n\treturn 0\n}\nvar (\n\tres      int\n\tminPrice = prices[0]\n)\nfor i := 1; i < n; i++ {\n\tif prices[i] < prices[i-1] {\n\t\tres += prices[i-1] - minPrice\n\t\tminPrice = prices[i]\n\t}\n\tif i == n-1 {\n\t\tres += prices[i] - minPrice\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b int\nfor i := 0; i < len(a); i++ {\n\tif i == 0 {\n\t\tb = a[i]\n\t} else {\n\t\tb += a[i]\n\t}\n}\nprintln(b)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "bs := []byte(s)\nvar recur func(int, int) bool\nrecur = func(l, r int) bool {\n\tfor l < r {\n\t\tif bs[l] != bs[r] {\n\t\t\treturn false\n\t\t}\n\t\tl++\n\t\tr--\n\t}\n\treturn true\n}\nfor l, r := 0, len(s)-1; l < r; l, r = l+1, r-1 {\n\tif bs[l] == bs[r] {\n\t\tcontinue\n\t}\n\treturn recur(l+1, r) || recur(l, r-1)\n}\nreturn true", "gen": "fmt.Println(validPalindrome(\"abcdcba\"))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 0,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxNumberOfBalloons(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOfBalloons(\"loonbalxballpoon\"))\nfmt.Println(maxNumberOfBalloons(\"leetcode\"))\nfmt.Println(maxNumberOfBalloons(\"nlaebolko\"))\nfmt.Println(maxNumberOf"}
{"tgt": "tests := [...]testType{\n\t{\n\t\twords: []string{\"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  true,\n\t},\n\t{\n\t\twords: []string{\"STR\", \"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  false,\n\t},\n\t{\n\t\twords: []string{\"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := isAlienSorted(tt.words, tt.order)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.words, got, tt.want)\n\t}\n}", "gen": "fmt.Println(isAlienSorted(\"abc\", \"abd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\nfmt.Println(isAlienSorted(\"abc\", \"abcd\"))\n"}
{"tgt": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 1, 3}},\n\t\tans1051{3},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 2, 3, 4}},\n\t\tans1051{5},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{0},\n\t},\n\t{\n\t\tpara1051{[]int{5, 4, 3, 2, 1}},\n\t\tans1051{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "i := 1\ntmp := 0\nfor i < len(arr) {\n\tif arr[i] >= arr[i-1] {\n\t\ti++\n\t} else {\n\t\ttmp = arr[i]\n\t\tarr[i] = arr[i-1]\n\t\tarr[i-1] = tmp\n\t\tif i > 1 {\n\t\t\ti--\n\t\t}\n\t}\n}", "gen": "var a [3]int\nvar b [3]int\nfor i := 0; i < 3; i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < 3; i++ {\n\ta[i] = a[i] + b[i]\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if maxSize > 0 {\n\tstack := &Stack{}\n\tstack.top = nil\n\tstack.size = 0\n\tstack.maxSize = maxSize\n\treturn stack\n}\nreturn nil", "gen": "var s Stack\ns.a = 1\ns.b = 2\ns.c = 3\nprintln(s.a, s.b, s.c)\n}\n"}
{"tgt": "b, _ := ioutil.ReadFile(\"STR\")\ns := strings.Replace(string(b), \"STR\", \"STR\", -1)\nnumData := strings.Split(s, \"STR\")\nfor _, n := range numData {\n\tnumber, err := strconv.Atoi(n)\n\tif err == nil {\n\t\tdata = append(data, number)\n\t}\n}", "gen": "var data []int\nvar err error\ndata, err = ioutil.ReadFile(\"input.txt\")\nif err != nil {\n\tpanic(err)\n}\nvar sum int\nfor _, v := range strings.Split(strings.Replace(string(data), \"\\n\", \"\", -1), \" \") {\n\ti, _ := strconv.Atoi(v)\n\tsum += i\n}\nfmt.Println(sum)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nc, res := []int{}, [][]int{}\nsort.Ints(candidates)\nfindcombinationSum(candidates, target, 0, c, &res)\nreturn res", "gen": "nums := []int{2, 3, 6, 7}\ntarget := 7\ncombinationSum(nums, target)\n}\n"}
{"tgt": "qs := []question786{\n\t{\n\t\tpara786{[]int{1, 2, 3, 5}, 3},\n\t\tans786{[]int{2, 5}},\n\t},\n\t{\n\t\tpara786{[]int{1, 7}, 1},\n\t\tans786{[]int{1, 7}},\n\t},\n\t{\n\t\tpara786{[]int{1, 2}, 1},\n\t\tans786{[]int{1, 2}},\n\t},\n\t{\n\t\tpara786{[]int{1, 2, 3, 5, 7}, 6},\n\t\tans786{[]int{3, 7}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans786, q.para786\n\tfmt.Printf(\"STR\", p, kthSmallestPrimeFraction(p.A, p.K))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(kthSmallestPrimeFraction([]int{2, 3, 5}, 3))\n}\n"}
{"tgt": "errObj := appError{\n\tError:      handlerError.Error(),\n\tMessage:    message,\n\tHTTPStatus: code,\n}\nError.Printf(\"STR\", handlerError)\nw.Header().Set(\"STR\", \"STR\")\nw.WriteHeader(code)\nif j, err := json.Marshal(errorResource{Data: errObj}); err == nil {\n\tw.Write(j)\n}", "gen": "var a, b, c int\nvar d, e, f float64\nvar g, h, i string\nvar j, k, l bool\nvar m, n, o []int\nvar p, q, r []string\nvar s, t, u []float64\nvar v, w, x, y, z int\nvar aa, bb, cc, dd, ee, ff, gg, hh, ii, jj, kk, ll, mm, nn, oo, pp, qq, rr, ss, tt, uu, vv, ww, xx, yy, zz int\nvar aaa, bbb, ccc, ddd, eee, fff, ggg, hhh, iii, jjj, kkk, lll, mmm, nnn, ooo, ppp, qqq, rrr, sss, ttt, uuu, vvv, www, xxx, yyy, zzz int\nvar aaaa, bbbb, cccc, dddd, eeee, ffff, gggg, hhhh, iiii, jjjj, kkkk, llll, mmmm, nnnn, oooo, pppp, qqqq, rrrr, ssss, tttt, uuuu, vvvv, wwww, xxxx, yyyy, zzzz int\nvar aaaa, bbbb, cccc, dddd, eeee, ffff, gggg, hhhh, iiii, jjjj, kkkk, llll, mmmm, nnnn, oooo, pppp, qqqq, rrrr, ssss, tttt, uuuu, vvvv, wwww, xxxx, yyyy, zzzz int\nvar aaaa, bbbb, cccc, dddd, eeee, ffff, gggg, hhhh, iiii, jjjj, kkkk, llll, mmmm, nnnn"}
{"tgt": "if len(strs) == 0 {\n\treturn nil\n}\nr := make(map[string][]string)\nfor _, str := range strs {\n\tcount := make([]int, 26)\n\tfor _, b := range []byte(str) {\n\t\tcount[b-'a']++\n\t}\n\tbs := make([]byte, 26*2)\n\tfor i, c := range count {\n\t\tbs[2*i] = '#'\n\t\tbs[2*i+1] = byte(c) + '0'\n\t}\n\tkey := string(bs)\n\tr[key] = append(r[key], str)\n}\nres := make([][]string, len(r))\ni := 0\nfor _, l := range r {\n\tres[i] = l\n\ti++\n}\nreturn res", "gen": "var m map[string]string\nm = make(map[string]string)\nm[\"a\"] = \"1\"\nm[\"b\"] = \"2\"\nm[\"c\"] = \"3\"\nvar s string\ns = m[\"a\"]\nfmt.Println(s)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "type Address struct {\n\tCountry string  `json:\"STR\"`\n\tPerson  *Person `json:\"STR\"`\n}\nperson := &Person{\n\tName: \"STR\",\n\tAge:  23,\n}\naddress := &Address{\n\tCountry: \"STR\",\n\tPerson:  person,\n}\ndefer func() {\n\terr := recover()\n\tif err != nil {\n\t\tfmt.Printf(\"STR\", err)\n\t\tt.Error(\"STR\")\n\t}\n}()\ns := New(address)\ns.TagName = \"STR\"\nm := s.Map()\nif m[\"STR\"] != person.String() {\n\tt.Errorf(\"STR\", person.String(), m[\"STR\"])\n}\nvs := s.Values()\nif vs[1] != person.String() {\n\tt.Errorf(\"STR\", person.String(), vs[1])\n}", "gen": "p := Person{\n\tName: \"Joe\",\n\tAge:  23,\n}\np.Map()\n}\n"}
{"tgt": "if parser.tokens_head > 0 && len(parser.tokens) == cap(parser.tokens) {\n\tif parser.tokens_head != len(parser.tokens) {\n\t\tcopy(parser.tokens, parser.tokens[parser.tokens_head:])\n\t}\n\tparser.tokens = parser.tokens[:len(parser.tokens)-parser.tokens_head]\n\tparser.tokens_head = 0\n}\nparser.tokens = append(parser.tokens, *token)\nif pos < 0 {\n\treturn\n}\ncopy(parser.tokens[parser.tokens_head+pos+1:], parser.tokens[parser.tokens_head+pos:])\nparser.tokens[parser.tokens_head+pos] = *token", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar bb [10]int\nvar cc [10]int\nvar dd [10]int\nvar ee [10]int\nvar ff [10]int\nvar gg [10]int\nvar hh [10]int\nvar ii [10]int\nvar jj [10]int\nvar kk [10]int\nvar ll [10]int\nvar mm [10]int\nvar nn [10]int\nvar oo [10]int\nvar pp [10]int\nvar qq [10]int\nvar rr [10]int\nvar ss [10]int\nvar tt [10]int\nvar uu [10]int\nvar vv [10]int\nvar ww [10]int\nvar xx [10]int\nvar yy [10]int\nvar zz [10]int\nvar aaa [10]int\nvar bbb [10]"}
{"tgt": "str := \"STR\"\nfmt.Println(longestPalindrome(str))", "gen": "fmt.Println(longestPalindrome(\"abcd\"))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   5,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   0,\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   1,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   2,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   13,\n\t\twant: 4,\n\t},\n\t{\n\t\tin:   130,\n\t\twant: 15,\n\t},\n}\nfor _, tt := range tests {\n\tgot := arrangeCoins(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "arrangeCoins(5)\n}\n"}
{"tgt": "return WordDictionary{}", "gen": "var a [27]int\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 4\na[4] = 5\na[5] = 6\na[6] = 7\na[7] = 8\na[8] = 9\na[9] = 10\na[10] = 11\na[11] = 12\na[12] = 13\na[13] = 14\na[14] = 15\na[15] = 16\na[16] = 17\na[17] = 18\na[18] = 19\na[19] = 20\na[20] = 21\na[21] = 22\na[22] = 23\na[23] = 24\na[24] = 25\na[25] = 26\na[26] = 27\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "tcs := []struct {\n\ts   string\n\tans bool\n}{\n\t{\n\t\t\"STR\",\n\t\tfalse,\n\t},\n\t{\n\t\t\"STR\",\n\t\ttrue,\n\t},\n\t{\n\t\t\"STR\",\n\t\tfalse,\n\t},\n\t{\n\t\t\"STR\",\n\t\ttrue,\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, tc := range tcs {\n\tfmt.Printf(\"STR\", tc, isPalindrome(tc.s))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Please enter a string:\")\nvar s string\nfmt.Scanf(\"%s\", &s)\nfmt.Println(isPalindrome(s))\n}\n"}
{"tgt": "var drinks []Drink\ninverted := make(map[Drink][]Customer)\nfor cust, favorites := range prefs {\n\tfor _, drink := range favorites {\n\t\tinverted[drink] = append(inverted[drink], cust)\n\t}\n}\ntotalCustomers := len(prefs)\nserved := make(map[Customer]struct{}, totalCustomers)\nfor len(served) < totalCustomers {\n\tvar largest []Customer\n\tvar largestDrink Drink\n\tvar largestIncrease int\n\tfor drink, custs := range inverted {\n\t\tvar newlyServed int\n\t\tfor _, cust := range custs {\n\t\t\tif _, found := served[cust]; !found {\n\t\t\t\tnewlyServed++\n\t\t\t}\n\t\t}\n\t\tif newlyServed > largestIncrease {\n\t\t\tlargestIncrease = newlyServed\n\t\t\tlargestDrink = drink\n\t\t\tlargest = custs\n\t\t}\n\t}\n\tdelete(inverted, largestDrink)\n\tdrinks = append(drinks, largestDrink)\n\tfor _, cust := range largest {\n\t\tserved[cust] = struct{}{}\n\t}\n}\nsort.Slice(drinks, func(i, j int) bool {\n\treturn drinks[i] < drinks[j]\n})\nreturn drinks", "gen": "var c Customer\nvar d Drink\nvar b Bartender\nc.Name = \"John\"\nc.Age = 20\nc.Drinks = make(map[Drink]Customer)\nd.Name = \"Beer\"\nd.Price = 10\nd.Quantity = 10\nc.Drinks[d] = c\nb.Drinks = make(map[Drink]Customer)\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d] = c\nb.Drinks[d]"}
{"tgt": "wg.Add(2)\ngoincCounter(1)\ngoincCounter(2)\nwg.Wait()\nfmt.Println(\"STR\", counter)", "gen": "var wg sync.WaitGroup\nwg.Add(2)\ngo func() {\n\tcounter := 0\n\tfmt.Println(counter)\n\twg.Done()\n}()\ngo func() {\n\tcounter := 0\n\tfmt.Println(counter)\n\twg.Done()\n}()\nwg.Wait()\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{{-1, 2, 1, -4}, {1}}, 2},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tret := threeSumClosest(c.inputs[0], c.inputs[1][0])\n\t\tif !reflect.DeepEqual(ret, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, ret, c.inputs)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 2}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello, world\")\n}\n"}
{"tgt": "sort.Slice(words, func(i, j int) bool {\n\tcuri := len(words[i])\n\tcurj := len(words[j])\n\tfor curi > 0 && curj > 0 {\n\t\tcuri--\n\t\tcurj--\n\t\tif words[i][curi] == words[j][curj] {\n\t\t\tcontinue\n\t\t}\n\t\tif words[i][curi] > words[j][curj] {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\treturn curi == 0\n})\nwords = append(words, \"STR\")\nres, i := 0, 1\nfor ; i < len(words); i++ {\n\tif !endWith(words[i], words[i-1]) {\n\t\tres += len(words[i-1]) + 1\n\t}\n}\nreturn res", "gen": "fmt.Println(minimumLengthEncoding(\"a\"))\nfmt.Println(minimumLengthEncoding(\"aa\"))\nfmt.Println(minimumLengthEncoding(\"aaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"))\nfmt.Println(minimumLengthEncoding"}
{"tgt": "fmt.Println(badLongestPalindrome(\"STR\"))\nfmt.Println(goodLongestPalindrome(\"STR\"))\nfmt.Println(bestLongestPalindrome(\"STR\"))", "gen": "badLongestPalindrome()\ngoodLongestPalindrome()\nbestLongestPalindrome()\n}\n"}
{"tgt": "for i := 0; i < len(A)-1; i++ {\n\tif A[i] == i {\n\t\tcontinue\n\t}\n\tif A[i] == i+1 && A[i+1] == i {\n\t\ti++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\ta[i] = i\n}\nfor i = 0; i < 10; i++ {\n\tif a[i] != i {\n\t\tpanic(\"a[i] != i\")\n\t}\n}\nfor i = 9; i >= 0; i-- {\n\tif a[i] != i {\n\t\tpanic(\"a[i] != i\")\n\t}\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "hash := uint32(0)\nfor i := len(sep) - 1; i >= 0; i-- {\n\thash = hash*PrimeRK + uint32(sep[i])\n}\nvar pow, sq uint32 = 1, PrimeRK\nfor i := len(sep); i > 0; i >>= 1 {\n\tif i&1 != 0 {\n\t\tpow *= sq\n\t}\n\tsq *= sq\n}\nreturn hash, pow", "gen": "var a [10]int\nvar b int\nfor i := 0; i < len(a); i++ {\n\tb += a[i]\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif sum := SumBSTRange(tc.root, tc.a, tc.b); sum != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, sum)\n\t}\n}", "gen": "fmt.Println(SumBSTRange(tree.New(1), 1, 2))\nfmt.Println(SumBSTRange(tree.New(1), 1, 3))\nfmt.Println(SumBSTRange(tree.New(1), 1, 4))\nfmt.Println(SumBSTRange(tree.New(1), 1, 5))\nfmt.Println(SumBSTRange(tree.New(1), 1, 6))\nfmt.Println(SumBSTRange(tree.New(1), 1, 7))\nfmt.Println(SumBSTRange(tree.New(1), 1, 8))\nfmt.Println(SumBSTRange(tree.New(1), 1, 9))\nfmt.Println(SumBSTRange(tree.New(1), 1, 10))\nfmt.Println(SumBSTRange(tree.New(1), 1, 11))\nfmt.Println(SumBSTRange(tree.New(1), 1, 12))\nfmt.Println(SumBSTRange(tree.New(1), 1, 13))\nfmt.Println(SumBSTRange(tree.New(1), 1, 14))\nfmt.Println(SumBSTRange(tree.New(1), 1, 15))\nfmt.Println(SumBSTRange(tree.New(1), 1, 16))\nfmt.Println(SumBSTRange(tree.New(1), 1, 17))\nfmt.Println(SumBSTRange(tree.New(1), 1, 18))\nfmt.Println(SumBSTRange(tree.New(1), 1, 19))\nfmt.Println(SumBSTRange(tree.New(1), 1, 20))\nfmt.Println(SumBSTRange(tree.New(1), 1, 21))\nfmt.Println(SumB"}
{"tgt": "arr := make([]bool, 105000)\narr[0], arr[1] = true, true\ncount, prime := 2, 3\nvar k int\nfor {\n\tfor k = 2 * prime; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tcount++\n\t\tif count == 10001 {\n\t\t\tprintln(prime)\n\t\t\tbreak\n\t\t}\n\t} else {\n\t\tbreak\n\t}\n}", "gen": "var a [105000]bool\nfor i := 0; i < 105000; i++ {\n\ta[i] = true\n\ta[i+1] = false\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = true\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = false\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = true\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = false\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = true\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = false\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = true\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = false\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\t"}
{"tgt": "n1, n2 := len(nums1), len(nums2)\nif n1 > n2 {\n\tn1, n2, nums1, nums2 = n2, n1, nums2, nums1\n}\nm := make(map[int]int, n1)\nfor _, num := range nums1 {\n\tm[num]++\n}\nres := make([]int, 0, n1)\nfor _, num := range nums2 {\n\tif v, ok := m[num]; ok && v > 0 {\n\t\tres = append(res, num)\n\t\tm[num]--\n\t}\n}\nreturn res", "gen": "var a [2]int\nvar b [2]int\nvar c [2]int\nvar d [2]int\nvar e [2]int\nvar f [2]int\nvar g [2]int\nvar h [2]int\nvar i [2]int\nvar j [2]int\nvar k [2]int\nvar l [2]int\nvar m [2]int\nvar n [2]int\nvar o [2]int\nvar p [2]int\nvar q [2]int\nvar r [2]int\nvar s [2]int\nvar t [2]int\nvar u [2]int\nvar v [2]int\nvar w [2]int\nvar x [2]int\nvar y [2]int\nvar z [2]int\nvar aa [2]int\nvar ab [2]int\nvar ac [2]int\nvar ad [2]int\nvar ae [2]int\nvar af [2]int\nvar ag [2]int\nvar ah [2]int\nvar ai [2]int\nvar aj [2]int\nvar ak [2]int\nvar al [2]int\nvar am [2]int\nvar an [2]int\nvar ao [2]int\nvar ap [2]int\nvar aq [2]int\nvar ar [2]int\nvar as [2]int\nvar at [2]int\nvar au [2]int\nvar av [2]int\nvar aw [2]int\nvar ax [2]int\nvar ay [2]int\nvar az [2]int\nvar aaa [2]int\nvar aab [2]int\nvar aac [2]int\nvar aad [2]int\nvar aae [2]int\nvar aaf [2]int\nvar aag [2]int\nvar aah [2]int\nvar aai [2]int\n"}
{"tgt": "if root == nil {\n\treturn nil\n}\ns := []*TreeNode{root}\nres := [][]int{}\nzigzag := false\nfor len(s) != 0 {\n\ttmp := []*TreeNode{}\n\tl := []int{}\n\tfor i, node := range s {\n\t\tif zigzag {\n\t\t\tl = append(l, s[len(s)-i-1].Val)\n\t\t} else {\n\t\t\tl = append(l, node.Val)\n\t\t}\n\t\tif node.Left != nil {\n\t\t\ttmp = append(tmp, node.Left)\n\t\t}\n\t\tif node.Right != nil {\n\t\t\ttmp = append(tmp, node.Right)\n\t\t}\n\t}\n\tres = append(res, l)\n\ts = tmp\n\tzigzag = !zigzag\n}\nreturn res", "gen": "fmt.Println(maxDepth(nil))\nfmt.Println(maxDepth(treeNode{Val: 3, Left: &treeNode{Val: 9}}))\nfmt.Println(maxDepth(treeNode{Val: 1, Left: &treeNode{Val: 2, Left: &treeNode{Val: 3, Left: &treeNode{Val: 4, Left: &treeNode{Val: 5, Left: &treeNode{Val: 6, Left: &treeNode{Val: 7, Left: &treeNode{Val: 8, Left: &treeNode{Val: 9}}}}}}}}))\n}\n"}
{"tgt": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)", "gen": "var a int\nvar b int\nfor {\n\tif isL(a, b) {\n\t\ta++\n\t} else {\n\t\tb++\n\t}\n\tif b > 9999 {\n\t\tbreak\n\t}\n}\nfmt.Println(a, b)\n}"}
{"tgt": "if len(str) == 0 {\n\treturn 0\n}\nvar (\n\tnum int\n\tneg bool\n)\nfor i, s := range str {\n\tif s != ' ' {\n\t\tstr = str[i:]\n\t\tbreak\n\t}\n}\nif str[0] == '+' {\n\tstr = str[1:]\n} else if str[0] == '-' {\n\tstr = str[1:]\n\tneg = true\n}\nfor _, s := range str {\n\tif s < '0' || s > '9' {\n\t\tbreak\n\t}\n\tnum = num*10 + int(s-'0')\n\tif num > 2147483648 {\n\t\tnum = 2147483648\n\t\tbreak\n\t}\n}\nif neg {\n\tnum *= -1\n} else if num > 2147483647 {\n\tnum = 2147483647\n}\nreturn num", "gen": "var s []byte\nvar i int\nfor {\n\tif len(s) == 0 {\n\t\tbreak\n\t}\n\ti = 0\n\tfor {\n\t\tif i >= len(s) {\n\t\t\tbreak\n\t\t}\n\t\tif s[i] == 43 {\n\t\t\tbreak\n\t\t}\n\t\tif s[i] == 45 {\n\t\t\tbreak\n\t\t}\n\t\ti++\n\t}\n\tif i >= len(s) {\n\t\tbreak\n\t}\n\tif s[i] == 43 {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == 45 {\n\t\ti++\n\t\tcontinue\n\t}\n\tvar j int\n\tfor {\n\t\tif j >= len(s) {\n\t\t\tbreak\n\t\t}\n\t\tif s[j] == 43 {\n\t\t\tbreak\n\t\t}\n\t\tif s[j] == 45 {\n\t\t\tbreak\n\t\t}\n\t\tj++\n\t}\n\tif j >= len(s) {\n\t\tbreak\n\t}\n\tif s[j] == 43 {\n\t\tj++\n\t\tcontinue\n\t}\n\tif s[j] == 45 {\n\t\tj++\n\t\tcontinue\n\t}\n\tvar k int\n\tfor {\n\t\tif k >= len(s) {\n\t\t\tbreak\n\t\t}\n\t\tif s[k] == 43 {\n\t\t\tbreak\n\t\t}\n\t\tif s[k] == 45 {\n\t\t\tbreak\n\t\t}\n\t\tk++\n\t}\n\tif k >= len(s) {\n\t\tbreak\n\t}\n\tif s[k] == "}
{"tgt": "ans, m, n := []int{}, len(matrix), len(matrix[0])\nfor j := 0; j < n; j++ {\n\tmax, rowIndex := 1, 0\n\tfor i := 0; i < m; i++ {\n\t\tif matrix[i][j] > max {\n\t\t\tmax = matrix[i][j]\n\t\t\trowIndex = i\n\t\t}\n\t}\n\tif Min(matrix[rowIndex]) == max {\n\t\tans = append(ans, max)\n\t}\n}\nreturn ans", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar b = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar c = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar d = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar e = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar f = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar g = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar h = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar i = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar j = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar k = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar m = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar n = []int"}
{"tgt": "strNumber := strconv.Itoa(number)\nfor _, runeDigit := range []rune(strNumber) {\n\tdigit := int(runeDigit - '0')\n\tlist = append(list, digit)\n}\nreturn", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar"}
{"tgt": "if num == 0 {\n\treturn \"STR\"\n}\nh := []string{\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\",\n\t\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\"}\nres := \"STR\"\nfor i := 0; i < 8 && num != 0; i++ {\n\tres = h[num&15] + res\n\tnum >>= 4\n}\nreturn res", "gen": "var s string\nfor i := 0; i < 8; i++ {\n\ts += fmt.Sprintf(\"%d\", i)\n}\nfmt.Println(s)\n}\n\n// Output:\n// 01234567\n\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```\n.LFB0:\nleaq -408(%rsp),%r11\ncmpq %fs:112,%r11\njnb .L14\nmovl $408,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L14:\npushq %rbp\nmovq %rsp,%rbp\npushq %rbx\nsubq $392,%rsp\nmovq %rdi,-392(%rbp)\nmovq $0,-336(%rbp)\nmovq $0,-328(%rbp)\n.LBB2:\n.LBB3:\ncmpq $0,-392(%rbp)\njne .L2\n.LBB4:\n.LBB5:\nleaq <.LC0>(%rip),%rcx\nmovl $1,%ebx\nmovq %rcx,-336(%rbp)\nmovq %rbx,-328(%rbp)\nmovq -336(%rbp),%rax\nmovq -328(%rbp),%rdx\njmp .L10\n.L2:\n.LBE5:\n.LBE4:\n.LBE3:\nleaq <.LC0>(%rip),%rcx\nmovq %rcx,-320(%rbp)\nmovq $1,-312(%rbp)\nleaq <.LC1>(%rip),%rcx\nmovq %rcx,-304(%rbp)\nmovq $1,-296(%"}
{"tgt": "if len(n.Exprs) == 0 {\n\treturn TypeString, nil\n}\nif len(n.Exprs) == 1 {\n\texprType, err := n.Exprs[0].Type(s)\n\tif err != nil {\n\t\treturn TypeInvalid, err\n\t}\n\tswitch exprType {\n\tcase TypeList:\n\t\treturn TypeList, nil\n\tcase TypeMap:\n\t\treturn TypeMap, nil\n\t}\n}\nfor index, expr := range n.Exprs {\n\texprType, err := expr.Type(s)\n\tif err != nil {\n\t\treturn TypeInvalid, err\n\t}\n\tif exprType == TypeList || exprType == TypeMap {\n\t\treturn TypeInvalid, fmt.Errorf(\n\t\t\t\"STR\",\n\t\t\tindex, exprType)\n\t}\n}\nreturn TypeString, nil", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\na[0] = 1\nb[0] = 2\nc[0] = 3\na[1] = 4\nb[1] = 5\nc[1] = 6\na[2] = 7\nb[2] = 8\nc[2] = 9\nfmt.Println(a[0], b[0], c[0])\nfmt.Println(a[1], b[1], c[1])\nfmt.Println(a[2], b[2], c[2])\nfmt.Println(a[0], b[0], c[0])\nfmt.Println(a[1], b[1], c[1])\nfmt.Println(a[2], b[2], c[2])\nfmt.Println(a[0], b[0], c[0])\nfmt.Println(a[1], b[1], c[1])\nfmt.Println(a[2], b[2], c[2])\nfmt.Println(a[0], b[0], c[0])\nfmt.Println(a[1], b[1], c[1])\nfmt.Println(a[2], b[2], c[2])\nfmt.Println(a[0], b[0], c[0])\nfmt.Println(a[1], b[1], c[1])\nfmt.Println(a[2], b[2], c[2])\nfmt.Println(a[0], b[0], c[0])\nfmt.Println(a[1], b[1], c[1])\nfmt.Println(a[2], b[2], c[2])\nfmt.Println(a[0], b[0], c[0])\nfmt.Println(a[1], b[1], c[1])\nfmt.Println(a[2], b[2], c"}
{"tgt": "psum, min := 0, 1\nfor _, val := range nums {\n\tpsum += val\n\tif psum < min {\n\t\tmin = psum\n\t}\n}\nif min > 0 {\n\treturn min\n}\nreturn -min + 1", "gen": "var a [3]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i\n}\nfmt.Println(a[i])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "arr := make([]bool, 2000000)\narr[0], arr[1] = true, true\nsum, prime := int64(5), 3\nvar k int\nfor {\n\tfor k = 2 * prime; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tsum += int64(k)\n\t} else {\n\t\tbreak\n\t}\n}\nprintln(sum)", "gen": "var a [2000000]byte\na[2000000] = 1\na[1] = 1\nfor i := 0; i < 5; i++ {\n\ta[i] = 1\n\ta[i+1] = 1\n}\nfor i := 0; i < 2000000; i++ {\n\tif i >= 1 {\n\t\tif i >= 2000000 {\n\t\t\tpanic(i)\n\t\t}\n\t\tpanic(i)\n\t}\n\ta[i] = 1\n\ta[i+1] = 1\n}\nfor i := 0; i < 2000000; i++ {\n\tif i >= 1 {\n\t\tif i >= 2000000 {\n\t\t\tpanic(i)\n\t\t}\n\t\tpanic(i)\n\t}\n\ta[i] = 1\n\ta[i+1] = 1\n}\nfor i := 0; i < 2000000; i++ {\n\tif i >= 1 {\n\t\tif i >= 2000000 {\n\t\t\tpanic(i)\n\t\t}\n\t\tpanic(i)\n\t}\n\ta[i] = 1\n\ta[i+1] = 1\n}\nfor i := 0; i < 2000000; i++ {\n\tif i >= 1 {\n\t\tif i >= 2000000 {\n\t\t\tpanic(i)\n\t\t}\n\t\tpanic(i)\n\t}\n\ta[i] = 1\n\ta[i+1] = 1\n}\nfor i := 0; i < 2000000; i++ {"}
{"tgt": "qs := []question693{\n\t{\n\t\tpara693{5},\n\t\tans693{true},\n\t},\n\t{\n\t\tpara693{7},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{11},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{10},\n\t\tans693{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans693, q.para693\n\tfmt.Printf(\"STR\", p, hasAlternatingBits(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(hasAlternatingBits(5))\nfmt.Println(hasAlternatingBits(7))\nfmt.Println(hasAlternatingBits(11))\nfmt.Println(hasAlternatingBits(10))\nfmt.Println(hasAlternatingBits(1))\nfmt.Println(hasAlternatingBits(2))\nfmt.Println(hasAlternatingBits(3))\nfmt.Println(hasAlternatingBits(4))\nfmt.Println(hasAlternatingBits(6))\nfmt.Println(hasAlternatingBits(8))\nfmt.Println(hasAlternatingBits(9))\nfmt.Println(hasAlternatingBits(10))\nfmt.Println(hasAlternatingBits(11))\nfmt.Println(hasAlternatingBits(12))\nfmt.Println(hasAlternatingBits(13))\nfmt.Println(hasAlternatingBits(14))\nfmt.Println(hasAlternatingBits(15))\nfmt.Println(hasAlternatingBits(16))\nfmt.Println(hasAlternatingBits(17))\nfmt.Println(hasAlternatingBits(18))\nfmt.Println(hasAlternatingBits(19))\nfmt.Println(hasAlternatingBits(20))\nfmt.Println(hasAlternatingBits(21))\nfmt.Println(hasAlternatingBits(22))\nfmt.Println(hasAlternatingBits(23))\nfmt.Println(hasAlternatingBits(24))\nfmt.Println(hasAlternatingBits(25))\nfmt.Println(hasAlternatingBits(26))\nfmt.Println(hasAlternatingBits(27))\nfmt.Println(hasAlternatingBits(28))"}
{"tgt": "sum := 0\nfor i := 1; i <= n; i++ {\n\tsquare := i * i\n\tsum += square\n}\nreturn sum", "gen": "var a int\nfor i := 0; i < 10; i++ {\n\ta += i\n}\nfmt.Println(a)\n}\n\n// 105\n// 0000000000000000 <main>:\n// 0:\t55                   \tpush   %rbp\n// 1:\t48 89 e5             \tmov    %rsp,%rbp\n// 4:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// 8:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// c:\t48 89 7d f0          \tmov    %rdx,-0x18(%rbp)\n// f:\t48 89 75 e8          \tmov    %rsi,-0x20(%rbp)\n// 13:\t48 89 7d e0          \tmov    %rdx,-0x28(%rbp)\n// 17:\t48 89 75 d8          \tmov    %rsi,-0x30(%rbp)\n// 1b:\t48 89 7d d0          \tmov    %rdx,-0x38(%rbp)\n// 1f:\t48 89 75 c8          \tmov    %rsi,-0x40(%rbp)\n// 23:\t48 89 7d c0          \tmov    %rdx,-0x48(%rbp)\n// 27:\t48 89 75 b8          \tmov    %rsi,-0x50(%rbp)\n// 2b:\t48 89 7d b0          \tmov    %rdx,-0x58(%rbp)\n// 2f:\t48 89 75 a8          \tmov    %rsi,-0x60(%rbp)\n//"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.nums); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "var i int\nfor j, k := 0, 0; j < len(nums); j = k {\n\tfor k < len(nums) && nums[j] == nums[k] {\n\t\tif k < j+2 {\n\t\t\tnums[i] = nums[k]\n\t\t\ti++\n\t\t}\n\t\tk++\n\t}\n}\nreturn i", "gen": "var a [10]int\nvar i int\nvar j int\nfor i = 0; i < 10; i++ {\n\tfor j = 0; j < 10; j++ {\n\t\ta[i] = a[j]\n\t}\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "result := make([]int, 0, len(left)+len(right))\nfor len(left) > 0 || len(right) > 0 {\n\tif len(left) == 0 {\n\t\treturn append(result, right...)\n\t}\n\tif len(right) == 0 {\n\t\treturn append(result, left...)\n\t}\n\tif left[0] <= right[0] {\n\t\tresult = append(result, left[0])\n\t\tleft = left[1:]\n\t} else {\n\t\tresult = append(result, right[0])\n\t\tright = right[1:]\n\t}\n}\nreturn result", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "if 0 == n {\n\treturn 0\n} else {\n\treturn n/5 + trailingZeroes(n/5)\n}", "gen": "fmt.Println(trailingZeroes(100))\n}\n"}
{"tgt": "n := len(s)\nuf := newUnionFind(n)\nfor _, p := range pairs {\n\tuf.connect(p[0], p[1])\n}\ngroups := make(map[int][]int, n)\nfor c, p := range uf.parent {\n\tp = uf.find(p)\n\tgroups[p] = append(groups[p], c)\n}\nbytes := []byte(s)\nres := make([]byte, n)\nfor _, g := range groups {\n\tsize := len(g)\n\ta := make([]int, size)\n\tcopy(a, g)\n\tsort.Slice(a, func(i, j int) bool {\n\t\treturn bytes[a[i]] < bytes[a[j]]\n\t})\n\tsort.Ints(g)\n\tfor i := 0; i < size; i++ {\n\t\tres[g[i]] = bytes[a[i]]\n\t}\n}\nreturn string(res)", "gen": "var n, k int\nfmt.Scan(&n, &k)\ns := make([]byte, n)\nfor i := 0; i < n; i++ {\n\tfmt.Scan(&s[i])\n}\nuf := newUnionFind(n)\nfor i := 0; i < n-1; i++ {\n\tuf.connect(s[i]-'a', s[i+1]-'a')\n}\nfor i := 0; i < k; i++ {\n\tuf.unionFind(s[i]-'a', s[i+1]-'a')\n}\nfor i := 0; i < n; i++ {\n\tuf.find(s[i]-'a')\n}\nfmt.Println(string(s))\n}\n"}
{"tgt": "data := [][]int{\n\t{2},\n\t{3, 4},\n\t{6, 5, 7},\n\t{4, 1, 8, 3}}\nfmt.Println(minimumTotal(data))", "gen": "var a = [][]int{\n\t{2},\n\t{3, 4},\n\t{6, 5, 7},\n\t{4, 1, 8, 3},\n}\nfmt.Println(minimumTotal(a))\n}\n"}
{"tgt": "left, right, res := 0, -1, 0\nfor left < len(s) {\n\tif right+1 < len(s) && maxCost-abs(int(s[right+1]-'a')-int(t[right+1]-'a')) >= 0 {\n\t\tright++\n\t\tmaxCost -= abs(int(s[right]-'a') - int(t[right]-'a'))\n\t} else {\n\t\tres = max(res, right-left+1)\n\t\tmaxCost += abs(int(s[left]-'a') - int(t[left]-'a'))\n\t\tleft++\n\t}\n}\nreturn res", "gen": "fmt.Println(maxVowels(\"aeiouuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu"}
{"tgt": "nums := []int{}\nfor n != 0 {\n\tnums = append(nums, n%10)\n\tn /= 10\n}\nm := len(nums)\nif m < 2 {\n\treturn -1\n}\ni := 1\nfor i < m {\n\tif nums[i] < nums[i-1] {\n\t\tbreak\n\t}\n\ti++\n}\nif i == m {\n\treturn -1\n}\nj := 0\nfor j < i {\n\tif nums[j] > nums[i] {\n\t\tbreak\n\t}\n\tj++\n}\nnums[i], nums[j] = nums[j], nums[i]\nfor k := 0; k < i/2; k++ {\n\tnums[k], nums[i-k-1] = nums[i-k-1], nums[k]\n}\nres := 0\np := 1\nfor _, n := range nums {\n\tres += n * p\n\tp *= 10\n}\nif res > math.MaxInt32 {\n\treturn -1\n}\nreturn res", "gen": "var a [7]int\nvar i int\nfor i = 0; i < 7; i++ {\n\ta[i] = i\n}\nvar j int\nfor j = 0; j < len(a); j++ {\n\tif a[j] > a[j+1] {\n\t\ta[j], a[j+1] = a[j+1], a[j]\n\t}\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "x := []int{10, 20, 30, 40, 50}\nfor k, v := range x {\n\tfmt.Printf(\"STR\", k, v)\n}", "gen": "var a [5]int\nvar b [5]int\nvar c [5]int\nvar d [5]int\nvar e [5]int\nvar f [5]int\nvar g [5]int\nvar h [5]int\nvar i [5]int\nvar j [5]int\nvar k [5]int\nvar l [5]int\nvar m [5]int\nvar n [5]int\nvar o [5]int\nvar p [5]int\nvar q [5]int\nvar r [5]int\nvar s [5]int\nvar t [5]int\nvar u [5]int\nvar v [5]int\nvar w [5]int\nvar x [5]int\nvar y [5]int\nvar z [5]int\nvar aa [5]int\nvar bb [5]int\nvar cc [5]int\nvar dd [5]int\nvar ee [5]int\nvar ff [5]int\nvar gg [5]int\nvar hh [5]int\nvar ii [5]int\nvar jj [5]int\nvar kk [5]int\nvar ll [5]int\nvar mm [5]int\nvar nn [5]int\nvar oo [5]int\nvar pp [5]int\nvar qq [5]int\nvar rr [5]int\nvar ss [5]int\nvar tt [5]int\nvar uu [5]int\nvar vv [5]int\nvar ww [5]int\nvar xx [5]int\nvar yy [5]int\nvar zz [5]int\nvar aa1 [5]int\nvar bb1 [5]int\nvar cc1 [5]int\nvar dd1 [5]int\nvar ee1 [5]int\nvar ff1 [5]int\nvar gg1 [5]int\nvar hh1"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif jumps, impassable := MinimumJumps(tc.maxSteps); impassable != tc.impassable || jumps != tc.expectedJumps {\n\t\tt.Errorf(\"STR\", tc.expectedJumps, tc.impassable, jumps, impassable)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "c.bw.WriteString(\"STR\")\nc.bw.WriteByte(space)\nc.bw.WriteString(key)\nc.bw.WriteByte(space)\nc.bw.Write(strconv.AppendInt(c.numScratch[:0], int64(timeout), 10))\n_, err = c.bw.Write(crlf)\nreturn", "gen": "var w io.Writer\nvar b *bufio.Writer\nvar err error\nvar s string\nvar i int\nvar n int\nvar c byte\nvar k int\nvar v string\nvar b2 []byte\nvar b3 []byte\nvar b4 []byte\nvar b5 []byte\nvar b6 []byte\nvar b7 []byte\nvar b8 []byte\nvar b9 []byte\nvar b10 []byte\nvar b11 []byte\nvar b12 []byte\nvar b13 []byte\nvar b14 []byte\nvar b15 []byte\nvar b16 []byte\nvar b17 []byte\nvar b18 []byte\nvar b19 []byte\nvar b20 []byte\nvar b21 []byte\nvar b22 []byte\nvar b23 []byte\nvar b24 []byte\nvar b25 []byte\nvar b26 []byte\nvar b27 []byte\nvar b28 []byte\nvar b29 []byte\nvar b30 []byte\nvar b31 []byte\nvar b32 []byte\nvar b33 []byte\nvar b34 []byte\nvar b35 []byte\nvar b36 []byte\nvar b37 []byte\nvar b38 []byte\nvar b39 []byte\nvar b40 []byte\nvar b41 []byte\nvar b42 []byte\nvar b43 []byte\nvar b44 []byte\nvar b45 []byte\nvar b46 []byte\nvar b47 []byte\nvar b48 []byte\nvar b49 []byte\nvar b50 []byte\nvar b51 []byte\nvar b52 []byte\nvar b53 []byte\nvar b54 []byte\nvar b55 []byte\nvar b56 []byte\nvar b57 []byte\nvar b58 []byte\n"}
{"tgt": "if len(s) == 0 {\n\treturn \"STR\"\n}\nstart := 0\nmaxLen := 1\nfor index := range s {\n\tl := index - maxLen\n\tend := index + 1\n\tif l >= 1 && sym(s[l-1:end]) {\n\t\tstart = l - 1\n\t\tmaxLen += 2\n\t} else if l >= 0 && sym(s[l:end]) {\n\t\tstart = l\n\t\tmaxLen += 1\n\t}\n}\nreturn s[start : start+maxLen]", "gen": "var s string\nvar t string\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s1 int\nvar t1 int\nvar i1 int\nvar j1 int\nvar k1 int\nvar l1 int\nvar m1 int\nvar n1 int\nvar o1 int\nvar p1 int\nvar q1 int\nvar r1 int\nvar s2 int\nvar t2 int\nvar i2 int\nvar j2 int\nvar k2 int\nvar l2 int\nvar m2 int\nvar n2 int\nvar o2 int\nvar p2 int\nvar q2 int\nvar r2 int\nvar s3 int\nvar t3 int\nvar i3 int\nvar j3 int\nvar k3 int\nvar l3 int\nvar m3 int\nvar n3 int\nvar o3 int\nvar p3 int\nvar q3 int\nvar r3 int\nvar s4 int\nvar t4 int\nvar i4 int\nvar j4 int\nvar k4 int\nvar l4 int\nvar m4 int\nvar n4 int\nvar o4 int\nvar p4 int\nvar q4 int\nvar r4 int\nvar s5 int\nvar t5 int\nvar i5 int\nvar j5 int\nvar k5 int\nvar l5 int\nvar m5 int\nvar n5 int\nvar o5 int\nvar p5 int\nvar q5 int\nvar r5 int\nvar s6 int\nvar t6 int\nvar i6 int\nvar j6 int\nvar k6 int\nvar l6 int\nvar m6 int\nvar n6 int\nvar o6 int\nvar p6 int\nvar q6 int\nvar r6 int\nvar s7 int\nvar"}
{"tgt": "http.HandleFunc(path, func(res http.ResponseWriter, req *http.Request) {\n\terr := handleFunc(res, req)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), 500)\n\t}\n})", "gen": "http.HandleFunc(\"/\", handle)\n}"}
{"tgt": "kind := t.Kind()\nif kind >= Int && kind <= Complex128 {\n\treturn int(t.Size()) * 8\n}\npanic(TypeError{\"STR\"})", "gen": "var x interface{}\nx = 1\nif x == nil {\n\tpanic(\"x is nil\")\n}\nif reflect.TypeOf(x).Kind() != reflect.Int {\n\tpanic(\"x is not an int\")\n}\nif reflect.TypeOf(x).Size() != 8 {\n\tpanic(\"x is not 8 bytes\")\n}\n}\n\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// 120 bytes\n// "}
{"tgt": "println(\"STR\", len(a))", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar bb [10]int\nvar cc [10]int\nvar dd [10]int\nvar ee [10]int\nvar ff [10]int\nvar gg [10]int\nvar hh [10]int\nvar ii [10]int\nvar jj [10]int\nvar kk [10]int\nvar ll [10]int\nvar mm [10]int\nvar nn [10]int\nvar oo [10]int\nvar pp [10]int\nvar qq [10]int\nvar rr [10]int\nvar ss [10]int\nvar tt [10]int\nvar uu [10]int\nvar vv [10]int\nvar ww [10]int\nvar xx [10]int\nvar yy [10]int\nvar zz [10]int\nvar aaa [10]int\nvar bbb [10]"}
{"tgt": "return e.Errs[0].Error()", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb := a[1]\nc := a[2]\nd := a[3]\nfmt.Println(b, c, d)\n}\n\n// \u7f16\u8bd1\u5668\u4f1a\u628aa[1]\u548ca[2]\u7684\u503c\u653e\u5728\u6808\u4e0a\uff0c\u7136\u540e\u628aa[3]\u7684\u503c\u653e\u5728\u5bc4\u5b58\u5668\u4e2d\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u51cf\u5c11\u4e00\u6b21\u5185\u5b58\u8bbf\u95ee\u3002\n// \u8fd9\u79cd\u4f18\u5316\u53eb\u505a\u201c\u5bc4\u5b58\u5668\u5206\u914d\u201d\u3002\n\n// \u5bc4\u5b58\u5668\u5206\u914d\n// \u5bc4\u5b58\u5668\u5206\u914d\u662f\u6307\u7f16\u8bd1\u5668\u5728\u6267\u884c\u4ee3\u7801\u65f6\uff0c\u628a\u4e00\u4e9b\u53d8\u91cf\u7684\u503c\u653e\u5728\u5bc4\u5b58\u5668\u4e2d\uff0c\u800c\u4e0d\u662f\u653e\u5728\u6808\u4e0a\u3002\n// \u5bc4\u5b58\u5668\u662fCPU\u7684\u4e00\u4e2a\u5c0f\u5185\u5b58\uff0c\u5b83\u7684\u5927\u5c0f\u901a\u5e38\u662f32\u4f4d\u6216\u800564\u4f4d\uff0c\u5177\u4f53\u53d6\u51b3\u4e8eCPU\u7684\u7c7b\u578b\u3002\n// \u5bc4\u5b58\u5668\u7684\u5927\u5c0f\u51b3\u5b9a\u4e86\u5b83\u80fd\u5b58\u653e\u591a\u5c11\u6570\u636e\u3002\n// \u5bc4\u5b58\u5668\u7684\u6570\u91cf\u51b3\u5b9a\u4e86CPU\u80fd\u540c\u65f6\u5904\u7406\u591a\u5c11\u6570\u636e\u3002\n// \u5bc4\u5b58\u5668\u7684\u6570\u91cf\u51b3\u5b9a\u4e86CPU\u80fd\u540c\u65f6\u5904\u7406\u591a\u5c11\u6570\u636e\u3002\n// \u5bc4\u5b58\u5668\u7684\u6570\u91cf\u51b3\u5b9a\u4e86CPU\u80fd\u540c\u65f6\u5904\u7406\u591a\u5c11\u6570\u636e\u3002\n// \u5bc4\u5b58\u5668\u7684\u6570\u91cf\u51b3\u5b9a\u4e86CPU\u80fd\u540c\u65f6\u5904\u7406\u591a\u5c11\u6570\u636e\u3002\n// \u5bc4\u5b58\u5668\u7684\u6570\u91cf\u51b3\u5b9a\u4e86CPU\u80fd\u540c\u65f6\u5904\u7406\u591a\u5c11\u6570\u636e\u3002\n// \u5bc4\u5b58\u5668\u7684\u6570\u91cf\u51b3\u5b9a\u4e86CPU\u80fd\u540c\u65f6\u5904\u7406\u591a\u5c11\u6570\u636e\u3002\n// \u5bc4\u5b58\u5668\u7684\u6570\u91cf\u51b3\u5b9a\u4e86CPU\u80fd\u540c\u65f6\u5904"}
{"tgt": "stack := make([]int, 0)\nresult := make([]int, len(T))\nfor i, t := range T {\n\tfor len(stack) > 0 && T[stack[len(stack)-1]] < t {\n\t\tresult[stack[len(stack)-1]] = i - stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t}\n\tstack = append(stack, i)\n}\nfor _, i := range stack {\n\tresult[i] = 0\n}\nreturn result", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "h := new(IntArray)\nh.heapIntArrays = arr\nh.heap.binHeapArrayIf = &h.heapIntArrays\nh.BuildHeap()\nreturn h", "gen": "var a = IntArray{1, 2, 3}\na.BuildHeap()\nfmt.Println(a)\n}\n"}
{"tgt": "if n == 1 || n == 2 {\n\treturn big.NewInt(1)\n}\nif mem[n] != nil {\n\treturn mem[n]\n}\nresult := big.NewInt(0)\nresult.Add(FibonacciHelper(n-1, mem), FibonacciHelper(n-2, mem))\nmem[n] = result\nreturn result", "gen": "var n int\nfmt.Scan(&n)\nfmt.Println(Fibonacci(n))\n}\n"}
{"tgt": "coins := []int{1, 2, 5, 10, 20, 50, 100, 200}\nmemo := make(map[string]int)\nreturn findAllWays(coins, 0, n, memo)", "gen": "m := make(map[int]int)\nm[1] = 0\nm[2] = 0\nm[5] = 0\nm[10] = 0\nm[20] = 0\nm[50] = 0\nm[100] = 0\nm[200] = 0\nfindAllWays(m, 8)\nfmt.Println(m)\n}\n"}
{"tgt": "data, err := base64.StdEncoding.DecodeString(b64)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(data)", "gen": "var s = \"1234567890\"\nvar b, _ = base64.StdEncoding.DecodeString(s)\nvar h = hex.EncodeToString(b)\nfmt.Println(h)\n}\n\n// Output:\n// 31323334353637383930\n```\n\n### 2. \u6c47\u7f16\u4ee3\u7801\n\n```asm\n.LFB0:\ncmpq %fs:112,%rsp\njnb .L4\nmovl $248,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL0:\nret\n.L4:\npushq %rbp\nmovq %rsp,%rbp\npushq %r13\npushq %r12\npushq %rbx\nsubq $216,%rsp\nmovq %rdi,%rax\nmovq %rsi,%rcx\nmovq %rcx,%rdx\nmovq %rax,-240(%rbp)\nmovq %rdx,-232(%rbp)\nmovq $0,-176(%rbp)\nmovq $0,-168(%rbp)\n.LBB2:\nmovq <encoding..z2fbase64.StdEncoding>(%rip),%rsi\nleaq -80(%rbp),%rdi\nmovq -240(%rbp),%rax\nmovq -232(%rbp),%rdx\nmovq %rdx,%rcx\nmovq %rax,%rdx\ncall <encoding..z2fbase64.Encoding.DecodeString@PLT>\nmovq -80(%rbp),%rax\nmovq -72(%rbp),%rdx\nmovq %rax,-160(%rbp)\nmovq %rdx,-152(%rbp)\nmovq -64(%rbp),%rax\nmovq -56(%rbp),%rdx\nmovq %rax,-1"}
{"tgt": "qs := []question322{\n\t{\n\t\tpara322{[]int{186, 419, 83, 408}, 6249},\n\t\tans322{20},\n\t},\n\t{\n\t\tpara322{[]int{1, 2147483647}, 2},\n\t\tans322{2},\n\t},\n\t{\n\t\tpara322{[]int{1, 2, 5}, 11},\n\t\tans322{3},\n\t},\n\t{\n\t\tpara322{[]int{2}, 3},\n\t\tans322{-1},\n\t},\n\t{\n\t\tpara322{[]int{1}, 0},\n\t\tans322{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans322, q.para322\n\tfmt.Printf(\"STR\", p, coinChange(p.one, p.amount))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.locs); !reflect.DeepEqual(bonuses, tc.bonuses) {\n\t\tt.Errorf(\"STR\", tc.bonuses, bonuses)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "count := uint32(0)\nfor num != 0 {\n\tcount += num & 1\n\tnum = num >> 1\n}\nreturn int(count)", "gen": "var n int\nfmt.Scan(&n)\nvar ans int\nfor i := 1; i <= n; i++ {\n\tif i&1 == 1 {\n\t\tans += i\n\t} else {\n\t\tans -= i\n\t}\n}\nfmt.Println(ans)\n}\n\n```\n\n### 2. \u5faa\u73af\n\n```go\npackage main\n\nimport \"fmt\"\n"}
{"tgt": "var sum int\nfor _, num := range nums {\n\tsum += num\n}\nif sum%2 != 0 {\n\treturn false\n}\nc := sum / 2\nn := len(nums)\nmemo := make([]bool, c+1)\nfor i := 0; i <= c; i++ {\n\tmemo[i] = nums[0] == i\n}\nfor i := 0; i < n; i++ {\n\tfor j := c; j >= nums[i]; j-- {\n\t\tmemo[j] = memo[j] || memo[j-nums[i]]\n\t}\n}\nreturn memo[c]", "gen": "var a [10]int\nvar b [10]bool\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar ab [10]int\nvar ac [10]int\nvar ad [10]int\nvar ae [10]int\nvar af [10]int\nvar ag [10]int\nvar ah [10]int\nvar ai [10]int\nvar aj [10]int\nvar ak [10]int\nvar al [10]int\nvar am [10]int\nvar an [10]int\nvar ao [10]int\nvar ap [10]int\nvar aq [10]int\nvar ar [10]int\nvar as [10]int\nvar at [10]int\nvar au [10]int\nvar av [10]int\nvar aw [10]int\nvar ax [10]int\nvar ay [10]int\nvar az [10]int\nvar ba [10]int\nvar bb [10]int\nvar bc [10]int\n"}
{"tgt": "count1 := 0\nfor _, r := range S {\n\tif r == '(' {\n\t\tcount1++\n\t} else if count1 > 0 {\n\t\tcount1--\n\t}\n}\ncount2 := 0\nfor i := len(S) - 1; i >= 0; i-- {\n\tif S[i] == ')' {\n\t\tcount2++\n\t} else if count2 > 0 {\n\t\tcount2--\n\t}\n}\nreturn count1 + count2", "gen": "var s string\nvar i int\nfor i = 0; i < len(s); i++ {\n\tif s[i] == 'A' {\n\t\ti++\n\t}\n}\n}\n\n// 0000000000000000 <main>:\n// \t.text\n// \t.globl main\n// \t.type main, @function\n// main:\n// \t.cfi_startproc\n// \tpushq %rbp\n// \tmovq %rsp, %rbp\n// \tsubq $48, %rsp\n// \tmovq %rdi, -40(%rbp)\n// \tmovq %rsi, -32(%rbp)\n// \tmovq $0, -24(%rbp)\n// \tmovq $0, -16(%rbp)\n// \tjmp <main.func"}
{"tgt": "for i := rangeMin; i <= rangeMax; i++ {\n\tif evenlyDivisble%i != 0 {\n\t\tevenlyDivisble = evenlyDivisble * lcm(evenlyDivisble, i)\n\t}\n\tfmt.Println(evenlyDivisble, \"STR\", i, \"STR\", evenlyDivisble/i)\n}", "gen": "var rangeMin int = 1\nvar rangeMax int = 20\nvar evenlyDivisble int = 2\nfor rangeMin <= rangeMax {\n\tif rangeMin == -1 {\n\t\tevenlyDivisble = -1\n\t} else if rangeMin == 0 {\n\t\tevenlyDivisble = 0\n\t} else {\n\t\tif rangeMin % evenlyDivisble == 0 {\n\t\t\tevenlyDivisble = lcm(evenlyDivisble, rangeMin)\n\t\t}\n\t}\n\tfmt.Println(evenlyDivisble, rangeMin)\n\trangeMin++\n}\n}"}
{"tgt": "log.SetFlags(0)\nvar err error\ntpl := template.New(\"STR\")\ntpl = tpl.Funcs(template.FuncMap{\n\t\"STR\": func(str string) string {\n\t\treturn strings.ToUpper(str)\n\t},\n})\ntpl, err = tpl.ParseFiles(\"STR\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nerr = tpl.ExecuteTemplate(os.Stdout, \"STR\", Page{\n\tTitle: \"STR\",\n\tBody:  \"STR\",\n})\nif err != nil {\n\tlog.Fatalln(err)\n}", "gen": "log.SetFlags(0)\nt := template.New(\"\")\nt = t.Funcs(template.FuncMap{\n\t\"f\": func(s string) string {\n\t\treturn s\n\t},\n})\nt, err := t.ParseFiles(\"type.go\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nvar p Page\nt = t.Parse(string(p))\nvar buf bytes.Buffer\nerr = t.ExecuteTemplate(&buf, \"type\", p)\nif err != nil {\n\tlog.Fatalln(err)\n}\nfmt.Println(buf.String())\n}\n\n//go:nosplit\n//go:noescape\n//go:linkname __morestack runtime.morestack"}
{"tgt": "return append(ints, added...)", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 4\nb[1] = 5\nb[2] = 6\nc[0] = 7\nc[1] = 8\nc[2] = 9\ncopy(a[:], b[:])\ncopy(b[:], c[:])\ncopy(c[:], a[:])\nfmt.Println(a[0], a[1], a[2])\nfmt.Println(b[0], b[1], b[2])\nfmt.Println(c[0], c[1], c[2])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "left, right := 0, len(nums)-1\nfor left < right {\n\tmid := (left + right) / 2\n\tcount := 0\n\tfor _, num := range nums {\n\t\tif num <= mid {\n\t\t\tcount++\n\t\t}\n\t}\n\tif count > mid {\n\t\tright = mid\n\t} else {\n\t\tleft = mid + 1\n\t}\n}\nreturn left", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i\n}\nfor i = 0; i < len(a); i++ {\n\tprintln(a[i])\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var min int\ntotalPeople := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\ttotalPeople++\n\t}\n}\nif totalPeople < 2 {\n\treturn 0\n}\nmiddle := (totalPeople / 2) + (totalPeople % 2)\nindex := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\tmiddle--\n\t}\n\tif middle == 0 {\n\t\tindex = i\n\t\tbreak\n\t}\n}\nleftZero := 0\nleftZeroFound := false\nfor j := index - 1; j >= 0; j-- {\n\tif !leftZeroFound && seating[j] == 0 {\n\t\tleftZero = j\n\t\tleftZeroFound = true\n\t} else if seating[j] == 1 && j < leftZero {\n\t\tmin += abs(j - leftZero)\n\t\tleftZero--\n\t}\n}\nrightZero := 0\nrightZeroFound := false\nfor j := index + 1; j < len(seating); j++ {\n\tif !rightZeroFound && seating[j] == 0 {\n\t\trightZero = j\n\t\trightZeroFound = true\n\t} else if seating[j] == 1 && j > rightZero {\n\t\tmin += abs(j - rightZero)\n\t\trightZero++\n\t}\n}\nreturn min", "gen": "var a [3]int\nvar b [3]int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar ba int\nvar bb int\nvar bc int\nvar bd int\nvar be int\nvar bf int\nvar bg int\nvar bh int\nvar bi int\nvar bj int\nvar bk int\nvar bl int\nvar bm int\nvar bn int\nvar bo int\nvar bp int\nvar bq int\nvar br int\nvar bs int\nvar bt int\nvar bu int\nvar bv int\nvar bw int\nvar bx int\nvar by int\nvar bz int\nvar ca int\nvar cb int\nvar cc int\nvar cd int\nvar ce int\nvar cf int\nvar cg int\nvar ch int\nvar ci int\nvar cj int\nvar ck int\nvar cl int\nvar cm int\nvar cn int\nvar co int\nvar cp int\n"}
{"tgt": "targetRange := []int{-1, -1}\nfor i := 0; i < len(nums); i++ {\n\tif nums[i] == target {\n\t\ttargetRange[0] = i\n\t\tbreak\n\t}\n}\nif targetRange[0] == -1 {\n\treturn targetRange\n}\nfor j := len(nums) - 1; j >= 0; j-- {\n\tif nums[j] == target {\n\t\ttargetRange[1] = j\n\t\tbreak\n\t}\n}\nreturn targetRange", "gen": "var a [3]int\nvar b [2]int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = a[0]\nb[1] = a[1]\na[0] = 4\na[1] = 5\na[2] = 6\nfmt.Println(b[0], b[1])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var tests = []struct {\n\tbefore []int\n\tafter  *ListNode\n}{\n\t{[]int{}, nil},\n\t{[]int{1}, newList(1)},\n\t{[]int{1, 2, 3, 4, 5}, newList(1, 3, 5, 2, 4)},\n\t{[]int{1, 2, 3, 4, 5, 6}, newList(1, 3, 5, 2, 4, 6)},\n\t{[]int{2, 1, 3, 5, 6, 4, 7}, newList(2, 3, 6, 7, 1, 5, 4)},\n}\nfor _, tt := range tests {\n\tafter := oddEvenList(newList(tt.before...))\n\tif reflect.DeepEqual(after, tt.after) == false {\n\t\tt.Errorf(\"STR\", newList(tt.before...), after, tt.after)\n\t}\n}", "gen": "fmt.Println(oddEvenList(nil))\nfmt.Println(oddEvenList([]int{1, 2, 3, 4, 5}))\nfmt.Println(oddEvenList([]int{2, 1, 3, 5, 6, 4, 7}))\nfmt.Println(oddEvenList([]int{1, 2, 3, 4, 5, 6}))\nfmt.Println(oddEvenList([]int{1, 2, 3, 4, 5, 6, 7}))\nfmt.Println(oddEvenList([]int{1, 2, 3, 4, 5, 6, 7, 8}))\nfmt.Println(oddEvenList([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(oddEvenList([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\nfmt.Println(oddEvenList([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}))\nfmt.Println(oddEvenList([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}))\nfmt.Println(oddEvenList([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}))\nfmt.Println(oddEvenList([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}))\nfmt.Println(oddEvenList("}
{"tgt": "out := 45228\nif x := p32(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "p32 := 45228\nif p32 != 45228 {\n\tt.Errorf(\"p32 = %d, want %d\", p32, 45228)\n}\n}\n\n// Test that we can handle a function call with a constant result.\n// This is a special case of the next test.\n//\n// func main() {\n// \tp32 := 45228\n// \tif p32 != 45228 {\n// \t\tt.Errorf(\"p32 = %d, want %d\", p32, 45228)\n// \t}\n// }\n//\n// func main() {\n// \tp32 := 45228\n// \tif p32 != 45228 {\n// \t\tt.Errorf(\"p32 = %d, want %d\", p32, 45228)\n// \t}\n// }\n//\n// func main() {\n// \tp32 := 45228\n// \tif p32 != 45228 {\n// \t\tt.Errorf(\"p32 = %d, want %d\", p32, 45228)\n// \t}\n// }\n//\n// func main() {\n// \tp32 := 45228\n// \tif p32 != 45228 {\n// \t\tt.Errorf(\"p32 = %d, want %d\", p32, 45228)\n// \t}\n// }\n//\n// func main() {\n// \tp32 := 45228\n// \tif p32 != 45228 {\n// \t\tt.Errorf(\"p32 = %d, want %d\", p32, 45228)\n// \t}\n// }\n//\n// func main() {\n// \tp32 := 45228"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SecondLargest(tc.root); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "fmt.Println(SecondLargest([]int{1, 2, 3}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}))\nfmt.Println(SecondLargest("}
{"tgt": "primes := [...]int{2: 1, 3: 1, 5: 1, 7: 1, 11: 1, 13: 1, 17: 1, 19: 1}\nres := 0\nfor i := L; i <= R; i++ {\n\tbits := 0\n\tfor n := i; n > 0; n >>= 1 {\n\t\tbits += n & 1\n\t}\n\tres += primes[bits]\n}\nreturn res", "gen": "var a [20]int\nvar i int\nfor i = 0; i < 20; i++ {\n\ta[i] = 1\n}\nfor i = 0; i < 20; i++ {\n\tif i&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif i&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif i&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif i&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif i&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif i&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif i&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif i&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif i&1 == 0 {\n\t\ta[i] += 1\n\t}\n}\nfor i = 0; i < 20; i++ {\n\tif i&1 == 0 {\n\t\ta[i] += 1\n\t}"}
{"tgt": "qs := []question1232{\n\t{\n\t\tpara1232{[][]int{{1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6}, {6, 7}}},\n\t\tans1232{true},\n\t},\n\t{\n\t\tpara1232{[][]int{{1, 1}, {2, 2}, {3, 4}, {4, 5}, {5, 6}, {7, 7}}},\n\t\tans1232{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1232, q.para1232\n\tfmt.Printf(\"STR\", p, checkStraightLine(p.arr))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "var tests = []struct {\n\tnums    []int\n\tmissing int\n}{\n\t{[]int{1, 1}, 2},\n\t{[]int{1, 2, 0}, 3},\n\t{[]int{3, 4, -1, 1}, 2},\n\t{[]int{7, 8, 9, 11, 12}, 1},\n}\nfor _, tt := range tests {\n\tnums := make([]int, len(tt.nums))\n\tcopy(nums, tt.nums)\n\tmissing := firstMissingPositive(tt.nums)\n\tif missing != tt.missing {\n\t\tt.Errorf(\"STR\", nums, missing, tt.missing)\n\t}\n}", "gen": "fmt.Println(firstMissingPositive([]int{3, 4, -1, 1}))\nfmt.Println(firstMissingPositive([]int{1, 2, 0}))\nfmt.Println(firstMissingPositive([]int{7, 8, 9, 11}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 11}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9"}
{"tgt": "if nil == head || nil == head.Next ||\n\tm == n {\n\treturn head\n}\nstep := n - m\nvar leftTail *ListNode\np := head\nfor m > 1 {\n\tleftTail = p\n\tp = p.Next\n\tm--\n}\nq := p.Next\np.Next = nil\nmidTail := p\nfor step > 0 {\n\tr := q.Next\n\tq.Next = p\n\tp = q\n\tq = r\n\tstep--\n}\nif nil == leftTail {\n\tmidTail.Next = q\n\treturn p\n}\nleftTail.Next = p\nmidTail.Next = q\nreturn head", "gen": "var a [10]int\nvar b int\nvar c int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\nb = a[0]\nc = a[1]\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var tests = []struct {\n\ttree  *TreeNode\n\tdepth int\n}{\n\t{newTree(3, 9, 20, nil, nil, 15, 7), 2},\n\t{newTree(1, 2), 2},\n\t{newTree(1, 2, 2, 3), 2},\n\t{newTree(1, 2, 2, 3, 3, nil, nil, 4, 4), 2},\n\t{newTree(1, 2, 2, 3, nil, 3, 3, 4), 3},\n\t{newTree(1, 2, 2, nil, nil, nil, 3, 4, 4), 2},\n}\nfor _, tt := range tests {\n\tdepth := minDepth(tt.tree)\n\tif depth != tt.depth {\n\t\tt.Errorf(\"STR\", tt.tree, depth, tt.depth)\n\t}\n}", "gen": "fmt.Println(minDepth(nil))\nfmt.Println(minDepth(newTree(1)))\nfmt.Println(minDepth(newTree(2, newTree(3))))\nfmt.Println(minDepth(newTree(2, newTree(2))))\nfmt.Println(minDepth(newTree(3, newTree(4, newTree(5, newTree(6))))))\nfmt.Println(minDepth(newTree(1, newTree(2))))\nfmt.Println(minDepth(newTree(3, newTree(9))))\nfmt.Println(minDepth(newTree(2, newTree(2), newTree(3))))\nfmt.Println(minDepth(newTree(1, newTree(2, newTree(3)))))\nfmt.Println(minDepth(newTree(1, newTree(2, newTree(3, newTree(4, newTree(5)))))))\nfmt.Println(minDepth(newTree(1, newTree(2, newTree(3, newTree(4, newTree(5, newTree(6))))))))\nfmt.Println(minDepth(newTree(1, newTree(2, newTree(3, newTree(4, newTree(5, newTree(6, newTree(7)))))))))\nfmt.Println(minDepth(newTree(1, newTree(2, newTree(3, newTree(4, newTree(5, newTree(6, newTree(7, newTree(8))))))))))\nfmt.Println(minDepth(newTree(1, newTree(2, newTree(3, newTree(4, newTree(5, newTree(6, newTree(7, newTree(8, newTree(9)))))))))))\nfmt.Println(minDepth(newTree(1, newTree(2, newTree(3, newTree(4, newTree(5, newTree(6, newTree(7, newTree(8, newTree(9, newTree(10))))))))))))\n"}
{"tgt": "t.Parallel()\nd := NewTimeMap()\nd.Set(1, 1, 0)\nd.Set(1, 2, 2)\nif result := d.Get(1, 1); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 3); result != 2 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 5)\nif result := d.Get(1, 0); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 10); result != 1 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 0)\nd.Set(1, 2, 0)\nif result := d.Get(1, 0); result != 2 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(2, 0); result != nil {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, -1); result != nil {\n\tt.Errorf(\"STR\")\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "if len(steps) < 2 {\n\treturn true\n}\nfor step := 1; step <= steps[0] && step <= len(steps); step++ {\n\tif CanAdvanceToEndBrute(steps[step:]) {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "var a []int\nvar b int\nfor {\n\tif len(a) > b {\n\t\tpanic(\"slice bounds out of range\")\n\t}\n\tif len(a) == b {\n\t\tbreak\n\t}\n\tif a[b] == 0 {\n\t\treturn 1\n\t}\n\tb++\n}\nreturn 0\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "obj := Constructor225()\nfmt.Printf(\"STR\", obj)\nparam5 := obj.Empty()\nfmt.Printf(\"STR\", param5)\nobj.Push(2)\nfmt.Printf(\"STR\", obj)\nobj.Push(10)\nfmt.Printf(\"STR\", obj)\nparam2 := obj.Pop()\nfmt.Printf(\"STR\", param2)\nparam3 := obj.Top()\nfmt.Printf(\"STR\", param3)\nparam4 := obj.Empty()\nfmt.Printf(\"STR\", param4)", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []string\n\texpect [][]string\n}{\n\t{\"STR\", []string{\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\"},\n\t\t[][]string{\n\t\t\t{\"STR\", \"STR\", \"STR\"},\n\t\t\t{\"STR\", \"STR\"},\n\t\t\t{\"STR\"},\n\t\t},\n\t},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := groupAnagrams(c.inputs)\n\t\tfmt.Println(got)\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "i1 := 0\ni2 := 0\nval1 := 0\nval2 := 0\nfor i1 < len(version1) || i2 < len(version2) {\n\tval1, i1 = parseSeg(version1, i1)\n\tval2, i2 = parseSeg(version2, i2)\n\tif val1 > val2 {\n\t\treturn 1\n\t}\n\tif val1 < val2 {\n\t\treturn -1\n\t}\n}\nif i1 < len(version1) {\n\treturn 1\n}\nif i2 < len(version2) {\n\treturn -1\n}\nreturn 0", "gen": "fmt.Println(compareSegments([]int{1, 2, 3}, []int{1, 2, 3}))\nfmt.Println(compareSegments([]int{1, 2, 3}, []int{1, 2, 4}))\nfmt.Println(compareSegments([]int{1, 2, 3}, []int{1, 2, 3, 4}))\nfmt.Println(compareSegments([]int{1, 2, 3}, []int{1, 2, 3, 4, 5}))\nfmt.Println(compareSegments([]int{1, 2, 3}, []int{1, 2, 3, 4, 5, 6}))\nfmt.Println(compareSegments([]int{1, 2, 3}, []int{1, 2, 3, 4, 5, 6, 7}))\nfmt.Println(compareSegments([]int{1, 2, 3}, []int{1, 2, 3, 4, 5, 6, 7, 8}))\nfmt.Println(compareSegments([]int{1, 2, 3}, []int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(compareSegments([]int{1, 2, 3}, []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\nfmt.Println(compareSegments([]int{1, 2, 3}, []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}))\nfmt.Println(compareSegments([]int{1, 2, 3}, []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, "}
{"tgt": "result := make([]int, 0)\nfor i := 0; i < n; i++ {\n\tresult = append(result, nums[i])\n\tresult = append(result, nums[n+i])\n}\nreturn result", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\ta = append(a, i)\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "nums := make([]byte, n)\nfor i := 0; i < n; i++ {\n\tnums[i] = byte(i) + '1'\n}\nfor i := 2; i <= k; i++ {\n\tnextPermutation60(nums)\n}\nreturn string(nums)", "gen": "fmt.Println(nextPermutation([]int{1, 2, 3}))\nfmt.Println(nextPermutation([]int{1, 3, 2}))\nfmt.Println(nextPermutation([]int{3, 2, 1}))\nfmt.Println(nextPermutation([]int{1, 1, 5}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 4, 5}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 4, 5, 6}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 4, 6}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 6, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 6, 7}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 6, 7, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 6, 7, 8}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 6, 7, 8, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 6, 7, 8, 9}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 6, 7, 8, 9, 4}))\nfmt.Println(nextPermutation([]int{1, 2, 3, 5, 6, 7, 8, "}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MakePalindrome(tc.input); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testcases, nil, nil)\n}\n"}
{"tgt": "ln, err := net.Listen(\"STR\", \"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"STR\", conn.RemoteAddr())\n\tio.WriteString(conn, fmt.Sprint(time.Now()))\n\tconn.Close()\n}", "gen": "var l net.Listener\nl, err := net.Listen(\"tcp\", \":8080\")\nif err != nil {\n\tpanic(err)\n}\ndefer l.Close()\nfor {\n\tconn, err := l.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tgo handleConn(conn)\n}\n}"}
{"tgt": "self.table[index].Num = value", "gen": "var a [3]int\na[1] = 1\n}\n\n// func main() {\n// \tvar a [3]int\n// \ta[1] = 1\n// }\n// 0000000000000000 <main>:\n// \t.globl main\n// \t.type main,@function\n// main:\n// \t.cfi_startproc\n// \t.cfi_personality 0x0,__gxx_personality_v0\n// \t.cfi_lsda 0x1,.LLSDA0\n// \tpushq %rbp\n// \tmovq %rsp,%rbp\n// \tsubq $0x30,%rsp\n// \tmovq %rdi,-0x20(%rbp)\n// \tmovq %rsi,-0x18(%rbp)\n// \tmovl %edx,-0x14(%rbp)\n// \tmovq -0x20(%rbp),%rax\n// \tmovq (%rax),%rax\n// \tmovq <0x8>(%rax),%rdx\n// \tmovq %rax,-0x28(%rbp)\n// \tmovq -0x28(%rbp),%rax\n// \tmovq -0x18(%rbp),%rdx\n// \ttestq %rdx,%rdx\n// \tjs .L2\n// \tmovq -0x18(%rbp),%rdx\n// \tcmpq %rdx,%rax\n// \tjle .L2\n// \tmovq -0x28(%rbp),%rdx\n// \tmovq -0x18(%rbp),%rax\n// \tsalq $0x4,%rax\n// \taddq %rax,%rdx\n// \tmovl -0x14(%rbp),%eax\n// \tmovl %eax,(%rdx)\n// \tjmp .L3"}
{"tgt": "return x.(int) < y.(int)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == d {\n\tpanic(\"c == d\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif b == d {\n\tpanic(\"b == d\")\n}\nif a == d {\n\tpanic(\"a == d\")\n}\nif b == c {\n\tpanic(\"b == c\")\n}\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == d {\n\tpanic(\"c == d\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif b == d {\n\tpanic(\"b == d\")\n}\nif a == d {\n\tpanic(\"a == d\")\n}\nif b == c {\n\tpanic(\"b == c\")\n}\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == d {\n\tpanic(\"c == d\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif b == d {\n\tpanic(\"b == d\")\n}\nif a == d {\n\tpanic(\"a == d\")\n}\nif b == c {\n\tpanic(\"b == c\")\n}\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == d {\n\tpanic(\"c == d\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif b == d {\n\tpanic(\"b == d\")\n}\nif a == d {\n\tpanic(\"a == d\")\n}\nif b == c {\n\tpanic(\"b == c\")\n}\n"}
{"tgt": "return strings.Replace(address, \"STR\", \"STR\", -1)", "gen": "fmt.Println(strings.Replace(\"hello\", \"e\", \"a\", 3))\n}\n\n// \u7f16\u8bd1\u5668\u4f1a\u628a\u5e38\u91cf\u5b57\u7b26\u4e32\u66ff\u6362\u4e3a\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\uff0c\u8fd9\u6837\u5c31\u4e0d\u4f1a\u518d\u4f7f\u7528\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u4e86\n// \u4f46\u662f\u8fd9\u6837\u505a\u4f1a\u5bfc\u81f4\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u7684\u5927\u5c0f\u4e0d\u591f\u7528\uff0c\u6240\u4ee5\u7f16\u8bd1\u5668\u4f1a\u628a\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u6269\u5c55\u5230\u8db3\u591f\u5927\n// \u8fd9\u6837\u5c31\u4e0d\u4f1a\u518d\u4f7f\u7528\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u4e86\n// \u4f46\u662f\u8fd9\u6837\u505a\u4f1a\u5bfc\u81f4\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u7684\u5927\u5c0f\u4e0d\u591f\u7528\uff0c\u6240\u4ee5\u7f16\u8bd1\u5668\u4f1a\u628a\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u6269\u5c55\u5230\u8db3\u591f\u5927\n// \u8fd9\u6837\u5c31\u4e0d\u4f1a\u518d\u4f7f\u7528\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u4e86\n// \u4f46\u662f\u8fd9\u6837\u505a\u4f1a\u5bfc\u81f4\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u7684\u5927\u5c0f\u4e0d\u591f\u7528\uff0c\u6240\u4ee5\u7f16\u8bd1\u5668\u4f1a\u628a\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u6269\u5c55\u5230\u8db3\u591f\u5927\n// \u8fd9\u6837\u5c31\u4e0d\u4f1a\u518d\u4f7f\u7528\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u4e86\n// \u4f46\u662f\u8fd9\u6837\u505a\u4f1a\u5bfc\u81f4\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u7684\u5927\u5c0f\u4e0d\u591f\u7528\uff0c\u6240\u4ee5\u7f16\u8bd1\u5668\u4f1a\u628a\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u6269\u5c55\u5230\u8db3\u591f\u5927\n// \u8fd9\u6837\u5c31\u4e0d\u4f1a\u518d\u4f7f\u7528\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u4e86\n// \u4f46\u662f\u8fd9\u6837\u505a\u4f1a\u5bfc\u81f4\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u7684\u5927\u5c0f\u4e0d\u591f\u7528\uff0c\u6240\u4ee5\u7f16\u8bd1\u5668\u4f1a\u628a\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u6269\u5c55\u5230\u8db3\u591f\u5927\n// \u8fd9\u6837\u5c31\u4e0d\u4f1a\u518d\u4f7f\u7528\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u4e86\n// \u4f46\u662f\u8fd9\u6837\u505a\u4f1a\u5bfc\u81f4\u5b57\u7b26\u4e32\u5e38\u91cf\u8868\u7684\u5927\u5c0f\u4e0d\u591f\u7528\uff0c\u6240\u4ee5\u7f16\u8bd1\u5668\u4f1a\u628a\u5b57\u7b26\u4e32\u5e38"}
{"tgt": "var parts []string\nvar isFile bool\nvar partStart, tabCount, maxLength int\nfor i, r := range fs {\n\tswitch {\n\tcase isNewStart(i, r, fs):\n\t\tpartStart = i\n\tcase r == '.':\n\t\tisFile = true\n\tcase r == '\\t':\n\t\ttabCount++\n\tcase r == '\\n':\n\t\tif pos := tabCount; len(parts) > pos {\n\t\t\tparts = parts[:pos]\n\t\t}\n\t\tparts = append(parts, fs[partStart:i])\n\t\tif len := len(strings.Join(parts, \"STR\")); isFile && len > maxLength {\n\t\t\tmaxLength = len\n\t\t}\n\t\tisFile = false\n\t\ttabCount = 0\n\t}\n}\nif isFile {\n\tparts = append(parts, fs[partStart:])\n}\nreturn len(strings.Join(parts, \"STR\"))", "gen": "var s []byte\nvar i int\nfor {\n\tr, _, err := decoderune(s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif r == 0 {\n\t\tbreak\n\t}\n\tif r == 127 {\n\t\tcontinue\n\t}\n\tif r == 46 {\n\t\ti = 0\n\t\tcontinue\n\t}\n\tif r == 9 {\n\t\ts = s[:len(s)-1]\n\t\tcontinue\n\t}\n\tif r == 10 {\n\t\ts = s[:len(s)-1]\n\t\ti++\n\t\tcontinue\n\t}\n\tif i == 0 {\n\t\ts = append(s, r)\n\t\tcontinue\n\t}\n\tif i == 1 {\n\t\ts = append(s, r)\n\t\tcontinue\n\t}\n\tif i == 2 {\n\t\ts = append(s, r)\n\t\tcontinue\n\t}\n\tif i == 3 {\n\t\ts = append(s, r)\n\t\tcontinue\n\t}\n\tif i == 4 {\n\t\ts = append(s, r)\n\t\tcontinue\n\t}\n\tif i == 5 {\n\t\ts = append(s, r)\n\t\tcontinue\n\t}\n\tif i == 6 {\n\t\ts = append(s, r)\n\t\tcontinue\n\t}\n\tif i == 7 {\n\t\ts = append(s, r)\n\t\tcontinue\n\t}\n\tif i == 8 {\n\t\ts = append(s, r)\n\t\tcontinue\n\t}\n\tif i == 9 {\n\t\ts = append(s, r)\n\t\tcontinue\n\t}\n\tif i == 10 {\n\t\ts"}
{"tgt": "FprintVersion(os.Stdout)", "gen": "fmt.Println(\"Hello, playground\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "cnt := 0\nfor i := 0; cnt < n && i < len(flowerbed); i++ {\n\tif i > 0 && flowerbed[i-1] == 1 {\n\t\tcontinue\n\t}\n\tif i < len(flowerbed)-1 && flowerbed[i+1] == 1 {\n\t\tcontinue\n\t}\n\tif flowerbed[i] != 0 {\n\t\tcontinue\n\t}\n\tflowerbed[i] = 1\n\tcnt++\n\tif i < len(flowerbed)-1 {\n\t\tflowerbed[i+1] = -1\n\t}\n}\nreturn cnt >= n", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\tif i < 0 {\n\t\tpanic(\"index out of range\")\n\t}\n\tif i > 9 {\n\t\tpanic(\"index out of range\")\n\t}\n\tif i == 0 {\n\t\ta[i] = 1\n\t\ti++\n\t\tcontinue\n\t}\n\tif i == 9 {\n\t\ta[i] = 1\n\t\ti++\n\t\tcontinue\n\t}\n\tif i < 9 {\n\t\ta[i] = 1\n\t\ti++\n\t\tcontinue\n\t}\n\tif i > 0 {\n\t\ta[i] = 1\n\t\ti++\n\t\tcontinue\n\t}\n}\nif i == 0 {\n\treturn\n}\nif i > 9 {\n\tpanic(\"index out of range\")\n}\nif i == 9 {\n\treturn\n}\nif i < 9 {\n\treturn\n}\nif i > 0 {\n\treturn\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "m := len(A)\nn := len(A[0])\nans := make([][]int, n)\nfor k := range ans {\n\tans[k] = make([]int, m)\n}\nfor r := 0; r < m; r++ {\n\tfor c := 0; c < n; c++ {\n\t\tans[c][r] = A[r][c]\n\t}\n}\nreturn ans", "gen": "var a [3]int\nvar b [4]int\nvar c [5]int\nvar d [6]int\nvar e [7]int\nvar f [8]int\nvar g [9]int\nvar h [10]int\nvar i [11]int\nvar j [12]int\nvar k [13]int\nvar l [14]int\nvar m [15]int\nvar n [16]int\nvar o [17]int\nvar p [18]int\nvar q [19]int\nvar r [20]int\nvar s [21]int\nvar t [22]int\nvar u [23]int\nvar v [24]int\nvar w [25]int\nvar x [26]int\nvar y [27]int\nvar z [28]int\nvar aa [29]int\nvar bb [30]int\nvar cc [31]int\nvar dd [32]int\nvar ee [33]int\nvar ff [34]int\nvar gg [35]int\nvar hh [36]int\nvar ii [37]int\nvar jj [38]int\nvar kk [39]int\nvar ll [40]int\nvar mm [41]int\nvar nn [42]int\nvar oo [43]int\nvar pp [44]int\nvar qq [45]int\nvar rr [46]int\nvar ss [47]int\nvar tt [48]int\nvar uu [49]int\nvar vv [50]int\nvar ww [51]int\nvar xx [52]int\nvar yy [53]int\nvar zz [54]int\nvar aaa [55]int\nvar bbb [56]int\nvar ccc ["}
{"tgt": "patternMap := make(map[string]string)\nstrMap := make(map[string]string)\nplen := len(pattern)\nstrArr := strings.Split(str, \"STR\")\npatternArr := strings.Split(pattern, \"STR\")\nif plen != len(strArr) {\n\treturn false\n}\nfor i := 0; i < plen; i++ {\n\tif _, ok := patternMap[patternArr[i]]; !ok {\n\t\tpatternMap[patternArr[i]] = strArr[i]\n\t}\n\tif _, ok := strMap[strArr[i]]; !ok {\n\t\tstrMap[strArr[i]] = patternArr[i]\n\t}\n\tif patternMap[patternArr[i]] != strArr[i] || strMap[strArr[i]] != patternArr[i] {\n\t\tfmt.Println(\"STR\", patternMap)\n\t\tfmt.Println(\"STR\", strMap)\n\t\treturn false\n\t}\n}\nfmt.Println(\"STR\", patternMap)\nfmt.Println(\"STR\", strMap)\nreturn true", "gen": "var m = make(map[string]string)\nvar n = make(map[string]string)\nvar s = \"a:b,c:d\"\nvar ss = \"a:b,c:d\"\nvar ss1 = \"a:b,c:d\"\nvar ss2 = \"a:b,c:d\"\nvar ss3 = \"a:b,c:d\"\nvar ss4 = \"a:b,c:d\"\nvar ss5 = \"a:b,c:d\"\nvar ss6 = \"a:b,c:d\"\nvar ss7 = \"a:b,c:d\"\nvar ss8 = \"a:b,c:d\"\nvar ss9 = \"a:b,c:d\"\nvar ss10 = \"a:b,c:d\"\nvar ss11 = \"a:b,c:d\"\nvar ss12 = \"a:b,c:d\"\nvar ss13 = \"a:b,c:d\"\nvar ss14 = \"a:b,c:d\"\nvar ss15 = \"a:b,c:d\"\nvar ss16 = \"a:b,c:d\"\nvar ss17 = \"a:b,c:d\"\nvar ss18 = \"a:b,c:d\"\nvar ss19 = \"a:b,c:d\"\nvar ss20 = \"a:b,c:d\"\nvar ss21 = \"a:b,c:d\"\nvar ss22 = \"a:b,c:d\"\nvar ss23 = \"a:b,c:d\"\nvar ss24 = \"a:b,c:d\"\nvar ss25 = \"a:b,c:d\"\nvar ss26 = \"a:b,c:d\"\nvar ss27 = \"a:b,c:d\"\nvar ss28 = \"a:b,c:d\"\nvar ss29 = \""}
{"tgt": "nlen := len(nums)\nfor i := 0; i < nlen-2; i++ {\n\tif i != 0 && nums[i] == nums[i-1] {\n\t\tcontinue\n\t}\n\tleft, right := i+1, nlen-1\n\tfor left < right {\n\t\tsum := nums[i] + nums[left] + nums[right]\n\t\tif sum == target {\n\t\t\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tleft++\n\t\t\tright--\n\t\t} else if sum < target {\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tleft++\n\t\t} else {\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tright--\n\t\t}\n\t}\n}", "gen": "var a [3]int\nvar b [4]int\nvar c [5]int\nvar d [6]int\nvar e [7]int\nvar f [8]int\nvar g [9]int\nvar h [10]int\nvar i [11]int\nvar j [12]int\nvar k [13]int\nvar l [14]int\nvar m [15]int\nvar n [16]int\nvar o [17]int\nvar p [18]int\nvar q [19]int\nvar r [20]int\nvar s [21]int\nvar t [22]int\nvar u [23]int\nvar v [24]int\nvar w [25]int\nvar x [26]int\nvar y [27]int\nvar z [28]int\nvar aa [29]int\nvar ab [30]int\nvar ac [31]int\nvar ad [32]int\nvar ae [33]int\nvar af [34]int\nvar ag [35]int\nvar ah [36]int\nvar ai [37]int\nvar aj [38]int\nvar ak [39]int\nvar al [40]int\nvar am [41]int\nvar an [42]int\nvar ao [43]int\nvar ap [44]int\nvar aq [45]int\nvar ar [46]int\nvar as [47]int\nvar at [48]int\nvar au [49]int\nvar av [50]int\nvar aw [51]int\nvar ax [52]int\nvar ay [53]int\nvar az [54]int\nvar ba [55]int\nvar bb [56]int\nvar bc [57]int\nvar bd [58]"}
{"tgt": "sLen, tLen := len(s), len(t)\nneed := [256]int{}\nfor i := range t {\n\tneed[t[i]]++\n}\nhas := [256]int{}\nmin := sLen + 1\nbegin, end, winBegin, winEnd, count := 0, 0, 0, 0, 0\nfor ; end < sLen; end++ {\n\tif need[s[end]] == 0 {\n\t\tcontinue\n\t}\n\tif has[s[end]] < need[s[end]] {\n\t\tcount++\n\t}\n\thas[s[end]]++\n\tif count == tLen {\n\t\tfor need[s[begin]] == 0 || has[s[begin]] > need[s[begin]] {\n\t\t\tif has[s[begin]] > need[s[begin]] {\n\t\t\t\thas[s[begin]]--\n\t\t\t}\n\t\t\tbegin++\n\t\t}\n\t\ttemp := end - begin + 1\n\t\tif min > temp {\n\t\t\tmin = temp\n\t\t\twinBegin = begin\n\t\t\twinEnd = end\n\t\t}\n\t}\n}\nif count < tLen {\n\treturn \"STR\"\n}\nreturn s[winBegin : winEnd+1]", "gen": "var s []byte\nvar p []byte\nvar n int\nvar i int\nvar c byte\nvar r rune\nvar b byte\nvar j int\nvar k int\nvar l int\nvar m int\nvar nn int\nvar nn1 int\nvar nn2 int\nvar nn3 int\nvar nn4 int\nvar nn5 int\nvar nn6 int\nvar nn7 int\nvar nn8 int\nvar nn9 int\nvar nn10 int\nvar nn11 int\nvar nn12 int\nvar nn13 int\nvar nn14 int\nvar nn15 int\nvar nn16 int\nvar nn17 int\nvar nn18 int\nvar nn19 int\nvar nn20 int\nvar nn21 int\nvar nn22 int\nvar nn23 int\nvar nn24 int\nvar nn25 int\nvar nn26 int\nvar nn27 int\nvar nn28 int\nvar nn29 int\nvar nn30 int\nvar nn31 int\nvar nn32 int\nvar nn33 int\nvar nn34 int\nvar nn35 int\nvar nn36 int\nvar nn37 int\nvar nn38 int\nvar nn39 int\nvar nn40 int\nvar nn41 int\nvar nn42 int\nvar nn43 int\nvar nn44 int\nvar nn45 int\nvar nn46 int\nvar nn47 int\nvar nn48 int\nvar nn49 int\nvar nn50 int\nvar nn51 int\nvar nn52 int\nvar nn53 int\nvar nn54 int\nvar nn55 int\nvar nn5"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif steps := MinimumStepsPath(tc.path); steps != tc.minimumSteps {\n\t\tt.Errorf(\"STR\", tc.minimumSteps, steps)\n\t}\n}", "gen": "fmt.Println(\"Hello, \u4e16\u754c\")\n}\n"}
{"tgt": "n := len(cost)\ndp := make([]int, n)\ndp[0], dp[1] = cost[0], cost[1]\nfor i := 2; i < n; i++ {\n\tdp[i] = cost[i] + min(dp[i-2], dp[i-1])\n}\nreturn min(dp[n-2], dp[n-1])", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar b = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar c = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar d = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar e = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar f = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar g = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar h = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar i = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar j = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar k = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar m = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar n = []int"}
{"tgt": "qs := []question845{\n\t{\n\t\tpara845{[]int{875, 884, 239, 731, 723, 685}},\n\t\tans845{4},\n\t},\n\t{\n\t\tpara845{[]int{0, 1, 2, 3, 4, 5, 4, 3, 2, 1, 0}},\n\t\tans845{11},\n\t},\n\t{\n\t\tpara845{[]int{2, 3}},\n\t\tans845{0},\n\t},\n\t{\n\t\tpara845{[]int{2, 1, 4, 7, 3, 2, 5}},\n\t\tans845{5},\n\t},\n\t{\n\t\tpara845{[]int{2, 2, 2}},\n\t\tans845{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans845, q.para845\n\tfmt.Printf(\"STR\", p, longestMountain(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "res := make([]int, 0)\nfor i := 0; i < len(nums); i = i + 2 {\n\tfreq, val := nums[i], nums[i+1]\n\tfor j := 0; j < freq; j++ {\n\t\tres = append(res, val)\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nfor i := 0; i < len(a); i++ {\n\ta[i] = i\n\tb[i] = i\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = a[i] + b[i]\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "defer wg.Done()\nfor v := range taskQueue {\n\tfmt.Printf(\"STR\", workerId, v.Id, v.JobId)\n\tv.Run()\n\tfmt.Printf(\"STR\", workerId, v.Status, v.Id, v.JobId)\n}", "gen": "var ch chan int\nvar i int\nvar t *Task\nvar t2 *Task\nvar t3 *Task\nvar t4 *Task\nvar t5 *Task\nvar t6 *Task\nvar t7 *Task\nvar t8 *Task\nvar t9 *Task\nvar t10 *Task\nvar t11 *Task\nvar t12 *Task\nvar t13 *Task\nvar t14 *Task\nvar t15 *Task\nvar t16 *Task\nvar t17 *Task\nvar t18 *Task\nvar t19 *Task\nvar t20 *Task\nvar t21 *Task\nvar t22 *Task\nvar t23 *Task\nvar t24 *Task\nvar t25 *Task\nvar t26 *Task\nvar t27 *Task\nvar t28 *Task\nvar t29 *Task\nvar t30 *Task\nvar t31 *Task\nvar t32 *Task\nvar t33 *Task\nvar t34 *Task\nvar t35 *Task\nvar t36 *Task\nvar t37 *Task\nvar t38 *Task\nvar t39 *Task\nvar t40 *Task\nvar t41 *Task\nvar t42 *Task\nvar t43 *Task\nvar t44 *Task\nvar t45 *Task\nvar t46 *Task\nvar t47 *Task\nvar t48 *Task\nvar t49 *Task\nvar t50 *Task\nvar t51 *Task\nvar t52 *Task\nvar t53 *Task\nvar t54 *Task\nvar t55 *Task\nvar t56 *Task\nvar t57 *Task\nvar t58 *Task\nvar t59 *Task\nvar t60 *Task\nvar t61 *Task\nvar t62 *Task\nvar"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := Reverse32Bits(tc.given); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "fmt.Println(Reverse32Bits(123456789))\nfmt.Println(Reverse32Bits(12345678))\nfmt.Println(Reverse32Bits(1234567))\nfmt.Println(Reverse32Bits(123456))\nfmt.Println(Reverse32Bits(12345))\nfmt.Println(Reverse32Bits(1234))\nfmt.Println(Reverse32Bits(123))\nfmt.Println(Reverse32Bits(12))\nfmt.Println(Reverse32Bits(1))\nfmt.Println(Reverse32Bits(0))\n}\n"}
{"tgt": "dummy := &ListNode{0, head}\nslow, fast := dummy, dummy\nfor fast.Next != nil && fast.Next.Next != nil {\n\tfast = fast.Next.Next\n\tslow = slow.Next\n}\nreturn slow.Next", "gen": "var a [2]int\na[0] = 1\na[1] = 2\nvar b [2]int\nb[0] = 3\nb[1] = 4\nvar c [2]int\nc[0] = 5\nc[1] = 6\nvar d [2]int\nd[0] = 7\nd[1] = 8\nvar e [2]int\ne[0] = 9\ne[1] = 10\nvar f [2]int\nf[0] = 11\nf[1] = 12\nvar g [2]int\ng[0] = 13\ng[1] = 14\nvar h [2]int\nh[0] = 15\nh[1] = 16\nvar i [2]int\ni[0] = 17\ni[1] = 18\nvar j [2]int\nj[0] = 19\nj[1] = 20\nvar k [2]int\nk[0] = 21\nk[1] = 22\nvar l [2]int\nl[0] = 23\nl[1] = 24\nvar m [2]int\nm[0] = 25\nm[1] = 26\nvar n [2]int\nn[0] = 27\nn[1] = 28\nvar o [2]int\no[0] = 29\no[1] = 30\nvar p [2]int\np[0] = 31\np[1] = 32\nvar q [2]int\nq[0] = 33\nq[1] = 34\nvar r [2]int\nr[0] = 35\nr[1] = 36\nvar s [2"}
{"tgt": "fmt.Println(superEggDrop(1, 2))\nfmt.Println(superEggDrop(2, 6))\nfmt.Println(superEggDrop(2, 4))", "gen": "fmt.Println(superEggDrop(2, 1))\nfmt.Println(superEggDrop(2, 2))\nfmt.Println(superEggDrop(3, 2))\n}\n"}
{"tgt": "var res []int\nstack := []*preOrderTree{root}\nfor len(stack) > 0 {\n\troot = stack[0]\n\tstack = stack[1:]\n\tres = append(res, root.data)\n\tif root.left != nil {\n\t\tstack = append(stack, root.left)\n\t}\n\tif root.right != nil {\n\t\tstack = append(stack, root.right)\n\t}\n}\nreturn res", "gen": "var a []preOrderTree\na = append(a, preOrderTree{1})\na = append(a, preOrderTree{2})\na = append(a, preOrderTree{3})\na = append(a, preOrderTree{4})\na = append(a, preOrderTree{5})\na = append(a, preOrderTree{6})\na = append(a, preOrderTree{7})\na = append(a, preOrderTree{8})\na = append(a, preOrderTree{9})\na = append(a, preOrderTree{10})\na = append(a, preOrderTree{11})\na = append(a, preOrderTree{12})\na = append(a, preOrderTree{13})\na = append(a, preOrderTree{14})\na = append(a, preOrderTree{15})\na = append(a, preOrderTree{16})\na = append(a, preOrderTree{17})\na = append(a, preOrderTree{18})\na = append(a, preOrderTree{19})\na = append(a, preOrderTree{20})\na = append(a, preOrderTree{21})\na = append(a, preOrderTree{22})\na = append(a, preOrderTree{23})\na = append(a, preOrderTree{24})\na = append(a, preOrderTree{25})\na = append(a, preOrderTree{26})\na = append(a, preOrderTree{27})\na = append(a, preOrderTree{28})\na = append(a, preOrderTree{29})\na = append(a, preOrderTree{30})\na = append(a, preOrderTree{31})\na = append(a, preOrderTree{32})\na = append(a, preOrderTree{33})\na = append(a"}
{"tgt": "l, r := 0, 0\nn := len(s)\nfor i := 0; i < n; i++ {\n\tif s[i] == ')' {\n\t\tl--\n\t} else {\n\t\tl++\n\t}\n\tj := n - i - 1\n\tif s[j] == '(' {\n\t\tr--\n\t} else {\n\t\tr++\n\t}\n\tif l < 0 || r < 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var s string\nvar i int\nvar b bool\ns = \"Hello, world!\"\ni = 0\nb = false\nfor i < len(s) {\n\tif s[i] == '!' {\n\t\tbreak\n\t}\n\ti++\n}\nif i == len(s) {\n\tb = true\n}\nif b {\n\tfmt.Println(\"No exclamation point found\")\n} else {\n\tfmt.Println(\"Found an exclamation point\")\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA\n\tC int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif !ok {\n\tt.Error(\"STR\")\n}", "gen": "var t TestHasZero_Nested\nt.B.i1.d = 123\nif !reflect.DeepEqual(t, TestHasZero_Nested{B: B{i1: i1{d: 123}}}) {\n\tt.Error(\"t != TestHasZero_Nested{B: B{i1: i1{d: 123}}}\")\n}\n}\n\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested.B.i1.d\n// TestHasZero_Nested"}
{"tgt": "for i, row := range matrix[1:] {\n\tfor j, v := range row[1:] {\n\t\tif v != matrix[i][j] {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "qs := []question28{\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{2},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{5},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{-1},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans28, q.para28\n\tfmt.Printf(\"STR\", p, strStr(p.s, p.p))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(strStr(\"hello\", \"ll\"))\nfmt.Println(strStr(\"aaaaa\", \"bba\"))\nfmt.Println(strStr(\"\", \"\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println"}
{"tgt": "digits := \"STR\"\nfor i := 1; i < 9999; i++ {\n\tnum := \"STR\"\n\tfor j := 1; j < 5; j++ {\n\t\tif len(num) < 9 {\n\t\t\tnum += strconv.Itoa(i * j)\n\t\t}\n\t}\n\tarr := strings.Split(num, \"STR\")\n\tsort.Strings(arr)\n\tnumSorted := strings.Join(arr, \"STR\")\n\tif numSorted == digits {\n\t\treturn num\n\t}\n}\nreturn \"STR\"", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a1 int\nvar b1 int\nvar c1 int\nvar d1 int\nvar e1 int\nvar f1 int\nvar g1 int\nvar h1 int\nvar i1 int\nvar j1 int\nvar k1 int\nvar l1 int\nvar m1 int\nvar n1 int\nvar o1 int\nvar p1 int\nvar q1 int\nvar r1 int\nvar s1 int\nvar t1 int\nvar u1 int\nvar v1 int\nvar w1 int\nvar x1 int\nvar y1 int\nvar z1 int\nvar a2 int\nvar b2 int\nvar c2 int\nvar d2 int\nvar e2 int\nvar f2 int\nvar g2 int\nvar h2 int\nvar i2 int\nvar j2 int\nvar k2 int\nvar l2 int\nvar m2 int\nvar n2 int\nvar o2 int\nvar p2 int\nvar q2 int\nvar r2 int\nvar s2 int\nvar t2 int\nvar u2 int\nvar v2 int\nvar w2 int\nvar x2 int\nvar y2 int\nvar z2 int\nvar a3 int\nvar b3 int\nvar c3 int\nvar d3 int\nvar e3 int\nvar f3 int\nvar g3 int\nvar h3 int\nvar i3 int\nvar j3"}
{"tgt": "obj := Constructor933()\nfmt.Printf(\"STR\", obj)\nparam1 := obj.Ping(1)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(100)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(3001)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(3002)\nfmt.Printf(\"STR\", param1)", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "root := new(*TreeNode)\ninsertArrayToTreeNode(root, array, 0)\nreturn *root", "gen": "var root *TreeNode\nroot = insertArrayToTreeNode([]int{1, 2, 3}, 0)\nfmt.Println(root)\n}\n"}
{"tgt": "res := 0\nsort.Ints(houses)\nsort.Ints(heaters)\nm, n := len(houses), len(heaters)\nindex := sort.SearchInts(heaters, houses[0])\nfor _, house := range houses {\n\tfor index < n && house > heaters[index] {\n\t\tindex++\n\t}\n\tif index == n {\n\t\treturn max(res, houses[m-1]-heaters[index-1])\n\t}\n\tleft := math.MaxInt32\n\tif index > 0 {\n\t\tleft = house - heaters[index-1]\n\t}\n\tright := heaters[index] - house\n\tres = max(res, min(left, right))\n}\nreturn res", "gen": "fmt.Println(maxProfit([]int{7, 1, 5, 3, 6, 4}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5}))\nfmt.Println(maxProfit([]int{7, 6, 4, 3, 1}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}))\nfmt.Println(maxProfit([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}))\nfmt.Println(maxProfit([]"}
{"tgt": "c := Candidates(candidates)\nsort.Sort(c)\nreturn orderedCombinationSum2(c, target)", "gen": "var nums = []int{10, 1, 2, 7, 6, 1, 5}\nvar target = 8\nvar result = combinationSum2(nums, target)\nfmt.Println(result)\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tresults := HeapsAlgorithmRecursive(tc.input)\n\tpos := 0\n\tfor result := range results {\n\t\tif !reflect.DeepEqual(result, tc.expected[pos]) {\n\t\t\tt.Errorf(\"STR\", tc.expected[pos], result)\n\t\t}\n\t\tpos++\n\t}\n}", "gen": "fmt.Println(\"Hello, World!\")\n}\n"}
{"tgt": "for i := 1; i < len(nums); i++ {\n\tif nums[i-1] > nums[i] {\n\t\tpre := deepCopy(nums)\n\t\tpre[i-1] = pre[i]\n\t\tnext := deepCopy(nums)\n\t\tnext[i] = next[i-1]\n\t\treturn sort.IsSorted(sort.IntSlice(pre)) || sort.IsSorted(sort.IntSlice(next))\n\t}\n}\nreturn true", "gen": "var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar b = make([]int, len(a))\ncopy(b, a)\nsort.Ints(b)\nfmt.Println(b)\n}\n"}
{"tgt": "res := []int{}\nfor _, num := range nums {\n\tn := num\n\tif n < 0 {\n\t\tn *= -1\n\t}\n\tif nums[n-1] < 0 {\n\t\tres = append(res, n)\n\t} else {\n\t\tnums[n-1] *= -1\n\t}\n}\nreturn res", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb := a[1:2]\nb[0] = 4\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "qs := []question1281{\n\t{\n\t\tpara1281{234},\n\t\tans1281{15},\n\t},\n\t{\n\t\tpara1281{4421},\n\t\tans1281{21},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1281, q.para1281\n\tfmt.Printf(\"STR\", p, subtractProductAndSum(p.n))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "fp := float64(p)\nfa := float64(a)\nfb := (fp * (fp - 2.0*fa)) / (2.0 * (fp - fa))\nb = int(fb)\nvalid = math.Abs(fb-math.Floor(fb)) < 0.000001\nreturn", "gen": "var a, b float64\nfmt.Scan(&a, &b)\nif a > b {\n\ta, b = b, a\n}\nc := math.Floor(a / b)\nd := math.Abs(a - b * c)\nif d < 1e-10 {\n\tc++\n}\nfmt.Println(c)\n}\n\n<ASM>\n.LFB2:\nmovq %rdi,-8(%rbp)\nmovq %rsi,-16(%rbp)\nmovq -8(%rbp),%rax\nmovq -16(%rbp),%rdx\nmovq %rax,%rsi\nmovq %rdx,%rdi\ncall <main.main@PLT>\nmovq %rax,%rdi\ncall <runtime.exit@PLT>\n.LFE2:\n.size main,.-main</ASM>"}
{"tgt": "start := -1\nlenMax := 0\ndict := [256]int{}\nfor i := range dict {\n\tdict[i] = -1\n}\nfor i, r := range s {\n\tif v := dict[r]; v > start {\n\t\tstart = v\n\t}\n\tlength := i - start\n\tif length > lenMax {\n\t\tlenMax = length\n\t}\n\tdict[r] = i\n}\nreturn lenMax", "gen": "var s []byte\nvar i int\nfor i = 0; i < 256; i++ {\n\tr, _ := utf8.DecodeRune(s)\n\tif r == -1 {\n\t\tbreak\n\t}\n\tif r > 127 {\n\t\tpanic(\"\")\n\t}\n\ts = s[r:]\n}\nif i != 256 {\n\tpanic(\"\")\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return &skipListNode{v: v, score: score, forwards: make([]*skipListNode, level, level), level: level}", "gen": "var s []skipListNode\ns = append(s, skipListNode{})\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "m := [26]int{}\nfor _, b := range B {\n\tcount := counter(b)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tm[i] = count[i]\n\t\t}\n\t}\n}\nres := []string{}\nfor _, a := range A {\n\tcount := counter(a)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tcontinueL\n\t\t}\n\t}\n\tres = append(res, a)\n}\nreturn res", "gen": "var a = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\nvar b = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\nvar c = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\nvar d = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\nvar e = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\nvar f = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\","}
{"tgt": "bulls, cows := 0, 0\nnums := [10]int{}\nfor i := 0; i < len(secret); i++ {\n\ts, g := int(secret[i]-'0'), int(guess[i]-'0')\n\tif s == g {\n\t\tbulls++\n\t} else {\n\t\tif nums[s] < 0 {\n\t\t\tcows++\n\t\t}\n\t\tif nums[g] > 0 {\n\t\t\tcows++\n\t\t}\n\t\tnums[s]++\n\t\tnums[g]--\n\t}\n}\nreturn fmt.Sprintf(\"STR\", bulls, cows)", "gen": "var a [10]int\nvar b [10]int\nvar c [2]int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\n"}
{"tgt": "t.Parallel()\nfor _, l := range mathTestData {\n\tif log2Floor(l.n) != l.f || log2Ceil(l.n) != l.c {\n\t\tt.Errorf(\"STR\",\n\t\t\tl.n, l.f, l.c, log2Floor(l.n), log2Ceil(l.n))\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "bs := strings.Builder{}\nvar dfs func(*TreeNode)\ndfs = func(node *TreeNode) {\n\tif node == nil {\n\t\treturn\n\t}\n\tbs.WriteString(strconv.Itoa(node.Val))\n\tif node.Left == nil && node.Right == nil {\n\t\treturn\n\t}\n\tbs.WriteByte('(')\n\tif node.Left != nil {\n\t\tdfs(node.Left)\n\t}\n\tbs.WriteByte(')')\n\tif node.Right != nil {\n\t\tbs.WriteByte('(')\n\t\tdfs(node.Right)\n\t\tbs.WriteByte(')')\n\t}\n}\ndfs(t)\nreturn bs.String()", "gen": "root := &TreeNode{Val: 1}\nroot.Left = &TreeNode{Val: 2}\nroot.Right = &TreeNode{Val: 3}\nroot.Left.Left = &TreeNode{Val: 4}\nroot.Left.Right = &TreeNode{Val: 5}\nroot.Right.Left = &TreeNode{Val: 6}\nroot.Right.Right = &TreeNode{Val: 7}\nroot.Right.Right.Left = &TreeNode{Val: 8}\nroot.Right.Right.Right = &TreeNode{Val: 9}\nroot.Right.Right.Right.Left = &TreeNode{Val: 10}\nroot.Right.Right.Right.Right = &TreeNode{Val: 11}\nroot.Right.Right.Right.Right.Left = &TreeNode{Val: 12}\nroot.Right.Right.Right.Right.Right = &TreeNode{Val: 13}\nroot.Right.Right.Right.Right.Right.Left = &TreeNode{Val: 14}\nroot.Right.Right.Right.Right.Right.Right = &TreeNode{Val: 15}\nroot.Right.Right.Right.Right.Right.Right.Left = &TreeNode{Val: 16}\nroot.Right.Right.Right.Right.Right.Right.Right = &TreeNode{Val: 17}\nroot.Right.Right.Right.Right.Right.Right.Right.Left = &TreeNode{Val: 18}\nroot.Right.Right.Right.Right.Right.Right.Right.Right = &TreeNode{Val: 19}\nroot.Right.Right.Right.Right.Right.Right.Right.Right.Left = &TreeNode{Val: 20}\nroot.Right.Right.Right.Right.Right.Right.Right.Right.Right = &TreeNode{Val: 21}\nroot.Right.Right.Right.Right.Right.Right.Right.Right.Right.Left = &TreeNode{"}
{"tgt": "return nil == root || isSame(root.Left, root.Right)", "gen": "var a, b int\nfmt.Scan(&a, &b)\nif a == b {\n\tfmt.Println(\"true\")\n} else {\n\tfmt.Println(\"false\")\n}\n}\n"}
{"tgt": "cases := []struct {\n\tname      string\n\tflowerbed []int\n\tn         int\n\texpect    bool\n}{\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 1, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 2, false},\n\t{\"STR\", []int{1, 0, 1, 0}, 0, true},\n\t{\"STR\", []int{0}, 1, true},\n\t{\"STR\", []int{1, 0, 1, 0, 1, 0, 1}, 1, false},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.flowerbed, c.n)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.flowerbed, c.n)\n\t\t}\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "const maxDiv = 20\ni, div := maxDiv, maxDiv-1\nfor {\n\tif i%div == 0 {\n\t\tif div > 1 {\n\t\t\tdiv--\n\t\t} else {\n\t\t\tfmt.Println(i)\n\t\t\tos.Exit(0)\n\t\t}\n\t} else {\n\t\ti += maxDiv\n\t\tdiv = maxDiv - 1\n\t}\n}", "gen": "var a int\nvar b int\na = 20\nb = 19\nfor {\n\tif b == -1 {\n\t\tbreak\n\t}\n\tif b == 0 {\n\t\tpanicdivide()\n\t}\n\tif a % b == 0 {\n\t\tfmt.Println(a / b)\n\t\tos.Exit(0)\n\t}\n\tb--\n}\n}\n"}
