{"tgt": "fmt.Println(mostCommonWord(\"STR\", []string{\"STR\", \"STR\"}))", "gen": "fmt.Println(mostCommonWord(\"STR\", []string{\"STR\", \"STR\", \"STR\"}))\n}"}
{"tgt": "if nil == nums || len(nums) == 0 {\n\treturn\n}\ninsertPos := 0\nfor _, values := range nums {\n\tif 0 != values {\n\t\tnums[insertPos] = values\n\t\tinsertPos++\n\t}\n}\nfor insertPos < len(nums) {\n\tnums[insertPos] = 0\n\tinsertPos++\n}", "gen": "if len(nums) == 0 || len(nums) == 1 {\n\treturn\n}\nvar i int\nfor _, v := range nums {\n\tif v != 0 {\n\t\tnums[i] = v\n\t\ti++\n\t}\n}\nfor i < len(nums) {\n\tnums[i] = 0\n\ti++\n}\n}"}
{"tgt": "cases := []struct {\n\ta, b, expected int\n}{\n\t{\n\t\ta:        0,\n\t\tb:        0,\n\t\texpected: 0,\n\t},\n\t{\n\t\ta:        1,\n\t\tb:        1,\n\t\texpected: 1,\n\t},\n\t{\n\t\ta:        -1,\n\t\tb:        1,\n\t\texpected: -1,\n\t},\n\t{\n\t\ta:        1,\n\t\tb:        -1,\n\t\texpected: -1,\n\t},\n\t{\n\t\ta:        10,\n\t\tb:        2,\n\t\texpected: 2,\n\t},\n}\nfor _, c := range cases {\n\tactual := Min(c.a, c.b)\n\tif actual != c.expected {\n\t\tt.Errorf(\"STR\", c.expected, actual)\n\t}\n}", "gen": "tests := []struct {\n\ta, b int\n\twant int\n}{\n\t{0, 0, 1},\n\t{1, 1, 1},\n\t{1, -1, -1},\n\t{10, 2, 2},\n}\nfor _, tt := range tests {\n\tif got := Min(tt.a, tt.b); got != tt.want {\n\t\tt.Errorf(\"STR\", tt.a, tt.b, tt.want, got)\n\t}\n}\n}"}
{"tgt": "ma := 0\nif len(heights) < 0 {\n\treturn 0\n}\nvar stack []int\nfor i := 0; i < len(heights); i++ {\n\tif i == 0 {\n\t\tstack = append(stack, heights[i])\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tcontinue\n\t}\n\tif heights[i-1] > heights[i] {\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tstack = changeStack(stack, heights[i])\n\t}\n\tstack = append(stack, heights[i])\n\tif i+1 == len(heights) {\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tcontinue\n\t}\n}\nreturn ma", "gen": "max := 0\nstack := []int{}\nfor i := 0; i < len(height); i++ {\n\tif len(stack) == 0 || height[i] >= height[stack[len(stack)-1]] {\n\t\tstack = append(stack, i)\n\t} else {\n\t\th := height[stack[len(stack)-1]]\n\t\tstack = stack[:len(stack)-1]\n\t\tmax = maxArea(max, h, i-stack[len(stack)-1])\n\t}\n}\nfor len(stack) > 0 {\n\th := height[stack[len(stack)-1]]\n\tstack = stack[:len(stack)-1]\n\tmax = maxArea(max, h, len(height)-stack[len(stack)-1]-1)\n}\nreturn max\n}"}
{"tgt": "min := func(a, b int) int {\n\treturn int(math.Min(float64(a), float64(b)))\n}\ndp := make([]int, 2)\ndp[0], dp[1] = cost[0], cost[1]\nfor i := 2; i < len(cost); i++ {\n\tdp[i%2] = cost[i] + min(dp[0], dp[1])\n}\nreturn min(dp[0], dp[1])", "gen": "var f func(int) int\nf = func(i int) int {\n\tif i < 2 {\n\t\treturn i\n\t}\n\treturn f(i-1) + f(i-2)\n}\ndp := make([]int, len(cost))\nfor i := 2; i < len(cost); i++ {\n\tdp[i] = f(cost[i])\n}\nreturn dp[len(cost)-1]\n}"}
{"tgt": "temp, mask := num, 0\nfor temp > 0 {\n\tmask = mask*2 + 1\n\ttemp /= 2\n}\nreturn mask ^ num", "gen": "n := x\nfor n != 0 {\n\tn = n >> 1\n\tn = n + n\n\tn = n >> 1\n}\nreturn x ^ n\n}"}
{"tgt": "listNode1 := &ListNode{\n\tVal: 4,\n\tNext: &ListNode{\n\t\tVal: 1,\n\t\tNext: &ListNode{\n\t\t\tVal:  4,\n\t\t\tNext: nil,\n\t\t},\n\t},\n}\nlistNode2 := &ListNode{\n\tVal: 1,\n\tNext: &ListNode{\n\t\tVal: 8,\n\t\tNext: &ListNode{\n\t\t\tVal:  4,\n\t\t\tNext: nil,\n\t\t},\n\t},\n}\ngetIntersectionNode(listNode1, listNode2)", "gen": "headA := &ListNode{4, nil}\nheadB := &ListNode{0, nil}\nheadC := &ListNode{4, nil}\nheadD := &ListNode{0, nil}\nheadE := &ListNode{1, nil}\nheadF := &ListNode{0, nil}\nheadA.Next = headB\nheadB.Next = headC\nheadC.Next = headD\nheadD.Next = headE\nheadE.Next = headF\nheadF.Next = headA\nheadG := &ListNode{1, nil}\nheadH := &ListNode{0, nil}\nheadG.Next = headH\nheadH.Next = headA\nheadI := &ListNode{4, nil}\nheadJ := &ListNode{0, nil}\nheadI.Next = headJ\nheadJ.Next = headA\nres := getIntersectionNode(headA, headG)\nfmt.Println(res)\n}"}
{"tgt": "switch {\ncase isIPv4(IP):\n\treturn \"STR\"\ncase isIPv6(IP):\n\treturn \"STR\"\ndefault:\n\treturn \"STR\"\n}", "gen": "if isIPv4(IP) {\n\treturn \"IPv4\"\n}\nif isIPv6(IP) {\n\treturn \"IPv6\"\n}\nreturn \"Neither\"\n}"}
{"tgt": "l := len(preorder)\nif l == 0 {\n\treturn nil\n}\nfor 1 < l && preorder[0] < preorder[l-1] {\n\tl--\n}\nreturn &TreeNode{\n\tVal:   preorder[0],\n\tLeft:  bstFromPreorder(preorder[1:l]),\n\tRight: bstFromPreorder(preorder[l:]),\n}", "gen": "n := len(preorder)\nif n == 0 {\n\treturn nil\n}\nif n == 1 {\n\treturn &TreeNode{Val: preorder[0]}\n}\nif preorder[0] < preorder[n-1] {\n\treturn &TreeNode{\n\t\tVal:   preorder[0],\n\t\tLeft:  bstFromPreorder(preorder[1 : n-1]),\n\t\tRight: bstFromPreorder(preorder[n-1:]),\n\t}\n}\nreturn &TreeNode{\n\tVal:   preorder[0],\n\tLeft:  bstFromPreorder(preorder[1:n-1]),\n\tRight: bstFromPreorder(preorder[n-1:]),\n}\n}"}
{"tgt": "sort.Slice(costs, func(i, j int) bool {\n\treturn abs(costs[i][0]-costs[i][1]) > abs(costs[j][0]-costs[j][1])\n})\ncost, a, b, n := 0, 0, 0, len(costs)/2\nfor _, c := range costs {\n\tif (c[0] < c[1] && a < n) || b == n {\n\t\tcost += c[0]\n\t\ta++\n\t} else {\n\t\tcost += c[1]\n\t\tb++\n\t}\n}\nreturn cost", "gen": "var cost func(int, int) int\ncost = func(i, j int) int {\n\treturn abs(profit[i] - profit[j]) + abs(weight[i] - weight[j])\n}\nsort.Slice(profit, func(i, j int) bool {\n\treturn cost(i, j) < cost(j, i)\n})\nvar minCost int\nfor i := 0; i < len(profit)/2; i++ {\n\tif cost(i, i+len(profit)/2) < cost(i+len(profit)/2, i) {\n\t\tminCost += profit[i]\n\t} else {\n\t\tminCost += profit[i+len(profit)/2]\n\t}\n}\nreturn minCost\n}"}
{"tgt": "println(\"STR\")\nprintln(\"STR\", v1)\nprintln(\"STR\", v2.x, v2.y)\nprintln(\"STR\", len(v3), cap(v3), v3[0], v3[3])\nprintln(\"STR\", len(v4), v4 == nil)\nprintln(\"STR\", len(v5), v5 == nil)\nprintln(\"STR\", v6)\nprintln(\"STR\", cap(v7), string(v7))\nprintln(uint8SliceSrc[0])\nprintln(uint8SliceDst[0])\nprintln(intSliceSrc[0])\nprintln(intSliceDst[0])", "gen": "println(\"STR\")\nprintln(v1, v2, v3[0], v3[1], v3[2], v3[3], v4, v5, v6, v7)\nprintln(v7 == v4)\nprintln(\"STR\", v7, v4)\nprintln(v7 == v4)\nprintln(\"STR\", v7, v4)\nprintln(uint8SliceSrc[0], uint8SliceDst[0], intSliceSrc[0], intSliceDst[0])\n}"}
{"tgt": "words := strings.Fields(s)\nreturn strings.Join(reverseSlice(words), \"STR\")", "gen": "return strings.Join(reverseSlice(strings.Fields(s)), \"STR\")\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect bool\n}{\n\t{\"STR\", []int{1, 2, 2, 3}, true},\n\t{\"STR\", []int{4, 3, 3, 2}, true},\n\t{\"STR\", []int{1, 3, 2}, false},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect bool\n}{\n\t{\"STR\", []int{1, 2, 2, 3}, true},\n\t{\"STR\", []int{4, 3, 3, 2}, false},\n\t{\"STR\", []int{1, 3, 2}, false},\n}\nfor i, c := range cases {\n\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := isStraight(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}\n}"}
{"tgt": "indexs := make([]int, 123)\nfor i, c := range order {\n\tindexs[c] = i\n}\nless := func(i, j int) bool {\n\tsi, sj := len(words[i]), len(words[j])\n\tfor k := 0; k < si && k < sj; k++ {\n\t\tii, ij := indexs[words[i][k]], indexs[words[j][k]]\n\t\tswitch {\n\t\tcase ii < ij:\n\t\t\treturn true\n\t\tcase ii > ij:\n\t\t\treturn false\n\t\t}\n\t}\n\treturn si <= sj\n}\nfor i := 1; i < len(words); i++ {\n\tif !less(i-1, i) {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "words := make([]string, 0, 123)\nfor _, word := range wordsStr {\n\twords = append(words, string(word))\n}\nfor i := 0; i < len(words); i++ {\n\twords[i] = string(words[i][0])\n}\nreturn func(order string, word string) bool {\n\tfor i := 0; i < len(order); i++ {\n\t\tif order[i] > word[0] {\n\t\t\treturn false\n\t\t}\n\t\tword = word[1:]\n\t}\n\treturn true\n}\n}"}
{"tgt": "row := len(grid)\ncol := len(grid[0])\ndp := make([][]int, row)\nfor i := 0; i < row; i++ {\n\tdp[i] = make([]int, col)\n}\ndp[0][0] = grid[0][0]\nfor i := 1; i < row; i++ {\n\tdp[i][0] = dp[i-1][0] + grid[i][0]\n}\nfor i := 1; i < col; i++ {\n\tdp[0][i] = dp[0][i-1] + grid[0][i]\n}\nfor i := 1; i < row; i++ {\n\tfor j := 1; j < col; j++ {\n\t\tdp[i][j] = Min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\t}\n}\nreturn dp[row-1][col-1]", "gen": "n := len(A)\ndp := make([][]int, n)\nfor i := 0; i < n; i++ {\n\tdp[i] = make([]int, n)\n}\nfor i := 0; i < n; i++ {\n\tdp[i][i] = A[i]\n}\nfor i := 1; i < n; i++ {\n\tfor j := 0; j < i; j++ {\n\t\tdp[i][j] = Min(dp[i-1][j], dp[i-1][j+1]) + A[i]\n\t}\n}\nfor i := n - 2; i >= 0; i-- {\n\tfor j := 0; j < i; j++ {\n\t\tdp[i][j] = Min(dp[i+1][j], dp[i+1][j+1]) + A[i]\n\t}\n}\nreturn dp[n-1][0]\n}"}
{"tgt": "fmt.Fprint(w, \"STR\")", "gen": "fmt.Fprint(w, \"STR\")\n}"}
{"tgt": "l := len(nums)\nk %= l\ns := make([]int, l)\ncopy(s, nums)\nfor i, v := range s[l-k:] {\n\tnums[i] = v\n}\nfor i, v := range s[:l-k] {\n\tnums[k+i] = v\n}", "gen": "n := len(nums)\nnums = nums[:n-k]\nfor i, v := range nums {\n\tnums[i] = v\n}\nfor i, v := range nums {\n\tnums[i] = v\n}\nfor i := range nums {\n\tnums[i] = nums[i+k]\n}\n}"}
{"tgt": "if p == nil || q == nil {\n\treturn p == q\n}\nreturn isSameTree(p.Left, q.Left) && p.Val == q.Val && isSameTree(p.Right, q.Right)", "gen": "if p == nil && q == nil {\n\treturn true\n}\nif p == nil || q == nil {\n\treturn false\n}\nreturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\n}"}
{"tgt": "for cur := t.root; cur != nil; {\n\tif cur.Key == key {\n\t\treturn cur\n\t} else if key < cur.Key {\n\t\tcur = cur.left\n\t} else {\n\t\tcur = cur.right\n\t}\n}\nreturn nil", "gen": "current := b.root\nfor current != nil {\n\tif current.value == value {\n\t\treturn &current.bstElement\n\t} else if current.value < value {\n\t\tcurrent = current.right\n\t} else {\n\t\tcurrent = current.left\n\t}\n}\nreturn nil\n}"}
{"tgt": "s := []int{}\nfor _, asteroid := range asteroids {\n\tfor len(s) != 0 && s[len(s)-1] > 0 && s[len(s)-1] < -asteroid {\n\t\ts = s[:len(s)-1]\n\t}\n\tif len(s) == 0 || asteroid > 0 || s[len(s)-1] < 0 {\n\t\ts = append(s, asteroid)\n\t} else if asteroid < 0 && s[len(s)-1] == -asteroid {\n\t\ts = s[:len(s)-1]\n\t}\n}\nreturn s", "gen": "res := []int{}\nfor _, num := range nums {\n\tif len(res) == 0 || res[len(res)-1] < num {\n\t\tres = append(res, num)\n\t} else if res[len(res)-1] > num {\n\t\tres = append(res, 0)\n\t\tres[len(res)-2] = num\n\t}\n}\nreturn res\n}"}
{"tgt": "sum := 0\nsunday := 5\nyear := 1901\nis_leap := false\nfor year < 2001 {\n\tchecker := month_len\n\tif is_leap {\n\t\tchecker = leap_len\n\t}\n\ttally := sunday\n\tfor _, v := range checker {\n\t\tif tally == 0 {\n\t\t\tsum += 1\n\t\t}\n\t\tif tally < v {\n\t\t\tbreak\n\t\t}\n\t\tif tally >= v {\n\t\t\ttally -= v\n\t\t}\n\t}\n\tsunday += 7\n\tif is_leap && sunday >= 366 {\n\t\tyear++\n\t\tsunday = sunday % 366\n\t\tis_leap = false\n\t} else if !is_leap && sunday >= 365 {\n\t\tyear++\n\t\tsunday = sunday % 365\n\t\tif year%4 == 0 {\n\t\t\tis_leap = true\n\t\t}\n\t}\n}\nfmt.Printf(\"STR\", year, sum)", "gen": "month_len := [...]int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}\nleap_len := [...]int{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}\nmonth_len_len := len(month_len)\nmonth := 5\nyear := 1901\nleap := false\nfor {\n\tif !leap {\n\t\tmonth_len = month_len[:]\n\t}\n\tfor _, day := range month_len {\n\t\tif day == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif day == 365 {\n\t\t\tyear++\n\t\t\tleap = false\n\t\t\tbreak\n\t\t}\n\t\tif day == 366 {\n\t\t\tyear++\n\t\t\tleap = true\n\t\t\tbreak\n\t\t}\n\t\tif day == 364 {\n\t\t\tyear++\n\t\t\tleap = false\n\t\t\tbreak\n\t\t}\n\t\tif day == 363 {\n\t\t\tyear++\n\t\t\tleap = true\n\t\t\tbreak\n\t\t}\n\t\tif day == 362 {\n\t\t\tyear++\n\t\t\tleap = false\n\t\t\tbreak\n\t\t}\n\t\tif day == 361 {\n\t\t\tyear++\n\t\t\tleap = true\n\t\t\tbreak\n\t\t}\n\t\tif day == 360 {\n\t\t\tyear++\n\t\t\tleap = false\n\t\t\tbreak\n\t\t}\n\t\tif day == 359 {\n\t\t\tyear"}
{"tgt": "max, winner := 0, 0\nfor i := 1; i < 1000000; i++ {\n\tterms := collatz(i)\n\tif terms > max {\n\t\tmax = terms\n\t\twinner = i\n\t}\n}\nfmt.Println(\"STR\", max, \"STR\", winner)", "gen": "max := 0\nmaxNum := 0\nfor i := 1; i < 1000000; i++ {\n\tn := collatz(i)\n\tif n > max {\n\t\tmax = n\n\t\tmaxNum = i\n\t}\n}\nfmt.Println(max, maxNum)\n}"}
{"tgt": "return fmt.Sprintf(\"STR\", c.FirstName, c.LastName, c.Email)", "gen": "return fmt.Sprintf(\"STR\", s.Str, s.Str2)\n}"}
{"tgt": "e.lgu = lgu\ne.mixin = mixin\ne.cluster = make(map[interface{}]*rsVEBTreeElement)\nif e.lgu > 1 {\n\te.summaryLgu = (e.lgu + 1) / 2\n\te.clusterLgu = e.lgu - e.summaryLgu\n\te.summary = new(rsVEBTreeElement).init(e.summaryLgu, e.mixin)\n} else {\n\te.summaryLgu = 0\n\te.clusterLgu = 0\n}\nreturn e", "gen": "t.root = key\nt.size = size\nif t.size > 1 {\n\tt.rs = t.rsVEBTreeElement{\n\t\tkey: t.root,\n\t\tsize: t.size,\n\t}\n\tt.root = t.size / 2\n\tt.size /= 2\n}\nreturn t\n}"}
{"tgt": "if isValid := checkHorizontal(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkVertical(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkReachable(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkRotationallySymmetric(puzzle); !isValid {\n\treturn false\n}\nreturn true", "gen": "if checkHorizontal(board) ||\n\tcheckVertical(board) ||\n\tcheckReachable(board) ||\n\tcheckRotationallySymmetric(board) {\n\treturn false\n}\nreturn true\n}"}
{"tgt": "b.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})", "gen": "b.Run(\"STR\", func(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSTR(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSTR(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSTR(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSTR(\"STR\")\n\t}\n})\n}"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := SumRevLLNum(tc.first, tc.second); !equal(result, tc.sum) {\n\t\tt.Errorf(\"STR\",\n\t\t\ttcid, String(result), String(tc.sum))\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SumRevLLNum(tc.input); !equal(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.input, result, tc.expected)\n\t}\n}\n}"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA `structs:\"STR\"`\n\tC  int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif ok {\n\tt.Error(\"STR\")\n}", "gen": "type B struct {\n\tA *structs.B\n}\nb := B{\n\tA: &structs.B{},\n}\nif HasZero(b) {\n\tt.Error(\"STR\")\n}\n}"}
{"tgt": "nums := []int{1, 1, 2, 2, 3, 3}\nfmt.Println(distributeCandies(nums))\nnums2 := []int{1, 1, 2, 3}\nfmt.Println(distributeCandies(nums2))", "gen": "candies := []int{1, 1, 2, 2, 3, 3}\nfmt.Println(distributeCandies(candies, 6))\nfmt.Println(distributeCandies(candies, 4))\n}"}
{"tgt": "i, j := start, len(nums)-1\nfor i < j {\n\tnums[i], nums[j] = nums[j], nums[i]\n\ti++\n\tj--\n}", "gen": "for i := 0; i < len(nums); i++ {\n\tfor j := len(nums) - 1; j > i; j-- {\n\t\tnums[i], nums[j] = nums[j], nums[i]\n\t}\n}\n}"}
{"tgt": "var val int\nfor n := uint(0); num != 0; num >>= 1 {\n\tval |= (1 - (num & 1)) << n\n\tn++\n}\nreturn val", "gen": "var ans uint64\nfor i := uint64(0); n > 0; i++ {\n\tans |= (n & 1) << i\n\tn >>= 1\n}\nreturn ans\n}"}
{"tgt": "size := len(A)\nres := make([]int, size)\neven, odd := 0, 1\nfor _, a := range A {\n\tif a%2 == 0 {\n\t\tres[even] = a\n\t\teven += 2\n\t} else {\n\t\tres[odd] = a\n\t\todd += 2\n\t}\n}\nreturn res", "gen": "n := len(nums)\nres := make([]int, 2*n)\ni, j := 0, 1\nfor _, num := range nums {\n\tif num&1 == 1 {\n\t\tres[i] = num\n\t\ti += 2\n\t} else {\n\t\tres[j] = num\n\t\tj += 2\n\t}\n}\nreturn res\n}"}
{"tgt": "slow, fast := head, head\nfor fast != nil && fast.Next != nil {\n\tslow = slow.Next\n\tfast = fast.Next.Next\n}\nvar prev *ListNode\nfor slow != nil {\n\tnext := slow.Next\n\tslow.Next = prev\n\tprev, slow = slow, next\n}\nfor p, q := head, prev; p != q; p, q = q, p {\n\tnext := p.Next\n\tp.Next = q\n\tp = next\n}", "gen": "head := l1\ntail := l1\nfor head != nil {\n\thead = head.Next\n\ttail = tail.Next\n}\nfor head := l1; head != nil; head = head.Next {\n\thead.Next = head.Next.Next\n}\nfor head := l1; head != nil; head = head.Next {\n\thead.Next = head.Next.Next\n}\n}"}
{"tgt": "for _, p := range perm6([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) {\n\tvalid := true\n\tfor _, g := range guesses {\n\t\tvar count int\n\t\tfor i := 0; i < len(p); i++ {\n\t\t\tif p[i] == g.Code[i] {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\tif count != g.Score {\n\t\t\tvalid = false\n\t\t\tbreak\n\t\t}\n\t}\n\tif valid {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "var res []int\nfor i := 0; i < 10; i++ {\n\tres = perm6(i)\n\tfor j := 0; j < len(res); j++ {\n\t\tif res[j] != res[0] {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true\n}"}
{"tgt": "for i := 0; i < 100000; i++ {\n\tif i%300 == 0 {\n\t\tarray := GetArrayOfSize(i)\n\t\tif len(array) != i {\n\t\t\tfmt.Println(array)\n\t\t\tt.Error()\n\t\t}\n\t}\n}", "gen": "for i := 0; i < 100000; i++ {\n\tif i%300 == 0 && i != 0 {\n\t\tfmt.Println(GetArrayOfSize(i))\n\t\tt.Error()\n\t}\n}\n}"}
{"tgt": "parent := this\nfor _, ch := range prefix {\n\tif child, ok := parent.Children[ch]; ok {\n\t\tparent = child\n\t\tcontinue\n\t}\n\treturn false\n}\nreturn true", "gen": "var node *Trie\nfor _, c := range s {\n\tif c > 127 {\n\t\treturn false\n\t}\n\tnode = node.children[c]\n\tif node == nil {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "sema <- struct{}{}\nb := balance\n<-sema\nreturn b", "gen": "balance <- 100\n<-sema\nreturn balance\n}"}
{"tgt": "pairs := [...][2]int{{10, 7}, {1000, 983}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p26(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "tests := [...]struct {\n\tin   int\n\twant int\n}{\n\t{10, 2},\n\t{7, 1},\n\t{1000, 983},\n\t{983, 983},\n}\nfor _, tt := range tests {\n\tgot := p26(tt.in)\n\tif got != tt.want {\n\t\tt.Errorf(\"STR\", tt.in, tt.want, got)\n\t}\n}\n}"}
{"tgt": "for i := 0; i < n; i++ {\n\tif len(squares) != i {\n\t\tprintln(\"STR\", len(squares), \"STR\", i)\n\t}\n\tsquares[i] = i * i\n\tfor j := 0; j <= i; j++ {\n\t\tif v, ok := squares[j]; !ok || v != j*j {\n\t\t\tif !ok {\n\t\t\t\tprintln(\"STR\", j)\n\t\t\t} else {\n\t\t\t\tprintln(\"STR\", j, v)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "for i := 0; i < n; i++ {\n\tif i == 0 {\n\t\tm[i] = 1\n\t} else {\n\t\tm[i] = i * m[i-1]\n\t}\n\tfor j := 0; j < i; j++ {\n\t\tif j%2 == 0 && j != 0 {\n\t\t\tfmt.Println(\"STR\", i, j)\n\t\t} else if j%2 == 1 && j != 0 {\n\t\t\tfmt.Println(\"STR\", i, j)\n\t\t}\n\t}\n}\n}"}
{"tgt": "for _, word := range words {\n\tremainNum[word] = 0\n}\nfor _, word := range words {\n\tremainNum[word]++\n}\nreturn 0", "gen": "m := make(map[string]int)\nfor _, v := range nums {\n\tm[v] = 0\n}\nfor _, v := range nums {\n\tm[v]++\n}\nfor k, v := range m {\n\tif v == 2 {\n\t\treturn k\n\t}\n}\nreturn \"\"\n}"}
{"tgt": "ad := admin{\n\tuser: user{\n\t\tname:  \"STR\",\n\t\temail: \"STR\",\n\t},\n\tlevel: \"STR\",\n}\nad.user.notify()\nad.notify()", "gen": "user.notify(STR, 10)\nadmin.notify(STR, 14)\n}"}
{"tgt": "if !ok {\n\tpanic(\"STR\")\n}", "gen": "if !c.IsValid() {\n\tpanic(\"STR\")\n}\n}"}
{"tgt": "sum := 0\nprev := 1\ncurr := 1\nfor curr <= 4e6 {\n\tprev, curr = curr, prev+curr\n\tif curr%2 == 0 {\n\t\tsum += curr\n\t}\n}\nfmt.Println(sum)", "gen": "sum, i := 0, 1\nfor i < 4000000 {\n\tif i%2 == 0 {\n\t\tsum += i\n\t}\n\ti += i\n}\nfmt.Println(sum)\n}"}
{"tgt": "dist := func(i int) int {\n\tx, y := points[i][0], points[i][1]\n\treturn x*x + y*y\n}\npartition := func(l, r int) int {\n\tpivot, pdist := l, dist(l)\n\tpoints[pivot], points[r] = points[r], points[pivot]\n\tdivider := l\n\tfor i := l; i < r; i++ {\n\t\tif dist(i) < pdist {\n\t\t\tpoints[i], points[divider] = points[divider], points[i]\n\t\t\tdivider++\n\t\t}\n\t}\n\tpoints[divider], points[r] = points[r], points[divider]\n\treturn divider\n}\nl, r := 0, len(points)-1\nfor l < r {\n\ti := partition(l, r)\n\tif i == K {\n\t\tbreak\n\t} else if i > K {\n\t\tr = i - 1\n\t} else {\n\t\tl = i + 1\n\t}\n}\nreturn points[:K]", "gen": "var (\n\tclosest = func(i int) int {\n\t\treturn i\n\t}\n\tfarthest = func(i int) int {\n\t\treturn len(points) - 1 - i\n\t}\n)\nfor i := 0; i < len(points); i++ {\n\tif kClosest(points, k, closest) < kClosest(points, k, farthest) {\n\t\tkClosest(points, k, farthest)\n\t}\n}\nreturn kClosest(points, k, closest)\n}"}
{"tgt": "if c < 0 {\n\treturn false\n}\nl, r := 0, mySqrt(c)\nfor l <= r {\n\tcur := l*l + r*r\n\tif cur < c {\n\t\tl++\n\t} else if cur > c {\n\t\tr--\n\t} else {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "if x < 0 {\n\treturn false\n}\nleft, right := 0, x\nfor left < right {\n\tmid := left + (right-left)/2\n\tif mid*mid < x {\n\t\tleft = mid + 1\n\t} else if mid*mid > x {\n\t\tright = mid - 1\n\t} else {\n\t\treturn true\n\t}\n}\nreturn false\n}"}
{"tgt": "n := len(edges)\nparent := make([]int, n+1)\nfor i := 0; i < n; i++ {\n\tparent[i] = i\n}\nvar i int\nvar e []int\nfor i, e = range edges {\n\tf, t := e[0], e[1]\n\tpf := find(parent, f)\n\tpt := find(parent, t)\n\tif pf == pt {\n\t\tbreak\n\t}\n\tparent[pf] = pt\n}\nreturn edges[i]", "gen": "n := len(A)\nB := make([]int, n+1)\nfor i := 0; i < n; i++ {\n\tB[i] = i\n}\nfor i := 0; i < n; i++ {\n\tB[i] = find(A, B, i)\n}\nfor i := 0; i < n; i++ {\n\tif B[i] != B[find(A, B, i)] {\n\t\tB[find(A, B, i)] = B[i]\n\t}\n}\nreturn B\n}"}
{"tgt": "var bin strings.Builder\nfor head != nil {\n\tbin.WriteString(strconv.Itoa(head.Val))\n\thead = head.Next\n}\ni, _ := strconv.ParseInt(bin.String(), 2, 64)\nreturn int(i)", "gen": "var sb strings.Builder\nfor head != nil {\n\tsb.WriteString(strconv.Itoa(head.Val))\n\thead = head.Next\n}\ni, _ := strconv.ParseInt(sb.String(), 64, 2)\nreturn i\n}"}
{"tgt": "if n == 0 {\n\treturn 0\n}\nreturn n/5 + trailingZeroes(n/5)", "gen": "if n == 0 {\n\treturn 0\n}\nreturn trailingZeroes(n / 5) + n/5\n}"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tpuzzle := make([][]rune, len(tc.puzzle))\n\tfor i := range puzzle {\n\t\tpuzzle[i] = []rune(tc.puzzle[i])\n\t}\n\tif result := FindWordLD(puzzle, []rune(tc.target)); result != tc.expected {\n\t\tt.Errorf(\"STR\", tcid, tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\ts := tc.s\n\twant := tc.want\n\tgot := FindWordLD(s)\n\tif got != want {\n\t\tt.Errorf(\"STR\", tc.s, got, want)\n\t}\n}\n}"}
{"tgt": "start := 0\nend := len(s) - 1\nfor start < end {\n\ts[start], s[end] = s[end], s[start]\n\tstart++\n\tend--\n}\nreturn s", "gen": "for i := 0; i < len(nums)-1; i++ {\n\tfor j := len(nums) - 1; j > i; j-- {\n\t\tif nums[i] == nums[j] {\n\t\t\tnums = append(nums[:i], nums[i+1:]...)\n\t\t\tj--\n\t\t}\n\t}\n}\nreturn nums\n}"}
{"tgt": "if m == 0 {\n\treturn 1\n}\nswitch n {\ncase 1:\n\treturn 2\ncase 2:\n\tif m == 1 {\n\t\treturn 3\n\t}\n\treturn 4\ndefault:\n\tswitch m {\n\tcase 1:\n\t\treturn 4\n\tcase 2:\n\t\treturn 7\n\tdefault:\n\t\treturn 8\n\t}\n}", "gen": "if n == 0 {\n\treturn 1\n}\nif n == 1 {\n\treturn 2\n}\nif n == 2 {\n\treturn 3\n}\nif n == 3 {\n\treturn 4\n}\nif n == 4 {\n\treturn 7\n}\nif n == 5 {\n\treturn 8\n}\nreturn 9\n}"}
{"tgt": "last, n := 0, len(s)\nfor i := 1; i < n; i++ {\n\tif s[i-1] == s[i] {\n\t\tcontinue\n\t}\n\tfor l := 0; i+l < n; l++ {\n\t\tif s[last+l] < s[i+l] {\n\t\t\tlast = i\n\t\t\tbreak\n\t\t}\n\t\tif s[last+l] > s[i+l] {\n\t\t\tbreak\n\t\t}\n\t}\n}\nreturn s[last:]", "gen": "max := 0\nfor i := 1; i < len(s); i++ {\n\tfor j := 0; j < i; j++ {\n\t\tif s[i] == s[j] && (i-j)%2 == 0 {\n\t\t\tmax = i - j\n\t\t\tbreak\n\t\t}\n\t}\n}\nreturn max\n}"}
{"tgt": "fmt.Println(checkPerfectNumber(6))\nfmt.Println(checkPerfectNumber(28))\nfmt.Println(checkPerfectNumber(30))", "gen": "fmt.Println(checkPerfectNumber(6))\nfmt.Println(checkPerfectNumber(28))\nfmt.Println(checkPerfectNumber(30))\n}"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := EqualWithShifting(tc.A, tc.B); result != tc.expected {\n\t\tt.Errorf(\"STR\", tcid, tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := EqualWithShifting(tc.s1, tc.s2); res != tc.res {\n\t\tt.Errorf(\"STR\", tc.s1, tc.s2, tc.res, res)\n\t}\n}\n}"}
{"tgt": "s = strings.TrimSpace(s)\n_, err := strconv.ParseFloat(s, 64)\nreturn err == nil || err.(*strconv.NumError).Err != strconv.ErrSyntax", "gen": "s = strings.TrimSpace(s)\n_, err := strconv.ParseFloat(s, 64)\nreturn err == nil\n}"}
{"tgt": "qs := []question76{\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans76, q.para76\n\tfmt.Printf(\"STR\", p, minWindow(p.s, p.p))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question76{\n\t{\n\t\tpara76{\n\t\t\t\"STR\",\n\t\t\t\"STR\",\n\t\t},\n\t\tans76{\n\t\t\tSTR,\n\t\t},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans76, q.para76\n\tfmt.Printf(\"STR\", p,STR)\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0}, 5},\n\t{\"STR\", []int{0, 0, 0, 0, 1}, []int{1, 0, 0, 0, 0}, 4},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums1, c.nums2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums1, c.nums2)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0}, []int{0}, 0},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tret := findMedianSortedArrays(c.nums1, c.nums2)\n\t\tif ret != c.expect {\n\t\t\tt.Fatalf(\"STR\", c.expect, ret)\n\t\t}\n\t})\n}\n}"}
{"tgt": "return strings.ReplaceAll(r.element.Name, \"STR\", \"\")", "gen": "return strings.ReplaceAll(s, \"STR\", \"STR\")\n}"}
{"tgt": "result := Mul3And5(5)\nif result != 3 {\n\tt.Errorf(\"STR\", result, 3)\n}\nresult = Mul3And5(6)\nif result != 8 {\n\tt.Errorf(\"STR\", result, 8)\n}\nresult = Mul3And5(7)\nif result != 14 {\n\tt.Errorf(\"STR\", result, 14)\n}\nresult = Mul3And5(10)\nif result != 23 {\n\tt.Errorf(\"STR\", result, 23)\n}\nresult = Mul3And5(11)\nif result != 33 {\n\tt.Errorf(\"STR\", result, 33)\n}", "gen": "if Mul3And5(5) != 3 {\n\tt.Errorf(\"STR\", 3)\n}\nif Mul3And5(8) != 5 {\n\tt.Errorf(\"STR\", 5)\n}\nif Mul3And5(10) != 7 {\n\tt.Errorf(\"STR\", 7)\n}\nif Mul3And5(14) != 11 {\n\tt.Errorf(\"STR\", 11)\n}\nif Mul3And5(23) != 33 {\n\tt.Errorf(\"STR\", 33)\n}\n}"}
{"tgt": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.STR))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "if root == nil {\n\treturn nil\n}\nif root.Key == key {\n\treturn root\n} else if root.Key < key {\n\troot = root.Right\n} else {\n\troot = root.Left\n}\nreturn Get(root, key)", "gen": "if root == nil {\n\treturn nil\n}\nif root.key == key {\n\treturn root\n}\nif root.key > key {\n\treturn Get(root.left, key)\n}\nreturn Get(root.right, key)\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1},\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1, 4, 2},\n\t\twant: 6,\n\t},\n\t{\n\t\tin:   []int{1},\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   []int{2, 1, 1, 2, 1, 3, 3, 3, 1, 3, 1, 3, 2},\n\t\twant: 7,\n\t},\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1},\n\t\twant: 2,\n\t},\n}\nfor _, tt := range tests {\n\tgot := findShortestSubArray(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "tests := [][]int{\n\t{1, 2, 3, 1, 2, 3},\n\t{1, 2, 3, 1, 2, 3, 4, 2, 3},\n\t{1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3},\n\t{1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3},\n\t{1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, "}
{"tgt": "fmt.Println(runtime.GOOS, runtime.GOARCH)", "gen": "fmt.Println(\"STR\", \"STR\")\n}"}
{"tgt": "result := make([]string, 0)\nstart := -1\nend := -1\nfor i, num := range nums {\n\tif i > 0 && num == nums[i-1]+1 {\n\t\tend = i\n\t} else {\n\t\tif i > 0 {\n\t\t\tresult = appendRanges(result, nums, start, end)\n\t\t}\n\t\tstart = i\n\t\tend = i\n\t}\n}\nif end >= 0 {\n\tresult = appendRanges(result, nums, start, end)\n}\nreturn result", "gen": "var res []string\nvar start, end int\nfor _, num := range nums {\n\tif start == -1 {\n\t\tstart = num\n\t\tend = num\n\t} else if num == end+1 {\n\t\tend = num\n\t} else {\n\t\tres = append(res, fmt.Sprintf(\"%d->%d\", start, end))\n\t\tstart = num\n\t\tend = num\n\t}\n}\nif start != -1 {\n\tres = append(res, fmt.Sprintf(\"%d->%d\", start, end))\n}\nreturn res\n}"}
{"tgt": "pigs := 0\nfor mypow(minutesToTest/minutesToDie+1, pigs) < buckets {\n\tpigs++\n}\nreturn pigs", "gen": "for i := 0; i < -b; i++ {\n\tif mypow(a, -b+i) == x {\n\t\treturn i\n\t}\n}\nreturn -1\n}"}
{"tgt": "qs := []question470{\n\t{\n\t\tpara470{},\n\t\tans470{2},\n\t},\n\t{\n\t\tpara470{},\n\t\tans470{0},\n\t},\n\t{\n\t\tpara470{},\n\t\tans470{1},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans470, q.para470\n\tfmt.Printf(\"STR\", p, rand10())\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question470{\n\t{\n\t\tpara470{2},\n\t\tans470{1},\n\t},\n\t{\n\t\tpara470{3},\n\t\tans470{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans470, q.para470\n\tfmt.Printf(\"STR\", p, rand10(p.para470))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "if s == nil {\n\treturn false\n}\nreturn isSubtree(s.Left, t) || isSameTree(s, t) || isSubtree(s.Right, t)", "gen": "if root == nil {\n\treturn false\n}\nreturn isSubtree(root.Left, p) || isSubtree(root.Right, p) || isSameTree(root, p)\n}"}
{"tgt": "if p := e.r; e.list != nil && p != &e.list.root {\n\treturn p\n}\nreturn nil", "gen": "if len(s.stack) > 0 {\n\tif s.stack[len(s.stack)-1] == s.top {\n\t\treturn len(s.stack) - 1\n\t}\n}\nreturn 0\n}"}
{"tgt": "switch {\ncase one == nil && two == nil:\n\treturn nil\ncase one == nil:\n\treturn &BinaryTree{two.Val,\n\t\tMergeBinaryTrees(nil, two.Left),\n\t\tMergeBinaryTrees(nil, two.Right),\n\t}\ncase two == nil:\n\treturn &BinaryTree{one.Val,\n\t\tMergeBinaryTrees(one.Left, nil),\n\t\tMergeBinaryTrees(one.Right, nil),\n\t}\n}\nreturn &BinaryTree{one.Val + two.Val,\n\tMergeBinaryTrees(one.Left, two.Left),\n\tMergeBinaryTrees(one.Right, two.Right),\n}", "gen": "if root1 == nil && root2 == nil {\n\treturn nil\n}\nif root1 == nil || root2 == nil {\n\treturn MergeBinaryTrees(root1, root2)\n}\nreturn &BinaryTree{\n\tVal:   root1.Val + root2.Val,\n\tLeft:  MergeBinaryTrees(root1.Left, root2.Left),\n\tRight: MergeBinaryTrees(root1.Right, root2.Right),\n}\n}"}
{"tgt": "rets := make([][]int, numRows)\nif numRows == 0 {\n\treturn rets\n}\nrets[0] = []int{1}\nfor i := 1; i < numRows; i++ {\n\trets[i] = make([]int, i+1)\n\trets[i][0] = 1\n\trets[i][i] = 1\n\tfor j := 1; j < i; j++ {\n\t\trets[i][j] = rets[i-1][j-1] + rets[i-1][j]\n\t}\n}\nreturn rets", "gen": "if len(nums) == 0 {\n\treturn [][]int{{}}\n}\nres := [][]int{{1}}\nfor i := 1; i < len(nums); i++ {\n\ttmp := make([]int, i+1)\n\ttmp[0] = 1\n\tfor j := 1; j <= i; j++ {\n\t\ttmp[j] = res[j-1][0] + res[j][0]\n\t}\n\tres = append(res, tmp)\n}\nreturn res\n}"}
{"tgt": "i, l := 0, len(bits)-1\nfor i < l {\n\ti += bits[i] + 1\n}\nreturn i == l", "gen": "i := 0\nn := len(nums) - 1\nfor i < n {\n\ti += nums[i] + 1\n}\nreturn i == n\n}"}
{"tgt": "fname, lname := \"STR\", \"STR\"\nage := 35\nfmt.Println(Title)\nfmt.Println(\"STR\", fname)\nfmt.Println(\"STR\", lname)\nfmt.Println(\"STR\", age)\nfmt.Println(\"STR\", Country)", "gen": "fmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println(\"STR\")\nfmt.Println"}
{"tgt": "for i := 0; i < b.N; i++ {\n\tSum(7, 8, 10)\n}", "gen": "for i := 0; i < t.N; i++ {\n\tSum([]int{7, 8, 10}, 3)\n}\n}"}
{"tgt": "dec := xml.NewDecoder(os.Stdin)\nvar stack []string\nfor {\n\ttok, err := dec.Token()\n\tif err == io.EOF {\n\t\tbreak\n\t} else if err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"STR\", err)\n\t\tos.Exit(1)\n\t}\n\tswitch tok := tok.(type) {\n\tcase xml.StartElement:\n\t\tstack = append(stack, tok.Name.Local)\n\tcase xml.EndElement:\n\t\tstack = stack[:len(stack)-1]\n\tcase xml.CharData:\n\t\tif containsAll(stack, os.Args[1:]) {\n\t\t\tfmt.Printf(\"STR\", strings.Join(stack, \"STR\"), tok)\n\t\t}\n\t}\n}", "gen": "dec := xml.NewDecoder(os.Stdin)\nfor {\n\ttoken, err := dec.Token()\n\tif err == io.EOF {\n\t\tos.Exit(1)\n\t}\n\tif token, ok := token.(xml.StartElement); ok {\n\t\tif containsAll(token.Name.Local, os.Args[1:]) {\n\t\t\tfmt.Printf(\"STR\", strings.Join(os.Args[1:], \"STR\"))\n\t\t}\n\t}\n}\n}"}
{"tgt": "var sentences []string\nvar start int\nspaceDelimited := strings.Split(text, \"STR\")\npossibleSentence := false\nfor i, part := range spaceDelimited {\n\trunes := []rune(part)\n\tif part == \"STR\" || !isValid(runes) {\n\t\tpossibleSentence = false\n\t\tcontinue\n\t}\n\tif runes[0] >= 'A' && runes[0] <= 'Z' {\n\t\tpossibleSentence = true\n\t\tstart = i\n\t\tcontinue\n\t}\n\tif last := runes[len(runes)-1]; last == '.' || last == '!' || last == '?' {\n\t\tif possibleSentence {\n\t\t\tsentences = append(sentences, strings.Join(spaceDelimited[start:i+1], \"STR\"))\n\t\t}\n\t}\n}\nreturn sentences", "gen": "var res []string\nvar valid bool\nfor _, s := range strings.Split(str, \"STR\") {\n\tvalid = false\n\tif s == \"STR\" {\n\t\tvalid = true\n\t} else {\n\t\tfor _, r := range []rune(s) {\n\t\t\tif !isValid(r) {\n\t\t\t\tvalid = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif r == 'STR' {\n\t\t\t\tvalid = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tif valid {\n\t\tres = append(res, \"STR\")\n\t} else {\n\t\tres = append(res, \"STR\"+s)\n\t}\n}\nreturn res\n}"}
{"tgt": "arr := randomSlice(0, 20, 10)\ndeleteSequence := randomSlice(0, 10, 10)\nnodeCnt := 0\nrbt := newRBT()\nfor _, v := range arr {\n\trbt.Insert(uint32(v))\n}\nfor i, v := range deleteSequence {\n\trbt.Delete(uint32(arr[v]))\n\tstop := rbt.PreOrderWalk(rbt.Root(), checkGBT(t, &nodeCnt, *debug))\n\tif stop {\n\t\treturn\n\t}\n\tif nodeCnt != len(deleteSequence)-1-i {\n\t\tt.Log(\"STR\", len(deleteSequence)-1-i, \"STR\", nodeCnt)\n\t\tt.Fail()\n\t}\n\tnodeCnt = 0\n\tif i != len(deleteSequence)-1 {\n\t\tstop = checkRBT(t, rbt)\n\t\tif stop {\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "s1 := randomSlice(10, 20, 0)\ns2 := randomSlice(10, 10, 0)\ntree := newRBT()\nfor _, v := range s1 {\n\ttree.Insert(uint32(v))\n}\nfor _, v := range s2 {\n\tif tree.Root != nil {\n\t\tif debug {\n\t\t\tcheckGBT(tree, s1, s2)\n\t\t}\n\t\ttree.Delete(uint32(v))\n\t\tif debug {\n\t\t\tcheckRBT(tree, s1, s2)\n\t\t}\n\t}\n}\nif debug {\n\tif tree.Root != nil {\n\t\tt.Log(\"STR\", \"STR\", \"STR\")\n\t\tt.Fail()\n\t}\n}\n}"}
{"tgt": "ans := make([]int, len(nums))\nfor i, idx := range index {\n\tcopy(ans[idx+1:], ans[idx:])\n\tans[idx] = nums[i]\n}\nreturn ans", "gen": "res := make([]int, len(nums))\nfor i, num := range nums {\n\tres[i] = num + 1\n}\nreturn res\n}"}
{"tgt": "min, max := A[0], A[0]\nfor _, a := range A {\n\tif a < min {\n\t\tmin = a\n\t}\n\tif a > max {\n\t\tmax = a\n\t}\n}\nif max-min <= K+K {\n\treturn 0\n}\nreturn max - min - K - K", "gen": "min, max := nums[0], nums[0]\nfor _, v := range nums {\n\tif v < min {\n\t\tmin = v\n\t}\n\tif v > max {\n\t\tmax = v\n\t}\n}\nif max-min < k {\n\treturn 0\n}\nreturn max - min - k\n}"}
{"tgt": "left := 0\nright := len(numbers) - 1\nfor left != right {\n\tif numbers[left]+numbers[right] == target {\n\t\tbreak\n\t}\n\tif numbers[left]+numbers[right] > target {\n\t\tright--\n\t}\n\tif numbers[left]+numbers[right] < target {\n\t\tleft++\n\t}\n}\nreturn []int{left + 1, right + 1}", "gen": "left, right := 0, len(nums)-1\nfor left < right {\n\tif nums[left]+nums[right] < target {\n\t\tright--\n\t} else if nums[left]+nums[right] > target {\n\t\tleft++\n\t} else {\n\t\treturn []int{left + 1, right + 1}\n\t}\n}\nreturn nil\n}"}
{"tgt": "for a != nil && b != nil {\n\tif a.Value != b.Value {\n\t\treturn false\n\t}\n\ta = a.Next\n\tb = b.Next\n}\nreturn a == nil && b == nil", "gen": "for l1 != nil && l2 != nil {\n\tif l1.Val != l2.Val {\n\t\treturn false\n\t}\n\tl1 = l1.Next\n\tl2 = l2.Next\n}\nreturn l1 == nil && l2 == nil\n}"}
{"tgt": "return func(treebinaryTreeIf, node interface{}) bool {\n\tn := node.(*gbtElement)\n\tif !tree.IsNil(n.Left) && n.Left.Key >= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Left, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif !tree.IsNil(n.Right) && n.Right.Key <= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Right, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif debug {\n\t\tfmt.Println(n)\n\t}\n\t*nodeCnt++\n\treturn false\n}", "gen": "t := t1{\n\tt: t,\n\tdebug: debug,\n\tnodeCnt: 0,\n}\nreturn t, &t\n}"}
{"tgt": "n := len(A)\nif n == 0 {\n\treturn A\n}\nabs := func(num int) int { return int(math.Abs(float64(num))) }\nans := make([]int, n)\ni, j, k := 0, n-1, n-1\nfor i <= j {\n\tif abs(A[i]) > abs(A[j]) {\n\t\tans[k] = A[i] * A[i]\n\t\ti++\n\t} else {\n\t\tans[k] = A[j] * A[j]\n\t\tj--\n\t}\n\tk--\n}\nreturn ans", "gen": "n := len(nums)\nif n == 0 {\n\treturn nums\n}\nres := make([]int, n)\nfor i := n - 1; i >= 0; i-- {\n\tfor j := i - 1; j >= 0; j-- {\n\t\tif nums[i] < nums[j] {\n\t\t\tres[j] += nums[i] * nums[i]\n\t\t} else {\n\t\t\tres[i] += nums[j] * nums[j]\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif denoms := EgyptianFractions(tc.numerator, tc.denominator); !reflect.DeepEqual(tc.denominators, denoms) {\n\t\tt.Errorf(\"STR\", tc.denominators, denoms)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := EgyptianFractions(tc.n); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "nums1 := []int{2}\nnums2 := []int{}\nmerge(nums1, 1, nums2, 0)\nfmt.Println(nums1)", "gen": "fmt.Println(merge([]int{2}, []int{1}))\n}"}
{"tgt": "result := 0\nfor num != 0 {\n\tresult++\n\tnum = num & (num - 1)\n}\nreturn result", "gen": "var count int\nfor n != 0 {\n\tn = n & (n - 1)\n\tcount++\n}\nreturn count\n}"}
{"tgt": "qs := []question448{\n\t{\n\t\tpara448{[]int{4, 3, 2, 7, 8, 2, 3, 1}},\n\t\tans448{[]int{5, 6}},\n\t},\n\t{\n\t\tpara448{[]int{4, 3, 2, 10, 9, 2, 3, 1, 1, 1, 1}},\n\t\tans448{[]int{5, 6, 7, 8, 11}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans448, q.para448\n\tfmt.Printf(\"STR\", p, findDisappearedNumbers(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question448{\n\t{\n\t\tpara448{[]int{4, 3, 2, 7, 8, 2, 3, 1}},\n\t\tans448{[]int{5, 6, 7, 8, 9}},\n\t},\n\t{\n\t\tpara448{[]int{5, 6, 7, 8, 9, 2, 3, 1}},\n\t\tans448{[]int{10}},\n\t},\n\t{\n\t\tpara448{[]int{4, 3, 2, 1, 1, 1, 1, 1}},\n\t\tans448{[]int{5, 6, 7, 8, 9}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans, q.para\n\tfmt.Printf(\"STR\", p, findDisappearedNumbers(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "flag.Parse()\nroots := flag.Args()\nif len(roots) == 0 {\n\troots = []string{\"STR\"}\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, root := range roots {\n\t\twalkDir(root, fileSizes)\n\t}\n\tclose(fileSizes)\n}()\nvar nfiles, nbytes int64\nfor size := range fileSizes {\n\tnfiles++\n\tnbytes += size\n}\nprintDiskUsage(nfiles, nbytes)", "gen": "flag.Parse()\nargs := flag.Args()\nif len(args) == 0 {\n\targs = []string{\"./\"}\n}\nch := make(chan int64)\ngo main.roots1(args, ch)\nvar total int64\nfor {\n\tsize, ok := <-ch\n\tif !ok {\n\t\tbreak\n\t}\n\ttotal += size\n}\nprintDiskUsage(total, len(args))\n}"}
{"tgt": "return toString[t]", "gen": "return toString[beerType]\n}"}
{"tgt": "for step := len(nums) / 2; step > 0; step /= 2 {\n\tfor i := step; i < len(nums); i++ {\n\t\tfor j := i - step; j >= 0 && nums[j+step] < nums[j]; j -= step {\n\t\t\tnums[j], nums[j+step] = nums[j+step], nums[j]\n\t\t}\n\t}\n}\nreturn nums", "gen": "n := len(nums)\ni := 0\nfor i < n {\n\tj := i\n\tfor j < n && nums[i] == nums[j] {\n\t\tj++\n\t}\n\tfor j < n && nums[i] < nums[j] {\n\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\ti++\n\t\tj++\n\t}\n\ti++\n}\nreturn nums\n}"}
{"tgt": "var tests = []struct {\n\ttree *TreeNode\n\tvals []int\n}{\n\t{newTree(1, 2, 3, nil, 5, nil, 4), []int{1, 3, 4}},\n\t{newTree(1, 2, 3, 4, 5, nil, 6, nil, 7, nil, nil, 8, nil, nil, 9, nil, nil, nil, 10), []int{1, 3, 6, 8, 9, 10}},\n}\nfor _, tt := range tests {\n\tvals := rightSideView(tt.tree)\n\tif reflect.DeepEqual(vals, tt.vals) == false {\n\t\tt.Errorf(\"STR\", tt.tree, vals, tt.vals)\n\t}\n}", "gen": "qs := []question{\n\t{\n\t\tpara{\n\t\t\troot: newTree([]int{1, 2, 3}),\n\t\t},\n\t\tans{\n\t\t\t[]int{1, 3},\n\t\t},\n\t},\n\t{\n\t\tpara{\n\t\t\troot: newTree([]int{1, 2, 3, 4, 5, 6, 7}),\n\t\t},\n\t\tans{\n\t\t\t[]int{1, 3, 5, 7},\n\t\t},\n\t},\n}\nfor _, q := range qs {\n\t_, p := q.ans, q.para\n\tgot := rightSideView(p.root)\n\tif !reflect.DeepEqual(got, p.ans) {\n\t\tt.Errorf(\"STR\", p.root, p.ans, got)\n\t}\n}\n}"}
{"tgt": "nodes := []int{\n\t1, 2, 3, 4, 5, 6,\n}\nedges := [][]bool{\n\t{false, true, true, false, false, false},\n\t{true, false, false, true, false, false},\n\t{true, false, false, true, false, false},\n\t{false, true, true, false, true, false},\n\t{false, false, false, true, false, true},\n\t{false, false, false, false, true, false},\n}\nstart := 1\nend := 6\nroute, _ := dfs(start, end, nodes, edges)\nfmt.Println(route)", "gen": "var res [][]int\nvar dfs func(i int, path []int)\ndfs = func(i int, path []int) {\n\tif i == len(nums) {\n\t\tres = append(res, path)\n\t\treturn\n\t}\n\tfor j := i; j < len(nums); j++ {\n\t\tif j > i && nums[j] == nums[j-1] {\n\t\t\tcontinue\n\t\t}\n\t\tdfs(j+1, append(path, nums[j]))\n\t}\n}\ndfs(0, []int{})\nfmt.Println(res)\n}"}
{"tgt": "if target < 0 {\n\ttarget = -target\n}\nk := 0\nfor target > 0 {\n\tk++\n\ttarget -= k\n}\nif target%2 == 0 {\n\treturn k\n}\nreturn k + 1 + k%2", "gen": "if n < 0 {\n\tn = -n\n}\ni := 0\nfor n > 0 {\n\ti++\n\tn = n - i\n}\nif n%2 == 0 {\n\treturn i\n}\nreturn i + 1\n}"}
{"tgt": "if mod == 1 {\n\treturn 0, nil\n}\nif exponent < 0 {\n\treturn -1, ErrorNegativeExponent\n}\n_, err := Multiply64BitInt(mod-1, mod-1)\nif err != nil {\n\treturn -1, err\n}\nvar result int64 = 1\nbase = base % mod\nfor exponent > 0 {\n\tif exponent%2 == 1 {\n\t\tresult = (result * base) % mod\n\t}\n\texponent = exponent >> 1\n\tbase = (base * base) % mod\n}\nreturn result, nil", "gen": "if n < 1 {\n\treturn ErrorNegativeExponent\n}\nif n == 1 {\n\treturn base\n}\nif n < 0 {\n\treturn ErrorNegativeExponent\n}\nvar result big.Int\nresult.Mul(base, base)\nfor n > 1 {\n\tif n%2 == 0 {\n\t\tresult.Mul(&result, base)\n\t}\n\tn /= 2\n\tbase.Mul(base, base)\n}\nreturn result\n}"}
{"tgt": "for n := 0; n < 32; n++ {\n\tsquare[n] = gf2MatrixTimes(mat, mat[n])\n}", "gen": "for i := 0; i < 32; i++ {\n\tcrc[i] = gf2MatrixTimes(crc, poly)\n\tcrc[i] ^= poly[i]\n}\n}"}
{"tgt": "return n.Ns == nil", "gen": "return len(s) == 0\n}"}
{"tgt": "n := len(p)\ndestination := n * n\nsquares := make([]int, 400)\nisChecked := [401]bool{}\nsquares[0] = 1\nisChecked[1] = true\nsteps := 0\nfor len(squares) > 0 {\n\tsteps++\n\tsize := len(squares)\n\tfor j := 0; j < size; j++ {\n\t\ts := squares[j]\n\t\tfor i := 1; i <= 6; i++ {\n\t\t\tsi := s + i\n\t\t\tx, y := position(si, n)\n\t\t\tif p[x][y] != -1 {\n\t\t\t\tisChecked[si] = true\n\t\t\t\tsi = p[x][y]\n\t\t\t}\n\t\t\tif si == destination {\n\t\t\t\treturn steps\n\t\t\t}\n\t\t\tif !isChecked[si] {\n\t\t\t\tsquares = append(squares, si)\n\t\t\t\tisChecked[si] = true\n\t\t\t}\n\t\t}\n\t}\n\tsquares = squares[size:]\n}\nreturn -1", "gen": "n := len(board)\nm := len(board[0])\nvar ans int\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < m; j++ {\n\t\tif board[i][j] == 'X' {\n\t\t\tcontinue\n\t\t}\n\t\tif position(board, i, j) == 0 {\n\t\t\tans = i\n\t\t\tbreak\n\t\t}\n\t\tfor k := 1; k < 7; k++ {\n\t\t\tx, y := position(board, i, j)\n\t\t\tif board[x][y] == 'X' {\n\t\t\t\tboard[i][j] = 'X'\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\nreturn ans\n}"}
{"tgt": "return &linkLoop{\n\tHead: &linkLoopNode{},\n}", "gen": "return &linkLoop{\n\thead: &linkLoopNode{},\n}\n}"}
{"tgt": "return bindataRead(\n\t_dataCustomersJson,\n\t\"STR\",\n)", "gen": "return bindataRead(\"STR\", _dataCustomersJson)\n}"}
{"tgt": "m := len(matrix)\nif m == 0 {\n\treturn 0\n}\nn := len(matrix[0])\nif n == 0 {\n\treturn 0\n}\nmaxEdge := 0\ndp := make([][]int, m+1)\nfor i := range dp {\n\tdp[i] = make([]int, n+1)\n}\nfor i := 1; i <= m; i++ {\n\tfor j := 1; j <= n; j++ {\n\t\tif matrix[i-1][j-1] == '1' {\n\t\t\tdp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))\n\t\t\tmaxEdge = max(maxEdge, dp[i][j])\n\t\t}\n\t}\n}\nreturn maxEdge * maxEdge", "gen": "n := len(A)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn A[0]\n}\nmin := A[0]\nmax := A[0]\nfor i := 1; i < n; i++ {\n\tif A[i] < min {\n\t\tmin = A[i]\n\t}\n\tif A[i] > max {\n\t\tmax = A[i]\n\t}\n}\nres := 0\nfor i := 1; i < n; i++ {\n\tfor j := 1; j < i; j++ {\n\t\tif A[i] < A[j] {\n\t\t\tres += min\n\t\t} else {\n\t\t\tres += max\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "return x * y", "gen": "return (x.R * y.R) + (x.G * y.G) + (x.B * y.B)\n}"}
{"tgt": "if len(a) != len(b) {\n\treturn false\n}\nfor i, v := range a {\n\tif v != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "if len(nums) == 0 {\n\treturn false\n}\nfor i := 0; i < len(nums); i++ {\n\tif nums[i] == nums[i+1] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "if len(s) <= 1 {\n\treturn s\n}\ni := getIndex(s + \"STR\" + reverse(s))\nreturn reverse(s[i:]) + s", "gen": "if len(s) == 1 {\n\treturn s\n}\ns = reverse(s)\ni := getIndex(s, \"STR\")\nreturn s[:i] + reverse(s[i:])\n}"}
{"tgt": "sorted := make([]int, 0, m+n)\np, q := 0, 0\nfor {\n\tif p == m {\n\t\tsorted = append(sorted, nums2[q:]...)\n\t\tbreak\n\t}\n\tif q == n {\n\t\tsorted = append(sorted, nums1[p:]...)\n\t\tbreak\n\t}\n\tif nums1[p] < nums2[q] {\n\t\tsorted = append(sorted, nums1[p])\n\t\tp++\n\t} else {\n\t\tsorted = append(sorted, nums2[q])\n\t\tq++\n\t}\n}\ncopy(nums1, sorted)", "gen": "res := make([]int, 0, len(nums1)+len(nums2))\ni, j := 0, 0\nfor i < len(nums1) || j < len(nums2) {\n\tif j == len(nums2) || (i < len(nums1) && nums1[i] <= nums2[j]) {\n\t\tres = append(res, nums1[i])\n\t\ti++\n\t} else {\n\t\tres = append(res, nums2[j])\n\t\tj++\n\t}\n}\nreturn res\n}"}
{"tgt": "freq := make(map[rune]int)\nfor _, r := range s {\n\tfreq[r]++\n}\ntype frequency struct {\n\tr     rune\n\tcount int\n}\nletters := make([]*frequency, 0, len(freq))\nfor letter, count := range freq {\n\tletters = append(letters, &frequency{letter, count})\n}\nsort.Slice(letters, func(i, j int) bool {\n\treturn letters[i].count > letters[j].count\n})\nvar sb strings.Builder\nfor len(letters) != 0 {\n\tif len(letters) == 1 && letters[0].count > 1 {\n\t\treturn \"STR\"\n\t}\n\tfor _, f := range letters {\n\t\tsb.WriteRune(f.r)\n\t\tf.count--\n\t}\n\tfor len(letters) != 0 && letters[len(letters)-1].count == 0 {\n\t\tletters = letters[:len(letters)-1]\n\t}\n}\nreturn sb.String()", "gen": "m := make(map[int]int)\nfor _, c := range s {\n\tm[c]++\n}\nvar f []frequency\nfor _, c := range m {\n\tf = append(f, frequency{c, c})\n}\nsort.Slice(f, func(i, j int) bool {\n\treturn f[i].count > f[j].count\n})\nvar sb strings.Builder\nfor _, f := range f {\n\tif f.count > 1 {\n\t\tsb.WriteString(\"STR\")\n\t} else {\n\t\tsb.WriteRune(f.rune)\n\t}\n}\nreturn sb.String()\n}"}
{"tgt": "n := len(A)\nfor i := n - 2; i >= 0; i-- {\n\tA[i] += A[i+1]\n}\nmem := [101][33]int{}\nvar dp func(int, int) int\ndp = func(i, m int) int {\n\tif i+2*m >= n {\n\t\treturn A[i]\n\t}\n\tif mem[i][m] > 0 {\n\t\treturn mem[i][m]\n\t}\n\tres := 0\n\tfor x := 1; x <= 2*m; x++ {\n\t\tres = max(\n\t\t\tres,\n\t\t\tA[i]-dp(i+x, max(m, x)),\n\t\t)\n\t}\n\tmem[i][m] = res\n\treturn res\n}\nreturn dp(0, 1)", "gen": "n := len(stones)\ndp := make([]int, n+1)\nfor i := n - 1; i >= 0; i-- {\n\tdp[i+1] = dp[i] + stones[i]\n}\nmemset(dp, 0, n)\nvar dfs func(i int) int\ndfs = func(i int) int {\n\tif i < 0 {\n\t\treturn 0\n\t}\n\tif dp[i] != 0 {\n\t\treturn dp[i]\n\t}\n\tdp[i] = -1\n\treturn dp[i]\n}\nreturn dfs(n - 1)\n}"}
{"tgt": "if n <= 2 {\n\treturn n\n}\nvar dp [2]int\ndp[0], dp[1] = 1, 2\nfor i := 2; i < n; i++ {\n\tdp[i%2] = dp[i%2] + dp[(i-1)%2]\n}\nreturn dp[(n-1)%2]", "gen": "if n <= 2 {\n\treturn n\n}\ndp := make([]int, n)\ndp[0] = 1\ndp[1] = 2\nfor i := 2; i < n; i++ {\n\tfor j := 0; j < i; j++ {\n\t\tdp[i] += dp[j] * dp[i-1-j]\n\t}\n}\nreturn dp[n-1]\n}"}
{"tgt": "email = strings.TrimSpace(email)\nemail = strings.ToLower(email)\nh := md5.New()\nio.WriteString(h, email)\nfinalBytes := h.Sum(nil)\nfinalString := hex.EncodeToString(finalBytes)\nreturn finalString", "gen": "s = strings.TrimSpace(s)\ns = strings.ToLower(s)\nh := md5.New()\nh.Write([]byte(s))\nreturn hex.EncodeToString(h.Sum(nil))\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t}, {\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n}\nfor _, tt := range tests {\n\tgot := repeatedSubstringPattern(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "tests := [...]struct {\n\ts        string\n\texpected bool\n}{\n\t{\"ABAB\", true},\n\t{\"ABA\", false},\n\t{\"ABABAB\", true},\n\t{\"ABABA\", false},\n\t{\"ABABABAB\", true},\n\t{\"ABABABA\", false},\n\t{\"ABABABABAB\", true},\n\t{\"ABABABABA\", false},\n\t{\"ABABABABABAB\", true},\n\t{\"ABABABABABA\", false},\n\t{\"ABABABABABABAB\", true},\n\t{\"ABABABABABABA\", false},\n\t{\"ABABABABABABABAB\", true},\n\t{\"ABABABABABABABA\", false},\n\t{\"ABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABA\", false},\n\t{\"ABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABA\", false},\n\t{\"ABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABA\", false},\n\t{\"ABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABA\", false},\n\t{\"ABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABA\", false},\n\t{\"ABABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABABA\", false},\n\t{\"ABABABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABABABA\", false},\n\t{\"ABABABABABABABABABABABABABABABAB\", true},\n\t{\"ABABABABABABABABABABABABABABABA\", false},"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   0x5555,\n\t\twant: 8,\n\t},\n}\nfor _, tt := range tests {\n\tgot := hammingWeight(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "tests := [...]struct {\n\tin   uint32\n\twant int\n}{\n\t{3, 2},\n\t{2, 1},\n\t{7, 3},\n\t{3, 2},\n\t{8, 1},\n\t{1, 21845},\n\t{8, 3},\n}\nfor i, tt := range tests {\n\tgot := hammingWeight(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", i, tt.in, got, tt.want)\n\t}\n}\n}"}
{"tgt": "return bindataRead(\n\t_assetsHomeCatJpg,\n\t\"STR\",\n)", "gen": "return bindataRead(\n\t\"STR\",\n\tSTR,\n)\n}"}
{"tgt": "b.table = make(map[string]*entry, capacity)\nb.priorityQueue = make([]*entry, 0, capacity)\nb.lruList.Init()\nb.freeList.Init()\nheap.Init(&b.priorityQueue)\narrayOfEntries := make([]entry, capacity)\nfor i := uint(0); i < capacity; i++ {\n\te := &arrayOfEntries[i]\n\te.element.Value = e\n\te.index = -1\n\tb.freeList.PushElementBack(&e.element)\n}", "gen": "cache.cache = make(map[string]entry)\ncache.list = list.Init()\ncache.pq = priorityQueue.Init()\ncache.pq.Init(priorityQueue.Less, priorityQueue.Pop, priorityQueue.Push, priorityQueue.Swap)\nfor i := 0; i < cache.capacity; i++ {\n\tentry := &entry{}\n\tcache.cache[i] = entry\n\tcache.list.PushElementBack(entry)\n}\n}"}
{"tgt": "list.rear = nil", "gen": "self.data = nil\n}"}
{"tgt": "h := newLinkedHeap()\nbenchmarkHeap(b, h)", "gen": "benchmarkHeap(newLinkedHeap())\n}"}
{"tgt": "close(p.work)\np.wg.Wait()", "gen": "close(c)\nwg.Wait()\n}"}
{"tgt": "res := 0\nfactor := 1\nsize := len(s)\nfor i := 0; i < size; i++ {\n\tif s[i] == '(' {\n\t\tfactor *= 2\n\t} else {\n\t\tfactor /= 2\n\t}\n\tif s[i] == '(' && s[i+1] == ')' {\n\t\tres += factor / 2\n\t}\n}\nreturn res", "gen": "sum := 0\nmax := 1\nn := len(s)\nfor i := 0; i < n; i++ {\n\tif s[i] == '(' {\n\t\tsum += max\n\t} else if s[i] == ')' {\n\t\tmax++\n\t}\n}\nreturn sum\n}"}
{"tgt": "qs := []question454{\n\t{\n\t\tpara454{[]int{1, 2}, []int{-2, -1}, []int{-1, 2}, []int{0, 2}},\n\t\tans454{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans454, q.para454\n\tfmt.Printf(\"STR\", p, fourSumCount(p.a, p.b, p.c, p.d))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question454{\n\t{\n\t\tpara454{[]int{1, 2, 3, 4}},\n\t\tans454{4},\n\t},\n\t{\n\t\tpara454{[]int{-1, -2, -3, -4}},\n\t\tans454{0},\n\t},\n\t{\n\t\tpara454{[]int{-1, 2, 3, 4}},\n\t\tans454{0},\n\t},\n\t{\n\t\tpara454{[]int{-1, 2, 3, 4, 5}},\n\t\tans454{0},\n\t},\n\t{\n\t\tpara454{[]int{-1, 2, 3, 4, 5, 6}},\n\t\tans454{0},\n\t},\n\t{\n\t\tpara454{[]int{-1, 2, 3, 4, 5, 6, 7}},\n\t\tans454{0},\n\t},\n\t{\n\t\tpara454{[]int{-1, 2, 3, 4, 5, 6, 7, 8}},\n\t\tans454{0},\n\t},\n\t{\n\t\tpara454{[]int{-1, 2, 3, 4, 5, 6, 7, 8, 9}},\n\t\tans454{0},\n\t},\n\t{\n\t\tpara454{[]int{-1, 2, 3, 4, 5, 6, 7, 8, 9, 10}},\n\t\tans454{0},\n\t},\n\t{\n\t\tpara454{[]int{-1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1"}
{"tgt": "for i := range langs {\n\tlanguage := langs[i]\n\tif strings.EqualFold(language.Lang, str) {\n\t\treturn &language\n\t}\n}\nreturn nil", "gen": "for _, lang := range langs {\n\tif lang.Name == name {\n\t\treturn lang\n\t}\n}\nreturn nil\n}"}
{"tgt": "sort.Ints(houses)\nsort.Ints(heaters)\ni, ans := 0, 0\nfor _, house := range houses {\n\tfor i < len(heaters)-1 && heaters[i]+heaters[i+1] <= house*2 {\n\t\ti++\n\t}\n\tans = maxInt(ans, absInt(heaters[i]-house))\n}\nreturn ans", "gen": "sort.Ints(A)\nsort.Ints(B)\nvar res int\nfor i := 0; i < len(A); i++ {\n\tif A[i] < B[i] {\n\t\tres = maxInt(res, absInt(A[i]+B[i+1]))\n\t} else {\n\t\tres = maxInt(res, absInt(A[i-1]+B[i]))\n\t}\n}\nreturn res\n}"}
{"tgt": "return h.FromHexString(string(b))", "gen": "return Hash{}.FromHexString(string(b))\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{\n\t\t{10, 16},\n\t\t{2, 8},\n\t\t{1, 6},\n\t\t{7, 12},\n\t}, 2},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := findMinArrowShots(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{{10, 16}, {2, 8}, {7, 12}}, 1},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.name, c.inputs)\n\t\t}\n\t})\n}\n}"}
{"tgt": "if n < 2 {\n\treturn false\n}\nfor i := 2; i < n; i++ {\n\tif n%i == 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "if n <= 1 {\n\treturn false\n}\nfor i := 2; i < n; i++ {\n\tif n%i == 0 {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{5, 3, 4, 5},\n\t\twant: true,\n\t},\n\t{\n\t\tin:   []int{2, 5, 7, 3},\n\t\twant: true,\n\t},\n}\nfor _, tt := range tests {\n\tgot := stoneGame(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "tests := []struct {\n\tpiles []int\n\twins  bool\n}{\n\t{[]int{5, 3, 4, 5}, true},\n\t{[]int{2, 5, 7, 3}, false},\n}\nfor i, tt := range tests {\n\tres := stoneGame(tt.piles)\n\tif res != tt.wins {\n\t\tt.Fatalf(\"STR\", i, tt.piles, tt.wins, res)\n\t}\n}\n}"}
{"tgt": "return self.code", "gen": "return *p\n}"}
{"tgt": "if N == 1 {\n\treturn 0\n}\nif K%2 == 1 {\n\treturn kthGrammar(N-1, (K+1)/2)\n}\nreturn opposite(kthGrammar(N-1, K/2))", "gen": "if N == 1 {\n\treturn 0\n}\nif K == 1 {\n\treturn N\n}\nif K%2 == 0 {\n\treturn kthGrammar(N-1, K/2)\n}\nreturn opposite(kthGrammar(N-1, K/2))\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := buddyStrings(tt.a, tt.b)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.a, tt.b, got, tt.want)\n\t}\n}", "gen": "qs := []question2{\n\t{\n\t\tpara2{\"ab\", \"ba\"},\n\t\tans2{true},\n\t},\n\t{\n\t\tpara2{\"ab\", \"ab\"},\n\t\tans2{false},\n\t},\n\t{\n\t\tpara2{\"aa\", \"aa\"},\n\t\tans2{true},\n\t},\n\t{\n\t\tpara2{\"aaaaaaabc\", \"aaaaaaacb\"},\n\t\tans2{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans2, q.para2\n\tfmt.Printf(\"STR\")\n\tgot := buddyStrings(p.one, p.two)\n\tfmt.Printf(\"STR\")\n\tif got != p.expect {\n\t\tt.Fatalf(\"STR\", p.one, p.two, p.expect, got)\n\t}\n}\n}"}
{"tgt": "ope := [][]int{\n\t{2, 2},\n\t{3, 3}}\nfmt.Println(maxCount(3, 3, ope))", "gen": "fmt.Println(maxCount(2, []int{2, 2, 3, 3}))\n}"}
{"tgt": "qs := []question274{\n\t{\n\t\tpara274{[]int{3, 6, 9, 1}},\n\t\tans274{3},\n\t},\n\t{\n\t\tpara274{[]int{1}},\n\t\tans274{1},\n\t},\n\t{\n\t\tpara274{[]int{}},\n\t\tans274{0},\n\t},\n\t{\n\t\tpara274{[]int{3, 0, 6, 1, 5}},\n\t\tans274{3},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans274, q.para274\n\tfmt.Printf(\"STR\", p, hIndex(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "var cases = []struct {\n\tcitations []int\n\texpect    int\n}{\n\t{\n\t\t[]int{3, 6, 9, 1, 4},\n\t\t3,\n\t},\n\t{\n\t\t[]int{1, 1, 1},\n\t\t1,\n\t},\n\t{\n\t\t[]int{0},\n\t\t0,\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, c := range cases {\n\tret := hIndex(c.citations)\n\tif ret != c.expect {\n\t\tt.Fatalf(\"STR\",\n\t\t\tc.citations, ret, c.expect)\n\t}\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "sort.Strings(words)\nmp := make(map[string]bool)\nvar res string\nfor _, word := range words {\n\tsize := len(word)\n\tif size == 1 || mp[word[:size-1]] {\n\t\tif size > len(res) {\n\t\t\tres = word\n\t\t}\n\t\tmp[word] = true\n\t}\n}\nreturn res", "gen": "sort.Strings(words)\nm := make(map[string]bool)\nfor _, word := range words {\n\tif len(word) < 2 {\n\t\tcontinue\n\t}\n\tif _, ok := m[word]; ok {\n\t\tif len(word) > len(m) {\n\t\t\tm[word] = true\n\t\t}\n\t} else {\n\t\tm[word] = true\n\t}\n}\nreturn m\n}"}
{"tgt": "longestCenter, longestLength := 0, 0\nfor i, v := range P {\n\tif v > longestLength {\n\t\tlongestLength = v\n\t\tlongestCenter = i\n\t}\n}\noffset := (longestCenter - longestLength) / 2\nreturn s[offset : offset+longestLength]", "gen": "var sum int\nvar max int\nfor _, v := range nums {\n\tif v > max {\n\t\tsum = v\n\t\tmax = v\n\t} else if v < max {\n\t\tsum += v\n\t}\n}\nreturn sum\n}"}
{"tgt": "for j := 1; j <= 20; j++ {\n\tif num%j != 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "for i := 1; i <= 20; i++ {\n\tif n%i != 0 {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "n := node.(*bstElement)\nif n == nil {\n\treturn nil\n}\nif n.right != nil {\n\treturn t.Min(n.right)\n}\ncur := n\nfor cur.parent != nil && cur.parent.left != cur {\n\tcur = cur.parent\n}\nreturn cur.parent", "gen": "if bst, ok := bstElement.(*bst); ok {\n\tif bst.root == nil {\n\t\treturn nil, nil\n\t}\n\treturn bst.Min()\n}\nreturn bstElement.(*bst).Min()\n}"}
{"tgt": "var r [][]int\nfor i := begin; i <= end; i++ {\n\tif 1 == k {\n\t\tr = append(r, []int{i})\n\t\tcontinue\n\t}\n\tsuf := comb(i+1, end, k-1)\n\tfor _, j := range suf {\n\t\tr = append(r, append([]int{i}, j...))\n\t}\n}\nreturn r", "gen": "res := [][]int{}\nfor i := 0; i < n; i++ {\n\tif i == 0 {\n\t\tres = append(res, []int{i})\n\t\tcontinue\n\t}\n\ttmp := []int{}\n\tfor _, v := range res {\n\t\ttmp = append(tmp, v...)\n\t\ttmp = append(tmp, i)\n\t\tres = append(res, tmp)\n\t}\n}\nreturn res\n}"}
{"tgt": "b.lock.Lock()\ndefer b.lock.Unlock()\ne := b.table[key]\nif e == nil {\n\treturn nil, false\n}\nif e.expire.Before(now) {\n\tif b.ExpireGracePeriod == 0 || e.expire.Sub(now) > b.ExpireGracePeriod {\n\t\tb.removeEntry(e)\n\t}\n\treturn nil, false\n}\nb.touchEntry(e)\nreturn e.value, true", "gen": "l.mu.Lock()\ne, ok := l.cache[key]\nif !ok {\n\tl.mu.Unlock()\n\treturn nil, false\n}\nif l.expiration != nil && e.expiration.Before(time.Now()) {\n\tl.removeEntry(e)\n\treturn nil, false\n}\nl.touchEntry(e)\nl.mu.Unlock()\nreturn e.value, true\n}"}
{"tgt": "if root == nil {\n\treturn 0\n}\nresult := 0\nif root.Val >= L && root.Val <= R {\n\tresult += root.Val\n}\nif root.Val >= L {\n\tresult += rangeSumBST(root.Left, L, R)\n}\nif root.Val <= R {\n\tresult += rangeSumBST(root.Right, L, R)\n}\nreturn result", "gen": "if root == nil {\n\treturn 0\n}\nvar sum int\nif root.Val >= low && root.Val <= high {\n\tsum += root.Val\n}\nif root.Val < high {\n\tsum += rangeSumBST(root.Left, low, high)\n}\nif root.Val > low {\n\tsum += rangeSumBST(root.Right, low, high)\n}\nreturn sum\n}"}
{"tgt": "if tree.root == nil {\n\treturn nil, false\n}\ncurrentNode := tree.root\nfor currentNode != nil {\n\tif i == currentNode.data {\n\t\treturn currentNode, true\n\t} else if i > currentNode.data {\n\t\tcurrentNode = currentNode.right\n\t} else if i < currentNode.data {\n\t\tcurrentNode = currentNode.left\n\t}\n}\nreturn nil, false", "gen": "if root == nil {\n\treturn 0, false\n}\nfor root != nil {\n\tif root.Val == val {\n\t\treturn root, true\n\t} else if root.Val < val {\n\t\troot = root.Right\n\t} else {\n\t\troot = root.Left\n\t}\n}\nreturn 0, false\n}"}
{"tgt": "length := len(nums)\nif length == 0 || length == 1 && nums[0] != target {\n\treturn []int{-1, -1}\n}\nreturn searchRangeI(nums, 0, length-1, target)", "gen": "n := len(nums)\nif n == 0 || n == 1 {\n\treturn []int{-1, -1}\n}\nif target < nums[0] {\n\treturn []int{-1, -1}\n}\nif target > nums[n-1] {\n\treturn searchRangeI(nums, target)\n}\nleft, right := 0, n-1\nfor left < right {\n\tmid := left + (right-left)>>1\n\tif nums[mid] < target {\n\t\tleft = mid + 1\n\t} else {\n\t\tright = mid\n\t}\n}\nleft--\nright++\nif nums[left] < target {\n\treturn []int{left, right}\n}\nreturn []int{-1, -1}\n}"}
{"tgt": "var (\n\tl int\n\tr = len(nums) - 1\n)\nfor l <= r {\n\tmid := l + (r-l)/2\n\tif target == nums[mid] {\n\t\treturn mid\n\t}\n\tif nums[mid] >= nums[l] && nums[mid] > nums[r] {\n\t\tif target >= nums[l] && target < nums[mid] {\n\t\t\tr = mid - 1\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t} else {\n\t\tif target > nums[mid] && target <= nums[r] {\n\t\t\tl = mid + 1\n\t\t} else {\n\t\t\tr = mid - 1\n\t\t}\n\t}\n}\nreturn -1", "gen": "left, right := 0, len(nums)-1\nfor left < right {\n\tmid := (left + right) / 2\n\tif nums[mid] < target {\n\t\tleft = mid + 1\n\t} else if nums[mid] > target {\n\t\tright = mid - 1\n\t} else {\n\t\treturn mid\n\t}\n}\nreturn -1\n}"}
{"tgt": "if squares < 3 {\n\treturn 1\n}\nif answer, ok := memo[squares]; ok {\n\treturn answer\n}\ntotal := int64(1)\nfor size := 3; size <= squares; size++ {\n\tfor start := 0; start <= squares-size; start++ {\n\t\tanswer := int64(1)\n\t\tanswer *= ways(squares - start - size - 1)\n\t\ttotal += answer\n\t}\n}\nmemo[squares] = total\nreturn total", "gen": "if n < 2 {\n\treturn 1\n}\nif memo[n] != 0 {\n\treturn memo[n]\n}\nvar res int64\nfor i := 0; i < n; i++ {\n\tfor j := 1; j < n-i; j++ {\n\t\tres += ways(n-i-j, i+1) * int64(i+1)\n\t}\n}\nmemo[n] = res\nreturn res\n}"}
{"tgt": "return &CircularBuffer{\n\tbuffer: make([]interface{}, size),\n\tsize:   size,\n\tavail:  make(chan bool, size),\n}", "gen": "return &CircularBuffer{\n\tbuffer: make([]interface{}, size),\n\tread:   make(chan bool),\n\twrite:  make(chan bool),\n\tsize:   size,\n}\n}"}
{"tgt": "return uint32((dev >> 8) & 0xff)", "gen": "return int(b >> 8) & 0xFF\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 4,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 6,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 6,\n\t},\n}\nfor _, tt := range tests {\n\tgot := longestValidParentheses(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "tests := [...]testType{\n\t{\"STR\", \"STR\", 2},\n\t{\"STR\", \"STRSTR\", 4},\n\t{\"STRSTR\", \"STR\", 4},\n\t{\"STRSTRSTR\", \"STR\", 6},\n\t{\"STRSTRSTRSTR\", \"STR\", 6},\n}\nfor i, tt := range tests {\n\tif result := longestValidParentheses(tt.input); result != tt.expected {\n\t\tt.Fatalf(\"STR\", i, tt.input, tt.expected, result)\n\t}\n}\n}"}
{"tgt": "iterator := func() <-chan VertexId {\n\tch := make(chan VertexId)\n\tgo func() {\n\t\tif connected, ok := g.edges[vertex]; ok {\n\t\t\tfor VertexId, _ := range connected {\n\t\t\t\tif g.IsEdge(vertex, VertexId) {\n\t\t\t\t\tch <- VertexId\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\nreturn VerticesIterable(&vertexIterableHelper{iterFunc: iterator})", "gen": "g := &graph{\n\tvertices: vertices,\n}\nid := VertexId(id)\nreturn &vertexIterableHelper{\n\tVerticesIter: func(c chan<- VertexId) {\n\t\tg.GetSuccessors(id, c)\n\t},\n}\n}"}
{"tgt": "ans := 0\nfor ; x != 0; x /= 10 {\n\tans = ans*10 + x%10\n}\nif ans < math.MinInt32 || ans > math.MaxInt32 {\n\treturn 0\n}\nreturn ans", "gen": "var res int\nfor n > 0 {\n\tres = res*10 + n%10\n\tn /= 10\n}\nif res < -2147483648 || res > 2147483647 {\n\treturn 0\n}\nreturn res\n}"}
{"tgt": "i, size := 0, len(s)\nss := make([]string, numRows)\nfor i < size {\n\tfor j := 0; j < numRows && i < size; j++ {\n\t\tss[j] += string(s[i])\n\t\ti++\n\t}\n\tfor j := numRows - 2; j > 0 && i < size; j-- {\n\t\tss[j] += string(s[i])\n\t\ti++\n\t}\n}\nvar ret string\nfor j := 0; j < numRows; j++ {\n\tret += ss[j]\n}\nreturn ret", "gen": "var i, j int\nfor j < len(s) {\n\tfor i < len(s) && s[i] != s[j] {\n\t\ti++\n\t}\n\tfor i < len(s) && s[i] == s[j] {\n\t\ti++\n\t}\n\tj++\n}\nvar res string\nfor i := 0; i < len(s); i++ {\n\tres += string(s[i])\n}\nfor i := 0; i < len(s); i++ {\n\tres += string(s[i])\n}\nreturn res\n}"}
{"tgt": "sum := big.NewInt(0)\nfor i := int64(1); i <= 1000; i++ {\n\tval := big.NewInt(i)\n\tsum.Add(sum, pow(val, i))\n}\nfmt.Println(\"STR\", sum.String())", "gen": "result := big.NewInt(0)\nfor i := 1; i <= 1000; i++ {\n\tresult = result.Add(result, pow(big.NewInt(i), big.NewInt(i)))\n}\nfmt.Println(result.String())\n}"}
{"tgt": "for l, r := 0, len(A)-1; ; {\n\tm := (l + r) / 2\n\tif A[m] < A[m+1] {\n\t\tl = m\n\t} else if A[m-1] > A[m] {\n\t\tr = m\n\t} else {\n\t\treturn m\n\t}\n}", "gen": "left, right := 0, len(nums)-1\nfor left < right {\n\tmid := (left + right) / 2\n\tif nums[mid] < nums[mid+1] {\n\t\tleft = mid + 1\n\t} else if nums[mid] > nums[mid-1] {\n\t\tright = mid - 1\n\t} else {\n\t\treturn mid\n\t}\n}\nreturn -1\n}"}
{"tgt": "max := 1000\nsum := 0\nfor i := 1; i < max; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)", "gen": "max := 1000\nsum := 0\nfor i := 1; i <= max; i++ {\n\tif i%3 == 0 || i%5 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "if k < 0 || len(nums) == 0 {\n\treturn 0\n}\nvar count int\nm := make(map[int]int, len(nums))\nfor _, value := range nums {\n\tm[value]++\n}\nfor key := range m {\n\tif k == 0 && m[key] > 1 {\n\t\tcount++\n\t\tcontinue\n\t}\n\tif k > 0 && m[key+k] > 0 {\n\t\tcount++\n\t}\n}\nreturn count", "gen": "if len(nums) == 0 || len(nums)%2 == 1 {\n\treturn 0\n}\ncount := 0\nm := make(map[int]int)\nfor _, num := range nums {\n\tm[num]++\n}\nfor _, num := range nums {\n\tif m[num] == 1 {\n\t\tcount++\n\t}\n\tif m[num] == 2 {\n\t\tcount++\n\t\tm[num+k]++\n\t}\n}\nreturn count\n}"}
{"tgt": "parentMap, countMap := make(map[int]int), make(map[int]int)\nfor _, num := range nums {\n\tif _, exists := parentMap[num]; exists {\n\t\tcontinue\n\t}\n\tparentMap[num], countMap[num] = num, 1\n\tneighbors := [2]int{num - 1, num + 1}\n\tfor _, n := range neighbors {\n\t\tif _, exists := parentMap[n]; exists {\n\t\t\tcount1 := countMap[getParent128(n, parentMap)]\n\t\t\tcount2 := countMap[getParent128(num, parentMap)]\n\t\t\tunion128(n, num, parentMap)\n\t\t\tcountMap[getParent128(num, parentMap)] = count1 + count2\n\t\t}\n\t}\n}\nmax := 0\nfor _, count := range countMap {\n\tif count > max {\n\t\tmax = count\n\t}\n}\nreturn max", "gen": "uf := make(map[int]int)\nuf2 := make(map[int]int)\nfor _, id := range id_nums {\n\tuf[id] = id\n\tuf2[id] = id\n}\nfor i, id := range id_nums {\n\tif uf2[id] != id {\n\t\tcontinue\n\t}\n\tfor j := i + 1; j < len(id_nums); j++ {\n\t\tif uf2[id_nums[j]] != id_nums[j] {\n\t\t\tcontinue\n\t\t}\n\t\tuf[id_nums[j]] = id\n\t\tuf2[id_nums[j]] = id\n\t}\n}\nmax := 0\nfor _, id := range id_nums {\n\tif uf[id] > max {\n\t\tmax = uf[id]\n\t}\n}\nreturn max\n}"}
{"tgt": "sort.Ints(people)\nthin, fat := 0, len(people)-1\nres := 0\nfor thin <= fat {\n\tif people[thin]+people[fat] <= limit {\n\t\tthin++\n\t}\n\tfat--\n\tres++\n}\nreturn res", "gen": "sort.Ints(nums)\nleft, right := 0, len(nums)-1\nfor left < right {\n\tif nums[left]+nums[right] < target {\n\t\tleft++\n\t} else if nums[left]+nums[right] > target {\n\t\tright--\n\t} else {\n\t\treturn true\n\t}\n}\nreturn false\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{1, 8, 6, 2, 5, 4, 8, 3, 7},\n\t\twant: 49,\n\t},\n\t{\n\t\tin:   []int{1, 8, 6, 30, 20, 6, 9, 10, 1},\n\t\twant: 48,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxArea(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "tests := []struct {\n\theight []int\n\twant   int\n}{\n\t{\n\t\theight: []int{1, 8, 6, 2, 5, 4, 8, 3, 7},\n\t\twant:   49,\n\t},\n\t{\n\t\theight: []int{1, 8, 6, 30, 20, 6, 9, 10, 1},\n\t\twant:   48,\n\t},\n}\nfor i, tt := range tests {\n\tgot := maxArea(tt.height)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", i, tt.height, got, tt.want)\n\t}\n}\n}"}
{"tgt": "count, k := make([]int, 128), len(s)/4\nfor _, v := range s {\n\tcount[int(v)]++\n}\nleft, right, res := 0, -1, len(s)\nfor left < len(s) {\n\tif count['Q'] > k || count['W'] > k || count['E'] > k || count['R'] > k {\n\t\tif right+1 < len(s) {\n\t\t\tright++\n\t\t\tcount[s[right]]--\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t} else {\n\t\tres = min(res, right-left+1)\n\t\tcount[s[left]]++\n\t\tleft++\n\t}\n}\nreturn res", "gen": "var max int\nfor _, c := range s {\n\tif c < 'A' || c > 'z' {\n\t\tcontinue\n\t}\n\tif c < 'Z' {\n\t\tmax = max + 1\n\t}\n\tif c < 'S' {\n\t\tmax = max + 1\n\t}\n\tif c < 'T' {\n\t\tmax = max + 1\n\t}\n}\nvar min int\nfor i := 0; i < len(s); i++ {\n\tif i < min {\n\t\tmin = i + 1\n\t}\n\tif i > max {\n\t\tmax = i + 1\n\t}\n}\nreturn max - min\n}"}
{"tgt": "http.HandleFunc(\"STR\", handler)", "gen": "http.HandleFunc(\"/\", handler)\n}"}
{"tgt": "pairs := [...][2]int{{15, 26}, {1000, 1366}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p16(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "tests := [...]struct {\n\tin   int\n\twant int\n}{\n\t{15, 1},\n\t{26, 1},\n\t{1000, 1},\n\t{1366, 1},\n}\nfor _, tt := range tests {\n\tgot := p16(tt.in)\n\tif got != tt.want {\n\t\tt.Errorf(\"STR\", tt.in, tt.want, got)\n\t}\n}\n}"}
{"tgt": "n := len(matrix)\nl, r := matrix[0][0], matrix[n-1][n-1]\nfor l < r {\n\tm := (l + r) / 2\n\tcount := 0\n\tfor i := 0; i < n; i++ {\n\t\tj := n - 1\n\t\tfor j >= 0 && matrix[i][j] > m {\n\t\t\tj--\n\t\t}\n\t\tcount += j + 1\n\t}\n\tif count < k {\n\t\tl = m + 1\n\t} else {\n\t\tr = m\n\t}\n}\nreturn l", "gen": "n := len(A)\nm := len(B)\nif m == 0 {\n\treturn 0\n}\nmax := A[n-1] + B[0]\nans := 0\nfor i := 0; i < n; i++ {\n\tsum := A[i] + B[m-1]\n\tfor j := 0; j < m; j++ {\n\t\tif sum < A[i] {\n\t\t\tsum += B[j]\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\tif sum > max {\n\t\tmax = sum\n\t\tans = i\n\t}\n}\nreturn ans\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tm: 3,\n\t\tn: 3,\n\t\tops: [][]int{\n\t\t\t{2, 2},\n\t\t\t{3, 3},\n\t\t},\n\t\twant: 4,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxCount(tt.m, tt.n, tt.ops)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.m, got, tt.want)\n\t}\n}", "gen": "qs := []question598{\n\t{\n\t\tpara1: []int{2, 2, 3, 3},\n\t\tpara2: 2,\n\t\tans:   2,\n\t},\n\t{\n\t\tpara1: []int{2, 2, 3, 3},\n\t\tpara2: 3,\n\t\tans:   3,\n\t},\n\t{\n\t\tpara1: []int{2, 2, 3, 3},\n\t\tpara2: 4,\n\t\tans:   2,\n\t},\n}\nfmt.Printf(\"STR\" +\n\t\"\")\nfor _, q := range qs {\n\t_, p, _ := q.ans, q.para1, q.para2\n\tfmt.Printf(\"STR\" +\n\t\t\"\")\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif isPartite := IsBipartiteGraph(tc.g); isPartite != tc.isPartite {\n\t\tt.Errorf(\"STR\", tc.isPartite, isPartite)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := IsBipartiteGraph(tc.graph); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "var i int\nlength := len(nums)\nif length <= 1 {\n\treturn\n}\nfor i = length - 1; i >= 1; i-- {\n\tif nums[i] > nums[i-1] {\n\t\tbreak\n\t}\n}\nif i > 0 {\n\tsort.Ints(nums[i:])\n\tfor j := i - 1; j < length; j++ {\n\t\tif nums[j] > nums[i-1] {\n\t\t\tnums[i-1], nums[j] = nums[j], nums[i-1]\n\t\t\treturn\n\t\t}\n\t}\n}\nsort.Ints(nums)", "gen": "if len(nums) > 1 {\n\tk := len(nums) - 1\n\tfor i := k; i >= 0; i-- {\n\t\tif nums[i] < nums[i+1] {\n\t\t\tnums[i], nums[k] = nums[k], nums[i]\n\t\t\tsort.Ints(nums[i+1:])\n\t\t\tk--\n\t\t}\n\t}\n}\nsort.Ints(nums)\n}"}
{"tgt": "return LoadUint64(&r.Reg)", "gen": "return LoadUint64(&v)\n}"}
{"tgt": "var tests = []struct {\n\tnumber int\n\ttitle  string\n}{\n\t{1, \"STR\"},\n\t{28, \"STR\"},\n\t{701, \"STR\"},\n}\nfor _, tt := range tests {\n\ttitle := convertToTitle(tt.number)\n\tif title != tt.title {\n\t\tt.Errorf(\"STR\", tt.number, title, tt.title)\n\t}\n}", "gen": "var tests = []struct {\n\tinput  int\n\texpect string\n}{\n\t{1, \"A\"},\n\t{28, \"AB\"},\n\t{701, \"ZY\"},\n}\nfor _, tt := range tests {\n\tresult := convertToTitle(tt.input)\n\tif result != tt.expect {\n\t\tt.Errorf(\"STR\", tt.expect, result)\n\t}\n}\n}"}
{"tgt": "empty := countBucket{}\nfor i, _ := range ss.olist {\n\tdelete(ss.hash, ss.olist[i].key)\n\tss.olist[i] = empty\n}", "gen": "for i := 0; i < len(s.buckets); i++ {\n\tdelete(s.buckets, s.keys[i])\n\ts.keys[i], s.values[i], s.count = s.keys[i], s.values[i], s.count-1\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tresult := EloGames(tc.scores, tc.kFactor, tc.matches)\n\tfor i := range result {\n\t\tresult[i] = math.Round(result[i]*tc.tolerance) / tc.tolerance\n\t}\n\tif !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tgot := EloGames(tc.games)\n\tif !reflect.DeepEqual(got, tc.want) {\n\t\tt.Errorf(\"STR\", tc.games, tc.want, got)\n\t}\n}\n}"}
{"tgt": "l.insert(e, &l.root)", "gen": "heap.insert(heap.min, element)\n}"}
{"tgt": "if root == nil {\n\treturn 0\n}\nmax := height(root.Left)\nif h := height(root.Right); h > max {\n\tmax = h\n}\nreturn max + 1", "gen": "if root == nil {\n\treturn 0\n}\nleftHeight := height(root.Left)\nrightHeight := height(root.Right)\nif rightHeight > leftHeight {\n\tleftHeight = rightHeight\n}\nreturn leftHeight + 1\n}"}
{"tgt": "qs := []question598{\n\t{\n\t\tpara598{3, 3, [][]int{{2, 2}, {3, 3}}},\n\t\tans598{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans598, q.para598\n\tfmt.Printf(\"STR\", p, maxCount(p.m, p.n, p.ops))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question598{\n\t{\n\t\tpara598{[][]int{{2, 2}, {3, 3}}},\n\t\tans598{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans598, q.para598\n\tfmt.Printf(\"STR\", p, maxCount(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "var tests = []struct {\n\tnums    []int\n\ttarget  int\n\tindices []int\n}{\n\t{[]int{2, 7, 11, 15}, 9, []int{0, 1}},\n\t{[]int{2, 3, 4, 6}, 6, []int{0, 2}},\n\t{[]int{2, 3, 4, 7}, 8, nil},\n\t{nil, 8, nil},\n}\nfor _, tt := range tests {\n\tindices := twoSum(tt.nums, tt.target)\n\tif reflect.DeepEqual(indices, tt.indices) == false {\n\t\tt.Errorf(\"STR\", tt.nums, tt.target, indices, tt.indices)\n\t}\n}", "gen": "var nums = []int{2, 7, 11, 15}\nvar target = 9\nvar tests = []struct {\n\tnums   []int\n\ttarget int\n\twant   []int\n}{\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, 1}},\n\t{nums, target, []int{0, "}
{"tgt": "if isSquare(n) {\n\treturn 1\n}\nfor n%4 == 0 {\n\tn /= 4\n}\nif n%8 == 7 {\n\treturn 4\n}\nfor i := 1; i <= mySqrt(n); i++ {\n\tif isSquare(n - i*i) {\n\t\treturn 2\n\t}\n}\nreturn 3", "gen": "if isSquare(n) {\n\treturn 1\n}\nif n%4 == 0 {\n\treturn 4\n}\nfor i := 1; i < mySqrt(n); i++ {\n\tif isSquare(n-i*i) {\n\t\treturn 2\n\t}\n}\nreturn 3\n}"}
{"tgt": "if N < 3 {\n\treturn N\n} else if N == 3 {\n\treturn 5\n}\nmod := 1000000007\ndp := make([]int, N+1)\ndp[1], dp[2], dp[3] = 1, 2, 5\nfor i := 4; i <= N; i++ {\n\tdp[i] = 2*dp[i-1] + dp[i-3]\n\tdp[i] %= mod\n}\nreturn dp[N]", "gen": "if n <= 2 {\n\treturn n\n}\nif n == 3 {\n\treturn 5\n}\ndp := make([]int, n+1)\ndp[1], dp[2], dp[3] = 1, 2, 5\nfor i := 4; i <= n; i++ {\n\tdp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % mod\n}\nreturn dp[n]\n}"}
{"tgt": "stack := []byte{}\nfor i := range num {\n\tdigit := num[i]\n\tfor k > 0 && len(stack) > 0 && digit < stack[len(stack)-1] {\n\t\tstack = stack[:len(stack)-1]\n\t\tk--\n\t}\n\tstack = append(stack, digit)\n}\nstack = stack[:len(stack)-k]\nans := strings.TrimLeft(string(stack), \"STR\")\nif ans == \"STR\" {\n\tans = \"STR\"\n}\nreturn ans", "gen": "var res []byte\nfor _, c := range s {\n\tif c < 'A' || c > 'Z' {\n\t\tcontinue\n\t}\n\tres = append(res, c)\n}\nreturn strings.TrimLeft(string(res), \"STR\")\n}"}
{"tgt": "if e.element.list != &b.freeList {\n\tpanic(\"STR\")\n}\nif !e.expire.IsZero() {\n\theap.Push(&b.priorityQueue, e)\n}\nb.freeList.Remove(&e.element)\nb.lruList.PushElementFront(&e.element)\nb.table[e.key] = e", "gen": "if pq.Len() == 0 {\n\tpanic(\"STR\")\n}\nif pq.Len() == 1 {\n\tpq.Remove(pq.Front())\n\tpq.PushElementFront(pq.Front())\n\treturn\n}\npq.Remove(e)\npq.PushElementFront(e)\n}"}
{"tgt": "in := make([]int, N)\nout := make([]int, N)\nfor _, pair := range trust {\n\tout[pair[0]-1]++\n\tin[pair[1]-1]++\n}\nfor i := 0; i < N; i++ {\n\tif in[i] == N-1 && out[i] == 0 {\n\t\treturn i + 1\n\t}\n}\nreturn -1", "gen": "res := make([]int, len(nums))\ncount := make([]int, len(nums))\nfor _, num := range nums {\n\tres[num]++\n\tcount[num]++\n}\nfor i := 0; i < len(nums); i++ {\n\tif res[i] == 1 && count[i] == 1 {\n\t\treturn i\n\t}\n}\nreturn -1\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs int\n\texpect int\n}{\n\t{\"STR\", 2, 1},\n\t{\"STR\", 3, 2},\n\t{\"STR\", 4, 3},\n\t{\"STR\", 0, 0},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{2, 3}, 1},\n\t{\"STR\", []int{2, 3}, 1},\n\t{\"STR\", []int{2, 3}, 1},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}\n}"}
{"tgt": "return xtime.Unix(int64(jt), 0), nil", "gen": "return Time{time.Unix(0, t)}\n}"}
{"tgt": "if len(name) == 0 && len(typed) == 0 {\n\treturn true\n}\nif (len(name) == 0 && len(typed) != 0) || (len(name) != 0 && len(typed) == 0) {\n\treturn false\n}\nj := 0\nfor i := 0; i < len(name); i++ {\n\tif j < len(typed) && name[i] == typed[j] {\n\t\tj++\n\t\tcontinue\n\t} else {\n\t\tif i > 0 && j < len(typed) && name[i-1] == typed[j] {\n\t\t\tj++\n\t\t\ti--\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "if len(s) == 0 || len(t) == 0 {\n\treturn false\n}\nif len(s) != len(t) {\n\treturn false\n}\nif len(s) == len(t) {\n\treturn true\n}\ni, j := 0, 0\nfor i < len(s) {\n\tif s[i] == t[j] {\n\t\ti++\n\t\tj++\n\t} else if i < j {\n\t\ti++\n\t} else if i > j {\n\t\tj++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "var i, j, tmp int\nfor i = 1; i < len(arr); i++ {\n\ttmp = arr[i]\n\tfor j = i; j > 0 && arr[j-1] > tmp; j-- {\n\t\tarr[j] = arr[j-1]\n\t}\n\tarr[j] = tmp\n}\nreturn arr", "gen": "var i, j, tmp int\nfor i = 1; i < len(nums); i++ {\n\ttmp = nums[i]\n\tfor j = i - 1; j >= 0 && nums[j] > tmp; j-- {\n\t\tnums[j+1] = nums[j]\n\t}\n\tnums[j+1] = tmp\n}\nreturn nums\n}"}
{"tgt": "res = [][]string{}\nif len(s) < 1 {\n\treturn res\n}\nhelper(s, 0, []string{})\nreturn res", "gen": "res = [][]string{}\nif len(strs) == 0 {\n\treturn res\n}\nhelper(strs, 0, []string{})\nreturn res\n}"}
{"tgt": "if from == to {\n\treturn errors.New(\"STR\")\n}\nif !g.CheckVertex(from) || !g.CheckVertex(to) {\n\treturn errors.New(\"STR\")\n}\ni, _ := g.edges[from][to]\nj, _ := g.edges[to][from]\nif i > 0 || j > 0 {\n\treturn errors.New(\"STR\")\n}\ng.TouchVertex(from)\ng.TouchVertex(to)\ng.edges[from][to] = weight\nif !g.isDirected {\n\tg.edges[to][from] = weight\n}\ng.edgesCount++\nreturn nil", "gen": "if v1 == v2 {\n\treturn errors.New(\"STR\")\n}\nif !g.CheckVertex(v1) || !g.CheckVertex(v2) {\n\treturn errors.New(\"STR\")\n}\nif _, ok := g.edges[v1]; ok {\n\tif _, ok := g.edges[v2]; ok {\n\t\treturn errors.New(\"STR\")\n\t}\n\tg.edges[v2] = g.edges[v1]\n\tg.edges[v1] = nil\n\tg.edges[v1] = nil\n\tg.edges[v2] = g.edges[v1]\n}\ng.edges[v1] = g.edges[v2]\ng.edges[v2] = nil\ng.edges[v2] = nil\ng.edges[v1] = g.edges[v2]\nreturn nil\n}"}
{"tgt": "i := 0\ndefer fmt.Println(\"STR\", i)\ndefer fmt.Println(\"STR\")\ndefer fmt.Println(\"STR\")\ni++\nfmt.Println(\"STR\", i)", "gen": "var res bool\ndefer func() {\n\tfmt.Println(res)\n}()\nres = false\nfor i := 0; i < 2; i++ {\n\tdefer func() {\n\t\tres = true\n\t}()\n\tres = false\n\tfor j := 0; j < 2; j++ {\n\t\tdefer func() {\n\t\t\tres = true\n\t\t}()\n\t\tres = false\n\t\tfor k := 0; k < 2; k++ {\n\t\t\tdefer func() {\n\t\t\t\tres = true\n\t\t\t}()\n\t\t\tres = false\n\t\t}\n\t}\n}\n}"}
{"tgt": "maxIndex := [26]int{}\nfor i, b := range S {\n\tmaxIndex[b-'a'] = i\n}\nbegin := 0\nend := maxIndex[S[begin]-'a']\nres := make([]int, 0, len(S))\nfor i, b := range S {\n\tif i < end {\n\t\tend = max(end, maxIndex[b-'a'])\n\t\tcontinue\n\t}\n\tres = append(res, i-begin+1)\n\tbegin = i + 1\n\tif begin < len(S) {\n\t\tend = maxIndex[S[begin]-'a']\n\t}\n}\nreturn res", "gen": "dp := make([]int, 26)\nfor i := 0; i < len(s); i++ {\n\tr := s[i]\n\tif r < 'A' || r > 'Z' {\n\t\tcontinue\n\t}\n\tr -= 'A' - 1\n\tdp[r] = max(dp[r], i-start+1)\n\tstart = i + 1\n}\ndp[s[len(s)-1]-'A'] = max(dp[s[len(s)-1]-'A'], len(s)-start)\nreturn dp\n}"}
{"tgt": "FirstNumber := 1\nSecondNumber := 2\nnextNumber := 0\nsum := SecondNumber\nfor nextNumber < 4000000 {\n\tnextNumber = FirstNumber + SecondNumber\n\tif nextNumber%2 == 0 {\n\t\tsum = sum + nextNumber\n\t}\n\tFirstNumber = SecondNumber\n\tSecondNumber = nextNumber\n}\nfmt.Println(\"STR\", sum, \"STR\")", "gen": "n, m := 1, 2\nsum := 0\nfor n < 4000000 {\n\tsum += n\n\tif sum%2 == 0 {\n\t\tsum += n\n\t}\n\tn, m = m, n+m\n}\nfmt.Println(sum)\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{2},\n\t\t\t{3, 4},\n\t\t\t{6, 5, 7},\n\t\t\t{4, 1, 8, 3},\n\t\t},\n\t\t11},\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{1},\n\t\t\t{2, 3},\n\t\t},\n\t\t3},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := minimumTotal(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{{2, 3, 4}, {1, 2, 3, 4}, {6, 5, 7}}, 11},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := maxProfit(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got)\n\t\t}\n\t})\n}\n}"}
{"tgt": "timeDelta := now.Sub(r.lastTimestamp)\nreturn r.Ewma.Update(nanosec/float64(timeDelta.Nanoseconds()), now)", "gen": "return e.Update(time.Since(t)).Value()\n}"}
{"tgt": "if list.head == nil {\n\treturn false\n}\nif list.head.data == i {\n\tlist.head = list.head.next\n\treturn true\n}\ncurrent := list.head\nfor current.next != nil {\n\tif current.next.data == i {\n\t\tcurrent.next = current.next.next\n\t\treturn true\n\t}\n\tcurrent = current.next\n}\nreturn false", "gen": "if head == nil {\n\treturn false\n}\nif head.Val == val {\n\thead = head.Next\n\treturn true\n}\nfor head != nil {\n\tif head.Next.Val == val {\n\t\thead.Next = head.Next.Next\n\t\treturn true\n\t}\n\thead = head.Next\n}\nreturn false\n}"}
{"tgt": "mySet := make(map[int]int, 0)\nfor _, v := range candies {\n\tmySet[v]++\n}\nif len(mySet) >= len(candies)/2 {\n\treturn len(candies) / 2\n}\nreturn len(mySet)", "gen": "m := make(map[int]int)\nfor _, v := range nums {\n\tm[v]++\n}\nif len(m) == 0 {\n\treturn 0\n}\nif len(m) == len(nums) {\n\treturn 1\n}\nreturn 2\n}"}
{"tgt": "a := []float64{1, 2, 3, 4, 5, 6}\nA := MakeMatrix(a, 3, 2)\nif A.cols != 2 ||\n\tA.rows != 3 ||\n\t!FloatArrayEquals(A.Elements, a) {\n\tt.Error()\n}", "gen": "a := []float64{1, 2, 3, 4, 5, 6}\nm := MakeMatrix(a, 2, 3)\nif m.Rows != 2 || m.Cols != 3 {\n\tt.Error()\n}\nif !FloatArrayEquals(m.Data, []float64{3, 4, 5, 6, 7, 8}) {\n\tt.Error()\n}\n}"}
{"tgt": "count := 0\nfor _, c := range word {\n\tif unicode.IsUpper(c) {\n\t\tcount++\n\t}\n}\nreturn count == 0 || count == len(word) || (count == 1 && unicode.IsUpper(rune(word[0])))", "gen": "count := 0\nfor _, c := range s {\n\tif unicode.IsUpper(c) {\n\t\tcount++\n\t}\n}\nif count == 0 || count == len(s) {\n\treturn false\n}\nif s[0] == 'A' {\n\treturn true\n}\nreturn false\n}"}
{"tgt": "p.mu.Lock()\nactive := p.active\np.mu.Unlock()\nreturn active", "gen": "self.lock.Lock()\ndefer self.lock.Unlock()\nreturn self.size\n}"}
{"tgt": "select {\ncase r, ok := <-p.resources:\n\tlog.Println(\"STR\", \"STR\")\n\tif !ok {\n\t\treturn nil, ErrPoolClosed\n\t}\n\treturn r, nil\ndefault:\n\tlog.Println(\"STR\", \"STR\")\n\treturn p.factory()\n}", "gen": "select {\ncase <-p.closed:\n\tlog.Println(\"STR\", ErrPoolClosed)\n\treturn ErrPoolClosed\ncase conn := <-p.pool:\n\treturn conn\n}\nreturn nil\n}"}
{"tgt": "err := ioutil.WriteFile(path, []byte(content), 0755)\nif err != nil {\n\tlog.Fatal(err)\n}", "gen": "err := ioutil.WriteFile(\"test.txt\", []byte(\"STR\"), 493)\nif err != nil {\n\tlog.Fatal(err)\n}\n}"}
{"tgt": "tree := New(compare)\ntree.Insert(1)\ntree.Insert(2)\ntree.Insert(3)\nfindTree := tree.Search(2)\nif findTree.node != 2 {\n\tt.Error(\"STR\")\n}\nfindNilTree := tree.Search(100)\nif findNilTree != nil {\n\tt.Error(\"STR\")\n}", "gen": "tree := New(compare)\ntree.Insert(1)\ntree.Insert(2)\ntree.Insert(3)\nif tree.Search(1) != 1 {\n\tt.Error(\"STR\")\n}\nif tree.Search(2) != 2 {\n\tt.Error(\"STR\")\n}\nif tree.Search(3) != 3 {\n\tt.Error(\"STR\")\n}\nif tree.Search(4) != nil {\n\tt.Error(\"STR\")\n}\n}"}
{"tgt": "l := new(ListNode)\nn := l\nvar extra int\nfor l1 != nil || l2 != nil {\n\tn.Next = new(ListNode)\n\tn = n.Next\n\tif l1 != nil {\n\t\textra += l1.Val\n\t\tl1 = l1.Next\n\t}\n\tif l2 != nil {\n\t\textra += l2.Val\n\t\tl2 = l2.Next\n\t}\n\tn.Val = extra % 10\n\textra /= 10\n}\nif extra > 0 {\n\tn.Next = &ListNode{Val: extra}\n}\nreturn l.Next", "gen": "var sum int\nvar head, tail *ListNode\nfor head != nil || tail != nil {\n\tsum += tail.Val\n\tif head != nil {\n\t\tsum += head.Val\n\t\ttail.Val = sum % 1000000007\n\t\thead = head.Next\n\t} else {\n\t\ttail.Val = sum % 1000000007\n\t}\n\tsum /= 1000000007\n}\nreturn tail\n}"}
{"tgt": "empty := 0\nhold := -1 << 63\nfor _, p := range prices {\n\ttemp := empty\n\tempty = max(empty, hold+p)\n\thold = max(hold, temp-p-fee)\n}\nreturn empty", "gen": "max := 0\nmin := -9223372036854775808\nfor _, num := range nums {\n\tmax = maxMax(max, num)\n\tmin = minMin(min, num)\n}\nreturn max - min\n}"}
{"tgt": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"STR\", got, tt.want)\n\t\t}\n\t})\n}", "gen": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tgot := largestOverlap(tt.args.A, tt.args.B)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"largestOverlap() = %v, want %v\", got, tt.want)\n\t\t}\n\t})\n}\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   5,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   10,\n\t\twant: 5,\n\t},\n\t{\n\t\tin:   0,\n\t\twant: 1,\n\t},\n}\nfor _, tt := range tests {\n\tgot := bitwiseComplement(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "tests := []struct {\n\tinput  int\n\texpect int\n}{\n\t{5, 2},\n\t{7, 0},\n\t{0, 1},\n\t{10, 5},\n\t{5, 2},\n}\nfor _, tt := range tests {\n\tif result := bitwiseComplement(tt.input); result != tt.expect {\n\t\tt.Fatalf(\"STR\", tt.input, tt.expect, result)\n\t}\n}\n}"}
{"tgt": "syscall.Exit(code)", "gen": "syscall.Exit(0)\n}"}
{"tgt": "if len(input) == 0 {\n\treturn true\n}\nif len(input)%2 != 0 {\n\treturn false\n}\nvar stack []byte\nfor i := 0; i < len(input); i++ {\n\tif input[i] == \"STR\" || input[i] == \"STR\" || input[i] == \"STR\" {\n\t\tstack = append(stack, input[i])\n\t} else {\n\t\tif len(stack) > 0 {\n\t\t\tpair := string(stack[len(stack)-1]) + string(input[i])\n\t\t\tstack = stack[:len(stack)-1]\n\t\t\tif pair != \"STR\" && pair != \"STR\" && pair != \"STR\" {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn len(stack) == 0", "gen": "if len(s) == 0 {\n\treturn true\n}\nif len(s)%2 == 1 {\n\treturn false\n}\nvar stack []byte\nfor i := 0; i < len(s); i++ {\n\tif s[i] == '(' || s[i] == '{' || s[i] == '[' {\n\t\tstack = append(stack, s[i])\n\t} else {\n\t\tif len(stack) == 0 {\n\t\t\treturn false\n\t\t}\n\t\tif s[i] == ')' && stack[len(stack)-1] != '(' {\n\t\t\treturn false\n\t\t}\n\t\tif s[i] == ']' && stack[len(stack)-1] != '[' {\n\t\t\treturn false\n\t\t}\n\t\tif s[i] == '}' && stack[len(stack)-1] != '{' {\n\t\t\treturn false\n\t\t}\n\t\tstack = stack[:len(stack)-1]\n\t}\n}\nif len(stack) == 0 {\n\treturn true\n}\nreturn false\n}"}
{"tgt": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 0},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 11},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 19},\n\t\tans1208{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s, p.t, p.maxCost))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\"},\n\t\ttrue,\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\"},\n\t\ttrue,\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\"},\n\t\ttrue,\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s1, p.s2))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{124123, 13425, 123, 65, 1, 54362, 134, 6543, 213}, 3},\n\t{\"STR\", []int{}, 0},\n\t{\"STR\", []int{4253626756, 3245876, 2345897, 23490}, 1},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{124123, 13425, 123, 65, 1, 54362, 134, 6543, 213}, 4253626756},\n\t{\"STR\", []int{4253626756, 3245876, 2345897, 23490, 1}, 4253626756},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}\n}"}
{"tgt": "if len(sorted) == 0 {\n\treturn nil\n}\nmid := len(sorted) / 2\nroot := &BST{Value: sorted[mid]}\nroot.Left = SortedSliceToBST(sorted[:mid])\nroot.Right = SortedSliceToBST(sorted[mid+1:])\nreturn root", "gen": "if len(nums) == 0 {\n\treturn nil\n}\nmid := len(nums) / 2\nleft := SortedSliceToBST(nums[:mid])\nright := SortedSliceToBST(nums[mid+1:])\nreturn &BST{\n\tVal:   nums[mid],\n\tLeft:  left,\n\tRight: right,\n}\n}"}
{"tgt": "negative := false\nif num < 0 {\n\tnegative = true\n\tnum = -num\n}\nbf := bytes.NewBufferString(\"STR\")\nfor num >= 7 {\n\tmod := num % 7\n\tnum /= 7\n\tbf.WriteByte(byte(mod) + 48)\n}\nbf.WriteByte(byte(num) + 48)\nif negative {\n\tbf.WriteByte('-')\n}\nbs := bf.Bytes()\nfor s, e := 0, len(bs)-1; s < e; s, e = s+1, e-1 {\n\tbs[s], bs[e] = bs[e], bs[s]\n}\nreturn string(bs)", "gen": "negative := n < 0\nn = abs(n)\nbuf := bytes.NewBufferString(\"\")\nfor n > 0 {\n\tbuf.WriteByte(byte(n%10 + '0'))\n\tn /= 10\n}\nbuf.WriteByte('-')\nif negative {\n\tbuf.WriteByte('-')\n}\nreturn buf.String()\n}"}
{"tgt": "s = strings.ToLower(s)\ni, j := 0, len(s)-1\nfor i < j {\n\tfor i < j && !isChar(s[i]) {\n\t\ti++\n\t}\n\tfor i < j && !isChar(s[j]) {\n\t\tj--\n\t}\n\tif s[i] != s[j] {\n\t\treturn false\n\t}\n\ti++\n\tj--\n}\nreturn true", "gen": "s = strings.ToLower(s)\ni, j := 0, len(s)-1\nfor i < j {\n\tfor !isChar(s[i]) {\n\t\ti++\n\t}\n\tfor !isChar(s[j]) {\n\t\tj--\n\t}\n\tif s[i] != s[j] {\n\t\treturn false\n\t}\n\ti++\n\tj--\n}\nreturn true\n}"}
{"tgt": "n := len(nums)\ntmp := make([]int, n)\ncopy(tmp, nums)\nfor i := 0; i < n; i++ {\n\tnums[(i+k)%n] = tmp[i]\n}", "gen": "n := len(nums)\nres := make([]int, n)\nfor i := 0; i < n; i++ {\n\tres[i] = nums[i*n%len(nums)]\n}\nreturn res\n}"}
{"tgt": "random := rand.New(rand.NewSource(time.Now().UnixNano()))\narray := make([]int, random.Intn(100-10)+10)\nfor i := range array {\n\tarray[i] = random.Intn(100)\n}\nSortArray(array)\nfor _, value := range array {\n\tresult := ExponentialSearch(array, value)\n\tif result == -1 {\n\t\tt.Fail()\n\t}\n}", "gen": "rand.Seed(time.Now().UnixNano())\narr := make([]int, 100)\nfor i := 0; i < 100; i++ {\n\tarr[i] = rand.Intn(100)\n}\nfor i := 0; i < 100; i++ {\n\tif ExponentialSearch(arr, i) != i {\n\t\tt.Fail()\n\t}\n}\nSortArray(arr)\nfor i := 0; i < 100; i++ {\n\tif ExponentialSearch(arr, i) != i {\n\t\tt.Fail()\n\t}\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimumPartitionPalindrome(tc.input); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimumPartitionPalindrome(tc.input); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "obj := Constructor732()\nfmt.Printf(\"STR\", obj.Book(10, 20))\nfmt.Printf(\"STR\", obj.Book(50, 60))\nfmt.Printf(\"STR\", obj.Book(10, 40))\nfmt.Printf(\"STR\", obj.Book(5, 15))\nfmt.Printf(\"STR\", obj.Book(5, 10))\nfmt.Printf(\"STR\", obj.Book(25, 55))", "gen": "c := Constructor732()\nc.Book(20, 10)\nfmt.Printf(\"STR\", c.Book(60, 50))\nfmt.Printf(\"STR\", c.Book(40, 10))\nfmt.Printf(\"STR\", c.Book(15, 5))\nfmt.Printf(\"STR\", c.Book(10, 5))\nfmt.Printf(\"STR\", c.Book(55, 25))\nfmt.Printf(\"STR\", c.Book(50, 25))\n}"}
{"tgt": "if a == nil && b == nil {\n\treturn true\n}\nif len(a) != len(b) {\n\treturn false\n}\nfor i := range a {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "if len(s) == 0 || len(s) == len(t) {\n\treturn false\n}\nif len(s) == len(t) {\n\treturn true\n}\nfor i := 0; i < len(s); i++ {\n\tif s[i] != t[i] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "val := \"STR\"\nfor i := 1; i < n; i++ {\n\tvar (\n\t\tc   int\n\t\tv   byte\n\t\tstr string\n\t)\n\tfor j := 0; j < len(val); j++ {\n\t\tif val[j] == v {\n\t\t\tc++\n\t\t\tcontinue\n\t\t}\n\t\tif c != 0 {\n\t\t\tstr += string(c+'0') + string(v)\n\t\t}\n\t\tc, v = 1, val[j]\n\t}\n\tval = str + string(c+'0') + string(v)\n}\nreturn val", "gen": "var (\n\tres string\n\tcnt int\n\ti   int\n)\nfor i = 1; i <= n; i++ {\n\tcnt = 0\n\tres = \"STR\"\n\tfor j := 0; j < len(s); j++ {\n\t\tif s[j] == 'STR'[cnt] {\n\t\t\tcnt++\n\t\t} else if cnt > 0 {\n\t\t\tres += \"STR\"[cnt]\n\t\t\tcnt = 0\n\t\t}\n\t}\n\tif cnt > 0 {\n\t\tres += \"STR\"[cnt]\n\t}\n\tres += \"STR\"[i]\n}\nreturn res\n}"}
{"tgt": "res := 0\nif n != 0 {\n\trightMostBitInt := n & -n\n\tnextHigherSetBitInt := n + rightMostBitInt\n\td := n ^ nextHigherSetBitInt\n\td /= rightMostBitInt\n\td >>= 2\n\tres = nextHigherSetBitInt | d\n}\nreturn res", "gen": "var res int\nif n != 0 {\n\tres = (n - 1) ^ (n + 1)\n\tres = (res >> 2) ^ (res & 3)\n}\nreturn res\n}"}
{"tgt": "if len(nums) == 0 || len(nums) < k {\n\treturn make([]int, 0)\n}\nqueue := make([]int, 0, k)\nans := make([]int, len(nums)-k+1)\nfor left, right := 1-k, 0; right < len(nums); left, right = left+1, right+1 {\n\tif left > 0 && queue[0] == nums[left-1] {\n\t\tqueue = queue[1:len(queue)]\n\t}\n\tfor len(queue) != 0 && queue[len(queue)-1] < nums[right] {\n\t\tqueue = queue[:len(queue)-1]\n\t}\n\tqueue = append(queue, nums[right])\n\tif left >= 0 {\n\t\tans[left] = queue[0]\n\t}\n}\nreturn ans", "gen": "if len(nums) == 0 || k > len(nums) {\n\treturn []int{}\n}\nres := make([]int, 0)\nstart, end := 0, len(nums)-k\nfor start < end {\n\tif nums[start] == nums[end] {\n\t\tres = append(res, nums[start])\n\t\tstart++\n\t\tend--\n\t} else if nums[start] < nums[end] {\n\t\tstart++\n\t} else {\n\t\tend--\n\t}\n}\nreturn res\n}"}
{"tgt": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{}\n} else if n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{intervals[0]}\nfor _, cur := range intervals[1:] {\n\tprevious := res[len(res)-1]\n\tif cur.Start <= previous.End {\n\t\tend := previous.End\n\t\tif cur.End > end {\n\t\t\tend = cur.End\n\t\t}\n\t\tres = append(res[:len(res)-1], Interval{Start: previous.Start, End: end})\n\t} else {\n\t\tres = append(res, cur)\n\t}\n}\nreturn res", "gen": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{{}}\n}\nif n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{{intervals[0]}}\nfor i := 1; i < n; i++ {\n\tif res[len(res)-1].End < intervals[i].Start {\n\t\tres = append(res, intervals[i])\n\t} else {\n\t\tres[len(res)-1].End = max(res[len(res)-1].End, intervals[i].End)\n\t}\n}\nreturn res\n}"}
{"tgt": "max := 9999\nbiggestPandigital := 0\nvar numberMultiplied int\nfor i := max; i > 0; i-- {\n\tnumberMultiplied = i\n\tfor j := 1; len(digits(numberMultiplied)) <= 9; j++ {\n\t\tnumberMultiplied = concatenMultiplication(i, j)\n\t\tif IsPandigital(numberMultiplied) && numberMultiplied > biggestPandigital {\n\t\t\tfmt.Println(numberMultiplied)\n\t\t\tbiggestPandigital = numberMultiplied\n\t\t}\n\t}\n}", "gen": "n := 9999\nmax := 0\nfor n > 0 {\n\tm := concatenMultiplication(n)\n\tif IsPandigital(m) {\n\t\tif m > max {\n\t\t\tmax = m\n\t\t}\n\t}\n\tn--\n}\nfmt.Println(max)\n}"}
{"tgt": "n := len(pushed)\ns := make([]int, 0, n)\ni := 0\nfor _, x := range pushed {\n\ts = append(s, x)\n\tfor len(s) != 0 && s[len(s)-1] == popped[i] {\n\t\ts = s[:len(s)-1]\n\t\ti++\n\t}\n}\nreturn i == n", "gen": "n := len(nums)\nres := make([]int, 0, n)\ni := 0\nfor j := 0; j < n; j++ {\n\tres = append(res, nums[j])\n\tfor i < j && res[i] == res[j] {\n\t\ti++\n\t}\n}\nreturn len(res) == n\n}"}
{"tgt": "testCases := [][]int{\n\t{1, 2, 3, 1},\n\t{1, 0, 1, 1},\n\t{1, 2, 3, 1, 2, 3},\n}\nks := []int{3, 1, 2}\nexpected := []bool{true, true, false}\nfor index, nums := range testCases {\n\tif res := containsNearbyDuplicate(nums, ks[index]); res != expected[index] {\n\t\tt.Errorf(\"STR\", expected[index], res)\n\t}\n}", "gen": "tests := []struct {\n\tnums   []int\n\tk      int\n\texpect bool\n}{\n\t{[]int{1, 2, 3, 1}, 3, true},\n\t{[]int{1, 0, 1, 1}, 1, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 2, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 3, true},\n\t{[]int{1, 2, 3, 1, 2, 3}, 4, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 5, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 6, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 7, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 8, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 9, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 10, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 11, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 12, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 13, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 14, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 15, false},\n\t{[]int{1, 2, 3"}
{"tgt": "item := req.URL.Query().Get(\"STR\")\nif price, ok := db[item]; ok {\n\tfmt.Fprintf(w, \"STR\", price)\n} else {\n\tw.WriteHeader(http.StatusNotFound)\n\tfmt.Fprintf(w, \"STR\", item)\n}", "gen": "query := u.Query()\nvalue := query.Get(\"code\")\nif value != \"\" {\n\tcode, _ := strconv.Atoi(value)\n\treturn code\n}\nfmt.Fprintf(w, \"STR\")\nfmt.Fprintf(w, \"STR\")\n}"}
{"tgt": "l, r := &maxHeap{}, &minHeap{}\nheap.Init(l)\nheap.Init(r)\nreturn MedianFinder{l, r}", "gen": "maxHeap := &maxHeap{}\nminHeap := &minHeap{}\nheap.Init(maxHeap)\nheap.Init(minHeap)\nreturn &MedianFinder{\n\tmaxHeap: maxHeap,\n\tminHeap: minHeap,\n}\n}"}
{"tgt": "var buf [32]byte\ni := len(buf) - 1\nfor val >= 10 {\n\tbuf[i] = byte(val%10 + \"STR\")\n\ti--\n\tval /= 10\n}\nbuf[i] = byte(val + \"STR\")\nreturn string(buf[i:])", "gen": "var res string\nfor i := 31; i >= 0; i-- {\n\tres = string(res + \"STR\"[i])\n\tnum /= 32\n}\nreturn res\n}"}
{"tgt": "if len(nums1) == 0 || len(nums2) == 0 {\n\treturn []int{}\n}\nnum1Map := make(map[int]bool)\nfor i := range nums1 {\n\tnum1Map[nums1[i]] = true\n}\nnum2Map := make(map[int]bool)\nvar res []int\nfor i := range nums2 {\n\tif _, ok1 := num1Map[nums2[i]]; ok1 && !num2Map[nums2[i]] {\n\t\tnum2Map[nums2[i]] = true\n\t\tres = append(res, nums2[i])\n\t}\n}\nreturn res", "gen": "if len(nums) == 0 || len(queries) == 0 {\n\treturn nil\n}\nm := make(map[int]bool)\nfor _, num := range nums {\n\tm[num] = true\n}\nm2 := make(map[int]bool)\nfor _, query := range queries {\n\tif _, ok := m[query]; ok {\n\t\tm2[query] = true\n\t}\n}\nres := make(map[int]bool)\nfor _, num := range nums {\n\tif _, ok := m2[num]; ok {\n\t\tres[num] = true\n\t}\n}\nreturn res\n}"}
{"tgt": "var ret [][]int\nvar nums []int\nnums = []int{-1, 0, 1, 2, -1, -4}\nret = [][]int{{-1, -1, 2}, {-1, 0, 1}}\nfor k, num := range threeSum(nums) {\n\tfor i, v := range num {\n\t\tif v != ret[k][i] {\n\t\t\tt.Fatalf(\"STR\", ret)\n\t\t}\n\t}\n}", "gen": "var res [][]int\nvar nums = []int{-1, 0, 1, -4}\nvar target = -1\nvar result = threeSum(nums)\nfor i := 0; i < len(result); i++ {\n\tfor j := 0; j < len(result[i]); j++ {\n\t\tif result[i][j] == target {\n\t\t\tres = append(res, result[i])\n\t\t}\n\t}\n}\nif !reflect.DeepEqual(res, [][]int{{-1, 0, 1}, {-1, -4, 1}}) {\n\tt.Fatalf(\"STR\", res, [][]int{{-1, 0, 1}, {-1, -4, 1}})\n}\n}"}
{"tgt": "dist := make([]int, N+1)\nfor i := 0; i < len(dist); i++ {\n\tdist[i] = math.MaxInt32\n}\ndist[K] = 0\nfor i := 0; i < N; i++ {\n\tfor _, t := range times {\n\t\tu, v, w := t[0], t[1], t[2]\n\t\tif dist[u] != math.MaxInt32 && dist[v] > dist[u]+w {\n\t\t\tdist[v] = dist[u] + w\n\t\t}\n\t}\n}\nmx := 0\nfor i := 1; i <= N; i++ {\n\tif mx < dist[i] {\n\t\tmx = dist[i]\n\t}\n}\nif mx == math.MaxInt32 {\n\treturn -1\n}\nreturn mx", "gen": "dp := make([]int, len(nums)+1)\nfor i := 0; i < len(nums); i++ {\n\tdp[i+1] = 2147483647\n}\ndp[0] = 0\nfor i := 1; i < len(nums); i++ {\n\tfor j := 0; j < i; j++ {\n\t\tif nums[i] > nums[j] && dp[j]+1 > dp[i] {\n\t\t\tdp[i] = dp[j] + 1\n\t\t}\n\t}\n}\nmax := 0\nfor i := 1; i < len(nums); i++ {\n\tif max < dp[i] {\n\t\tmax = dp[i]\n\t}\n}\nif max == 2147483647 {\n\treturn -1\n}\nreturn max\n}"}
{"tgt": "dat, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\nnamesList := string(dat)\nnamesList = strings.Replace(namesList, \"STR\", \"STR\", -1)\nnames := strings.Split(namesList, \"STR\")\nsort.Strings(names)\nnamesScore := 0\nfor index, name := range names {\n\tnamesScore += nameScore(name) * (index + 1)\n}\nfmt.Println(namesScore)", "gen": "data, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)\ndata = []byte(STR)"}
{"tgt": "var matrix [][]int\nmatrix = [][]int{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 9},\n}\nrotate(matrix)", "gen": "nums1 := []int{1, 2, 3, 4, 5, 6, 7}\nnums2 := []int{4, 5, 6, 7, 8, 9}\nrotate(nums1, 3)\nfmt.Println(nums1)\nfmt.Println(nums2)\n}"}
{"tgt": "curr := n\nfor _, c := range s {\n\tnext, ok := curr.children[c]\n\tif !ok {\n\t\tnext = NewNode()\n\t\tcurr.children[c] = next\n\t}\n\tcurr = next\n}\ncurr.isLeaf = true", "gen": "for _, c := range s {\n\tn := t.root\n\tfor i := 0; i < len(s); i++ {\n\t\tif c > 127 {\n\t\t\tbreak\n\t\t}\n\t\tc = rune(c)\n\t\tn = n.children[c]\n\t}\n\tn.isWord = true\n\tt.root = n\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "sum := 0\nfor i := 2; i < 999999; i++ {\n\tif isSumOfFivePowerOfDigitsEqualToNumber(i) {\n\t\tsum += i\n\t}\n}\nreturn sum", "gen": "sum := 0\nfor i := 2; i < 1000000; i++ {\n\tif isSumOfFivePowerOfDigitsEqualToNumber(i) {\n\t\tsum += i\n\t}\n}\nreturn sum\n}"}
{"tgt": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nret := &ListNode{}\nif l1.Val <= l2.Val {\n\tret = l1\n\tret.Next = mergeTwoLists1(l1.Next, l2)\n} else {\n\tret = l2\n\tret.Next = mergeTwoLists1(l1, l2.Next)\n}\nreturn ret", "gen": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nif l1.Val < l2.Val {\n\tl1.Next = mergeTwoLists1(l1.Next, l2)\n\treturn l1\n}\nl2.Next = mergeTwoLists1(l1, l2.Next)\nreturn l2\n}"}
{"tgt": "a := int(math.Log10(float64(number))) + 1\nresult := 0\nfor i := 1; i <= a; i++ {\n\tresult += digit(number, i) * int(math.Pow10(a-i))\n}\nreturn result", "gen": "n := int(math.Log10(float64(n))) + 1\nsum := 0\nfor i := 1; i <= n; i++ {\n\tsum += digit(n, i) * int(math.Pow10(n-i))\n}\nreturn sum\n}"}
{"tgt": "maxans := 0\ndp := make([]int, len(s))\nfor i := 1; i < len(s); i++ {\n\tif s[i] == \"STR\" {\n\t\tif s[i-1] == \"STR\" {\n\t\t\tif i >= 2 {\n\t\t\t\tdp[i] = dp[i-2] + 2\n\t\t\t} else {\n\t\t\t\tdp[i] = 2\n\t\t\t}\n\t\t} else if i-dp[i-1] > 0 && s[i-dp[i-1]-1] == \"STR\" {\n\t\t\tif i-dp[i-1] >= 2 {\n\t\t\t\tdp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2\n\t\t\t} else {\n\t\t\t\tdp[i] = dp[i-1] + 2\n\t\t\t}\n\t\t}\n\t}\n\tmaxans = Max(maxans, dp[i])\n}\nreturn maxans", "gen": "res := 0\ndp := make([]int, len(s))\ndp[0] = 1\nfor i := 1; i < len(s); i++ {\n\tif s[i] == '(' {\n\t\tif i < len(s)-1 && s[i+1] == ')' {\n\t\t\tdp[i+1] = dp[i] + 2\n\t\t} else {\n\t\t\tdp[i+1] = dp[i] + 1\n\t\t}\n\t} else {\n\t\tif i > 0 && s[i-1] == '(' {\n\t\t\tdp[i] = dp[i-1] + 2\n\t\t} else {\n\t\t\tdp[i] = dp[i-1] + 1\n\t\t}\n\t}\n\tres = Max(res, dp[i])\n}\nreturn res\n}"}
{"tgt": "s.lock.Lock()\ndefer s.lock.Unlock()\nl := len(s.nodes)\nif l == 0 {\n\treturn nil, errors.New(\"STR\")\n}\nnode := s.nodes[l-1]\ns.nodes = s.nodes[:l-1]\nreturn node, nil", "gen": "defer func() {\n\tif err != nil {\n\t\terr = errors.New(\"STR\")\n\t}\n}()\nif len(root) == 0 {\n\treturn nil, errors.New(\"STR\")\n}\nreturn root[0], nil\n}"}
{"tgt": "max1, max2, max3, min1, min2 := -1001, -1001, -1001, 1001, 1001\nfor _, v := range nums {\n\tif v > max1 {\n\t\tmax3 = max2\n\t\tmax2 = max1\n\t\tmax1 = v\n\t} else if v > max2 {\n\t\tmax3 = max2\n\t\tmax2 = v\n\t} else if v > max3 {\n\t\tmax3 = v\n\t}\n\tif v < min1 {\n\t\tmin2 = min1\n\t\tmin1 = v\n\t} else if v < min2 {\n\t\tmin2 = v\n\t}\n}\nreturn max(max1*min1*min2, max1*max2*max3)", "gen": "max, min := -1001, -1001\nfor _, num := range nums {\n\tif num > max {\n\t\tmax = num\n\t}\n\tif num < min {\n\t\tmin = num\n\t}\n}\nreturn max * min\n}"}
{"tgt": "h := fnv.New64a()\n_, _ = h.Write([]byte(fmt.Sprintf(\"STR\", key)))\nhashValue := h.Sum64()\nreturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))", "gen": "hasher := fnv.New64a()\nhasher.Write([]byte(fmt.Sprintf(\"STR\", len(STR))))\nreturn hasher.Sum64() & STR[0]\n}"}
{"tgt": "arr := make([]int, n+1, n+1)\narr[0] = 0\narr[1] = 1\nfor x := 2; x <= n; x++ {\n\tarr[x] = -1\n}\nreturn fibonacciDyamic(n, arr)", "gen": "f := make([]int, n+2)\nf[0], f[1] = 0, 1\nfor i := 2; i <= n; i++ {\n\tf[i] = -1\n}\nreturn fibonacciDyamic(f, n)\n}"}
{"tgt": "*ss = Count{\n\tolist: make([]countBucket, size),\n\thash:  make(map[string]uint32, size),\n}\nreturn ss", "gen": "return Count{\n\tbuckets: make([]uint32, len(s)),\n\tcounts:  make(map[string]uint32, len(s)),\n}\n}"}
{"tgt": "if len(nums) == 0 {\n\treturn 0\n} else if len(nums) == 1 {\n\treturn nums[0]\n}\nmax := func(m, n int) int {\n\tif m > n {\n\t\treturn m\n\t}\n\treturn n\n}\ndp := []int{nums[0], max(nums[0], nums[1])}\nfor i := 2; i < len(nums); i++ {\n\tdp[i%2] = max(dp[(i-1)%2], nums[i]+dp[i%2])\n}\nreturn dp[(len(nums)-1)%2]", "gen": "if len(nums) == 0 {\n\treturn 0\n}\nif len(nums) == 1 {\n\treturn nums[0]\n}\ndp := make([]int, len(nums))\ndp[0] = nums[0]\ndp[1] = max(nums[0], nums[1])\nfor i := 2; i < len(nums); i++ {\n\tdp[i] = max(dp[i-2]+nums[i], dp[i-1])\n}\nreturn dp[len(nums)-1]\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CanHopToEnd(tc.hops); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.hops, tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := CanHopToEnd(tc.start, tc.end, tc.hops); res != tc.expected {\n\t\tt.Errorf(\"STR\", tc.start, tc.end, tc.hops, tc.expected, res)\n\t}\n}\n}"}
{"tgt": "n := NewNode()\ninsertWords := [...]string{\n\t\"STR\",\n\t\"STR\",\n}\ncheckWords := map[string]bool{\n\t\"STR\": false,\n\t\"STR\": false,\n\t\"STR\": true,\n}\nfor _, w := range insertWords {\n\tn.Insert(w)\n\tt.Logf(\n\t\t\"STR\",\n\t\tw,\n\t)\n}\nfor k, v := range checkWords {\n\tok := n.Find(k)\n\tif ok != v {\n\t\tt.Fatalf(\n\t\t\t\"STR\",\n\t\t\tk,\n\t\t\tmap[bool]string{true: \"STR\"}[v],\n\t\t)\n\t}\n\tt.Logf(\n\t\t\"STR\",\n\t\tk,\n\t\tmap[bool]string{true: \"STR\"}[ok],\n\t)\n}", "gen": "trie := NewNode()\nstrs := []string{\"STR\", \"STR\", \"STR\"}\nfor _, str := range strs {\n\ttrie.Insert(str)\n}\nfor str, ok := trie.Find(strs[0]); ok; str, ok = trie.Find(strs[0]) {\n\tt.Fatalf(\"STR\")\n}\nfor str, ok := trie.Find(strs[1]); ok; str, ok = trie.Find(strs[1]) {\n\tt.Fatalf(\"STR\")\n}\nfor str, ok := trie.Find(strs[2]); ok; str, ok = trie.Find(strs[2]) {\n\tt.Fatalf(\"STR\")\n}\n}"}
{"tgt": "if cl.Size > 0 {\n\tif places < 0 {\n\t\tmultiple := cl.Size - 1 - places/cl.Size\n\t\tplaces += multiple * cl.Size\n\t}\n\tplaces %= cl.Size\n\tif places > cl.Size/2 {\n\t\tplaces = cl.Size - places\n\t\tfor i := 0; i < places; i++ {\n\t\t\tcl.Head = cl.Head.Prev\n\t\t}\n\t} else if places == 0 {\n\t\treturn\n\t} else {\n\t\tfor i := 0; i < places; i++ {\n\t\t\tcl.Head = cl.Head.Next\n\t\t}\n\t}\n}", "gen": "if len(this.data) > 0 && this.data[0] < 0 {\n\tif this.data[0] == -1 {\n\t\tthis.data[0] = -1 * this.data[0]\n\t\tthis.data[1] = -1 * this.data[1]\n\t} else {\n\t\tthis.data[0] = this.data[0] * this.data[1]\n\t\tthis.data[1] = 0\n\t}\n}\nif this.data[0] < 0 {\n\tthis.data[0] = -1 * this.data[0]\n\tthis.data[1] = -1 * this.data[1]\n}\nif this.data[0] < 0 {\n\tthis.data[0] = -1 * this.data[0]\n\tthis.data[1] = -1 * this.data[1]\n}\nif this.data[0] < 0 {\n\tthis.data[0] = -1 * this.data[0]\n\tthis.data[1] = -1 * this.data[1]\n}\nif this.data[0] < 0 {\n\tthis.data[0] = -1 * this.data[0]\n\tthis.data[1] = -1 * this.data[1]\n}\nif this.data[0] < 0 {\n\tthis.data[0] = -1 * this.data[0]\n\tthis.data[1] = -1 * this.data[1]\n}\nif this.data[0] < 0 {\n\tthis.data[0] = -1 * this.data[0]\n\tthis.data[1] = -1 * this.data[1]\n}\nif this.data[0] < 0 {\n\tthis.data[0] = -1 * this.data[0]\n\tthis.data[1] = -1 * this.data[1"}
{"tgt": "s.lock.Lock()\ndefer s.lock.Unlock()\nreturn s.len", "gen": "defer s.lock.Unlock()\nreturn s.top\n}"}
{"tgt": "return fmt.Sprintf(\"STR\", p.Name, p.Age)", "gen": "return fmt.Sprintf(\"STR\", t.ID)\n}"}
{"tgt": "if n < 2 {\n\treturn 1\n}\nrec := make([]int, n+1)\nrec[0], rec[1] = 1, 1\nfor i := 2; i <= n; i++ {\n\trec[i] = rec[i-1] + rec[i-2]\n}\nreturn rec[n]", "gen": "if n <= 1 {\n\treturn 1\n}\ndp := make([]int, n+1)\ndp[1] = 1\nfor i := 2; i <= n; i++ {\n\tdp[i] = dp[i-1] + dp[i-2]\n}\nreturn dp[n]\n}"}
{"tgt": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\ntmp := nums[0]\nmax := tmp\nfor i := 1; i < n; i++ {\n\tif tmp < 0 {\n\t\ttmp = nums[i]\n\t} else {\n\t\ttmp += nums[i]\n\t}\n\tif max < tmp {\n\t\tmax = tmp\n\t}\n}\nreturn max", "gen": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\nmax := nums[0]\nfor i := 1; i < n; i++ {\n\tif nums[i] < 0 {\n\t\tnums[i] = nums[i-1]\n\t} else {\n\t\tnums[i] += nums[i-1]\n\t}\n\tif nums[i] > max {\n\t\tmax = nums[i]\n\t}\n}\nreturn max\n}"}
{"tgt": "return syscall.Getgid()", "gen": "return syscall.Getgid()\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tarr1   []int\n\tarr2   []int\n\td      int\n\texpect int\n}{\n\t{\"STR\", []int{4, 5, 8}, []int{10, 9, 1, 8}, 2, 2},\n\t{\"STR\", []int{1, 4, 2, 3}, []int{-4, -3, 6, 10, 20, 30}, 3, 2},\n\t{\"STR\", []int{2, 1, 100, 3}, []int{-5, -2, 10, -3, 7}, 6, 1},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.arr1, c.arr2, c.d)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.arr1, c.arr2, c.d)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tarr1   []int\n\tarr2   []int\n\td      int\n\texpect int\n}{\n\t{\"STR\", []int{4, 5, 8}, []int{10, 9, 1}, 3, 2},\n\t{\"STR\", []int{1, 4, 2}, []int{10, 3, 7}, 5, 1},\n\t{\"STR\", []int{-5, -3, 6}, []int{10, 20, 30}, -2, 1},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := findMedianSortedArrays(c.arr1, c.arr2, c.d)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.name, c.arr1, c.arr2, c.d, c.expect, got)\n\t\t}\n\t})\n}\n}"}
{"tgt": "if h.Count != 0 {\n\tfor i := 0; i < int(h.Cap); i++ {\n\t\thashValue := h.hash(key, uint32(i))\n\t\tif h.backets[hashValue] != nil && h.backets[hashValue].Key == key {\n\t\t\treturn h.backets[hashValue].Value, h.backets[hashValue].exist\n\t\t}\n\t}\n}\nreturn nil, false", "gen": "if len(h.buckets) > 0 {\n\tfor i := 0; i < len(h.buckets); i++ {\n\t\tif h.buckets[i] != nil {\n\t\t\tif h.buckets[i].hash == hash {\n\t\t\t\treturn h.buckets[i].value, true\n\t\t\t}\n\t\t}\n\t}\n}\nreturn nil, false\n}"}
{"tgt": "l1 := len(board)\nif l1 == 0 {\n\treturn\n}\nl2 := len(board[0])\nif l2 == 0 {\n\treturn\n}\nvisit := make([][]bool, l1)\nfor i := 0; i < l1; i++ {\n\tvisit[i] = make([]bool, l2)\n}\nfor i := 0; i < l1; i++ {\n\tfor j := 0; j < l2; j++ {\n\t\tif !visit[i][j] {\n\t\t\thelper(board, visit, i, j)\n\t\t}\n\t}\n}", "gen": "n := len(A)\nif n == 0 {\n\treturn nil\n}\nm := len(A[0])\nres := make([][]bool, n)\nfor i := 0; i < n; i++ {\n\tres[i] = make([]bool, m)\n\tfor j := 0; j < m; j++ {\n\t\tres[i][j] = helper(A, i, j)\n\t}\n}\nreturn res\n}"}
{"tgt": "return me[0] == \"STR\"", "gen": "return len(s) > 1 && s[1] == \"1\"\n}"}
{"tgt": "if len(intervals) <= 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i][0] <= intervals[j][0]\n})\nresult := make([][]int, 0)\ncur := intervals[0]\nfor i := 1; i < len(intervals); i++ {\n\tif intervals[i][0] > cur[1] {\n\t\tresult = append(result, cur)\n\t\tcur = intervals[i]\n\t} else {\n\t\tcur[1] = int(math.Max(float64(cur[1]), float64(intervals[i][1])))\n\t}\n}\nresult = append(result, cur)\nreturn result", "gen": "if len(nums1) == 1 {\n\treturn nums1\n}\nsort.Slice(nums1, func(i, j int) bool {\n\treturn nums1[i] < nums1[j]\n})\nres := make([]int, 0, len(nums1))\nfor i := 1; i < len(nums1); i++ {\n\tif nums1[i] > nums1[i-1] {\n\t\tres = append(res, nums1[i])\n\t}\n}\nreturn res\n}"}
{"tgt": "return Frame{}, false", "gen": "return nil\n}"}
{"tgt": "dist := [200][][]int{}\nfor r := 0; r < R; r++ {\n\tfor c := 0; c < C; c++ {\n\t\td := abs(r-r0) + abs(c-c0)\n\t\tdist[d] = append(dist[d], []int{r, c})\n\t}\n}\nbegin, end := 0, 0\nfor d := 0; len(dist[d]) > 0; d++ {\n\tbegin, end = end, end+len(dist[d])\n\tcopy(res[begin:end], dist[d])\n}\nreturn res[:end]", "gen": "var res [][]int\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < m; j++ {\n\t\tif abs(i-j) < k {\n\t\t\tres = append(res, []int{i, j})\n\t\t}\n\t}\n}\nfor i := 0; i < len(res); i++ {\n\tfor j := 0; j < len(res); j++ {\n\t\tif abs(res[i][0]-res[j][0]) < k && abs(res[i][1]-res[j][1]) < k {\n\t\t\tres = append(res[:j], res[j+1:]...)\n\t\t\ti--\n\t\t\tbreak\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "n, err := io.Copy(h, r)\nif err != nil {\n\treturn err\n}\nif n != fSize {\n\treturn errReadSizeMismatch\n}\nreturn nil", "gen": "if err := io.Copy(w, r.Reader); err != nil {\n\treturn err\n}\nif fSize != r.Reader.Size() {\n\treturn errReadSizeMismatch\n}\nreturn nil\n}"}
{"tgt": "if max.Sign() <= 0 {\n\tpanic(\"STR\")\n}\nn = new(big.Int)\nn.Sub(max, n.SetUint64(1))\nbitLen := n.BitLen()\nif bitLen == 0 {\n\treturn\n}\nk := (bitLen + 7) / 8\nb := uint(bitLen % 8)\nif b == 0 {\n\tb = 8\n}\nbytes := make([]byte, k)\nfor {\n\t_, err = io.ReadFull(rand, bytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbytes[0] &= uint8(int(1<<b) - 1)\n\tn.SetBytes(bytes)\n\tif n.Cmp(max) < 0 {\n\t\treturn\n\t}\n}", "gen": "if n.Sign() < 0 {\n\tpanic(\"STR\")\n}\nvar (\n\tb = new(big.Int).SetUint64(1)\n\tr = new(big.Int).Sub(n, b)\n\tl = r.BitLen()\n\td = l/8 + 1\n\tb0 = l%8\n)\nvar buf [8]byte\nfor {\n\t_, err := io.ReadFull(r, buf[:])\n\tif err != nil {\n\t\treturn\n\t}\n\tr.SetBytes(buf[:])\n\tif r.Cmp(n) < 0 {\n\t\treturn\n\t}\n\tr.SetBytes(buf[:])\n}\n}"}
{"tgt": "s := \"STR\"\nfmt.Println(reverseString(s))", "gen": "fmt.Println(STR)\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tnums: []int{1, 2, 3, 1},\n\t\tk:    3,\n\t\twant: true,\n\t},\n\t{\n\t\tnums: []int{1, 0, 1, 1},\n\t\tk:    1,\n\t\twant: true,\n\t},\n\t{\n\t\tnums: []int{1, 2, 3, 1, 2, 3},\n\t\tk:    2,\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := containsNearbyDuplicate(tt.nums, tt.k)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.nums, tt.k, got, tt.want)\n\t}\n}", "gen": "tests := []struct {\n\tnums   []int\n\tk      int\n\texpect bool\n}{\n\t{[]int{1, 2, 3, 1}, 3, true},\n\t{[]int{1, 0, 1, 1}, 1, false},\n\t{[]int{1, 2, 3, 1, 2, 3}, 2, false},\n}\nfor _, tt := range tests {\n\tgot := containsNearbyDuplicate(tt.nums, tt.k)\n\tif got != tt.expect {\n\t\tt.Fatalf(\"STR\", tt.nums, tt.k, tt.expect, got)\n\t}\n}\n}"}
{"tgt": "for V > 0 {\n\tV--\n\tif !isDroppedLeft(heights, K) && !isDroppedRight(heights, K) {\n\t\theights[K]++\n\t}\n}\nreturn heights", "gen": "for i := n - 1; i >= 0; i-- {\n\tif isDroppedLeft(i) || isDroppedRight(i) {\n\t\tcontinue\n\t}\n\tnums[i]++\n}\nreturn nums\n}"}
{"tgt": "qs := []question231{\n\t{\n\t\tpara231{1},\n\t\tans231{true},\n\t},\n\t{\n\t\tpara231{16},\n\t\tans231{true},\n\t},\n\t{\n\t\tpara231{218},\n\t\tans231{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans231, q.para231\n\tfmt.Printf(\"STR\", p, isPowerOfTwo(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question231{\n\t{\n\t\tpara231{1},\n\t\tans231{true, 1},\n\t},\n\t{\n\t\tpara231{16},\n\t\tans231{true, 16},\n\t},\n\t{\n\t\tpara231{218},\n\t\tans231{false, 0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans231, q.para231\n\tfmt.Printf(\"STR\", p, isPowerOfTwo(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "m := map[string]struct{}{}\nfor _, email := range emails {\n\tn := len(email)\n\tbs := strings.Builder{}\n\tignore := false\n\tfor i := 0; i < n; i++ {\n\t\tif email[i] == '@' {\n\t\t\tbs.WriteString(email[i:])\n\t\t\tbreak\n\t\t}\n\t\tif ignore || email[i] == '.' {\n\t\t\tcontinue\n\t\t}\n\t\tif email[i] == '+' {\n\t\t\tignore = true\n\t\t\tcontinue\n\t\t}\n\t\tbs.WriteByte(email[i])\n\t}\n\tm[bs.String()] = struct{}{}\n}\nreturn len(m)", "gen": "m := make(map[string]struct{})\nfor _, s := range strs {\n\tif s == \"\" {\n\t\treturn \"\"\n\t}\n\tvar sb strings.Builder\n\tfor _, c := range s {\n\t\tif c == 'I' {\n\t\t\tsb.WriteString(\"I\")\n\t\t} else if c == 'V' {\n\t\t\tsb.WriteString(\"V\")\n\t\t} else if c == 'X' {\n\t\t\tsb.WriteString(\"X\")\n\t\t} else if c == 'L' {\n\t\t\tsb.WriteString(\"L\")\n\t\t} else if c == 'C' {\n\t\t\tsb.WriteString(\"C\")\n\t\t} else if c == 'D' {\n\t\t\tsb.WriteString(\"D\")\n\t\t} else if c == 'M' {\n\t\t\tsb.WriteString(\"M\")\n\t\t} else {\n\t\t\tif sb.Len() > 0 {\n\t\t\t\tsb.WriteByte(c)\n\t\t\t} else {\n\t\t\t\tsb.WriteString(string(c))\n\t\t\t}\n\t\t}\n\t}\n\tm[sb.String()] = struct{}{}\n}\nfor k := range m {\n\treturn k\n}\nreturn \"\"\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinput1 string\n\tinput2 string\n\texpect bool\n}{\n\t{\"STR\", \"STR\", \"STR\", false},\n\t{\"STR\", \"STR\", \"STR\", false},\n\t{\"STR\", \"STR\", \"STR\", true},\n\t{\"STR\", \"STR\", \"STR\", true},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := canConstruct2(c.input1, c.input2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.input1, c.input2)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tinput1 string\n\tinput2 string\n\texpect bool\n}{\n\t{\"STR1STR2\", \"STR1\", \"STR2\", true},\n\t{\"STR1STR1\", \"STR1\", \"STR1\", false},\n\t{\"STR2STR1\", \"STR2\", \"STR1\", false},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := isAnagram(c.input1, c.input2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\", c.expect, got)\n\t\t}\n\t})\n}\n}"}
{"tgt": "for {\n\tswitch r := l.next(); {\n\tcase unicode.IsNumber(r):\n\tcase r == \"STR\":\n\t\tl.backup()\n\t\tl.emit(itemEnd)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase r == eof:\n\t\tl.emit(itemEnd)\n\t\treturn byteRangeSet\n\tdefault:\n\t\treturn l.error(\"STR\")\n\t}\n}", "gen": "for {\n\tswitch l.next() {\n\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\tl.backup()\n\t\tl.emit(byteRangeSet)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase ',':\n\t\tl.emit(byteRangeSet)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tdefault:\n\t\tl.error(\"STR\")\n\t\treturn byteRangeSet\n\t}\n}\n}"}
{"tgt": "var res byte\nfor i := 0; i < len(s); i++ {\n\tres ^= s[i]\n}\nfor i := 0; i < len(t); i++ {\n\tres ^= t[i]\n}\nreturn res", "gen": "var res bool\nfor i := 0; i < len(s1); i++ {\n\tres ^= s1[i]\n}\nfor i := 0; i < len(s2); i++ {\n\tres ^= s2[i]\n}\nreturn res\n}"}
{"tgt": "var s int\nfor _, c := range m.cache {\n\ts += c.Expire()\n}\nreturn s", "gen": "var expired int\nfor _, e := range c.l.list {\n\tc.Expire(e)\n\texpired++\n}\nreturn expired\n}"}
{"tgt": "if len(num) <= 1 {\n\treturn\n}\nfor i := len(num) - 1; i > 0; i-- {\n\tif num[i-1] < num[i] {\n\t\tj := len(num) - 1\n\t\tfor num[i-1] >= num[j] {\n\t\t\tj--\n\t\t}\n\t\tnum[j], num[i-1] = num[i-1], num[j]\n\t\treverse(num[i:])\n\t\tfmt.Println(num)\n\t\treturn\n\t}\n\tif i == 1 {\n\t\treturn\n\t}\n}", "gen": "if len(nums) <= 1 {\n\treturn\n}\nfor i := len(nums) - 2; i >= 0; i-- {\n\tif nums[i] < nums[i+1] {\n\t\tj := len(nums) - 1\n\t\tfor nums[i] < nums[j] {\n\t\t\tj--\n\t\t}\n\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\treverse(nums, i+1, len(nums)-1)\n\t\tfmt.Println(nums)\n\t}\n}\n}"}
{"tgt": "words := map[string]struct{}{}\ncap, vowel := map[string]string{}, map[string]string{}\nfor _, word := range wordlist {\n\twords[word] = struct{}{}\n\tlower := strings.ToLower(word)\n\tif _, ok := cap[lower]; !ok {\n\t\tcap[lower] = word\n\t\tif _, ok = vowel[todev(lower)]; !ok {\n\t\t\tvowel[todev(lower)] = word\n\t\t}\n\t}\n}\nfor i, query := range queries {\n\tif _, ok := words[query]; ok {\n\t\tcontinue\n\t}\n\tlower := strings.ToLower(query)\n\tif word, ok := cap[lower]; ok {\n\t\tqueries[i] = word\n\t} else if word, ok = vowel[todev(lower)]; ok {\n\t\tqueries[i] = word\n\t} else {\n\t\tqueries[i] = \"STR\"\n\t}\n}\nreturn queries", "gen": "m := map[string]struct{}{}\nfor _, s := range A {\n\tm[strings.ToLower(s)] = struct{}{}\n}\nm2 := map[string]string{}\nfor _, s := range B {\n\tm2[strings.ToLower(s)] = s\n}\nm3 := map[string]string{}\nfor _, s := range C {\n\tm3[strings.ToLower(s)] = s\n}\nfor _, s := range A {\n\tif _, ok := m[s]; ok {\n\t\tif _, ok := m2[s]; ok {\n\t\t\tm3[s] = m2[s]\n\t\t}\n\t}\n}\nfor _, s := range B {\n\tif _, ok := m[s]; ok {\n\t\tif _, ok := m3[s]; ok {\n\t\t\tm2[s] = m3[s]\n\t\t}\n\t}\n}\nreturn m2\n}"}
{"tgt": "return c.name", "gen": "return e.data\n}"}
{"tgt": "qs := []question984{\n\t{\n\t\tpara984{1, 2},\n\t\tans984{\"STR\"},\n\t},\n\t{\n\t\tpara984{4, 1},\n\t\tans984{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans984, q.para984\n\tfmt.Printf(\"STR\", p, strWithout3a3b(p.a, p.b))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question984{\n\t{\n\t\tpara984{\"STR\", \"STR\"},\n\t\tans984{\"STR\", false},\n\t},\n\t{\n\t\tpara984{\"STR\", \"STR\"},\n\t\tans984{\"STR\", false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans984, q.para984\n\tfmt.Printf(\"STR\", p, strWithout3a3b(p.para984))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "var sum int\nfor i := start; i < end; i++ {\n\tsum += l[i]\n}\nreturn sum", "gen": "sum := 0\nfor i := 0; i < len(nums); i++ {\n\tsum += nums[i]\n}\nreturn sum\n}"}
{"tgt": "arr := make([]bool, 1000000)\narr[1] = true\nprime := 3\ncount := 13\nvar k, tmp, localCount int\nvar str string\nfor {\n\tfor k = prime * 2; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tstr = strconv.Itoa(prime)\n\t\tif prime > 100 {\n\t\t\tlocalCount = 1\n\t\t\tfor i := 0; i < len(str)-1; i++ {\n\t\t\t\tstr = str[1:] + str[0:1]\n\t\t\t\ttmp, _ = strconv.Atoi(str)\n\t\t\t\tif tmp > prime {\n\t\t\t\t\tcontinueprimeloop\n\t\t\t\t} else if !arr[tmp] && tmp%2 != 0 {\n\t\t\t\t\tlocalCount++\n\t\t\t\t} else {\n\t\t\t\t\tcontinueprimeloop\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount += localCount\n\t\t}\n\t} else {\n\t\tbreak\n\t}\n}\nprintln(count)", "gen": "var res = make([]bool, 1000000)\nres[0] = true\nvar i, j int\nfor i = 1; i < 1000000; i++ {\n\tfor j = i + 1; j < 1000000; j++ {\n\t\tres[j] = true\n\t}\n\ti += 2\n}\nfor i = 0; i < 1000000; i++ {\n\tif i < 100 {\n\t\tvar count int\n\t\tfor _, v := range res[i:] {\n\t\t\tif v {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\tif count%2 == 1 {\n\t\t\tcount++\n\t\t}\n\t\tif count > 100 {\n\t\t\treturn\n\t\t}\n\t}\n\tif i < 1000000 {\n\t\tvar n int\n\t\tn, _ = strconv.Atoi(strconv.Itoa(i))\n\t\tif n < 100 {\n\t\t\tcount := 0\n\t\t\tfor _, v := range res[i:] {\n\t\t\t\tif v {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t\tif count%2 == 1 {\n\t\t\t\tcount++\n\t\t\t}\n\t\t\tif count > 100 {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n}"}
{"tgt": "count := make(map[string]int, len(words))\nfor _, w := range words {\n\tcount[w]++\n}\nfw := make(freWords, 0, len(count))\nfor w, c := range count {\n\tfw = append(fw, &entry{\n\t\tword:      w,\n\t\tfrequence: c,\n\t})\n}\nsort.Sort(fw)\nres := make([]string, k)\nfor i := 0; i < k; i++ {\n\tres[i] = fw[i].word\n}\nreturn res", "gen": "m := make(map[string]int)\nfor _, word := range words {\n\tm[word]++\n}\nvar res []entry\nfor k, v := range m {\n\tres = append(res, entry{k, v})\n}\nsort.Sort(freWords(res))\nans := make([]string, 0, len(words))\nfor _, e := range res {\n\tans = append(ans, e.key)\n}\nreturn ans\n}"}
{"tgt": "str1 := \"STR\"\nfmt.Println(largeGroupPositions(str1))\nstr2 := \"STR\"\nfmt.Println(largeGroupPositions(str2))\nstr3 := \"STR\"\nfmt.Println(largeGroupPositions(str3))\nstr4 := \"STR\"\nfmt.Println(largeGroupPositions(str4))", "gen": "fmt.Println(\"STR\")\nfmt.Println(largeGroupPositions(\"STR\", 3))\nfmt.Println(largeGroupPositions(\"STRR\", 3))\nfmt.Println(largeGroupPositions(\"STRRR\", 3))\nfmt.Println(largeGroupPositions(\"STRRRR\", 3))\nfmt.Println(largeGroupPositions(\"STRRRRR\", 3))\nfmt.Println(largeGroupPositions(\"STRRRRRR\", 3))\nfmt.Println(largeGroupPositions(\"STRRRRRRR\", 3))\nfmt.Println(largeGroupPositions(\"STRRRRRRRR\", 3))\nfmt.Println(largeGroupPositions(\"STRRRRRRRRR\", 3))\n}"}
{"tgt": "list := NewCyclic()\nfillList(list, 3)\nwant := 1\ngot := list.Walk()\nif got.Val != want {\n\tt.Errorf(\"STR\", got)\n}", "gen": "ll := NewCyclic()\nfillList(ll, 3)\nif ll.Walk(1) != ll.Head {\n\tt.Errorf(\"STR\")\n}\n}"}
{"tgt": "m := make(map[int]struct{})\nfor _, num := range nums1 {\n\tm[num] = struct{}{}\n}\nnums := make([]int, 0)\nfor _, num := range nums2 {\n\tif _, ok := m[num]; ok {\n\t\tnums = append(nums, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn nums", "gen": "m := make(map[int]struct{})\nfor _, num := range nums {\n\tm[num] = struct{}{}\n}\nres := make([]int, 0)\nfor _, num := range nums {\n\tif _, ok := m[num]; !ok {\n\t\tres = append(res, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn res\n}"}
{"tgt": "factorial := new(big.Int).MulRange(1, 100)\nbytes := factorial.Append([]byte{}, 10)\nsum := 0\nfor b := range bytes {\n\tsum += int(bytes[b] - '0')\n}\nfmt.Println(\"STR\", sum)", "gen": "n := new(big.Int)\nn.MulRange(0, 100)\nn.Append(10)\nvar s string\nfor _, d := range n.Bytes() {\n\ts += string(d - '0')\n}\nfmt.Println(s)\n}"}
{"tgt": "qs := []question1003{\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{true},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{true},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{false},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1003, q.para1003\n\tfmt.Printf(\"STR\", p, isValid1003(p.s))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1003{\n\t{\n\t\tpara1003{\"STR\", true},\n\t\tans1003{true},\n\t},\n\t{\n\t\tpara1003{\"STRSTR\", true},\n\t\tans1003{true},\n\t},\n\t{\n\t\tpara1003{\"STRSTRSTR\", false},\n\t\tans1003{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1003, q.para1003\n\tfmt.Printf(\"STRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTR"}
{"tgt": "var v *error\nreturn v", "gen": "var err error\nreturn err\n}"}
{"tgt": "m := map[string]int{}\nrets := []string{}\nfor i := 0; i <= len(s)-10; i++ {\n\tsub := string(s[i : i+10])\n\tm[sub]++\n\tif m[sub] == 2 {\n\t\trets = append(rets, sub)\n\t}\n}\nreturn rets", "gen": "m := make(map[string]int)\nvar res []string\nfor i := 0; i < len(s)-10; i++ {\n\tif m[s[i:i+10]] == 2 {\n\t\tcontinue\n\t}\n\tm[s[i:i+10]]++\n\tif m[s[i:i+10]] == 2 {\n\t\tres = append(res, s[i:i+10])\n\t}\n}\nreturn res\n}"}
{"tgt": "q[i], q[j] = q[j], q[i]", "gen": "this.data[i] = this.data[j]\nthis.data[j] = v\n}"}
{"tgt": "runes := []rune(s)\nlength := len(runes)\nif length <= 1 {\n\treturn s\n}\nmaxRune := runes[0:1]\nfor i := 0; i < length-1; i++ {\n\ttmpRune := findPalindrome(runes, i, i)\n\tif len(tmpRune) > len(maxRune) {\n\t\tmaxRune = tmpRune\n\t}\n\tif runes[i] == runes[i+1] {\n\t\ttmpRune = findPalindrome(runes, i, i+1)\n\t\tif len(tmpRune) > len(maxRune) {\n\t\t\tmaxRune = tmpRune\n\t\t}\n\t}\n}\nreturn string(maxRune)", "gen": "s := []rune(str)\nif len(s) < 2 {\n\treturn str\n}\nl, r := 0, 0\nfor i := 0; i < len(s); i++ {\n\tl, r = findPalindrome(s, i, l, r)\n}\nreturn string(s[l : r+1])\n}"}
{"tgt": "stack, j, N := []int{}, 0, len(pushed)\nfor _, x := range pushed {\n\tstack = append(stack, x)\n\tfmt.Printf(\"STR\", stack, j)\n\tfor len(stack) != 0 && j < N && stack[len(stack)-1] == popped[j] {\n\t\tstack = stack[0 : len(stack)-1]\n\t\tj++\n\t}\n\tfmt.Printf(\"STR\", stack, j)\n}\nreturn j == N", "gen": "var res [][]int\nfor _, num := range nums {\n\tif len(res) == 0 || res[len(res)-1][len(res[len(res)-1])-1] == num {\n\t\tres = append(res, []int{num})\n\t} else {\n\t\tres[len(res)-1] = append(res[len(res)-1], num)\n\t}\n}\nfmt.Printf(\"STR\", res)\nif len(res) == len(nums) {\n\tfmt.Printf(\"STR\", res)\n}\nreturn res\n}"}
{"tgt": "return numDistinctBytes([]byte(s), []byte(t))", "gen": "return numDistinctBytes([]byte(s), []byte(t))\n}"}
{"tgt": "return key1.(int) < key2.(int)", "gen": "return a == b\n}"}
{"tgt": "return x != y", "gen": "return a == b || a < b\n}"}
{"tgt": "for prime := range sig(a) {\n\tif sig(b)[prime] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "for _, v := range sigs {\n\tif sig, ok := sigs[v]; ok {\n\t\tif sig {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true\n}"}
{"tgt": "var low, mid, high int = 0, len(sorted) / 2, len(sorted)\nfor low < high {\n\tcurr := sorted[mid]\n\tswitch {\n\tcase curr == target:\n\t\treturn mid\n\tcase inRange(sorted[mid:high], target):\n\t\tlow = mid\n\t\tmid = (low + high) / 2\n\tdefault:\n\t\thigh = mid\n\t\tmid = (low + high) / 2\n\t}\n}\nreturn -1", "gen": "low, high := 0, len(nums)>>1\nfor low < high {\n\tmid := (low + high) >> 1\n\tif nums[mid] < target {\n\t\tlow = mid + 1\n\t} else if nums[mid] > target {\n\t\thigh = mid\n\t} else {\n\t\treturn mid\n\t}\n}\nreturn -1\n}"}
{"tgt": "if n < sumOfProperDivisors(n) {\n\treturn true\n}\nreturn false", "gen": "if sumOfProperDivisors(n) < n {\n\treturn true\n}\nreturn false\n}"}
{"tgt": "ss := []string{S}\nfor i := 0; i < len(S); i++ {\n\tif S[i] < '0' || S[i] > '9' {\n\t\tfor _, s := range ss {\n\t\t\tb := []byte(s)\n\t\t\tletterCase(b, i)\n\t\t\tss = append(ss, string(b))\n\t\t}\n\t}\n}\nreturn ss", "gen": "res := []string{}\nfor i := 0; i < len(s); i++ {\n\tif s[i] >= 'A' && s[i] <= 'Z' {\n\t\tres = append(res, letterCase(s[:i], true))\n\t} else if s[i] >= 'a' && s[i] <= 'z' {\n\t\tres = append(res, letterCase(s[:i], false))\n\t}\n}\nreturn res\n}"}
{"tgt": "digits := convert(N + 1)\nbits := len(digits)\nnoRepeat := 0\nfor b := 1; b < bits; b++ {\n\tnoRepeat += 9 * count(9, b-1)\n}\nhasSeen := make(map[int]bool, 10)\nfor b := 0; b < bits; b++ {\n\td := 0\n\tif b == 0 {\n\t\td = 1\n\t}\n\tfor ; d < digits[b]; d++ {\n\t\tif !hasSeen[d] {\n\t\t\tnoRepeat += count(9-b, bits-b-1)\n\t\t}\n\t}\n\tif hasSeen[digits[b]] {\n\t\tbreak\n\t}\n\thasSeen[digits[b]] = true\n}\nreturn N - noRepeat", "gen": "res := convert(1 + n)\ncount := 0\nfor i := 1; i <= n; i++ {\n\tcount += count(9, i)\n}\nm := make(map[int]bool)\nfor i := 0; i < n; i++ {\n\tif m[res[i]] {\n\t\tcount += count(9, n-i)\n\t}\n\tm[res[i]] = true\n}\nreturn n - count\n}"}
{"tgt": "b := NewLRUCache(1000)\nfor i := 0; i < 1000; i++ {\n\tb.Set(randomString(2), \"STR\", expire)\n}\nreturn b", "gen": "cache := NewLRUCache(1000)\nfor i := 0; i < 1000; i++ {\n\tcache.Set(0, randomString(2))\n}\nreturn cache\n}"}
{"tgt": "h := &IntMaxHeap{}\nheap.Init(h)\nheap.Push(h, 7)\nheap.Push(h, 3)\nheap.Push(h, 2)\nheap.Push(h, 1)\nheap.Push(h, 5)\nheap.Push(h, 5)\nheap.Push(h, 6)\nheap.Push(h, 7)\nfmt.Printf(\"STR\", (*h))\nfor h.Len() > 0 {\n\tfmt.Printf(\"STR\", heap.Pop(h))\n}", "gen": "h := IntMaxHeap{}\nh.Init(nil)\nh.Push(0)\nh.Push(1)\nh.Push(2)\nh.Push(3)\nh.Push(4)\nh.Push(5)\nh.Push(6)\nh.Push(7)\nh.Push(8)\nh.Push(9)\nh.Push(10)\nh.Push(11)\nh.Push(12)\nh.Push(13)\nh.Push(14)\nh.Push(15)\nh.Push(16)\nh.Push(17)\nh.Push(18)\nh.Push(19)\nh.Push(20)\nh.Push(21)\nh.Push(22)\nh.Push(23)\nh.Push(24)\nh.Push(25)\nh.Push(26)\nh.Push(27)\nh.Push(28)\nh.Push(29)\nh.Push(30)\nh.Push(31)\nh.Push(32)\nh.Push(33)\nh.Push(34)\nh.Push(35)\nh.Push(36)\nh.Push(37)\nh.Push(38)\nh.Push(39)\nh.Push(40)\nh.Push(41)\nh.Push(42)\nh.Push(43)\nh.Push(44)\nh.Push(45)\nh.Push(46)\nh.Push(47)\nh.Push(48)\nh.Push(49)\nh.Push(50)\nh.Push(51)\nh.Push(52)\nh.Push(53)\nh.Push(54"}
{"tgt": "return MyCalendar{\n\tbooks: make([]seg, 0),\n}", "gen": "return Solution{\n\tseg: make([]*SegNode, 0),\n}\n}"}
{"tgt": "var buf bytes.Buffer\nbuf.WriteByte(\"STR\")\nfor i, word := range s.words {\n\tif word == 0 {\n\t\tcontinue\n\t}\n\tfor j := 0; j < 64; j++ {\n\t\tif word&(1<<uint(j)) != 0 {\n\t\t\tif buf.Len() > len(\"STR\") {\n\t\t\t\tbuf.WriteByte(\"STR\")\n\t\t\t}\n\t\t\tfmt.Fprintf(&buf, \"STR\", 64*i+j)\n\t\t}\n\t}\n}\nbuf.WriteByte(\"STR\")\nreturn buf.String()", "gen": "var buf bytes.Buffer\nbuf.WriteByte('{')\nfor i, b := range s {\n\tif b&127 == '{' {\n\t\tbuf.WriteByte('\"')\n\t\tfor j := 0; j < i; j++ {\n\t\t\tif b&127 == '{' {\n\t\t\t\tbuf.WriteByte('\"')\n\t\t\t}\n\t\t}\n\t}\n}\nbuf.WriteByte('}')\nreturn buf.String()\n}"}
{"tgt": "matrix := [][]int{\n\t{5, 1, 9, 11},\n\t{2, 4, 8, 10},\n\t{13, 3, 6, 7},\n\t{15, 14, 12, 16},\n}\nmatrix = rotate(matrix)\nfor _, nums := range matrix {\n\tfor _, num := range nums {\n\t\tfmt.Print(num, \"STR\")\n\t}\n\tfmt.Println()\n}", "gen": "var nums = []int{5, 1, 9, 11, 2, 4, 8, 10, 13, 3, 6, 7, 15, 14, 12, 16}\nrotate(nums, 4)\nfor i, v := range nums {\n\tfmt.Printf(\"STR\", v)\n\tfmt.Println(\"STR\", i)\n}\nfmt.Println(\"STR\", nums)\n}"}
{"tgt": "return MyQueue{\n\tlist: list.New(),\n}", "gen": "return list.New()\n}"}
{"tgt": "res := sizeOfLargestBST(tree)\nreturn res.AnsPtr", "gen": "size := sizeOfLargestBST(root)\nreturn size\n}"}
{"tgt": "sort.Ints(candidates)\nvar res [][]int\ndfs(candidates, nil, target, 0, &res)\nreturn res", "gen": "sort.Ints(nums)\nvar res [][]int\ndfs(nums, 0, []int{}, &res)\nreturn res\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := checkRecord(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "cases := []struct {\n\ts   string\n\tans bool\n}{\n\t{\"STR\", true},\n\t{\"STR\", false},\n}\nfor _, c := range cases {\n\tif ret := checkRecord(c.s); ret != c.ans {\n\t\tt.Fatalf(\"STR\", c.ans, ret)\n\t}\n}\n}"}
{"tgt": "for i := 1; i < len(arr); i++ {\n\tvalue := arr[i]\n\tj := i - 1\n\tfor j >= 0 && arr[j] > value {\n\t\tarr[j+1] = arr[j]\n\t\tj = j - 1\n\t}\n\tarr[j+1] = value\n}", "gen": "for i := 1; i < len(nums); i++ {\n\ttemp := nums[i]\n\tj := i - 1\n\tfor j >= 0 && nums[j] < temp {\n\t\tnums[j+1] = nums[j]\n\t\tj--\n\t}\n\tnums[j+1] = temp\n}\n}"}
{"tgt": "var nums []int\nvar ret bool\nnums = []int{1, 2, 3, 1}\nret = true\nif ret != containsDuplicate(nums) {\n\tt.Fatalf(\"STR\", ret)\n}\nnums = []int{1, 2, 3, 4}\nret = false\nif ret != containsDuplicate(nums) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "cases := []struct {\n\tin   []int\n\twant bool\n}{\n\t{[]int{}, false},\n\t{[]int{1, 2, 3, 4}, false},\n\t{[]int{1, 2, 3, 4, 1}, true},\n}\nfor _, c := range cases {\n\tgot := containsDuplicate(c.in)\n\tif got != c.want {\n\t\tt.Fatalf(\"STR\", c.want, got)\n\t}\n}\ncases = []struct {\n\tin   []int\n\twant bool\n}{\n\t{[]int{1, 2, 3, 4}, false},\n\t{[]int{1, 2, 3, 4, 1}, true},\n}\nfor _, c := range cases {\n\tgot := containsDuplicate(c.in)\n\tif got != c.want {\n\t\tt.Fatalf(\"STR\", c.want, got)\n\t}\n}\n}"}
{"tgt": "switch {\ncase head.Left == nil && head.Right == nil:\n\treturn head.Value\ncase head.Left != nil && head.Right != nil:\n\tleft := head.Value + MinPathSum(head.Left)\n\tright := head.Value + MinPathSum(head.Right)\n\treturn min(left, right)\ncase head.Left != nil:\n\treturn head.Value + MinPathSum(head.Left)\ndefault:\n\treturn head.Value + MinPathSum(head.Right)\n}", "gen": "if root == nil {\n\treturn 0\n}\nif root.Left == nil && root.Right == nil {\n\treturn root.Val\n}\nif root.Left != nil {\n\treturn min(root.Val+MinPathSum(root.Left), MinPathSum(root.Right))\n}\nif root.Right != nil {\n\treturn min(root.Val+MinPathSum(root.Right), MinPathSum(root.Left))\n}\nreturn MinPathSum(root.Right) + MinPathSum(root.Left)\n}"}
{"tgt": "sets := make([][]int, 1, 1<<uint(len(nums)))\nfor _, num := range nums {\n\tfor _, set := range sets {\n\t\ts := make([]int, len(set), len(set)+1)\n\t\tcopy(s, set)\n\t\tsets = append(sets, append(s, num))\n\t}\n}\nreturn sets", "gen": "res := make([][]int, 1, 1<<n)\nfor i := 0; i < len(nums); i++ {\n\ttmp := make([]int, 1, len(nums))\n\ttmp[0] = nums[i]\n\tres = append(res, tmp)\n\tfor j := 0; j < len(res); j++ {\n\t\ttmp := make([]int, len(res[j])+1)\n\t\tcopy(tmp, res[j])\n\t\ttmp[len(tmp)-1] = nums[i]\n\t\tres = append(res, tmp)\n\t}\n}\nreturn res\n}"}
{"tgt": "out := 100\nif x := p33(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "if p33(100) != 100 {\n\tt.Errorf(\"STR\", 100, p33(100))\n}\n}"}
{"tgt": "steps := countSteps([]int{0, 0}, target)\nfor _, g := range ghosts {\n\tif steps >= countSteps(g, target) {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "steps := countSteps([][]int{{0, 1}, {1, 0}})\nfor _, p := range points {\n\tif countSteps(p) < steps {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CourseOrder(tc.prereqs); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CourseOrder(tc.courses); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "if nil == root || k <= 0 {\n\treturn nil\n}\nvar target *BinaryTreeNode\nif root.left != nil {\n\ttarget = kthNode(root.left, k)\n}\nif target == nil {\n\tif 1 == k {\n\t\ttarget = root\n\t} else {\n\t\tk--\n\t}\n}\nif target == nil && root.right != nil {\n\ttarget = kthNode(root.right, k)\n}\nreturn target", "gen": "if root == nil || k <= 0 {\n\treturn nil\n}\nif k > root.Size {\n\treturn kthNode(root.Right, k)\n}\nif k < root.Size {\n\treturn kthNode(root.Left, k)\n}\nreturn root\n}"}
{"tgt": "nums := []int{0, 0, 1, 2}\nfmt.Println(dominantIndex(nums))", "gen": "fmt.Println(dominantIndex([]int{0, 1, 2, 3, 4}))\n}"}
{"tgt": "if root == nil {\n\treturn nil\n}\nif root.Val < L {\n\treturn trimBST(root.Right, L, R)\n}\nif root.Val > R {\n\treturn trimBST(root.Left, L, R)\n}\nroot.Left = trimBST(root.Left, L, R)\nroot.Right = trimBST(root.Right, L, R)\nreturn root", "gen": "if root == nil {\n\treturn nil\n}\nif root.Val < L {\n\treturn trimBST(root.Right, L, R)\n}\nif root.Val > R {\n\treturn trimBST(root.Left, L, R)\n}\nroot.Left = trimBST(root.Left, L, R)\nroot.Right = trimBST(root.Right, L, R)\nreturn root\n}"}
{"tgt": "length := len(matrix)\nfor i := 0; 2*i < length-1; i++ {\n\tfor j := i; j < length-i-1; j++ {\n\t\tmatrix[i][j], matrix[j][length-i-1], matrix[length-i-1][length-j-1], matrix[length-j-1][i] =\n\t\t\tmatrix[length-j-1][i], matrix[i][j], matrix[j][length-i-1], matrix[length-i-1][length-j-1]\n\t}\n}", "gen": "for i := 0; i < len(A); i++ {\n\tfor j := 0; j < len(A); j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tA[i][j], A[j][i] = A[j][i], A[i][j]\n\t}\n}\n}"}
{"tgt": "p = len(postorder) - 1\nidxMap = make(map[int]int)\nfor i, v := range inorder {\n\tidxMap[v] = i\n}\nreturn build(0, len(inorder)-1, postorder)", "gen": "idxMap = make(map[int]int)\nfor i, v := range nums {\n\tidxMap[v] = i\n}\nreturn build(0, nums, nums)\n}"}
{"tgt": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Print(sum, \"STR\")", "gen": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif i%3 == 0 || i%5 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}"}
{"tgt": "qs := []question856{\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{1},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{2},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{2},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{6},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{3},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{8},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans856, q.para856\n\tfmt.Printf(\"STR\", p, scoreOfParentheses(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question856{\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{1},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{1},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{1},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans856, q.para856\n\tfmt.Printf(\"STR\", p, scoreOfParentheses(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "const (\n\txmin, ymin, xmax, ymax = -2, -2, +2, +2\n\twidth, height          = 1024, 1024\n)\nimg := image.NewRGBA(image.Rect(0, 0, width, height))\nfor py := 0; py < height; py++ {\n\ty := float64(py)/height*(ymax-ymin) + ymin\n\tfor px := 0; px < width; px++ {\n\t\tx := float64(px)/width*(xmax-xmin) + xmin\n\t\tz := complex(x, y)\n\t\timg.Set(px, py, mandelbrot(z))\n\t}\n}\npng.Encode(os.Stdout, img)", "gen": "img := image.NewRGBA(image.Rect(0, 0, 1024, 1024))\nfor y := 0; y < 1024; y++ {\n\tfor x := 0; x < 1024; x++ {\n\t\tz := complex(float64(x)/1024, float64(y)/1024)\n\t\timg.Set(x, y, mandelbrot(z))\n\t}\n}\npng.Encode(os.Stdout, img)\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif start, end := BusiestBuildingTimes(tc.moves); start != tc.start || end != tc.end {\n\t\tt.Errorf(\"STR\", tc.start, tc.end, start, end)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := BusiestBuildingTimes(tc.input); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "n := len(cost)\ndp := make([]int, n+1)\nfor i := 2; i <= n; i++ {\n\tdp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])\n}\nreturn dp[n]", "gen": "n := len(triangle) + 1\ndp := make([]int, n)\nfor i := 2; i < n; i++ {\n\tfor j := i - 1; j > 0; j-- {\n\t\tdp[i] = min(dp[i], dp[j]+triangle[i][j])\n\t}\n}\nreturn dp[n-1]\n}"}
{"tgt": "return new(runningSchTaskList).init(tasks)", "gen": "return new(runningSchTaskList).init(tasks)\n}"}
{"tgt": "return area(A, B, C, D) + area(E, F, G, H) - area(max(A, E), max(B, F), min(C, G), min(D, H))", "gen": "return max(area(x1, y1, x2, y2), area(x3, y3, x4, y4)) - min(area(x1, y1, x2, y2), area(x3, y3, x4, y4)) + area(x1, y1, x3, y3) + area(x2, y2, x4, y4)\n}"}
{"tgt": "r, err := http.Get(os.Args[1])\nif err != nil {\n\tfmt.Println(err)\n\treturn\n}\nio.Copy(os.Stdout, r.Body)\nif err := r.Body.Close(); err != nil {\n\tfmt.Println(err)\n}", "gen": "resp, err := http.Get(os.Args[1])\nif err != nil {\n\tfmt.Println(err)\n} else {\n\tdefer resp.Body.Close()\n\tio.Copy(os.Stdout, resp.Body)\n\tfmt.Println(resp.StatusCode)\n}\n}"}
{"tgt": "qs := []question1304{\n\t{\n\t\tpara1304{5},\n\t\tans1304{[]int{-7, -1, 1, 3, 4}},\n\t},\n\t{\n\t\tpara1304{0},\n\t\tans1304{[]int{}},\n\t},\n\t{\n\t\tpara1304{3},\n\t\tans1304{[]int{-1, 0, 1}},\n\t},\n\t{\n\t\tpara1304{1},\n\t\tans1304{[]int{0}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1304, q.para1304\n\tfmt.Printf(\"STR\", p, sumZero(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1304{\n\t{\n\t\tpara1304{[]int{1, 3, 4, 0, 5}},\n\t\tans1304{[]int{1, 3, 4, 0, 5}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1304, q.para1304\n\tfmt.Printf(\"STR\", p, sumZero(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 2, 1}, []int{0, 4, 1, 3, 2}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1}, []int{0}, []int{1}},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums, c.index)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums, c.index)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 4}, []int{1, 2, 3, 4, 0}},\n\t{\"STR\", []int{4, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}, []int{4, 1, 2, 3, 0}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{1, 2, 3, 4, 0}, []int{1, 2, 3, 4, 0}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 4}, []int{1, 2, 3, 4, 0}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{1, 2, 3, 4, 0}, []int{1, 2, 3, 4, 0}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{1, 2, 3, 4, 0}, []int{1, 2, 3, 4, 0}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{1, 2, 3, 4, 0}, []int{1, 2, 3, 4, 0}},\n\t{\"STR\", []int"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := isRobotBounded(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "cases := []struct {\n\tinput  []string\n\texpect bool\n}{\n\t{\n\t\tinput:  []string{\"STR\", \"STR\"},\n\t\texpect: true,\n\t},\n\t{\n\t\tinput:  []string{\"STR\", \"STRR\"},\n\t\texpect: false,\n\t},\n\t{\n\t\tinput:  []string{\"STR\", \"STRRR\"},\n\t\texpect: false,\n\t},\n\t{\n\t\tinput:  []string{\"STR\", \"STRRRR\"},\n\t\texpect: false,\n\t},\n\t{\n\t\tinput:  []string{\"STR\", \"STRRRRR\"},\n\t\texpect: false,\n\t},\n\t{\n\t\tinput:  []string{\"STR\", \"STRRRRRR\"},\n\t\texpect: false,\n\t},\n\t{\n\t\tinput:  []string{\"STR\", \"STRRRRRRR\"},\n\t\texpect: false,\n\t},\n\t{\n\t\tinput:  []string{\"STR\", \"STRRRRRRRR\"},\n\t\texpect: false,\n\t},\n\t{\n\t\tinput:  []string{\"STR\", \"STRRRRRRRRR\"},\n\t\texpect: false,\n\t},\n\t{\n\t\tinput:  []string{\"STR\", \"STRRRRRRRRRR\"},\n\t\texpect: false,\n\t},\n\t{\n\t\tinput:  []string{\"STR\", \"STRRRRRRRRRRR\"},\n\t\texpect: false,\n\t},\n\t{\n\t\tinput:  []string{\"STR\", \"STRRRRRRRRRRRR\"},\n\t\texpect: false,\n\t},\n\t{\n\t\tinput:  []string{\"STR\", \"STRRRRRRRRRRRRR\"},\n\t\texpect: false,\n"}
{"tgt": "seen := make(map[string]struct{})\nfor _, tier := range al {\n\tfor _, v := range tier {\n\t\tif _, ok := seen[v]; !ok {\n\t\t\tseen[v] = struct{}{}\n\t\t\tret = append(ret, v)\n\t\t}\n\t}\n}\nreturn", "gen": "m := make(map[string]struct{})\nfor _, s := range strs {\n\tfor _, c := range s {\n\t\tm[string(c)] = struct{}{}\n\t}\n}\nvar res []string\nfor k := range m {\n\tif len(res) == 0 || res[len(res)-1] != k {\n\t\tres = append(res, k)\n\t}\n}\nreturn res\n}"}
{"tgt": "return h.tasks[i].r < h.tasks[j].r", "gen": "return l1.Val == l2.Val\n}"}
{"tgt": "return xtime.Unix(int64(jt), 0)", "gen": "t := time.Unix(0, t.UnixNano())\nreturn &t\n}"}
{"tgt": "return RandomizedSet{\n\tl: []int{},\n\tm: make(map[int]int),\n}", "gen": "return &TreeNode{\n\tchildren: make([]*TreeNode, 0),\n}\n}"}
{"tgt": "return TypeInt, nil", "gen": "return &ListNode{\n\tVal:  val,\n\tNext: nil,\n}\n}"}
{"tgt": "return createSkyline(buildings, 0, len(buildings)-1)", "gen": "createSkyline(heights, [][]int{})\nreturn skyline\n}"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil && max.Right != root {\n\t\t\tmax = max.Right\n\t\t}\n\t\tif max.Right == nil {\n\t\t\tmax.Right = root\n\t\t\troot = root.Left\n\t\t} else {\n\t\t\tres = append(res, root.Val)\n\t\t\troot = root.Right\n\t\t\tmax.Right = nil\n\t\t}\n\t}\n}\nreturn res", "gen": "var res []*TreeNode\ncur := root\nfor cur != nil {\n\tres = append(res, cur)\n\tcur = cur.Right\n}\ncur = root\nfor cur != nil {\n\tcur = cur.Right\n\tif cur != nil {\n\t\tcur = cur.Right\n\t}\n}\nreturn res\n}"}
{"tgt": "_, err := os.Open(\"STR\")\nif !os.IsNotExist(err) {\n\tpanic(\"STR\")\n}\nf, err := os.Open(\"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer func() {\n\tif err := f.Close(); err != nil {\n\t\tpanic(err)\n\t}\n\t_, err := f.Read(make([]byte, 10))\n\tif err == nil {\n\t\tpanic(\"STR\")\n\t}\n}()\ndata, err := ioutil.ReadAll(f)\nif err != nil {\n\tpanic(err)\n}\nprint(string(data))", "gen": "file, err := os.Open(\"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer file.Close()\ncontent, err := ioutil.ReadAll(file)\nif err != nil {\n\tpanic(err)\n}\nprintln(STR, STR)\n}"}
{"tgt": "start, total, tank := 0, 0, 0\nfor i, g := range gas {\n\ttank += g - cost[i]\n\tif tank < 0 {\n\t\tstart = i + 1\n\t\ttotal += tank\n\t\ttank = 0\n\t}\n}\nif total+tank < 0 {\n\treturn -1\n}\nreturn start", "gen": "var sum, count int\nfor i, n := range nums {\n\tif n < 0 {\n\t\tsum += n\n\t\tcount++\n\t} else {\n\t\tsum -= n\n\t\tcount--\n\t}\n\tif count < 0 {\n\t\treturn -1\n\t}\n}\nreturn sum\n}"}
{"tgt": "fmt.Println(btree.Data)", "gen": "fmt.Println(root)\n}"}
{"tgt": "n := len(num)\nres := []string{}\nvar dfs func(string, int, int, int)\ndfs = func(path string, index, result, pre int) {\n\tif index == n && result == target {\n\t\tres = append(res, path)\n\t\treturn\n\t}\n\tfor i := index; i < n; i++ {\n\t\tif num[index] == '0' && i != index {\n\t\t\treturn\n\t\t}\n\t\tcurrStr := num[index : i+1]\n\t\tcurr, _ := strconv.Atoi(currStr)\n\t\tif index == 0 {\n\t\t\tdfs(currStr, i+1, curr, curr)\n\t\t} else {\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result+curr, curr)\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result-curr, -curr)\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result-pre+pre*curr, pre*curr)\n\t\t}\n\t}\n}\ndfs(\"STR\", 0, 0, 0)\nreturn res", "gen": "var res []string\nvar dfs func(s string, start int, cur string)\ndfs = func(s string, start int, cur string) {\n\tif start == len(s) {\n\t\tif cur != \"\" {\n\t\t\tres = append(res, cur)\n\t\t}\n\t\treturn\n\t}\n\tfor i := start; i < len(s); i++ {\n\t\tif s[start] == '0' && i > start {\n\t\t\tbreak\n\t\t}\n\t\tif i > start && s[start] == '0' {\n\t\t\tbreak\n\t\t}\n\t\tif i > start && s[start] == '0' {\n\t\t\tbreak\n\t\t}\n\t\tdfs(s, i+1, cur+\"+\"+s[start:i+1])\n\t\tdfs(s, i+1, cur+\"-\"+s[start:i+1])\n\t\tdfs(s, i+1, cur+\"*\"+s[start:i+1])\n\t}\n}\ndfs(s, 0, \"\")\nreturn res\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: \"STR\",\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: \"STR\",\n\t},\n}\nfor _, tt := range tests {\n\tgot := defangIPaddr(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "tests := [...]struct {\n\tip   string\n\twant string\n}{\n\t{\"STR\", \"STR\"},\n\t{\"STR\", \"STR\"},\n\t{\"STR\", \"STR\"},\n}\nfor _, tt := range tests {\n\tif got := defangIPaddr(tt.ip); got != tt.want {\n\t\tt.Fatalf(\"STR\", got, tt.want)\n\t}\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := Base64DecodeDelegate(tc.base64); res != tc.decoded {\n\t\tt.Errorf(\"STR\", tc.decoded, res)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := Base64DecodeDelegate(tc.input); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "qs := []question1207{\n\t{\n\t\tpara1207{[]int{1, 2, 2, 1, 1, 3}},\n\t\tans1207{true},\n\t},\n\t{\n\t\tpara1207{[]int{1, 2}},\n\t\tans1207{false},\n\t},\n\t{\n\t\tpara1207{[]int{-3, 0, 1, -3, 1, 1, 1, -3, 10, 0}},\n\t\tans1207{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1207, q.para1207\n\tfmt.Printf(\"STR\", p, uniqueOccurrences(p.arr))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1207{\n\t{\n\t\tpara1207{[]int{1, 2, 2, 1, 1, 3}},\n\t\tans1207{true},\n\t},\n\t{\n\t\tpara1207{[]int{1, 2, 2, 1, 1, 3, 3}},\n\t\tans1207{false},\n\t},\n\t{\n\t\tpara1207{[]int{-3, 0, 1, -3, 10, 0}},\n\t\tans1207{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1207, q.para1207\n\tfmt.Printf(\"STR\", p, uniqueOccurrences(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "max := -1001\nmax1 := -1001\nmax2 := -1001\nmin1 := 1001\nmin2 := 1001\nfor _, n := range nums {\n\tswitch {\n\tcase n > max:\n\t\tmax2, max1, max = max1, max, n\n\tcase n > max1:\n\t\tmax2, max1 = max1, n\n\tcase n > max2:\n\t\tmax2 = n\n\t}\n\tswitch {\n\tcase n < min1:\n\t\tmin2, min1 = min1, n\n\tcase n < min2:\n\t\tmin2 = n\n\t}\n}\nreturn bigger(max1*max2, min1*min2) * max", "gen": "min, max, mid := -1001, -1001, -1001\nfor _, num := range nums {\n\tif num < min {\n\t\tmid = max\n\t\tmax = min\n\t\tmin = num\n\t} else if num < mid {\n\t\tmid = num\n\t} else if num > max {\n\t\tmax = num\n\t}\n}\nreturn bigger(min, bigger(mid, max))\n}"}
{"tgt": "var ret float64\nvar x float64\nvar n int\nret = 0\nx = 0.00001\nn = 2147483647\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 1.0000\nx = 2\nn = 0\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 10.0000\nx = 10.0000\nn = 1\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 0.25000\nx = 2.0000\nn = -2\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "var x, n, expected float64\nx = 0\nn = 2147483647\nexpected = 0\nif myPow(x, n) != expected {\n\tt.Fatalf(\"STR\", expected)\n}\nx = 1\nn = 14\nexpected = 1\nif myPow(x, n) != expected {\n\tt.Fatalf(\"STR\", expected)\n}\nx = -2\nn = -2\nexpected = 0\nif myPow(x, n) != expected {\n\tt.Fatalf(\"STR\", expected)\n}\n}"}
{"tgt": "for len(w.data) > 0 && w.data[len(w.data)-1] < n {\n\tw.data = w.data[0 : len(w.data)-1]\n}\nw.data = append(w.data, n)", "gen": "for node.Next != nil {\n\tnode = node.Next\n}\nnode.Next = append(node.Next, val)\n}"}
{"tgt": "n := 0\ntmp := head\nfor tmp != nil {\n\tn++\n\ttmp = tmp.Next\n}\nreturn helper(&head, 0, n-1)", "gen": "var i int\nhead := node\nfor head != nil {\n\ti++\n\thead = head.Next\n}\nreturn helper(i, head)\n}"}
{"tgt": "const templ = `<p>A:{{.A}}</p><p>B:{{.B}}</p>`\nt := template.Must(template.New(\"STR\").Parse(templ))\nvar data struct {\n\tA string\n\tBtemplate.HTML\n}\ndata.A = \"STR\"\ndata.B = \"STR\"\nif err := t.Execute(os.Stdout, data); err != nil {\n\tlog.Fatal(err)\n}", "gen": "t := template.Must(template.New(\"STR\").Parse(STR))\nt.Execute(os.Stdout, STR)\n}"}
{"tgt": "if len(A) == len(A[0]) {\n\tfor i := 0; i < len(A); i++ {\n\t\tfor j := 0; j < len(A); j++ {\n\t\t\tif i == j {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]\n\t\t}\n\t}\n\treturn A\n}\nres := make([][]int, len(A[0]))\nfor i := 0; i < len(res); i++ {\n\tres[i] = make([]int, len(A))\n\tfor j := 0; j < len(A); j++ {\n\t\tres[i][j] = A[j][i]\n\t}\n}\nreturn res", "gen": "if len(matrix) == 0 {\n\treturn nil\n}\nif len(matrix[0]) == 0 {\n\treturn nil\n}\nres := make([][]int, len(matrix[0]))\nfor i := 0; i < len(matrix[0]); i++ {\n\tfor j := 0; j < len(matrix); j++ {\n\t\tres[i] = append(res[i], matrix[j][i])\n\t}\n}\nreturn res\n}"}
{"tgt": "out := make(map[string]string)\nmain_pieces := strings.Split(s, sep1)\nfor _, piece := range main_pieces {\n\tminor_pieces := strings.Split(piece, sep2)\n\tout[minor_pieces[0]] = minor_pieces[1]\n}\nreturn out", "gen": "m := make(map[string]string)\nfor _, s := range strings.Split(str, sep) {\n\tfor _, t := range strings.Split(sub, sep) {\n\t\tm[s] = t\n\t}\n}\nreturn m\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CountLargerAndSmallerBrute(tc.mat, tc.i1, tc.j1, tc.i2, tc.j2); result != tc.count {\n\t\tt.Errorf(\"STR\", tc.count, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CountLargerAndSmallerBrute(tc.nums); result != tc.result {\n\t\tt.Errorf(\"STR\", tc.result, result)\n\t}\n}\n}"}
{"tgt": "size := len(a)\nlo, hi := 0, size-1\nvar miD, miA int\nfor lo <= hi {\n\tmiD = (lo + hi) / 2\n\tmiA = size - miD - 1\n\tif a[miA] > miD {\n\t\tlo = miD + 1\n\t} else {\n\t\thi = miD - 1\n\t}\n}\nreturn lo", "gen": "n := len(nums)\nstart, end := 0, n-1\nfor start < end {\n\tmid := (start + end) / 2\n\tif nums[mid] < nums[n-1] {\n\t\tstart = mid + 1\n\t} else {\n\t\tend = mid - 1\n\t}\n}\nreturn start\n}"}
{"tgt": "l1, l2 := []int{}, []int{}\ndfs(root1, &l1)\ndfs(root2, &l2)\nif len(l1) != len(l2) {\n\treturn false\n}\nfor i, _ := range l1 {\n\tif l1[i] != l2[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var stack1, stack2 []int\ndfs(root, &stack1, &stack2)\ndfs(p, &stack2, &stack1)\nif len(stack1) != len(stack2) {\n\treturn false\n}\nfor i := range stack1 {\n\tif stack1[i] != stack2[i] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result, err := ShortestRunnerPath(tc.elevations, tc.paths); result != tc.shortestRoute || err != tc.err {\n\t\tt.Errorf(\"STR\", tc.shortestRoute, tc.err, result, err)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := ShortestRunnerPath(tc.grid); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "sLen, pLen := len(s), len(p)\ndp := make([][]bool, sLen+1)\nfor i := range dp {\n\tdp[i] = make([]bool, pLen+1)\n}\ndp[sLen][pLen] = true\nfor i := sLen; i > -1; i-- {\n\tfor j := pLen - 1; j > -1; j-- {\n\t\tfirstMatch := i < sLen && (p[j] == s[i] || p[j] == '.')\n\t\tif j+1 < pLen && p[j+1] == '*' {\n\t\t\tdp[i][j] = dp[i][j+2] || firstMatch && dp[i+1][j]\n\t\t} else {\n\t\t\tdp[i][j] = firstMatch && dp[i+1][j+1]\n\t\t}\n\t}\n}\nreturn dp[0][0]", "gen": "n := len(s)\ndp := make([][]bool, n+1)\nfor i := range dp {\n\tdp[i] = make([]bool, n+1)\n}\nfor i := 1; i <= n; i++ {\n\tfor j := 1; j <= n; j++ {\n\t\tif s[i-1] == s[j-1] {\n\t\t\tdp[i][j] = dp[i-1][j-1]\n\t\t} else {\n\t\t\tif s[i-1] == ')' && dp[i-1][j] {\n\t\t\t\tdp[i][j] = true\n\t\t\t} else if s[i-1] == '(' && dp[i][j-1] {\n\t\t\t\tdp[i][j] = true\n\t\t\t}\n\t\t}\n\t}\n}\nreturn dp[n][n]\n}"}
{"tgt": "sort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].End < intervals[j].End\n})\ncount := 0\ncurrent := -int(^uint(0)>>1) - 1\nfor _, interval := range intervals {\n\tif interval.Start >= current {\n\t\tcount++\n\t\tcurrent = interval.End\n\t}\n}\nreturn len(intervals) - count", "gen": "var res []Interval\nvar f func(Interval)\nf = func(i Interval) {\n\tres = append(res, i)\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nvar max int\nfor _, i := range intervals {\n\tif i.Start < max {\n\t\tcontinue\n\t}\n\tmax = i.End\n\tf(i)\n}\nreturn res\n}"}
{"tgt": "i := len(nums) - 2\nfor i >= 0 && nums[i] >= nums[i+1] {\n\ti--\n}\nj, k := i+1, len(nums)-1\nfor j < k {\n\tnums[j], nums[k] = nums[k], nums[j]\n\tj, k = j+1, k-1\n}\nif i >= 0 {\n\tj = i + 1\n\tfor nums[j] <= nums[i] {\n\t\tj++\n\t}\n\tnums[i], nums[j] = nums[j], nums[i]\n}", "gen": "n := len(nums) - 2\nfor i := n; i >= 0; i-- {\n\tif nums[i] > nums[i+1] {\n\t\tbreak\n\t}\n}\nif i < 0 {\n\treturn 0\n}\nl, r := i+1, len(nums)-1\nfor l < r {\n\tmid := (l + r) / 2\n\tif nums[i] < nums[mid] {\n\t\tr = mid - 1\n\t} else {\n\t\tl = mid\n\t}\n}\nnums[i], nums[l] = nums[l], nums[i]\nreturn l\n}"}
{"tgt": "denoms := make(map[int]struct{})\nfor d, way := range ways {\n\tif others := waysToProduce(d, denoms); (way == 1 && d > 0) || others == way-1 {\n\t\tdenoms[d] = struct{}{}\n\t}\n}\nres := make([]int, 0, len(denoms))\nfor k := range denoms {\n\tres = append(res, k)\n}\nsort.Ints(res)\nreturn res", "gen": "ways := make(map[int]struct{})\nfor _, item := range items {\n\tways[waysToProduce(item)] = struct{}{}\n}\nres := make([]int, 0, len(ways))\nfor _, way := range ways {\n\tif way == 1 {\n\t\tres = append(res, 1)\n\t} else {\n\t\tres = append(res, way-1)\n\t}\n}\nsort.Ints(res)\nreturn res\n}"}
{"tgt": "return len(self.data)", "gen": "return len(s.data)\n}"}
{"tgt": "var ri, gi int\nfor i, r := range letters {\n\tif r == 'R' {\n\t\tletters[i] = letters[gi]\n\t\tletters[gi] = letters[ri]\n\t\tletters[ri] = r\n\t\tgi++\n\t\tri++\n\t} else if r == 'G' {\n\t\tletters[i] = letters[gi]\n\t\tletters[gi] = r\n\t\tgi++\n\t}\n}", "gen": "i, j := 0, 0\nfor _, v := range nums {\n\tif v == 82 {\n\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\ti++\n\t\tj++\n\t} else if v == 71 {\n\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\ti++\n\t} else {\n\t\tj++\n\t}\n}\n}"}
{"tgt": "switch rand.Intn(10) {\ncase 1, 9:\n\treturn io.EOF\ncase 5:\n\treturn errors.New(\"STR\")\ndefault:\n\td.Line = \"STR\"\n\tfmt.Println(\"STR\", d.Line)\n\treturn nil\n}", "gen": "switch rand.Intn(10) {\ncase 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:\n\treturn nil\ndefault:\n\treturn errors.New(\"STR\")\n}\nfmt.Println(\"STR\")\n}"}
{"tgt": "return helper(root, p, q)", "gen": "return helper(root, sum, 0)\n}"}
{"tgt": "benchmark(bb, 16384, 0.1)", "gen": "benchmark(b, 16384, 1)\n}"}
{"tgt": "this.mutex.Lock()\ndefer this.mutex.Unlock()\nif priority < 0 || priority > this.max {\n\treturn nil\n}\nreturn this.queues[priority].Peek()", "gen": "defer self.lock.Unlock()\nif self.head == nil {\n\treturn 0, 0\n}\nif self.head.next == nil {\n\treturn 0, 0\n}\nreturn self.head.next.value, self.head.next.priority\n}"}
{"tgt": "if i < 0 || i >= itemKind(len(_itemKind_index)-1) {\n\treturn fmt.Sprintf(\"STR\", i)\n}\nreturn _itemKind_name[_itemKind_index[i]:_itemKind_index[i+1]]", "gen": "if i.kind == itemKind {\n\treturn fmt.Sprintf(\"STR\", i.index)\n}\nreturn fmt.Sprintf(\"STR\", i.index+1)\n}"}
{"tgt": "arr := randomSlice(0, 20, 10)\nnodeCnt := 0\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\nrotateNodes := make([]*gbtElement, 0, 0)\ngbt.InOrderWalk(gbt.Root(), func(GBTbinaryTreeIf, node interface{}) bool {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\trotateNodes = append(rotateNodes, node.(*gbtElement))\n\t}\n\treturn false\n})\nfor _, v := range rotateNodes {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\tgbt.LeftRotate(v)\n\t} else {\n\t\tgbt.RightRotate(v)\n\t}\n}\ngbt.InOrderWalk(gbt.Root(), checkGBT(t, &nodeCnt, *debug))\nif nodeCnt != len(arr) {\n\tt.Log(fmt.Sprintf(\"STR\", len(arr), nodeCnt))\n\tt.Fail()\n}", "gen": "nodes := randomSlice(10, 20, 0)\ntree := newGBT()\nfor _, node := range nodes {\n\ttree.Insert(node)\n}\nfor _, node := range nodes {\n\tif rand.Intn(2) == 0 {\n\t\ttree.Rotate(node)\n\t}\n}\nif debug {\n\tcheckGBT(tree, nodes)\n}\nif !tree.check() {\n\tt.Log(\"STR\", \"STR\", \"STR\")\n\tt.Fail()\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := InversionCountBrute(tc.input); result != tc.inversions {\n\t\tt.Errorf(\"STR\", tc.inversions, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := InversionCountBrute(tc.arr); res != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, res)\n\t}\n}\n}"}
{"tgt": "fmt.Println(subarrayBitwiseORs([]int{0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))", "gen": "fmt.Println(subarrayBitwiseORs([]int{0, 1, 1}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))\n}"}
{"tgt": "if nil == root {\n\treturn []int{}\n}\nlargestVals := []int{}\nchildren := []*TreeNode{root}\nfor len(children) > 0 {\n\ttmp := children[:]\n\tchildren = []*TreeNode{}\n\tlargest := -(1 << 32)\n\tfor _, child := range tmp {\n\t\tif child.Val > largest {\n\t\t\tlargest = child.Val\n\t\t}\n\t\tif nil != child.Left {\n\t\t\tchildren = append(children, child.Left)\n\t\t}\n\t\tif nil != child.Right {\n\t\t\tchildren = append(children, child.Right)\n\t\t}\n\t}\n\tlargestVals = append(largestVals, largest)\n}\nreturn largestVals", "gen": "if root == nil {\n\treturn []int{}\n}\nvar res []*TreeNode\nvar stack []*TreeNode\nstack = append(stack, root)\nfor len(stack) > 0 {\n\tnode := stack[len(stack)-1]\n\tstack = stack[:len(stack)-1]\n\tif node.Left != nil {\n\t\tstack = append(stack, node.Left)\n\t}\n\tif node.Right != nil {\n\t\tstack = append(stack, node.Right)\n\t}\n\tif node.Left == nil && node.Right == nil {\n\t\tres = append(res, node)\n\t\tstack = append(stack, nil)\n\t}\n}\nvar ret []int\nfor _, node := range res {\n\tret = append(ret, node.Val)\n}\nreturn ret\n}"}
{"tgt": "{\n\tdata, err := json.Marshal(movies)\n\tif err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Printf(\"STR\", data)\n}\n{\n\tdata, err := json.MarshalIndent(movies, \"STR\")\n\tif err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Printf(\"STR\", data)\n\tvar titles []struct{ Title string }\n\tif err := json.Unmarshal(data, &titles); err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Println(titles)\n}", "gen": "movies := []Movie{\n\t{Title: \"STR\", Year: 2012, Color: true},\n\t{Title: \"STR\", Year: 2012, Color: true},\n\t{Title: \"STR\", Year: 2012, Color: true},\n}\nif len(movies) == 0 {\n\tlog.Fatalf(\"STR\")\n}\njsonBytes, err := json.Marshal(movies)\nif err != nil {\n\tlog.Fatalf(\"STR\")\n}\nfmt.Printf(\"STR\")\njsonBytesIndent, err := json.MarshalIndent(movies, \"\", \"STR\")\nif err != nil {\n\tlog.Fatalf(\"STR\")\n}\nfmt.Printf(\"STR\")\nvar m Movie\nerr = json.Unmarshal(jsonBytes, &m)\nif err != nil {\n\tlog.Fatalf(\"STR\")\n}\nfmt.Println(m)\n}"}
{"tgt": "if num <= 0 {\n\treturn false\n}\nif num&(num-1) != 0 {\n\treturn false\n}\nif num&0x55555555 == 0 {\n\treturn false\n}\nreturn true", "gen": "if n < 0 {\n\treturn false\n}\nif n&(n-1) != 0 {\n\treturn false\n}\nif n&1431655765 == 0 {\n\treturn false\n}\nreturn true\n}"}
{"tgt": "major := uint32((dev & 0x00000000000fff00) >> 8)\nmajor |= uint32((dev & 0xfffff00000000000) >> 32)\nreturn major", "gen": "return (x & 1048320) >> 8 | (x & 0xffffffff00000000) >> 32\n}"}
{"tgt": "t.Parallel()\nvar ba BitArray\nfor _, tc := range testcases {\n\tba.Init(tc.size)\n\tfor index, val := range tc.ones {\n\t\tif err := ba.Set(index, val); err != nil {\n\t\t\tt.Errorf(\"STR\")\n\t\t}\n\t}\n\tfor i := 0; i < tc.size; i++ {\n\t\tif val, err := ba.Get(i); err != nil {\n\t\t\tt.Errorf(\"STR\", err)\n\t\t} else if tc.ones[i] != val {\n\t\t\tt.Errorf(\"STR\", tc.ones[i], val, i)\n\t\t}\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tba := BitArray{}\n\tba.Init(tc.n)\n\tfor i, v := range tc.set {\n\t\tba.Set(i, v)\n\t}\n\tfor i, v := range tc.get {\n\t\tif v != ba.Get(i) {\n\t\t\tt.Errorf(\"STR\", tc.n, tc.set, tc.get, i, v, ba.Get(i))\n\t\t}\n\t}\n}\n}"}
{"tgt": "if a == b {\n\treturn -1\n}\nif len(a) > len(b) {\n\treturn len(a)\n}\nreturn len(b)", "gen": "if p == q {\n\treturn 1\n}\nif p < q {\n\treturn p\n}\nreturn q\n}"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil {\n\t\t\tmax = max.Right\n\t\t}\n\t\tmax.Right = root\n\t\troot, root.Left = root.Left, nil\n\t}\n}\nreturn res", "gen": "var res []int\nfor head != nil {\n\tif head.Next == nil {\n\t\tres = append(res, head.Val)\n\t\tbreak\n\t}\n\thead = head.Next\n}\nfor head != nil {\n\thead = head.Next\n}\nhead.Next = &ListNode{Val: 1, Next: nil}\nfor head != nil {\n\thead = head.Next\n}\nreturn res\n}"}
{"tgt": "if a > b {\n\treturn b\n}\nreturn a", "gen": "if a > b {\n\treturn b\n}\nreturn a\n}"}
{"tgt": "var buf bytes.Buffer\nif err := encode(&buf, reflect.ValueOf(v)); err != nil {\n\treturn nil, err\n}\nreturn buf.Bytes(), nil", "gen": "var buf bytes.Buffer\nencode(reflect.ValueOf(val), &buf)\nif buf.Len() == 0 {\n\treturn nil, nil\n}\nreturn buf.Bytes(), nil\n}"}
{"tgt": "m := map[byte]struct{}{}\nfor i := range J {\n\tm[J[i]] = struct{}{}\n}\nres := 0\nfor i := range S {\n\tif _, ok := m[S[i]]; ok {\n\t\tres++\n\t}\n}\nreturn res", "gen": "m := make(map[byte]struct{})\nfor i := 0; i < len(s); i++ {\n\tm[s[i]] = struct{}{}\n}\nvar cnt int\nfor i := 0; i < len(t); i++ {\n\tif _, ok := m[t[i]]; ok {\n\t\tcnt++\n\t}\n}\nreturn cnt\n}"}
{"tgt": "if numRows < 2 {\n\treturn s\n}\nmaxInterval := (numRows - 1) << 1\ninterval := maxInterval\nafter := \"STR\"\nfor i := 0; i < numRows; i++ {\n\tif numRows-1 == i {\n\t\tinterval = maxInterval\n\t}\n\tfor j, no := i, 0; j < len(s); no++ {\n\t\tafter += string(s[j])\n\t\tif i > 0 && i < numRows-1 && 1 == no&1 {\n\t\t\tj += maxInterval - interval\n\t\t\tcontinue\n\t\t}\n\t\tj += interval\n\t}\n\tinterval -= 2\n}\nreturn after", "gen": "if n == 1 {\n\treturn []string{s}\n}\nn--\nres := []string{}\nfor i := 0; i < n; i++ {\n\tif i == n-1 {\n\t\tres = append(res, s)\n\t}\n\tfor j := 0; j < n-i; j++ {\n\t\tif j%2 == 1 {\n\t\t\tres = append(res, s[i:])\n\t\t} else {\n\t\t\tres = append(res, s[i:])\n\t\t}\n\t}\n\ts = s[1:]\n}\nreturn res\n}"}
{"tgt": "var result []string\ndfs(s, []string{}, &result)\nreturn result", "gen": "var res []string\ndfs(root, &res)\nreturn res\n}"}
{"tgt": "if n < 7 {\n\treturn int64(n + 1)\n}\nans := (1 + int64(n%7)) * row(n/7)\nreturn ans", "gen": "if n < 7 {\n\treturn n + 1\n}\nreturn row(n/10) * 10 + row(n%10)\n}"}
{"tgt": "if len(mat) == 0 || len(mat[0]) == 0 {\n\treturn []int{}\n}\nm, n := len(mat), len(mat[0])\nisUpping := true\nnext := func(i, j int) (int, int) {\n\tif isUpping {\n\t\ti--\n\t\tj++\n\t\tif 0 <= i && j < n {\n\t\t\treturn i, j\n\t\t}\n\t\tisUpping = false\n\t\tif i < 0 && j < n {\n\t\t\treturn 0, j\n\t\t}\n\t\treturn i + 2, j - 1\n\t}\n\ti++\n\tj--\n\tif i < m && 0 <= j {\n\t\treturn i, j\n\t}\n\tisUpping = true\n\tif i < m && j < 0 {\n\t\treturn i, 0\n\t}\n\treturn i - 1, j + 2\n}\nmn := m * n\nres := make([]int, mn)\ni, j := 0, 0\nfor k := 0; k < mn; k++ {\n\tres[k] = mat[i][j]\n\ti, j = next(i, j)\n}\nreturn res", "gen": "if len(matrix) == 0 || len(matrix[0]) == 0 {\n\treturn []int{}\n}\ndiag := make([]int, len(matrix)*len(matrix[0]))\ni, j := 0, 1\nfor i < len(matrix) && j < len(matrix[0]) {\n\tdiag[i*len(matrix[0])+j] = matrix[i][j]\n\ti++\n\tj++\n}\nreturn findDiagonalOrder(diag, len(matrix[0]))\n}"}
{"tgt": "n := len(quality)\nworkers := make([][2]float64, n)\nfor i := 0; i < n; i++ {\n\tw, q := float64(wage[i]), float64(quality[i])\n\tworkers[i][0], workers[i][1] = w/q, q\n}\nsort.Slice(workers, func(i, j int) bool {\n\treturn workers[i][0] < workers[j][0]\n})\nres := math.MaxFloat64\nsum := 0.\nh := floatHeap{}\nfor _, w := range workers {\n\tsum += w[1]\n\theap.Push(&h, w[1])\n\tif len(h) > K {\n\t\tsum -= heap.Pop(&h).(float64)\n\t}\n\tif len(h) == K {\n\t\tres = min(res, sum*w[0])\n\t}\n}\nreturn res", "gen": "n := len(cost)\ndp := make([]float64, n)\nfor i := 0; i < n; i++ {\n\tdp[i] = float64(cost[i]) / float64(cost[i]+cost[n-1])\n}\nsort.Slice(dp, func(i, j int) bool {\n\treturn dp[i] < dp[j]\n})\nmin := math.Inf(1)\nh := &floatHeap{\n\tdata: dp,\n}\nheap.Init(h)\nfor h.Len() < k {\n\tmin += heap.Pop(h).(float64)\n\theap.Push(h, min)\n}\nreturn min\n}"}
{"tgt": "t.Parallel()\nlfu := NewLFUCache(3)\nlfu.Set(\"STR\", \"STR\")\nlfu.Set(1, 2)\nlfu.Set(\"STR\", \"STR\")\nlfu.Get(1)\nlfu.Get(\"STR\")\nlfu.Set(100, 1)\nif result := lfu.Get(\"STR\"); result != nil {\n\tt.Errorf(\"STR\", result)\n}\nif result := lfu.Get(1); result == nil {\n\tt.Errorf(\"STR\")\n}\nif result := lfu.Get(\"STR\"); result == nil {\n\tt.Errorf(\"STR\")\n}\nif result := lfu.Get(100); result == nil {\n\tt.Errorf(\"STR\")\n}\nlfu.Set(100, \"STR\")\nif result := lfu.Get(100); result.(string) != \"STR\" {\n\tt.Errorf(\"STR\")\n}", "gen": "t.Parallel()\ncache := NewLFUCache(3)\ncache.Set(\"STR\", \"STR\")\ncache.Set(\"STR\", \"STR\")\ncache.Set(\"STR\", \"STR\")\nif cache.Get(\"STR\") != \"STR\" {\n\tt.Errorf(\"STRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTR"}
{"tgt": "m := len(pattern)\nnext := make([]int, m)\nfor index := range next {\n\tnext[index] = -1\n}\nfor i := 1; i < m-1; i++ {\n\tj := next[i-1]\n\tfor pattern[j+1] != pattern[i] && j >= 0 {\n\t\tj = next[j]\n\t}\n\tif pattern[j+1] == pattern[i] {\n\t\tj += 1\n\t}\n\tnext[i] = j\n}\nreturn next", "gen": "n := len(nums)\ndp := make([]int, n)\nfor i := range dp {\n\tdp[i] = -1\n}\nfor i := 0; i < n; i++ {\n\tif nums[i] == 0 {\n\t\tdp[i] = 0\n\t}\n}\nfor i := 1; i < n; i++ {\n\tfor j := 0; j < i; j++ {\n\t\tif nums[i] == nums[j] {\n\t\t\tdp[i] = dp[j] + 1\n\t\t\tbreak\n\t\t}\n\t}\n}\nreturn dp\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := AllPossibleSubsequences(tc.input); !reflect.DeepEqual(result, tc.subseq) {\n\t\tt.Errorf(\"STR\", tc.subseq, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := AllPossibleSubsequences(tc.input); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 3, 4, 2, 2}, 2},\n\t{\"STR\", []int{3, 1, 3, 4, 2}, 3},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := findDuplicate(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 3, 4, 2, 2}, 3},\n\t{\"STR\", []int{3, 1, 3, 4, 2}, 3},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}\n}"}
{"tgt": "cases := []struct {\n\tname    string\n\tinputs  []int\n\texpects bool\n}{\n\t{\"STR\", []int{1, 2, 3, 1}, true},\n\t{\"STR\", []int{1, 2, 3, 4}, false},\n\t{\"STR\", []int{1, 1, 1, 3, 3, 4, 3, 2, 4, 2}, true},\n}\nfor _, testcase := range cases {\n\tt.Run(testcase.name, func(t *testing.T) {\n\t\tresult := containsDuplicate(testcase.inputs)\n\t\tif !reflect.DeepEqual(result, testcase.expects) {\n\t\t\tt.Fatalf(\"STR\", testcase.expects, result, testcase.inputs)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect bool\n}{\n\t{\"STR\", []int{1, 2, 3, 1}, true},\n\t{\"STR\", []int{1, 2, 3, 4}, false},\n\t{\"STR\", []int{1, 1, 2, 3, 4, 3, 2, 4, 2}, true},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := containsDuplicate(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}\n}"}
{"tgt": "arr := randomSlice(0, 20, 10)\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\ncheckGBTPreOrder(t, gbt, arr)", "gen": "for _, v := range randomSlice(10, 20, 0) {\n\ttree := newGBT()\n\ttree.Insert(v)\n\tcheckGBTPreOrder(tree, 0)\n}\n}"}
{"tgt": "fmt.Println(maxDistToClosest([]int{1, 0, 0, 0, 1, 0, 1}))\nfmt.Println(maxDistToClosest([]int{1, 0, 0, 0}))\nfmt.Println(maxDistToClosest([]int{0, 1}))\nfmt.Println(maxDistToClosest([]int{0, 1, 1, 1, 0, 0, 1, 0, 0}))\nfmt.Println(maxDistToClosest([]int{0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0}))", "gen": "fmt.Println(maxDistToClosest([]int{1, 0, 0, 0, 1}))\nfmt.Println(maxDistToClosest([]int{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}))\nfmt.Println(maxDistToClosest([]int{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}))\nfmt.Println(maxDistToClosest([]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0"}
{"tgt": "iE := i.(*ltHeapElement)\njE := j.(*ltHeapElement)\nif iE == nil {\n\treturn jE\n}\nif jE == nil {\n\treturn iE\n}\nif h.Key(iE) < h.Key(jE) {\n\th.Swap(&iE, &jE)\n}\niE.right = h.merge(iE.right, jE).(*ltHeapElement)\nif iE.left == nil || iE.right.dist > iE.left.dist {\n\th.Swap(&iE.left, &iE.right)\n}\nif iE.right == nil {\n\tiE.dist = 0\n} else {\n\tiE.dist = iE.right.dist + 1\n}\nreturn iE", "gen": "if h.Key == nil {\n\treturn h.Key, h.Value\n}\nif h.Key.Key == nil {\n\treturn h.Key, h.Value\n}\nif h.Key.Key.Less(h.Key.Key, h.Key.Key) {\n\th.Key.Key, h.Key.Value = h.Key.Key.Swap(h.Key.Key, h.Key.Value)\n\th.merge(h.Key.Key)\n\th.Key.Key.Key, h.Key.Key.Value = h.Key.Key.Key.Swap(h.Key.Key.Key, h.Key.Key.Value)\n}\nreturn h.Key, h.Value\n}"}
{"tgt": "result := MakeMatrix(make([]float64, A.cols*A.rows), A.cols, A.rows)\nfor i := 0; i < A.rows; i++ {\n\tfor j := 0; j < A.cols; j++ {\n\t\tsum := float64(0)\n\t\tfor k := 0; k < A.cols; k++ {\n\t\t\tsum += A.GetElm(i, k) * B.GetElm(k, j)\n\t\t}\n\t\tresult.SetElm(i, j, sum)\n\t}\n}\nreturn result", "gen": "m := MakeMatrix(a.Rows, a.Cols, 0)\nfor i := 0; i < a.Rows; i++ {\n\tfor j := 0; j < a.Cols; j++ {\n\t\tsum := 0.0\n\t\tfor k := 0; k < a.Cols; k++ {\n\t\t\tsum += a.GetElm(i, k) * b.GetElm(k, j)\n\t\t}\n\t\tm.SetElm(i, j, sum)\n\t}\n}\nreturn m\n}"}
{"tgt": "if head == nil {\n\treturn nil\n}\neven := head.Next\np, q := head, head.Next\nfor q != nil && q.Next != nil {\n\tp.Next = q.Next\n\tp = p.Next\n\tq.Next = p.Next\n\tq = q.Next\n}\np.Next = even\nreturn head", "gen": "if head == nil {\n\treturn nil\n}\npre, cur := head, head.Next\nfor cur != nil {\n\tcur.Next = pre\n\tpre, cur = cur, cur.Next\n}\nhead.Next = nil\nreturn head\n}"}
{"tgt": "for i := 0; i < b.N; i++ {\n\thmap.HashInsert(rand.Intn(128), i)\n}", "gen": "for i := 0; i < len(s.data); i++ {\n\tkey := rand.Intn(128)\n\ts.data[key] = i\n\ts.data[i] = key\n\ts.data[s.data[i]] = i\n}\n}"}
{"tgt": "size := len(prices)\nif size <= 1 {\n\treturn 0\n}\nprofits := []int{}\ntemp := 0\nfor i := 1; i < size; i++ {\n\tdiff := prices[i] - prices[i-1]\n\tif temp*diff >= 0 {\n\t\ttemp += diff\n\t\tcontinue\n\t}\n\tprofits = append(profits, temp)\n\ttemp = diff\n}\nprofits = append(profits, temp)\nres := 0\nfor i := 0; i < len(profits); i++ {\n\ttemp = max(profits[:i]) + max(profits[i:])\n\tif res < temp {\n\t\tres = temp\n\t}\n}\nreturn res", "gen": "n := len(A)\nif n == 1 {\n\treturn 0\n}\nsums := make([]int, 0, n)\nsum := 0\nfor i := 1; i < n; i++ {\n\tsum += A[i] * A[i-1]\n\tif sum < 0 {\n\t\tsum = 0\n\t\tsums = append(sums, 0)\n\t} else {\n\t\tsums = append(sums, sum)\n\t}\n\tsum = sum + A[i]\n}\nmax := 0\nfor i := 0; i < len(sums); i++ {\n\tif max < sums[i] {\n\t\tmax = sums[i]\n\t}\n\tif max < sums[len(sums)-1-i] {\n\t\tmax = sums[len(sums)-1-i]\n\t}\n}\nreturn max\n}"}
{"tgt": "_a := a\n_b := b\nif a < 0 {\n\ta *= -1\n}\nif b < 0 {\n\tb *= -1\n}\nx0, y0 := 0, 1\nx1, y1 := 1, 0\nfor b != 0 {\n\tquotient := a / b\n\ta, b = b, divide(a, b)\n\tx1, x0 = x0-quotient*x1, x1\n\ty1, y0 = y0-quotient*y1, y1\n}\nif _a < 0 {\n\ty0 *= -1\n}\nif _b < 0 {\n\tx0 *= -1\n}\nreturn y0, x0", "gen": "a, b := abs(a), abs(b)\nx, y := 0, 1\nfor b != 0 {\n\tx, y = x*b+a*y, x\n\ta, b = b, a%b\n}\nreturn x, y\n}"}
{"tgt": "t.Run(\"STR\", func(t *testing.T) {\n\tdata := []int{1, 1, 2}\n\tgot := removeDuplicates(data)\n\twant := 2\n\tif got != want {\n\t\tt.Error(\"STR\", got, \"STR\", want)\n\t}\n})\nt.Run(\"STR\", func(t *testing.T) {\n\tdata := []int{0, 0, 1, 1, 1, 2, 2, 3, 3, 4}\n\tgot := removeDuplicates(data)\n\twant := 5\n\tif got != want {\n\t\tt.Error(\"STR\", got, \"STR\", want)\n\t}\n})", "gen": "t.Run(\"STR\", func(t *testing.T) {\n\ttestStr(t, \"STR\", \"STR\")\n})\nt.Run(\"STR\", func(t *testing.T) {\n\ttestStr(t, \"STR\", \"STR\")\n})\n}"}
{"tgt": "if list == nil || list.Size == 0 {\n\tfmt.Println(\"STR\")\n\treturn\n}\nlist.mutex.RLock()\ndefer list.mutex.RUnlock()\nfmt.Printf(\"STR\", list.Size)\nptr := list.Head\nvar i uint\nfor i = 0; i < list.Size; i++ {\n\tfmt.Printf(\"STR\", i+1, ptr.Data)\n\tptr = ptr.Next\n}", "gen": "if nil == root {\n\tfmt.Println(\"STR\")\n\treturn\n}\nroot.RLock()\ndefer root.RUnlock()\nif nil == root.Root {\n\tfmt.Println(\"STR\")\n\treturn\n}\nfor i := 0; i < len(root.Root.Children); i++ {\n\tfmt.Printf(\"STR\", i, root.Root.Children[i].Value)\n}\nreturn\n}"}
{"tgt": "commonChars := make([]string, 0)\nif len(A) == 0 {\n\treturn commonChars\n}\nminFrequencies := [26]int{}\nfor i := range minFrequencies {\n\tminFrequencies[i] = math.MaxInt32\n}\nfor _, word := range A {\n\tcharFrequencies := [26]int{}\n\tfor _, char := range word {\n\t\tcharFrequencies[char-\"STR\"]++\n\t}\n\tfor i := 0; i < 26; i++ {\n\t\tminFrequencies[i] = min(minFrequencies[i], charFrequencies[i])\n\t}\n}\nfor i := 0; i < 26; i++ {\n\tfor minFrequencies[i] > 0 {\n\t\tcommonChars = append(commonChars, string(rune(i)+\"STR\"))\n\t\tminFrequencies[i]--\n\t}\n}\nreturn commonChars", "gen": "if len(s) == 0 {\n\treturn s\n}\nres := make([]string, 0)\nfor i := 0; i < len(s); i++ {\n\tif s[i] == ' ' {\n\t\tcontinue\n\t}\n\tres = append(res, \"\")\n\tfor j := i + 1; j < len(s); j++ {\n\t\tif s[j] == ' ' {\n\t\t\tbreak\n\t\t}\n\t\tif s[j] < 'a' || s[j] > 'z' {\n\t\t\tcontinue\n\t\t}\n\t\tres[i] += string(s[j])\n\t}\n}\nfor i := 0; i < len(res); i++ {\n\tfor j := i + 1; j < len(res); j++ {\n\t\tif len(res[i]) > len(res[j]) {\n\t\t\tres[i], res[j] = res[j], res[i]\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "return N&1 == 0", "gen": "return n&1 == 0\n}"}
{"tgt": "var head *event\nreturn MyCalendar{head: head}", "gen": "var res int\nreturn res\n}"}
{"tgt": "var num uint32\nvar ret int\nnum = 00000000000000000000000000001011\nret = 3\nif ret != hammingWeight(num) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "var tests = [...]struct {\n\tn   uint32\n\tans int\n}{\n\t{521, 3},\n}\nfor _, tt := range tests {\n\tif ans := hammingWeight(tt.n); ans != tt.ans {\n\t\tt.Fatalf(\"STR\", tt.ans, ans)\n\t}\n}\n}"}
{"tgt": "if head == nil || head.Next == nil {\n\treturn head\n}\nresult := head.Next\nresult.Next, head.Next = head, head.Next.Next\nresult.Next.Next = SwapEveryTwo(result.Next.Next)\nreturn result", "gen": "if root == nil {\n\treturn nil\n}\nif root.Right == nil {\n\treturn root\n}\nroot.Right.Right, root.Right.Left = root.Left, root.Right\nSwapEveryTwo(root.Right)\nreturn root\n}"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := AreSentencesEquivalentTransitive(tc.sentence1,\n\t\ttc.sentence2, tc.thesaurus); result != tc.expectedTransitive {\n\t\tt.Errorf(\"STR\", tcid,\n\t\t\ttc.expectedTransitive, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := AreSentencesEquivalentTransitive(tc.sentence1, tc.sentence2); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.sentence1, tc.sentence2, tc.expected, result)\n\t}\n}\n}"}
{"tgt": "m := make(map[int]int)\nfor k, v := range nums {\n\tif idx, ok := m[target-v]; ok {\n\t\treturn []int{idx, k}\n\t}\n\tm[v] = k\n}\nreturn nil", "gen": "m := make(map[int]int)\nfor _, num := range nums {\n\tif _, ok := m[num]; ok {\n\t\treturn []int{m[num], num}\n\t}\n\tm[num-target] = num\n}\nreturn nil\n}"}
{"tgt": "sum := 100 * 101 / 2\nsqSum := sum * sum\nsumSq := 0\nfor i := 1; i <= 100; i++ {\n\tsumSq += i * i\n}\nfmt.Println(sqSum - sumSq)", "gen": "sum := 5050 * 5050\nvar res int\nfor i := 1; i <= 100; i++ {\n\tres += i * i\n}\nfmt.Println(sum - res)\n}"}
{"tgt": "if a > b {\n\treturn b\n}\nreturn a", "gen": "if a > b {\n\treturn b\n}\nreturn a\n}"}
{"tgt": "return this.Val", "gen": "return self.head\n}"}
{"tgt": "n := len(prices)\nif 0 == n || 1 == n {\n\treturn 0\n}\nvar (\n\tres      int\n\tminPrice = prices[0]\n)\nfor i := 1; i < n; i++ {\n\tif prices[i] < prices[i-1] {\n\t\tres += prices[i-1] - minPrice\n\t\tminPrice = prices[i]\n\t}\n\tif i == n-1 {\n\t\tres += prices[i] - minPrice\n\t}\n}\nreturn res", "gen": "n := len(nums)\nif n == 0 || n == 1 {\n\treturn 0\n}\nsum := nums[0]\nres := nums[0]\nfor i := 1; i < n; i++ {\n\tif nums[i] < nums[i-1] {\n\t\tres += nums[i] - nums[i-1]\n\t} else {\n\t\tsum = nums[i]\n\t}\n}\nif n-1 == res {\n\tres += nums[n-1]\n}\nreturn res\n}"}
{"tgt": "bs := []byte(s)\nvar recur func(int, int) bool\nrecur = func(l, r int) bool {\n\tfor l < r {\n\t\tif bs[l] != bs[r] {\n\t\t\treturn false\n\t\t}\n\t\tl++\n\t\tr--\n\t}\n\treturn true\n}\nfor l, r := 0, len(s)-1; l < r; l, r = l+1, r-1 {\n\tif bs[l] == bs[r] {\n\t\tcontinue\n\t}\n\treturn recur(l+1, r) || recur(l, r-1)\n}\nreturn true", "gen": "s := []byte(str)\nvar f func(i, j int) bool\nf = func(i, j int) bool {\n\tif i < j {\n\t\treturn f(i+1, j) || f(i, j-1)\n\t}\n\treturn s[i] == s[j]\n}\nreturn f(0, len(s)-1)\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 0,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxNumberOfBalloons(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var tests = []struct {\n\ts   string\n\tans int\n}{\n\t{\"STR\", 1},\n\t{\"STRSTR\", 2},\n\t{\"STRSTRSTR\", 3},\n\t{\"STRSTRSTRSTR\", 4},\n}\nfor _, tt := range tests {\n\tif ans := maxNumberOfBalloons(tt.s); ans != tt.ans {\n\t\tt.Fatalf(\"STR\", tt.s, tt.ans, ans)\n\t}\n}\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\twords: []string{\"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  true,\n\t},\n\t{\n\t\twords: []string{\"STR\", \"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  false,\n\t},\n\t{\n\t\twords: []string{\"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := isAlienSorted(tt.words, tt.order)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.words, got, tt.want)\n\t}\n}", "gen": "qs := []question953{\n\t{\n\t\tpara953{\n\t\t\t[]string{\"STR\", \"STR\", \"STR\", \"STR\"},\n\t\t\t[]string{\"STR\", \"STR\", \"STR\", \"STR\"},\n\t\t},\n\t\tans953{\n\t\t\ttrue,\n\t\t},\n\t},\n\t{\n\t\tpara953{\n\t\t\t[]string{\"STR\", \"STR\", \"STR\", \"STR\"},\n\t\t\t[]string{\"STR\", \"STR\", \"STR\", \"STR\"},\n\t\t},\n\t\tans953{\n\t\t\tfalse,\n\t\t},\n\t},\n\t{\n\t\tpara953{\n\t\t\t[]string{\"STR\", \"STR\", \"STR\", \"STR\"},\n\t\t\t[]string{\"STR\", \"STR\", \"STR\", \"STR\"},\n\t\t},\n\t\tans953{\n\t\t\tfalse,\n\t\t},\n\t},\n}\nfor _, q := range qs {\n\t_, p := q.ans953, q.para953\n\tast.Equal(p.one, isAlienSorted(p.para1, p.para2), \"STR\")\n}\n}"}
{"tgt": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 1, 3}},\n\t\tans1051{3},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 2, 3, 4}},\n\t\tans1051{5},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{0},\n\t},\n\t{\n\t\tpara1051{[]int{5, 4, 3, 2, 1}},\n\t\tans1051{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 3}},\n\t\tans1051{true},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 4, 2, 3}},\n\t\tans1051{false},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "i := 1\ntmp := 0\nfor i < len(arr) {\n\tif arr[i] >= arr[i-1] {\n\t\ti++\n\t} else {\n\t\ttmp = arr[i]\n\t\tarr[i] = arr[i-1]\n\t\tarr[i-1] = tmp\n\t\tif i > 1 {\n\t\t\ti--\n\t\t}\n\t}\n}", "gen": "for i := 1; i < len(nums); i++ {\n\tif nums[i] < nums[i-1] {\n\t\tnums[i], nums[i-1] = nums[i-1], nums[i]\n\t\treturn\n\t}\n}\nif i < len(nums) {\n\tnums[i], nums[i-1] = nums[i-1], nums[i]\n}\n}"}
{"tgt": "if maxSize > 0 {\n\tstack := &Stack{}\n\tstack.top = nil\n\tstack.size = 0\n\tstack.maxSize = maxSize\n\treturn stack\n}\nreturn nil", "gen": "if s != nil {\n\treturn &Stack{\n\t\tdata: s.data,\n\t}\n}\nreturn nil\n}"}
{"tgt": "b, _ := ioutil.ReadFile(\"STR\")\ns := strings.Replace(string(b), \"STR\", \"STR\", -1)\nnumData := strings.Split(s, \"STR\")\nfor _, n := range numData {\n\tnumber, err := strconv.Atoi(n)\n\tif err == nil {\n\t\tdata = append(data, number)\n\t}\n}", "gen": "data, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\treturn\n}\ndata = []byte(STR)\ndata = []byte(STR)\nfor _, v := range STR {\n\ti, _ := strconv.Atoi(STR)\n\tdata = append(data, i)\n}\nreturn\n}"}
{"tgt": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nc, res := []int{}, [][]int{}\nsort.Ints(candidates)\nfindcombinationSum(candidates, target, 0, c, &res)\nreturn res", "gen": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nsort.Ints(candidates)\nreturn findcombinationSum(candidates, target, []int{}, 0)\n}"}
{"tgt": "qs := []question786{\n\t{\n\t\tpara786{[]int{1, 2, 3, 5}, 3},\n\t\tans786{[]int{2, 5}},\n\t},\n\t{\n\t\tpara786{[]int{1, 7}, 1},\n\t\tans786{[]int{1, 7}},\n\t},\n\t{\n\t\tpara786{[]int{1, 2}, 1},\n\t\tans786{[]int{1, 2}},\n\t},\n\t{\n\t\tpara786{[]int{1, 2, 3, 5, 7}, 6},\n\t\tans786{[]int{3, 7}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans786, q.para786\n\tfmt.Printf(\"STR\", p, kthSmallestPrimeFraction(p.A, p.K))\n}\nfmt.Printf(\"STR\")", "gen": "A := [][]int{\n\t{1, 2, 3},\n\t{5, 6, 7},\n\t{11, 12, 13},\n}\nB := [][]int{\n\t{2, 5},\n\t{1, 7},\n\t{1, 13},\n}\nfmt.Printf(\"STR\")\nfor i, A := range A {\n\tfor j, B := range B {\n\t\tfmt.Printf(\"STR\", i, j, kthSmallestPrimeFraction(A, B))\n\t}\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "errObj := appError{\n\tError:      handlerError.Error(),\n\tMessage:    message,\n\tHTTPStatus: code,\n}\nError.Printf(\"STR\", handlerError)\nw.Header().Set(\"STR\", \"STR\")\nw.WriteHeader(code)\nif j, err := json.Marshal(errorResource{Data: errObj}); err == nil {\n\tw.Write(j)\n}", "gen": "if err := w.WriteHeader(http.StatusOK); err != nil {\n\tlog.Printf(\"STR\", err)\n\treturn\n}\nw.Header().Set(\"STR\", \"STR\")\nbody, err := json.Marshal(errorResource{\n\tMessage: err.Error(),\n})\nif err != nil {\n\tlog.Printf(\"STR\", err)\n\treturn\n}\nw.Write(body)\n}"}
{"tgt": "if len(strs) == 0 {\n\treturn nil\n}\nr := make(map[string][]string)\nfor _, str := range strs {\n\tcount := make([]int, 26)\n\tfor _, b := range []byte(str) {\n\t\tcount[b-'a']++\n\t}\n\tbs := make([]byte, 26*2)\n\tfor i, c := range count {\n\t\tbs[2*i] = '#'\n\t\tbs[2*i+1] = byte(c) + '0'\n\t}\n\tkey := string(bs)\n\tr[key] = append(r[key], str)\n}\nres := make([][]string, len(r))\ni := 0\nfor _, l := range r {\n\tres[i] = l\n\ti++\n}\nreturn res", "gen": "if len(s) == 0 {\n\treturn []string{}\n}\nm := make(map[string][]string)\nfor _, word := range s {\n\tkey := strings.Map(func"}
{"tgt": "type Address struct {\n\tCountry string  `json:\"STR\"`\n\tPerson  *Person `json:\"STR\"`\n}\nperson := &Person{\n\tName: \"STR\",\n\tAge:  23,\n}\naddress := &Address{\n\tCountry: \"STR\",\n\tPerson:  person,\n}\ndefer func() {\n\terr := recover()\n\tif err != nil {\n\t\tfmt.Printf(\"STR\", err)\n\t\tt.Error(\"STR\")\n\t}\n}()\ns := New(address)\ns.TagName = \"STR\"\nm := s.Map()\nif m[\"STR\"] != person.String() {\n\tt.Errorf(\"STR\", person.String(), m[\"STR\"])\n}\nvs := s.Values()\nif vs[1] != person.String() {\n\tt.Errorf(\"STR\", person.String(), vs[1])\n}", "gen": "type Address struct {\n\tStreet string\n\tCity   string\n\tState  string\n}\ntype Person struct {\n\tName   string\n\tAge    int\n\tAddress\n}\np := Person{\n\tName: \"STR\",\n\tAge:  23,\n\tAddress: Address{\n\t\tStreet: \"STR\",\n\t\tCity:   \"STR\",\n\t\tState:  \"STR\",\n\t},\n}\ndefer func() {\n\tif v, ok := p.Map(\"STR\").(map[string]interface{})[\"STR\"]; !ok || v != \"STR\" {\n\t\tt.Errorf(\"STR\")\n\t}\n\tif v, ok := p.Values(\"STR\")[1].(map[string]interface{})[\"STR\"]; !ok || v != \"STR\" {\n\t\tt.Errorf(\"STR\")\n\t}\n}()\np.Map(\"STR\").(map[string]interface{})[\"STR\"] = \"STR\"\np.Values(\"STR\")[1].(map[string]interface{})[\"STR\"] = \"STR\"\n}"}
{"tgt": "if parser.tokens_head > 0 && len(parser.tokens) == cap(parser.tokens) {\n\tif parser.tokens_head != len(parser.tokens) {\n\t\tcopy(parser.tokens, parser.tokens[parser.tokens_head:])\n\t}\n\tparser.tokens = parser.tokens[:len(parser.tokens)-parser.tokens_head]\n\tparser.tokens_head = 0\n}\nparser.tokens = append(parser.tokens, *token)\nif pos < 0 {\n\treturn\n}\ncopy(parser.tokens[parser.tokens_head+pos+1:], parser.tokens[parser.tokens_head+pos:])\nparser.tokens[parser.tokens_head+pos] = *token", "gen": "if len(t.tokens) == 0 {\n\treturn\n}\nif t.tokens[0].typ == token.EOF {\n\treturn\n}\nif t.tokens[0].typ == token.COMMENT {\n\treturn\n}\nt.tokens = t.tokens[1:]\nt.tokens[0].start = t.tokens[0].start + t.offset\nt.tokens[0].end = t.tokens[0].end + t.offset\nt.tokens[0].typ = token.COMMENT\nt.tokens[0].value = t.tokens[0].value[1:]\nt.offset++\n}"}
{"tgt": "str := \"STR\"\nfmt.Println(longestPalindrome(str))", "gen": "fmt.Println(longestPalindrome(\"STR\"))\n}"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   5,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   0,\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   1,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   2,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   13,\n\t\twant: 4,\n\t},\n\t{\n\t\tin:   130,\n\t\twant: 15,\n\t},\n}\nfor _, tt := range tests {\n\tgot := arrangeCoins(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "tests := [...]struct {\n\tcoins int\n\twant  int\n}{\n\t{5, 2},\n\t{2, 0},\n\t{8, 3},\n\t{3, 1},\n\t{1, 1},\n\t{1, 1},\n\t{2, 1},\n\t{13, 4},\n\t{15, 130},\n}\nfor i, tt := range tests {\n\tgot := arrangeCoins(tt.coins)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", i, tt.coins, tt.want, got)\n\t}\n}\n}"}
{"tgt": "return WordDictionary{}", "gen": "return &Stack{\n\tdata: make([]interface{}, 0, 27),\n}\n}"}
{"tgt": "tcs := []struct {\n\ts   string\n\tans bool\n}{\n\t{\n\t\t\"STR\",\n\t\tfalse,\n\t},\n\t{\n\t\t\"STR\",\n\t\ttrue,\n\t},\n\t{\n\t\t\"STR\",\n\t\tfalse,\n\t},\n\t{\n\t\t\"STR\",\n\t\ttrue,\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, tc := range tcs {\n\tfmt.Printf(\"STR\", tc, isPalindrome(tc.s))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question{\n\t{\n\t\tpara{\"STR\", false},\n\t\tans{false, nil},\n\t},\n\t{\n\t\tpara{\"STRSTR\", true},\n\t\tans{true, nil},\n\t},\n\t{\n\t\tpara{\"STRSTRSTR\", false},\n\t\tans{false, nil},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans, q.para\n\tfmt.Printf(\"STRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTRSTR"}
{"tgt": "var drinks []Drink\ninverted := make(map[Drink][]Customer)\nfor cust, favorites := range prefs {\n\tfor _, drink := range favorites {\n\t\tinverted[drink] = append(inverted[drink], cust)\n\t}\n}\ntotalCustomers := len(prefs)\nserved := make(map[Customer]struct{}, totalCustomers)\nfor len(served) < totalCustomers {\n\tvar largest []Customer\n\tvar largestDrink Drink\n\tvar largestIncrease int\n\tfor drink, custs := range inverted {\n\t\tvar newlyServed int\n\t\tfor _, cust := range custs {\n\t\t\tif _, found := served[cust]; !found {\n\t\t\t\tnewlyServed++\n\t\t\t}\n\t\t}\n\t\tif newlyServed > largestIncrease {\n\t\t\tlargestIncrease = newlyServed\n\t\t\tlargestDrink = drink\n\t\t\tlargest = custs\n\t\t}\n\t}\n\tdelete(inverted, largestDrink)\n\tdrinks = append(drinks, largestDrink)\n\tfor _, cust := range largest {\n\t\tserved[cust] = struct{}{}\n\t}\n}\nsort.Slice(drinks, func(i, j int) bool {\n\treturn drinks[i] < drinks[j]\n})\nreturn drinks", "gen": "var (\n\tcustomers = make(map[Customer][]Drink)\n\tbartender = LazyBartender(func"}
{"tgt": "wg.Add(2)\ngoincCounter(1)\ngoincCounter(2)\nwg.Wait()\nfmt.Println(\"STR\", counter)", "gen": "wg.Add(2)\ngo func() {\n\tcounter++\n}()\ngo func() {\n\tcounter++\n}()\nwg.Wait()\nfmt.Println(\"STR\", counter)\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{{-1, 2, 1, -4}, {1}}, 2},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tret := threeSumClosest(c.inputs[0], c.inputs[1][0])\n\t\tif !reflect.DeepEqual(ret, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, ret, c.inputs)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{{-1, 2, 1, -4}, {1}}, 1},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := maxProfit(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got)\n\t\t}\n\t})\n}\n}"}
{"tgt": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 2}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 4}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}, {4, 4}}},\n\t\tans1037{false},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "sort.Slice(words, func(i, j int) bool {\n\tcuri := len(words[i])\n\tcurj := len(words[j])\n\tfor curi > 0 && curj > 0 {\n\t\tcuri--\n\t\tcurj--\n\t\tif words[i][curi] == words[j][curj] {\n\t\t\tcontinue\n\t\t}\n\t\tif words[i][curi] > words[j][curj] {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\treturn curi == 0\n})\nwords = append(words, \"STR\")\nres, i := 0, 1\nfor ; i < len(words); i++ {\n\tif !endWith(words[i], words[i-1]) {\n\t\tres += len(words[i-1]) + 1\n\t}\n}\nreturn res", "gen": "var res int\nvar s = make([]string, 0, len(words))\nsort.Slice(words, func(i, j int) bool {\n\treturn words[i] < words[j]\n})\nfor i := 0; i < len(words); i++ {\n\tif endWith(words[i], words[i+1]) {\n\t\tres += len(words[i]) + 1\n\t} else {\n\t\tres += len(words[i])\n\t}\n}\nreturn res\n}"}
{"tgt": "fmt.Println(badLongestPalindrome(\"STR\"))\nfmt.Println(goodLongestPalindrome(\"STR\"))\nfmt.Println(bestLongestPalindrome(\"STR\"))", "gen": "fmt.Println(badLongestPalindrome(\"STR\"))\nfmt.Println(goodLongestPalindrome(\"STR\"))\nfmt.Println(bestLongestPalindrome(\"STR\"))\n}"}
{"tgt": "for i := 0; i < len(A)-1; i++ {\n\tif A[i] == i {\n\t\tcontinue\n\t}\n\tif A[i] == i+1 && A[i+1] == i {\n\t\ti++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "for i := 0; i < len(nums)-1; i++ {\n\tif nums[i] == nums[i+1] {\n\t\tcontinue\n\t}\n\tif nums[i] < nums[i+1] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "hash := uint32(0)\nfor i := len(sep) - 1; i >= 0; i-- {\n\thash = hash*PrimeRK + uint32(sep[i])\n}\nvar pow, sq uint32 = 1, PrimeRK\nfor i := len(sep); i > 0; i >>= 1 {\n\tif i&1 != 0 {\n\t\tpow *= sq\n\t}\n\tsq *= sq\n}\nreturn hash, pow", "gen": "var sum, mul int\nfor i := len(nums) - 1; i >= 0; i-- {\n\tsum += nums[i] * 16777619\n}\nfor i := len(nums) - 1; i >= 0; i-- {\n\tif i%2 == 1 {\n\t\tsum *= 16777619\n\t}\n}\nreturn sum\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif sum := SumBSTRange(tc.root, tc.a, tc.b); sum != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, sum)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SumBSTRange(tc.root, tc.low, tc.high); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "arr := make([]bool, 105000)\narr[0], arr[1] = true, true\ncount, prime := 2, 3\nvar k int\nfor {\n\tfor k = 2 * prime; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tcount++\n\t\tif count == 10001 {\n\t\t\tprintln(prime)\n\t\t\tbreak\n\t\t}\n\t} else {\n\t\tbreak\n\t}\n}", "gen": "var res = make([]bool, 105000)\nres[0] = true\nres[1] = true\nvar i, j int\nfor i < 105000 {\n\tfor j = i + 2; j < 105000; j += 2 {\n\t\tres[j] = true\n\t}\n\ti += 2\n\tfor j = i + 2; j < 105000; j += 2 {\n\t\tres[j] = true\n\t}\n\ti += 2\n\tif i < 10001 {\n\t\ti += 1\n\t}\n}\nfor i := 0; i < 105000; i++ {\n\tif res[i] {\n\t\tfmt.Println(i)\n\t\tbreak\n\t}\n}\n}"}
{"tgt": "n1, n2 := len(nums1), len(nums2)\nif n1 > n2 {\n\tn1, n2, nums1, nums2 = n2, n1, nums2, nums1\n}\nm := make(map[int]int, n1)\nfor _, num := range nums1 {\n\tm[num]++\n}\nres := make([]int, 0, n1)\nfor _, num := range nums2 {\n\tif v, ok := m[num]; ok && v > 0 {\n\t\tres = append(res, num)\n\t\tm[num]--\n\t}\n}\nreturn res", "gen": "n := len(nums)\nm := make(map[int]int)\nfor i := 0; i < n; i++ {\n\tm[nums[i]]++\n}\nres := make([]int, 0, n)\nfor i := 0; i < n; i++ {\n\tif v, ok := m[nums[i]]; ok && v > 1 {\n\t\tres = append(res, nums[i])\n\t\tm[nums[i]]--\n\t}\n}\nreturn res\n}"}
{"tgt": "if root == nil {\n\treturn nil\n}\ns := []*TreeNode{root}\nres := [][]int{}\nzigzag := false\nfor len(s) != 0 {\n\ttmp := []*TreeNode{}\n\tl := []int{}\n\tfor i, node := range s {\n\t\tif zigzag {\n\t\t\tl = append(l, s[len(s)-i-1].Val)\n\t\t} else {\n\t\t\tl = append(l, node.Val)\n\t\t}\n\t\tif node.Left != nil {\n\t\t\ttmp = append(tmp, node.Left)\n\t\t}\n\t\tif node.Right != nil {\n\t\t\ttmp = append(tmp, node.Right)\n\t\t}\n\t}\n\tres = append(res, l)\n\ts = tmp\n\tzigzag = !zigzag\n}\nreturn res", "gen": "if root == nil {\n\treturn nil\n}\nvar res [][]int\nvar stack []*TreeNode\nstack = append(stack, root)\nvar isLeft bool\nfor len(stack) > 0 {\n\tnode := stack[len(stack)-1]\n\tstack = stack[:len(stack)-1]\n\tif node.Left != nil {\n\t\tstack = append(stack, node.Left)\n\t}\n\tif node.Right != nil {\n\t\tstack = append(stack, node.Right)\n\t}\n\tif isLeft {\n\t\tres[len(res)-1] = append(res[len(res)-1], node.Val)\n\t} else {\n\t\tres = append(res, []int{node.Val})\n\t}\n\tisLeft = !isLeft\n}\nreturn res\n}"}
{"tgt": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)", "gen": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)\n}"}
{"tgt": "if len(str) == 0 {\n\treturn 0\n}\nvar (\n\tnum int\n\tneg bool\n)\nfor i, s := range str {\n\tif s != ' ' {\n\t\tstr = str[i:]\n\t\tbreak\n\t}\n}\nif str[0] == '+' {\n\tstr = str[1:]\n} else if str[0] == '-' {\n\tstr = str[1:]\n\tneg = true\n}\nfor _, s := range str {\n\tif s < '0' || s > '9' {\n\t\tbreak\n\t}\n\tnum = num*10 + int(s-'0')\n\tif num > 2147483648 {\n\t\tnum = 2147483648\n\t\tbreak\n\t}\n}\nif neg {\n\tnum *= -1\n} else if num > 2147483647 {\n\tnum = 2147483647\n}\nreturn num", "gen": "if len(s) == 0 {\n\treturn 0\n}\nvar res int\nvar sign bool\nfor i := 0; i < len(s); i++ {\n\tif s[i] == ' ' {\n\t\tcontinue\n\t}\n\tif s[i] == '+' {\n\t\tsign = true\n\t} else if s[i] == '-' {\n\t\tsign = false\n\t} else {\n\t\tif s[i] < '0' || s[i] > '9' {\n\t\t\treturn 0\n\t\t}\n\t\tres = res*10 + int(s[i]-'0')\n\t\tif sign {\n\t\t\tres = -res\n\t\t}\n\t}\n}\nif res > 2147483647 {\n\treturn 2147483647\n}\nif res < -2147483648 {\n\treturn -2147483648\n}\nreturn res\n}"}
{"tgt": "ans, m, n := []int{}, len(matrix), len(matrix[0])\nfor j := 0; j < n; j++ {\n\tmax, rowIndex := 1, 0\n\tfor i := 0; i < m; i++ {\n\t\tif matrix[i][j] > max {\n\t\t\tmax = matrix[i][j]\n\t\t\trowIndex = i\n\t\t}\n\t}\n\tif Min(matrix[rowIndex]) == max {\n\t\tans = append(ans, max)\n\t}\n}\nreturn ans", "gen": "res := []int{}\nn := len(nums)\nfor i := 0; i < n; i++ {\n\tmin := nums[i]\n\tfor j := i + 1; j < n; j++ {\n\t\tif nums[j] < min {\n\t\t\tmin = nums[j]\n\t\t}\n\t}\n\tres = append(res, min)\n}\nreturn res\n}"}
{"tgt": "strNumber := strconv.Itoa(number)\nfor _, runeDigit := range []rune(strNumber) {\n\tdigit := int(runeDigit - '0')\n\tlist = append(list, digit)\n}\nreturn", "gen": "str := strconv.Itoa(num)\nres := make([]int, 0)\nfor _, r := range []rune(str) {\n\tres = append(res, int(r-'0'))\n}\nreturn res\n}"}
{"tgt": "if num == 0 {\n\treturn \"STR\"\n}\nh := []string{\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\",\n\t\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\"}\nres := \"STR\"\nfor i := 0; i < 8 && num != 0; i++ {\n\tres = h[num&15] + res\n\tnum >>= 4\n}\nreturn res", "gen": "if n == 0 {\n\treturn \"STR\"\n}\nvar res string\nfor n != 0 {\n\tres += strconv.Itoa(n % 16)\n\tn /= 16\n}\nreturn res\n}"}
{"tgt": "if len(n.Exprs) == 0 {\n\treturn TypeString, nil\n}\nif len(n.Exprs) == 1 {\n\texprType, err := n.Exprs[0].Type(s)\n\tif err != nil {\n\t\treturn TypeInvalid, err\n\t}\n\tswitch exprType {\n\tcase TypeList:\n\t\treturn TypeList, nil\n\tcase TypeMap:\n\t\treturn TypeMap, nil\n\t}\n}\nfor index, expr := range n.Exprs {\n\texprType, err := expr.Type(s)\n\tif err != nil {\n\t\treturn TypeInvalid, err\n\t}\n\tif exprType == TypeList || exprType == TypeMap {\n\t\treturn TypeInvalid, fmt.Errorf(\n\t\t\t\"STR\",\n\t\t\tindex, exprType)\n\t}\n}\nreturn TypeString, nil", "gen": "if len(n.Children) == 0 {\n\treturn 8, nil\n}\nif len(n.Children) == 1 {\n\treturn n.Children[0].eval(e)\n}\nvar (\n\terr error\n\ti   int\n\tt   Type\n)\nfor i, t = range n.Children {\n\tif err = t.eval(e); err != nil {\n\t\tbreak\n\t}\n\tif i == 64 {\n\t\treturn 64, nil\n\t}\n\tif i == 128 {\n\t\treturn 128, nil\n\t}\n}\nreturn 0, err\n}"}
{"tgt": "psum, min := 0, 1\nfor _, val := range nums {\n\tpsum += val\n\tif psum < min {\n\t\tmin = psum\n\t}\n}\nif min > 0 {\n\treturn min\n}\nreturn -min + 1", "gen": "sum := 0\nmax := 1\nfor _, v := range nums {\n\tsum += v\n\tif sum < 0 {\n\t\tsum = 0\n\t\tmax = 1\n\t} else if sum > max {\n\t\tmax = sum\n\t}\n}\nif max == 0 {\n\treturn 1\n}\nreturn max\n}"}
{"tgt": "arr := make([]bool, 2000000)\narr[0], arr[1] = true, true\nsum, prime := int64(5), 3\nvar k int\nfor {\n\tfor k = 2 * prime; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tsum += int64(k)\n\t} else {\n\t\tbreak\n\t}\n}\nprintln(sum)", "gen": "var res = make([]bool, 2000000)\nres[0] = true\nres[1] = true\nfor i := 2; i < 2000000; i++ {\n\tfor j := 2 * i; j < 2000000; j += i {\n\t\tres[j] = true\n\t}\n}\nvar count int\nvar start int\nfor i := 0; i < 2000000; i++ {\n\tif res[i] {\n\t\tcount++\n\t\tstart = i\n\t}\n\tfor j := start + 2; j < 2000000; j += i {\n\t\tres[j] = true\n\t}\n}\nprintln(count)\n}"}
{"tgt": "qs := []question693{\n\t{\n\t\tpara693{5},\n\t\tans693{true},\n\t},\n\t{\n\t\tpara693{7},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{11},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{10},\n\t\tans693{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans693, q.para693\n\tfmt.Printf(\"STR\", p, hasAlternatingBits(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question693{\n\t{\n\t\tpara693{5},\n\t\tans693{true},\n\t},\n\t{\n\t\tpara693{7},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{11},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{10},\n\t\tans693{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans693, q.para693\n\tfmt.Printf(\"STR\", p, hasAlternatingBits(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "sum := 0\nfor i := 1; i <= n; i++ {\n\tsquare := i * i\n\tsum += square\n}\nreturn sum", "gen": "sum := 0\nfor i := 1; i <= n; i++ {\n\tsum += i * i\n}\nreturn sum\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.nums); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.left, tc.right); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "var i int\nfor j, k := 0, 0; j < len(nums); j = k {\n\tfor k < len(nums) && nums[j] == nums[k] {\n\t\tif k < j+2 {\n\t\t\tnums[i] = nums[k]\n\t\t\ti++\n\t\t}\n\t\tk++\n\t}\n}\nreturn i", "gen": "var i, j int\nfor i = 0; i < len(nums); i++ {\n\tfor j = i + 1; j < len(nums); j++ {\n\t\tif nums[i] > nums[j] {\n\t\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\t\ti++\n\t\t}\n\t}\n}\nreturn i\n}"}
{"tgt": "result := make([]int, 0, len(left)+len(right))\nfor len(left) > 0 || len(right) > 0 {\n\tif len(left) == 0 {\n\t\treturn append(result, right...)\n\t}\n\tif len(right) == 0 {\n\t\treturn append(result, left...)\n\t}\n\tif left[0] <= right[0] {\n\t\tresult = append(result, left[0])\n\t\tleft = left[1:]\n\t} else {\n\t\tresult = append(result, right[0])\n\t\tright = right[1:]\n\t}\n}\nreturn result", "gen": "res := make([]int, 0, len(nums)+len(queries))\nfor i := 0; i < len(nums); i++ {\n\tif i == 0 {\n\t\tres = append(res, nums[i])\n\t} else {\n\t\tif nums[i] < nums[i-1] {\n\t\t\tres = append(res, nums[i])\n\t\t} else {\n\t\t\tres = append(res, nums[i-1])\n\t\t}\n\t}\n}\nfor i := 0; i < len(queries); i++ {\n\tif i == 0 {\n\t\tres = append(res, queries[i])\n\t} else {\n\t\tif queries[i] < queries[i-1] {\n\t\t\tres = append(res, queries[i])\n\t\t} else {\n\t\t\tres = append(res, queries[i-1])\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "if 0 == n {\n\treturn 0\n} else {\n\treturn n/5 + trailingZeroes(n/5)\n}", "gen": "if n == 0 {\n\treturn 0\n}\nreturn trailingZeroes(n / 5) + n/5\n}"}
{"tgt": "n := len(s)\nuf := newUnionFind(n)\nfor _, p := range pairs {\n\tuf.connect(p[0], p[1])\n}\ngroups := make(map[int][]int, n)\nfor c, p := range uf.parent {\n\tp = uf.find(p)\n\tgroups[p] = append(groups[p], c)\n}\nbytes := []byte(s)\nres := make([]byte, n)\nfor _, g := range groups {\n\tsize := len(g)\n\ta := make([]int, size)\n\tcopy(a, g)\n\tsort.Slice(a, func(i, j int) bool {\n\t\treturn bytes[a[i]] < bytes[a[j]]\n\t})\n\tsort.Ints(g)\n\tfor i := 0; i < size; i++ {\n\t\tres[g[i]] = bytes[a[i]]\n\t}\n}\nreturn string(res)", "gen": "uf := newUnionFind(len(strs))\nfor i, s := range strs {\n\tuf.connect(i, s[0]-'a')\n}\nm := make(map[int][]int)\nfor i, s := range strs {\n\tf := uf.find(i)\n\tm[f] = append(m[f], i)\n}\nfor i := range m {\n\tsort.Ints(m[i])\n}\nsort.Ints(m[0])\nres := make([]byte, len(strs))\nfor i, s := range m[0] {\n\tres[s] = strs[s][0]\n}\nreturn string(res)\n}"}
{"tgt": "data := [][]int{\n\t{2},\n\t{3, 4},\n\t{6, 5, 7},\n\t{4, 1, 8, 3}}\nfmt.Println(minimumTotal(data))", "gen": "fmt.Println(minimumTotal([][]int{{2, 3, 4}, {1, 5, 7}, {8, 9, 3}}))\n}"}
{"tgt": "left, right, res := 0, -1, 0\nfor left < len(s) {\n\tif right+1 < len(s) && maxCost-abs(int(s[right+1]-'a')-int(t[right+1]-'a')) >= 0 {\n\t\tright++\n\t\tmaxCost -= abs(int(s[right]-'a') - int(t[right]-'a'))\n\t} else {\n\t\tres = max(res, right-left+1)\n\t\tmaxCost += abs(int(s[left]-'a') - int(t[left]-'a'))\n\t\tleft++\n\t}\n}\nreturn res", "gen": "i, j, max := 0, -1, 0\nfor i < len(s) && j < len(t) {\n\tif s[i] == t[j] {\n\t\ti++\n\t\tj++\n\t} else {\n\t\tmax = max(max, abs(i-j))\n\t\ti++\n\t}\n}\nreturn max\n}"}
{"tgt": "nums := []int{}\nfor n != 0 {\n\tnums = append(nums, n%10)\n\tn /= 10\n}\nm := len(nums)\nif m < 2 {\n\treturn -1\n}\ni := 1\nfor i < m {\n\tif nums[i] < nums[i-1] {\n\t\tbreak\n\t}\n\ti++\n}\nif i == m {\n\treturn -1\n}\nj := 0\nfor j < i {\n\tif nums[j] > nums[i] {\n\t\tbreak\n\t}\n\tj++\n}\nnums[i], nums[j] = nums[j], nums[i]\nfor k := 0; k < i/2; k++ {\n\tnums[k], nums[i-k-1] = nums[i-k-1], nums[k]\n}\nres := 0\np := 1\nfor _, n := range nums {\n\tres += n * p\n\tp *= 10\n}\nif res > math.MaxInt32 {\n\treturn -1\n}\nreturn res", "gen": "var res []int\nfor i := 0; i < len(nums); i++ {\n\tnums[i] = nums[i] ^ nums[i+1]\n\tnums[i+1] = nums[i]\n}\nif len(nums) == 1 {\n\treturn -1\n}\nvar sum int\nfor i := 0; i < len(nums); i++ {\n\tsum += nums[i]\n}\nif sum == 0 {\n\treturn -1\n}\nvar max int\nfor i := 0; i < len(nums); i++ {\n\tfor j := i + 1; j < len(nums); j++ {\n\t\tif nums[i] < nums[j] {\n\t\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\t}\n\t}\n\tif i == 0 {\n\t\tmax = nums[i]\n\t} else {\n\t\tmax = max * 2\n\t}\n\tif nums[i] == max {\n\t\treturn i\n\t}\n}\nreturn -1\n}"}
{"tgt": "x := []int{10, 20, 30, 40, 50}\nfor k, v := range x {\n\tfmt.Printf(\"STR\", k, v)\n}", "gen": "for i, v := range []int{10, 20, 30, 40, 50} {\n\tfmt.Printf(\"STR\", i, v)\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif jumps, impassable := MinimumJumps(tc.maxSteps); impassable != tc.impassable || jumps != tc.expectedJumps {\n\t\tt.Errorf(\"STR\", tc.expectedJumps, tc.impassable, jumps, impassable)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := MinimumJumps(tc.input); res != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, res)\n\t}\n}\n}"}
{"tgt": "c.bw.WriteString(\"STR\")\nc.bw.WriteByte(space)\nc.bw.WriteString(key)\nc.bw.WriteByte(space)\nc.bw.Write(strconv.AppendInt(c.numScratch[:0], int64(timeout), 10))\n_, err = c.bw.Write(crlf)\nreturn", "gen": "w.WriteString(\"VALUE \")\nw.WriteString(key)\nw.WriteByte(space)\nw.WriteString(strconv.Itoa(flags))\nw.WriteByte(space)\nw.WriteString(strconv.Itoa(expiration))\nw.WriteString(crlf)\nw.WriteString(string(data))\nw.WriteString(crlf)\nw.WriteString(crlf)\nreturn w.Flush()\n}"}
{"tgt": "if len(s) == 0 {\n\treturn \"STR\"\n}\nstart := 0\nmaxLen := 1\nfor index := range s {\n\tl := index - maxLen\n\tend := index + 1\n\tif l >= 1 && sym(s[l-1:end]) {\n\t\tstart = l - 1\n\t\tmaxLen += 2\n\t} else if l >= 0 && sym(s[l:end]) {\n\t\tstart = l\n\t\tmaxLen += 1\n\t}\n}\nreturn s[start : start+maxLen]", "gen": "if len(s) == 0 {\n\treturn \"STR\"\n}\nvar i, j int\nfor i = 0; i < len(s); i++ {\n\tif s[i] < 128 {\n\t\tcontinue\n\t}\n\tj = i + 1\n\tfor j < len(s) {\n\t\tif s[i] == s[j] {\n\t\t\ti++\n\t\t\tj++\n\t\t} else {\n\t\t\tif s[i] < 128 {\n\t\t\t\ti++\n\t\t\t} else {\n\t\t\t\tif s[i] < s[j] {\n\t\t\t\t\ti++\n\t\t\t\t} else {\n\t\t\t\t\tj++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nreturn sym(s[:i], s[i:])\n}"}
{"tgt": "http.HandleFunc(path, func(res http.ResponseWriter, req *http.Request) {\n\terr := handleFunc(res, req)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), 500)\n\t}\n})", "gen": "handle := func(w http.ResponseWriter, r *http.Request) {\n\thandleFunc(w, r)\n}\nhttp.HandleFunc(\"/\", handle)\n}"}
{"tgt": "kind := t.Kind()\nif kind >= Int && kind <= Complex128 {\n\treturn int(t.Size()) * 8\n}\npanic(TypeError{\"STR\"})", "gen": "switch t.Kind() {\ncase reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr, reflect.Float32, reflect.Float64, reflect.Complex64, reflect.Complex128, reflect.String:\n\treturn t.Size() * 8\ndefault:\n\tpanic(TypeError{STR})\n}\n}"}
{"tgt": "println(\"STR\", len(a))", "gen": "println(\"STR\", 4)\n}"}
{"tgt": "return e.Errs[0].Error()", "gen": "return tree.root.left.value\n}"}
{"tgt": "stack := make([]int, 0)\nresult := make([]int, len(T))\nfor i, t := range T {\n\tfor len(stack) > 0 && T[stack[len(stack)-1]] < t {\n\t\tresult[stack[len(stack)-1]] = i - stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t}\n\tstack = append(stack, i)\n}\nfor _, i := range stack {\n\tresult[i] = 0\n}\nreturn result", "gen": "res := make([]int, 0, len(nums))\nfor _, num := range nums {\n\tif len(res) == 0 || res[len(res)-1] < num {\n\t\tres = append(res, num)\n\t} else {\n\t\tres[len(res)-1] = num\n\t}\n}\nfor i := 0; i < len(res); i++ {\n\tres[i] = 0\n}\nreturn res\n}"}
{"tgt": "h := new(IntArray)\nh.heapIntArrays = arr\nh.heap.binHeapArrayIf = &h.heapIntArrays\nh.BuildHeap()\nreturn h", "gen": "h := &heapIntArrays{\n\tIntArray: IntArray{\n\t\tHead:    nil,\n\t\tKey:     nil,\n\t\tLast:    nil,\n\t\tLen:     0,\n\t\tNext:    nil,\n\t\tParent:  nil,\n\t\tPrev:    nil,\n\t\tRight:   nil,\n\t\tSwap:    nil,\n\t\tValid:   nil,\n\t\tValue:   nil,\n\t},\n}\nh.BuildHeap()\nreturn h\n}"}
{"tgt": "if n == 1 || n == 2 {\n\treturn big.NewInt(1)\n}\nif mem[n] != nil {\n\treturn mem[n]\n}\nresult := big.NewInt(0)\nresult.Add(FibonacciHelper(n-1, mem), FibonacciHelper(n-2, mem))\nmem[n] = result\nreturn result", "gen": "if n < 2 {\n\treturn big.NewInt(1)\n}\nif n == 2 {\n\treturn big.NewInt(2)\n}\nif fib[n-1] != nil {\n\treturn fib[n-1]\n}\nreturn big.NewInt(0)\n}"}
{"tgt": "coins := []int{1, 2, 5, 10, 20, 50, 100, 200}\nmemo := make(map[string]int)\nreturn findAllWays(coins, 0, n, memo)", "gen": "var ways = make(map[int]int)\nways[1] = 1\nways[2] = 2\nways[5] = 5\nways[10] = 10\nways[20] = 20\nways[50] = 50\nways[100] = 100\nways[200] = 200\nreturn findAllWays(ways, 0)\n}"}
{"tgt": "data, err := base64.StdEncoding.DecodeString(b64)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(data)", "gen": "decoded, err := StdEncoding.DecodeString(str)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(decoded)\n}"}
{"tgt": "qs := []question322{\n\t{\n\t\tpara322{[]int{186, 419, 83, 408}, 6249},\n\t\tans322{20},\n\t},\n\t{\n\t\tpara322{[]int{1, 2147483647}, 2},\n\t\tans322{2},\n\t},\n\t{\n\t\tpara322{[]int{1, 2, 5}, 11},\n\t\tans322{3},\n\t},\n\t{\n\t\tpara322{[]int{2}, 3},\n\t\tans322{-1},\n\t},\n\t{\n\t\tpara322{[]int{1}, 0},\n\t\tans322{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans322, q.para322\n\tfmt.Printf(\"STR\", p, coinChange(p.one, p.amount))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question322{\n\t{\n\t\tpara322{[]int{186, 419, 83, 408}},\n\t\tans322{6249},\n\t},\n\t{\n\t\tpara322{[]int{1, 2147483647}},\n\t\tans322{20},\n\t},\n\t{\n\t\tpara322{[]int{1, 2, 5, 11}},\n\t\tans322{3},\n\t},\n\t{\n\t\tpara322{[]int{2}},\n\t\tans322{-1},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans322, q.para322\n\tfmt.Printf(\"STR\", p, coinChange(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.locs); !reflect.DeepEqual(bonuses, tc.bonuses) {\n\t\tt.Errorf(\"STR\", tc.bonuses, bonuses)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.input); !reflect.DeepEqual(bonuses, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, bonuses)\n\t}\n}\n}"}
{"tgt": "count := uint32(0)\nfor num != 0 {\n\tcount += num & 1\n\tnum = num >> 1\n}\nreturn int(count)", "gen": "var sum int\nfor n != 0 {\n\tsum += n & 1\n\tn >>= 1\n}\nreturn sum\n}"}
{"tgt": "var sum int\nfor _, num := range nums {\n\tsum += num\n}\nif sum%2 != 0 {\n\treturn false\n}\nc := sum / 2\nn := len(nums)\nmemo := make([]bool, c+1)\nfor i := 0; i <= c; i++ {\n\tmemo[i] = nums[0] == i\n}\nfor i := 0; i < n; i++ {\n\tfor j := c; j >= nums[i]; j-- {\n\t\tmemo[j] = memo[j] || memo[j-nums[i]]\n\t}\n}\nreturn memo[c]", "gen": "sum := 0\nfor _, num := range nums {\n\tsum += num\n}\nif sum%2 == 1 {\n\treturn false\n}\nhalf := sum / 2\nres := make([]bool, half+1)\nfor i := 0; i < half; i++ {\n\tfor j := 0; j < len(nums); j++ {\n\t\tif res[j] {\n\t\t\tcontinue\n\t\t}\n\t\tif nums[j] < half-i {\n\t\t\tres[j] = true\n\t\t}\n\t}\n}\nfor i := 0; i < len(nums); i++ {\n\tif !res[i] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "count1 := 0\nfor _, r := range S {\n\tif r == '(' {\n\t\tcount1++\n\t} else if count1 > 0 {\n\t\tcount1--\n\t}\n}\ncount2 := 0\nfor i := len(S) - 1; i >= 0; i-- {\n\tif S[i] == ')' {\n\t\tcount2++\n\t} else if count2 > 0 {\n\t\tcount2--\n\t}\n}\nreturn count1 + count2", "gen": "count := 0\nfor _, c := range s {\n\tif c == '(' {\n\t\tcount++\n\t} else if c == ')' {\n\t\tif count == 0 {\n\t\t\treturn 0\n\t\t}\n\t\tcount--\n\t}\n}\nleft, right := 0, 0\nfor i := len(s) - 1; i >= 0; i-- {\n\tif s[i] == '(' {\n\t\tleft++\n\t} else if s[i] == ')' {\n\t\tif left == 0 {\n\t\t\treturn 0\n\t\t}\n\t\tleft--\n\t}\n}\nreturn left + right\n}"}
{"tgt": "for i := rangeMin; i <= rangeMax; i++ {\n\tif evenlyDivisble%i != 0 {\n\t\tevenlyDivisble = evenlyDivisble * lcm(evenlyDivisble, i)\n\t}\n\tfmt.Println(evenlyDivisble, \"STR\", i, \"STR\", evenlyDivisble/i)\n}", "gen": "for i := rangeMin; i <= rangeMax; i++ {\n\tif i%rangeMin != 0 {\n\t\tevenlyDivisble = lcm(evenlyDivisble, i)\n\t}\n\tfmt.Println(\"STR\", evenlyDivisble, i)\n}\n}"}
{"tgt": "log.SetFlags(0)\nvar err error\ntpl := template.New(\"STR\")\ntpl = tpl.Funcs(template.FuncMap{\n\t\"STR\": func(str string) string {\n\t\treturn strings.ToUpper(str)\n\t},\n})\ntpl, err = tpl.ParseFiles(\"STR\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nerr = tpl.ExecuteTemplate(os.Stdout, \"STR\", Page{\n\tTitle: \"STR\",\n\tBody:  \"STR\",\n})\nif err != nil {\n\tlog.Fatalln(err)\n}", "gen": "log.SetFlags(log.Lshortfile)\nt := template.New(\"\").Funcs(map[string]interface{}{\n\t\"STR\": STR,\n})\n_, err := t.ParseFiles(\"STR.html\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nt.ExecuteTemplate(os.Stdout, \"STR.html\", Page{STR: \"STR\"})\n}"}
{"tgt": "return append(ints, added...)", "gen": "return append(s, 0)\n}"}
{"tgt": "left, right := 0, len(nums)-1\nfor left < right {\n\tmid := (left + right) / 2\n\tcount := 0\n\tfor _, num := range nums {\n\t\tif num <= mid {\n\t\t\tcount++\n\t\t}\n\t}\n\tif count > mid {\n\t\tright = mid\n\t} else {\n\t\tleft = mid + 1\n\t}\n}\nreturn left", "gen": "left, right := 0, len(nums)-1\nfor left < right {\n\tmid := (left + right) / 2\n\tcount := 0\n\tfor _, num := range nums {\n\t\tif num <= mid {\n\t\t\tcount++\n\t\t}\n\t}\n\tif count > mid {\n\t\tright = mid - 1\n\t} else {\n\t\tleft = mid + 1\n\t}\n}\nreturn left\n}"}
{"tgt": "var min int\ntotalPeople := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\ttotalPeople++\n\t}\n}\nif totalPeople < 2 {\n\treturn 0\n}\nmiddle := (totalPeople / 2) + (totalPeople % 2)\nindex := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\tmiddle--\n\t}\n\tif middle == 0 {\n\t\tindex = i\n\t\tbreak\n\t}\n}\nleftZero := 0\nleftZeroFound := false\nfor j := index - 1; j >= 0; j-- {\n\tif !leftZeroFound && seating[j] == 0 {\n\t\tleftZero = j\n\t\tleftZeroFound = true\n\t} else if seating[j] == 1 && j < leftZero {\n\t\tmin += abs(j - leftZero)\n\t\tleftZero--\n\t}\n}\nrightZero := 0\nrightZeroFound := false\nfor j := index + 1; j < len(seating); j++ {\n\tif !rightZeroFound && seating[j] == 0 {\n\t\trightZero = j\n\t\trightZeroFound = true\n\t} else if seating[j] == 1 && j > rightZero {\n\t\tmin += abs(j - rightZero)\n\t\trightZero++\n\t}\n}\nreturn min", "gen": "var sum, count int\nfor _, n := range nums {\n\tif n == 1 {\n\t\tcount++\n\t}\n}\nif count == 0 {\n\treturn 0\n}\nvar i, j int\nfor i = 0; i < len(nums); i++ {\n\tif nums[i] == 1 {\n\t\tj = i\n\t\tbreak\n\t}\n}\nfor i < len(nums) {\n\tif nums[i] == 1 {\n\t\tsum++\n\t}\n\ti++\n}\nfor i < len(nums) {\n\tif nums[i] == 1 {\n\t\tsum++\n\t}\n\ti++\n}\nreturn sum\n}"}
{"tgt": "targetRange := []int{-1, -1}\nfor i := 0; i < len(nums); i++ {\n\tif nums[i] == target {\n\t\ttargetRange[0] = i\n\t\tbreak\n\t}\n}\nif targetRange[0] == -1 {\n\treturn targetRange\n}\nfor j := len(nums) - 1; j >= 0; j-- {\n\tif nums[j] == target {\n\t\ttargetRange[1] = j\n\t\tbreak\n\t}\n}\nreturn targetRange", "gen": "var res []int\nres = append(res, -1)\nres = append(res, -1)\nfor i := 0; i < len(nums); i++ {\n\tif nums[i] == target {\n\t\tres[1] = i\n\t\treturn res\n\t}\n}\nfor i := len(nums) - 1; i >= 0; i-- {\n\tif nums[i] == target {\n\t\tres[0] = i\n\t\treturn res\n\t}\n}\nreturn res\n}"}
{"tgt": "var tests = []struct {\n\tbefore []int\n\tafter  *ListNode\n}{\n\t{[]int{}, nil},\n\t{[]int{1}, newList(1)},\n\t{[]int{1, 2, 3, 4, 5}, newList(1, 3, 5, 2, 4)},\n\t{[]int{1, 2, 3, 4, 5, 6}, newList(1, 3, 5, 2, 4, 6)},\n\t{[]int{2, 1, 3, 5, 6, 4, 7}, newList(2, 3, 6, 7, 1, 5, 4)},\n}\nfor _, tt := range tests {\n\tafter := oddEvenList(newList(tt.before...))\n\tif reflect.DeepEqual(after, tt.after) == false {\n\t\tt.Errorf(\"STR\", newList(tt.before...), after, tt.after)\n\t}\n}", "gen": "head1 := newList([]int{1})\nhead2 := newList([]int{1, 3, 5, 2, 4})\nhead3 := newList([]int{1, 3, 5, 2, 4, 6})\nhead4 := newList([]int{2, 1, 3, 5, 6, 4, 7})\nhead5 := newList([]int{1, 2, 3, 4, 5, 6, 7})\ntests := []*ListNode{\n\thead1,\n\thead2,\n\thead3,\n\thead4,\n\thead5,\n}\nfor i, tt := range tests {\n\tgot := oddEvenList(tt)\n\twant := newList([]int{1, 3, 5, 2, 4, 6, 7})\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"STR\", i, tt, got, want)\n\t}\n}\n}"}
{"tgt": "out := 45228\nif x := p32(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "if p32(45228) != 45228 {\n\tt.Errorf(\"STR\", 45228, p32(45228))\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SecondLargest(tc.root); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := SecondLargest(tc.nums); res != tc.secondLargest {\n\t\tt.Errorf(\"STR\", tc.secondLargest, res)\n\t}\n}\n}"}
{"tgt": "primes := [...]int{2: 1, 3: 1, 5: 1, 7: 1, 11: 1, 13: 1, 17: 1, 19: 1}\nres := 0\nfor i := L; i <= R; i++ {\n\tbits := 0\n\tfor n := i; n > 0; n >>= 1 {\n\t\tbits += n & 1\n\t}\n\tres += primes[bits]\n}\nreturn res", "gen": "var res int\nfor i := 0; i < n; i++ {\n\tvar sum int\n\tfor j := 0; j < 20; j++ {\n\t\tsum += (1 << j) & i\n\t}\n\tres += sum\n}\nreturn res\n}"}
{"tgt": "qs := []question1232{\n\t{\n\t\tpara1232{[][]int{{1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6}, {6, 7}}},\n\t\tans1232{true},\n\t},\n\t{\n\t\tpara1232{[][]int{{1, 1}, {2, 2}, {3, 4}, {4, 5}, {5, 6}, {7, 7}}},\n\t\tans1232{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1232, q.para1232\n\tfmt.Printf(\"STR\", p, checkStraightLine(p.arr))\n}\nfmt.Printf(\"STR\")", "gen": "var points = [][]int{\n\t{1, 2},\n\t{2, 3},\n\t{3, 4},\n\t{4, 5},\n\t{5, 6},\n\t{6, 7},\n}\nvar res = [][]int{\n\t{1, 1},\n\t{2, 2},\n\t{3, 4},\n\t{4, 5},\n\t{5, 6},\n\t{6, 7},\n}\nfmt.Printf(\"STR\", points)\nfor _, point := range points {\n\tfmt.Printf(\"STR\", point, checkStraightLine(points, point))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "var tests = []struct {\n\tnums    []int\n\tmissing int\n}{\n\t{[]int{1, 1}, 2},\n\t{[]int{1, 2, 0}, 3},\n\t{[]int{3, 4, -1, 1}, 2},\n\t{[]int{7, 8, 9, 11, 12}, 1},\n}\nfor _, tt := range tests {\n\tnums := make([]int, len(tt.nums))\n\tcopy(nums, tt.nums)\n\tmissing := firstMissingPositive(tt.nums)\n\tif missing != tt.missing {\n\t\tt.Errorf(\"STR\", nums, missing, tt.missing)\n\t}\n}", "gen": "tests := [][]int{\n\t{1, 2, 3},\n\t{1, 2, 3, 4, 5},\n\t{1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12},\n}\nfor _, tt := range tests {\n\tif result := firstMissingPositive(tt); result != tt[len(tt)] {\n\t\tt.Errorf(\"STR\", tt, result)\n\t}\n}\n}"}
{"tgt": "if nil == head || nil == head.Next ||\n\tm == n {\n\treturn head\n}\nstep := n - m\nvar leftTail *ListNode\np := head\nfor m > 1 {\n\tleftTail = p\n\tp = p.Next\n\tm--\n}\nq := p.Next\np.Next = nil\nmidTail := p\nfor step > 0 {\n\tr := q.Next\n\tq.Next = p\n\tp = q\n\tq = r\n\tstep--\n}\nif nil == leftTail {\n\tmidTail.Next = q\n\treturn p\n}\nleftTail.Next = p\nmidTail.Next = q\nreturn head", "gen": "if root == nil || root.Left == nil || root.Right == nil {\n\treturn root\n}\nvar (\n\tcount = root.Left.Val - root.Val\n\tnode  = root\n)\nfor node.Left != nil {\n\tcount = node.Left.Val - node.Val\n\tnode = node.Left\n}\nfor count > 0 {\n\tnode.Right = &TreeNode{Val: node.Val}\n\tnode = node.Right\n\tcount--\n}\nnode.Right = &TreeNode{Val: node.Val}\nreturn root\n}"}
{"tgt": "var tests = []struct {\n\ttree  *TreeNode\n\tdepth int\n}{\n\t{newTree(3, 9, 20, nil, nil, 15, 7), 2},\n\t{newTree(1, 2), 2},\n\t{newTree(1, 2, 2, 3), 2},\n\t{newTree(1, 2, 2, 3, 3, nil, nil, 4, 4), 2},\n\t{newTree(1, 2, 2, 3, nil, 3, 3, 4), 3},\n\t{newTree(1, 2, 2, nil, nil, nil, 3, 4, 4), 2},\n}\nfor _, tt := range tests {\n\tdepth := minDepth(tt.tree)\n\tif depth != tt.depth {\n\t\tt.Errorf(\"STR\", tt.tree, depth, tt.depth)\n\t}\n}", "gen": "var tests = []struct {\n\troot *Tree\n\twant int\n}{\n\t{newTree([]int{3, 9, 20, nil, nil, 15, 7}), 2},\n\t{newTree([]int{1, 2}), 2},\n\t{newTree([]int{1, nil, 2}), 2},\n\t{newTree([]int{1, nil, 2, nil, 3}), 2},\n\t{newTree([]int{1, nil, 2, nil, 3, nil, 4, nil, 5}), 2},\n\t{newTree([]int{1, nil, 2, nil, 3, nil, 4, nil, 5, nil, 6}), 2},\n\t{newTree([]int{1, nil, 2, nil, 3, nil, 4, nil, 5, nil, 6, nil, 7}), 2},\n\t{newTree([]int{1, nil, 2, nil, 3, nil, 4, nil, 5, nil, 6, nil, 7, nil, 8}), 2},\n\t{newTree([]int{1, nil, 2, nil, 3, nil, 4, nil, 5, nil, 6, nil, 7, nil, 8, nil, 9}), 2},\n\t{newTree([]int{1, nil, 2, nil, 3, nil, 4, nil, 5, nil, 6, nil, 7, nil, 8, nil, 9, nil, 10}), 2},\n\t{newTree([]int{1, nil, 2, nil, 3, nil, 4, nil, 5, nil, 6, nil, 7, nil, 8, nil, 9, nil, 10, nil, 11}), 2},\n\t{newTree([]int{1, nil, 2, nil, 3, nil, 4, nil,"}
{"tgt": "t.Parallel()\nd := NewTimeMap()\nd.Set(1, 1, 0)\nd.Set(1, 2, 2)\nif result := d.Get(1, 1); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 3); result != 2 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 5)\nif result := d.Get(1, 0); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 10); result != 1 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 0)\nd.Set(1, 2, 0)\nif result := d.Get(1, 0); result != 2 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(2, 0); result != nil {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, -1); result != nil {\n\tt.Errorf(\"STR\")\n}", "gen": "t.Parallel()\ntm := NewTimeMap()\ntm.Set(0, 0)\ntm.Set(2, 2)\nif tm.Get(0) != 0 {\n\tt.Errorf(\"STR\")\n}\nif tm.Get(1) != 0 {\n\tt.Errorf(\"STR\")\n}\nif tm.Get(2) != 2 {\n\tt.Errorf(\"STR\")\n}\ntm.Set(3, 1)\nif tm.Get(3) != 1 {\n\tt.Errorf(\"STR\")\n}\ntm.Set(5, 1)\nif tm.Get(5) != 1 {\n\tt.Errorf(\"STR\")\n}\ntm.Set(10, 1)\nif tm.Get(10) != 1 {\n\tt.Errorf(\"STR\")\n}\ntm.Set(0, 1)\nif tm.Get(0) != 1 {\n\tt.Errorf(\"STR\")\n}\ntm.Set(0, 2)\nif tm.Get(0) != 2 {\n\tt.Errorf(\"STR\")\n}\ntm.Set(0, 10)\nif tm.Get(0) != 10 {\n\tt.Errorf(\"STR\")\n}\ntm.Set(0, 0)\nif tm.Get(0) != 0 {\n\tt.Errorf(\"STR\")\n}\n}"}
{"tgt": "if len(steps) < 2 {\n\treturn true\n}\nfor step := 1; step <= steps[0] && step <= len(steps); step++ {\n\tif CanAdvanceToEndBrute(steps[step:]) {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "if len(rooms) < 2 {\n\treturn true\n}\nfor i := 1; i < len(rooms); i++ {\n\tif CanAdvanceToEndBrute(rooms, i) {\n\t\treturn true\n\t}\n}\nreturn false\n}"}
{"tgt": "obj := Constructor225()\nfmt.Printf(\"STR\", obj)\nparam5 := obj.Empty()\nfmt.Printf(\"STR\", param5)\nobj.Push(2)\nfmt.Printf(\"STR\", obj)\nobj.Push(10)\nfmt.Printf(\"STR\", obj)\nparam2 := obj.Pop()\nfmt.Printf(\"STR\", param2)\nparam3 := obj.Top()\nfmt.Printf(\"STR\", param3)\nparam4 := obj.Empty()\nfmt.Printf(\"STR\", param4)", "gen": "qs := Constructor225()\nfmt.Printf(\"STR\", qs)\nqs.Push(1)\nqs.Push(2)\nfmt.Printf(\"STR\", qs)\nqs.Pop()\nfmt.Printf(\"STR\", qs.Top())\nfmt.Printf(\"STR\", qs.Empty())\n}"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []string\n\texpect [][]string\n}{\n\t{\"STR\", []string{\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\"},\n\t\t[][]string{\n\t\t\t{\"STR\", \"STR\", \"STR\"},\n\t\t\t{\"STR\", \"STR\"},\n\t\t\t{\"STR\"},\n\t\t},\n\t},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := groupAnagrams(c.inputs)\n\t\tfmt.Println(got)\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tinputs []string\n\texpect []string\n}{\n\t{\"STR\", []string{\"STR\"}, []string{\"STR\"}},\n\t{\"STRSTR\", []string{\"STRSTR\"}, []string{\"STRSTRSTR\"}},\n\t{\"STRSTRSTR\", []string{\"STRSTRSTR\"}, []string{\"STRSTRSTRSTRSTR\"}},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := StrStr(c.inputs[0], c.inputs[1])\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.inputs[0],\n\t\t\t\tc.inputs[1],\n\t\t\t\tc.expect,\n\t\t\t\tgot)\n\t\t}\n\t})\n}\n}"}
{"tgt": "i1 := 0\ni2 := 0\nval1 := 0\nval2 := 0\nfor i1 < len(version1) || i2 < len(version2) {\n\tval1, i1 = parseSeg(version1, i1)\n\tval2, i2 = parseSeg(version2, i2)\n\tif val1 > val2 {\n\t\treturn 1\n\t}\n\tif val1 < val2 {\n\t\treturn -1\n\t}\n}\nif i1 < len(version1) {\n\treturn 1\n}\nif i2 < len(version2) {\n\treturn -1\n}\nreturn 0", "gen": "var (\n\tstart, end int\n\ts1, s2    = parseSeg(S), parseSeg(E)\n)\nfor start < len(S) && end < len(E) {\n\tif s1 < s2 {\n\t\treturn 1\n\t}\n\tif s1 > s2 {\n\t\treturn -1\n\t}\n\ts1, s2 = parseSeg(S[start:])\n\ts1, s2 = parseSeg(E[end:])\n\tif s1 < s2 {\n\t\treturn 1\n\t}\n\tif s1 > s2 {\n\t\treturn -1\n\t}\n\tstart++\n\tend++\n}\nif start < len(S) {\n\treturn 1\n}\nif end < len(E) {\n\treturn -1\n}\nreturn 0\n}"}
{"tgt": "result := make([]int, 0)\nfor i := 0; i < n; i++ {\n\tresult = append(result, nums[i])\n\tresult = append(result, nums[n+i])\n}\nreturn result", "gen": "res := make([]int, 0)\nfor i := 0; i < len(nums); i++ {\n\tif i < len(nums) && nums[i] == nums[i-1] {\n\t\tcontinue\n\t}\n\tres = append(res, nums[i])\n\tfor j := i + 1; j < len(nums); j++ {\n\t\tif nums[j] == nums[i] {\n\t\t\tbreak\n\t\t}\n\t\tres = append(res, nums[j])\n\t}\n}\nreturn res\n}"}
{"tgt": "nums := make([]byte, n)\nfor i := 0; i < n; i++ {\n\tnums[i] = byte(i) + '1'\n}\nfor i := 2; i <= k; i++ {\n\tnextPermutation60(nums)\n}\nreturn string(nums)", "gen": "res := make([]byte, len(nums))\nfor i := 0; i < len(nums); i++ {\n\tres[i] = '0' + nums[i]\n}\nfor i := 0; i < len(nums); i++ {\n\tnextPermutation(nums)\n\tif i < k {\n\t\tcontinue\n\t}\n\treturn string(nums)\n}\nreturn \"\"\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MakePalindrome(tc.input); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MakePalindrome(tc.input); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "ln, err := net.Listen(\"STR\", \"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"STR\", conn.RemoteAddr())\n\tio.WriteString(conn, fmt.Sprint(time.Now()))\n\tconn.Close()\n}", "gen": "listener, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\nif err != nil {\n\tpanic(err)\n}\ndefer listener.Close()\nfmt.Println(\"STR\")\ntime.Sleep(time.Second)\nfmt.Println(time.Now())\nlistener.WriteString(\"STR\")\n}"}
{"tgt": "self.table[index].Num = value", "gen": "this.data[i] = v\n}"}
{"tgt": "return x.(int) < y.(int)", "gen": "return a == b\n}"}
{"tgt": "return strings.Replace(address, \"STR\", \"STR\", -1)", "gen": "return strings.Replace(s, \"STR\", \"STR\", -1)\n}"}
{"tgt": "var parts []string\nvar isFile bool\nvar partStart, tabCount, maxLength int\nfor i, r := range fs {\n\tswitch {\n\tcase isNewStart(i, r, fs):\n\t\tpartStart = i\n\tcase r == '.':\n\t\tisFile = true\n\tcase r == '\\t':\n\t\ttabCount++\n\tcase r == '\\n':\n\t\tif pos := tabCount; len(parts) > pos {\n\t\t\tparts = parts[:pos]\n\t\t}\n\t\tparts = append(parts, fs[partStart:i])\n\t\tif len := len(strings.Join(parts, \"STR\")); isFile && len > maxLength {\n\t\t\tmaxLength = len\n\t\t}\n\t\tisFile = false\n\t\ttabCount = 0\n\t}\n}\nif isFile {\n\tparts = append(parts, fs[partStart:])\n}\nreturn len(strings.Join(parts, \"STR\"))", "gen": "var start int\nvar isNewStart bool\nvar count int\nvar isNewCount bool\nvar result string\nfor i, c := range s {\n\tif isNewStart {\n\t\tstart = i\n\t\tisNewStart = false\n\t}\n\tif c == ' ' {\n\t\tisNewStart = true\n\t}\n\tif c == '.' {\n\t\tcount++\n\t\tisNewCount = true\n\t}\n\tif isNewCount {\n\t\tif count > 46 {\n\t\t\tresult = strings.Join(s[start:i], \".\")\n\t\t\treturn result\n\t\t}\n\t\tisNewCount = false\n\t}\n}\nreturn result\n}"}
{"tgt": "FprintVersion(os.Stdout)", "gen": "FprintVersion(os.Stdout, Version)\n}"}
{"tgt": "cnt := 0\nfor i := 0; cnt < n && i < len(flowerbed); i++ {\n\tif i > 0 && flowerbed[i-1] == 1 {\n\t\tcontinue\n\t}\n\tif i < len(flowerbed)-1 && flowerbed[i+1] == 1 {\n\t\tcontinue\n\t}\n\tif flowerbed[i] != 0 {\n\t\tcontinue\n\t}\n\tflowerbed[i] = 1\n\tcnt++\n\tif i < len(flowerbed)-1 {\n\t\tflowerbed[i+1] = -1\n\t}\n}\nreturn cnt >= n", "gen": "var count int\nfor i := 0; i < len(A); i++ {\n\tif i > 0 && A[i] == A[i-1] {\n\t\tcontinue\n\t}\n\tif i < len(A)-1 && A[i] == A[i+1] {\n\t\tcontinue\n\t}\n\tif i == 0 || i == len(A)-1 {\n\t\tA[i] = 1\n\t\tcount++\n\t}\n}\nreturn count == len(A)\n}"}
{"tgt": "m := len(A)\nn := len(A[0])\nans := make([][]int, n)\nfor k := range ans {\n\tans[k] = make([]int, m)\n}\nfor r := 0; r < m; r++ {\n\tfor c := 0; c < n; c++ {\n\t\tans[c][r] = A[r][c]\n\t}\n}\nreturn ans", "gen": "n := len(nums)\ncount := make([][]int, n)\nfor i := range count {\n\tcount[i] = make([]int, n)\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tcount[i][j] = nums[i] + nums[j]\n\t}\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tnums[i] = count[i][j]\n\t}\n}\nreturn nums\n}"}
{"tgt": "patternMap := make(map[string]string)\nstrMap := make(map[string]string)\nplen := len(pattern)\nstrArr := strings.Split(str, \"STR\")\npatternArr := strings.Split(pattern, \"STR\")\nif plen != len(strArr) {\n\treturn false\n}\nfor i := 0; i < plen; i++ {\n\tif _, ok := patternMap[patternArr[i]]; !ok {\n\t\tpatternMap[patternArr[i]] = strArr[i]\n\t}\n\tif _, ok := strMap[strArr[i]]; !ok {\n\t\tstrMap[strArr[i]] = patternArr[i]\n\t}\n\tif patternMap[patternArr[i]] != strArr[i] || strMap[strArr[i]] != patternArr[i] {\n\t\tfmt.Println(\"STR\", patternMap)\n\t\tfmt.Println(\"STR\", strMap)\n\t\treturn false\n\t}\n}\nfmt.Println(\"STR\", patternMap)\nfmt.Println(\"STR\", strMap)\nreturn true", "gen": "m1 := make(map[string]string)\nm2 := make(map[string]string)\ns1 := strings.Split(STR, \"STR\")\ns2 := strings.Split(STR, \"STR\")\nfor i := 0; i < len(s1); i++ {\n\tif len(s1[i]) != len(s2[i]) {\n\t\treturn false\n\t}\n\tif m1[s1[i]] != s2[i] {\n\t\treturn false\n\t}\n\tif m2[s2[i]] != s1[i] {\n\t\treturn false\n\t}\n}\nreturn true\n}"}
{"tgt": "nlen := len(nums)\nfor i := 0; i < nlen-2; i++ {\n\tif i != 0 && nums[i] == nums[i-1] {\n\t\tcontinue\n\t}\n\tleft, right := i+1, nlen-1\n\tfor left < right {\n\t\tsum := nums[i] + nums[left] + nums[right]\n\t\tif sum == target {\n\t\t\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tleft++\n\t\t\tright--\n\t\t} else if sum < target {\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tleft++\n\t\t} else {\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tright--\n\t\t}\n\t}\n}", "gen": "for i := 0; i < len(nums); i++ {\n\tfor j := i + 1; j < len(nums); j++ {\n\t\tif nums[i]+nums[j] == target {\n\t\t\treturn []int{i, j}\n\t\t}\n\t}\n\tfor j := i - 1; j >= 0; j-- {\n\t\tif nums[i]+nums[j] == target {\n\t\t\treturn []int{i, j}\n\t\t}\n\t}\n}\nreturn nil\n}"}
{"tgt": "sLen, tLen := len(s), len(t)\nneed := [256]int{}\nfor i := range t {\n\tneed[t[i]]++\n}\nhas := [256]int{}\nmin := sLen + 1\nbegin, end, winBegin, winEnd, count := 0, 0, 0, 0, 0\nfor ; end < sLen; end++ {\n\tif need[s[end]] == 0 {\n\t\tcontinue\n\t}\n\tif has[s[end]] < need[s[end]] {\n\t\tcount++\n\t}\n\thas[s[end]]++\n\tif count == tLen {\n\t\tfor need[s[begin]] == 0 || has[s[begin]] > need[s[begin]] {\n\t\t\tif has[s[begin]] > need[s[begin]] {\n\t\t\t\thas[s[begin]]--\n\t\t\t}\n\t\t\tbegin++\n\t\t}\n\t\ttemp := end - begin + 1\n\t\tif min > temp {\n\t\t\tmin = temp\n\t\t\twinBegin = begin\n\t\t\twinEnd = end\n\t\t}\n\t}\n}\nif count < tLen {\n\treturn \"STR\"\n}\nreturn s[winBegin : winEnd+1]", "gen": "n := len(s)\ndp := make([]int, n)\nfor i := range dp {\n\tdp[i] = 1\n}\nfor i := 0; i < n; i++ {\n\tif s[i] == '1' {\n\t\tcontinue\n\t}\n\tfor j := i + 1; j < n; j++ {\n\t\tif s[j] == '1' {\n\t\t\tcontinue\n\t\t}\n\t\tif s[i] == s[j] {\n\t\t\tdp[j] = dp[i] + 1\n\t\t}\n\t}\n}\nvar max int\nfor i := range dp {\n\tif dp[i] > max {\n\t\tmax = dp[i]\n\t}\n}\nif max < 2 {\n\treturn \"STR\"\n}\nreturn \"STR\"\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif steps := MinimumStepsPath(tc.path); steps != tc.minimumSteps {\n\t\tt.Errorf(\"STR\", tc.minimumSteps, steps)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimumStepsPath(tc.input); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "n := len(cost)\ndp := make([]int, n)\ndp[0], dp[1] = cost[0], cost[1]\nfor i := 2; i < n; i++ {\n\tdp[i] = cost[i] + min(dp[i-2], dp[i-1])\n}\nreturn min(dp[n-2], dp[n-1])", "gen": "n := len(A)\nB := make([]int, n)\nB[0] = A[0]\nB[n-1] = A[n-1]\nfor i := 2; i < n; i++ {\n\tB[i] = min(A[i-2], A[i-1]) + A[i]\n}\nreturn B[n-1]\n}"}
{"tgt": "qs := []question845{\n\t{\n\t\tpara845{[]int{875, 884, 239, 731, 723, 685}},\n\t\tans845{4},\n\t},\n\t{\n\t\tpara845{[]int{0, 1, 2, 3, 4, 5, 4, 3, 2, 1, 0}},\n\t\tans845{11},\n\t},\n\t{\n\t\tpara845{[]int{2, 3}},\n\t\tans845{0},\n\t},\n\t{\n\t\tpara845{[]int{2, 1, 4, 7, 3, 2, 5}},\n\t\tans845{5},\n\t},\n\t{\n\t\tpara845{[]int{2, 2, 2}},\n\t\tans845{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans845, q.para845\n\tfmt.Printf(\"STR\", p, longestMountain(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question845{\n\t{\n\t\tpara845{[]int{875, 884, 239, 731, 723, 685}},\n\t\tans845{4},\n\t},\n\t{\n\t\tpara845{[]int{0, 1, 2, 3, 4, 4, 3, 2, 1, 0}},\n\t\tans845{11},\n\t},\n\t{\n\t\tpara845{[]int{2, 3, 2, 1, 0}},\n\t\tans845{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans845, q.para845\n\tfmt.Printf(\"STR\", p, longestMountain(p.one))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "res := make([]int, 0)\nfor i := 0; i < len(nums); i = i + 2 {\n\tfreq, val := nums[i], nums[i+1]\n\tfor j := 0; j < freq; j++ {\n\t\tres = append(res, val)\n\t}\n}\nreturn res", "gen": "res := make([]int, 0)\nfor i := 0; i < len(nums); i++ {\n\tfor j := i + 1; j < len(nums); j++ {\n\t\tres = append(res, nums[i]+nums[j])\n\t}\n}\nreturn res\n}"}
{"tgt": "defer wg.Done()\nfor v := range taskQueue {\n\tfmt.Printf(\"STR\", workerId, v.Id, v.JobId)\n\tv.Run()\n\tfmt.Printf(\"STR\", workerId, v.Status, v.Id, v.JobId)\n}", "gen": "defer func() {\n\tfmt.Printf(\"STR\", t.TaskID)\n\tt.Run()\n\tfmt.Printf(\"STR\", t.TaskID, t.TaskID)\n}()\nfor {\n\ttask, ok := <-taskChan\n\tif !ok {\n\t\tbreak\n\t}\n\tfmt.Printf(\"STR\", task.TaskID)\n\ttask.Run()\n\tfmt.Printf(\"STR\", task.TaskID, task.TaskID)\n}\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := Reverse32Bits(tc.given); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := Reverse32Bits(tc.input); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "dummy := &ListNode{0, head}\nslow, fast := dummy, dummy\nfor fast.Next != nil && fast.Next.Next != nil {\n\tfast = fast.Next.Next\n\tslow = slow.Next\n}\nreturn slow.Next", "gen": "var head *ListNode\nfor head != nil && head.Next != nil && head.Next.Next != nil {\n\thead = head.Next.Next\n}\nreturn head\n}"}
{"tgt": "fmt.Println(superEggDrop(1, 2))\nfmt.Println(superEggDrop(2, 6))\nfmt.Println(superEggDrop(2, 4))", "gen": "fmt.Println(superEggDrop(2, 1, 1))\nfmt.Println(superEggDrop(6, 2, 2))\nfmt.Println(superEggDrop(4, 2, 4))\n}"}
{"tgt": "var res []int\nstack := []*preOrderTree{root}\nfor len(stack) > 0 {\n\troot = stack[0]\n\tstack = stack[1:]\n\tres = append(res, root.data)\n\tif root.left != nil {\n\t\tstack = append(stack, root.left)\n\t}\n\tif root.right != nil {\n\t\tstack = append(stack, root.right)\n\t}\n}\nreturn res", "gen": "var res []int\nvar stack []*preOrderTree\nfor p := root; p != nil; p = p.Right {\n\tstack = append(stack, p)\n}\nfor len(stack) > 0 {\n\tp := stack[len(stack)-1]\n\tstack = stack[:len(stack)-1]\n\tres = append(res, p.Val)\n\tif p.Left != nil {\n\t\tstack = append(stack, p.Left)\n\t}\n\tif p.Right != nil {\n\t\tstack = append(stack, p.Right)\n\t}\n}\nreturn res\n}"}
{"tgt": "l, r := 0, 0\nn := len(s)\nfor i := 0; i < n; i++ {\n\tif s[i] == ')' {\n\t\tl--\n\t} else {\n\t\tl++\n\t}\n\tj := n - i - 1\n\tif s[j] == '(' {\n\t\tr--\n\t} else {\n\t\tr++\n\t}\n\tif l < 0 || r < 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "balance := 0\nmaxBalance := 0\nfor i := 0; i < len(s); i++ {\n\tif s[i] == '(' {\n\t\tbalance++\n\t} else {\n\t\tbalance--\n\t}\n\tif balance < 0 {\n\t\tbalance++\n\t\tmaxBalance++\n\t}\n}\nif balance != 0 {\n\treturn false\n}\nreturn true\n}"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA\n\tC int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif !ok {\n\tt.Error(\"STR\")\n}", "gen": "type B struct {\n\tA *B\n\tD int\n}\nb := B{\n\tA: &B{},\n\tD: 123,\n}\nif HasZero(b) {\n\tt.Error(\"STR\")\n}\n}"}
{"tgt": "for i, row := range matrix[1:] {\n\tfor j, v := range row[1:] {\n\t\tif v != matrix[i][j] {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "var i, j int\nfor _, s := range strs {\n\tif len(s) == 0 {\n\t\treturn false\n\t}\n\tfor _, t := range strs {\n\t\tif len(t) < len(s) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, j = 0, len(s); i < len(s) && j < len(t); i, j = i+1, j+1 {\n\t\t\tif s[i] != t[j] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n}\nreturn true\n}"}
{"tgt": "qs := []question28{\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{2},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{5},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{-1},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans28, q.para28\n\tfmt.Printf(\"STR\", p, strStr(p.s, p.p))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question28{\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans28, q.para28\n\tfmt.Printf(\"STR\", p,STR)\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "digits := \"STR\"\nfor i := 1; i < 9999; i++ {\n\tnum := \"STR\"\n\tfor j := 1; j < 5; j++ {\n\t\tif len(num) < 9 {\n\t\t\tnum += strconv.Itoa(i * j)\n\t\t}\n\t}\n\tarr := strings.Split(num, \"STR\")\n\tsort.Strings(arr)\n\tnumSorted := strings.Join(arr, \"STR\")\n\tif numSorted == digits {\n\t\treturn num\n\t}\n}\nreturn \"STR\"", "gen": "for i := 1; i < 10000; i++ {\n\ts := \"STR\" + strconv.Itoa(i)\n\tss := strings.Split(s, \"STR\")\n\tsort.Strings(ss)\n\ts = strings.Join(ss, \"STR\")\n\tif s == \"STR\" {\n\t\treturn i\n\t}\n}\nreturn -1\n}"}
{"tgt": "obj := Constructor933()\nfmt.Printf(\"STR\", obj)\nparam1 := obj.Ping(1)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(100)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(3001)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(3002)\nfmt.Printf(\"STR\", param1)", "gen": "q := Constructor933()\nfmt.Printf(\"STR\", q)\nq.Ping(1)\nfmt.Printf(\"STR\", q.Ping(100))\nfmt.Printf(\"STR\", q.Ping(3001))\nfmt.Printf(\"STR\", q.Ping(3002))\n}"}
{"tgt": "root := new(*TreeNode)\ninsertArrayToTreeNode(root, array, 0)\nreturn *root", "gen": "var root *TreeNode\ninsertArrayToTreeNode(root, nums)\nreturn root\n}"}
{"tgt": "res := 0\nsort.Ints(houses)\nsort.Ints(heaters)\nm, n := len(houses), len(heaters)\nindex := sort.SearchInts(heaters, houses[0])\nfor _, house := range houses {\n\tfor index < n && house > heaters[index] {\n\t\tindex++\n\t}\n\tif index == n {\n\t\treturn max(res, houses[m-1]-heaters[index-1])\n\t}\n\tleft := math.MaxInt32\n\tif index > 0 {\n\t\tleft = house - heaters[index-1]\n\t}\n\tright := heaters[index] - house\n\tres = max(res, min(left, right))\n}\nreturn res", "gen": "sort.Ints(A)\nsort.Ints(B)\ni := sort.SearchInts(A, B[0])\nmax := A[i-1]\nmin := A[i]\nfor i < len(A) && i < len(B) {\n\tmax = max(max, A[i])\n\tmin = min(min, B[i])\n\ti++\n}\nif i < len(B) {\n\tmax = max(max, 2147483647)\n\tmin = min(min, B[i])\n}\nreturn max - min\n}"}
{"tgt": "c := Candidates(candidates)\nsort.Sort(c)\nreturn orderedCombinationSum2(c, target)", "gen": "c := Candidates{\n\tnums: nums,\n}\nsort.Sort(&c)\norderedCombinationSum2(nums, target, ret, &c)\nreturn ret\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tresults := HeapsAlgorithmRecursive(tc.input)\n\tpos := 0\n\tfor result := range results {\n\t\tif !reflect.DeepEqual(result, tc.expected[pos]) {\n\t\t\tt.Errorf(\"STR\", tc.expected[pos], result)\n\t\t}\n\t\tpos++\n\t}\n}", "gen": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := HeapsAlgorithmRecursive(tc.input); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}\n}"}
{"tgt": "for i := 1; i < len(nums); i++ {\n\tif nums[i-1] > nums[i] {\n\t\tpre := deepCopy(nums)\n\t\tpre[i-1] = pre[i]\n\t\tnext := deepCopy(nums)\n\t\tnext[i] = next[i-1]\n\t\treturn sort.IsSorted(sort.IntSlice(pre)) || sort.IsSorted(sort.IntSlice(next))\n\t}\n}\nreturn true", "gen": "for i := 1; i < len(nums); i++ {\n\tif nums[i] < nums[i-1] {\n\t\tnums[i], nums[i-1] = deepCopy(nums[i-1:]), deepCopy(nums[i:])\n\t\tif !sort.IsSorted(sort.IntSlice(nums)) {\n\t\t\treturn false\n\t\t}\n\t\tif !sort.IsSorted(sort.IntSlice(nums)) {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true\n}"}
{"tgt": "res := []int{}\nfor _, num := range nums {\n\tn := num\n\tif n < 0 {\n\t\tn *= -1\n\t}\n\tif nums[n-1] < 0 {\n\t\tres = append(res, n)\n\t} else {\n\t\tnums[n-1] *= -1\n\t}\n}\nreturn res", "gen": "res := []int{}\nfor _, num := range nums {\n\tif num < 0 {\n\t\tres = append(res, -num)\n\t}\n}\nreturn res\n}"}
{"tgt": "qs := []question1281{\n\t{\n\t\tpara1281{234},\n\t\tans1281{15},\n\t},\n\t{\n\t\tpara1281{4421},\n\t\tans1281{21},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1281, q.para1281\n\tfmt.Printf(\"STR\", p, subtractProductAndSum(p.n))\n}\nfmt.Printf(\"STR\")", "gen": "qs := []question1281{\n\t{\n\t\tpara1281{234, 15, 4421, 21},\n\t\tans1281{21},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.para, q.ans\n\tfmt.Printf(\"STR\", p, subtractProductAndSum(p.num1, p.num2, p.num3, p.num4))\n}\nfmt.Printf(\"STR\")\n}"}
{"tgt": "fp := float64(p)\nfa := float64(a)\nfb := (fp * (fp - 2.0*fa)) / (2.0 * (fp - fa))\nb = int(fb)\nvalid = math.Abs(fb-math.Floor(fb)) < 0.000001\nreturn", "gen": "x := float64(a)\ny := float64(b)\nz := x - y\nz = z * z\nz = x / z\nz = math.Floor(z)\nz = math.Abs(z - math.Floor(z))\nreturn int(z), z < 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}
{"tgt": "start := -1\nlenMax := 0\ndict := [256]int{}\nfor i := range dict {\n\tdict[i] = -1\n}\nfor i, r := range s {\n\tif v := dict[r]; v > start {\n\t\tstart = v\n\t}\n\tlength := i - start\n\tif length > lenMax {\n\t\tlenMax = length\n\t}\n\tdict[r] = i\n}\nreturn lenMax", "gen": "max := -1\nmin := 0\nfor i := 0; i < 256; i++ {\n\tdp[i] = -1\n}\nfor i := 0; i < len(s); i++ {\n\tif i < 0 || i > 255 {\n\t\tpanic(\"STR\")\n\t}\n\tdp[i] = -1\n}\nfor i, c := range s {\n\tif c < 0 || c > 127 {\n\t\tpanic(\"STR\")\n\t}\n\tif dp[i] < 0 {\n\t\tdp[i] = c\n\t}\n\tif dp[i] < c {\n\t\tmax = c\n\t}\n\tif c < min {\n\t\tmin = c\n\t}\n}\nreturn max - min\n}"}
{"tgt": "return &skipListNode{v: v, score: score, forwards: make([]*skipListNode, level, level), level: level}", "gen": "return &skipListNode{\n\tkey:   key,\n\tvalue: value,\n\tnext:  make([]*skipListNode, height),\n}\n}"}
{"tgt": "m := [26]int{}\nfor _, b := range B {\n\tcount := counter(b)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tm[i] = count[i]\n\t\t}\n\t}\n}\nres := []string{}\nfor _, a := range A {\n\tcount := counter(a)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tcontinueL\n\t\t}\n\t}\n\tres = append(res, a)\n}\nreturn res", "gen": "var res []string\nfor _, word := range words {\n\tcounter := counter(word)\n\tfor i := 0; i < len(word); i++ {\n\t\tif counter[i] == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tfor j := 0; j < len(word); j++ {\n\t\t\tif j == i {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif counter[j] == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tres = append(res, word[:i]+word[j:])\n\t\t}\n\t}\n}\nreturn res\n}"}
{"tgt": "bulls, cows := 0, 0\nnums := [10]int{}\nfor i := 0; i < len(secret); i++ {\n\ts, g := int(secret[i]-'0'), int(guess[i]-'0')\n\tif s == g {\n\t\tbulls++\n\t} else {\n\t\tif nums[s] < 0 {\n\t\t\tcows++\n\t\t}\n\t\tif nums[g] > 0 {\n\t\t\tcows++\n\t\t}\n\t\tnums[s]++\n\t\tnums[g]--\n\t}\n}\nreturn fmt.Sprintf(\"STR\", bulls, cows)", "gen": "count, count2 := 0, 0\nvar res []int\nfor i := 0; i < len(s); i++ {\n\tif s[i] == 'I' {\n\t\tcount++\n\t} else {\n\t\tcount2++\n\t}\n}\nreturn fmt.Sprintf(\"STR\", count, count2)\n}"}
{"tgt": "t.Parallel()\nfor _, l := range mathTestData {\n\tif log2Floor(l.n) != l.f || log2Ceil(l.n) != l.c {\n\t\tt.Errorf(\"STR\",\n\t\t\tl.n, l.f, l.c, log2Floor(l.n), log2Ceil(l.n))\n\t}\n}", "gen": "t.Parallel()\nfor _, test := range mathTestData {\n\tif log2Floor(test.n) != test.expected {\n\t\tt.Errorf(\"STR\", test.n, test.expected, log2Floor(test.n))\n\t}\n\tif log2Ceil(test.n) != test.expected {\n\t\tt.Errorf(\"STR\", test.n, test.expected, log2Ceil(test.n))\n\t}\n}\n}"}
{"tgt": "bs := strings.Builder{}\nvar dfs func(*TreeNode)\ndfs = func(node *TreeNode) {\n\tif node == nil {\n\t\treturn\n\t}\n\tbs.WriteString(strconv.Itoa(node.Val))\n\tif node.Left == nil && node.Right == nil {\n\t\treturn\n\t}\n\tbs.WriteByte('(')\n\tif node.Left != nil {\n\t\tdfs(node.Left)\n\t}\n\tbs.WriteByte(')')\n\tif node.Right != nil {\n\t\tbs.WriteByte('(')\n\t\tdfs(node.Right)\n\t\tbs.WriteByte(')')\n\t}\n}\ndfs(t)\nreturn bs.String()", "gen": "var res strings.Builder\nvar dfs func(root *TreeNode)\ndfs = func(root *TreeNode) {\n\tif root == nil {\n\t\treturn\n\t}\n\tres.WriteString(strconv.Itoa(root.Val))\n\tif root.Left != nil || root.Right != nil {\n\t\tres.WriteString(\"(\")\n\t\tdfs(root.Left)\n\t\tres.WriteString(\")\")\n\t}\n\tif root.Right != nil {\n\t\tres.WriteString(\"(\")\n\t\tdfs(root.Right)\n\t\tres.WriteString(\")\")\n\t}\n}\ndfs(root)\nreturn res.String()\n}"}
{"tgt": "return nil == root || isSame(root.Left, root.Right)", "gen": "return isSame(root, root)\n}"}
{"tgt": "cases := []struct {\n\tname      string\n\tflowerbed []int\n\tn         int\n\texpect    bool\n}{\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 1, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 2, false},\n\t{\"STR\", []int{1, 0, 1, 0}, 0, true},\n\t{\"STR\", []int{0}, 1, true},\n\t{\"STR\", []int{1, 0, 1, 0, 1, 0, 1}, 1, false},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.flowerbed, c.n)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.flowerbed, c.n)\n\t\t}\n\t})\n}", "gen": "cases := []struct {\n\tname   string\n\tflowerbed []int\n\tn       int\n\texpect  bool\n}{\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 1, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 2, false},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 3, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 4, false},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 5, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 6, false},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 7, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 8, false},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 9, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 10, false},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 11, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 12, false},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 13, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 14, false},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 15, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 16, false},\n\t{\"STR\", []int{1"}
{"tgt": "const maxDiv = 20\ni, div := maxDiv, maxDiv-1\nfor {\n\tif i%div == 0 {\n\t\tif div > 1 {\n\t\t\tdiv--\n\t\t} else {\n\t\t\tfmt.Println(i)\n\t\t\tos.Exit(0)\n\t\t}\n\t} else {\n\t\ti += maxDiv\n\t\tdiv = maxDiv - 1\n\t}\n}", "gen": "n, m := 20, 19\nfor m > 1 {\n\tif n%m == 0 {\n\t\tfmt.Println(n / m)\n\t\tos.Exit(0)\n\t}\n\tn += 20\n\tm--\n}\n}"}
