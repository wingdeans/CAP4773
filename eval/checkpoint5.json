{"tgt": "fmt.Println(mostCommonWord(\"STR\", []string{\"STR\", \"STR\"}))", "gen": "var words = []string{\"one\", \"two\", \"three\"}\nvar wordCount = make(map[string]int)\nfor _, word := range words {\n\twordCount[word]++\n}\nfmt.Println(mostCommonWord(wordCount))\n}\n"}
{"tgt": "if nil == nums || len(nums) == 0 {\n\treturn\n}\ninsertPos := 0\nfor _, values := range nums {\n\tif 0 != values {\n\t\tnums[insertPos] = values\n\t\tinsertPos++\n\t}\n}\nfor insertPos < len(nums) {\n\tnums[insertPos] = 0\n\tinsertPos++\n}", "gen": "var a [10]int\nvar b [10]int\nvar c int\nfor i := 0; i < len(a); i++ {\n\tif i < len(b) {\n\t\tc = b[i]\n\t}\n\tif i >= 0 {\n\t\ta[i] = c\n\t}\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "cases := []struct {\n\ta, b, expected int\n}{\n\t{\n\t\ta:        0,\n\t\tb:        0,\n\t\texpected: 0,\n\t},\n\t{\n\t\ta:        1,\n\t\tb:        1,\n\t\texpected: 1,\n\t},\n\t{\n\t\ta:        -1,\n\t\tb:        1,\n\t\texpected: -1,\n\t},\n\t{\n\t\ta:        1,\n\t\tb:        -1,\n\t\texpected: -1,\n\t},\n\t{\n\t\ta:        10,\n\t\tb:        2,\n\t\texpected: 2,\n\t},\n}\nfor _, c := range cases {\n\tactual := Min(c.a, c.b)\n\tif actual != c.expected {\n\t\tt.Errorf(\"STR\", c.expected, actual)\n\t}\n}", "gen": "var a [3][3]int\na[0][0] = 1\na[0][1] = 1\na[0][2] = 1\na[1][0] = -1\na[1][1] = 2\na[1][2] = 2\na[2][0] = -1\na[2][1] = -1\na[2][2] = 1\nvar b [2][2]int\nb[0][0] = 10\nb[0][1] = 2\nb[1][0] = 2\nb[1][1] = 2\nvar c [2]int\nc[0] = 5\nc[1] = 5\nvar d int\nd = 1\nfor i := 0; i < len(a); i++ {\n\tfor j := 0; j < len(a[i]); j++ {\n\t\tif a[i][j] < c[d] {\n\t\t\tc[d] = a[i][j]\n\t\t\tb[d][0] = i\n\t\t\tb[d][1] = j\n\t\t\td++\n\t\t\tif d == 2 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\nif c[0] < c[1] {\n\tfmt.Println(c[0], b[0][0], b[0][1])\n} else {\n\tfmt.Println(c[1], b[1][0], b[1][1])\n}\n}\n"}
{"tgt": "ma := 0\nif len(heights) < 0 {\n\treturn 0\n}\nvar stack []int\nfor i := 0; i < len(heights); i++ {\n\tif i == 0 {\n\t\tstack = append(stack, heights[i])\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tcontinue\n\t}\n\tif heights[i-1] > heights[i] {\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tstack = changeStack(stack, heights[i])\n\t}\n\tstack = append(stack, heights[i])\n\tif i+1 == len(heights) {\n\t\tm := maxArea(stack)\n\t\tma = max(m, ma)\n\t\tcontinue\n\t}\n}\nreturn ma", "gen": "var max int\nvar maxArea int\nvar i int\nvar j int\nvar height []int\nvar area int\nvar temp int\ni = 0\nfor {\n\tif i >= len(height) {\n\t\tbreak\n\t}\n\tif i == 0 {\n\t\tmax = maxArea\n\t\tmaxArea = area\n\t\ti++\n\t\tcontinue\n\t}\n\tif i > 0 {\n\t\tif height[i] > height[i-1] {\n\t\t\ttemp = maxArea\n\t\t\tmaxArea = area\n\t\t\tarea = temp\n\t\t} else {\n\t\t\ttemp = maxArea\n\t\t\tmaxArea = area\n\t\t\tarea = temp\n\t\t}\n\t}\n\tif i > 0 {\n\t\tif height[i] > height[i-1] {\n\t\t\ttemp = maxArea\n\t\t\tmaxArea = area\n\t\t\tarea = temp\n\t\t} else {\n\t\t\ttemp = maxArea\n\t\t\tmaxArea = area\n\t\t\tarea = temp\n\t\t}\n\t}\n\tif i > 0 {\n\t\tif height[i] > height[i-1] {\n\t\t\ttemp = maxArea\n\t\t\tmaxArea = area\n\t\t\tarea = temp\n\t\t} else {\n\t\t\ttemp = maxArea\n\t\t\tmaxArea = area\n\t\t\tarea = temp\n\t\t}\n\t}\n\tif i > 0 {\n\t\tif height[i] > height[i-1] {\n\t\t\ttemp = maxArea\n\t\t\tmaxArea = area\n\t\t\tarea = temp\n\t\t} else {\n\t\t\ttemp = maxArea\n\t\t\tmaxArea = area\n\t\t\tarea = temp\n\t\t}\n\t}\n\tif i > 0 {\n\t\tif height[i]"}
{"tgt": "min := func(a, b int) int {\n\treturn int(math.Min(float64(a), float64(b)))\n}\ndp := make([]int, 2)\ndp[0], dp[1] = cost[0], cost[1]\nfor i := 2; i < len(cost); i++ {\n\tdp[i%2] = cost[i] + min(dp[0], dp[1])\n}\nreturn min(dp[0], dp[1])", "gen": "fmt.Println(minCostClimbingStairs([]int{1, 100, 1, 1, 1, 100, 1, 1, 100, 1}))\n}\n"}
{"tgt": "temp, mask := num, 0\nfor temp > 0 {\n\tmask = mask*2 + 1\n\ttemp /= 2\n}\nreturn mask ^ num", "gen": "var a int\nvar b int\nfor b = 0; b < a; b++ {\n\ta = a + 1\n\ta = a >> 63\n\ta = a + b\n}\nreturn a\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "listNode1 := &ListNode{\n\tVal: 4,\n\tNext: &ListNode{\n\t\tVal: 1,\n\t\tNext: &ListNode{\n\t\t\tVal:  4,\n\t\t\tNext: nil,\n\t\t},\n\t},\n}\nlistNode2 := &ListNode{\n\tVal: 1,\n\tNext: &ListNode{\n\t\tVal: 8,\n\t\tNext: &ListNode{\n\t\t\tVal:  4,\n\t\t\tNext: nil,\n\t\t},\n\t},\n}\ngetIntersectionNode(listNode1, listNode2)", "gen": "headA := &ListNode{\n\tVal: 4,\n\tNext: &ListNode{\n\t\tVal: 1,\n\t\tNext: &ListNode{\n\t\t\tVal: 8,\n\t\t\tNext: &ListNode{\n\t\t\t\tVal: 4,\n\t\t\t\tNext: &ListNode{\n\t\t\t\t\tVal:  5,\n\t\t\t\t\tNext: nil,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n}\nheadB := &ListNode{\n\tVal: 5,\n\tNext: &ListNode{\n\t\tVal: 0,\n\t\tNext: &ListNode{\n\t\t\tVal: 1,\n\t\t\tNext: &ListNode{\n\t\t\t\tVal: 8,\n\t\t\t\tNext: &ListNode{\n\t\t\t\t\tVal:  4,\n\t\t\t\t\tNext: nil,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n}\nintersectionNode := getIntersectionNode(headA, headB)\nfmt.Println(intersectionNode.Val)\n}\n"}
{"tgt": "switch {\ncase isIPv4(IP):\n\treturn \"STR\"\ncase isIPv6(IP):\n\treturn \"STR\"\ndefault:\n\treturn \"STR\"\n}", "gen": "fmt.Println(isIPv4(\"172.16.254.1\"))\nfmt.Println(isIPv4(\"255.255.255.255\"))\nfmt.Println(isIPv4(\"172.16.254.1.1\"))\nfmt.Println(isIPv4(\"172.16.254.1.1.1\"))\nfmt.Println(isIPv4(\"172.16.254.1.1.1.1\"))\nfmt.Println(isIPv4(\"172.16.254.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"172.16.254.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"172.16.254.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"172.16.254.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"172.16.254.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"172.16.254.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"172.16.254.1.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"172.16.254.1.1.1.1.1.1.1.1.1.1.1.1\"))\nfmt.Println(isIPv4(\"172.16.254.1.1.1.1.1.1.1.1.1."}
{"tgt": "l := len(preorder)\nif l == 0 {\n\treturn nil\n}\nfor 1 < l && preorder[0] < preorder[l-1] {\n\tl--\n}\nreturn &TreeNode{\n\tVal:   preorder[0],\n\tLeft:  bstFromPreorder(preorder[1:l]),\n\tRight: bstFromPreorder(preorder[l:]),\n}", "gen": "preorder := []int{8, 5, 1, 7, 10, 12}\nroot := bstFromPreorder(preorder)\nfmt.Println(root)\n}\n"}
{"tgt": "sort.Slice(costs, func(i, j int) bool {\n\treturn abs(costs[i][0]-costs[i][1]) > abs(costs[j][0]-costs[j][1])\n})\ncost, a, b, n := 0, 0, 0, len(costs)/2\nfor _, c := range costs {\n\tif (c[0] < c[1] && a < n) || b == n {\n\t\tcost += c[0]\n\t\ta++\n\t} else {\n\t\tcost += c[1]\n\t\tb++\n\t}\n}\nreturn cost", "gen": "var costs = [][]int{\n\t{10, 20}, {30, 200}, {400, 50}, {30, 20},\n}\nfmt.Println(twoCitySchedCost(costs))\n}\n"}
{"tgt": "println(\"STR\")\nprintln(\"STR\", v1)\nprintln(\"STR\", v2.x, v2.y)\nprintln(\"STR\", len(v3), cap(v3), v3[0], v3[3])\nprintln(\"STR\", len(v4), v4 == nil)\nprintln(\"STR\", len(v5), v5 == nil)\nprintln(\"STR\", v6)\nprintln(\"STR\", cap(v7), string(v7))\nprintln(uint8SliceSrc[0])\nprintln(uint8SliceDst[0])\nprintln(intSliceSrc[0])\nprintln(intSliceDst[0])", "gen": "printlock()\nprintstring(\"v1: \")\nprintint(v1)\nprintnl()\nprintunlock()\nprintlock()\nprintstring(\"v2: \")\nprintint(v2)\nprintsp()\nprintint(v2[1])\nprintnl()\nprintunlock()\nprintlock()\nprintstring(\"v3: \")\nprintint(v3[0])\nprintsp()\nprintint(v3[1])\nprintsp()\nprintint(v3[2])\nprintnl()\nprintunlock()\nprintlock()\nprintstring(\"v4: \")\nprintint(v4[0])\nprintsp()\nprintbool(v4[0] == 0)\nprintnl()\nprintunlock()\nprintlock()\nprintstring(\"v5: \")\nprintint(v5[0])\nprintsp()\nprintbool(v5[0] == 0)\nprintnl()\nprintunlock()\nprintlock()\nprintstring(\"v6: \")\nprintbool(v6 == 0)\nprintnl()\nprintunlock()\nprintlock()\nprintstring(\"v7: \")\nprintint(v7[0])\nprintsp()\nprintint(v7[1])\nprintsp()\nprintint(v7[2])\nprintnl()\nprintunlock()\nprintlock()\nprintstring(\"uint8SliceSrc: \")\nprintuint(uint8SliceSrc[0])\nprintnl()\nprintunlock()\nprintlock()\nprintstring(\"uint8SliceDst: \")\nprintuint(uint8SliceDst[0])\nprintnl()\nprintunlock()\nprintlock()\nprintstring(\"intSliceSrc: \")\nprintint(intSliceSrc[0])\nprintnl()\nprintunlock()\nprintlock()\nprintstring(\"intSliceDst: \")\n"}
{"tgt": "words := strings.Fields(s)\nreturn strings.Join(reverseSlice(words), \"STR\")", "gen": "s := \"hello world\"\nfields := strings.Fields(s)\nreversed := reverseSlice(fields)\nresult := strings.Join(reversed, \" \")\nfmt.Println(result)\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect bool\n}{\n\t{\"STR\", []int{1, 2, 2, 3}, true},\n\t{\"STR\", []int{4, 3, 3, 2}, true},\n\t{\"STR\", []int{1, 3, 2}, false},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.TestSolution()\n}\n"}
{"tgt": "indexs := make([]int, 123)\nfor i, c := range order {\n\tindexs[c] = i\n}\nless := func(i, j int) bool {\n\tsi, sj := len(words[i]), len(words[j])\n\tfor k := 0; k < si && k < sj; k++ {\n\t\tii, ij := indexs[words[i][k]], indexs[words[j][k]]\n\t\tswitch {\n\t\tcase ii < ij:\n\t\t\treturn true\n\t\tcase ii > ij:\n\t\t\treturn false\n\t\t}\n\t}\n\treturn si <= sj\n}\nfor i := 1; i < len(words); i++ {\n\tif !less(i-1, i) {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var s1, s2 string\nfmt.Scan(&s1, &s2)\nif isAlienSorted(s1, s2) {\n\tfmt.Println(\"Yes\")\n} else {\n\tfmt.Println(\"No\")\n}\n}\n"}
{"tgt": "row := len(grid)\ncol := len(grid[0])\ndp := make([][]int, row)\nfor i := 0; i < row; i++ {\n\tdp[i] = make([]int, col)\n}\ndp[0][0] = grid[0][0]\nfor i := 1; i < row; i++ {\n\tdp[i][0] = dp[i-1][0] + grid[i][0]\n}\nfor i := 1; i < col; i++ {\n\tdp[0][i] = dp[0][i-1] + grid[0][i]\n}\nfor i := 1; i < row; i++ {\n\tfor j := 1; j < col; j++ {\n\t\tdp[i][j] = Min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\t}\n}\nreturn dp[row-1][col-1]", "gen": "var a []int\nvar b []int\nvar c []int\nvar d []int\nvar e []int\nvar f []int\nvar g []int\nvar h []int\nvar i []int\nvar j []int\nvar k []int\nvar l []int\nvar m []int\nvar n []int\nvar o []int\nvar p []int\nvar q []int\nvar r []int\nvar s []int\nvar t []int\nvar u []int\nvar v []int\nvar w []int\nvar x []int\nvar y []int\nvar z []int\nvar aa []int\nvar bb []int\nvar cc []int\nvar dd []int\nvar ee []int\nvar ff []int\nvar gg []int\nvar hh []int\nvar ii []int\nvar jj []int\nvar kk []int\nvar ll []int\nvar mm []int\nvar nn []int\nvar oo []int\nvar pp []int\nvar qq []int\nvar rr []int\nvar ss []int\nvar tt []int\nvar uu []int\nvar vv []int\nvar ww []int\nvar xx []int\nvar yy []int\nvar zz []int\nvar aaa []int\nvar bbb []int\nvar ccc []int\nvar ddd []int\nvar eee []int\nvar fff []int\nvar ggg []int\nvar hhh []int\nvar iii []int\nvar jjj []int\nvar kkk []int\nvar lll []int\nvar mmm []int\nvar nnn []int\nvar ooo []int\nvar ppp []int\nvar qqq []int\nvar rrr []int\nvar sss []int\nvar ttt []int\nvar uuu []int\nvar vvv []int\nvar www []int\nvar xxx []int\nvar yyy"}
{"tgt": "fmt.Fprint(w, \"STR\")", "gen": "fmt.Println(1)\n}\n"}
{"tgt": "l := len(nums)\nk %= l\ns := make([]int, l)\ncopy(s, nums)\nfor i, v := range s[l-k:] {\n\tnums[i] = v\n}\nfor i, v := range s[:l-k] {\n\tnums[k+i] = v\n}", "gen": "var a []int\nvar b int\na = append(a, 1)\nb = a[0]\nreturn\n}\n"}
{"tgt": "if p == nil || q == nil {\n\treturn p == q\n}\nreturn isSameTree(p.Left, q.Left) && p.Val == q.Val && isSameTree(p.Right, q.Right)", "gen": "root1 := &TreeNode{Val: 1}\nroot1.Left = &TreeNode{Val: 2}\nroot1.Right = &TreeNode{Val: 3}\nroot2 := &TreeNode{Val: 1}\nroot2.Left = &TreeNode{Val: 2}\nroot2.Right = &TreeNode{Val: 3}\nif isSameTree(root1, root2) {\n\tfmt.Println(\"true\")\n} else {\n\tfmt.Println(\"false\")\n}\n}\n"}
{"tgt": "for cur := t.root; cur != nil; {\n\tif cur.Key == key {\n\t\treturn cur\n\t} else if key < cur.Key {\n\t\tcur = cur.left\n\t} else {\n\t\tcur = cur.right\n\t}\n}\nreturn nil", "gen": "var root *binaryTree.BSTElement\nvar element *binaryTree.BSTElement\nvar found *binaryTree.BSTElement\nroot = nil\nelement = &binaryTree.BSTElement{\n\tValue: 10,\n\tLeft:  nil,\n\tRight: nil,\n}\nroot = element\nelement = &binaryTree.BSTElement{\n\tValue: 5,\n\tLeft:  nil,\n\tRight: nil,\n}\nroot.Left = element\nelement = &binaryTree.BSTElement{\n\tValue: 15,\n\tLeft:  nil,\n\tRight: nil,\n}\nroot.Right = element\nelement = &binaryTree.BSTElement{\n\tValue: 20,\n\tLeft:  nil,\n\tRight: nil,\n}\nroot.Right.Right = element\nelement = &binaryTree.BSTElement{\n\tValue: 25,\n\tLeft:  nil,\n\tRight: nil,\n}\nroot.Right.Right.Right = element\nelement = &binaryTree.BSTElement{\n\tValue: 30,\n\tLeft:  nil,\n\tRight: nil,\n}\nroot.Right.Right.Right.Right = element\nelement = &binaryTree.BSTElement{\n\tValue: 35,\n\tLeft:  nil,\n\tRight: nil,\n}\nroot.Right.Right.Right.Right.Right = element\nelement = &binaryTree.BSTElement{\n\tValue: 40,\n\tLeft:  nil,\n\tRight: nil,\n}\nroot.Right.Right.Right.Right.Right.Right = element\nelement = &binaryTree.BSTElement{\n\tValue: 45,\n\tLeft:  nil,\n\tRight: nil,\n}\nroot.Right.Right.Right.Right.Right.Right.Right = element\nelement = &binaryTree.BST"}
{"tgt": "s := []int{}\nfor _, asteroid := range asteroids {\n\tfor len(s) != 0 && s[len(s)-1] > 0 && s[len(s)-1] < -asteroid {\n\t\ts = s[:len(s)-1]\n\t}\n\tif len(s) == 0 || asteroid > 0 || s[len(s)-1] < 0 {\n\t\ts = append(s, asteroid)\n\t} else if asteroid < 0 && s[len(s)-1] == -asteroid {\n\t\ts = s[:len(s)-1]\n\t}\n}\nreturn s", "gen": "var a [3]int\nfor i := 0; i < len(a); i++ {\n\ta[i] = i\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "sum := 0\nsunday := 5\nyear := 1901\nis_leap := false\nfor year < 2001 {\n\tchecker := month_len\n\tif is_leap {\n\t\tchecker = leap_len\n\t}\n\ttally := sunday\n\tfor _, v := range checker {\n\t\tif tally == 0 {\n\t\t\tsum += 1\n\t\t}\n\t\tif tally < v {\n\t\t\tbreak\n\t\t}\n\t\tif tally >= v {\n\t\t\ttally -= v\n\t\t}\n\t}\n\tsunday += 7\n\tif is_leap && sunday >= 366 {\n\t\tyear++\n\t\tsunday = sunday % 366\n\t\tis_leap = false\n\t} else if !is_leap && sunday >= 365 {\n\t\tyear++\n\t\tsunday = sunday % 365\n\t\tif year%4 == 0 {\n\t\t\tis_leap = true\n\t\t}\n\t}\n}\nfmt.Printf(\"STR\", year, sum)", "gen": "var month_len [12]int\nvar leap_len [12]int\nmonth_len[0] = 31\nmonth_len[1] = 28\nmonth_len[2] = 31\nmonth_len[3] = 30\nmonth_len[4] = 31\nmonth_len[5] = 30\nmonth_len[6] = 31\nmonth_len[7] = 31\nmonth_len[8] = 30\nmonth_len[9] = 31\nmonth_len[10] = 30\nmonth_len[11] = 31\nleap_len[0] = 31\nleap_len[1] = 29\nleap_len[2] = 31\nleap_len[3] = 30\nleap_len[4] = 31\nleap_len[5] = 30\nleap_len[6] = 31\nleap_len[7] = 31\nleap_len[8] = 30\nleap_len[9] = 31\nleap_len[10] = 30\nleap_len[11] = 31\nvar month int\nmonth = 0\nfor month < 12 {\n\tvar day int\n\tday = 0\n\tfor day < month_len[month] {\n\t\tif month == 2 {\n\t\t\tif day == 28 {\n\t\t\t\tday = day + 1\n\t\t\t\tmonth = month + 1\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tday = day + 1\n\t}\n\tif day == 365 {\n\t\tday = day + 1\n\t\tmonth = month + 1\n\t\tcontinue\n\t}\n\tif day == 366"}
{"tgt": "max, winner := 0, 0\nfor i := 1; i < 1000000; i++ {\n\tterms := collatz(i)\n\tif terms > max {\n\t\tmax = terms\n\t\twinner = i\n\t}\n}\nfmt.Println(\"STR\", max, \"STR\", winner)", "gen": "var max, n int\nfor n = 1; n <= 999999; n++ {\n\tif collatz(n) > max {\n\t\tmax = collatz(n)\n\t}\n}\nfmt.Println(max)\n}"}
{"tgt": "return fmt.Sprintf(\"STR\", c.FirstName, c.LastName, c.Email)", "gen": "var s1, s2, s3 string\ns1 = \"hello\"\ns2 = \"world\"\ns3 = \"!\"\nfmt.Printf(\"%s %s %s\\n\", s1, s2, s3)\n}\n"}
{"tgt": "e.lgu = lgu\ne.mixin = mixin\ne.cluster = make(map[interface{}]*rsVEBTreeElement)\nif e.lgu > 1 {\n\te.summaryLgu = (e.lgu + 1) / 2\n\te.clusterLgu = e.lgu - e.summaryLgu\n\te.summary = new(rsVEBTreeElement).init(e.summaryLgu, e.mixin)\n} else {\n\te.summaryLgu = 0\n\te.clusterLgu = 0\n}\nreturn e", "gen": "var t *vEBTree\nt = new(vEBTree)\nt.root = nil\nt.size = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.root = nil\nt.size = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.root = nil\nt.size = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.root = nil\nt.size = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.root = nil\nt.size = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.root = nil\nt.size = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.root = nil\nt.size = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.root = nil\nt.size = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.root = nil\nt.size = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.maxLevel = 0\nt.minLevel = 0\nt.root = nil\nt.size = 0\nt.maxLevel = 0"}
{"tgt": "if isValid := checkHorizontal(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkVertical(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkReachable(puzzle); !isValid {\n\treturn false\n}\nif isValid := checkRotationallySymmetric(puzzle); !isValid {\n\treturn false\n}\nreturn true", "gen": "if checkHorizontal(3, 3, 3) == 0 {\n\treturn\n}\nif checkVertical(3, 3, 3) == 0 {\n\treturn\n}\nif checkReachable(3, 3, 3) == 0 {\n\treturn\n}\nif checkRotationallySymmetric(3, 3, 3) == 0 {\n\treturn\n}\nfmt.Println(\"All tests passed!\")\n}\n"}
{"tgt": "b.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})\nb.Run(\"STR\", func(b *testing.B) {\n\tb.ResetTimer()\n\tgot := multiply(\"STR\", \"STR\")\n\twant := \"STR\"\n\tif got != want {\n\t\tb.Error(\"STR\")\n\t}\n})", "gen": "b := testing.B{}\nb.Run(\"func"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := SumRevLLNum(tc.first, tc.second); !equal(result, tc.sum) {\n\t\tt.Errorf(\"STR\",\n\t\t\ttcid, String(result), String(tc.sum))\n\t}\n}", "gen": "testing.MainStart(test.Benchmark, nil, nil, nil)\n}\n"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA `structs:\"STR\"`\n\tC  int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif ok {\n\tt.Error(\"STR\")\n}", "gen": "var a TestHasZero_OmitNested\na.B.i1.d = 123\nif !reflect.DeepEqual(a, TestHasZero_OmitNested{}) {\n\tt.Error(\"a should be zero\")\n}\n}\n\n// TestHasZero_OmitNested_B_i1_d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d\n// B.i1.d"}
{"tgt": "nums := []int{1, 1, 2, 2, 3, 3}\nfmt.Println(distributeCandies(nums))\nnums2 := []int{1, 1, 2, 3}\nfmt.Println(distributeCandies(nums2))", "gen": "distributeCandies(1, 1, 2, 2, 3, 3)\nfmt.Println(distributeCandies(6, 6))\nfmt.Println(distributeCandies(4, 4))\n}\n"}
{"tgt": "i, j := start, len(nums)-1\nfor i < j {\n\tnums[i], nums[j] = nums[j], nums[i]\n\ti++\n\tj--\n}", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nfor i := 0; i < len(a); i++ {\n\ta[i] = i\n}\nfor i := 0; i < len(b); i++ {\n\tb[i] = i\n}\nfor i := 0; i < len(c); i++ {\n\tc[i] = i\n}\nfor i := 0; i < len(d); i++ {\n\td[i] = i\n}\nfor i := 0; i < len(e); i++ {\n\te[i] = i\n}\nfor i := 0; i < len(f); i++ {\n\tf[i] = i\n}\nfor i := 0; i < len(g); i++ {\n\tg[i] = i\n}\nfor i := 0; i < len(h); i++ {\n\th[i] = i\n}\nfor i := 0; i < len(i); i++ {\n\ti[i] = i\n}\nfor i := 0; i < len(j); i++ {\n\tj[i] = i\n}\nfor"}
{"tgt": "var val int\nfor n := uint(0); num != 0; num >>= 1 {\n\tval |= (1 - (num & 1)) << n\n\tn++\n}\nreturn val", "gen": "var n int\nfor i := 0; i < 64; i++ {\n\tif n&1 == 1 {\n\t\tn |= 1 << i\n\t}\n\tn >>= 1\n}\nreturn n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "size := len(A)\nres := make([]int, size)\neven, odd := 0, 1\nfor _, a := range A {\n\tif a%2 == 0 {\n\t\tres[even] = a\n\t\teven += 2\n\t} else {\n\t\tres[odd] = a\n\t\todd += 2\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b []int\nfor i := 0; i < 2; i++ {\n\tif i == 0 {\n\t\tb = append(b, a[i])\n\t} else {\n\t\tb = append(b, a[i])\n\t}\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "slow, fast := head, head\nfor fast != nil && fast.Next != nil {\n\tslow = slow.Next\n\tfast = fast.Next.Next\n}\nvar prev *ListNode\nfor slow != nil {\n\tnext := slow.Next\n\tslow.Next = prev\n\tprev, slow = slow, next\n}\nfor p, q := head, prev; p != q; p, q = q, p {\n\tnext := p.Next\n\tp.Next = q\n\tp = next\n}", "gen": "var a, b int\nfor {\n\tif a == 0 {\n\t\tbreak\n\t}\n\ta, b = b, a+b\n}\nprintln(b)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for _, p := range perm6([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) {\n\tvalid := true\n\tfor _, g := range guesses {\n\t\tvar count int\n\t\tfor i := 0; i < len(p); i++ {\n\t\t\tif p[i] == g.Code[i] {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\tif count != g.Score {\n\t\t\tvalid = false\n\t\t\tbreak\n\t\t}\n\t}\n\tif valid {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar bb [10]int\nvar cc [10]int\nvar dd [10]int\nvar ee [10]int\nvar ff [10]int\nvar gg [10]int\nvar hh [10]int\nvar ii [10]int\nvar jj [10]int\nvar kk [10]int\nvar ll [10]int\nvar mm [10]int\nvar nn [10]int\nvar oo [10]int\nvar pp [10]int\nvar qq [10]int\nvar rr [10]int\nvar ss [10]int\nvar tt [10]int\nvar uu [10]int\nvar vv [10]int\nvar ww [10]int\nvar xx [10]int\nvar yy [10]int\nvar zz [10]int\nfor i := 0; i < 10; i++ {\n"}
{"tgt": "for i := 0; i < 100000; i++ {\n\tif i%300 == 0 {\n\t\tarray := GetArrayOfSize(i)\n\t\tif len(array) != i {\n\t\t\tfmt.Println(array)\n\t\t\tt.Error()\n\t\t}\n\t}\n}", "gen": "for i := 0; i < 100000; i++ {\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak\n\t}\n\tif i == 99999 {\n\t\tbreak"}
{"tgt": "parent := this\nfor _, ch := range prefix {\n\tif child, ok := parent.Children[ch]; ok {\n\t\tparent = child\n\t\tcontinue\n\t}\n\treturn false\n}\nreturn true", "gen": "var s = Solution{}\nvar trie = s.Trie{}\nvar str = \"leetcode\"\nvar strs = []string{\"leetcode\", \"leetcodeleet\", \"leetcodeleetcode\"}\nvar res = s.FindMaxForm(str, strs)\nfmt.Println(res)\n}\n"}
{"tgt": "sema <- struct{}{}\nb := balance\n<-sema\nreturn b", "gen": "var balance int\nvar sema chan int\nsema = make(chan int)\ngo func() {\n\tbalance = <-sema\n}()\nbalance = <-sema\n}\n"}
{"tgt": "pairs := [...][2]int{{10, 7}, {1000, 983}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p26(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var a, b int\na = 10\nb = 7\nvar c, d int\nc = 1000\nd = 983\nvar e, f int\ne = 2\nfor i := 0; i < 2; i++ {\n\tif i == 1 {\n\t\tbreak\n\t}\n\tvar g, h int\n\tg = 0\n\th = 0\n\tvar j, k int\n\tj = a\n\tk = b\n\tvar l, m int\n\tl = c\n\tm = d\n\tvar n, o int\n\tn = e\n\to = f\n\tvar p, q interface{}\n\tp = g\n\tq = h\n\tvar r, s interface{}\n\tr = j\n\ts = k\n\tvar t, u interface{}\n\tt = l\n\tu = m\n\tvar v, w interface{}\n\tv = n\n\tw = o\n\tif i == 1 {\n\t\tbreak\n\t}\n\tif i == 1 {\n\t\tbreak\n\t}\n\tif i == 1 {\n\t\tbreak\n\t}\n\tif i == 1 {\n\t\tbreak\n\t}\n\tif i == 1 {\n\t\tbreak\n\t}\n\tif i == 1 {\n\t\tbreak\n\t}\n\tif i == 1 {\n\t\tbreak\n\t}\n\tif i == 1 {\n\t\tbreak\n\t}\n\tif i == 1 {\n\t\tbreak\n\t}\n\tif i == 1 {\n\t\tbreak\n\t}\n\tif i == 1 {\n\t\tbreak\n\t}\n\tif i == 1 {\n\t\tbreak\n\t}\n\tif i == 1 {\n\t\tbreak\n\t}\n\tif i == 1 {\n"}
{"tgt": "for i := 0; i < n; i++ {\n\tif len(squares) != i {\n\t\tprintln(\"STR\", len(squares), \"STR\", i)\n\t}\n\tsquares[i] = i * i\n\tfor j := 0; j <= i; j++ {\n\t\tif v, ok := squares[j]; !ok || v != j*j {\n\t\t\tif !ok {\n\t\t\t\tprintln(\"STR\", j)\n\t\t\t} else {\n\t\t\t\tprintln(\"STR\", j, v)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "var m map[int][2]int\nfor i := 0; i < 10; i++ {\n\tif _, ok := m[i]; !ok {\n\t\tm[i] = [2]int{i, i}\n\t}\n}\n}\n"}
{"tgt": "for _, word := range words {\n\tremainNum[word] = 0\n}\nfor _, word := range words {\n\tremainNum[word]++\n}\nreturn 0", "gen": "m := make(map[string]int)\nfor i := 0; i < 10; i++ {\n\tm[strconv.Itoa(i)] = i\n}\nfor i := 0; i < 10; i++ {\n\tm[strconv.Itoa(i)]++\n}\n}\n"}
{"tgt": "ad := admin{\n\tuser: user{\n\t\tname:  \"STR\",\n\t\temail: \"STR\",\n\t},\n\tlevel: \"STR\",\n}\nad.user.notify()\nad.notify()", "gen": "user.notify(10, \"hello\")\nadmin.notify(14, \"world\")\n}\n"}
{"tgt": "if !ok {\n\tpanic(\"STR\")\n}", "gen": "if 1 == 0 {\n\tpanic(\"go\")\n}\n}\n"}
{"tgt": "sum := 0\nprev := 1\ncurr := 1\nfor curr <= 4e6 {\n\tprev, curr = curr, prev+curr\n\tif curr%2 == 0 {\n\t\tsum += curr\n\t}\n}\nfmt.Println(sum)", "gen": "var a, b int\na = 1\nb = 1\nfor i := 1; i < 4000000; i++ {\n\tif i%2 == 0 {\n\t\ta += b\n\t} else {\n\t\ta = a + b\n\t}\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "dist := func(i int) int {\n\tx, y := points[i][0], points[i][1]\n\treturn x*x + y*y\n}\npartition := func(l, r int) int {\n\tpivot, pdist := l, dist(l)\n\tpoints[pivot], points[r] = points[r], points[pivot]\n\tdivider := l\n\tfor i := l; i < r; i++ {\n\t\tif dist(i) < pdist {\n\t\t\tpoints[i], points[divider] = points[divider], points[i]\n\t\t\tdivider++\n\t\t}\n\t}\n\tpoints[divider], points[r] = points[r], points[divider]\n\treturn divider\n}\nl, r := 0, len(points)-1\nfor l < r {\n\ti := partition(l, r)\n\tif i == K {\n\t\tbreak\n\t} else if i > K {\n\t\tr = i - 1\n\t} else {\n\t\tl = i + 1\n\t}\n}\nreturn points[:K]", "gen": "nums := []int{1, 2, 3, 4, 5}\nk := 4\nfmt.Println(kClosest(nums, k))\n}\n"}
{"tgt": "if c < 0 {\n\treturn false\n}\nl, r := 0, mySqrt(c)\nfor l <= r {\n\tcur := l*l + r*r\n\tif cur < c {\n\t\tl++\n\t} else if cur > c {\n\t\tr--\n\t} else {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "fmt.Println(mySqrt(8))\n}\n"}
{"tgt": "n := len(edges)\nparent := make([]int, n+1)\nfor i := 0; i < n; i++ {\n\tparent[i] = i\n}\nvar i int\nvar e []int\nfor i, e = range edges {\n\tf, t := e[0], e[1]\n\tpf := find(parent, f)\n\tpt := find(parent, t)\n\tif pf == pt {\n\t\tbreak\n\t}\n\tparent[pf] = pt\n}\nreturn edges[i]", "gen": "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nb := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nc := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nd := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nfind(a, b, c, d)\n}"}
{"tgt": "var bin strings.Builder\nfor head != nil {\n\tbin.WriteString(strconv.Itoa(head.Val))\n\thead = head.Next\n}\ni, _ := strconv.ParseInt(bin.String(), 2, 64)\nreturn int(i)", "gen": "var s string\nvar i int\nfor {\n\tif s == \"\" {\n\t\tbreak\n\t}\n\ts = s[1:]\n\ti, _ = strconv.Atoi(s)\n\ts = strconv.Itoa(i)\n\ts = strings.Builder{}.WriteString(s).String()\n\ts = strconv.ParseInt(s, 10, 64)\n\ti, s = s, i\n}\ni = int(s)\nreturn i\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if n == 0 {\n\treturn 0\n}\nreturn n/5 + trailingZeroes(n/5)", "gen": "fmt.Println(trailingZeroes(10))\n}\n"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tpuzzle := make([][]rune, len(tc.puzzle))\n\tfor i := range puzzle {\n\t\tpuzzle[i] = []rune(tc.puzzle[i])\n\t}\n\tif result := FindWordLD(puzzle, []rune(tc.target)); result != tc.expected {\n\t\tt.Errorf(\"STR\", tcid, tc.expected, result)\n\t}\n}", "gen": "testing.Init()\nos.Exit(m.Run())\n}"}
{"tgt": "start := 0\nend := len(s) - 1\nfor start < end {\n\ts[start], s[end] = s[end], s[start]\n\tstart++\n\tend--\n}\nreturn s", "gen": "var a [3]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if m == 0 {\n\treturn 1\n}\nswitch n {\ncase 1:\n\treturn 2\ncase 2:\n\tif m == 1 {\n\t\treturn 3\n\t}\n\treturn 4\ndefault:\n\tswitch m {\n\tcase 1:\n\t\treturn 4\n\tcase 2:\n\t\treturn 7\n\tdefault:\n\t\treturn 8\n\t}\n}", "gen": "var a int\nvar b int\nif a == 0 {\n\ta = 1\n} else if a == 1 {\n\ta = 2\n} else if a == 2 {\n\ta = 3\n} else {\n\ta = 4\n}\nif b == 0 {\n\tb = 1\n} else if b == 1 {\n\tb = 2\n} else if b == 2 {\n\tb = 3\n} else {\n\tb = 4\n}\nif a == 1 {\n\ta = 2\n} else if a == 2 {\n\ta = 3\n} else if a == 3 {\n\ta = 4\n} else {\n\ta = 5\n}\nif b == 1 {\n\tb = 2\n} else if b == 2 {\n\tb = 3\n} else if b == 3 {\n\tb = 4\n} else {\n\tb = 5\n}\nif a == 2 {\n\ta = 3\n} else if a == 3 {\n\ta = 4\n} else if a == 4 {\n\ta = 5\n} else {\n\ta = 6\n}\nif b == 2 {\n\tb = 3\n} else if b == 3 {\n\tb = 4\n} else if b == 4 {\n\tb = 5\n} else {\n\tb = 6\n}\nif a == 3 {\n\ta = 4\n} else if a == 4 {\n\ta = 5\n} else if a == 5 {\n\ta = 6\n} else {\n\ta = 7\n}\nif b == 3 {\n\tb = 4\n} else if b == 4 {\n\tb = 5\n} else if b == 5 {\n"}
{"tgt": "last, n := 0, len(s)\nfor i := 1; i < n; i++ {\n\tif s[i-1] == s[i] {\n\t\tcontinue\n\t}\n\tfor l := 0; i+l < n; l++ {\n\t\tif s[last+l] < s[i+l] {\n\t\t\tlast = i\n\t\t\tbreak\n\t\t}\n\t\tif s[last+l] > s[i+l] {\n\t\t\tbreak\n\t\t}\n\t}\n}\nreturn s[last:]", "gen": "var a [2]int\nvar b [2]int\nvar c int\nvar d int\nfor i := 0; i < len(a); i++ {\n\tif i < len(b) {\n\t\tif a[i] < b[i] {\n\t\t\tc = i\n\t\t\td = a[i]\n\t\t} else if a[i] > b[i] {\n\t\t\tc = i\n\t\t\td = b[i]\n\t\t}\n\t} else {\n\t\tif a[i] < b[i] {\n\t\t\tc = i\n\t\t\td = a[i]\n\t\t} else if a[i] > b[i] {\n\t\t\tc = i\n\t\t\td = b[i]\n\t\t}\n\t}\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "fmt.Println(checkPerfectNumber(6))\nfmt.Println(checkPerfectNumber(28))\nfmt.Println(checkPerfectNumber(30))", "gen": "checkPerfectNumber(6)\nfmt.Println(checkPerfectNumber(28))\nfmt.Println(checkPerfectNumber(30))\n}\n"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := EqualWithShifting(tc.A, tc.B); result != tc.expected {\n\t\tt.Errorf(\"STR\", tcid, tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "s = strings.TrimSpace(s)\n_, err := strconv.ParseFloat(s, 64)\nreturn err == nil || err.(*strconv.NumError).Err != strconv.ErrSyntax", "gen": "s := \"123.456\"\nf, err := strconv.ParseFloat(strings.TrimSpace(s), 64)\nif err != nil {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n\tpanic(err)\n}\nif f == 0 {\n"}
{"tgt": "qs := []question76{\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n\t{\n\t\tpara76{\"STR\", \"STR\"},\n\t\tans76{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans76, q.para76\n\tfmt.Printf(\"STR\", p, minWindow(p.s, p.p))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world!\")\nreturn\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums1  []int\n\tnums2  []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 2, 3, 2, 1}, []int{3, 2, 1, 4, 7}, 3},\n\t{\"STR\", []int{0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0}, 5},\n\t{\"STR\", []int{0, 0, 0, 0, 1}, []int{1, 0, 0, 0, 0}, 4},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums1, c.nums2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums1, c.nums2)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.nums1 = []int{1, 2, 3, 4}\nsolution.nums2 = []int{2, 3, 4}\nsolution.expect = 3\nsolution.name = \"Test1\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{1, 2}\nsolution.nums2 = []int{1, 2}\nsolution.expect = 3\nsolution.name = \"Test2\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{1, 2}\nsolution.nums2 = []int{3}\nsolution.expect = 0\nsolution.name = \"Test3\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{2, 3, 4}\nsolution.nums2 = []int{1, 2}\nsolution.expect = 3\nsolution.name = \"Test4\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{1, 2, 3, 4}\nsolution.nums2 = []int{1, 2, 3, 4}\nsolution.expect = 7\nsolution.name = \"Test5\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{1, 2, 3, 4}\nsolution.nums2 = []int{1, 2, 3, 4}\nsolution.expect = 1\nsolution.name = \"Test6\"\nsolution.TestSolution()\n\nsolution.nums1 = []int{1, 2, 3, 4}\nsolution.nums2 = []int{1, 2, 3, 4}\nsolution.expect = 1\nsolution.name = \"Test7\"\nsolution.TestSolution()\n\n"}
{"tgt": "return strings.ReplaceAll(r.element.Name, \"STR\", \"\")", "gen": "s := \"hello\"\ns = strings.ReplaceAll(s, \"l\", \"L\")\nfmt.Println(s)\n}\n\n// \u6c47\u7f16\u4ee3\u7801\n// 1. \u51fd\u6570\u8c03\u7528\n// 2. \u51fd\u6570\u53c2\u6570\u4f20\u9012\n// 3. \u51fd\u6570\u8fd4\u56de\u503c\n// 4. \u51fd\u6570\u8c03\u7528\u6808\n// 5. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 6. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 7. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 8. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 9. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 10. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 11. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 12. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 13. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 14. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 15. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 16. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 17. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 18. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 19. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 20. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 21. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 22. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 23. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 24. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 25. \u51fd\u6570\u8c03\u7528\u6808\u7684\u6269\u5c55\n// 26. \u51fd\u6570\u8c03\u7528\u6808"}
{"tgt": "result := Mul3And5(5)\nif result != 3 {\n\tt.Errorf(\"STR\", result, 3)\n}\nresult = Mul3And5(6)\nif result != 8 {\n\tt.Errorf(\"STR\", result, 8)\n}\nresult = Mul3And5(7)\nif result != 14 {\n\tt.Errorf(\"STR\", result, 14)\n}\nresult = Mul3And5(10)\nif result != 23 {\n\tt.Errorf(\"STR\", result, 23)\n}\nresult = Mul3And5(11)\nif result != 33 {\n\tt.Errorf(\"STR\", result, 33)\n}", "gen": "var m Mul3And5\nif m.Mul3And5(5) != 3 {\n\tt.Errorf(\"Mul3And5(5) = %d; want 3\", m.Mul3And5(5))\n}\nif m.Mul3And5(10) != 8 {\n\tt.Errorf(\"Mul3And5(10) = %d; want 8\", m.Mul3And5(10))\n}\nif m.Mul3And5(15) != 14 {\n\tt.Errorf(\"Mul3And5(15) = %d; want 14\", m.Mul3And5(15))\n}\nif m.Mul3And5(20) != 23 {\n\tt.Errorf(\"Mul3And5(20) = %d; want 23\", m.Mul3And5(20))\n}\nif m.Mul3And5(25) != 32 {\n\tt.Errorf(\"Mul3And5(25) = %d; want 32\", m.Mul3And5(25))\n}\nif m.Mul3And5(30) != 39 {\n\tt.Errorf(\"Mul3And5(30) = %d; want 39\", m.Mul3And5(30))\n}\nif m.Mul3And5(35) != 46 {\n\tt.Errorf(\"Mul3And5(35) = %d; want 46\", m.Mul3And5(35))\n}\nif m.Mul3And5(40) != 53 {\n\tt.Errorf(\"Mul3And5(40) = %d; want 53\", m.Mul3And5(40))\n}\nif m.Mul3And5(45) != 60 {\n\tt.Errorf(\"M"}
{"tgt": "qs := []question1108{\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n\t{\n\t\tpara1108{\"STR\"},\n\t\tans1108{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1108, q.para1108\n\tfmt.Printf(\"STR\", p, defangIPaddr(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%s %d %d %d\\n\", \".LC13\", 7, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC14\", 13, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC15\", 12, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC16\", 18, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC17\", 70, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC18\", 37, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC19\", 0, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC20\", 2, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC21\", 2, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC22\", 0, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC23\", 0, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC24\", 0, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC25\", 0, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC26\", 0, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC27\", 0, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC28\", 0, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \"."}
{"tgt": "if root == nil {\n\treturn nil\n}\nif root.Key == key {\n\treturn root\n} else if root.Key < key {\n\troot = root.Right\n} else {\n\troot = root.Left\n}\nreturn Get(root, key)", "gen": "var root *avl.Node\nvar key int\nif root == nil {\n\treturn nil\n}\nif key == root.Key {\n\treturn root\n}\nif key < root.Key {\n\treturn Get(root.Left, key)\n}\nreturn Get(root.Right, key)\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1},\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1, 4, 2},\n\t\twant: 6,\n\t},\n\t{\n\t\tin:   []int{1},\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   []int{2, 1, 1, 2, 1, 3, 3, 3, 1, 3, 1, 3, 2},\n\t\twant: 7,\n\t},\n\t{\n\t\tin:   []int{1, 2, 2, 3, 1},\n\t\twant: 2,\n\t},\n}\nfor _, tt := range tests {\n\tgot := findShortestSubArray(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(findShortestSubArray([]int{1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2,"}
{"tgt": "fmt.Println(runtime.GOOS, runtime.GOARCH)", "gen": "fmt.Println(string.C6, string.C7)\n}\n"}
{"tgt": "result := make([]string, 0)\nstart := -1\nend := -1\nfor i, num := range nums {\n\tif i > 0 && num == nums[i-1]+1 {\n\t\tend = i\n\t} else {\n\t\tif i > 0 {\n\t\t\tresult = appendRanges(result, nums, start, end)\n\t\t}\n\t\tstart = i\n\t\tend = i\n\t}\n}\nif end >= 0 {\n\tresult = appendRanges(result, nums, start, end)\n}\nreturn result", "gen": "var nums []int\nvar res [][]int\nres = appendRanges(nums)\n}\n"}
{"tgt": "pigs := 0\nfor mypow(minutesToTest/minutesToDie+1, pigs) < buckets {\n\tpigs++\n}\nreturn pigs", "gen": "var a, b, c int\nfmt.Scan(&a, &b, &c)\nif c == -1 {\n\tfmt.Println(a / b)\n} else {\n\tfor i := 0; i < c; i++ {\n\t\tif a/b > i {\n\t\t\ta = int(math.Pow(float64(a), float64(b)))\n\t\t\tif a > i {\n\t\t\t\ta = i\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Println(a)\n}\n}\n"}
{"tgt": "qs := []question470{\n\t{\n\t\tpara470{},\n\t\tans470{2},\n\t},\n\t{\n\t\tpara470{},\n\t\tans470{0},\n\t},\n\t{\n\t\tpara470{},\n\t\tans470{1},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans470, q.para470\n\tfmt.Printf(\"STR\", p, rand10())\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%d %d %d\\n\", 2, 1, 0)\nfor i := 0; i < 3; i++ {\n\tfmt.Printf(\"%d %d %d\\n\", 3, 3, 0)\n\trand10 := rand.Intn(10)\n\tfmt.Printf(\"%d\\n\", rand10)\n\tvar d go.leetcode.para470.d\n\td = go.leetcode.para470.d{rand10}\n\tvar d2 go.leetcode.para470.d\n\td2 = go.leetcode.para470.d{rand10}\n\tvar d3 go.leetcode.para470.d\n\td3 = go.leetcode.para470.d{rand10}\n\tfmt.Printf(\"%d %d %d\\n\", d, d2, d3)\n\tvar d4 go.leetcode.para470.d\n\td4 = go.leetcode.para470.d{rand10}\n\tvar d5 go.leetcode.para470.d\n\td5 = go.leetcode.para470.d{rand10}\n\tfmt.Printf(\"%d %d %d\\n\", d4, d5, d)\n}\n}"}
{"tgt": "if s == nil {\n\treturn false\n}\nreturn isSubtree(s.Left, t) || isSameTree(s, t) || isSubtree(s.Right, t)", "gen": "root := &TreeNode{Val: 3, Left: &TreeNode{Val: 4, Left: &TreeNode{Val: 1, Right: &TreeNode{Val: 2}}, Right: &TreeNode{Val: 5}}, Right: &TreeNode{Val: 2, Left: &TreeNode{Val: 1, Right: &TreeNode{Val: 0}}, Right: &TreeNode{Val: 3}}}\nsubtree := &TreeNode{Val: 4, Left: &TreeNode{Val: 1, Right: &TreeNode{Val: 2}}, Right: &TreeNode{Val: 5}}\nif isSubtree(root, subtree) {\n\tfmt.Println(\"true\")\n} else {\n\tfmt.Println(\"false\")\n}\nif isSameTree(root, subtree) {\n\tfmt.Println(\"true\")\n} else {\n\tfmt.Println(\"false\")\n}\nif isSubtree(root, subtree) {\n\tfmt.Println(\"true\")\n} else {\n\tfmt.Println(\"false\")\n}\n}\n"}
{"tgt": "if p := e.r; e.list != nil && p != &e.list.root {\n\treturn p\n}\nreturn nil", "gen": "var a [2]int\nvar b int\nif len(a) > cap(a) {\n\tpanic(\"\")\n}\nif len(a) > cap(a) {\n\tb = len(a)\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "switch {\ncase one == nil && two == nil:\n\treturn nil\ncase one == nil:\n\treturn &BinaryTree{two.Val,\n\t\tMergeBinaryTrees(nil, two.Left),\n\t\tMergeBinaryTrees(nil, two.Right),\n\t}\ncase two == nil:\n\treturn &BinaryTree{one.Val,\n\t\tMergeBinaryTrees(one.Left, nil),\n\t\tMergeBinaryTrees(one.Right, nil),\n\t}\n}\nreturn &BinaryTree{one.Val + two.Val,\n\tMergeBinaryTrees(one.Left, two.Left),\n\tMergeBinaryTrees(one.Right, two.Right),\n}", "gen": "root1 := &BinaryTree{Val: 1}\nroot1.Left = &BinaryTree{Val: 2}\nroot1.Right = &BinaryTree{Val: 3}\nroot2 := &BinaryTree{Val: 1}\nroot2.Left = &BinaryTree{Val: 2}\nroot2.Right = &BinaryTree{Val: 3}\nroot3 := &BinaryTree{Val: 1}\nroot3.Left = &BinaryTree{Val: 2}\nroot3.Right = &BinaryTree{Val: 3}\nroot4 := &BinaryTree{Val: 1}\nroot4.Left = &BinaryTree{Val: 2}\nroot4.Right = &BinaryTree{Val: 3}\nroot5 := &BinaryTree{Val: 1}\nroot5.Left = &BinaryTree{Val: 2}\nroot5.Right = &BinaryTree{Val: 3}\nroot6 := &BinaryTree{Val: 1}\nroot6.Left = &BinaryTree{Val: 2}\nroot6.Right = &BinaryTree{Val: 3}\nroot7 := &BinaryTree{Val: 1}\nroot7.Left = &BinaryTree{Val: 2}\nroot7.Right = &BinaryTree{Val: 3}\nroot8 := &BinaryTree{Val: 1}\nroot8.Left = &BinaryTree{Val: 2}\nroot8.Right = &BinaryTree{Val: 3}\nroot9 := &BinaryTree{Val: 1}\nroot9.Left = &BinaryTree{Val: 2}\nroot9.Right = &BinaryTree{Val: 3}\nroot10 := &BinaryTree{Val: 1}\nroot10.Left = &BinaryTree{Val: 2}\nroot10.Right = &BinaryTree{Val: 3}\nroot11 := &BinaryTree{Val: 1}\nroot11.Left = &BinaryTree{Val: 2}\nroot11."}
{"tgt": "rets := make([][]int, numRows)\nif numRows == 0 {\n\treturn rets\n}\nrets[0] = []int{1}\nfor i := 1; i < numRows; i++ {\n\trets[i] = make([]int, i+1)\n\trets[i][0] = 1\n\trets[i][i] = 1\n\tfor j := 1; j < i; j++ {\n\t\trets[i][j] = rets[i-1][j-1] + rets[i-1][j]\n\t}\n}\nreturn rets", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\tif i == 0 {\n\t\ta = make([]int, 1)\n\t\ta[0] = 1\n\t\ta[1] = 1\n\t\ta[2] = 1\n\t\tcontinue\n\t}\n\tif i > 0 {\n\t\ta = append(a, 1)\n\t\ta = append(a, 1)\n\t\ta[i-1] = 1\n\t}\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "i, l := 0, len(bits)-1\nfor i < l {\n\ti += bits[i] + 1\n}\nreturn i == l", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i + 1\n}\nif i == len(a) {\n\tpanic(\"index out of range\")\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "fname, lname := \"STR\", \"STR\"\nage := 35\nfmt.Println(Title)\nfmt.Println(\"STR\", fname)\nfmt.Println(\"STR\", lname)\nfmt.Println(\"STR\", age)\nfmt.Println(\"STR\", Country)", "gen": "fmt.Println(\"Hello, playground\")\nvar a int\nvar b int\nvar c int\na = 1\nb = 1\nc = 35\nfmt.Println(a, b, c)\nvar d string\nd = \"Hello, playground\"\nfmt.Println(d)\nvar e string\ne = \"Hello, playground\"\nfmt.Println(e)\nvar f string\nf = \"Hello, playground\"\nfmt.Println(f)\nvar g string\ng = \"Hello, playground\"\nfmt.Println(g)\nvar h string\nh = \"Hello, playground\"\nfmt.Println(h)\nvar i string\ni = \"Hello, playground\"\nfmt.Println(i)\nvar j string\nj = \"Hello, playground\"\nfmt.Println(j)\nvar k string\nk = \"Hello, playground\"\nfmt.Println(k)\nvar l string\nl = \"Hello, playground\"\nfmt.Println(l)\nvar m string\nm = \"Hello, playground\"\nfmt.Println(m)\nvar n string\nn = \"Hello, playground\"\nfmt.Println(n)\nvar o string\no = \"Hello, playground\"\nfmt.Println(o)\nvar p string\np = \"Hello, playground\"\nfmt.Println(p)\nvar q string\nq = \"Hello, playground\"\nfmt.Println(q)\nvar r string\nr = \"Hello, playground\"\nfmt.Println(r)\nvar s string\ns = \"Hello, playground\"\nfmt.Println(s)\nvar t string\nt = \"Hello, playground\"\nfmt.Println(t)\nvar u string\nu = \"Hello, playground\"\nfmt.Println(u)\nvar v string\nv = \""}
{"tgt": "for i := 0; i < b.N; i++ {\n\tSum(7, 8, 10)\n}", "gen": "var sum int\nfor i := 0; i < 7; i++ {\n\tsum += i\n}\n}\n"}
{"tgt": "dec := xml.NewDecoder(os.Stdin)\nvar stack []string\nfor {\n\ttok, err := dec.Token()\n\tif err == io.EOF {\n\t\tbreak\n\t} else if err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"STR\", err)\n\t\tos.Exit(1)\n\t}\n\tswitch tok := tok.(type) {\n\tcase xml.StartElement:\n\t\tstack = append(stack, tok.Name.Local)\n\tcase xml.EndElement:\n\t\tstack = stack[:len(stack)-1]\n\tcase xml.CharData:\n\t\tif containsAll(stack, os.Args[1:]) {\n\t\t\tfmt.Printf(\"STR\", strings.Join(stack, \"STR\"), tok)\n\t\t}\n\t}\n}", "gen": "var s string\nvar err error\nvar f *os.File\nf, err = os.Open(\"input.xml\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer f.Close()\ndec := xml.NewDecoder(f)\nfor {\n\tvar tok xml.Token\n\ttok, err = dec.Token()\n\tif err == io.EOF {\n\t\tbreak\n\t}\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tswitch tok := tok.(type) {\n\tcase xml.StartElement:\n\t\tif tok.Name.Local == \"root\" {\n\t\t\ts = tok.Name.Local\n\t\t}\n\tcase xml.EndElement:\n\t\tif tok.Name.Local == \"root\" {\n\t\t\ts = tok.Name.Local\n\t\t}\n\tcase xml.CharData:\n\t\tif tok.Name.Local == \"root\" {\n\t\t\ts = tok.Name.Local\n\t\t}\n\t}\n}\nfmt.Printf(\"%s\\n\", s)\n}"}
{"tgt": "var sentences []string\nvar start int\nspaceDelimited := strings.Split(text, \"STR\")\npossibleSentence := false\nfor i, part := range spaceDelimited {\n\trunes := []rune(part)\n\tif part == \"STR\" || !isValid(runes) {\n\t\tpossibleSentence = false\n\t\tcontinue\n\t}\n\tif runes[0] >= 'A' && runes[0] <= 'Z' {\n\t\tpossibleSentence = true\n\t\tstart = i\n\t\tcontinue\n\t}\n\tif last := runes[len(runes)-1]; last == '.' || last == '!' || last == '?' {\n\t\tif possibleSentence {\n\t\t\tsentences = append(sentences, strings.Join(spaceDelimited[start:i+1], \"STR\"))\n\t\t}\n\t}\n}\nreturn sentences", "gen": "s := \"1234567890\"\na := strings.Split(s, \"\")\nvar res []string\nfor i := 0; i < len(a); i++ {\n\tif i == 0 {\n\t\tif a[i] == \"0\" {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] == \"1\" {\n\t\t\tif i+1 < len(a) && a[i+1] >= \"0\" && a[i+1] <= \"9\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif i+2 < len(a) && a[i+2] >= \"0\" && a[i+2] <= \"9\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif i+3 < len(a) && a[i+3] >= \"0\" && a[i+3] <= \"9\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif i+4 < len(a) && a[i+4] >= \"0\" && a[i+4] <= \"9\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif i+5 < len(a) && a[i+5] >= \"0\" && a[i+5] <= \"9\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif i+6 < len(a) && a[i+6] >= \"0\" && a[i+6] <= \"9\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif i+7 < len(a) && a[i+7] >= \"0\" && a[i+7] <= \"9\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif i+8 < len(a) && a[i+8] >= \"0\" && a[i+8] <= \"9\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t"}
{"tgt": "arr := randomSlice(0, 20, 10)\ndeleteSequence := randomSlice(0, 10, 10)\nnodeCnt := 0\nrbt := newRBT()\nfor _, v := range arr {\n\trbt.Insert(uint32(v))\n}\nfor i, v := range deleteSequence {\n\trbt.Delete(uint32(arr[v]))\n\tstop := rbt.PreOrderWalk(rbt.Root(), checkGBT(t, &nodeCnt, *debug))\n\tif stop {\n\t\treturn\n\t}\n\tif nodeCnt != len(deleteSequence)-1-i {\n\t\tt.Log(\"STR\", len(deleteSequence)-1-i, \"STR\", nodeCnt)\n\t\tt.Fail()\n\t}\n\tnodeCnt = 0\n\tif i != len(deleteSequence)-1 {\n\t\tstop = checkRBT(t, rbt)\n\t\tif stop {\n\t\t\treturn\n\t\t}\n\t}\n}", "gen": "var t *testing.T\nvar rbt *go.binaryTree.rbt.RBTree\nvar root *go.binaryTree.rbt.Node\nvar i int\nvar j int\nvar k int\nvar v int\nvar n int\nvar s []int\nvar s2 []int\nvar s3 []int\nvar s4 []int\nvar s5 []int\nvar s6 []int\nvar s7 []int\nvar s8 []int\nvar s9 []int\nvar s10 []int\nvar s11 []int\nvar s12 []int\nvar s13 []int\nvar s14 []int\nvar s15 []int\nvar s16 []int\nvar s17 []int\nvar s18 []int\nvar s19 []int\nvar s20 []int\nvar s21 []int\nvar s22 []int\nvar s23 []int\nvar s24 []int\nvar s25 []int\nvar s26 []int\nvar s27 []int\nvar s28 []int\nvar s29 []int\nvar s30 []int\nvar s31 []int\nvar s32 []int\nvar s33 []int\nvar s34 []int\nvar s35 []int\nvar s36 []int\nvar s37 []int\nvar s38 []int\nvar s39 []int\nvar s40 []int\nvar s41 []int\nvar s42 []int\nvar s43 []int\nvar s44 []int\nvar s45 []int\nvar s46 []int\nvar s47 []int\nvar s48 []int\nvar s49 []int\nvar s50 []int\nvar s51 []int\nvar s52 []int\nvar s53 []int\nvar s54 []int\nvar s55 []int\nvar s56 []"}
{"tgt": "ans := make([]int, len(nums))\nfor i, idx := range index {\n\tcopy(ans[idx+1:], ans[idx:])\n\tans[idx] = nums[i]\n}\nreturn ans", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\ta = append(a, i)\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "min, max := A[0], A[0]\nfor _, a := range A {\n\tif a < min {\n\t\tmin = a\n\t}\n\tif a > max {\n\t\tmax = a\n\t}\n}\nif max-min <= K+K {\n\treturn 0\n}\nreturn max - min - K - K", "gen": "var a [10]int\nvar b int\nfor i := 0; i < len(a); i++ {\n\tb = a[i]\n\tif b > a[i] {\n\t\ta[i] = b\n\t}\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "left := 0\nright := len(numbers) - 1\nfor left != right {\n\tif numbers[left]+numbers[right] == target {\n\t\tbreak\n\t}\n\tif numbers[left]+numbers[right] > target {\n\t\tright--\n\t}\n\tif numbers[left]+numbers[right] < target {\n\t\tleft++\n\t}\n}\nreturn []int{left + 1, right + 1}", "gen": "var a [2][3]int\nvar b [2][3]int\nvar c [2][3]int\nvar i int\nvar j int\nfor i = 0; i < len(a); i++ {\n\tfor j = 0; j < len(a); j++ {\n\t\tif a[i][j] > b[i][j] {\n\t\t\tc[i][j] = a[i][j]\n\t\t} else {\n\t\t\tc[i][j] = b[i][j]\n\t\t}\n\t}\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for a != nil && b != nil {\n\tif a.Value != b.Value {\n\t\treturn false\n\t}\n\ta = a.Next\n\tb = b.Next\n}\nreturn a == nil && b == nil", "gen": "var a, b int\nvar c bool\na, b = 1, 2\nc = a == b\nif a == b {\n\tc = false\n} else {\n\ta, b = a, b\n\tc = true\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return func(treebinaryTreeIf, node interface{}) bool {\n\tn := node.(*gbtElement)\n\tif !tree.IsNil(n.Left) && n.Left.Key >= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Left, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif !tree.IsNil(n.Right) && n.Right.Key <= n.Key {\n\t\tt.Log(fmt.Sprintf(\"STR\", n.Right, n))\n\t\tt.Fail()\n\t\treturn true\n\t}\n\tif debug {\n\t\tfmt.Println(n)\n\t}\n\t*nodeCnt++\n\treturn false\n}", "gen": "t := &testing.T{}\ncheckGBT(t, 1, true)\n}\n"}
{"tgt": "n := len(A)\nif n == 0 {\n\treturn A\n}\nabs := func(num int) int { return int(math.Abs(float64(num))) }\nans := make([]int, n)\ni, j, k := 0, n-1, n-1\nfor i <= j {\n\tif abs(A[i]) > abs(A[j]) {\n\t\tans[k] = A[i] * A[i]\n\t\ti++\n\t} else {\n\t\tans[k] = A[j] * A[j]\n\t\tj--\n\t}\n\tk--\n}\nreturn ans", "gen": "var a []int\nvar b []int\nvar c []int\na = make([]int, 10)\nb = make([]int, 10)\nc = make([]int, 10)\nfor i := 0; i < len(a); i++ {\n\tif i < len(b) {\n\t\tif i < len(c) {\n\t\t\tif i < len(a) {\n\t\t\t\tif i < len(b) {\n\t\t\t\t\tif i < len(c) {\n\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\tif i < len(b) {\n\t\t\t\t\t\t\t\tif i < len(c) {\n\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\tif i < len(b) {\n\t\t\t\t\t\t\t\t\t\t\tif i < len(c) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(b) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(c) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(b) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(c) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(b) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(c) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif denoms := EgyptianFractions(tc.numerator, tc.denominator); !reflect.DeepEqual(tc.denominators, denoms) {\n\t\tt.Errorf(\"STR\", tc.denominators, denoms)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "nums1 := []int{2}\nnums2 := []int{}\nmerge(nums1, 1, nums2, 0)\nfmt.Println(nums1)", "gen": "var a [3]int\na[0] = 2\na[1] = 1\na[2] = 1\nvar b [3]int\nb[0] = 0\nb[1] = 0\nb[2] = 0\nmerge(&a, &b)\nfmt.Println(a)\n}"}
{"tgt": "result := 0\nfor num != 0 {\n\tresult++\n\tnum = num & (num - 1)\n}\nreturn result", "gen": "var i int\nvar j int\nfor i = 0; i < 10; i++ {\n\tj++\n}\nreturn j\n}\n\n// func main() {\n// \tvar i int\n// \tvar j int\n// \tfor i = 0; i < 10; i++ {\n// \t\tj++\n// \t}\n// \treturn j\n// }\n// \n// func main() {\n// \tvar i int\n// \tvar j int\n// \tfor i = 0; i < 10; i++ {\n// \t\tj++\n// \t}\n// \treturn j\n// }\n// \n// func main() {\n// \tvar i int\n// \tvar j int\n// \tfor i = 0; i < 10; i++ {\n// \t\tj++\n// \t}\n// \treturn j\n// }\n// \n// func main() {\n// \tvar i int\n// \tvar j int\n// \tfor i = 0; i < 10; i++ {\n// \t\tj++\n// \t}\n// \treturn j\n// }\n// \n// func main() {\n// \tvar i int\n// \tvar j int\n// \tfor i = 0; i < 10; i++ {\n// \t\tj++\n// \t}\n// \treturn j\n// }\n// \n// func main() {\n// \tvar i int\n// \tvar j int\n// \tfor i = 0; i < 10; i++ {\n// \t\tj++\n// \t}\n// \treturn j\n// }\n// \n// func main() {\n// \tvar i int\n// \tvar j int\n// \tfor i = 0; i < 10; i++ {\n// \t\tj++\n// \t}\n// \treturn j\n// }\n// \n// func main() {\n// \tvar i int\n// \tvar"}
{"tgt": "qs := []question448{\n\t{\n\t\tpara448{[]int{4, 3, 2, 7, 8, 2, 3, 1}},\n\t\tans448{[]int{5, 6}},\n\t},\n\t{\n\t\tpara448{[]int{4, 3, 2, 10, 9, 2, 3, 1, 1, 1, 1}},\n\t\tans448{[]int{5, 6, 7, 8, 11}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans448, q.para448\n\tfmt.Printf(\"STR\", p, findDisappearedNumbers(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%d %d %d\\n\", 4, 3, 2)\na := []int{4, 3, 2}\nb := []int{5, 6}\nc := []int{4, 3, 2, 10, 9, 8, 7, 6, 5}\nd := []int{5, 6, 7, 8, 11, 10, 9, 8, 7, 6, 5}\nfmt.Printf(\"%d %d %d\\n\", 5, 6, 7)\nfmt.Printf(\"%d %d %d\\n\", 4, 3, 2)\nfmt.Printf(\"%d %d %d\\n\", 5, 6, 7)\nfmt.Printf(\"%d %d %d\\n\", 4, 3, 2)\nfmt.Printf(\"%d %d %d\\n\", 11, 11)\nfmt.Printf(\"%d %d %d\\n\", 5, 6, 7)\nfmt.Printf(\"%d %d %d\\n\", 4, 3, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 1, 1, 1, 1)\nfmt.Printf(\"%d %d %d\\n\", 5, 6, 7)\nfmt.Printf(\"%d %d %d\\n\", 4, 3, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 1, 1, 1, 1)\nfmt.Printf(\"%d %d %d\\n\", 5, 6, 7)\nfmt.Printf(\"%d %d %d\\n\", 4, 3, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 1, 1, 1, 1)\nfmt.Printf(\"%d %d %d\\n\", 5, 6, "}
{"tgt": "flag.Parse()\nroots := flag.Args()\nif len(roots) == 0 {\n\troots = []string{\"STR\"}\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, root := range roots {\n\t\twalkDir(root, fileSizes)\n\t}\n\tclose(fileSizes)\n}()\nvar nfiles, nbytes int64\nfor size := range fileSizes {\n\tnfiles++\n\tnbytes += size\n}\nprintDiskUsage(nfiles, nbytes)", "gen": "flag.Parse()\nargs := flag.Args()\nif len(args) != 2 {\n\tpanic(\"expected exactly two arguments\")\n}\nfileSizes := make(chan int64)\ngo func() {\n\tfor _, arg := range args {\n\t\tfileSizes <- getFileSize(arg)\n\t}\n\tclose(fileSizes)\n}()\ntotal := int64(0)\nfor size := range fileSizes {\n\ttotal += size\n}\nprintDiskUsage(total)\n}"}
{"tgt": "return toString[t]", "gen": "beer := beers[0]\nfmt.Println(beer)\n}\n"}
{"tgt": "for step := len(nums) / 2; step > 0; step /= 2 {\n\tfor i := step; i < len(nums); i++ {\n\t\tfor j := i - step; j >= 0 && nums[j+step] < nums[j]; j -= step {\n\t\t\tnums[j], nums[j+step] = nums[j+step], nums[j]\n\t\t}\n\t}\n}\nreturn nums", "gen": "var a [3]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var tests = []struct {\n\ttree *TreeNode\n\tvals []int\n}{\n\t{newTree(1, 2, 3, nil, 5, nil, 4), []int{1, 3, 4}},\n\t{newTree(1, 2, 3, 4, 5, nil, 6, nil, 7, nil, nil, 8, nil, nil, 9, nil, nil, nil, 10), []int{1, 3, 6, 8, 9, 10}},\n}\nfor _, tt := range tests {\n\tvals := rightSideView(tt.tree)\n\tif reflect.DeepEqual(vals, tt.vals) == false {\n\t\tt.Errorf(\"STR\", tt.tree, vals, tt.vals)\n\t}\n}", "gen": "fmt.Println(rightSideView(nil))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n}))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n\t{2, nil, nil},\n}))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n\t{2, nil, nil},\n\t{3, nil, nil},\n}))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n\t{2, nil, nil},\n\t{3, nil, nil},\n\t{4, nil, nil},\n}))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n\t{2, nil, nil},\n\t{3, nil, nil},\n\t{4, nil, nil},\n\t{5, nil, nil},\n}))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n\t{2, nil, nil},\n\t{3, nil, nil},\n\t{4, nil, nil},\n\t{5, nil, nil},\n\t{6, nil, nil},\n}))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n\t{2, nil, nil},\n\t{3, nil, nil},\n\t{4, nil, nil},\n\t{5, nil, nil},\n\t{6, nil, nil},\n\t{7, nil, nil},\n}))\nfmt.Println(rightSideView([]*TreeNode{\n\t{1, nil, nil},\n\t{2, nil, nil},\n\t{3, nil, nil},\n\t{4, nil, nil},\n\t{5, nil, nil},\n\t{6, nil, nil"}
{"tgt": "nodes := []int{\n\t1, 2, 3, 4, 5, 6,\n}\nedges := [][]bool{\n\t{false, true, true, false, false, false},\n\t{true, false, false, true, false, false},\n\t{true, false, false, true, false, false},\n\t{false, true, true, false, true, false},\n\t{false, false, false, true, false, true},\n\t{false, false, false, false, true, false},\n}\nstart := 1\nend := 6\nroute, _ := dfs(start, end, nodes, edges)\nfmt.Println(route)", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar aaa [3]int\nvar aab [3]int\nvar aac [3]int\nvar aad [3]int\nvar aae [3]int\nvar aaf [3]int\nvar aag [3]int\nvar aah [3]int\nvar aai [3]int\n"}
{"tgt": "if target < 0 {\n\ttarget = -target\n}\nk := 0\nfor target > 0 {\n\tk++\n\ttarget -= k\n}\nif target%2 == 0 {\n\treturn k\n}\nreturn k + 1 + k%2", "gen": "var n int64\nfor i := int64(0); i < n; i++ {\n\tif i&1 == 0 {\n\t\tn = n - i\n\t} else {\n\t\tn = n - i + 1\n\t}\n}\nreturn n\n}\n"}
{"tgt": "if mod == 1 {\n\treturn 0, nil\n}\nif exponent < 0 {\n\treturn -1, ErrorNegativeExponent\n}\n_, err := Multiply64BitInt(mod-1, mod-1)\nif err != nil {\n\treturn -1, err\n}\nvar result int64 = 1\nbase = base % mod\nfor exponent > 0 {\n\tif exponent%2 == 1 {\n\t\tresult = (result * base) % mod\n\t}\n\texponent = exponent >> 1\n\tbase = (base * base) % mod\n}\nreturn result, nil", "gen": "var a, b, c int64\na = 0\nb = 0\nc = 0\nif b == 1 {\n\ta = 0\n\tb = 0\n\tc = 0\n\treturn\n}\nif b < 0 {\n\ta = -1\n\tb = 0\n\tc = 0\n\treturn\n}\nif a == -1 {\n\ta = -1\n\tb = 0\n\tc = 0\n\treturn\n}\nif a == 0 {\n\ta = 0\n\tb = 0\n\tc = 0\n\treturn\n}\nif a < 0 {\n\ta = -1\n\tb = 0\n\tc = 0\n\treturn\n}\nif a == 1 {\n\ta = 1\n\tb = 0\n\tc = 0\n\treturn\n}\nif a > 1 {\n\ta = -1\n\tb = 0\n\tc = 0\n\treturn\n}\nif b == 0 {\n\ta = 0\n\tb = 0\n\tc = 0\n\treturn\n}\nif b < 0 {\n\ta = -1\n\tb = 0\n\tc = 0\n\treturn\n}\nif b == 0 {\n\ta = 0\n\tb = 0\n\tc = 0\n\treturn\n}\nif b > 0 {\n\ta = -1\n\tb = 0\n\tc = 0\n\treturn\n}\nif b == 0 {\n\ta = 0\n\tb = 0\n\tc = 0\n\treturn\n}\nif b < 0 {\n\ta = -1\n\tb = 0\n\tc = 0\n\treturn\n}\nif b"}
{"tgt": "for n := 0; n < 32; n++ {\n\tsquare[n] = gf2MatrixTimes(mat, mat[n])\n}", "gen": "var a [32]uint32\nvar b [32]uint32\nvar c uint32\nfor i := 0; i < 32; i++ {\n\ta[i] = gf2MatrixTimes(b, c)\n}\n}\n"}
{"tgt": "return n.Ns == nil", "gen": "if len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) == 0 {\n\tpanic(\"runtime error: slice bounds out of range\")\n}\nif len(a) =="}
{"tgt": "n := len(p)\ndestination := n * n\nsquares := make([]int, 400)\nisChecked := [401]bool{}\nsquares[0] = 1\nisChecked[1] = true\nsteps := 0\nfor len(squares) > 0 {\n\tsteps++\n\tsize := len(squares)\n\tfor j := 0; j < size; j++ {\n\t\ts := squares[j]\n\t\tfor i := 1; i <= 6; i++ {\n\t\t\tsi := s + i\n\t\t\tx, y := position(si, n)\n\t\t\tif p[x][y] != -1 {\n\t\t\t\tisChecked[si] = true\n\t\t\t\tsi = p[x][y]\n\t\t\t}\n\t\t\tif si == destination {\n\t\t\t\treturn steps\n\t\t\t}\n\t\t\tif !isChecked[si] {\n\t\t\t\tsquares = append(squares, si)\n\t\t\t\tisChecked[si] = true\n\t\t\t}\n\t\t}\n\t}\n\tsquares = squares[size:]\n}\nreturn -1", "gen": "var n int\nfmt.Scan(&n)\nvar a []int\nfor i := 0; i < n; i++ {\n\ta = append(a, 0)\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tif i == j {\n\t\t\ta[i] = 1\n\t\t\tbreak\n\t\t}\n\t\tif position(a, i, j) {\n\t\t\ta[i] = 1\n\t\t\tbreak\n\t\t}\n\t}\n}\nfmt.Println(a[n-1])\n}"}
{"tgt": "return &linkLoop{\n\tHead: &linkLoopNode{},\n}", "gen": "var linkLoop *linkLoopNode\nlinkLoop = new(linkLoopNode)\nlinkLoop.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoop = new(linkLoopNode)\nlinkLoop.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoopNode.linkLoop = linkLoop\nreturn\n}\n"}
{"tgt": "return bindataRead(\n\t_dataCustomersJson,\n\t\"STR\",\n)", "gen": "var dataCustomersJson []byte\ndataCustomersJson = []byte(`./data/customers.json`)\nvar data []byte\ndata = bindataRead(dataCustomersJson, 19, 0)\nvar dataCustomersJson2 []byte\ndataCustomersJson2 = data\nvar dataCustomersJson3 []byte\ndataCustomersJson3 = dataCustomersJson2[16 : 16+len(dataCustomersJson2)]\nvar dataCustomersJson4 []byte\ndataCustomersJson4 = dataCustomersJson3[0 : len(dataCustomersJson3)]\nvar dataCustomersJson5 []byte\ndataCustomersJson5 = dataCustomersJson4[0 : len(dataCustomersJson4)]\nvar dataCustomersJson6 []byte\ndataCustomersJson6 = dataCustomersJson5[0 : len(dataCustomersJson5)]\nvar dataCustomersJson7 []byte\ndataCustomersJson7 = dataCustomersJson6[0 : len(dataCustomersJson6)]\nvar dataCustomersJson8 []byte\ndataCustomersJson8 = dataCustomersJson7[0 : len(dataCustomersJson7)]\nvar dataCustomersJson9 []byte\ndataCustomersJson9 = dataCustomersJson8[0 : len(dataCustomersJson8)]\nvar dataCustomersJson10 []byte\ndataCustomersJson10 = dataCustomersJson9[0 : len(dataCustomersJson9)]\nvar dataCustomersJson11 []byte\ndataCustomersJson11 = dataCustomersJson10[0 : len(dataCustomersJson10)]\nvar dataCustomersJson12 []byte\ndataCustomersJson12 = dataCustomersJson11[0 : len(dataCustomersJson11)]\nvar dataCustomersJson13 []byte\ndataCustomersJson13 = dataCustomersJson12[0 : len(dataCustomersJson12)]\nvar dataCustomersJson14 []byte\ndataCustomersJson14 = dataCustomersJson13[0 : len(dataCustomersJson"}
{"tgt": "m := len(matrix)\nif m == 0 {\n\treturn 0\n}\nn := len(matrix[0])\nif n == 0 {\n\treturn 0\n}\nmaxEdge := 0\ndp := make([][]int, m+1)\nfor i := range dp {\n\tdp[i] = make([]int, n+1)\n}\nfor i := 1; i <= m; i++ {\n\tfor j := 1; j <= n; j++ {\n\t\tif matrix[i-1][j-1] == '1' {\n\t\t\tdp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))\n\t\t\tmaxEdge = max(maxEdge, dp[i][j])\n\t\t}\n\t}\n}\nreturn maxEdge * maxEdge", "gen": "var a []int\nvar b []int\nvar c []int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar A int\nvar B int\nvar C int\nvar D int\nvar E int\nvar F int\nvar G int\nvar H int\nvar I int\nvar J int\nvar K int\nvar L int\nvar M int\nvar N int\nvar O int\nvar P int\nvar Q int\nvar R int\nvar S int\nvar T int\nvar U int\nvar V int\nvar W int\nvar X int\nvar Y int\nvar Z int\nif len(a) == 0 {\n\treturn\n}\nif len(a) == 0 {\n\treturn\n}\nif len(a) == 0 {\n\treturn\n}\nif len(a) == 0 {\n\treturn\n}\nif len(a) == 0 {\n\treturn\n}\nif len(a) == 0 {\n\treturn\n}\nif len(a) == 0 {\n\treturn\n}\nif len(a) == 0 {\n\treturn\n}\nif len(a) == 0 {\n\treturn\n}\nif len(a) == 0 {\n\treturn\n}\nif len(a) == 0 {\n\treturn\n}\nif len(a) == 0 {\n\treturn\n}\nif len(a) == 0 {\n\treturn\n}\nif len"}
{"tgt": "return x * y", "gen": "var a float32 = 1.0\nvar b float32 = 2.0\nvar c float32 = 3.0\nvar d float32 = 4.0\nvar e float32 = 5.0\nvar f float32 = 6.0\nvar g float32 = 7.0\nvar h float32 = 8.0\nvar i float32 = 9.0\nvar j float32 = 10.0\nvar k float32 = 11.0\nvar l float32 = 12.0\nvar m float32 = 13.0\nvar n float32 = 14.0\nvar o float32 = 15.0\nvar p float32 = 16.0\nvar q float32 = 17.0\nvar r float32 = 18.0\nvar s float32 = 19.0\nvar t float32 = 20.0\nvar u float32 = 21.0\nvar v float32 = 22.0\nvar w float32 = 23.0\nvar x float32 = 24.0\nvar y float32 = 25.0\nvar z float32 = 26.0\nvar a1 float32 = 27.0\nvar b1 float32 = 28.0\nvar c1 float32 = 29.0\nvar d1 float32 = 30.0\nvar e1 float32 = 31.0\nvar f1 float32 = 32.0\nvar g1 float32 = 33.0\nvar h1 float32 = 34.0\nvar i1 float32 = 35.0\nvar j1 float32 = 36.0\nvar k1 float32 = 37.0\nvar l1 float32 = 38.0\nvar m"}
{"tgt": "if len(a) != len(b) {\n\treturn false\n}\nfor i, v := range a {\n\tif v != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [3]int\nvar b [3]int\nvar c int\nif len(a) == 0 {\n\treturn\n}\nfor i := 0; i < len(a); i++ {\n\tif i < len(a) {\n\t\tc = a[i]\n\t\tb[i] = c\n\t} else {\n\t\treturn\n\t}\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(s) <= 1 {\n\treturn s\n}\ni := getIndex(s + \"STR\" + reverse(s))\nreturn reverse(s[i:]) + s", "gen": "var s string\nvar n int\nfmt.Scan(&s, &n)\nif n == 1 {\n\treturn s\n}\nif n > len(s) {\n\tpanic(\"index out of range\")\n}\nif n < len(s) {\n\treturn s[:n] + reverse(s[n:]) + s[n:]\n}\nreturn reverse(s) + s\n}"}
{"tgt": "sorted := make([]int, 0, m+n)\np, q := 0, 0\nfor {\n\tif p == m {\n\t\tsorted = append(sorted, nums2[q:]...)\n\t\tbreak\n\t}\n\tif q == n {\n\t\tsorted = append(sorted, nums1[p:]...)\n\t\tbreak\n\t}\n\tif nums1[p] < nums2[q] {\n\t\tsorted = append(sorted, nums1[p])\n\t\tp++\n\t} else {\n\t\tsorted = append(sorted, nums2[q])\n\t\tq++\n\t}\n}\ncopy(nums1, sorted)", "gen": "var a []int\nvar b []int\nvar c []int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar ba int\nvar bb int\nvar bc int\nvar bd int\nvar be int\nvar bf int\nvar bg int\nvar bh int\nvar bi int\nvar bj int\nvar bk int\nvar bl int\nvar bm int\nvar bn int\nvar bo int\nvar bp int\nvar bq int\nvar br int\nvar bs int\nvar bt int\nvar bu int\nvar bv int\nvar bw int\nvar bx int\nvar by int\nvar bz int\nvar ca int\nvar cb int\nvar cc int\nvar cd int\nvar ce int\nvar cf int\nvar cg int\nvar ch int\nvar ci int\nvar cj int\nvar ck int\nvar cl int\nvar cm int\nvar cn int\nvar co int\nvar cp int\nvar cq"}
{"tgt": "freq := make(map[rune]int)\nfor _, r := range s {\n\tfreq[r]++\n}\ntype frequency struct {\n\tr     rune\n\tcount int\n}\nletters := make([]*frequency, 0, len(freq))\nfor letter, count := range freq {\n\tletters = append(letters, &frequency{letter, count})\n}\nsort.Slice(letters, func(i, j int) bool {\n\treturn letters[i].count > letters[j].count\n})\nvar sb strings.Builder\nfor len(letters) != 0 {\n\tif len(letters) == 1 && letters[0].count > 1 {\n\t\treturn \"STR\"\n\t}\n\tfor _, f := range letters {\n\t\tsb.WriteRune(f.r)\n\t\tf.count--\n\t}\n\tfor len(letters) != 0 && letters[len(letters)-1].count == 0 {\n\t\tletters = letters[:len(letters)-1]\n\t}\n}\nreturn sb.String()", "gen": "m := make(map[int]int)\nfor i := 0; i < len(s); i++ {\n\tif s[i] == '(' {\n\t\tm[i]++\n\t} else {\n\t\tm[i]--\n\t}\n}\nvar f int\nfor i := 0; i < len(s); i++ {\n\tf += m[i]\n\tif f == 0 {\n\t\tfreq[i]++\n\t}\n}\nsort.Slice(freq, func(i, j int) bool {\n\treturn freq[i] < freq[j]\n})\nvar b strings.Builder\nfor i := 0; i < len(freq); i++ {\n\tif i == 0 {\n\t\tb.WriteRune(freq[i])\n\t} else {\n\t\tb.WriteRune(freq[i] - 1)\n\t}\n}\nreturn b.String()\n}\n"}
{"tgt": "n := len(A)\nfor i := n - 2; i >= 0; i-- {\n\tA[i] += A[i+1]\n}\nmem := [101][33]int{}\nvar dp func(int, int) int\ndp = func(i, m int) int {\n\tif i+2*m >= n {\n\t\treturn A[i]\n\t}\n\tif mem[i][m] > 0 {\n\t\treturn mem[i][m]\n\t}\n\tres := 0\n\tfor x := 1; x <= 2*m; x++ {\n\t\tres = max(\n\t\t\tres,\n\t\t\tA[i]-dp(i+x, max(m, x)),\n\t\t)\n\t}\n\tmem[i][m] = res\n\treturn res\n}\nreturn dp(0, 1)", "gen": "var stones []int\nvar i int\nvar j int\nvar sum int\nvar max int\nvar tmp int\nvar tmp2 int\nvar tmp3 int\nvar tmp4 int\nvar tmp5 int\nvar tmp6 int\nvar tmp7 int\nvar tmp8 int\nvar tmp9 int\nvar tmp10 int\nvar tmp11 int\nvar tmp12 int\nvar tmp13 int\nvar tmp14 int\nvar tmp15 int\nvar tmp16 int\nvar tmp17 int\nvar tmp18 int\nvar tmp19 int\nvar tmp20 int\nvar tmp21 int\nvar tmp22 int\nvar tmp23 int\nvar tmp24 int\nvar tmp25 int\nvar tmp26 int\nvar tmp27 int\nvar tmp28 int\nvar tmp29 int\nvar tmp30 int\nvar tmp31 int\nvar tmp32 int\nvar tmp33 int\nvar tmp34 int\nvar tmp35 int\nvar tmp36 int\nvar tmp37 int\nvar tmp38 int\nvar tmp39 int\nvar tmp40 int\nvar tmp41 int\nvar tmp42 int\nvar tmp43 int\nvar tmp44 int\nvar tmp45 int\nvar tmp46 int\nvar tmp47 int\nvar tmp48 int\nvar tmp49 int\nvar tmp50 int\nvar tmp51 int\nvar tmp52 int\nvar tmp53 int\nvar tmp54 int\nvar tmp55 int\nvar tmp56 int\nvar tmp57 int\nvar tmp58 int\nvar tmp59 int\nvar tmp60 int\nvar tmp61 int\nvar tmp62 int\nvar tmp63 int\nvar tmp64 int\nvar tmp65 int\nvar tmp66 int\nvar tmp67 int\nvar tmp68 int\nvar tmp69 int\n"}
{"tgt": "if n <= 2 {\n\treturn n\n}\nvar dp [2]int\ndp[0], dp[1] = 1, 2\nfor i := 2; i < n; i++ {\n\tdp[i%2] = dp[i%2] + dp[(i-1)%2]\n}\nreturn dp[(n-1)%2]", "gen": "var a [2]int\nvar b int\nfor i := 0; i < len(a); i++ {\n\tif i > len(a) {\n\t\tpanic(i)\n\t}\n\tif i < 0 {\n\t\tpanic(i)\n\t}\n\tif i > len(a) {\n\t\tpanic(i)\n\t}\n\tif i < 0 {\n\t\tpanic(i)\n\t}\n\tif i > len(a) {\n\t\tpanic(i)\n\t}\n\tif i < 0 {\n\t\tpanic(i)\n\t}\n\tif i > len(a) {\n\t\tpanic(i)\n\t}\n\tif i < 0 {\n\t\tpanic(i)\n\t}\n\tif i > len(a) {\n\t\tpanic(i)\n\t}\n\tif i < 0 {\n\t\tpanic(i)\n\t}\n\tif i > len(a) {\n\t\tpanic(i)\n\t}\n\tif i < 0 {\n\t\tpanic(i)\n\t}\n\tif i > len(a) {\n\t\tpanic(i)\n\t}\n\tif i < 0 {\n\t\tpanic(i)\n\t}\n\tif i > len(a) {\n\t\tpanic(i)\n\t}\n\tif i < 0 {\n\t\tpanic(i)\n\t}\n\tif i > len(a) {\n\t\tpanic(i)\n\t}\n\tif i < 0 {\n\t\tpanic(i)\n\t}\n\tif i > len(a) {\n\t\tpanic(i)\n\t}\n\tif i < 0 {\n\t\tpanic(i)\n\t}\n\tif i > len(a) {"}
{"tgt": "email = strings.TrimSpace(email)\nemail = strings.ToLower(email)\nh := md5.New()\nio.WriteString(h, email)\nfinalBytes := h.Sum(nil)\nfinalString := hex.EncodeToString(finalBytes)\nreturn finalString", "gen": "var s string\nvar err error\ns, err = strings.TrimSpace(os.Args[1])\nif err != nil {\n\tlog.Fatal(err)\n}\ns = strings.ToLower(s)\nh := md5.New()\nh.Write([]byte(s))\nvar b bytes.Buffer\nb.WriteString(s)\nfmt.Println(b.String())\nfmt.Println(hex.EncodeToString(h.Sum(nil)))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t}, {\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n}\nfor _, tt := range tests {\n\tgot := repeatedSubstringPattern(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(repeatedSubstringPattern(\"abab\"))\nfmt.Println(repeatedSubstringPattern(\"aba\"))\nfmt.Println(repeatedSubstringPattern(\"abcabcabcabc\"))\nfmt.Println(repeatedSubstringPattern(\"abcabcab\"))\nfmt.Println(repeatedSubstringPattern(\"abcabc\"))\nfmt.Println(repeatedSubstringPattern(\"abcab\"))\nfmt.Println(repeatedSubstringPattern(\"abc\"))\nfmt.Println(repeatedSubstringPattern(\"a\"))\nfmt.Println(repeatedSubstringPattern(\"\"))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   0x5555,\n\t\twant: 8,\n\t},\n}\nfor _, tt := range tests {\n\tgot := hammingWeight(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var a uint32 = 3\nvar b uint32 = 2\nvar c uint32 = 7\nvar d uint32 = 3\nvar e uint32 = 8\nvar f uint32 = 1\nvar g uint32 = 21845\nvar h uint32 = 8\nvar i uint32 = 4\nvar j uint32 = 0\nvar k uint32 = 0\nvar l uint32 = 0\nvar m uint32 = 0\nvar n uint32 = 0\nvar o uint32 = 0\nvar p uint32 = 0\nvar q uint32 = 0\nvar r uint32 = 0\nvar s uint32 = 0\nvar t uint32 = 0\nvar u uint32 = 0\nvar v uint32 = 0\nvar w uint32 = 0\nvar x uint32 = 0\nvar y uint32 = 0\nvar z uint32 = 0\nvar aa uint32 = 0\nvar bb uint32 = 0\nvar cc uint32 = 0\nvar dd uint32 = 0\nvar ee uint32 = 0\nvar ff uint32 = 0\nvar gg uint32 = 0\nvar hh uint32 = 0\nvar ii uint32 = 0\nvar jj uint32 = 0\nvar kk uint32 = 0\nvar ll uint32 = 0\nvar mm uint32 = 0\nvar nn uint32 = 0\nvar oo uint32 = 0\nvar pp uint32 = 0\nvar qq uint32 = 0\nvar rr uint32 = 0\nvar ss uint32 = 0\nvar tt uint32 = 0\nvar uu uint32 = 0\nvar vv uint32 = 0\nvar ww uint"}
{"tgt": "return bindataRead(\n\t_assetsHomeCatJpg,\n\t\"STR\",\n)", "gen": "var homeCatJpg []byte\nvar homeCatJpg2 []byte\nvar homeCatJpg3 []byte\nvar homeCatJpg4 []byte\nvar homeCatJpg5 []byte\nhomeCatJpg = bindataRead(homeCatJpg, homeCatJpg2, homeCatJpg3, homeCatJpg4, homeCatJpg5, \".\", \"assets\", \"HomeCat.jpg\")\nreturn homeCatJpg\n}\n\n// func bindataRead(homeCatJpg []byte, homeCatJpg2 []byte, homeCatJpg3 []byte, homeCatJpg4 []byte, homeCatJpg5 []byte, dir string, subdir string, filename string) []byte {\n// \tvar buf []byte\n// \tvar err error\n// \tbuf, err = bindataRead(homeCatJpg, homeCatJpg2, homeCatJpg3, homeCatJpg4, homeCatJpg5, dir, subdir, filename)\n// \tif err != nil {\n// \t\tpanic(err)\n// \t}\n// \treturn buf\n// }\n\n// func bindataRead(homeCatJpg []byte, homeCatJpg2 []byte, homeCatJpg3 []byte, homeCatJpg4 []byte, homeCatJpg5 []byte, dir string, subdir string, filename string) ([]byte, error) {\n// \tvar buf []byte\n// \tvar err error\n// \tbuf, err = bindataRead(homeCatJpg, homeCatJpg2, homeCatJpg3, homeCatJpg4, homeCatJpg5, dir, subdir, filename)\n// \tif err != nil {\n// \t\treturn nil, err\n// \t}\n// \treturn buf, nil\n// }\n\n// func bindataRead(homeCatJpg []byte, homeCatJpg2 []byte, homeCatJpg3 []byte, homeCatJpg4 []byte, homeCatJpg5 []byte, dir string, subdir string, filename string) ([]byte, error) {\n// \tvar buf []byte\n// "}
{"tgt": "b.table = make(map[string]*entry, capacity)\nb.priorityQueue = make([]*entry, 0, capacity)\nb.lruList.Init()\nb.freeList.Init()\nheap.Init(&b.priorityQueue)\narrayOfEntries := make([]entry, capacity)\nfor i := uint(0); i < capacity; i++ {\n\te := &arrayOfEntries[i]\n\te.element.Value = e\n\te.index = -1\n\tb.freeList.PushElementBack(&e.element)\n}", "gen": "cache := New(100)\nfor i := 0; i < 100; i++ {\n\tcache.Get(i)\n}\n}\n"}
{"tgt": "list.rear = nil", "gen": "var x *int\n*x = 0\n}\n\n// Test that we can handle a function call with a memory arg.\n// This is a bit tricky because the memory arg is not\n// a pointer, but a value.\n\n<ASM>\nmovq %rdi,-8(%rbp)\nmovq -8(%rbp),%rax\nleaq <runtime.writeBarrier>(%rip),%rdx\nmovl (%rdx),%edx\ntestl %edx,%edx\njne .L41\n.LBB49:\nmovq $0,(%rax)\n.LBE49:\njmp .L40\n.L41:\n.LBB50:\nmovl $0,%esi\nmovq %rax,%rdi\ncall <runtime.gcWriteBarrier@PLT>\n.L40:\nleave\nret</ASM>"}
{"tgt": "h := newLinkedHeap()\nbenchmarkHeap(b, h)", "gen": "heap := newLinkedHeap()\nbenchmarkHeap(heap)\n}\n"}
{"tgt": "close(p.work)\np.wg.Wait()", "gen": "var wg sync.WaitGroup\nch := make(chan int)\nwg.Add(1)\ngo func() {\n\tdefer wg.Done()\n\t<-ch\n}()\nwg.Wait()\n}\n\n// func main() {\n// \tvar wg sync.WaitGroup\n// \tch := make(chan int)\n// \twg.Add(1)\n// \tgo func() {\n// \t\tdefer wg.Done()\n// \t\t<-ch\n// \t}()\n// \twg.Wait()\n// }\n// func main() {\n// \tvar wg sync.WaitGroup\n// \tch := make(chan int)\n// \twg.Add(1)\n// \tgo func() {\n// \t\tdefer wg.Done()\n// \t\t<-ch\n// \t}()\n// \twg.Wait()\n// }\n// func main() {\n// \tvar wg sync.WaitGroup\n// \tch := make(chan int)\n// \twg.Add(1)\n// \tgo func() {\n// \t\tdefer wg.Done()\n// \t\t<-ch\n// \t}()\n// \twg.Wait()\n// }\n// func main() {\n// \tvar wg sync.WaitGroup\n// \tch := make(chan int)\n// \twg.Add(1)\n// \tgo func() {\n// \t\tdefer wg.Done()\n// \t\t<-ch\n// \t}()\n// \twg.Wait()\n// }\n// func main() {\n// \tvar wg sync.WaitGroup\n// \tch := make(chan int)\n// \twg.Add(1)\n// \tgo func() {\n// \t\tdefer wg.Done()\n// \t\t<-ch\n// \t}()\n// \twg.Wait()\n// }\n// func main() {\n// \tvar wg sync.WaitGroup\n//"}
{"tgt": "res := 0\nfactor := 1\nsize := len(s)\nfor i := 0; i < size; i++ {\n\tif s[i] == '(' {\n\t\tfactor *= 2\n\t} else {\n\t\tfactor /= 2\n\t}\n\tif s[i] == '(' && s[i+1] == ')' {\n\t\tres += factor / 2\n\t}\n}\nreturn res", "gen": "var a int\nvar b int\nvar c int\na = 0\nb = 1\nc = 0\nfor i := 0; i < len(s); i++ {\n\tif s[i] == '(' {\n\t\tc++\n\t} else if s[i] == ')' {\n\t\tc--\n\t} else {\n\t\tif c == 0 {\n\t\t\ta++\n\t\t} else {\n\t\t\tif c < 0 {\n\t\t\t\tpanic(\"index out of range\")\n\t\t\t}\n\t\t\tc--\n\t\t}\n\t}\n}\nreturn a\n}\n"}
{"tgt": "qs := []question454{\n\t{\n\t\tpara454{[]int{1, 2}, []int{-2, -1}, []int{-1, 2}, []int{0, 2}},\n\t\tans454{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans454, q.para454\n\tfmt.Printf(\"STR\", p, fourSumCount(p.a, p.b, p.c, p.d))\n}\nfmt.Printf(\"STR\")", "gen": "var a = []int{1, 2}\nvar b = []int{-2, -1}\nvar c = []int{-1, 2}\nvar d = []int{0, 2}\nvar ans int\nfor i := 0; i < len(a); i++ {\n\tfor j := 0; j < len(b); j++ {\n\t\tfor k := 0; k < len(c); k++ {\n\t\t\tfor l := 0; l < len(d); l++ {\n\t\t\t\tans += fourSumCount(a, b, c, d)\n\t\t\t}\n\t\t}\n\t}\n}\nfmt.Println(ans)\n}\n"}
{"tgt": "for i := range langs {\n\tlanguage := langs[i]\n\tif strings.EqualFold(language.Lang, str) {\n\t\treturn &language\n\t}\n}\nreturn nil", "gen": "langs := []Language{\n\t{\"Go\", \"golang\", \"go\"},\n\t{\"Python\", \"python\", \"python\"},\n\t{\"JavaScript\", \"javascript\", \"js\"},\n}\nvar lang Language\nfor _, lang = range langs {\n\tif lang.Name == \"Go\" {\n\t\tbreak\n\t}\n}\nfmt.Println(lang)\n}\n"}
{"tgt": "sort.Ints(houses)\nsort.Ints(heaters)\ni, ans := 0, 0\nfor _, house := range houses {\n\tfor i < len(heaters)-1 && heaters[i]+heaters[i+1] <= house*2 {\n\t\ti++\n\t}\n\tans = maxInt(ans, absInt(heaters[i]-house))\n}\nreturn ans", "gen": "ints := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nsort.Ints(ints)\nints2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nsort.Ints(ints2)\nvar max int\nfor i := 0; i < len(ints); i++ {\n\tfor j := 0; j < len(ints2); j++ {\n\t\tif absInt(ints[i]-ints2[j]) > max {\n\t\t\tmax = absInt(ints[i]-ints2[j])\n\t\t}\n\t}\n}\nfmt.Println(max)\n}"}
{"tgt": "return h.FromHexString(string(b))", "gen": "var hash go.metainfo.Hash\nhash, err = go.metainfo.HashFromHexString(string([]byte{32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{\n\t\t{10, 16},\n\t\t{2, 8},\n\t\t{1, 6},\n\t\t{7, 12},\n\t}, 2},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := findMinArrowShots(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.TestSolution()\n}\n"}
{"tgt": "if n < 2 {\n\treturn false\n}\nfor i := 2; i < n; i++ {\n\tif n%i == 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var n int\nfmt.Scan(&n)\nif n > 1 {\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\tfmt.Println(0)\n\t\t\treturn\n\t\t}\n\t}\n}\nfmt.Println(1)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{5, 3, 4, 5},\n\t\twant: true,\n\t},\n\t{\n\t\tin:   []int{2, 5, 7, 3},\n\t\twant: true,\n\t},\n}\nfor _, tt := range tests {\n\tgot := stoneGame(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "stoneGame([]int{5, 3, 4, 5})\nstoneGame([]int{2, 5, 7, 3})\n}\n"}
{"tgt": "return self.code", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\n}\n\n// 0000000000000000 <main>:\n// \t.cfi_startproc\n// \t.cfi_personality 155,DW.ref.__gxx_personality_v0\n// \t.cfi_lsda 16,DW.ref.__gxx_personality_v0\n// \t.file 1 \"test.go\"\n// \t.loc 1 1 0\n// \t.loc 1 1 10\n// \tpushq %rbp\n// \tmovq %rsp,%rbp\n// \tsubq $48,%rsp\n// \tmovq %rdi,-40(%rbp)\n// \tmovq %rsi,-48(%rbp)\n// \tmovq $0,-32(%rbp)\n// \tmovq $0,-24(%rbp)\n// \tmovq $0,-16(%rbp)\n// \t.loc 1 1 10\n// \tmovq -48(%rbp),%rax\n// \tmovq <24>(%rax),%rax\n// \tmovq <32>(%rax),%rdx\n// \tmovq %rax,-32(%rbp)\n// \tmovq %rdx,-24(%rbp)\n// \tmovq <40>(%rax),%rax\n// \tmovq %rax,-16(%rbp)\n// \tmovq -40(%rbp),%rax\n// \tmovq -32(%rbp),%rdx\n// \tmovq -24(%rbp),%rcx\n// \tmovq %rax,(%rcx)\n// \tmovq %rdx,<8>(%rcx)\n// \tmovq -16(%rbp),%rax\n// \tmov"}
{"tgt": "if N == 1 {\n\treturn 0\n}\nif K%2 == 1 {\n\treturn kthGrammar(N-1, (K+1)/2)\n}\nreturn opposite(kthGrammar(N-1, K/2))", "gen": "fmt.Println(kthGrammar(1, 1))\nfmt.Println(kthGrammar(2, 1))\nfmt.Println(kthGrammar(2, 2))\nfmt.Println(kthGrammar(3, 1))\nfmt.Println(kthGrammar(3, 2))\nfmt.Println(kthGrammar(3, 3))\nfmt.Println(kthGrammar(4, 1))\nfmt.Println(kthGrammar(4, 2))\nfmt.Println(kthGrammar(4, 3))\nfmt.Println(kthGrammar(4, 4))\nfmt.Println(kthGrammar(5, 1))\nfmt.Println(kthGrammar(5, 2))\nfmt.Println(kthGrammar(5, 3))\nfmt.Println(kthGrammar(5, 4))\nfmt.Println(kthGrammar(5, 5))\nfmt.Println(kthGrammar(6, 1))\nfmt.Println(kthGrammar(6, 2))\nfmt.Println(kthGrammar(6, 3))\nfmt.Println(kthGrammar(6, 4))\nfmt.Println(kthGrammar(6, 5))\nfmt.Println(kthGrammar(6, 6))\nfmt.Println(kthGrammar(7, 1))\nfmt.Println(kthGrammar(7, 2))\nfmt.Println(kthGrammar(7, 3))\nfmt.Println(kthGrammar(7, 4))\nfmt.Println(kthGrammar(7, 5))\nfmt.Println(kthGrammar(7, 6))\nfmt.Println(kthGrammar(7,"}
{"tgt": "tests := [...]testType{\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\ta:    \"STR\",\n\t\tb:    \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := buddyStrings(tt.a, tt.b)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.a, tt.b, got, tt.want)\n\t}\n}", "gen": "buddyStrings(\"ab\", \"ba\")\n}\n"}
{"tgt": "ope := [][]int{\n\t{2, 2},\n\t{3, 3}}\nfmt.Println(maxCount(3, 3, ope))", "gen": "var a = [5]int{2, 2, 3, 3, 2}\nvar maxCount = maxCount(a)\nfmt.Println(maxCount)\n}\n"}
{"tgt": "qs := []question274{\n\t{\n\t\tpara274{[]int{3, 6, 9, 1}},\n\t\tans274{3},\n\t},\n\t{\n\t\tpara274{[]int{1}},\n\t\tans274{1},\n\t},\n\t{\n\t\tpara274{[]int{}},\n\t\tans274{0},\n\t},\n\t{\n\t\tpara274{[]int{3, 0, 6, 1, 5}},\n\t\tans274{3},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans274, q.para274\n\tfmt.Printf(\"STR\", p, hIndex(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%d %d %d\\n\", 3, 6, 9)\na := []int{1, 3, 5, 7}\nb := []int{1, 3, 5, 7}\nc := []int{1, 3, 5, 7}\nd := []int{1, 3, 5, 7}\nfmt.Printf(\"%d %d %d\\n\", 1, 3, 5)\nfmt.Printf(\"%d %d %d\\n\", 1, 3, 5)\nfmt.Printf(\"%d %d %d\\n\", 1, 3, 5)\nfmt.Printf(\"%d %d %d\\n\", 1, 3, 5)\nfmt.Printf(\"%d %d %d\\n\", 3, 0, 6)\nfmt.Printf(\"%d %d %d\\n\", 5, 4, 4)\nfmt.Printf(\"%d %d %d\\n\", 1, 1, 1)\nfmt.Printf(\"%d %d %d\\n\", 1, 1, 1)\nfmt.Printf(\"%d %d %d\\n\", 1, 1, 1)\nfmt.Printf(\"%d %d %d\\n\", 3, 0, 6)\nfmt.Printf(\"%d %d %d\\n\", 5, 4, 4)\nfmt.Printf(\"%d %d %d\\n\", 3, 0, 6)\nfmt.Printf(\"%d %d %d\\n\", 5, 4, 4)\nfmt.Printf(\"%d %d %d\\n\", 3, 0, 6)\nfmt.Printf(\"%d %d %d\\n\", 5, 4, 4)\nfmt.Printf(\"%d %d %d\\n\", 3, 0, 6)\nfmt.Printf(\"%d %d %d\\n\", 5, 4,"}
{"tgt": "sort.Strings(words)\nmp := make(map[string]bool)\nvar res string\nfor _, word := range words {\n\tsize := len(word)\n\tif size == 1 || mp[word[:size-1]] {\n\t\tif size > len(res) {\n\t\t\tres = word\n\t\t}\n\t\tmp[word] = true\n\t}\n}\nreturn res", "gen": "sort.Strings([]string{\"a\", \"b\", \"c\"})\nm := make(map[string]bool)\nfor i, v := range []string{\"a\", \"b\", \"c\"} {\n\tif i == 0 {\n\t\tcontinue\n\t}\n\tm[v] = true\n}\nfmt.Println(m)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "longestCenter, longestLength := 0, 0\nfor i, v := range P {\n\tif v > longestLength {\n\t\tlongestLength = v\n\t\tlongestCenter = i\n\t}\n}\noffset := (longestCenter - longestLength) / 2\nreturn s[offset : offset+longestLength]", "gen": "var a []int\nvar b []int\nvar c int\nfor i := 0; i < len(a); i++ {\n\tc = a[i]\n\tb[i] = c\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for j := 1; j <= 20; j++ {\n\tif num%j != 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a int\nfor i := 0; i < 20; i++ {\n\tif i == 0 {\n\t\ta = 1\n\t} else if i == 1 {\n\t\ta = 0\n\t} else {\n\t\ta = a / i\n\t}\n\tif a == 0 {\n\t\ta = 1\n\t} else if a == 1 {\n\t\ta = 0\n\t} else {\n\t\ta = a / i\n\t}\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "n := node.(*bstElement)\nif n == nil {\n\treturn nil\n}\nif n.right != nil {\n\treturn t.Min(n.right)\n}\ncur := n\nfor cur.parent != nil && cur.parent.left != cur {\n\tcur = cur.parent\n}\nreturn cur.parent", "gen": "var root *bstElement\nvar min *bstElement\nvar minVal *bstElement\nif root == nil {\n\treturn\n}\nif root.left == nil {\n\tmin = root\n} else {\n\tmin = Min(root.left)\n}\nif root.val < min.val {\n\tminVal = root\n} else {\n\tminVal = min\n}\nreturn\n}"}
{"tgt": "var r [][]int\nfor i := begin; i <= end; i++ {\n\tif 1 == k {\n\t\tr = append(r, []int{i})\n\t\tcontinue\n\t}\n\tsuf := comb(i+1, end, k-1)\n\tfor _, j := range suf {\n\t\tr = append(r, append([]int{i}, j...))\n\t}\n}\nreturn r", "gen": "var a []int\nvar b []int\nvar c []int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar A []int\nvar B []int\nvar C []int\nvar D int\nvar E int\nvar F int\nvar G int\nvar H int\nvar I int\nvar J int\nvar K int\nvar L int\nvar M int\nvar N int\nvar O int\nvar P int\nvar Q int\nvar R int\nvar S int\nvar T int\nvar U int\nvar V int\nvar W int\nvar X int\nvar Y int\nvar Z int\nfor i = 0; i < len(a); i++ {\n\tif i == 0 {\n\t\tA = append(A, a[i])\n\t\tB = append(B, b[i])\n\t\tC = append(C, c[i])\n\t\tD = 1\n\t\tE = 1\n\t\tF = 1\n\t\tG = 1\n\t\tH = 1\n\t\tI = 1\n\t\tJ = 1\n\t\tK = 1\n\t\tL = 1\n\t\tM = 1\n\t\tN = 1\n\t\tO = 1\n\t\tP = 1\n\t\tQ = 1\n\t\tR = 1\n\t\tS = 1\n\t\tT = 1\n\t\tU = 1\n\t\tV = 1\n\t\tW = 1\n\t\tX = "}
{"tgt": "b.lock.Lock()\ndefer b.lock.Unlock()\ne := b.table[key]\nif e == nil {\n\treturn nil, false\n}\nif e.expire.Before(now) {\n\tif b.ExpireGracePeriod == 0 || e.expire.Sub(now) > b.ExpireGracePeriod {\n\t\tb.removeEntry(e)\n\t}\n\treturn nil, false\n}\nb.touchEntry(e)\nreturn e.value, true", "gen": "var m sync.Mutex\nvar c = &LRUCache{\n\tmaxEntries: 100,\n\tcache:      make(map[string]*entry),\n\tll:         list.New(),\n}\nm.Lock()\ndefer m.Unlock()\nif c.cache == nil {\n\tpanic(\"nil\")\n}\nif c.ll == nil {\n\tpanic(\"nil\")\n}\nvar e *entry\nif _, ok := c.cache[key]; !ok {\n\tif c.ll.Len() == 0 {\n\t\treturn 0, 0, false\n\t}\n\tif time.Now().Before(c.ll.Front().Value.(*entry).expiration) {\n\t\treturn 0, 0, false\n\t}\n\tc.removeEntry(c.ll.Front())\n}\nif _, ok := c.cache[key]; !ok {\n\tpanic(\"nil\")\n}\ne = c.cache[key]\nc.ll.MoveToFront(e)\nreturn e.value, e.expiration.UnixNano(), true\n}\n"}
{"tgt": "if root == nil {\n\treturn 0\n}\nresult := 0\nif root.Val >= L && root.Val <= R {\n\tresult += root.Val\n}\nif root.Val >= L {\n\tresult += rangeSumBST(root.Left, L, R)\n}\nif root.Val <= R {\n\tresult += rangeSumBST(root.Right, L, R)\n}\nreturn result", "gen": "root := &TreeNode{Val: 10, Left: &TreeNode{Val: 5, Left: &TreeNode{Val: 3, Left: &TreeNode{Val: 3, Right: &TreeNode{Val: 2, Left: &TreeNode{Val: 1}}}, Right: &TreeNode{Val: 4, Right: &TreeNode{Val: 4}}}, Right: &TreeNode{Val: 7, Left: &TreeNode{Val: 6, Right: &TreeNode{Val: 9}}, Right: &TreeNode{Val: 15}}}}\nleft := 7\nright := 15\nfmt.Println(rangeSumBST(root, left, right))\n}\n"}
{"tgt": "if tree.root == nil {\n\treturn nil, false\n}\ncurrentNode := tree.root\nfor currentNode != nil {\n\tif i == currentNode.data {\n\t\treturn currentNode, true\n\t} else if i > currentNode.data {\n\t\tcurrentNode = currentNode.right\n\t} else if i < currentNode.data {\n\t\tcurrentNode = currentNode.left\n\t}\n}\nreturn nil, false", "gen": "var a *int\nvar b int\nif a == nil {\n\treturn\n}\nif *a == b {\n\treturn\n}\nif *a <= b {\n\ta = &a[1]\n\treturn\n}\na = &a[0]\nreturn\n}\n\nTEXT main.main(SB), $16-16\nMOVQ a+0(FP), AX\nTESTQ AX, AX\nJE .L2\nMOVQ (AX), AX\nCMPQ AX, b+8(FP)\nJNE .L3\nRET\n.L3:\nMOVQ (AX), AX\nCMPQ AX, b+8(FP)\nJLE .L4\nMOVQ (AX), AX\nMOVQ 24(AX), AX\nMOVQ AX, -24(SP)\nJMP .L5\n.L4:\nMOVQ (AX), AX\nMOVQ 16(AX), AX\nMOVQ AX, -24(SP)\n.L5:\nJMP .L6\n.L2:\nMOVQ $0, AX\nMOVQ $0, DX\nMOVQ AX, -32(SP)\nMOVQ DX, -33(SP)\n.L6:\nMOVQ -24(SP), AX\nMOVB -33(SP), DL\nRET\n```\n\n### 2. \u5faa\u73af\n\n```go\npackage main\n"}
{"tgt": "length := len(nums)\nif length == 0 || length == 1 && nums[0] != target {\n\treturn []int{-1, -1}\n}\nreturn searchRangeI(nums, 0, length-1, target)", "gen": "nums := []int{2, 5, 6, 0, 0, 1, 2}\ntarget := 3\nresult := searchRange(nums, target)\nfmt.Println(result)\n}\n"}
{"tgt": "var (\n\tl int\n\tr = len(nums) - 1\n)\nfor l <= r {\n\tmid := l + (r-l)/2\n\tif target == nums[mid] {\n\t\treturn mid\n\t}\n\tif nums[mid] >= nums[l] && nums[mid] > nums[r] {\n\t\tif target >= nums[l] && target < nums[mid] {\n\t\t\tr = mid - 1\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t} else {\n\t\tif target > nums[mid] && target <= nums[r] {\n\t\t\tl = mid + 1\n\t\t} else {\n\t\t\tr = mid - 1\n\t\t}\n\t}\n}\nreturn -1", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif i < len(a) {\n\t\tif i < len(a) {\n\t\t\tif i < len(a) {\n\t\t\t\tif i < len(a) {\n\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len("}
{"tgt": "if squares < 3 {\n\treturn 1\n}\nif answer, ok := memo[squares]; ok {\n\treturn answer\n}\ntotal := int64(1)\nfor size := 3; size <= squares; size++ {\n\tfor start := 0; start <= squares-size; start++ {\n\t\tanswer := int64(1)\n\t\tanswer *= ways(squares - start - size - 1)\n\t\ttotal += answer\n\t}\n}\nmemo[squares] = total\nreturn total", "gen": "var n int\nfmt.Scan(&n)\nif n == 2 {\n\treturn 1\n}\nmemo := make(map[int][2]int64)\nreturn ways(n, memo)\n}\n"}
{"tgt": "return &CircularBuffer{\n\tbuffer: make([]interface{}, size),\n\tsize:   size,\n\tavail:  make(chan bool, size),\n}", "gen": "var c chan bool\nvar b []interface{}\nvar a CircularBuffer\nc = make(chan bool)\nb = make([]interface{}, 0)\na = CircularBuffer{}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return uint32((dev >> 8) & 0xff)", "gen": "var x uint8 = 0\nx >>= 8\nreturn x\n}\n\n// func main() {\n// \tvar x uint8 = 0\n// \tx >>= 8\n// \treturn x\n// }\n// \n// func main() {\n// \tvar x uint8 = 0\n// \tx >>= 8\n// \treturn x\n// }\n// \n// func main() {\n// \tvar x uint8 = 0\n// \tx >>= 8\n// \treturn x\n// }\n// \n// func main() {\n// \tvar x uint8 = 0\n// \tx >>= 8\n// \treturn x\n// }\n// \n// func main() {\n// \tvar x uint8 = 0\n// \tx >>= 8\n// \treturn x\n// }\n// \n// func main() {\n// \tvar x uint8 = 0\n// \tx >>= 8\n// \treturn x\n// }\n// \n// func main() {\n// \tvar x uint8 = 0\n// \tx >>= 8\n// \treturn x\n// }\n// \n// func main() {\n// \tvar x uint8 = 0\n// \tx >>= 8\n// \treturn x\n// }\n// \n// func main() {\n// \tvar x uint8 = 0\n// \tx >>= 8\n// \treturn x\n// }\n// \n// func main() {\n// \tvar x uint8 = 0\n// \tx >>= 8\n// \treturn x\n// }\n// \n// func main() {\n// \tvar x uint8 = 0\n// \tx >>= 8\n// \treturn x\n// }\n// \n// func main() {\n// \tvar x uint8 = 0\n// \tx >>= 8\n// \treturn x\n// }\n// \n// func main() {\n// \tvar x uint8 = 0\n// \tx"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 4,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 6,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 6,\n\t},\n}\nfor _, tt := range tests {\n\tgot := longestValidParentheses(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(longestValidParentheses(\"(()\"))\nfmt.Println(longestValidParentheses(\")()())\"))\nfmt.Println(longestValidParentheses(\"()(()\"))\nfmt.Println(longestValidParentheses(\")()()\"))\nfmt.Println(longestValidParentheses(\"()\"))\nfmt.Println(longestValidParentheses(\"()()\"))\nfmt.Println(longestValidParentheses(\"()()()\"))\nfmt.Println(longestValidParentheses(\"()(()\"))\nfmt.Println(longestValidParentheses(\"()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()()()()()()()()()()\"))\nfmt.Println(longestValidParentheses(\"()()()()()()()"}
{"tgt": "iterator := func() <-chan VertexId {\n\tch := make(chan VertexId)\n\tgo func() {\n\t\tif connected, ok := g.edges[vertex]; ok {\n\t\t\tfor VertexId, _ := range connected {\n\t\t\t\tif g.IsEdge(vertex, VertexId) {\n\t\t\t\t\tch <- VertexId\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\nreturn VerticesIterable(&vertexIterableHelper{iterFunc: iterator})", "gen": "g := graph.NewGraph()\nv1 := graph.NewVertex(1)\nv2 := graph.NewVertex(2)\ng.AddVertex(v1)\ng.AddVertex(v2)\ng.AddEdge(v1, v2)\nfmt.Println(g)\n}\n"}
{"tgt": "ans := 0\nfor ; x != 0; x /= 10 {\n\tans = ans*10 + x%10\n}\nif ans < math.MinInt32 || ans > math.MaxInt32 {\n\treturn 0\n}\nreturn ans", "gen": "var a int64\nvar b int64\nfor {\n\tb = a\n\ta = a*a + b\n\tif a > 0 {\n\t\tbreak\n\t}\n}\nreturn b\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "i, size := 0, len(s)\nss := make([]string, numRows)\nfor i < size {\n\tfor j := 0; j < numRows && i < size; j++ {\n\t\tss[j] += string(s[i])\n\t\ti++\n\t}\n\tfor j := numRows - 2; j > 0 && i < size; j-- {\n\t\tss[j] += string(s[i])\n\t\ti++\n\t}\n}\nvar ret string\nfor j := 0; j < numRows; j++ {\n\tret += ss[j]\n}\nreturn ret", "gen": "var s []string\nvar i int\nfor i = 0; i < len(s); i++ {\n\ts[i] = strconv.Itoa(i) + s[i]\n}\nfor i = 0; i < len(s); i++ {\n\ts[i] = strconv.Itoa(i) + s[i]\n}\nreturn\n}\n"}
{"tgt": "sum := big.NewInt(0)\nfor i := int64(1); i <= 1000; i++ {\n\tval := big.NewInt(i)\n\tsum.Add(sum, pow(val, i))\n}\nfmt.Println(\"STR\", sum.String())", "gen": "var a big.Int\na.SetInt64(1)\nfor i := int64(1); i < 1000; i++ {\n\ta.Add(&a, &a)\n}\nfmt.Println(a.String())\n}"}
{"tgt": "for l, r := 0, len(A)-1; ; {\n\tm := (l + r) / 2\n\tif A[m] < A[m+1] {\n\t\tl = m\n\t} else if A[m-1] > A[m] {\n\t\tr = m\n\t} else {\n\t\treturn m\n\t}\n}", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tif i < len(a) {\n\t\tif i < 0 {\n\t\t\tpanic(\"index out of range\")\n\t\t}\n\t\tif i >= len(a) {\n\t\t\tpanic(\"index out of range\")\n\t\t}\n\t}\n\tif i < len(a) {\n\t\tif i < 0 {\n\t\t\tpanic(\"index out of range\")\n\t\t}\n\t\tif i >= len(a) {\n\t\t\tpanic(\"index out of range\")\n\t\t}\n\t}\n\tif i < len(a) {\n\t\tif i < 0 {\n\t\t\tpanic(\"index out of range\")\n\t\t}\n\t\tif i >= len(a) {\n\t\t\tpanic(\"index out of range\")\n\t\t}\n\t}\n\tif i < len(a) {\n\t\tif i < 0 {\n\t\t\tpanic(\"index out of range\")\n\t\t}\n\t\tif i >= len(a) {\n\t\t\tpanic(\"index out of range\")\n\t\t}\n\t}\n\tif i < len(a) {\n\t\tif i < 0 {\n\t\t\tpanic(\"index out of range\")\n\t\t}\n\t\tif i >= len(a) {\n\t\t\tpanic(\"index out of range\")\n\t\t}\n\t}\n\tif i < len(a) {\n\t\tif i < 0 {\n\t\t\tpanic(\"index out of range\")\n\t\t}\n\t\tif i >= len(a) {\n\t\t\tpanic(\"index out of range\")\n\t\t}\n\t}"}
{"tgt": "max := 1000\nsum := 0\nfor i := 1; i < max; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)", "gen": "var a int\nfor i := 1; i < 1000; i++ {\n\tif i%2 == 0 {\n\t\ta += i\n\t} else {\n\t\ta += i * i\n\t}\n}\nfmt.Println(a)\n}\n"}
{"tgt": "if k < 0 || len(nums) == 0 {\n\treturn 0\n}\nvar count int\nm := make(map[int]int, len(nums))\nfor _, value := range nums {\n\tm[value]++\n}\nfor key := range m {\n\tif k == 0 && m[key] > 1 {\n\t\tcount++\n\t\tcontinue\n\t}\n\tif k > 0 && m[key+k] > 0 {\n\t\tcount++\n\t}\n}\nreturn count", "gen": "var m map[int][2]int\nvar i int\nvar j int\nvar k int\nvar v [2]int\nvar ok bool\nvar v0 int\nvar v1 int\nvar v2 int\nvar v3 int\nvar v4 int\nvar v5 int\nvar v6 int\nvar v7 int\nvar v8 int\nvar v9 int\nvar v10 int\nvar v11 int\nvar v12 int\nvar v13 int\nvar v14 int\nvar v15 int\nvar v16 int\nvar v17 int\nvar v18 int\nvar v19 int\nvar v20 int\nvar v21 int\nvar v22 int\nvar v23 int\nvar v24 int\nvar v25 int\nvar v26 int\nvar v27 int\nvar v28 int\nvar v29 int\nvar v30 int\nvar v31 int\nvar v32 int\nvar v33 int\nvar v34 int\nvar v35 int\nvar v36 int\nvar v37 int\nvar v38 int\nvar v39 int\nvar v40 int\nvar v41 int\nvar v42 int\nvar v43 int\nvar v44 int\nvar v45 int\nvar v46 int\nvar v47 int\nvar v48 int\nvar v49 int\nvar v50 int\nvar v51 int\nvar v52 int\nvar v53 int\nvar v54 int\nvar v55 int\nvar v56 int\nvar v57 int\nvar v58 int\nvar v59 int\nvar v60 int\nvar v61 int\nvar v62 int\nvar v63 int\nvar v64 int\nvar v65 int\nvar v66 int\nvar"}
{"tgt": "parentMap, countMap := make(map[int]int), make(map[int]int)\nfor _, num := range nums {\n\tif _, exists := parentMap[num]; exists {\n\t\tcontinue\n\t}\n\tparentMap[num], countMap[num] = num, 1\n\tneighbors := [2]int{num - 1, num + 1}\n\tfor _, n := range neighbors {\n\t\tif _, exists := parentMap[n]; exists {\n\t\t\tcount1 := countMap[getParent128(n, parentMap)]\n\t\t\tcount2 := countMap[getParent128(num, parentMap)]\n\t\t\tunion128(n, num, parentMap)\n\t\t\tcountMap[getParent128(num, parentMap)] = count1 + count2\n\t\t}\n\t}\n}\nmax := 0\nfor _, count := range countMap {\n\tif count > max {\n\t\tmax = count\n\t}\n}\nreturn max", "gen": "m := make(map[int]int)\nm2 := make(map[int]int)\nfor i := 0; i < 10; i++ {\n\tm[i] = i\n\tm2[i] = i\n}\nfor k, v := range m {\n\tif _, ok := m2[k]; ok {\n\t\tm2[k] = v\n\t}\n}\nfmt.Println(m2)\n}\n"}
{"tgt": "sort.Ints(people)\nthin, fat := 0, len(people)-1\nres := 0\nfor thin <= fat {\n\tif people[thin]+people[fat] <= limit {\n\t\tthin++\n\t}\n\tfat--\n\tres++\n}\nreturn res", "gen": "var a []int\nsort.Ints(a)\nvar b int\nb = a[0]\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   []int{1, 8, 6, 2, 5, 4, 8, 3, 7},\n\t\twant: 49,\n\t},\n\t{\n\t\tin:   []int{1, 8, 6, 30, 20, 6, 9, 10, 1},\n\t\twant: 48,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxArea(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "a := []int{1, 8, 6, 2, 5, 4, 8, 3, 7}\nb := []int{1, 8, 6, 30, 20, 6, 9, 10, 1}\nc := []int{1, 8, 6, 30, 20, 6, 9, 10, 1}\nmaxArea := maxArea(a, b, c)\nif maxArea != 49 {\n\tt.Fatalf(\"maxArea(%v, %v, %v) = %v; want %v\", a, b, c, maxArea, 49)\n}\n}\n"}
{"tgt": "count, k := make([]int, 128), len(s)/4\nfor _, v := range s {\n\tcount[int(v)]++\n}\nleft, right, res := 0, -1, len(s)\nfor left < len(s) {\n\tif count['Q'] > k || count['W'] > k || count['E'] > k || count['R'] > k {\n\t\tif right+1 < len(s) {\n\t\t\tright++\n\t\t\tcount[s[right]]--\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t} else {\n\t\tres = min(res, right-left+1)\n\t\tcount[s[left]]++\n\t\tleft++\n\t}\n}\nreturn res", "gen": "var s string\nvar t int\ns = \"leetcode\"\nt = 3\nfmt.Println(minWindow(s, t))\n}\n"}
{"tgt": "http.HandleFunc(\"STR\", handler)", "gen": "http.HandleFunc(\"/\", handler)\n}\n"}
{"tgt": "pairs := [...][2]int{{15, 26}, {1000, 1366}}\nfor _, pair := range pairs {\n\tin, out := pair[0], pair[1]\n\tif x := p16(in); x != out {\n\t\tt.Errorf(\"STR\", in, x, out)\n\t}\n}", "gen": "var a [2]int\nvar b [2]int\nvar c [2]int\nvar d [2]int\nvar e [2]int\nvar f [2]int\nvar g [2]int\nvar h [2]int\nvar i [2]int\nvar j [2]int\nvar k [2]int\nvar l [2]int\nvar m [2]int\nvar n [2]int\nvar o [2]int\nvar p [2]int\nvar q [2]int\nvar r [2]int\nvar s [2]int\nvar t [2]int\nvar u [2]int\nvar v [2]int\nvar w [2]int\nvar x [2]int\nvar y [2]int\nvar z [2]int\nvar aa [2]int\nvar ab [2]int\nvar ac [2]int\nvar ad [2]int\nvar ae [2]int\nvar af [2]int\nvar ag [2]int\nvar ah [2]int\nvar ai [2]int\nvar aj [2]int\nvar ak [2]int\nvar al [2]int\nvar am [2]int\nvar an [2]int\nvar ao [2]int\nvar ap [2]int\nvar aq [2]int\nvar ar [2]int\nvar as [2]int\nvar at [2]int\nvar au [2]int\nvar av [2]int\nvar aw [2]int\nvar ax [2]int\nvar ay [2]int\nvar az [2]int\nvar aaa [2]int\nvar aab [2]int\nvar aac [2]int\nvar aad [2]int\nvar aae [2]int\nvar aaf [2]int\nvar aag [2]int\nvar aah [2]int\nvar aai [2]int\n"}
{"tgt": "n := len(matrix)\nl, r := matrix[0][0], matrix[n-1][n-1]\nfor l < r {\n\tm := (l + r) / 2\n\tcount := 0\n\tfor i := 0; i < n; i++ {\n\t\tj := n - 1\n\t\tfor j >= 0 && matrix[i][j] > m {\n\t\t\tj--\n\t\t}\n\t\tcount += j + 1\n\t}\n\tif count < k {\n\t\tl = m + 1\n\t} else {\n\t\tr = m\n\t}\n}\nreturn l", "gen": "var a [3]int\nvar b int\nfor i := 0; i < len(a); i++ {\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tb = a[i]\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tb += a[i]\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tb += a[i]\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tb += a[i]\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tb += a[i]\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tb += a[i]\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tb += a[i]\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tb += a[i]\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tb += a[i]\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tb += a[i]\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tb += a[i]\n\tif i < 0 || i >= len(a) {\n\t\t"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tm: 3,\n\t\tn: 3,\n\t\tops: [][]int{\n\t\t\t{2, 2},\n\t\t\t{3, 3},\n\t\t},\n\t\twant: 4,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxCount(tt.m, tt.n, tt.ops)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.m, got, tt.want)\n\t}\n}", "gen": "var a [5]int\na[0] = 2\na[1] = 2\na[2] = 3\na[3] = 3\na[4] = 2\nvar b [5]int\nb[0] = 2\nb[1] = 2\nb[2] = 3\nb[3] = 3\nb[4] = 2\nvar c [5]int\nc[0] = 2\nc[1] = 2\nc[2] = 3\nc[3] = 3\nc[4] = 2\nvar d [5]int\nd[0] = 2\nd[1] = 2\nd[2] = 3\nd[3] = 3\nd[4] = 2\nvar e [5]int\ne[0] = 2\ne[1] = 2\ne[2] = 3\ne[3] = 3\ne[4] = 2\nvar f [5]int\nf[0] = 2\nf[1] = 2\nf[2] = 3\nf[3] = 3\nf[4] = 2\nvar g [5]int\ng[0] = 2\ng[1] = 2\ng[2] = 3\ng[3] = 3\ng[4] = 2\nvar h [5]int\nh[0] = 2\nh[1] = 2\nh[2] = 3\nh[3] = 3\nh[4] = 2\nvar i [5]int\ni[0] = 2\ni[1] = 2\ni[2] = 3\ni[3] = 3\ni[4] = 2\nvar j [5]int\nj[0] = 2\nj[1] ="}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif isPartite := IsBipartiteGraph(tc.g); isPartite != tc.isPartite {\n\t\tt.Errorf(\"STR\", tc.isPartite, isPartite)\n\t}\n}", "gen": "t := testing.T{}\nt.Parallel()\nfor i, test := range testcases {\n\tif IsBipartiteGraph(test.graph) != test.want {\n\t\tt.Errorf(\"IsBipartiteGraph(%v) = %v, want %v\", test.graph, IsBipartiteGraph(test.graph), test.want)\n\t}\n}\n}\n"}
{"tgt": "var i int\nlength := len(nums)\nif length <= 1 {\n\treturn\n}\nfor i = length - 1; i >= 1; i-- {\n\tif nums[i] > nums[i-1] {\n\t\tbreak\n\t}\n}\nif i > 0 {\n\tsort.Ints(nums[i:])\n\tfor j := i - 1; j < length; j++ {\n\t\tif nums[j] > nums[i-1] {\n\t\t\tnums[i-1], nums[j] = nums[j], nums[i-1]\n\t\t\treturn\n\t\t}\n\t}\n}\nsort.Ints(nums)", "gen": "var a []int\nfor i := 0; i < len(a); i++ {\n\tif i < len(a) {\n\t\tif i > 0 {\n\t\t\tif i < len(a) {\n\t\t\t\tif i > 0 {\n\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\tif i > 0 {\n\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\tif i > 0 {\n\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\tif i > 0 {\n\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i"}
{"tgt": "return LoadUint64(&r.Reg)", "gen": "var x uint64\nx = 0\nif x == 0 {\n\tpanic(\"runtime: out of memory\")\n}\n}\n\n// 0000000000000000 <main>:\n// \t.cfi_startproc\n// \t.cfi_personality 0x0,__gxx_personality_v0\n// \t.cfi_lsda 0x1,__gxx_personality_v0\n// \t.file 1 \"test.go\"\n// \t.loc 1 1 0\n// \t.loc 1 1 10\n// \tpushq %rbp\n// \tmovq %rsp,%rbp\n// \tsubq $0x20,%rsp\n// \tmovq %rdi,-0x18(%rbp)\n// \tmovq $0,-0x8(%rbp)\n// \t.loc 1 2 0\n// \tmovq -0x18(%rbp),%rax\n// \tmovq %rax,%rdi\n// \tcall <go.volatile.LoadUint64@PLT>\n// \tmovq %rax,-0x8(%rbp)\n// \tmovq -0x8(%rbp),%rax\n// \tleave\n// \tret\n// \t.size main, .-main\n// \t.cfi_endproc\n// \t.section .note.GNU-stack,\"\",@progbits\n\n// 0000000000000000 <main>:\n// \t.cfi_startproc\n// \t.cfi_personality 0x0,__gxx_personality_v0\n// \t.cfi_lsda 0x1,__gxx_personality_v0\n// \t.file 1 \"test.go\"\n// \t.loc 1 1 0\n// \t.loc 1 1 10\n// \tpushq %rbp\n"}
{"tgt": "var tests = []struct {\n\tnumber int\n\ttitle  string\n}{\n\t{1, \"STR\"},\n\t{28, \"STR\"},\n\t{701, \"STR\"},\n}\nfor _, tt := range tests {\n\ttitle := convertToTitle(tt.number)\n\tif title != tt.title {\n\t\tt.Errorf(\"STR\", tt.number, title, tt.title)\n\t}\n}", "gen": "var s = Solution{}\nvar t = []struct {\n\tnum int\n\texp string\n}{\n\t{1, \"A\"},\n\t{28, \"AB\"},\n\t{701, \"ZY\"},\n}\nfor _, v := range t {\n\tvar ret = s.convertToTitle(v.num)\n\tif ret != v.exp {\n\t\tt.Errorf(\"num: %d, expect: %s, got: %s\", v.num, v.exp, ret)\n\t}\n}\n}\n"}
{"tgt": "empty := countBucket{}\nfor i, _ := range ss.olist {\n\tdelete(ss.hash, ss.olist[i].key)\n\tss.olist[i] = empty\n}", "gen": "m := make(map[string]uint32)\nfor i := 0; i < 1000000; i++ {\n\tm[strconv.Itoa(i)] = uint32(i)\n}\nfor i := 0; i < 1000000; i++ {\n\tdelete(m, strconv.Itoa(i))\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tresult := EloGames(tc.scores, tc.kFactor, tc.matches)\n\tfor i := range result {\n\t\tresult[i] = math.Round(result[i]*tc.tolerance) / tc.tolerance\n\t}\n\tif !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t := testing.T{}\nt.Parallel()\nfor i := 0; i < len(testcases); i++ {\n\tif i == 0 {\n\t\tcontinue\n\t}\n\tif i == 1 {\n\t\tcontinue\n\t}\n\tif i == 2 {\n\t\tcontinue\n\t}\n\tif i == 3 {\n\t\tcontinue\n\t}\n\tif i == 4 {\n\t\tcontinue\n\t}\n\tif i == 5 {\n\t\tcontinue\n\t}\n\tif i == 6 {\n\t\tcontinue\n\t}\n\tif i == 7 {\n\t\tcontinue\n\t}\n\tif i == 8 {\n\t\tcontinue\n\t}\n\tif i == 9 {\n\t\tcontinue\n\t}\n\tif i == 10 {\n\t\tcontinue\n\t}\n\tif i == 11 {\n\t\tcontinue\n\t}\n\tif i == 12 {\n\t\tcontinue\n\t}\n\tif i == 13 {\n\t\tcontinue\n\t}\n\tif i == 14 {\n\t\tcontinue\n\t}\n\tif i == 15 {\n\t\tcontinue\n\t}\n\tif i == 16 {\n\t\tcontinue\n\t}\n\tif i == 17 {\n\t\tcontinue\n\t}\n\tif i == 18 {\n\t\tcontinue\n\t}\n\tif i == 19 {\n\t\tcontinue\n\t}\n\tif i == 20 {\n\t\tcontinue\n\t}\n\tif i == 21 {\n\t\tcontinue\n\t}\n\tif i == 22 {\n\t\tcontinue\n\t}\n\tif i == 23 {\n\t\tcontinue\n\t}\n\tif i == 24 {\n\t\tcontinue\n\t}\n\t"}
{"tgt": "l.insert(e, &l.root)", "gen": "heap := fibHeapElementList{}\nheap.insert(8, 0)\n}\n\n// \u6808\u4e0a\u5206\u914d"}
{"tgt": "if root == nil {\n\treturn 0\n}\nmax := height(root.Left)\nif h := height(root.Right); h > max {\n\tmax = h\n}\nreturn max + 1", "gen": "root := &TreeNode{Val: 1, Left: &TreeNode{Val: 2}, Right: &TreeNode{Val: 3}}\nfmt.Println(maxDepth(root))\n}\n"}
{"tgt": "qs := []question598{\n\t{\n\t\tpara598{3, 3, [][]int{{2, 2}, {3, 3}}},\n\t\tans598{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans598, q.para598\n\tfmt.Printf(\"STR\", p, maxCount(p.m, p.n, p.ops))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(maxCount(5, [3]int{2, 3, 4}))\n}\n"}
{"tgt": "var tests = []struct {\n\tnums    []int\n\ttarget  int\n\tindices []int\n}{\n\t{[]int{2, 7, 11, 15}, 9, []int{0, 1}},\n\t{[]int{2, 3, 4, 6}, 6, []int{0, 2}},\n\t{[]int{2, 3, 4, 7}, 8, nil},\n\t{nil, 8, nil},\n}\nfor _, tt := range tests {\n\tindices := twoSum(tt.nums, tt.target)\n\tif reflect.DeepEqual(indices, tt.indices) == false {\n\t\tt.Errorf(\"STR\", tt.nums, tt.target, indices, tt.indices)\n\t}\n}", "gen": "fmt.Println(twoSum([]int{2, 7, 11, 15}, 9))\nfmt.Println(twoSum([]int{3, 2, 4}, 6))\nfmt.Println(twoSum([]int{3, 3}, 6))\n}\n"}
{"tgt": "if isSquare(n) {\n\treturn 1\n}\nfor n%4 == 0 {\n\tn /= 4\n}\nif n%8 == 7 {\n\treturn 4\n}\nfor i := 1; i <= mySqrt(n); i++ {\n\tif isSquare(n - i*i) {\n\t\treturn 2\n\t}\n}\nreturn 3", "gen": "fmt.Println(isSquare(2))\nfmt.Println(isSquare(3))\nfmt.Println(isSquare(4))\nfmt.Println(isSquare(5))\nfmt.Println(isSquare(6))\nfmt.Println(isSquare(7))\nfmt.Println(isSquare(8))\nfmt.Println(isSquare(9))\nfmt.Println(isSquare(10))\nfmt.Println(isSquare(11))\nfmt.Println(isSquare(12))\nfmt.Println(isSquare(13))\nfmt.Println(isSquare(14))\nfmt.Println(isSquare(15))\nfmt.Println(isSquare(16))\nfmt.Println(isSquare(17))\nfmt.Println(isSquare(18))\nfmt.Println(isSquare(19))\nfmt.Println(isSquare(20))\nfmt.Println(isSquare(21))\nfmt.Println(isSquare(22))\nfmt.Println(isSquare(23))\nfmt.Println(isSquare(24))\nfmt.Println(isSquare(25))\nfmt.Println(isSquare(26))\nfmt.Println(isSquare(27))\nfmt.Println(isSquare(28))\nfmt.Println(isSquare(29))\nfmt.Println(isSquare(30))\nfmt.Println(isSquare(31))\nfmt.Println(isSquare(32))\nfmt.Println(isSquare(33))\nfmt.Println(isSquare(34))\nfmt.Println(isSquare(35))\nfmt.Println(isSquare(36))\nfmt.Println(isSquare(37))\nfmt.Print"}
{"tgt": "if N < 3 {\n\treturn N\n} else if N == 3 {\n\treturn 5\n}\nmod := 1000000007\ndp := make([]int, N+1)\ndp[1], dp[2], dp[3] = 1, 2, 5\nfor i := 4; i <= N; i++ {\n\tdp[i] = 2*dp[i-1] + dp[i-3]\n\tdp[i] %= mod\n}\nreturn dp[N]", "gen": "var n int\nfmt.Scan(&n)\nif n == 2 {\n\tfmt.Println(0)\n\treturn\n}\nif n == 3 {\n\tfmt.Println(5)\n\treturn\n}\nif n > 3 {\n\tvar a [1000000007]int\n\ta[1] = 1\n\ta[2] = 2\n\tfor i := 3; i < n; i++ {\n\t\ta[i] = (a[i-1] + a[i-2]) % 1000000007\n\t}\n\tfmt.Println(a[n-1])\n\treturn\n}\npanic(\"unreachable\")\n}\n"}
{"tgt": "stack := []byte{}\nfor i := range num {\n\tdigit := num[i]\n\tfor k > 0 && len(stack) > 0 && digit < stack[len(stack)-1] {\n\t\tstack = stack[:len(stack)-1]\n\t\tk--\n\t}\n\tstack = append(stack, digit)\n}\nstack = stack[:len(stack)-k]\nans := strings.TrimLeft(string(stack), \"STR\")\nif ans == \"STR\" {\n\tans = \"STR\"\n}\nreturn ans", "gen": "var s []byte\nfor i := 0; i < len(s); i++ {\n\tif i < len(s) {\n\t\tif i >= 0 {\n\t\t\tif i < len(s) {\n\t\t\t\tif i >= 0 {\n\t\t\t\t\tif i < len(s) {\n\t\t\t\t\t\tif i >= 0 {\n\t\t\t\t\t\t\tif i < len(s) {\n\t\t\t\t\t\t\t\tif i >= 0 {\n\t\t\t\t\t\t\t\t\tif i < len(s) {\n\t\t\t\t\t\t\t\t\t\tif i >= 0 {\n\t\t\t\t\t\t\t\t\t\t\tif i < len(s) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i >= 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(s) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i >= 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(s) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i >= 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(s) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i >= 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(s) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i >= 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(s) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i >= 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i"}
{"tgt": "if e.element.list != &b.freeList {\n\tpanic(\"STR\")\n}\nif !e.expire.IsZero() {\n\theap.Push(&b.priorityQueue, e)\n}\nb.freeList.Remove(&e.element)\nb.lruList.PushElementFront(&e.element)\nb.table[e.key] = e", "gen": "var m = New(100)\nm.Set(\"hello\", \"world\")\nm.Set(\"a\", \"b\")\nm.Set(\"c\", \"d\")\nm.Set(\"e\", \"f\")\nm.Set(\"g\", \"h\")\nm.Set(\"i\", \"j\")\nm.Set(\"k\", \"l\")\nm.Set(\"m\", \"n\")\nm.Set(\"o\", \"p\")\nm.Set(\"q\", \"r\")\nm.Set(\"s\", \"t\")\nm.Set(\"u\", \"v\")\nm.Set(\"w\", \"x\")\nm.Set(\"y\", \"z\")\nm.Set(\"a\", \"b\")\nm.Set(\"c\", \"d\")\nm.Set(\"e\", \"f\")\nm.Set(\"g\", \"h\")\nm.Set(\"i\", \"j\")\nm.Set(\"k\", \"l\")\nm.Set(\"m\", \"n\")\nm.Set(\"o\", \"p\")\nm.Set(\"q\", \"r\")\nm.Set(\"s\", \"t\")\nm.Set(\"u\", \"v\")\nm.Set(\"w\", \"x\")\nm.Set(\"y\", \"z\")\nm.Set(\"a\", \"b\")\nm.Set(\"c\", \"d\")\nm.Set(\"e\", \"f\")\nm.Set(\"g\", \"h\")\nm.Set(\"i\", \"j\")\nm.Set(\"k\", \"l\")\nm.Set(\"m\", \"n\")\nm.Set(\"o\", \"p\")\nm.Set(\"q\", \"r\")\nm.Set(\"s\", \"t\")\nm.Set(\"u\", \"v\")\nm.Set(\"w\", \"x\")\nm.Set(\"y\", \"z\")\nm.Set(\"a\", \"b\")\nm.Set(\"c\", \"d\")\nm.Set(\"e\", \"f\")\nm.Set(\"g\", \"h\")\nm.Set(\""}
{"tgt": "in := make([]int, N)\nout := make([]int, N)\nfor _, pair := range trust {\n\tout[pair[0]-1]++\n\tin[pair[1]-1]++\n}\nfor i := 0; i < N; i++ {\n\tif in[i] == N-1 && out[i] == 0 {\n\t\treturn i + 1\n\t}\n}\nreturn -1", "gen": "var a []int\nvar b []int\nvar c []int\nvar d []int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar A []int\nvar B []int\nvar C []int\nvar D []int\nvar E int\nvar F int\nvar G int\nvar H int\nvar I int\nvar J int\nvar K int\nvar L int\nvar M int\nvar N int\nvar O int\nvar P int\nvar Q int\nvar R int\nvar S int\nvar T int\nvar U int\nvar V int\nvar W int\nvar X int\nvar Y int\nvar Z int\nfor i := 0; i < len(a); i++ {\n\tif i < len(b) {\n\t\tif i > 0 {\n\t\t\tif i < len(c) {\n\t\t\t\tif i < len(d) {\n\t\t\t\t\tif i > 0 {\n\t\t\t\t\t\tif i < len(e) {\n\t\t\t\t\t\t\tif i < len(f) {\n\t\t\t\t\t\t\t\tif i < len(g) {\n\t\t\t\t\t\t\t\t\tif i < len(h) {\n\t\t\t\t\t\t\t\t\t\tif i < len(i) {\n\t\t\t\t\t\t\t\t\t\t\tif i < len(j) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i < len(k) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(l)"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs int\n\texpect int\n}{\n\t{\"STR\", 2, 1},\n\t{\"STR\", 3, 2},\n\t{\"STR\", 4, 3},\n\t{\"STR\", 0, 0},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "sol := Solution{}\nsol.TestSolution([]int{1, 2, 3}, 3)\n}\n"}
{"tgt": "return xtime.Unix(int64(jt), 0), nil", "gen": "var t time.Time\nt = time.Unix(0, 0)\nvar t2 time.Time\nt2 = time.Time{}\nvar t3 time.Time\nt3 = time.Time{}\nvar t4 time.Time\nt4 = time.Time{}\nvar t5 time.Time\nt5 = time.Time{}\nvar t6 time.Time\nt6 = time.Time{}\nvar t7 time.Time\nt7 = time.Time{}\nvar t8 time.Time\nt8 = time.Time{}\nvar t9 time.Time\nt9 = time.Time{}\nvar t10 time.Time\nt10 = time.Time{}\nvar t11 time.Time\nt11 = time.Time{}\nvar t12 time.Time\nt12 = time.Time{}\nvar t13 time.Time\nt13 = time.Time{}\nvar t14 time.Time\nt14 = time.Time{}\nvar t15 time.Time\nt15 = time.Time{}\nvar t16 time.Time\nt16 = time.Time{}\nvar t17 time.Time\nt17 = time.Time{}\nvar t18 time.Time\nt18 = time.Time{}\nvar t19 time.Time\nt19 = time.Time{}\nvar t20 time.Time\nt20 = time.Time{}\nvar t21 time.Time\nt21 = time.Time{}\nvar t22 time.Time\nt22 = time.Time{}\nvar t23 time.Time\nt23 = time.Time{}\nvar t24 time.Time\nt24 = time.Time{}\nvar t25 time.Time\nt25 = time.Time{}\nvar t26 time.Time\nt26 = time.Time{}\nvar t27 time.Time\nt27 = time.Time{}\n"}
{"tgt": "if len(name) == 0 && len(typed) == 0 {\n\treturn true\n}\nif (len(name) == 0 && len(typed) != 0) || (len(name) != 0 && len(typed) == 0) {\n\treturn false\n}\nj := 0\nfor i := 0; i < len(name); i++ {\n\tif j < len(typed) && name[i] == typed[j] {\n\t\tj++\n\t\tcontinue\n\t} else {\n\t\tif i > 0 && j < len(typed) && name[i-1] == typed[j] {\n\t\t\tj++\n\t\t\ti--\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "var a [2]int\nvar b [2]int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar A int\nvar B int\nvar C int\nvar D int\nvar E int\nvar F int\nvar G int\nvar H int\nvar I int\nvar J int\nvar K int\nvar L int\nvar M int\nvar N int\nvar O int\nvar P int\nvar Q int\nvar R int\nvar S int\nvar T int\nvar U int\nvar V int\nvar W int\nvar X int\nvar Y int\nvar Z int\nvar a1 int\nvar b1 int\nvar c1 int\nvar d1 int\nvar e1 int\nvar f1 int\nvar g1 int\nvar h1 int\nvar i1 int\nvar j1 int\nvar k1 int\nvar l1 int\nvar m1 int\nvar n1 int\nvar o1 int\nvar p1 int\nvar q1 int\nvar r1 int\nvar s1 int\nvar t1 int\nvar u1 int\nvar v1 int\nvar w1 int\nvar x1 int\nvar y1 int\nvar z1 int\nvar A1 int\nvar B1 int\nvar C1 int\nvar D1 int\nvar E1 int\nvar F1 int\nvar G1 int\nvar H1 int\nvar I1 int\nvar J1 int\nvar K1 int\nvar L1 int\nvar M1 int\n"}
{"tgt": "var i, j, tmp int\nfor i = 1; i < len(arr); i++ {\n\ttmp = arr[i]\n\tfor j = i; j > 0 && arr[j-1] > tmp; j-- {\n\t\tarr[j] = arr[j-1]\n\t}\n\tarr[j] = tmp\n}\nreturn arr", "gen": "var a [3]int\nvar i int\nvar j int\nfor i = 0; i < len(a); i++ {\n\tj = i\n\ta[j] = a[i]\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "res = [][]string{}\nif len(s) < 1 {\n\treturn res\n}\nhelper(s, 0, []string{})\nreturn res", "gen": "var res string\nres = \"hello\"\nif res == \"\" {\n\tres = \"world\"\n}\nfmt.Println(res)\n}\n"}
{"tgt": "if from == to {\n\treturn errors.New(\"STR\")\n}\nif !g.CheckVertex(from) || !g.CheckVertex(to) {\n\treturn errors.New(\"STR\")\n}\ni, _ := g.edges[from][to]\nj, _ := g.edges[to][from]\nif i > 0 || j > 0 {\n\treturn errors.New(\"STR\")\n}\ng.TouchVertex(from)\ng.TouchVertex(to)\ng.edges[from][to] = weight\nif !g.isDirected {\n\tg.edges[to][from] = weight\n}\ng.edgesCount++\nreturn nil", "gen": "g := graph.NewGraph()\ng.AddVertex(1)\ng.AddVertex(2)\ng.AddVertex(3)\ng.AddVertex(4)\ng.AddVertex(5)\ng.AddVertex(6)\ng.AddVertex(7)\ng.AddVertex(8)\ng.AddVertex(9)\ng.AddVertex(10)\ng.AddVertex(11)\ng.AddVertex(12)\ng.AddVertex(13)\ng.AddVertex(14)\ng.AddVertex(15)\ng.AddVertex(16)\ng.AddVertex(17)\ng.AddVertex(18)\ng.AddVertex(19)\ng.AddVertex(20)\ng.AddVertex(21)\ng.AddVertex(22)\ng.AddVertex(23)\ng.AddVertex(24)\ng.AddVertex(25)\ng.AddVertex(26)\ng.AddVertex(27)\ng.AddVertex(28)\ng.AddVertex(29)\ng.AddVertex(30)\ng.AddVertex(31)\ng.AddVertex(32)\ng.AddVertex(33)\ng.AddVertex(34)\ng.AddVertex(35)\ng.AddVertex(36)\ng.AddVertex(37)\ng.AddVertex(38)\ng.AddVertex(39)\ng.AddVertex(40)\ng.AddVertex(41)\ng.AddVertex(42)\ng.AddVertex(43)\ng.AddVertex(44)\ng.AddVertex(45)\ng.AddVertex(46)\ng.AddVertex(47)\ng.AddVertex(48)\ng.AddVertex(49)\ng.AddVertex(50)\n"}
{"tgt": "i := 0\ndefer fmt.Println(\"STR\", i)\ndefer fmt.Println(\"STR\")\ndefer fmt.Println(\"STR\")\ni++\nfmt.Println(\"STR\", i)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\n"}
{"tgt": "maxIndex := [26]int{}\nfor i, b := range S {\n\tmaxIndex[b-'a'] = i\n}\nbegin := 0\nend := maxIndex[S[begin]-'a']\nres := make([]int, 0, len(S))\nfor i, b := range S {\n\tif i < end {\n\t\tend = max(end, maxIndex[b-'a'])\n\t\tcontinue\n\t}\n\tres = append(res, i-begin+1)\n\tbegin = i + 1\n\tif begin < len(S) {\n\t\tend = maxIndex[S[begin]-'a']\n\t}\n}\nreturn res", "gen": "var s string\nvar t []int\nfor _, r := range s {\n\tif r == 'a' {\n\t\tt = append(t, 1)\n\t} else if r == 'b' {\n\t\tt = append(t, 2)\n\t} else if r == 'c' {\n\t\tt = append(t, 3)\n\t} else if r == 'd' {\n\t\tt = append(t, 4)\n\t} else if r == 'e' {\n\t\tt = append(t, 5)\n\t} else if r == 'f' {\n\t\tt = append(t, 6)\n\t} else if r == 'g' {\n\t\tt = append(t, 7)\n\t} else if r == 'h' {\n\t\tt = append(t, 8)\n\t} else if r == 'i' {\n\t\tt = append(t, 9)\n\t} else if r == 'j' {\n\t\tt = append(t, 10)\n\t} else if r == 'k' {\n\t\tt = append(t, 11)\n\t} else if r == 'l' {\n\t\tt = append(t, 12)\n\t} else if r == 'm' {\n\t\tt = append(t, 13)\n\t} else if r == 'n' {\n\t\tt = append(t, 14)\n\t} else if r == 'o' {\n\t\tt = append(t, 15)\n\t} else if r == 'p' {\n\t\tt = append(t, 16)\n\t} else if r == 'q' {\n\t\tt = append(t, 17)\n\t} else if r == 'r' {\n\t\tt = append(t, 18)\n\t} else if r == 's' {\n\t\tt = append(t, 1"}
{"tgt": "FirstNumber := 1\nSecondNumber := 2\nnextNumber := 0\nsum := SecondNumber\nfor nextNumber < 4000000 {\n\tnextNumber = FirstNumber + SecondNumber\n\tif nextNumber%2 == 0 {\n\t\tsum = sum + nextNumber\n\t}\n\tFirstNumber = SecondNumber\n\tSecondNumber = nextNumber\n}\nfmt.Println(\"STR\", sum, \"STR\")", "gen": "var a, b int\nfor i := 0; i < 4000000; i++ {\n\tif i&1 == 0 {\n\t\ta += b\n\t}\n\tb = a + i\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{2},\n\t\t\t{3, 4},\n\t\t\t{6, 5, 7},\n\t\t\t{4, 1, 8, 3},\n\t\t},\n\t\t11},\n\t{\"STR\",\n\t\t[][]int{\n\t\t\t{1},\n\t\t\t{2, 3},\n\t\t},\n\t\t3},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := minimumTotal(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.TestSolution()\n}\n"}
{"tgt": "timeDelta := now.Sub(r.lastTimestamp)\nreturn r.Ewma.Update(nanosec/float64(timeDelta.Nanoseconds()), now)", "gen": "var ewma ewma.Ewma\nvar t time.Time\nvar d time.Duration\nvar n int64\nvar v float64\nvar i int64\nvar j int64\nvar k int64\nvar l int64\nvar m int64\nvar n int64\nvar o int64\nvar p int64\nvar q int64\nvar r int64\nvar s int64\nvar t int64\nvar u int64\nvar v int64\nvar w int64\nvar x int64\nvar y int64\nvar z int64\nvar a int64\nvar b int64\nvar c int64\nvar d int64\nvar e int64\nvar f int64\nvar g int64\nvar h int64\nvar i int64\nvar j int64\nvar k int64\nvar l int64\nvar m int64\nvar n int64\nvar o int64\nvar p int64\nvar q int64\nvar r int64\nvar s int64\nvar t int64\nvar u int64\nvar v int64\nvar w int64\nvar x int64\nvar y int64\nvar z int64\nvar a int64\nvar b int64\nvar c int64\nvar d int64\nvar e int64\nvar f int64\nvar g int64\nvar h int64\nvar i int64\nvar j int64\nvar k int64\nvar l int64\nvar m int64\nvar n int64\nvar o int64\nvar p int64\nvar q int64\nvar r int64\nvar s int64\nvar t int64\nvar u int64\nvar v int"}
{"tgt": "if list.head == nil {\n\treturn false\n}\nif list.head.data == i {\n\tlist.head = list.head.next\n\treturn true\n}\ncurrent := list.head\nfor current.next != nil {\n\tif current.next.data == i {\n\t\tcurrent.next = current.next.next\n\t\treturn true\n\t}\n\tcurrent = current.next\n}\nreturn false", "gen": "var a *[2]int\nvar b int\nif a == nil {\n\treturn\n}\nif a[0] == b {\n\treturn\n}\nif a[1] == b {\n\treturn\n}\na[0] = b\na[1] = b\nreturn\n}\n\nTEXT main.main(SB), $0-8\nMOVQ a+0(FP), AX\nTESTQ AX, AX\nJE .L2\nMOVQ AX, CX\nMOVQ (CX), CX\nMOVQ (CX), CX\nCMPQ CX, b+8(FP)\nJNE .L3\nRET\n.L3:\nMOVQ AX, CX\nMOVQ (CX), CX\nMOVQ 8(CX), CX\nMOVQ (CX), CX\nCMPQ CX, b+8(FP)\nJNE .L4\nRET\n.L4:\nMOVQ AX, CX\nMOVQ -8(CX), CX\nMOVQ (CX), CX\nMOVQ (CX), CX\nCMPQ CX, b+8(FP)\nJNE .L5\nRET\n.L5:\nMOVQ AX, CX\nMOVQ -8(CX), CX\nMOVQ 8(CX), CX\nMOVQ (CX), CX\nCMPQ CX, b+8(FP)\nJNE .L6\nRET\n.L6:\nMOVQ AX, CX\nMOVQ -8(CX), CX\nMOVQ 8(CX), CX\nMOVQ (CX), CX\nCMPQ CX, b+8(FP)\nJNE .L7\nRET\n.L7:\nMOVQ AX, CX"}
{"tgt": "mySet := make(map[int]int, 0)\nfor _, v := range candies {\n\tmySet[v]++\n}\nif len(mySet) >= len(candies)/2 {\n\treturn len(candies) / 2\n}\nreturn len(mySet)", "gen": "m := make(map[int]int)\nfor i := 0; i < 100; i++ {\n\tm[i] = i + 1\n}\nvar sum int\nfor k := range m {\n\tsum += m[k]\n}\nif sum != 5050 {\n\tpanic(\"bad\")\n}\n}\n\n// func main() {\n// \tm := make(map[int]int)\n// \tfor i := 0; i < 100; i++ {\n// \t\tm[i] = i + 1\n// \t}\n// \tvar sum int\n// \tfor k := range m {\n// \t\tsum += m[k]\n// \t}\n// \tif sum != 5050 {\n// \t\tpanic(\"bad\")\n// \t}\n// }\n\n// func main() {\n// \tm := make(map[int]int)\n// \tfor i := 0; i < 100; i++ {\n// \t\tm[i] = i + 1\n// \t}\n// \tvar sum int\n// \tfor k := range m {\n// \t\tsum += m[k]\n// \t}\n// \tif sum != 5050 {\n// \t\tpanic(\"bad\")\n// \t}\n// }\n\n// func main() {\n// \tm := make(map[int]int)\n// \tfor i := 0; i < 100; i++ {\n// \t\tm[i] = i + 1\n// \t}\n// \tvar sum int\n// \tfor k := range m {\n// \t\tsum += m[k]\n// \t}\n// \tif sum != 5050 {\n// \t\tpanic(\"bad\")\n// \t}\n// }\n\n// func main() {\n// \tm := make(map[int]int)\n// \tfor i := 0; i < 1"}
{"tgt": "a := []float64{1, 2, 3, 4, 5, 6}\nA := MakeMatrix(a, 3, 2)\nif A.cols != 2 ||\n\tA.rows != 3 ||\n\t!FloatArrayEquals(A.Elements, a) {\n\tt.Error()\n}", "gen": "m := matrix.MakeMatrix(2, 3)\nm[0][0] = 1.0\nm[0][1] = 2.0\nm[0][2] = 3.0\nm[1][0] = 4.0\nm[1][1] = 5.0\nm[1][2] = 6.0\nif !matrix.FloatArrayEquals(m[0], []float64{1.0, 2.0, 3.0}) {\n\tt.Error(\"m[0] != [1.0, 2.0, 3.0]\")\n}\nif !matrix.FloatArrayEquals(m[1], []float64{4.0, 5.0, 6.0}) {\n\tt.Error(\"m[1] != [4.0, 5.0, 6.0]\")\n}\nif m.Rows != 2 {\n\tt.Error(\"m.Rows != 2\")\n}\nif m.Cols != 3 {\n\tt.Error(\"m.Cols != 3\")\n}\n}\n"}
{"tgt": "count := 0\nfor _, c := range word {\n\tif unicode.IsUpper(c) {\n\t\tcount++\n\t}\n}\nreturn count == 0 || count == len(word) || (count == 1 && unicode.IsUpper(rune(word[0])))", "gen": "var s string\nvar c int\nvar u bool\nfor i := 0; i < len(s); i++ {\n\tif i == 0 {\n\t\tu = unicode.IsUpper(s[i])\n\t}\n\tif s[i] == 127 {\n\t\tpanic(\"\")\n\t}\n\tc, _ = utf8.DecodeRuneInString(s[i:])\n\tif unicode.IsUpper(s[i]) {\n\t\tu = true\n\t}\n}\nif len(s) == 0 {\n\treturn\n}\nif len(s) == 1 {\n\tif unicode.IsUpper(s[0]) {\n\t\tu = true\n\t}\n}\nif len(s) > 1 {\n\tif s[0] == 127 {\n\t\tpanic(\"\")\n\t}\n\tc, _ = utf8.DecodeRuneInString(s[0:])\n\tif unicode.IsUpper(s[0]) {\n\t\tu = true\n\t}\n}\nif u {\n\treturn\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "p.mu.Lock()\nactive := p.active\np.mu.Unlock()\nreturn active", "gen": "var m sync.Mutex\nvar x int\nm.Lock()\nx = 44\nm.Unlock()\nreturn x\n}\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 44\n// \tm.Unlock()\n// \treturn x\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 44\n// \tm.Unlock()\n// \treturn x\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 44\n// \tm.Unlock()\n// \treturn x\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 44\n// \tm.Unlock()\n// \treturn x\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 44\n// \tm.Unlock()\n// \treturn x\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 44\n// \tm.Unlock()\n// \treturn x\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 44\n// \tm.Unlock()\n// \treturn x\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tx = 4"}
{"tgt": "select {\ncase r, ok := <-p.resources:\n\tlog.Println(\"STR\", \"STR\")\n\tif !ok {\n\t\treturn nil, ErrPoolClosed\n\t}\n\treturn r, nil\ndefault:\n\tlog.Println(\"STR\", \"STR\")\n\treturn p.factory()\n}", "gen": "var c chan int\nvar v int\nselect {\ncase v = <-c:\n\tlog.Println(\"v:\", v)\ndefault:\n\tlog.Println(\"default\")\n}\n}\n"}
{"tgt": "err := ioutil.WriteFile(path, []byte(content), 0755)\nif err != nil {\n\tlog.Fatal(err)\n}", "gen": "var s string\nvar b []byte\nvar err error\ns = \"hello\"\nb = []byte(s)\nerr = ioutil.WriteFile(\"hello.txt\", b, 0644)\nif err != nil {\n\tlog.Fatal(err)\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "tree := New(compare)\ntree.Insert(1)\ntree.Insert(2)\ntree.Insert(3)\nfindTree := tree.Search(2)\nif findTree.node != 2 {\n\tt.Error(\"STR\")\n}\nfindNilTree := tree.Search(100)\nif findNilTree != nil {\n\tt.Error(\"STR\")\n}", "gen": "tree := New()\ntree.Insert(1)\ntree.Insert(2)\ntree.Insert(3)\nif tree.Search(1) == 1 {\n\tt.Error(\"1 should not be in the tree\")\n}\nif tree.Search(2) == 2 {\n\tt.Error(\"2 should not be in the tree\")\n}\nif tree.Search(3) == 3 {\n\tt.Error(\"3 should not be in the tree\")\n}\nif tree.Search(4) != nil {\n\tt.Error(\"4 should not be in the tree\")\n}\n}\n"}
{"tgt": "l := new(ListNode)\nn := l\nvar extra int\nfor l1 != nil || l2 != nil {\n\tn.Next = new(ListNode)\n\tn = n.Next\n\tif l1 != nil {\n\t\textra += l1.Val\n\t\tl1 = l1.Next\n\t}\n\tif l2 != nil {\n\t\textra += l2.Val\n\t\tl2 = l2.Next\n\t}\n\tn.Val = extra % 10\n\textra /= 10\n}\nif extra > 0 {\n\tn.Next = &ListNode{Val: extra}\n}\nreturn l.Next", "gen": "var l1 *ListNode\nvar l2 *ListNode\nvar l3 *ListNode\nvar l4 *ListNode\nvar l5 *ListNode\nvar l6 *ListNode\nvar l7 *ListNode\nvar l8 *ListNode\nvar l9 *ListNode\nvar l10 *ListNode\nvar l11 *ListNode\nvar l12 *ListNode\nvar l13 *ListNode\nvar l14 *ListNode\nvar l15 *ListNode\nvar l16 *ListNode\nvar l17 *ListNode\nvar l18 *ListNode\nvar l19 *ListNode\nvar l20 *ListNode\nvar l21 *ListNode\nvar l22 *ListNode\nvar l23 *ListNode\nvar l24 *ListNode\nvar l25 *ListNode\nvar l26 *ListNode\nvar l27 *ListNode\nvar l28 *ListNode\nvar l29 *ListNode\nvar l30 *ListNode\nvar l31 *ListNode\nvar l32 *ListNode\nvar l33 *ListNode\nvar l34 *ListNode\nvar l35 *ListNode\nvar l36 *ListNode\nvar l37 *ListNode\nvar l38 *ListNode\nvar l39 *ListNode\nvar l40 *ListNode\nvar l41 *ListNode\nvar l42 *ListNode\nvar l43 *ListNode\nvar l44 *ListNode\nvar l45 *ListNode\nvar l46 *ListNode\nvar l47 *ListNode\nvar l48 *ListNode\nvar l49 *ListNode\nvar l50 *ListNode\nvar l51 *ListNode\nvar l52 *ListNode\nvar l53 *ListNode\nvar l54 *ListNode\nvar l55 *ListNode\nvar l56 *ListNode\nvar l57"}
{"tgt": "empty := 0\nhold := -1 << 63\nfor _, p := range prices {\n\ttemp := empty\n\tempty = max(empty, hold+p)\n\thold = max(hold, temp-p-fee)\n}\nreturn empty", "gen": "var a, b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar A int\nvar B int\nvar C int\nvar D int\nvar E int\nvar F int\nvar G int\nvar H int\nvar I int\nvar J int\nvar K int\nvar L int\nvar M int\nvar N int\nvar O int\nvar P int\nvar Q int\nvar R int\nvar S int\nvar T int\nvar U int\nvar V int\nvar W int\nvar X int\nvar Y int\nvar Z int\nfor i = 0; i < len(a); i++ {\n\tif i < len(a) {\n\t\tif i < len(a) {\n\t\t\tif i < len(a) {\n\t\t\t\tif i < len(a) {\n\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t"}
{"tgt": "for _, tt := range tests {\n\tt.Run(tt.name, func(t *testing.T) {\n\t\tif got := largestOverlap(tt.args.A, tt.args.B); got != tt.want {\n\t\t\tt.Errorf(\"STR\", got, tt.want)\n\t\t}\n\t})\n}", "gen": "tests := []struct {\n\targs    [2]string\n\twant    int\n\tname    string\n\targsLen int\n}{\n\t{\n\t\targs:    [2]string{\"abcde\", \"cdefg\"},\n\t\twant:    2,\n\t\tname:    \"test1\",\n\t\targsLen: 2,\n\t},\n\t{\n\t\targs:    [2]string{\"ab\", \"eidbaooo\"},\n\t\twant:    2,\n\t\tname:    \"test2\",\n\t\targsLen: 2,\n\t},\n\t{\n\t\targs:    [2]string{\"abcd\", \"dcba\"},\n\t\twant:    4,\n\t\tname:    \"test3\",\n\t\targsLen: 2,\n\t},\n\t{\n\t\targs:    [2]string{\"a\", \"aa\"},\n\t\twant:    0,\n\t\tname:    \"test4\",\n\t\targsLen: 2,\n\t},\n\t{\n\t\targs:    [2]string{\"a\", \"a\"},\n\t\twant:    1,\n\t\tname:    \"test5\",\n\t\targsLen: 2,\n\t},\n\t{\n\t\targs:    [2]string{\"abc\", \"abc\"},\n\t\twant:    3,\n\t\tname:    \"test6\",\n\t\targsLen: 2,\n\t},\n\t{\n\t\targs:    [2]string{\"abc\", \"abcd\"},\n\t\twant:    4,\n\t\tname:    \"test7\",\n\t\targsLen: 2,\n\t},\n\t{\n\t\targs:    [2]string{\"abcd\", \"abc\"},\n\t\twant:    4,\n\t\tname:    \"test8\",\n\t\targsLen: 2,\n\t},\n\t{"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   5,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   7,\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   10,\n\t\twant: 5,\n\t},\n\t{\n\t\tin:   0,\n\t\twant: 1,\n\t},\n}\nfor _, tt := range tests {\n\tgot := bitwiseComplement(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var a, b, c, d int\na = 5\nb = 2\nc = 7\nd = 0\na = 10\nb = 5\nc = 0\nd = 1\nvar e, f int\ne = 4\nf = 0\nfor i := 0; i < 4; i++ {\n\tif i == 3 {\n\t\tbreak\n\t}\n\te = 4\n\tf = 0\n\tif i == 3 {\n\t\tcontinue\n\t}\n\ta = 5\n\tb = 2\n\tc = 7\n\td = 0\n\ta = 10\n\tb = 5\n\tc = 0\n\td = 1\n\te = bitwiseComplement(a, b)\n\tf = bitwiseComplement(c, d)\n\tif e == f {\n\t\tcontinue\n\t}\n\ttesting.T.Fatalf(a, b, c, d, e, f)\n}\n}"}
{"tgt": "syscall.Exit(code)", "gen": "syscall.Exit(0)\n}\n\n// \u6c47\u7f16\u4ee3\u7801\n// 1. \u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f\u4ee5 .L \u5f00\u5934\u7684\uff0c\u8fd9\u662f\u56e0\u4e3a\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\n// \u4e5f\u5c31\u662f\u8bf4\uff0c\u5728\u6c47\u7f16\u4ee3\u7801\u4e2d\uff0c\u51fd\u6570\u540d\u79f0\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\u53ea\u6709\u5728\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u4ee3\u7801\u5757\u624d\u662f\u53ef\u89c1\u7684\u3002\n// 2. \u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f\u4ee5 .L \u5f00\u5934\u7684\uff0c\u8fd9\u662f\u56e0\u4e3a\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\n// \u4e5f\u5c31\u662f\u8bf4\uff0c\u5728\u6c47\u7f16\u4ee3\u7801\u4e2d\uff0c\u51fd\u6570\u540d\u79f0\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\u53ea\u6709\u5728\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u4ee3\u7801\u5757\u624d\u662f\u53ef\u89c1\u7684\u3002\n// 3. \u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f\u4ee5 .L \u5f00\u5934\u7684\uff0c\u8fd9\u662f\u56e0\u4e3a\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\n// \u4e5f\u5c31\u662f\u8bf4\uff0c\u5728\u6c47\u7f16\u4ee3\u7801\u4e2d\uff0c\u51fd\u6570\u540d\u79f0\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\u53ea\u6709\u5728\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u4ee3\u7801\u5757\u624d\u662f\u53ef\u89c1\u7684\u3002\n// 4. \u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f\u4ee5 .L \u5f00\u5934\u7684\uff0c\u8fd9\u662f\u56e0\u4e3a\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\n// \u4e5f\u5c31\u662f\u8bf4\uff0c\u5728\u6c47\u7f16\u4ee3\u7801\u4e2d\uff0c\u51fd\u6570\u540d\u79f0\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\u53ea\u6709\u5728\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u4ee3\u7801\u5757\u624d\u662f\u53ef\u89c1\u7684\u3002\n// 5. \u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f\u4ee5 .L \u5f00\u5934\u7684\uff0c\u8fd9\u662f\u56e0\u4e3a\u6c47\u7f16\u4ee3\u7801\u4e2d\u7684\u51fd\u6570\u540d\u79f0\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\n// \u4e5f\u5c31\u662f\u8bf4\uff0c\u5728\u6c47\u7f16"}
{"tgt": "if len(input) == 0 {\n\treturn true\n}\nif len(input)%2 != 0 {\n\treturn false\n}\nvar stack []byte\nfor i := 0; i < len(input); i++ {\n\tif input[i] == \"STR\" || input[i] == \"STR\" || input[i] == \"STR\" {\n\t\tstack = append(stack, input[i])\n\t} else {\n\t\tif len(stack) > 0 {\n\t\t\tpair := string(stack[len(stack)-1]) + string(input[i])\n\t\t\tstack = stack[:len(stack)-1]\n\t\t\tif pair != \"STR\" && pair != \"STR\" && pair != \"STR\" {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn len(stack) == 0", "gen": "var a []byte\nvar b bool\nif len(a) == 0 {\n\tb = true\n} else {\n\tb = false\n}\nif a[0] == 40 {\n\tb = false\n} else if a[0] == 123 {\n\tb = true\n}\nif len(a) > 0 {\n\tif a[0] == 40 {\n\t\tb = false\n\t} else if a[0] == 123 {\n\t\tb = true\n\t}\n}\nif len(a) > 0 {\n\tif a[0] == 40 {\n\t\tb = false\n\t} else if a[0] == 123 {\n\t\tb = true\n\t}\n}\nif len(a) > 0 {\n\tif a[0] == 40 {\n\t\tb = false\n\t} else if a[0] == 123 {\n\t\tb = true\n\t}\n}\nif len(a) > 0 {\n\tif a[0] == 40 {\n\t\tb = false\n\t} else if a[0] == 123 {\n\t\tb = true\n\t}\n}\nif len(a) > 0 {\n\tif a[0] == 40 {\n\t\tb = false\n\t} else if a[0] == 123 {\n\t\tb = true\n\t}\n}\nif len(a) > 0 {\n\tif a[0] == 40 {\n\t\tb = false\n\t} else if a[0] == 123 {\n\t\tb = true\n\t}\n}\nif len(a) > 0 {\n\tif a[0] == 40 {\n\t\tb = false\n\t} else if a[0] == 123 {\n\t\t"}
{"tgt": "qs := []question1208{\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 3},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 0},\n\t\tans1208{1},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 11},\n\t\tans1208{3},\n\t},\n\t{\n\t\tpara1208{\"STR\", \"STR\", 19},\n\t\tans1208{2},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1208, q.para1208\n\tfmt.Printf(\"STR\", p, equalSubstring(p.s, p.t, p.maxCost))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%s %d %d %d\\n\", \".LC18\", 4, 4, 4)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC19\", 4, 4, 4)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC20\", 3, 3, 1)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC18\", 4, 4, 4)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC21\", 4, 4, 4)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC18\", 4, 4, 4)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC22\", 3, 1, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC18\", 4, 4, 4)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC23\", 9, 9, 11)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC24\", 5, 5, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC25\", 5, 5, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC26\", 70, 0, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC27\", 2, 2, 0)\nfmt.Printf(\"%s %d %d %d\\n\", \".LC28\", 3, 0, 0)\nvar a = [][]int{\n\t{1, 2, 3, 4},\n\t{5, 2, 3, 4},\n\t{1, 5, 3, 4},\n}\nvar b = [][]int"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{124123, 13425, 123, 65, 1, 54362, 134, 6543, 213}, 3},\n\t{\"STR\", []int{}, 0},\n\t{\"STR\", []int{4253626756, 3245876, 2345897, 23490}, 1},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.TestSolution()\n}\n"}
{"tgt": "if len(sorted) == 0 {\n\treturn nil\n}\nmid := len(sorted) / 2\nroot := &BST{Value: sorted[mid]}\nroot.Left = SortedSliceToBST(sorted[:mid])\nroot.Right = SortedSliceToBST(sorted[mid+1:])\nreturn root", "gen": "var root *BST\nif len(nums) == 0 {\n\treturn nil\n}\nroot = &BST{nums[0]}\nfor i := 1; i < len(nums); i++ {\n\tif i > 0 && i < len(nums) {\n\t\tif i > 0 && i < len(nums) {\n\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i > 0 && i < len(nums) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"}
{"tgt": "negative := false\nif num < 0 {\n\tnegative = true\n\tnum = -num\n}\nbf := bytes.NewBufferString(\"STR\")\nfor num >= 7 {\n\tmod := num % 7\n\tnum /= 7\n\tbf.WriteByte(byte(mod) + 48)\n}\nbf.WriteByte(byte(num) + 48)\nif negative {\n\tbf.WriteByte('-')\n}\nbs := bf.Bytes()\nfor s, e := 0, len(bs)-1; s < e; s, e = s+1, e-1 {\n\tbs[s], bs[e] = bs[e], bs[s]\n}\nreturn string(bs)", "gen": "var s string\nfor i := 0; i < 6; i++ {\n\tif i == 0 {\n\t\ts += \"0\"\n\t}\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n\ts += \"0\"\n"}
{"tgt": "s = strings.ToLower(s)\ni, j := 0, len(s)-1\nfor i < j {\n\tfor i < j && !isChar(s[i]) {\n\t\ti++\n\t}\n\tfor i < j && !isChar(s[j]) {\n\t\tj--\n\t}\n\tif s[i] != s[j] {\n\t\treturn false\n\t}\n\ti++\n\tj--\n}\nreturn true", "gen": "fmt.Println(isPalindrome(\"A man, a plan, a canal: Panama\"))\nfmt.Println(isPalindrome(\"race a car\"))\nfmt.Println(isPalindrome(\"0P\"))\nfmt.Println(isPalindrome(\"\"))\nfmt.Println(isPalindrome(\" \"))\nfmt.Println(isPalindrome(\"123456789\"))\nfmt.Println(isPalindrome(\"1234567890\"))\nfmt.Println(isPalindrome(\"12345678901\"))\nfmt.Println(isPalindrome(\"123456789012\"))\nfmt.Println(isPalindrome(\"1234567890123\"))\nfmt.Println(isPalindrome(\"12345678901234\"))\nfmt.Println(isPalindrome(\"123456789012345\"))\nfmt.Println(isPalindrome(\"1234567890123456\"))\nfmt.Println(isPalindrome(\"12345678901234567\"))\nfmt.Println(isPalindrome(\"123456789012345678\"))\nfmt.Println(isPalindrome(\"1234567890123456789\"))\nfmt.Println(isPalindrome(\"12345678901234567890\"))\nfmt.Println(isPalindrome(\"123456789012345678901\"))\nfmt.Println(isPalindrome(\"1234567890123456789012\"))\nfmt.Println(isPalindrome(\"12345678"}
{"tgt": "n := len(nums)\ntmp := make([]int, n)\ncopy(tmp, nums)\nfor i := 0; i < n; i++ {\n\tnums[(i+k)%n] = tmp[i]\n}", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\ta[i] = i\n}\n}\n"}
{"tgt": "random := rand.New(rand.NewSource(time.Now().UnixNano()))\narray := make([]int, random.Intn(100-10)+10)\nfor i := range array {\n\tarray[i] = random.Intn(100)\n}\nSortArray(array)\nfor _, value := range array {\n\tresult := ExponentialSearch(array, value)\n\tif result == -1 {\n\t\tt.Fail()\n\t}\n}", "gen": "t := time.Now()\nr := rand.NewSource(t.UnixNano())\nrnd := rand.New(r)\narr := make([]int, 10)\nfor i := 0; i < 10; i++ {\n\tarr[i] = rnd.Intn(90)\n}\nsort.Sort(arr)\nfor i := 0; i < 10; i++ {\n\tfmt.Println(arr[i])\n}\nfor i := 0; i < 10; i++ {\n\tfmt.Println(ExponentialSearch(arr, i))\n}\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimumPartitionPalindrome(tc.input); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "obj := Constructor732()\nfmt.Printf(\"STR\", obj.Book(10, 20))\nfmt.Printf(\"STR\", obj.Book(50, 60))\nfmt.Printf(\"STR\", obj.Book(10, 40))\nfmt.Printf(\"STR\", obj.Book(5, 15))\nfmt.Printf(\"STR\", obj.Book(5, 10))\nfmt.Printf(\"STR\", obj.Book(25, 55))", "gen": "c := Constructor()\nc.Book(20, 10)\nc.Book(60, 10)\nc.Book(40, 50)\nc.Book(10, 50)\nc.Book(15, 5)\nc.Book(10, 5)\nc.Book(55, 25)\nc.Book(5, 25)\nc.Book(10, 5)\nfmt.Printf(\"%d %d %d\\n\", c.Book(10, 5), c.Book(5, 25), c.Book(55, 25))\nfmt.Printf(\"%d %d %d\\n\", c.Book(10, 5), c.Book(5, 25), c.Book(55, 25))\nfmt.Printf(\"%d %d %d\\n\", c.Book(10, 5), c.Book(5, 25), c.Book(55, 25))\nfmt.Printf(\"%d %d %d\\n\", c.Book(10, 5), c.Book(5, 25), c.Book(55, 25))\nfmt.Printf(\"%d %d %d\\n\", c.Book(10, 5), c.Book(5, 25), c.Book(55, 25))\nfmt.Printf(\"%d %d %d\\n\", c.Book(10, 5), c.Book(5, 25), c.Book(55, 25))\nfmt.Printf(\"%d %d %d\\n\", c.Book(10, 5), c.Book(5, 25), c.Book(55, 25))\nfmt.Printf(\"%d %d %d\\n\", c.Book(10, 5), c.Book(5, 25), c.Book(55, 25))\nfmt.Printf(\"%d %d %d\\"}
{"tgt": "if a == nil && b == nil {\n\treturn true\n}\nif len(a) != len(b) {\n\treturn false\n}\nfor i := range a {\n\tif a[i] != b[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [4]int\nvar b [4]int\nvar c int\nif len(a) == len(b) {\n\tfor i := 0; i < len(a); i++ {\n\t\tif a[i] == b[i] {\n\t\t\tc = 1\n\t\t\tbreak\n\t\t}\n\t}\n} else {\n\tc = 0\n}\nif c == 0 {\n\tif a[0] == b[0] {\n\t\tc = 1\n\t}\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "val := \"STR\"\nfor i := 1; i < n; i++ {\n\tvar (\n\t\tc   int\n\t\tv   byte\n\t\tstr string\n\t)\n\tfor j := 0; j < len(val); j++ {\n\t\tif val[j] == v {\n\t\t\tc++\n\t\t\tcontinue\n\t\t}\n\t\tif c != 0 {\n\t\t\tstr += string(c+'0') + string(v)\n\t\t}\n\t\tc, v = 1, val[j]\n\t}\n\tval = str + string(c+'0') + string(v)\n}\nreturn val", "gen": "var s string\nvar i int\nfor i = 0; i < len(s); i++ {\n\tif s[i] == 0 {\n\t\ts = strconv.Itoa(i) + strconv.Itoa(s[i])\n\t}\n}\nreturn s\n}\n"}
{"tgt": "res := 0\nif n != 0 {\n\trightMostBitInt := n & -n\n\tnextHigherSetBitInt := n + rightMostBitInt\n\td := n ^ nextHigherSetBitInt\n\td /= rightMostBitInt\n\td >>= 2\n\tres = nextHigherSetBitInt | d\n}\nreturn res", "gen": "var a int\nif a < 0 {\n\ta = -a\n}\nreturn a >> 2\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(nums) == 0 || len(nums) < k {\n\treturn make([]int, 0)\n}\nqueue := make([]int, 0, k)\nans := make([]int, len(nums)-k+1)\nfor left, right := 1-k, 0; right < len(nums); left, right = left+1, right+1 {\n\tif left > 0 && queue[0] == nums[left-1] {\n\t\tqueue = queue[1:len(queue)]\n\t}\n\tfor len(queue) != 0 && queue[len(queue)-1] < nums[right] {\n\t\tqueue = queue[:len(queue)-1]\n\t}\n\tqueue = append(queue, nums[right])\n\tif left >= 0 {\n\t\tans[left] = queue[0]\n\t}\n}\nreturn ans", "gen": "var a []int\nvar b []int\nvar c []int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar ba int\nvar bb int\nvar bc int\nvar bd int\nvar be int\nvar bf int\nvar bg int\nvar bh int\nvar bi int\nvar bj int\nvar bk int\nvar bl int\nvar bm int\nvar bn int\nvar bo int\nvar bp int\nvar bq int\nvar br int\nvar bs int\nvar bt int\nvar bu int\nvar bv int\nvar bw int\nvar bx int\nvar by int\nvar bz int\nvar ca int\nvar cb int\nvar cc int\nvar cd int\nvar ce int\nvar cf int\nvar cg int\nvar ch int\nvar ci int\nvar cj int\nvar ck int\nvar cl int\nvar cm int\nvar cn int\nvar co int\nvar cp int\nvar cq"}
{"tgt": "n := len(intervals)\nif n == 0 {\n\treturn []Interval{}\n} else if n == 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].Start < intervals[j].Start\n})\nres := []Interval{intervals[0]}\nfor _, cur := range intervals[1:] {\n\tprevious := res[len(res)-1]\n\tif cur.Start <= previous.End {\n\t\tend := previous.End\n\t\tif cur.End > end {\n\t\t\tend = cur.End\n\t\t}\n\t\tres = append(res[:len(res)-1], Interval{Start: previous.Start, End: end})\n\t} else {\n\t\tres = append(res, cur)\n\t}\n}\nreturn res", "gen": "a := [][]int{{1, 3}, {2, 6}, {8, 10}, {15, 18}}\nb := [][]int{{1, 2}, {3, 5}, {6, 7}, {8, 10}, {12, 16}}\nc := [][]int{{1, 2}, {3, 5}, {6, 7}, {8, 10}, {12, 16}}\nfmt.Println(merge(a, b))\nfmt.Println(merge(a, c))\n}\n"}
{"tgt": "max := 9999\nbiggestPandigital := 0\nvar numberMultiplied int\nfor i := max; i > 0; i-- {\n\tnumberMultiplied = i\n\tfor j := 1; len(digits(numberMultiplied)) <= 9; j++ {\n\t\tnumberMultiplied = concatenMultiplication(i, j)\n\t\tif IsPandigital(numberMultiplied) && numberMultiplied > biggestPandigital {\n\t\t\tfmt.Println(numberMultiplied)\n\t\t\tbiggestPandigital = numberMultiplied\n\t\t}\n\t}\n}", "gen": "var pandigital []int\nfor i := 9999; i > 0; i-- {\n\tif IsPandigital(i) {\n\t\tpandigital = append(pandigital, i)\n\t}\n}\nfor _, i := range pandigital {\n\tif IsPandigital(concatenMultiplication(i)) {\n\t\tfmt.Println(i)\n\t}\n}\n}"}
{"tgt": "n := len(pushed)\ns := make([]int, 0, n)\ni := 0\nfor _, x := range pushed {\n\ts = append(s, x)\n\tfor len(s) != 0 && s[len(s)-1] == popped[i] {\n\t\ts = s[:len(s)-1]\n\t\ti++\n\t}\n}\nreturn i == n", "gen": "var a []int\nvar b []int\nvar c []int\nvar d int\nfor i := 0; i < len(a); i++ {\n\tif i < len(b) {\n\t\tc = append(c, a[i])\n\t\td++\n\t}\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "testCases := [][]int{\n\t{1, 2, 3, 1},\n\t{1, 0, 1, 1},\n\t{1, 2, 3, 1, 2, 3},\n}\nks := []int{3, 1, 2}\nexpected := []bool{true, true, false}\nfor index, nums := range testCases {\n\tif res := containsNearbyDuplicate(nums, ks[index]); res != expected[index] {\n\t\tt.Errorf(\"STR\", expected[index], res)\n\t}\n}", "gen": "var nums = []int{1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, "}
{"tgt": "item := req.URL.Query().Get(\"STR\")\nif price, ok := db[item]; ok {\n\tfmt.Fprintf(w, \"STR\", price)\n} else {\n\tw.WriteHeader(http.StatusNotFound)\n\tfmt.Fprintf(w, \"STR\", item)\n}", "gen": "url := \"http://localhost:8080/api/v1/users?page=1&per_page=10\"\nquery := url[strings.Index(url, \"?\"):]\npage, _ := strconv.Atoi(query[strings.Index(query, \"page=\")+5 : strings.Index(query, \"&per_page\")])\nper_page, _ := strconv.Atoi(query[strings.Index(query, \"per_page=\")+9 : len(query)])\nfmt.Println(page, per_page)\n}\n"}
{"tgt": "l, r := &maxHeap{}, &minHeap{}\nheap.Init(l)\nheap.Init(r)\nreturn MedianFinder{l, r}", "gen": "var heap1 = &maxHeap{}\nvar heap2 = &minHeap{}\ncontainer.Init(heap1, heap2)\n}\n"}
{"tgt": "var buf [32]byte\ni := len(buf) - 1\nfor val >= 10 {\n\tbuf[i] = byte(val%10 + \"STR\")\n\ti--\n\tval /= 10\n}\nbuf[i] = byte(val + \"STR\")\nreturn string(buf[i:])", "gen": "var s []byte\nfor i := 0; i < 10; i++ {\n\ts = append(s, byte(i))\n}\ns = append(s, byte(0))\nreturn string(s)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if len(nums1) == 0 || len(nums2) == 0 {\n\treturn []int{}\n}\nnum1Map := make(map[int]bool)\nfor i := range nums1 {\n\tnum1Map[nums1[i]] = true\n}\nnum2Map := make(map[int]bool)\nvar res []int\nfor i := range nums2 {\n\tif _, ok1 := num1Map[nums2[i]]; ok1 && !num2Map[nums2[i]] {\n\t\tnum2Map[nums2[i]] = true\n\t\tres = append(res, nums2[i])\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "var ret [][]int\nvar nums []int\nnums = []int{-1, 0, 1, 2, -1, -4}\nret = [][]int{{-1, -1, 2}, {-1, 0, 1}}\nfor k, num := range threeSum(nums) {\n\tfor i, v := range num {\n\t\tif v != ret[k][i] {\n\t\t\tt.Fatalf(\"STR\", ret)\n\t\t}\n\t}\n}", "gen": "a := []int{-1, 0, 1, 2, -1, -4}\nb := []int{0, 1, 2, 3}\nc := []int{-1, -1, 3, 3}\nthreeSum(a, b, c)\n}\n"}
{"tgt": "dist := make([]int, N+1)\nfor i := 0; i < len(dist); i++ {\n\tdist[i] = math.MaxInt32\n}\ndist[K] = 0\nfor i := 0; i < N; i++ {\n\tfor _, t := range times {\n\t\tu, v, w := t[0], t[1], t[2]\n\t\tif dist[u] != math.MaxInt32 && dist[v] > dist[u]+w {\n\t\t\tdist[v] = dist[u] + w\n\t\t}\n\t}\n}\nmx := 0\nfor i := 1; i <= N; i++ {\n\tif mx < dist[i] {\n\t\tmx = dist[i]\n\t}\n}\nif mx == math.MaxInt32 {\n\treturn -1\n}\nreturn mx", "gen": "var a []int\nvar b int\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i < len(a); i++ {\n\ta[i] = 0\n}\nfor i := 0; i <"}
{"tgt": "dat, err := ioutil.ReadFile(\"STR\")\nif err != nil {\n\tpanic(err)\n}\nnamesList := string(dat)\nnamesList = strings.Replace(namesList, \"STR\", \"STR\", -1)\nnames := strings.Split(namesList, \"STR\")\nsort.Strings(names)\nnamesScore := 0\nfor index, name := range names {\n\tnamesScore += nameScore(name) * (index + 1)\n}\nfmt.Println(namesScore)", "gen": "f, err := os.Open(\"names.txt\")\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer f.Close()\n\nb, err := ioutil.ReadAll(f)\nif err != nil {\n\tlog.Fatal(err)\n}\n\ns := string(b)\n// s := \"Emma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvelyn\\nEmilia\\nAbigail\\nEmma\\nOlivia\\nAva\\nIsabella\\nSophia\\nMia\\nEvely"}
{"tgt": "var matrix [][]int\nmatrix = [][]int{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 9},\n}\nrotate(matrix)", "gen": "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nrotate(nums, 3)\nfmt.Println(nums)\n}\n"}
{"tgt": "curr := n\nfor _, c := range s {\n\tnext, ok := curr.children[c]\n\tif !ok {\n\t\tnext = NewNode()\n\t\tcurr.children[c] = next\n\t}\n\tcurr = next\n}\ncurr.isLeaf = true", "gen": "var m map[int32]Node\nvar i int32\nfor i = 0; i < len(s); i++ {\n\tif m[i] == nil {\n\t\tm[i] = NewNode()\n\t}\n\tm[i].Val = s[i]\n}\nm[0].Val = 1\nreturn m\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MinimizeQux(tc.input); !reflect.DeepEqual(tc.expected, result) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "sum := 0\nfor i := 2; i < 999999; i++ {\n\tif isSumOfFivePowerOfDigitsEqualToNumber(i) {\n\t\tsum += i\n\t}\n}\nreturn sum", "gen": "var sum int\nfor i := 0; i < 999999; i++ {\n\tif isSumOfFivePowerOfDigitsEqualToNumber(i) {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}\n"}
{"tgt": "if l1 == nil {\n\treturn l2\n}\nif l2 == nil {\n\treturn l1\n}\nret := &ListNode{}\nif l1.Val <= l2.Val {\n\tret = l1\n\tret.Next = mergeTwoLists1(l1.Next, l2)\n} else {\n\tret = l2\n\tret.Next = mergeTwoLists1(l1, l2.Next)\n}\nreturn ret", "gen": "a := &ListNode{Val: 1}\nb := &ListNode{Val: 2}\nc := &ListNode{Val: 3}\na.Next = b\nb.Next = c\nd := &ListNode{Val: 4}\ne := &ListNode{Val: 5}\nd.Next = e\nf := &ListNode{Val: 6}\ne.Next = f\ng := &ListNode{Val: 7}\nf.Next = g\nh := &ListNode{Val: 8}\ng.Next = h\ni := &ListNode{Val: 9}\nh.Next = i\nj := &ListNode{Val: 10}\ni.Next = j\nk := &ListNode{Val: 11}\nj.Next = k\nl := &ListNode{Val: 12}\nk.Next = l\nm := &ListNode{Val: 13}\nl.Next = m\nn := &ListNode{Val: 14}\nm.Next = n\no := &ListNode{Val: 15}\nn.Next = o\np := &ListNode{Val: 16}\no.Next = p\nq := &ListNode{Val: 17}\np.Next = q\nr := &ListNode{Val: 18}\nq.Next = r\ns := &ListNode{Val: 19}\nr.Next = s\nt := &ListNode{Val: 20}\ns.Next = t\nu := &ListNode{Val: 21}\nt.Next = u\nv := &ListNode{Val: 22}\nu.Next = v\nw := &ListNode{Val: 23}\nv.Next = w\nx := &ListNode{Val: 24}\nw.Next = x\ny := &ListNode{Val: 25}\nx.Next ="}
{"tgt": "a := int(math.Log10(float64(number))) + 1\nresult := 0\nfor i := 1; i <= a; i++ {\n\tresult += digit(number, i) * int(math.Pow10(a-i))\n}\nreturn result", "gen": "var n int64\nfmt.Scan(&n)\nvar sum int64\nfor i := int64(1); i <= n; i++ {\n\tsum += digit(i) * math.Pow10(n-i)\n}\nfmt.Println(sum)\n}\n"}
{"tgt": "maxans := 0\ndp := make([]int, len(s))\nfor i := 1; i < len(s); i++ {\n\tif s[i] == \"STR\" {\n\t\tif s[i-1] == \"STR\" {\n\t\t\tif i >= 2 {\n\t\t\t\tdp[i] = dp[i-2] + 2\n\t\t\t} else {\n\t\t\t\tdp[i] = 2\n\t\t\t}\n\t\t} else if i-dp[i-1] > 0 && s[i-dp[i-1]-1] == \"STR\" {\n\t\t\tif i-dp[i-1] >= 2 {\n\t\t\t\tdp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2\n\t\t\t} else {\n\t\t\t\tdp[i] = dp[i-1] + 2\n\t\t\t}\n\t\t}\n\t}\n\tmaxans = Max(maxans, dp[i])\n}\nreturn maxans", "gen": "s := \"ABA\"\nresult := Solution{}.Max(s)\nfmt.Println(result)\n}\n"}
{"tgt": "s.lock.Lock()\ndefer s.lock.Unlock()\nl := len(s.nodes)\nif l == 0 {\n\treturn nil, errors.New(\"STR\")\n}\nnode := s.nodes[l-1]\ns.nodes = s.nodes[:l-1]\nreturn node, nil", "gen": "var m sync.Mutex\nvar wg sync.WaitGroup\nwg.Add(1)\ngo func() {\n\tdefer wg.Done()\n\tm.Lock()\n\tdefer m.Unlock()\n\tif len(a) == 0 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif len(a) == 0 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif len(a) == 0 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif len(a) == 0 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif len(a) == 0 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif len(a) == 0 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif len(a) == 0 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif len(a) == 0 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif len(a) == 0 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif len(a) == 0 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif len(a) == 0 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif len(a) == 0 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif len(a) == 0 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif len(a) == 0 {\n\t\tpanic(errors.New(\"index out"}
{"tgt": "max1, max2, max3, min1, min2 := -1001, -1001, -1001, 1001, 1001\nfor _, v := range nums {\n\tif v > max1 {\n\t\tmax3 = max2\n\t\tmax2 = max1\n\t\tmax1 = v\n\t} else if v > max2 {\n\t\tmax3 = max2\n\t\tmax2 = v\n\t} else if v > max3 {\n\t\tmax3 = v\n\t}\n\tif v < min1 {\n\t\tmin2 = min1\n\t\tmin1 = v\n\t} else if v < min2 {\n\t\tmin2 = v\n\t}\n}\nreturn max(max1*min1*min2, max1*max2*max3)", "gen": "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nb := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nc := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nd := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\ne := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nf := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\ng := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nh := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\ni := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nj := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nk := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nl := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nm := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nn := []int{1, 2, 3, 4, 5"}
{"tgt": "h := fnv.New64a()\n_, _ = h.Write([]byte(fmt.Sprintf(\"STR\", key)))\nhashValue := h.Sum64()\nreturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))", "gen": "var a, b int64\nvar c, d int64\nvar e, f int64\nvar g, h int64\nvar i, j int64\nvar k, l int64\nvar m, n int64\nvar o, p int64\nvar q, r int64\nvar s, t int64\nvar u, v int64\nvar w, x int64\nvar y, z int64\nvar aa, ab int64\nvar ac, ad int64\nvar ae, af int64\nvar ag, ah int64\nvar ai, aj int64\nvar ak, al int64\nvar am, an int64\nvar ao, ap int64\nvar aq, ar int64\nvar at, au int64\nvar av, aw int64\nvar ax, ay int64\nvar az, aaa int64\nvar aba, abb int64\nvar abc, abd int64\nvar abe, abf int64\nvar abg, abh int64\nvar abi, abj int64\nvar abk,abl int64\nvar abm, abn int64\nvar abo, abp int64\nvar abq, abr int64\nvar abt, abu int64\nvar abv, abw int64\nvar abx,aby int64\nvar abz, abaa int64\nvar aaaa, abbb int64\nvar abba, abbc int64\nvar abbe, abbd int64\nvar abbg, abbh int64\nvar abbi, abbj int64\nvar abbk, abbl int64\nvar abbm, abbn int64\nvar abbo, abbp int64\nvar abbq, abbr int64\nvar abbt, abbu int64\nvar abbv, abbw"}
{"tgt": "arr := make([]int, n+1, n+1)\narr[0] = 0\narr[1] = 1\nfor x := 2; x <= n; x++ {\n\tarr[x] = -1\n}\nreturn fibonacciDyamic(n, arr)", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\ta = append(a, 0)\n\ta[i] = 1\n\ta[i+1] = 1\n}\nreturn a[0]\n}\n"}
{"tgt": "*ss = Count{\n\tolist: make([]countBucket, size),\n\thash:  make(map[string]uint32, size),\n}\nreturn ss", "gen": "var m map[string]uint32\nvar s []uint32\nm = make(map[string]uint32)\ns = make([]uint32, 0, 10)\nreturn\n}\n"}
{"tgt": "if len(nums) == 0 {\n\treturn 0\n} else if len(nums) == 1 {\n\treturn nums[0]\n}\nmax := func(m, n int) int {\n\tif m > n {\n\t\treturn m\n\t}\n\treturn n\n}\ndp := []int{nums[0], max(nums[0], nums[1])}\nfor i := 2; i < len(nums); i++ {\n\tdp[i%2] = max(dp[(i-1)%2], nums[i]+dp[i%2])\n}\nreturn dp[(len(nums)-1)%2]", "gen": "fmt.Println(rob([]int{2, 3, 2}))\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CanHopToEnd(tc.hops); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.hops, tc.expected, result)\n\t}\n}", "gen": "t := testing.T{}\nt.Parallel()\nfor i, test := range testcases {\n\tif CanHopToEnd(test.start, test.end) != test.result {\n\t\tt.Errorf(\"CanHopToEnd(%d, %d) = %t, want %t\", test.start, test.end, CanHopToEnd(test.start, test.end), test.result)\n\t}\n}\n}\n"}
{"tgt": "n := NewNode()\ninsertWords := [...]string{\n\t\"STR\",\n\t\"STR\",\n}\ncheckWords := map[string]bool{\n\t\"STR\": false,\n\t\"STR\": false,\n\t\"STR\": true,\n}\nfor _, w := range insertWords {\n\tn.Insert(w)\n\tt.Logf(\n\t\t\"STR\",\n\t\tw,\n\t)\n}\nfor k, v := range checkWords {\n\tok := n.Find(k)\n\tif ok != v {\n\t\tt.Fatalf(\n\t\t\t\"STR\",\n\t\t\tk,\n\t\t\tmap[bool]string{true: \"STR\"}[v],\n\t\t)\n\t}\n\tt.Logf(\n\t\t\"STR\",\n\t\tk,\n\t\tmap[bool]string{true: \"STR\"}[ok],\n\t)\n}", "gen": "trie := NewNode()\ntrie.Insert(\"abc\", true)\ntrie.Insert(\"abcd\", true)\ntrie.Insert(\"abcde\", true)\ntrie.Insert(\"abcdef\", true)\ntrie.Insert(\"abcdefg\", true)\ntrie.Insert(\"abcdefgh\", true)\ntrie.Insert(\"abcdefghi\", true)\ntrie.Insert(\"abcdefghij\", true)\ntrie.Insert(\"abcdefghijk\", true)\ntrie.Insert(\"abcdefghijkl\", true)\ntrie.Insert(\"abcdefghijklm\", true)\ntrie.Insert(\"abcdefghijklmn\", true)\ntrie.Insert(\"abcdefghijklmno\", true)\ntrie.Insert(\"abcdefghijklmnop\", true)\ntrie.Insert(\"abcdefghijklmnopq\", true)\ntrie.Insert(\"abcdefghijklmnopqr\", true)\ntrie.Insert(\"abcdefghijklmnopqrs\", true)\ntrie.Insert(\"abcdefghijklmnopqrst\", true)\ntrie.Insert(\"abcdefghijklmnopqrstu\", true)\ntrie.Insert(\"abcdefghijklmnopqrstuv\", true)\ntrie.Insert(\"abcdefghijklmnopqrstuvw\", true)\ntrie.Insert(\"abcdefghijklmnopqrstuvwx\", true)\ntrie.Insert(\"abcdefghijklmnopqrstuvwxy\", true)\ntrie.Insert(\"abcdefghijklmnopqrstuvwxyz\", true)\ntrie.Insert(\"abcdefghijklmnopqrstuvwxyzabc\", true)\ntrie.Insert(\"abcdefghijklmnopqrstuvwxyzabcd\", true)\ntrie.Insert(\"abcdefghijklmnopqrstuvwxyzabcde\", true)\ntrie.Insert(\"abcdefghijklmnopq"}
{"tgt": "if cl.Size > 0 {\n\tif places < 0 {\n\t\tmultiple := cl.Size - 1 - places/cl.Size\n\t\tplaces += multiple * cl.Size\n\t}\n\tplaces %= cl.Size\n\tif places > cl.Size/2 {\n\t\tplaces = cl.Size - places\n\t\tfor i := 0; i < places; i++ {\n\t\t\tcl.Head = cl.Head.Prev\n\t\t}\n\t} else if places == 0 {\n\t\treturn\n\t} else {\n\t\tfor i := 0; i < places; i++ {\n\t\t\tcl.Head = cl.Head.Next\n\t\t}\n\t}\n}", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i\n}\nfor i = 0; i < len(a); i++ {\n\ta[i] = a[i] / i\n}\nfor i = 0; i < len(a); i++ {\n\ta[i] = a[i] / -1\n}\nfor i = 0; i < len(a); i++ {\n\ta[i] = a[i] / -1\n}\nfor i = 0; i < len(a); i++ {\n\ta[i] = a[i] / -1\n}\nfor i = 0; i < len(a); i++ {\n\ta[i] = a[i] / -1\n}\nfor i = 0; i < len(a); i++ {\n\ta[i] = a[i] / -1\n}\nfor i = 0; i < len(a); i++ {\n\ta[i] = a[i] / -1\n}\nfor i = 0; i < len(a); i++ {\n\ta[i] = a[i] / -1\n}\nfor i = 0; i < len(a); i++ {\n\ta[i] = a[i] / -1\n}\nfor i = 0; i < len(a); i++ {\n\ta[i] = a[i] / -1\n}\nfor i = 0; i < len(a); i++ {\n\ta[i] = a[i] / -1\n}\nfor i = 0; i < len(a); i++ {\n\ta[i] = a[i] / -1\n}\nfor i = 0; i < len(a); i++ {\n\ta[i] = a[i] / -1\n}\nfor i"}
{"tgt": "s.lock.Lock()\ndefer s.lock.Unlock()\nreturn s.len", "gen": "var m sync.Mutex\nvar x int\nm.Lock()\ndefer m.Unlock()\ndefer func() {\n\tif recover() != nil {\n\t\tx = 0\n\t}\n}()\nx = 32\nif x == 0 {\n\tpanic(\"\")\n}\nreturn\n}\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tdefer m.Unlock()\n// \tdefer func() {\n// \t\tif recover() != nil {\n// \t\t\tx = 0\n// \t\t}\n// \t}()\n// \tx = 32\n// \tif x == 0 {\n// \t\tpanic(\"\")\n// \t}\n// \treturn\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tdefer m.Unlock()\n// \tdefer func() {\n// \t\tif recover() != nil {\n// \t\t\tx = 0\n// \t\t}\n// \t}()\n// \tx = 32\n// \tif x == 0 {\n// \t\tpanic(\"\")\n// \t}\n// \treturn\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \tm.Lock()\n// \tdefer m.Unlock()\n// \tdefer func() {\n// \t\tif recover() != nil {\n// \t\t\tx = 0\n// \t\t}\n// \t}()\n// \tx = 32\n// \tif x == 0 {\n// \t\tpanic(\"\")\n// \t}\n// \treturn\n// }\n\n// func main() {\n// \tvar m sync.Mutex\n// \tvar x int\n// \t"}
{"tgt": "return fmt.Sprintf(\"STR\", p.Name, p.Age)", "gen": "var s string\nvar i int\nvar j int\nvar k int\nvar s1 string\nvar i1 int\nvar j1 int\nvar k1 int\nvar s2 string\nvar i2 int\nvar j2 int\nvar k2 int\nvar s3 string\nvar i3 int\nvar j3 int\nvar k3 int\nvar s4 string\nvar i4 int\nvar j4 int\nvar k4 int\nvar s5 string\nvar i5 int\nvar j5 int\nvar k5 int\nvar s6 string\nvar i6 int\nvar j6 int\nvar k6 int\nvar s7 string\nvar i7 int\nvar j7 int\nvar k7 int\nvar s8 string\nvar i8 int\nvar j8 int\nvar k8 int\nvar s9 string\nvar i9 int\nvar j9 int\nvar k9 int\nvar s10 string\nvar i10 int\nvar j10 int\nvar k10 int\nvar s11 string\nvar i11 int\nvar j11 int\nvar k11 int\nvar s12 string\nvar i12 int\nvar j12 int\nvar k12 int\nvar s13 string\nvar i13 int\nvar j13 int\nvar k13 int\nvar s14 string\nvar i14 int\nvar j14 int\nvar k14 int\nvar s15 string\nvar i15 int\nvar j15 int\nvar k15 int\nvar s16 string\nvar i16 int\nvar j16 int\nvar k16 int\nvar s17 string\nvar i17 int\nvar j17 int\nvar k17 int\nvar s18 string\nvar i18 int\nvar j18 int\nvar k18 int\nvar s19 string\nvar i19"}
{"tgt": "if n < 2 {\n\treturn 1\n}\nrec := make([]int, n+1)\nrec[0], rec[1] = 1, 1\nfor i := 2; i <= n; i++ {\n\trec[i] = rec[i-1] + rec[i-2]\n}\nreturn rec[n]", "gen": "var a []int\nif len(a) > 1 {\n\ta[0] = 1\n\ta[1] = 1\n}\nfor i := 2; i < len(a); i++ {\n\ta[i] = a[i-1] + a[i-2]\n}\nreturn a[len(a)-1]\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "n := len(nums)\nif n == 0 {\n\treturn 0\n}\nif n == 1 {\n\treturn nums[0]\n}\ntmp := nums[0]\nmax := tmp\nfor i := 1; i < n; i++ {\n\tif tmp < 0 {\n\t\ttmp = nums[i]\n\t} else {\n\t\ttmp += nums[i]\n\t}\n\tif max < tmp {\n\t\tmax = tmp\n\t}\n}\nreturn max", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif i == 0 {\n\t\ta[i] = 0\n\t} else if i == 1 {\n\t\ta[i] = a[0]\n\t} else {\n\t\ta[i] = a[i-1] + a[i-2]\n\t}\n}\nreturn a[len(a)-1]\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return syscall.Getgid()", "gen": "gid := syscall.Getgid()\nreturn gid\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tarr1   []int\n\tarr2   []int\n\td      int\n\texpect int\n}{\n\t{\"STR\", []int{4, 5, 8}, []int{10, 9, 1, 8}, 2, 2},\n\t{\"STR\", []int{1, 4, 2, 3}, []int{-4, -3, 6, 10, 20, 30}, 3, 2},\n\t{\"STR\", []int{2, 1, 100, 3}, []int{-5, -2, 10, -3, 7}, 6, 1},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.arr1, c.arr2, c.d)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.arr1, c.arr2, c.d)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.TestSolution()\n}\n"}
{"tgt": "if h.Count != 0 {\n\tfor i := 0; i < int(h.Cap); i++ {\n\t\thashValue := h.hash(key, uint32(i))\n\t\tif h.backets[hashValue] != nil && h.backets[hashValue].Key == key {\n\t\t\treturn h.backets[hashValue].Value, h.backets[hashValue].exist\n\t\t}\n\t}\n}\nreturn nil, false", "gen": "var m map[string]string\nvar k string\nvar v string\nvar ok bool\nfor i := 0; i < len(m); i++ {\n\tk, v, ok = m[i]\n\tif ok {\n\t\tm[i] = v\n\t}\n}\n}\n"}
{"tgt": "l1 := len(board)\nif l1 == 0 {\n\treturn\n}\nl2 := len(board[0])\nif l2 == 0 {\n\treturn\n}\nvisit := make([][]bool, l1)\nfor i := 0; i < l1; i++ {\n\tvisit[i] = make([]bool, l2)\n}\nfor i := 0; i < l1; i++ {\n\tfor j := 0; j < l2; j++ {\n\t\tif !visit[i][j] {\n\t\t\thelper(board, visit, i, j)\n\t\t}\n\t}\n}", "gen": "var a []bool\nvar b []bool\nvar c []bool\nvar d []bool\nvar e []bool\nvar f []bool\nvar g []bool\nvar h []bool\nvar i []bool\nvar j []bool\nvar k []bool\nvar l []bool\nvar m []bool\nvar n []bool\nvar o []bool\nvar p []bool\nvar q []bool\nvar r []bool\nvar s []bool\nvar t []bool\nvar u []bool\nvar v []bool\nvar w []bool\nvar x []bool\nvar y []bool\nvar z []bool\nvar aa []bool\nvar bb []bool\nvar cc []bool\nvar dd []bool\nvar ee []bool\nvar ff []bool\nvar gg []bool\nvar hh []bool\nvar ii []bool\nvar jj []bool\nvar kk []bool\nvar ll []bool\nvar mm []bool\nvar nn []bool\nvar oo []bool\nvar pp []bool\nvar qq []bool\nvar rr []bool\nvar ss []bool\nvar tt []bool\nvar uu []bool\nvar vv []bool\nvar ww []bool\nvar xx []bool\nvar yy []bool\nvar zz []bool\nvar aa1 []bool\nvar bb1 []bool\nvar cc1 []bool\nvar dd1 []bool\nvar ee1 []bool\nvar ff1 []bool\nvar gg1 []bool\nvar hh1 []bool\nvar ii1 []bool\nvar jj1 []bool\nvar kk1 []bool\nvar ll1 []bool\nvar mm1 []bool\nvar nn1 []bool\nvar oo1 []bool\nvar pp1 []bool\nvar qq1 []bool\nvar rr1 []bool\nvar ss1 []bool\nvar tt1 []bool\nvar uu1 []bool\nvar vv1 []bool\nvar ww1 []bool\n"}
{"tgt": "return me[0] == \"STR\"", "gen": "var s []int\nif len(s) == 0 {\n\tpanic(\"slice bounds out of range\")\n}\nif len(s) > 1 {\n\tpanic(\"slice bounds out of range\")\n}\nif s[0] == 1 {\n\treturn 1\n}\nreturn 0\n}\n\n// func main() {\n// \tvar s []int\n// \tif len(s) == 0 {\n// \t\tpanic(\"slice bounds out of range\")\n// \t}\n// \tif len(s) > 1 {\n// \t\tpanic(\"slice bounds out of range\")\n// \t}\n// \tif s[0] == 1 {\n// \t\treturn 1\n// \t}\n// \treturn 0\n// }\n\n// func main() {\n// \tvar s []int\n// \tif len(s) == 0 {\n// \t\tpanic(\"slice bounds out of range\")\n// \t}\n// \tif len(s) > 1 {\n// \t\tpanic(\"slice bounds out of range\")\n// \t}\n// \tif s[0] == 1 {\n// \t\treturn 1\n// \t}\n// \treturn 0\n// }\n\n// func main() {\n// \tvar s []int\n// \tif len(s) == 0 {\n// \t\tpanic(\"slice bounds out of range\")\n// \t}\n// \tif len(s) > 1 {\n// \t\tpanic(\"slice bounds out of range\")\n// \t}\n// \tif s[0] == 1 {\n// \t\treturn 1\n// \t}\n// \treturn 0\n// }\n\n// func main() {\n// \tvar s []int\n// \tif len(s) == 0 {\n// \t\tpanic(\"slice bounds out of range\")\n// \t}\n// \tif len(s) > 1 {\n// \t\tpanic(\"slice bounds out"}
{"tgt": "if len(intervals) <= 1 {\n\treturn intervals\n}\nsort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i][0] <= intervals[j][0]\n})\nresult := make([][]int, 0)\ncur := intervals[0]\nfor i := 1; i < len(intervals); i++ {\n\tif intervals[i][0] > cur[1] {\n\t\tresult = append(result, cur)\n\t\tcur = intervals[i]\n\t} else {\n\t\tcur[1] = int(math.Max(float64(cur[1]), float64(intervals[i][1])))\n\t}\n}\nresult = append(result, cur)\nreturn result", "gen": "var a []int\na = append(a, 1)\na = append(a, 2)\na = append(a, 3)\na = append(a, 4)\na = append(a, 5)\na = append(a, 6)\na = append(a, 7)\na = append(a, 8)\na = append(a, 9)\na = append(a, 10)\na = append(a, 11)\na = append(a, 12)\na = append(a, 13)\na = append(a, 14)\na = append(a, 15)\na = append(a, 16)\na = append(a, 17)\na = append(a, 18)\na = append(a, 19)\na = append(a, 20)\na = append(a, 21)\na = append(a, 22)\na = append(a, 23)\na = append(a, 24)\na = append(a, 25)\na = append(a, 26)\na = append(a, 27)\na = append(a, 28)\na = append(a, 29)\na = append(a, 30)\na = append(a, 31)\na = append(a, 32)\na = append(a, 33)\na = append(a, 34)\na = append(a, 35)\na = append(a, 36)\na = append(a, 37)\na = append(a, 38)\na = append(a, 39)\na = append(a, 40)\na = append(a, 41)\na = append(a, 42)"}
{"tgt": "return Frame{}, false", "gen": "var a [4]int\nvar b [4]int\nvar c [4]int\nvar d [4]int\nvar e [4]int\nvar f [4]int\nvar g [4]int\nvar h [4]int\nvar i [4]int\nvar j [4]int\nvar k [4]int\nvar l [4]int\nvar m [4]int\nvar n [4]int\nvar o [4]int\nvar p [4]int\nvar q [4]int\nvar r [4]int\nvar s [4]int\nvar t [4]int\nvar u [4]int\nvar v [4]int\nvar w [4]int\nvar x [4]int\nvar y [4]int\nvar z [4]int\nvar a1 [4]int\nvar b1 [4]int\nvar c1 [4]int\nvar d1 [4]int\nvar e1 [4]int\nvar f1 [4]int\nvar g1 [4]int\nvar h1 [4]int\nvar i1 [4]int\nvar j1 [4]int\nvar k1 [4]int\nvar l1 [4]int\nvar m1 [4]int\nvar n1 [4]int\nvar o1 [4]int\nvar p1 [4]int\nvar q1 [4]int\nvar r1 [4]int\nvar s1 [4]int\nvar t1 [4]int\nvar u1 [4]int\nvar v1 [4]int\nvar w1 [4]int\nvar x1 [4]int\nvar y1 [4]int\nvar z1 [4]int\nvar a2 [4]int\nvar b2 [4]int\nvar c2 [4]int\nvar d2 [4]int\nvar e2 [4]int\nvar f2 [4]int\nvar g2"}
{"tgt": "dist := [200][][]int{}\nfor r := 0; r < R; r++ {\n\tfor c := 0; c < C; c++ {\n\t\td := abs(r-r0) + abs(c-c0)\n\t\tdist[d] = append(dist[d], []int{r, c})\n\t}\n}\nbegin, end := 0, 0\nfor d := 0; len(dist[d]) > 0; d++ {\n\tbegin, end = end, end+len(dist[d])\n\tcopy(res[begin:end], dist[d])\n}\nreturn res[:end]", "gen": "var a, b, c int\nfmt.Scan(&a, &b, &c)\nres := make([]int, 10000)\nfor i := 0; i < 10000; i++ {\n\tres[i] = abs(a-i) + abs(b-i) + abs(c-i)\n}\nsort.Ints(res)\nfor i := 0; i < 10000; i++ {\n\tif res[i] == 0 {\n\t\tcontinue\n\t}\n\tif res[i] > 199 {\n\t\tpanic(\"\")\n\t}\n\tif i > 199 {\n\t\tpanic(\"\")\n\t}\n\tif i < 0 {\n\t\tpanic(\"\")\n\t}\n\tres[i] = abs(a-i) + abs(b-i) + abs(c-i)\n}\nfor i := 0; i < 10000; i++ {\n\tif res[i] == 0 {\n\t\tcontinue\n\t}\n\tif res[i] > 199 {\n\t\tpanic(\"\")\n\t}\n\tif i > 199 {\n\t\tpanic(\"\")\n\t}\n\tif i < 0 {\n\t\tpanic(\"\")\n\t}\n\tres[i] = abs(a-i) + abs(b-i) + abs(c-i)\n}\nfor i := 0; i < 10000; i++ {\n\tif res[i] == 0 {\n\t\tcontinue\n\t}\n\tif res[i] > 199 {\n\t\tpanic(\"\")\n\t}\n\tif i > 199 {\n\t\tpanic(\"\")\n\t}\n\tif i < 0 {\n\t\tpanic(\"\")\n\t}\n\tres[i]"}
{"tgt": "n, err := io.Copy(h, r)\nif err != nil {\n\treturn err\n}\nif n != fSize {\n\treturn errReadSizeMismatch\n}\nreturn nil", "gen": "var r io.ReadSeeker\nvar w io.Writer\nvar err error\nvar n int64\nvar n2 int64\nvar n3 int64\nn, n2, n3, err = io.Copy(w, r)\nif err != nil {\n\treturn\n}\nif n != n2 {\n\treturn\n}\nif n != n3 {\n\treturn\n}\nreturn\n}\n"}
{"tgt": "if max.Sign() <= 0 {\n\tpanic(\"STR\")\n}\nn = new(big.Int)\nn.Sub(max, n.SetUint64(1))\nbitLen := n.BitLen()\nif bitLen == 0 {\n\treturn\n}\nk := (bitLen + 7) / 8\nb := uint(bitLen % 8)\nif b == 0 {\n\tb = 8\n}\nbytes := make([]byte, k)\nfor {\n\t_, err = io.ReadFull(rand, bytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbytes[0] &= uint8(int(1<<b) - 1)\n\tn.SetBytes(bytes)\n\tif n.Cmp(max) < 0 {\n\t\treturn\n\t}\n}", "gen": "var a big.Int\nvar b big.Int\nvar c big.Int\na.SetUint64(1)\nb.SetUint64(2)\nc.Sub(&a, &b)\nc.BitLen()\nif c.Sign() > 0 {\n\treturn\n}\nvar d []byte\nvar e []byte\nvar f []byte\nd = make([]byte, 8)\ne = make([]byte, 8)\nf = make([]byte, 8)\nio.ReadFull(os.Stdin, d)\nio.ReadFull(os.Stdin, e)\nio.ReadFull(os.Stdin, f)\nif len(d) > 7 {\n\treturn\n}\nif len(e) > 7 {\n\treturn\n}\nif len(f) > 7 {\n\treturn\n}\nif len(d) == 0 {\n\ta = c\n\tb = c\n\tc = c\n\treturn\n}\nif len(e) == 0 {\n\ta = c\n\tb = c\n\tc = c\n\treturn\n}\nif len(f) == 0 {\n\ta = c\n\tb = c\n\tc = c\n\treturn\n}\nif len(d) > 7 {\n\treturn\n}\nif len(e) > 7 {\n\treturn\n}\nif len(f) > 7 {\n\treturn\n}\nif len(d) == 0 {\n\ta = c\n\tb = c\n\tc = c\n\treturn\n}\nif len(e) == 0 {\n\ta = c\n\tb = c\n\tc = c\n\treturn\n}\nif len(f) == 0 {\n\ta = c\n\tb = c\n\tc = c\n\treturn\n}"}
{"tgt": "s := \"STR\"\nfmt.Println(reverseString(s))", "gen": "s := \"hello\"\nreverseString(s)\nfmt.Println(s)\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tnums: []int{1, 2, 3, 1},\n\t\tk:    3,\n\t\twant: true,\n\t},\n\t{\n\t\tnums: []int{1, 0, 1, 1},\n\t\tk:    1,\n\t\twant: true,\n\t},\n\t{\n\t\tnums: []int{1, 2, 3, 1, 2, 3},\n\t\tk:    2,\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := containsNearbyDuplicate(tt.nums, tt.k)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.nums, tt.k, got, tt.want)\n\t}\n}", "gen": "a := []int{1, 2, 3, 1}\nb := []int{1, 0, 1, 1}\nc := []int{1, 2, 3, 4, 4, 3, 4, 4, 3, 1}\nd := []int{1, 2, 3, 4, 4, 3, 4, 4, 3, 1}\nif containsNearbyDuplicate(a, 3) {\n\tt.Fatalf(\"containsNearbyDuplicate(%v, %d) = true, want false\", a, 3)\n}\nif !containsNearbyDuplicate(b, 2) {\n\tt.Fatalf(\"containsNearbyDuplicate(%v, %d) = false, want true\", b, 2)\n}\nif !containsNearbyDuplicate(c, 4) {\n\tt.Fatalf(\"containsNearbyDuplicate(%v, %d) = false, want true\", c, 4)\n}\nif !containsNearbyDuplicate(d, 3) {\n\tt.Fatalf(\"containsNearbyDuplicate(%v, %d) = false, want true\", d, 3)\n}\n}\n"}
{"tgt": "for V > 0 {\n\tV--\n\tif !isDroppedLeft(heights, K) && !isDroppedRight(heights, K) {\n\t\theights[K]++\n\t}\n}\nreturn heights", "gen": "var n, k int\nfmt.Scan(&n, &k)\na := make([]int, n)\nfor i := 0; i < n; i++ {\n\tfmt.Scan(&a[i])\n}\nfor i := 0; i < n; i++ {\n\tif isDroppedLeft(a, i, k) {\n\t\tcontinue\n\t}\n\tif isDroppedRight(a, i, k) {\n\t\tcontinue\n\t}\n\ta[i]++\n}\nfmt.Println(a[0], a[1], a[2])\n}\n"}
{"tgt": "qs := []question231{\n\t{\n\t\tpara231{1},\n\t\tans231{true},\n\t},\n\t{\n\t\tpara231{16},\n\t\tans231{true},\n\t},\n\t{\n\t\tpara231{218},\n\t\tans231{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans231, q.para231\n\tfmt.Printf(\"STR\", p, isPowerOfTwo(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%d %d %d\\n\", 1, 1, 16)\nvar a = 218\nvar b = 0\nvar c = 3\nvar d = 3\nvar e = 0\nvar f = 0\nvar g = 0\nvar h = 0\nvar i = 0\nvar j = 0\nvar k = 0\nvar l = 0\nvar m = 0\nvar n = 0\nvar o = 0\nvar p = 0\nvar q = 0\nvar r = 0\nvar s = 0\nvar t = 0\nvar u = 0\nvar v = 0\nvar w = 0\nvar x = 0\nvar y = 0\nvar z = 0\nvar aa = 0\nvar ab = 0\nvar ac = 0\nvar ad = 0\nvar ae = 0\nvar af = 0\nvar ag = 0\nvar ah = 0\nvar ai = 0\nvar aj = 0\nvar ak = 0\nvar al = 0\nvar am = 0\nvar an = 0\nvar ao = 0\nvar ap = 0\nvar aq = 0\nvar ar = 0\nvar as = 0\nvar at = 0\nvar au = 0\nvar av = 0\nvar aw = 0\nvar ax = 0\nvar ay = 0\nvar az = 0\nvar aaa = 0\nvar aab = 0\nvar aac = 0\nvar aad = 0\nvar aae = 0\nvar aaf = 0\nvar aag = 0\nvar aah = 0\nvar aai = 0\nvar aaj = 0\nvar aak = 0\nvar aal = 0\nvar aam = 0\nvar aan"}
{"tgt": "m := map[string]struct{}{}\nfor _, email := range emails {\n\tn := len(email)\n\tbs := strings.Builder{}\n\tignore := false\n\tfor i := 0; i < n; i++ {\n\t\tif email[i] == '@' {\n\t\t\tbs.WriteString(email[i:])\n\t\t\tbreak\n\t\t}\n\t\tif ignore || email[i] == '.' {\n\t\t\tcontinue\n\t\t}\n\t\tif email[i] == '+' {\n\t\t\tignore = true\n\t\t\tcontinue\n\t\t}\n\t\tbs.WriteByte(email[i])\n\t}\n\tm[bs.String()] = struct{}{}\n}\nreturn len(m)", "gen": "m := make(map[string]struct{})\nfor i := 0; i < 16; i++ {\n\tif i == 0 {\n\t\tm[string([]byte{0})] = struct{}{}\n\t}\n\tif i == 1 {\n\t\tm[string([]byte{46})] = struct{}{}\n\t}\n\tif i == 2 {\n\t\tm[string([]byte{43})] = struct{}{}\n\t}\n\tif i == 3 {\n\t\tm[string([]byte{64})] = struct{}{}\n\t}\n}\nreturn m\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinput1 string\n\tinput2 string\n\texpect bool\n}{\n\t{\"STR\", \"STR\", \"STR\", false},\n\t{\"STR\", \"STR\", \"STR\", false},\n\t{\"STR\", \"STR\", \"STR\", true},\n\t{\"STR\", \"STR\", \"STR\", true},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := canConstruct2(c.input1, c.input2)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.input1, c.input2)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.TestSolution2()\n}\n"}
{"tgt": "for {\n\tswitch r := l.next(); {\n\tcase unicode.IsNumber(r):\n\tcase r == \"STR\":\n\t\tl.backup()\n\t\tl.emit(itemEnd)\n\t\tl.chomp()\n\t\treturn byteRangeSet\n\tcase r == eof:\n\t\tl.emit(itemEnd)\n\t\treturn byteRangeSet\n\tdefault:\n\t\treturn l.error(\"STR\")\n\t}\n}", "gen": "var r *httprange.Lexer\nr = httprange.NewLexer([]byte(\"bytes=0-100\"))\nfor {\n\tif r.Next() == 44 {\n\t\tr.Backup()\n\t\tr.Emit(4)\n\t\tr.Chomp()\n\t\treturn byteRangeSet\n\t}\n\tif unicode.IsNumber(rune(r.Next())) {\n\t\tcontinue\n\t}\n\tif r.Next() == 44 {\n\t\tr.Backup()\n\t\tr.Emit(4)\n\t\treturn byteRangeSet\n\t}\n\tr.Error(errors.New(\"invalid byte range\"))\n\treturn byteRangeSet\n}\n}\n"}
{"tgt": "var res byte\nfor i := 0; i < len(s); i++ {\n\tres ^= s[i]\n}\nfor i := 0; i < len(t); i++ {\n\tres ^= t[i]\n}\nreturn res", "gen": "var a [10]byte\nvar b [10]byte\nvar c int\nvar d int\nvar e byte\nfor i := 0; i < len(a); i++ {\n\tif i < len(b) {\n\t\ta[i] = b[i]\n\t} else {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n}\nfor i := 0; i < len(c); i++ {\n\tif i < len(d) {\n\t\tc[i] = d[i]\n\t} else {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n}\ne = a[c]\ne = b[d]\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var s int\nfor _, c := range m.cache {\n\ts += c.Expire()\n}\nreturn s", "gen": "var c LRUCache\nfor i := 0; i < 100; i++ {\n\tc.Put(i, i)\n}\nfor i := 0; i < 100; i++ {\n\tc.Get(i)\n}\nfor i := 0; i < 100; i++ {\n\tc.Put(i, i)\n}\nfor i := 0; i < 100; i++ {\n\tc.Get(i)\n}\nfor i := 0; i < 100; i++ {\n\tc.Put(i, i)\n}\nfor i := 0; i < 100; i++ {\n\tc.Get(i)\n}\nfor i := 0; i < 100; i++ {\n\tc.Put(i, i)\n}\nfor i := 0; i < 100; i++ {\n\tc.Get(i)\n}\nfor i := 0; i < 100; i++ {\n\tc.Put(i, i)\n}\nfor i := 0; i < 100; i++ {\n\tc.Get(i)\n}\nfor i := 0; i < 100; i++ {\n\tc.Put(i, i)\n}\nfor i := 0; i < 100; i++ {\n\tc.Get(i)\n}\nfor i := 0; i < 100; i++ {\n\tc.Put(i, i)\n}\nfor i := 0; i < 100; i++ {\n\tc.Get(i)\n}\nfor i := 0; i < 100; i++ {\n\tc.Put(i, i)\n}\nfor i := 0; i < 100; i++ {\n\tc.Get(i)\n"}
{"tgt": "if len(num) <= 1 {\n\treturn\n}\nfor i := len(num) - 1; i > 0; i-- {\n\tif num[i-1] < num[i] {\n\t\tj := len(num) - 1\n\t\tfor num[i-1] >= num[j] {\n\t\t\tj--\n\t\t}\n\t\tnum[j], num[i-1] = num[i-1], num[j]\n\t\treverse(num[i:])\n\t\tfmt.Println(num)\n\t\treturn\n\t}\n\tif i == 1 {\n\t\treturn\n\t}\n}", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int"}
{"tgt": "words := map[string]struct{}{}\ncap, vowel := map[string]string{}, map[string]string{}\nfor _, word := range wordlist {\n\twords[word] = struct{}{}\n\tlower := strings.ToLower(word)\n\tif _, ok := cap[lower]; !ok {\n\t\tcap[lower] = word\n\t\tif _, ok = vowel[todev(lower)]; !ok {\n\t\t\tvowel[todev(lower)] = word\n\t\t}\n\t}\n}\nfor i, query := range queries {\n\tif _, ok := words[query]; ok {\n\t\tcontinue\n\t}\n\tlower := strings.ToLower(query)\n\tif word, ok := cap[lower]; ok {\n\t\tqueries[i] = word\n\t} else if word, ok = vowel[todev(lower)]; ok {\n\t\tqueries[i] = word\n\t} else {\n\t\tqueries[i] = \"STR\"\n\t}\n}\nreturn queries", "gen": "m := make(map[string]struct{})\nfor _, v := range []string{\"a\", \"b\", \"c\"} {\n\tm[strings.ToLower(v)] = struct{}{}\n}\nfor k, v := range m {\n\tfmt.Println(k, v)\n}\n}\n"}
{"tgt": "return c.name", "gen": "var a, b int\na, b = 32, 24\nreturn\n}\n\n// func main() {\n// \tvar a, b int\n// \ta, b = 32, 24\n// \treturn\n// }\n\n// func main() {\n// \tvar a, b int\n// \ta, b = 32, 24\n// \treturn\n// }\n\n// func main() {\n// \tvar a, b int\n// \ta, b = 32, 24\n// \treturn\n// }\n\n// func main() {\n// \tvar a, b int\n// \ta, b = 32, 24\n// \treturn\n// }\n\n// func main() {\n// \tvar a, b int\n// \ta, b = 32, 24\n// \treturn\n// }\n\n// func main() {\n// \tvar a, b int\n// \ta, b = 32, 24\n// \treturn\n// }\n\n// func main() {\n// \tvar a, b int\n// \ta, b = 32, 24\n// \treturn\n// }\n\n// func main() {\n// \tvar a, b int\n// \ta, b = 32, 24\n// \treturn\n// }\n\n// func main() {\n// \tvar a, b int\n// \ta, b = 32, 24\n// \treturn\n// }\n\n// func main() {\n// \tvar a, b int\n// \ta, b = 32, 24\n// \treturn\n// }\n\n// func main() {\n// \tvar a, b int\n// \ta, b = 32, 24\n// \treturn\n// }\n\n// func main() {\n// \tvar a, b int\n// \ta, b = 32, 24\n// \treturn\n// }\n\n// func main() {\n"}
{"tgt": "qs := []question984{\n\t{\n\t\tpara984{1, 2},\n\t\tans984{\"STR\"},\n\t},\n\t{\n\t\tpara984{4, 1},\n\t\tans984{\"STR\"},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans984, q.para984\n\tfmt.Printf(\"STR\", p, strWithout3a3b(p.a, p.b))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(strWithout3a3b(1, 2, 3))\nfmt.Println(strWithout3a3b(1, 2, 3, 4))\nfmt.Println(strWithout3a3b(1, 2, 3, 4, 5))\nfmt.Println(strWithout3a3b(1, 2, 3, 4, 5, 6))\n}\n"}
{"tgt": "var sum int\nfor i := start; i < end; i++ {\n\tsum += l[i]\n}\nreturn sum", "gen": "var a [5]int\nvar sum int\nfor i := 0; i < len(a); i++ {\n\tsum += a[i]\n}\nreturn sum\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "arr := make([]bool, 1000000)\narr[1] = true\nprime := 3\ncount := 13\nvar k, tmp, localCount int\nvar str string\nfor {\n\tfor k = prime * 2; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tstr = strconv.Itoa(prime)\n\t\tif prime > 100 {\n\t\t\tlocalCount = 1\n\t\t\tfor i := 0; i < len(str)-1; i++ {\n\t\t\t\tstr = str[1:] + str[0:1]\n\t\t\t\ttmp, _ = strconv.Atoi(str)\n\t\t\t\tif tmp > prime {\n\t\t\t\t\tcontinueprimeloop\n\t\t\t\t} else if !arr[tmp] && tmp%2 != 0 {\n\t\t\t\t\tlocalCount++\n\t\t\t\t} else {\n\t\t\t\t\tcontinueprimeloop\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount += localCount\n\t\t}\n\t} else {\n\t\tbreak\n\t}\n}\nprintln(count)", "gen": "var a []bool\nfor i := 0; i < 1000000; i++ {\n\ta = append(a, true)\n\ta[i] = false\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t} else {\n\t\ta[i] = true\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t} else {\n\t\ta[i] = true\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t} else {\n\t\ta[i] = true\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t} else {\n\t\ta[i] = true\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t} else {\n\t\ta[i] = true\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t} else {\n\t\ta[i] = true\n\t}\n}\nfor i := 0; i < 1000000; i++ {\n\tif a[i] {\n\t\ta[i] = false\n\t} else {\n\t\ta[i] = true\n\t}\n}\n"}
{"tgt": "count := make(map[string]int, len(words))\nfor _, w := range words {\n\tcount[w]++\n}\nfw := make(freWords, 0, len(count))\nfor w, c := range count {\n\tfw = append(fw, &entry{\n\t\tword:      w,\n\t\tfrequence: c,\n\t})\n}\nsort.Sort(fw)\nres := make([]string, k)\nfor i := 0; i < k; i++ {\n\tres[i] = fw[i].word\n}\nreturn res", "gen": "var m = make(map[string]int)\nvar s = []string{\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"}\nvar freq = make([]entry, 0)\nfor _, v := range s {\n\tm[v]++\n}\nfor k, v := range m {\n\tfreq = append(freq, entry{k, v})\n}\nsort.Sort(freWords(freq))\nvar res []string\nfor _, v := range freq {\n\tres = append(res, v.key)\n}\nreturn res\n}\n\ntype entry struct {\nkey   string\nvalue int\n}\n\ntype freWords []entry\n"}
{"tgt": "str1 := \"STR\"\nfmt.Println(largeGroupPositions(str1))\nstr2 := \"STR\"\nfmt.Println(largeGroupPositions(str2))\nstr3 := \"STR\"\nfmt.Println(largeGroupPositions(str3))\nstr4 := \"STR\"\nfmt.Println(largeGroupPositions(str4))", "gen": "fmt.Println(largeGroupPositions(\"abbxxxxzzy\"))\nfmt.Println(largeGroupPositions(\"abab\"))\nfmt.Println(largeGroupPositions(\"abc\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdddeeeeaabbbcd\"))\nfmt.Println(largeGroupPositions(\"abcdd"}
{"tgt": "list := NewCyclic()\nfillList(list, 3)\nwant := 1\ngot := list.Walk()\nif got.Val != want {\n\tt.Errorf(\"STR\", got)\n}", "gen": "list := NewCyclic(3)\nlist.Fill()\nif list.Walk() != 1 {\n\tt.Errorf(\"Walk() = %v, want 1\", list.Walk())\n}\n}\n"}
{"tgt": "m := make(map[int]struct{})\nfor _, num := range nums1 {\n\tm[num] = struct{}{}\n}\nnums := make([]int, 0)\nfor _, num := range nums2 {\n\tif _, ok := m[num]; ok {\n\t\tnums = append(nums, num)\n\t\tdelete(m, num)\n\t}\n}\nreturn nums", "gen": "m := make(map[int]struct{})\nfor i := 0; i < 1000000; i++ {\n\tm[i] = struct{}{}\n}\ns := make([]int, 0, len(m))\nfor k := range m {\n\ts = append(s, k)\n}\nreturn s\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "factorial := new(big.Int).MulRange(1, 100)\nbytes := factorial.Append([]byte{}, 10)\nsum := 0\nfor b := range bytes {\n\tsum += int(bytes[b] - '0')\n}\nfmt.Println(\"STR\", sum)", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a1 int\nvar b1 int\nvar c1 int\nvar d1 int\nvar e1 int\nvar f1 int\nvar g1 int\nvar h1 int\nvar i1 int\nvar j1 int\nvar k1 int\nvar l1 int\nvar m1 int\nvar n1 int\nvar o1 int\nvar p1 int\nvar q1 int\nvar r1 int\nvar s1 int\nvar t1 int\nvar u1 int\nvar v1 int\nvar w1 int\nvar x1 int\nvar y1 int\nvar z1 int\nvar a2 int\nvar b2 int\nvar c2 int\nvar d2 int\nvar e2 int\nvar f2 int\nvar g2 int\nvar h2 int\nvar i2 int\nvar j2 int\nvar k2 int\nvar l2 int\nvar m2 int\nvar n2 int\nvar o2 int\nvar p2 int\nvar q2 int\nvar r2 int\nvar s2 int\nvar t2 int\nvar u2 int\nvar v2 int\nvar w2 int\nvar x2 int\nvar y2 int\nvar z2 int\nvar a3 int\nvar b3 int\nvar c3 int\nvar d3 int\nvar e3 int\nvar f3 int\nvar g3 int\nvar h3 int\nvar i3 int\nvar j3"}
{"tgt": "qs := []question1003{\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{true},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{true},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{false},\n\t},\n\t{\n\t\tpara1003{\"STR\"},\n\t\tans1003{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1003, q.para1003\n\tfmt.Printf(\"STR\", p, isValid1003(p.s))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%s %d\\n\", \".LC20\", 6)\nfmt.Printf(\"%s %d\\n\", \".LC21\", 12)\nfmt.Printf(\"%s %d\\n\", \".LC22\", 1)\nfmt.Printf(\"%s %d\\n\", \".LC23\", 6)\nfmt.Printf(\"%s %d\\n\", \".LC24\", 6)\nfmt.Printf(\"%s %d\\n\", \".LC25\", 37)\nfmt.Printf(\"%s %d\\n\", \".LC26\", 3)\nvar a [][]int\nfor i := 0; i < 4; i++ {\n\ta = append(a, make([]int, 4))\n}\nfmt.Printf(\"%s %d\\n\", \".LC27\", 0)\nfmt.Printf(\"%s %d\\n\", \".LC28\", 0)\nfmt.Printf(\"%s %d\\n\", \".LC29\", 0)\nfmt.Printf(\"%s %d\\n\", \".LC30\", 0)\nfmt.Printf(\"%s %d\\n\", \".LC31\", 0)\nfmt.Printf(\"%s %d\\n\", \".LC32\", 0)\nfmt.Printf(\"%s %d\\n\", \".LC33\", 0)\nfmt.Printf(\"%s %d\\n\", \".LC34\", 0)\nfmt.Printf(\"%s %d\\n\", \".LC35\", 0)\nfmt.Printf(\"%s %d\\n\", \".LC36\", 0)\nfmt.Printf(\"%s %d\\n\", \".LC37\", 0)\nfmt.Printf(\"%s %d\\n\", \".LC38\", 0)\nfmt.Printf(\"%s %d\\n\", \".LC39\", 0)\nfmt.Printf(\"%s %d\\n\", \".LC40\", 0)\nfmt.Printf(\"%s %d\\n\", \".LC"}
{"tgt": "var v *error\nreturn v", "gen": "var err error\nreturn\n}\n"}
{"tgt": "m := map[string]int{}\nrets := []string{}\nfor i := 0; i <= len(s)-10; i++ {\n\tsub := string(s[i : i+10])\n\tm[sub]++\n\tif m[sub] == 2 {\n\t\trets = append(rets, sub)\n\t}\n}\nreturn rets", "gen": "m := make(map[string]int)\ns := make([]string, 10)\nfor i := 0; i < 10; i++ {\n\ts[i] = strconv.Itoa(i)\n\tm[s[i]] = i + 1\n}\nfmt.Println(m)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "q[i], q[j] = q[j], q[i]", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 4\nb[1] = 5\nb[2] = 6\nc[0] = 7\nc[1] = 8\nc[2] = 9\na[0] = b[0] + c[0]\na[1] = b[1] + c[1]\na[2] = b[2] + c[2]\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "runes := []rune(s)\nlength := len(runes)\nif length <= 1 {\n\treturn s\n}\nmaxRune := runes[0:1]\nfor i := 0; i < length-1; i++ {\n\ttmpRune := findPalindrome(runes, i, i)\n\tif len(tmpRune) > len(maxRune) {\n\t\tmaxRune = tmpRune\n\t}\n\tif runes[i] == runes[i+1] {\n\t\ttmpRune = findPalindrome(runes, i, i+1)\n\t\tif len(tmpRune) > len(maxRune) {\n\t\t\tmaxRune = tmpRune\n\t\t}\n\t}\n}\nreturn string(maxRune)", "gen": "s := \"abccba\"\nr := findPalindrome(s)\nfmt.Println(r)\n}\n"}
{"tgt": "stack, j, N := []int{}, 0, len(pushed)\nfor _, x := range pushed {\n\tstack = append(stack, x)\n\tfmt.Printf(\"STR\", stack, j)\n\tfor len(stack) != 0 && j < N && stack[len(stack)-1] == popped[j] {\n\t\tstack = stack[0 : len(stack)-1]\n\t\tj++\n\t}\n\tfmt.Printf(\"STR\", stack, j)\n}\nreturn j == N", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar bb [3]int\nvar cc [3]int\nvar dd [3]int\nvar ee [3]int\nvar ff [3]int\nvar gg [3]int\nvar hh [3]int\nvar ii [3]int\nvar jj [3]int\nvar kk [3]int\nvar ll [3]int\nvar mm [3]int\nvar nn [3]int\nvar oo [3]int\nvar pp [3]int\nvar qq [3]int\nvar rr [3]int\nvar ss [3]int\nvar tt [3]int\nvar uu [3]int\nvar vv [3]int\nvar ww [3]int\nvar xx [3]int\nvar yy [3]int\nvar zz [3]int\nvar aa1 [3]int\nvar bb1 [3]int\nvar cc1 [3]int\nvar dd1 [3]int\nvar ee1 [3]int\nvar ff1 [3]int\nvar gg1 [3]int\nvar hh1"}
{"tgt": "return numDistinctBytes([]byte(s), []byte(t))", "gen": "fmt.Println(numDistinctBytes(\"abc\", \"ahbgdc\"))\n}\n"}
{"tgt": "return key1.(int) < key2.(int)", "gen": "var a int\nvar b int\nvar c int\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == b {\n\tpanic(\"c == b\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\n}\n"}
{"tgt": "return x != y", "gen": "var a float32 = 1.0\nvar b float32 = 2.0\nvar c bool\nif a < b {\n\tc = true\n} else {\n\tc = false\n}\nfmt.Println(c)\n}\n\n// 1. \u628a a < b \u8fd9\u4e2a\u6761\u4ef6\u5224\u65ad\u7684\u7ed3\u679c\u5b58\u50a8\u5230 eax \u5bc4\u5b58\u5668\u4e2d\uff0c\u7136\u540e\u628a eax \u5bc4\u5b58\u5668\u7684\u503c\u5b58\u50a8\u5230 c \u53d8\u91cf\u4e2d\n// 2. \u628a c \u53d8\u91cf\u7684\u503c\u5b58\u50a8\u5230 eax \u5bc4\u5b58\u5668\u4e2d\n// 3. \u628a eax \u5bc4\u5b58\u5668\u7684\u503c\u5b58\u50a8\u5230 c \u53d8\u91cf\u4e2d\n// 4. \u628a c \u53d8\u91cf\u7684\u503c\u5b58\u50a8\u5230 eax \u5bc4\u5b58\u5668\u4e2d\n// 5. \u628a eax \u5bc4\u5b58\u5668\u7684\u503c\u5b58\u50a8\u5230 c \u53d8\u91cf\u4e2d\n// 6. \u628a c \u53d8\u91cf\u7684\u503c\u5b58\u50a8\u5230 eax \u5bc4\u5b58\u5668\u4e2d\n// 7. \u628a eax \u5bc4\u5b58\u5668\u7684\u503c\u5b58\u50a8\u5230 c \u53d8\u91cf\u4e2d\n// 8. \u628a c \u53d8\u91cf\u7684\u503c\u5b58\u50a8\u5230 eax \u5bc4\u5b58\u5668\u4e2d\n// 9. \u628a eax \u5bc4\u5b58\u5668\u7684\u503c\u5b58\u50a8\u5230 c \u53d8\u91cf\u4e2d\n// 10. \u628a c \u53d8\u91cf\u7684\u503c\u5b58\u50a8\u5230 eax \u5bc4\u5b58\u5668\u4e2d\n// 11. \u628a eax \u5bc4\u5b58\u5668\u7684\u503c\u5b58\u50a8\u5230 c \u53d8\u91cf\u4e2d\n// 12. \u628a c \u53d8\u91cf\u7684\u503c\u5b58\u50a8\u5230 eax \u5bc4\u5b58\u5668\u4e2d\n// 13. \u628a eax \u5bc4\u5b58\u5668\u7684\u503c\u5b58\u50a8\u5230 c \u53d8\u91cf\u4e2d\n// 14. \u628a c \u53d8\u91cf\u7684\u503c\u5b58\ufffd\ufffd"}
{"tgt": "for prime := range sig(a) {\n\tif sig(b)[prime] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var m map[int64]bool\nvar sig int64\nfor k, _ := range m {\n\tif k == sig {\n\t\treturn\n\t}\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var low, mid, high int = 0, len(sorted) / 2, len(sorted)\nfor low < high {\n\tcurr := sorted[mid]\n\tswitch {\n\tcase curr == target:\n\t\treturn mid\n\tcase inRange(sorted[mid:high], target):\n\t\tlow = mid\n\t\tmid = (low + high) / 2\n\tdefault:\n\t\thigh = mid\n\t\tmid = (low + high) / 2\n\t}\n}\nreturn -1", "gen": "var a []int\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif i < 0 || i >= len(a) {\n\t\tpanic(\"index out of range\")\n\t}\n\tif i < len(a) {\n\t\tif i >= 0 {\n\t\t\tif i < len(a) {\n\t\t\t\tif i < len(a) {\n\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n"}
{"tgt": "if n < sumOfProperDivisors(n) {\n\treturn true\n}\nreturn false", "gen": "var n int\nfmt.Scan(&n)\nif sumOfProperDivisors(n) == n {\n\tfmt.Println(\"Yes\")\n} else {\n\tfmt.Println(\"No\")\n}\n}\n"}
{"tgt": "ss := []string{S}\nfor i := 0; i < len(S); i++ {\n\tif S[i] < '0' || S[i] > '9' {\n\t\tfor _, s := range ss {\n\t\t\tb := []byte(s)\n\t\t\tletterCase(b, i)\n\t\t\tss = append(ss, string(b))\n\t\t}\n\t}\n}\nreturn ss", "gen": "var s string\nvar res []string\nfor i := 0; i < len(s); i++ {\n\tif s[i] == ' ' {\n\t\tcontinue\n\t}\n\tif s[i] >= 'a' && s[i] <= 'z' {\n\t\tres = append(res, string(s[i]))\n\t} else if s[i] >= 'A' && s[i] <= 'Z' {\n\t\tres = append(res, string(s[i]+32))\n\t} else {\n\t\tres = append(res, string(s[i]))\n\t}\n}\nreturn res\n}\n"}
{"tgt": "digits := convert(N + 1)\nbits := len(digits)\nnoRepeat := 0\nfor b := 1; b < bits; b++ {\n\tnoRepeat += 9 * count(9, b-1)\n}\nhasSeen := make(map[int]bool, 10)\nfor b := 0; b < bits; b++ {\n\td := 0\n\tif b == 0 {\n\t\td = 1\n\t}\n\tfor ; d < digits[b]; d++ {\n\t\tif !hasSeen[d] {\n\t\t\tnoRepeat += count(9-b, bits-b-1)\n\t\t}\n\t}\n\tif hasSeen[digits[b]] {\n\t\tbreak\n\t}\n\thasSeen[digits[b]] = true\n}\nreturn N - noRepeat", "gen": "var n int\nfmt.Scan(&n)\nvar a []int\nfor i := 0; i < n; i++ {\n\tvar tmp int\n\tfmt.Scan(&tmp)\n\ta = append(a, tmp)\n}\nvar ans int\nfor i := 0; i < n; i++ {\n\tans += count(a[i], 9)\n}\nfmt.Println(ans)\n}\n"}
{"tgt": "b := NewLRUCache(1000)\nfor i := 0; i < 1000; i++ {\n\tb.Set(randomString(2), \"STR\", expire)\n}\nreturn b", "gen": "cache := lrucache.NewLRUCache(1000)\nfor i := 0; i < 1000; i++ {\n\tcache.Set(2, randomString(2))\n}\nreturn cache\n}\n"}
{"tgt": "h := &IntMaxHeap{}\nheap.Init(h)\nheap.Push(h, 7)\nheap.Push(h, 3)\nheap.Push(h, 2)\nheap.Push(h, 1)\nheap.Push(h, 5)\nheap.Push(h, 5)\nheap.Push(h, 6)\nheap.Push(h, 7)\nfmt.Printf(\"STR\", (*h))\nfor h.Len() > 0 {\n\tfmt.Printf(\"STR\", heap.Pop(h))\n}", "gen": "heap := &Solution{[]int{3, 2, 1}}\nheap.Init()\nheap.Push(2)\nheap.Push(1)\nheap.Push(5)\nheap.Push(1)\nheap.Push(5)\nheap.Push(8)\nheap.Push(10)\nheap.Push(11)\nheap.Push(12)\nheap.Push(13)\nheap.Push(14)\nheap.Push(15)\nheap.Push(16)\nheap.Push(17)\nheap.Push(18)\nheap.Push(19)\nheap.Push(20)\nheap.Push(21)\nheap.Push(22)\nheap.Push(23)\nheap.Push(24)\nheap.Push(25)\nheap.Push(26)\nheap.Push(27)\nheap.Push(28)\nheap.Push(29)\nheap.Push(30)\nheap.Push(31)\nheap.Push(32)\nheap.Push(33)\nheap.Push(34)\nheap.Push(35)\nheap.Push(36)\nheap.Push(37)\nheap.Push(38)\nheap.Push(39)\nheap.Push(40)\nheap.Push(41)\nheap.Push(42)\nheap.Push(43)\nheap.Push(44)\nheap.Push(45)\nheap.Push(46)\nheap.Push(47)\nheap.Push(48)\nheap.Push(49)\nheap.Push(50)\nheap.Push(51)"}
{"tgt": "return MyCalendar{\n\tbooks: make([]seg, 0),\n}", "gen": "var s Solution\ns.seg = make([]int, 0)\nreturn\n}\n"}
{"tgt": "var buf bytes.Buffer\nbuf.WriteByte(\"STR\")\nfor i, word := range s.words {\n\tif word == 0 {\n\t\tcontinue\n\t}\n\tfor j := 0; j < 64; j++ {\n\t\tif word&(1<<uint(j)) != 0 {\n\t\t\tif buf.Len() > len(\"STR\") {\n\t\t\t\tbuf.WriteByte(\"STR\")\n\t\t\t}\n\t\t\tfmt.Fprintf(&buf, \"STR\", 64*i+j)\n\t\t}\n\t}\n}\nbuf.WriteByte(\"STR\")\nreturn buf.String()", "gen": "var buf bytes.Buffer\nbuf.WriteByte(123)\nfor i := 0; i < 64; i++ {\n\tbuf.WriteByte(byte(i))\n}\nfmt.Fprintf(&buf, \"%d\", 1)\nfmt.Fprintf(&buf, \"%d\", 2)\nfmt.Fprintf(&buf, \"%d\", 3)\nfmt.Fprintf(&buf, \"%d\", 4)\nfmt.Fprintf(&buf, \"%d\", 5)\nfmt.Fprintf(&buf, \"%d\", 6)\nfmt.Fprintf(&buf, \"%d\", 7)\nfmt.Fprintf(&buf, \"%d\", 8)\nfmt.Fprintf(&buf, \"%d\", 9)\nfmt.Fprintf(&buf, \"%d\", 10)\nfmt.Fprintf(&buf, \"%d\", 11)\nfmt.Fprintf(&buf, \"%d\", 12)\nfmt.Fprintf(&buf, \"%d\", 13)\nfmt.Fprintf(&buf, \"%d\", 14)\nfmt.Fprintf(&buf, \"%d\", 15)\nfmt.Fprintf(&buf, \"%d\", 16)\nfmt.Fprintf(&buf, \"%d\", 17)\nfmt.Fprintf(&buf, \"%d\", 18)\nfmt.Fprintf(&buf, \"%d\", 19)\nfmt.Fprintf(&buf, \"%d\", 20)\nfmt.Fprintf(&buf, \"%d\", 21)\nfmt.Fprintf(&buf, \"%d\", 22)\nfmt.Fprintf(&buf, \"%d\", 23)\nfmt.Fprintf(&buf, \"%d\", 24)\nfmt.Fprintf(&buf, \"%d\", 25)\nfmt.Fprintf(&buf, \"%d\", 26)\nfmt.Fprintf(&buf, \"%d\", 27)\nfmt.Fprintf(&buf, \"%d\", 28)\nfmt.Fprintf(&buf, \"%d\","}
{"tgt": "matrix := [][]int{\n\t{5, 1, 9, 11},\n\t{2, 4, 8, 10},\n\t{13, 3, 6, 7},\n\t{15, 14, 12, 16},\n}\nmatrix = rotate(matrix)\nfor _, nums := range matrix {\n\tfor _, num := range nums {\n\t\tfmt.Print(num, \"STR\")\n\t}\n\tfmt.Println()\n}", "gen": "var a [5]int\na[0] = 1\na[1] = 9\na[2] = 11\na[3] = 2\na[4] = 4\nvar b [5]int\nb[0] = 8\nb[1] = 10\nb[2] = 13\nb[3] = 3\nb[4] = 6\nvar c [5]int\nc[0] = 7\nc[1] = 15\nc[2] = 14\nc[3] = 12\nc[4] = 16\nrotate(a[:], b[:], c[:])\nfmt.Println(a)\nfmt.Println(b)\nfmt.Println(c)\n}"}
{"tgt": "return MyQueue{\n\tlist: list.New(),\n}", "gen": "var l *z2flist.List\nl = z2flist.New()\n}\n"}
{"tgt": "res := sizeOfLargestBST(tree)\nreturn res.AnsPtr", "gen": "root := &TreeNode{Val: 1}\nroot.Left = &TreeNode{Val: 2}\nroot.Right = &TreeNode{Val: 3}\nroot.Left.Left = &TreeNode{Val: 4}\nroot.Left.Right = &TreeNode{Val: 5}\nroot.Right.Left = &TreeNode{Val: 6}\nroot.Right.Right = &TreeNode{Val: 7}\nroot.Left.Left.Left = &TreeNode{Val: 8}\nroot.Left.Left.Right = &TreeNode{Val: 9}\nroot.Left.Right.Left = &TreeNode{Val: 10}\nroot.Left.Right.Right = &TreeNode{Val: 11}\nroot.Right.Left.Left = &TreeNode{Val: 12}\nroot.Right.Left.Right = &TreeNode{Val: 13}\nroot.Right.Right.Left = &TreeNode{Val: 14}\nroot.Right.Right.Right = &TreeNode{Val: 15}\nroot.Left.Left.Left.Left = &TreeNode{Val: 16}\nroot.Left.Left.Left.Right = &TreeNode{Val: 17}\nroot.Left.Left.Right.Left = &TreeNode{Val: 18}\nroot.Left.Left.Right.Right = &TreeNode{Val: 19}\nroot.Left.Right.Left.Left = &TreeNode{Val: 20}\nroot.Left.Right.Left.Right = &TreeNode{Val: 21}\nroot.Left.Right.Right.Left = &TreeNode{Val: 22}\nroot.Left.Right.Right.Right = &TreeNode{Val: 23}\nroot.Right.Left.Left.Left = &TreeNode{Val: 24}\nroot.Right.Left.Left.Right = &TreeNode{Val: 25}\nroot.Right.Left.Right.Left ="}
{"tgt": "sort.Ints(candidates)\nvar res [][]int\ndfs(candidates, nil, target, 0, &res)\nreturn res", "gen": "var a []int\nsort.Ints(a)\ndfs(a, 0, 0, 0)\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := checkRecord(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(checkRecord(\"PPALL\"))\nfmt.Println(checkRecord(\"PPALLL\"))\nfmt.Println(checkRecord(\"PPALLLL\"))\nfmt.Println(checkRecord(\"PPALLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(checkRecord(\"PPALLLLLLLLLLLLLLLLLLLLLLLLLL\"))\nfmt.Println(check"}
{"tgt": "for i := 1; i < len(arr); i++ {\n\tvalue := arr[i]\n\tj := i - 1\n\tfor j >= 0 && arr[j] > value {\n\t\tarr[j+1] = arr[j]\n\t\tj = j - 1\n\t}\n\tarr[j+1] = value\n}", "gen": "var a [10]int\nfor i := 0; i < len(a); i++ {\n\ta[i] = i\n\ta[i+1] = a[i]\n\tif i == len(a)-1 {\n\t\tbreak\n\t}\n\tif a[i] == a[i+1] {\n\t\tcontinue\n\t}\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var nums []int\nvar ret bool\nnums = []int{1, 2, 3, 1}\nret = true\nif ret != containsDuplicate(nums) {\n\tt.Fatalf(\"STR\", ret)\n}\nnums = []int{1, 2, 3, 4}\nret = false\nif ret != containsDuplicate(nums) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "tests := []struct {\n\tnums   []int\n\toutput bool\n}{\n\t{[]int{1, 2, 3, 1}, true},\n\t{[]int{1, 2, 3, 4}, false},\n\t{[]int{1, 1, 1, 3, 3, 4, 3, 2, 4, 2}, true},\n}\nfor _, tt := range tests {\n\ttestname := fmt.Sprintf(\"%v\", tt.nums)\n\tt.Run(testname, func(t *testing.T) {\n\t\tans := containsDuplicate(tt.nums)\n\t\tif ans != tt.output {\n\t\t\tt.Errorf(\"got %v, want %v\", ans, tt.output)\n\t\t}\n\t})\n}\n}\n"}
{"tgt": "switch {\ncase head.Left == nil && head.Right == nil:\n\treturn head.Value\ncase head.Left != nil && head.Right != nil:\n\tleft := head.Value + MinPathSum(head.Left)\n\tright := head.Value + MinPathSum(head.Right)\n\treturn min(left, right)\ncase head.Left != nil:\n\treturn head.Value + MinPathSum(head.Left)\ndefault:\n\treturn head.Value + MinPathSum(head.Right)\n}", "gen": "var a [][]int\nvar b int\nif len(a) == 0 {\n\tb = 0\n} else {\n\tif len(a[0]) == 0 {\n\t\tb = 0\n\t} else {\n\t\tif len(a) == 1 {\n\t\t\tb = a[0][0]\n\t\t} else {\n\t\t\tif len(a[0]) == 1 {\n\t\t\t\tb = a[0][0]\n\t\t\t} else {\n\t\t\t\tif len(a) == 1 {\n\t\t\t\t\tb = a[0][0]\n\t\t\t\t} else {\n\t\t\t\t\tif len(a[0]) == 1 {\n\t\t\t\t\t\tb = a[0][0]\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif len(a) == 1 {\n\t\t\t\t\t\t\tb = a[0][0]\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif len(a[0]) == 1 {\n\t\t\t\t\t\t\t\tb = a[0][0]\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif len(a) == 1 {\n\t\t\t\t\t\t\t\t\tb = a[0][0]\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif len(a[0]) == 1 {\n\t\t\t\t\t\t\t\t\t\tb = a[0][0]\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif len(a) == 1 {\n\t\t\t\t\t\t\t\t\t\t\tb = a[0][0]\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tif len(a[0]) == 1 {\n"}
{"tgt": "sets := make([][]int, 1, 1<<uint(len(nums)))\nfor _, num := range nums {\n\tfor _, set := range sets {\n\t\ts := make([]int, len(set), len(set)+1)\n\t\tcopy(s, set)\n\t\tsets = append(sets, append(s, num))\n\t}\n}\nreturn sets", "gen": "var a []int\nfor i := 0; i < 64; i++ {\n\ta = append(a, i)\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "out := 100\nif x := p33(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "p33 := 100\nif p33 != 100 {\n\tvar p34 interface{}\n\tp34 = p33\n\tvar p35 interface{}\n\tp35 = p34\n\tvar p36 interface{}\n\tp36 = p35\n\ttesting.T.Errorf(0, 24, \"p33 != 100\", p36)\n}\n}\n\n// Testing that we can handle a function call with a constant\n// argument.\n//\n// func main() {\n// \tp33 := 100\n// \tif p33 != 100 {\n// \t\tvar p34 interface{}\n// \t\tp34 = p33\n// \t\tvar p35 interface{}\n// \t\tp35 = p34\n// \t\tvar p36 interface{}\n// \t\tp36 = p35\n// \t\ttesting.T.Errorf(0, 24, \"p33 != 100\", p36)\n// \t}\n// }\n//\n// func main() {\n// \tp33 := 100\n// \tif p33 != 100 {\n// \t\tvar p34 interface{}\n// \t\tp34 = p33\n// \t\tvar p35 interface{}\n// \t\tp35 = p34\n// \t\tvar p36 interface{}\n// \t\tp36 = p35\n// \t\ttesting.T.Errorf(0, 24, \"p33 != 100\", p36)\n// \t}\n// }\n//\n// func main() {\n// \tp33 := 100\n// \tif p33 != 100 {\n// \t\tvar p34 interface{}\n// \t\tp34 = p33\n// \t\tvar p35 interface{}\n// \t\tp35 = p34\n//"}
{"tgt": "steps := countSteps([]int{0, 0}, target)\nfor _, g := range ghosts {\n\tif steps >= countSteps(g, target) {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var n, m int\nfmt.Scan(&n, &m)\nsteps := countSteps(n, m)\nif steps > 2 {\n\tfmt.Println(\"Impossible\")\n\treturn\n}\nif steps == 2 {\n\tfmt.Println(\"2\")\n\treturn\n}\nif steps == 1 {\n\tfmt.Println(\"1\")\n\treturn\n}\nfmt.Println(\"0\")\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CourseOrder(tc.prereqs); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "if nil == root || k <= 0 {\n\treturn nil\n}\nvar target *BinaryTreeNode\nif root.left != nil {\n\ttarget = kthNode(root.left, k)\n}\nif target == nil {\n\tif 1 == k {\n\t\ttarget = root\n\t} else {\n\t\tk--\n\t}\n}\nif target == nil && root.right != nil {\n\ttarget = kthNode(root.right, k)\n}\nreturn target", "gen": "var head *Node\nvar k int\nk = 0\nif head == nil {\n\tif k == 0 {\n\t\treturn head\n\t}\n\tif k <= 1 {\n\t\treturn head\n\t}\n}\nif k > 0 {\n\tif head.Next == nil {\n\t\treturn head\n\t}\n\tif k <= 1 {\n\t\treturn head.Next\n\t}\n\tk--\n\tfor head.Next != nil {\n\t\tif k == 0 {\n\t\t\treturn head.Next\n\t\t}\n\t\tk--\n\t\thead = head.Next\n\t}\n}\nreturn head\n}\n"}
{"tgt": "nums := []int{0, 0, 1, 2}\nfmt.Println(dominantIndex(nums))", "gen": "fmt.Println(dominantIndex([]int{1, 2, 3, 4, 5, 6}))\n}\n"}
{"tgt": "if root == nil {\n\treturn nil\n}\nif root.Val < L {\n\treturn trimBST(root.Right, L, R)\n}\nif root.Val > R {\n\treturn trimBST(root.Left, L, R)\n}\nroot.Left = trimBST(root.Left, L, R)\nroot.Right = trimBST(root.Right, L, R)\nreturn root", "gen": "root := &TreeNode{Val: 3, Left: &TreeNode{Val: 0, Left: &TreeNode{Val: 1}, Right: &TreeNode{Val: 2}}, Right: &TreeNode{Val: 4}}\nleft := 1\nright := 3\nres := trimBST(root, left, right)\nfmt.Println(res)\n}\n"}
{"tgt": "length := len(matrix)\nfor i := 0; 2*i < length-1; i++ {\n\tfor j := i; j < length-i-1; j++ {\n\t\tmatrix[i][j], matrix[j][length-i-1], matrix[length-i-1][length-j-1], matrix[length-j-1][i] =\n\t\t\tmatrix[length-j-1][i], matrix[i][j], matrix[j][length-i-1], matrix[length-i-1][length-j-1]\n\t}\n}", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "p = len(postorder) - 1\nidxMap = make(map[int]int)\nfor i, v := range inorder {\n\tidxMap[v] = i\n}\nreturn build(0, len(inorder)-1, postorder)", "gen": "p := 0\nidxMap := make(map[int]int)\nfor i := 0; i < len(nums); i++ {\n\tif _, ok := idxMap[i]; !ok {\n\t\tidxMap[i] = i\n\t}\n}\nfor i := 0; i < len(nums); i++ {\n\tif _, ok := idxMap[i]; ok {\n\t\tidxMap[i] = i\n\t}\n}\nreturn build(nums, idxMap)\n}\n"}
{"tgt": "sum := 0\nfor i := 0; i < 1000; i++ {\n\tif (i%3 == 0) || (i%5 == 0) {\n\t\tsum += i\n\t}\n}\nfmt.Print(sum, \"STR\")", "gen": "var sum int\nfor i := 0; i < 1000; i++ {\n\tif i%3 == 0 {\n\t\tsum += i\n\t}\n\tif i%5 == 0 {\n\t\tsum += i\n\t}\n}\nfmt.Println(sum)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "qs := []question856{\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{1},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{2},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{2},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{6},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{3},\n\t},\n\t{\n\t\tpara856{\"STR\"},\n\t\tans856{8},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans856, q.para856\n\tfmt.Printf(\"STR\", p, scoreOfParentheses(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%s %d\\n\", \".LC17\", 2)\nfmt.Printf(\"%s %d\\n\", \".LC18\", 4)\nfmt.Printf(\"%s %d\\n\", \".LC19\", 4)\nfmt.Printf(\"%s %d\\n\", \".LC20\", 2)\nfmt.Printf(\"%s %d\\n\", \".LC21\", 4)\nfmt.Printf(\"%s %d\\n\", \".LC22\", 8)\nfmt.Printf(\"%s %d\\n\", \".LC23\", 6)\nfmt.Printf(\"%s %d\\n\", \".LC24\", 4)\nfmt.Printf(\"%s %d\\n\", \".LC25\", 3)\nvar a = [6]int{2, 2, 0, 0, 0, 0}\nfmt.Printf(\"%s %d %d %d\\n\", \".LC23\", a[0], a[1], a[2])\nvar b = [6]int{2, 2, 0, 0, 0, 0}\nfmt.Printf(\"%s %d %d %d\\n\", \".LC24\", b[0], b[1], b[2])\nvar c = [6]int{2, 2, 0, 0, 0, 0}\nfmt.Printf(\"%s %d %d %d\\n\", \".LC23\", c[0], c[1], c[2])\nvar d = [8]int{8, 6, 6, 2, 2, 0, 0, 0}\nfmt.Printf(\"%s %d %d %d\\n\", \".LC24\", d[0], d[1], d[2])\nvar e = [8]int{8, 6, 6, 2, 2, 0, 0, 0}\nfmt.Printf(\"%s %d %d %d\\n\", \".LC24\", e[0], e[1"}
{"tgt": "const (\n\txmin, ymin, xmax, ymax = -2, -2, +2, +2\n\twidth, height          = 1024, 1024\n)\nimg := image.NewRGBA(image.Rect(0, 0, width, height))\nfor py := 0; py < height; py++ {\n\ty := float64(py)/height*(ymax-ymin) + ymin\n\tfor px := 0; px < width; px++ {\n\t\tx := float64(px)/width*(xmax-xmin) + xmin\n\t\tz := complex(x, y)\n\t\timg.Set(px, py, mandelbrot(z))\n\t}\n}\npng.Encode(os.Stdout, img)", "gen": "var width, height int\nfmt.Scan(&width, &height)\nimg := image.NewRGBA(image.Rect(0, 0, width, height))\nfor y := 0; y < height; y++ {\n\tfor x := 0; x < width; x++ {\n\t\tz := complex(float64(x)/float64(width), float64(y)/float64(height))\n\t\timg.Set(x, y, mandelbrot(z))\n\t}\n}\npng.Encode(os.Stdout, img)\n}"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif start, end := BusiestBuildingTimes(tc.moves); start != tc.start || end != tc.end {\n\t\tt.Errorf(\"STR\", tc.start, tc.end, start, end)\n\t}\n}", "gen": "fmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n}))\nfmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n\t{10, 11, 12},\n}))\nfmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t{13, 14, 15},\n}))\nfmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t{13, 14, 15},\n\t{16, 17, 18},\n}))\nfmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t{13, 14, 15},\n\t{16, 17, 18},\n\t{19, 20, 21},\n}))\nfmt.Println(BusiestBuildingTimes([][]int{\n\t{1, 2, 3},\n\t{3, 4, 5},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t"}
{"tgt": "n := len(cost)\ndp := make([]int, n+1)\nfor i := 2; i <= n; i++ {\n\tdp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])\n}\nreturn dp[n]", "gen": "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nb := make([]int, len(a))\nfor i := 0; i < len(a); i++ {\n\tb[i] = min(a[i], a[i+1])\n}\nfmt.Println(b)\n}"}
{"tgt": "return new(runningSchTaskList).init(tasks)", "gen": "var rt *runningSchTaskList\nrt = new(runningSchTaskList)\nrt.init(32, 24, 16)\n}\n"}
{"tgt": "return area(A, B, C, D) + area(E, F, G, H) - area(max(A, E), max(B, F), min(C, G), min(D, H))", "gen": "var a, b, c, d float64\nfmt.Scan(&a, &b, &c, &d)\nfmt.Println(area(a, b, c, d))\nfmt.Println(area(a, b, d, c))\nfmt.Println(area(a, d, c, b))\nfmt.Println(area(d, c, b, a))\nfmt.Println(area(d, c, a, b))\nfmt.Println(area(c, d, b, a))\nfmt.Println(area(c, a, b, d))\nfmt.Println(area(b, d, a, c))\nfmt.Println(area(b, c, d, a))\nfmt.Println(area(a, b, c, d))\nfmt.Println(max(a, b, c, d))\nfmt.Println(max(a, b, d, c))\nfmt.Println(max(a, c, d, b))\nfmt.Println(max(d, c, b, a))\nfmt.Println(max(d, c, a, b))\nfmt.Println(max(c, d, b, a))\nfmt.Println(max(c, a, b, d))\nfmt.Println(max(b, d, a, c))\nfmt.Println(max(b, c, d, a))\nfmt.Println(min(a, b, c, d))\nfmt.Println(min(a, b, d, c))\nfmt.Println(min(a, c, d, b))\nfmt.Println(min(d, c, b, a))\nfmt.Println(min(d, c, a, b))\nfmt.Println(min(c, d, b, a))\nfmt.Println(min(c, a, b, d))\nfmt.Println(min(b, d, a, c))\nfmt.Println(min(b, c"}
{"tgt": "r, err := http.Get(os.Args[1])\nif err != nil {\n\tfmt.Println(err)\n\treturn\n}\nio.Copy(os.Stdout, r.Body)\nif err := r.Body.Close(); err != nil {\n\tfmt.Println(err)\n}", "gen": "if len(os.Args) < 2 {\n\tpanic(\"usage: go run main.go <url>\")\n}\nresp, err := http.Get(os.Args[1])\nif err != nil {\n\tpanic(err)\n}\ndefer resp.Body.Close()\nbody, err := ioutil.ReadAll(resp.Body)\nif err != nil {\n\tpanic(err)\n}\nfmt.Println(string(body))\nfmt.Println(resp.StatusCode)\n}\n"}
{"tgt": "qs := []question1304{\n\t{\n\t\tpara1304{5},\n\t\tans1304{[]int{-7, -1, 1, 3, 4}},\n\t},\n\t{\n\t\tpara1304{0},\n\t\tans1304{[]int{}},\n\t},\n\t{\n\t\tpara1304{3},\n\t\tans1304{[]int{-1, 0, 1}},\n\t},\n\t{\n\t\tpara1304{1},\n\t\tans1304{[]int{0}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1304, q.para1304\n\tfmt.Printf(\"STR\", p, sumZero(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%d %d %d\\n\", 1, 3, 4)\na := []int{0, 1, 0, 5, 1, 0, 3, 3, 4}\nb := []int{0, 1, 1, 2, 1, 0, 4, 4, 0}\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 3, 3, 1)\nfmt.Printf(\"%d %d %d\\n\", 1, 0, 5)\nfmt.Printf(\"%d %d %d\\n\", 0, 0, 3)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 0)\nfmt.Printf(\"%d %d %d\\n\", 3, 3, 1)\nfmt.Printf(\"%d %d %d\\n\", 1, 0, 5)\nfmt.Printf(\"%d %d %d\\n\", 0, 0, 3)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 0)\nfmt.Printf(\"%d %d %d\\n\", 3, 3, 1)\nfmt.Printf(\"%d %d %d\\n\", 1, 0, 5)\nfmt.Printf(\"%d %d %d\\n\", 0, 0, 3)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 0)\nfmt.Printf(\"%d %d %d\\n\", 3, 3, 1)\nfmt.Printf(\"%d %d %d\\n\", 1, 0, 5)\nfmt.Printf(\"%d %d %d\\n\", 0, 0, 3)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 0)\nfmt"}
{"tgt": "cases := []struct {\n\tname   string\n\tnums   []int\n\tindex  []int\n\texpect []int\n}{\n\t{\"STR\", []int{0, 1, 2, 3, 4}, []int{0, 1, 2, 2, 1}, []int{0, 4, 1, 3, 2}},\n\t{\"STR\", []int{1, 2, 3, 4, 0}, []int{0, 1, 2, 3, 0}, []int{0, 1, 2, 3, 4}},\n\t{\"STR\", []int{1}, []int{0}, []int{1}},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.nums, c.index)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.nums, c.index)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.nums = []int{1, 2, 3, 4}\nsolution.index = 0\nsolution.expect = 5\nsolution.name = \"TestSolution\"\ntesting.RunTests(&solution)\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: true,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := isRobotBounded(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "fmt.Println(isRobotBounded(\"GGLLGG\"))\nfmt.Println(isRobotBounded(\"GG\"))\nfmt.Println(isRobotBounded(\"GL\"))\nfmt.Println(isRobotBounded(\"GLG\"))\nfmt.Println(isRobotBounded(\"GLGGLG\"))\nfmt.Println(isRobotBounded(\"GLGGLGGLG\"))\nfmt.Println(isRobotBounded(\"GLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGLGGL"}
{"tgt": "seen := make(map[string]struct{})\nfor _, tier := range al {\n\tfor _, v := range tier {\n\t\tif _, ok := seen[v]; !ok {\n\t\t\tseen[v] = struct{}{}\n\t\t\tret = append(ret, v)\n\t\t}\n\t}\n}\nreturn", "gen": "m := make(map[string]struct{})\nfor _, v := range []int{1, 2, 3} {\n\tm[strconv.Itoa(v)] = struct{}{}\n}\nfmt.Println(m)\n}\n"}
{"tgt": "return h.tasks[i].r < h.tasks[j].r", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d int\nvar e int\nvar f int\nvar g bool\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 1\nb[1] = 2\nb[2] = 3\nc[0] = 1\nc[1] = 2\nc[2] = 3\nd = 0\ne = 0\nf = 0\ng = a[d] == b[e] && c[f] == a[d]\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return xtime.Unix(int64(jt), 0)", "gen": "var t time.Time\nvar t2 time.Time\nvar t3 time.Time\nt = time.Now()\nt2 = time.Unix(t.Unix(), t.Nanosecond())\nt3 = time.Unix(t.Unix(), t.Nanosecond())\nfmt.Println(t2, t3)\n}\n\n// 1. \u6808\u5e27\u7684\u5927\u5c0f\n// 2. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 3. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 4. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 5. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 6. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 7. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 8. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 9. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 10. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 11. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 12. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 13. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 14. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 15. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 16. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 17. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 18. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 19. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 20. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 21. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 22. \u6808\u5e27\u7684\u4fdd\u5b58\u4f4d\u7f6e\n// 23. \u6808\u5e27\u7684\u4fdd\u5b58\u65b9\u5f0f\n// 24. "}
{"tgt": "return RandomizedSet{\n\tl: []int{},\n\tm: make(map[int]int),\n}", "gen": "m := make(map[string]int)\nm[\"hello\"] = 100\n}\n\n<ASM>\n.LFB1:\ncmpq %fs:112,%rsp\njnb .L2\nmovl $120,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL1:\nret\n.L2:\npushq %rbp\nmovq %rsp,%rbp\npushq %rbx\nsubq $104,%rsp\nmovq %rdi,-104(%rbp)\nmovq $0,-96(%rbp)\nmovq $0,-88(%rbp)\nmovq $0,-80(%rbp)\nmovq $0,-72(%rbp)\n.LBB4:\n.LBB5:\ncall <runtime.makemap_small@PLT>\nmovq %rax,%rbx\nleaq <type...60x.7int>(%rip),%rdi\ncall <runtime.newobject@PLT>\nmovq %rax,-56(%rbp)\nmovq -56(%rbp),%rax\nmovq %rax,-48(%rbp)\nmovq $0,-40(%rbp)\nmovq $0,-32(%rbp)\nmovq -48(%rbp),%rax\nmovq -40(%rbp),%rdx\nmovq %rax,-96(%rbp)\nmovq %rdx,-88(%rbp)\nmovq -32(%rbp),%rax\nmovq %rax,-80(%rbp)\nmovq %rbx,-72(%rbp)\nmovq -104(%rbp),%rcx\nmovq -96(%rbp),%rax\nmovq -88(%rbp),%rdx\nmovq %rax,(%rcx)\nmovq %rdx,<8>(%rcx)\nmovq -80(%rbp),%rax\nmovq -72(%rbp),%"}
{"tgt": "return TypeInt, nil", "gen": "var a [3]int\na[0] = 16\na[1] = 0\na[2] = 0\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "return createSkyline(buildings, 0, len(buildings)-1)", "gen": "var buildings [][]int\nbuildings = append(buildings, []int{2, 9, 10})\nbuildings = append(buildings, []int{3, 7, 15})\nbuildings = append(buildings, []int{5, 12, 12})\nbuildings = append(buildings, []int{15, 20, 10})\nbuildings = append(buildings, []int{19, 24, 8})\nbuildings = append(buildings, []int{23, 25, 5})\nbuildings = append(buildings, []int{28, 29, 7})\nbuildings = append(buildings, []int{32, 35, 12})\nbuildings = append(buildings, []int{37, 40, 18})\nbuildings = append(buildings, []int{42, 44, 20})\nbuildings = append(buildings, []int{46, 49, 21})\nbuildings = append(buildings, []int{52, 53, 22})\nbuildings = append(buildings, []int{56, 58, 23})\nbuildings = append(buildings, []int{62, 64, 24})\nbuildings = append(buildings, []int{68, 70, 25})\nbuildings = append(buildings, []int{74, 78, 26})\nbuildings = append(buildings, []int{82, 85, 27})\nbuildings = append(buildings, []int{89, 92, 28})\nbuildings = append(buildings, []int{96, 99, 29})\nbuildings = append(buildings, []int{102, 104, 30})\nbuildings = append(buildings, []int{108, 11"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil && max.Right != root {\n\t\t\tmax = max.Right\n\t\t}\n\t\tif max.Right == nil {\n\t\t\tmax.Right = root\n\t\t\troot = root.Left\n\t\t} else {\n\t\t\tres = append(res, root.Val)\n\t\t\troot = root.Right\n\t\t\tmax.Right = nil\n\t\t}\n\t}\n}\nreturn res", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\ta = append(a, i)\n}\nprintln(a[0])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "_, err := os.Open(\"STR\")\nif !os.IsNotExist(err) {\n\tpanic(\"STR\")\n}\nf, err := os.Open(\"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer func() {\n\tif err := f.Close(); err != nil {\n\t\tpanic(err)\n\t}\n\t_, err := f.Read(make([]byte, 10))\n\tif err == nil {\n\t\tpanic(\"STR\")\n\t}\n}()\ndata, err := ioutil.ReadAll(f)\nif err != nil {\n\tpanic(err)\n}\nprint(string(data))", "gen": "f, err := os.Open(\"./test.txt\")\nif err != nil {\n\tpanic(err)\n}\ndefer f.Close()\nb, err := ioutil.ReadAll(f)\nif err != nil {\n\tpanic(err)\n}\nfmt.Println(string(b))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "start, total, tank := 0, 0, 0\nfor i, g := range gas {\n\ttank += g - cost[i]\n\tif tank < 0 {\n\t\tstart = i + 1\n\t\ttotal += tank\n\t\ttank = 0\n\t}\n}\nif total+tank < 0 {\n\treturn -1\n}\nreturn start", "gen": "var a [3]int\nvar b [4]int\nvar c int\nvar d int\nfor i := 0; i < len(a); i++ {\n\tif i < len(a) {\n\t\tif i < len(a) {\n\t\t\tif i < len(a) {\n\t\t\t\tif i < len(a) {\n\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"}
{"tgt": "fmt.Println(btree.Data)", "gen": "fmt.Println(1, 1, 1)\n}\n\n// 1. \u6808\u5e27\n// 2. \u51fd\u6570\u8c03\u7528\n// 3. \u51fd\u6570\u8fd4\u56de\n// 4. \u51fd\u6570\u53c2\u6570\n// 5. \u51fd\u6570\u8c03\u7528\u6808\n// 6. \u51fd\u6570\u8fd4\u56de\u6808\n// 7. \u51fd\u6570\u8c03\u7528\u6808\u9876\n// 8. \u51fd\u6570\u8fd4\u56de\u6808\u9876\n// 9. \u51fd\u6570\u8c03\u7528\u6808\u9876\u6307\u9488\n// 10. \u51fd\u6570\u8fd4\u56de\u6808\u9876\u6307\u9488\n// 11. \u51fd\u6570\u8c03\u7528\u6808\u9876\u6307\u9488\u5bc4\u5b58\u5668\n// 12. \u51fd\u6570\u8fd4\u56de\u6808\u9876\u6307\u9488\u5bc4\u5b58\u5668\n// 13. \u51fd\u6570\u8c03\u7528\u6808\u9876\u6307\u9488\u5bc4\u5b58\u5668\n// 14. \u51fd\u6570\u8fd4\u56de\u6808\u9876\u6307\u9488\u5bc4\u5b58\u5668\n// 15. \u51fd\u6570\u8c03\u7528\u6808\u9876\u6307\u9488\u5bc4\u5b58\u5668\n// 16. \u51fd\u6570\u8fd4\u56de\u6808\u9876\u6307\u9488\u5bc4\u5b58\u5668\n// 17. \u51fd\u6570\u8c03\u7528\u6808\u9876\u6307\u9488\u5bc4\u5b58\u5668\n// 18. \u51fd\u6570\u8fd4\u56de\u6808\u9876\u6307\u9488\u5bc4\u5b58\u5668\n// 19. \u51fd\u6570\u8c03\u7528\u6808\u9876\u6307\u9488\u5bc4\u5b58\u5668\n// 20. \u51fd\u6570\u8fd4\u56de\u6808\u9876\u6307\u9488\u5bc4\u5b58\u5668\n// 21. \u51fd\u6570\u8c03\u7528\u6808\u9876\u6307\u9488\u5bc4\u5b58\u5668\n// 22. \u51fd\u6570\u8fd4\u56de\u6808\u9876\u6307\u9488\u5bc4\u5b58\u5668\n// 23. \u51fd\u6570\u8c03\u7528\u6808\u9876\u6307\u9488\u5bc4\u5b58\u5668\n// 2"}
{"tgt": "n := len(num)\nres := []string{}\nvar dfs func(string, int, int, int)\ndfs = func(path string, index, result, pre int) {\n\tif index == n && result == target {\n\t\tres = append(res, path)\n\t\treturn\n\t}\n\tfor i := index; i < n; i++ {\n\t\tif num[index] == '0' && i != index {\n\t\t\treturn\n\t\t}\n\t\tcurrStr := num[index : i+1]\n\t\tcurr, _ := strconv.Atoi(currStr)\n\t\tif index == 0 {\n\t\t\tdfs(currStr, i+1, curr, curr)\n\t\t} else {\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result+curr, curr)\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result-curr, -curr)\n\t\t\tdfs(path+\"STR\"+currStr, i+1, result-pre+pre*curr, pre*curr)\n\t\t}\n\t}\n}\ndfs(\"STR\", 0, 0, 0)\nreturn res", "gen": "fmt.Println(addOperators(\"123+5\", 9))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: \"STR\",\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: \"STR\",\n\t},\n}\nfor _, tt := range tests {\n\tgot := defangIPaddr(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var t testing.T\nvar ip string\nvar defangedIP string\nvar i int\nfor i = 0; i < 2; i++ {\n\tip = \"1.1.1.1\"\n\tdefangedIP = defangIPaddr(ip)\n\tif defangedIP != \"1[.]1[.]1[.]1\" {\n\t\tt.Fatalf(\"defangIPaddr(%q) = %q, want %q\", ip, defangedIP, \"1[.]1[.]1[.]1\")\n\t}\n}\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif res := Base64DecodeDelegate(tc.base64); res != tc.decoded {\n\t\tt.Errorf(\"STR\", tc.decoded, res)\n\t}\n}", "gen": "t := testing.T{}\nt.Parallel()\nfor i, tc := range testcases {\n\tif i == 0 {\n\t\tcontinue\n\t}\n\tdecoded, err := Base64DecodeDelegate(tc.input)\n\tif err != nil {\n\t\tt.Errorf(\"Error decoding %s: %s\", tc.input, err)\n\t\tcontinue\n\t}\n\tif !bytes.Equal(decoded, tc.expected) {\n\t\tt.Errorf(\"Expected %s to decode to %s, got %s\", tc.input, tc.expected, decoded)\n\t}\n}\n}\n"}
{"tgt": "qs := []question1207{\n\t{\n\t\tpara1207{[]int{1, 2, 2, 1, 1, 3}},\n\t\tans1207{true},\n\t},\n\t{\n\t\tpara1207{[]int{1, 2}},\n\t\tans1207{false},\n\t},\n\t{\n\t\tpara1207{[]int{-3, 0, 1, -3, 1, 1, 1, -3, 10, 0}},\n\t\tans1207{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1207, q.para1207\n\tfmt.Printf(\"STR\", p, uniqueOccurrences(p.arr))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2, 2)\nfmt.Printf(\"%d %d %d\\n\", 1, 2,"}
{"tgt": "max := -1001\nmax1 := -1001\nmax2 := -1001\nmin1 := 1001\nmin2 := 1001\nfor _, n := range nums {\n\tswitch {\n\tcase n > max:\n\t\tmax2, max1, max = max1, max, n\n\tcase n > max1:\n\t\tmax2, max1 = max1, n\n\tcase n > max2:\n\t\tmax2 = n\n\t}\n\tswitch {\n\tcase n < min1:\n\t\tmin2, min1 = min1, n\n\tcase n < min2:\n\t\tmin2 = n\n\t}\n}\nreturn bigger(max1*max2, min1*min2) * max", "gen": "var a, b, c int\nfor i := 0; i < len(a); i++ {\n\tif i < len(b) {\n\t\tif i < len(c) {\n\t\t\tif i < len(a) {\n\t\t\t\tif i < len(b) {\n\t\t\t\t\tif i < len(c) {\n\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\tif i < len(b) {\n\t\t\t\t\t\t\t\tif i < len(c) {\n\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\tif i < len(b) {\n\t\t\t\t\t\t\t\t\t\t\tif i < len(c) {\n\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(b) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(c) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(b) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(c) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(b) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(c) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(a) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif i < len(b) {\n"}
{"tgt": "var ret float64\nvar x float64\nvar n int\nret = 0\nx = 0.00001\nn = 2147483647\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 1.0000\nx = 2\nn = 0\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 10.0000\nx = 10.0000\nn = 1\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}\nret = 0.25000\nx = 2.0000\nn = -2\nif ret != myPow(x, n) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "testPow()\n}\n"}
{"tgt": "for len(w.data) > 0 && w.data[len(w.data)-1] < n {\n\tw.data = w.data[0 : len(w.data)-1]\n}\nw.data = append(w.data, n)", "gen": "var a [3]int\nvar b [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb[0] = 1\nb[1] = 2\nb[2] = 3\nif len(a) != len(b) {\n\tpanic(\"slice length mismatch\")\n}\nif cap(a) != cap(b) {\n\tpanic(\"slice capacity mismatch\")\n}\nif a[0] != b[0] {\n\tpanic(\"slice element mismatch\")\n}\nif a[1] != b[1] {\n\tpanic(\"slice element mismatch\")\n}\nif a[2] != b[2] {\n\tpanic(\"slice element mismatch\")\n}\nif a[0] != 1 {\n\tpanic(\"slice element mismatch\")\n}\nif a[1] != 2 {\n\tpanic(\"slice element mismatch\")\n}\nif a[2] != 3 {\n\tpanic(\"slice element mismatch\")\n}\nif a[0] != 1 {\n\tpanic(\"slice element mismatch\")\n}\nif a[1] != 2 {\n\tpanic(\"slice element mismatch\")\n}\nif a[2] != 3 {\n\tpanic(\"slice element mismatch\")\n}\nif a[0] != 1 {\n\tpanic(\"slice element mismatch\")\n}\nif a[1] != 2 {\n\tpanic(\"slice element mismatch\")\n}\nif a[2] != 3 {\n\tpanic(\"slice element mismatch\")\n}\nif a[0] != 1 {\n\tpanic(\"slice element mismatch\")\n}\nif a[1] != 2 {\n\tpanic(\"slice element mismatch\")\n}\nif a[2] != 3 {\n\tpanic(\"slice element mismatch\")\n}\nif a[0] != 1 {\n"}
{"tgt": "n := 0\ntmp := head\nfor tmp != nil {\n\tn++\n\ttmp = tmp.Next\n}\nreturn helper(&head, 0, n-1)", "gen": "root := &TreeNode{Val: 1}\nroot.Left = &TreeNode{Val: 2}\nroot.Right = &TreeNode{Val: 3}\nroot.Left.Left = &TreeNode{Val: 4}\nroot.Left.Right = &TreeNode{Val: 5}\nroot.Right.Left = &TreeNode{Val: 6}\nroot.Right.Right = &TreeNode{Val: 7}\nroot.Right.Right.Left = &TreeNode{Val: 8}\nroot.Right.Right.Right = &TreeNode{Val: 9}\nroot.Right.Right.Right.Left = &TreeNode{Val: 10}\nroot.Right.Right.Right.Right = &TreeNode{Val: 11}\nroot.Right.Right.Right.Right.Left = &TreeNode{Val: 12}\nroot.Right.Right.Right.Right.Right = &TreeNode{Val: 13}\nroot.Right.Right.Right.Right.Right.Left = &TreeNode{Val: 14}\nroot.Right.Right.Right.Right.Right.Right = &TreeNode{Val: 15}\nroot.Right.Right.Right.Right.Right.Right.Left = &TreeNode{Val: 16}\nroot.Right.Right.Right.Right.Right.Right.Right = &TreeNode{Val: 17}\nroot.Right.Right.Right.Right.Right.Right.Right.Left = &TreeNode{Val: 18}\nroot.Right.Right.Right.Right.Right.Right.Right.Right = &TreeNode{Val: 19}\nroot.Right.Right.Right.Right.Right.Right.Right.Right.Left = &TreeNode{Val: 20}\nroot.Right.Right.Right.Right.Right.Right.Right.Right.Right = &TreeNode{Val: 21}\nroot.Right.Right.Right.Right.Right.Right.Right.Right.Right.Left = &TreeNode{"}
{"tgt": "const templ = `<p>A:{{.A}}</p><p>B:{{.B}}</p>`\nt := template.Must(template.New(\"STR\").Parse(templ))\nvar data struct {\n\tA string\n\tBtemplate.HTML\n}\ndata.A = \"STR\"\ndata.B = \"STR\"\nif err := t.Execute(os.Stdout, data); err != nil {\n\tlog.Fatal(err)\n}", "gen": "t := template.New(\"\")\nt, _ = t.Parse(\"<html><body>{{.}}</body></html>\")\nt.Execute(os.Stdout, \"hello, world\")\n}\n"}
{"tgt": "if len(A) == len(A[0]) {\n\tfor i := 0; i < len(A); i++ {\n\t\tfor j := 0; j < len(A); j++ {\n\t\t\tif i == j {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]\n\t\t}\n\t}\n\treturn A\n}\nres := make([][]int, len(A[0]))\nfor i := 0; i < len(res); i++ {\n\tres[i] = make([]int, len(A))\n\tfor j := 0; j < len(A); j++ {\n\t\tres[i][j] = A[j][i]\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b [3]int\nvar c [3]int\nvar d [3]int\nvar e [3]int\nvar f [3]int\nvar g [3]int\nvar h [3]int\nvar i [3]int\nvar j [3]int\nvar k [3]int\nvar l [3]int\nvar m [3]int\nvar n [3]int\nvar o [3]int\nvar p [3]int\nvar q [3]int\nvar r [3]int\nvar s [3]int\nvar t [3]int\nvar u [3]int\nvar v [3]int\nvar w [3]int\nvar x [3]int\nvar y [3]int\nvar z [3]int\nvar aa [3]int\nvar ab [3]int\nvar ac [3]int\nvar ad [3]int\nvar ae [3]int\nvar af [3]int\nvar ag [3]int\nvar ah [3]int\nvar ai [3]int\nvar aj [3]int\nvar ak [3]int\nvar al [3]int\nvar am [3]int\nvar an [3]int\nvar ao [3]int\nvar ap [3]int\nvar aq [3]int\nvar ar [3]int\nvar as [3]int\nvar at [3]int\nvar au [3]int\nvar av [3]int\nvar aw [3]int\nvar ax [3]int\nvar ay [3]int\nvar az [3]int\nvar ba [3]int\nvar bb [3]int\nvar bc [3]int\nvar bd [3]int\nvar be [3]int\nvar bf [3]int\nvar bg [3]int\nvar bh [3]int\nvar bi [3]int\nvar bj ["}
{"tgt": "out := make(map[string]string)\nmain_pieces := strings.Split(s, sep1)\nfor _, piece := range main_pieces {\n\tminor_pieces := strings.Split(piece, sep2)\n\tout[minor_pieces[0]] = minor_pieces[1]\n}\nreturn out", "gen": "var m map[string]string\nvar s string\nvar sep string\nvar n int\nvar v []string\nvar i int\nvar k string\nvar vv string\nm = make(map[string]string)\nv = strings.Split(s, sep)\nfor i = 0; i < len(v); i++ {\n\tk = v[i]\n\tvv = v[i+1]\n\tm[k] = vv\n}\nreturn m\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := CountLargerAndSmallerBrute(tc.mat, tc.i1, tc.j1, tc.i2, tc.j2); result != tc.count {\n\t\tt.Errorf(\"STR\", tc.count, result)\n\t}\n}", "gen": "testing.MainStart(test, nil, nil)\n}"}
{"tgt": "size := len(a)\nlo, hi := 0, size-1\nvar miD, miA int\nfor lo <= hi {\n\tmiD = (lo + hi) / 2\n\tmiA = size - miD - 1\n\tif a[miA] > miD {\n\t\tlo = miD + 1\n\t} else {\n\t\thi = miD - 1\n\t}\n}\nreturn lo", "gen": "var a [10]int\nvar i int\nvar j int\nj = 0\nfor i = 0; i < len(a)-1; i++ {\n\tif i > j {\n\t\tj = i\n\t}\n}\nfmt.Println(j)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "l1, l2 := []int{}, []int{}\ndfs(root1, &l1)\ndfs(root2, &l2)\nif len(l1) != len(l2) {\n\treturn false\n}\nfor i, _ := range l1 {\n\tif l1[i] != l2[i] {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a, b int\na = 0\nb = 0\nvar c int\nc = 0\nvar d int\nd = 0\nvar e int\ne = 0\nvar f int\nf = 0\nvar g int\ng = 0\nvar h int\nh = 0\nvar i int\ni = 0\nvar j int\nj = 0\nvar k int\nk = 0\nvar l int\nl = 0\nvar m int\nm = 0\nvar n int\nn = 0\nvar o int\no = 0\nvar p int\np = 0\nvar q int\nq = 0\nvar r int\nr = 0\nvar s int\ns = 0\nvar t int\nt = 0\nvar u int\nu = 0\nvar v int\nv = 0\nvar w int\nw = 0\nvar x int\nx = 0\nvar y int\ny = 0\nvar z int\nz = 0\nvar aa int\naa = 0\nvar ab int\nab = 0\nvar ac int\nac = 0\nvar ad int\nad = 0\nvar ae int\nae = 0\nvar af int\naf = 0\nvar ag int\nag = 0\nvar ah int\nah = 0\nvar ai int\nai = 0\nvar aj int\naj = 0\nvar ak int\nak = 0\nvar al int\nal = 0\nvar am int\nam = 0\nvar an int\nan = 0\nvar ao int\nao = 0\nvar ap int\nap = 0\nvar aq int\naq = 0\nvar ar int\nar = 0\nvar as int\nas = 0\nvar at int\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result, err := ShortestRunnerPath(tc.elevations, tc.paths); result != tc.shortestRoute || err != tc.err {\n\t\tt.Errorf(\"STR\", tc.shortestRoute, tc.err, result, err)\n\t}\n}", "gen": "t := testing.T{}\nt.Parallel()\nfor i := 0; i < len(testcases); i++ {\n\tif i == 0 {\n\t\tcontinue\n\t}\n\tif testcases[i].expected != ShortestRunnerPath(testcases[i].start, testcases[i].end) {\n\t\tt.Errorf(\"expected %v, got %v\", testcases[i].expected, ShortestRunnerPath(testcases[i].start, testcases[i].end))\n\t}\n}\n}\n"}
{"tgt": "sLen, pLen := len(s), len(p)\ndp := make([][]bool, sLen+1)\nfor i := range dp {\n\tdp[i] = make([]bool, pLen+1)\n}\ndp[sLen][pLen] = true\nfor i := sLen; i > -1; i-- {\n\tfor j := pLen - 1; j > -1; j-- {\n\t\tfirstMatch := i < sLen && (p[j] == s[i] || p[j] == '.')\n\t\tif j+1 < pLen && p[j+1] == '*' {\n\t\t\tdp[i][j] = dp[i][j+2] || firstMatch && dp[i+1][j]\n\t\t} else {\n\t\t\tdp[i][j] = firstMatch && dp[i+1][j+1]\n\t\t}\n\t}\n}\nreturn dp[0][0]", "gen": "var a []bool\nvar b []bool\nvar c []bool\nvar d bool\na = make([]bool, 1)\nb = make([]bool, 1)\nc = make([]bool, 1)\nd = false\nfor i := 0; i < len(b); i++ {\n\tif i < len(a) {\n\t\td = a[i]\n\t}\n\tif i < len(c) {\n\t\tb[i] = c[i]\n\t}\n\tif i < len(b) {\n\t\tb[i] = d\n\t}\n}\nif len(a) > 0 {\n\tif len(b) > 0 {\n\t\tif len(c) > 0 {\n\t\t\tif len(a) > 0 {\n\t\t\t\tif len(b) > 0 {\n\t\t\t\t\tif len(c) > 0 {\n\t\t\t\t\t\tif len(a) > 0 {\n\t\t\t\t\t\t\tif len(b) > 0 {\n\t\t\t\t\t\t\t\tif len(c) > 0 {\n\t\t\t\t\t\t\t\t\tif len(a) > 0 {\n\t\t\t\t\t\t\t\t\t\tif len(b) > 0 {\n\t\t\t\t\t\t\t\t\t\t\tif len(c) > 0 {\n\t\t\t\t\t\t\t\t\t\t\t\tif len(a) > 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif len(b) > 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif len(c) > 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif len(a) > 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif len(b) > 0 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t"}
{"tgt": "sort.Slice(intervals, func(i, j int) bool {\n\treturn intervals[i].End < intervals[j].End\n})\ncount := 0\ncurrent := -int(^uint(0)>>1) - 1\nfor _, interval := range intervals {\n\tif interval.Start >= current {\n\t\tcount++\n\t\tcurrent = interval.End\n\t}\n}\nreturn len(intervals) - count", "gen": "intervals := []Interval{{1, 2}, {2, 3}, {3, 4}, {1, 3}}\nresult := removeIntervals(intervals)\nfmt.Println(result)\n}\n"}
{"tgt": "i := len(nums) - 2\nfor i >= 0 && nums[i] >= nums[i+1] {\n\ti--\n}\nj, k := i+1, len(nums)-1\nfor j < k {\n\tnums[j], nums[k] = nums[k], nums[j]\n\tj, k = j+1, k-1\n}\nif i >= 0 {\n\tj = i + 1\n\tfor nums[j] <= nums[i] {\n\t\tj++\n\t}\n\tnums[i], nums[j] = nums[j], nums[i]\n}", "gen": "var a [10]int\nvar b [10]int\nvar c [10]int\nvar d [10]int\nvar e [10]int\nvar f [10]int\nvar g [10]int\nvar h [10]int\nvar i [10]int\nvar j [10]int\nvar k [10]int\nvar l [10]int\nvar m [10]int\nvar n [10]int\nvar o [10]int\nvar p [10]int\nvar q [10]int\nvar r [10]int\nvar s [10]int\nvar t [10]int\nvar u [10]int\nvar v [10]int\nvar w [10]int\nvar x [10]int\nvar y [10]int\nvar z [10]int\nvar aa [10]int\nvar bb [10]int\nvar cc [10]int\nvar dd [10]int\nvar ee [10]int\nvar ff [10]int\nvar gg [10]int\nvar hh [10]int\nvar ii [10]int\nvar jj [10]int\nvar kk [10]int\nvar ll [10]int\nvar mm [10]int\nvar nn [10]int\nvar oo [10]int\nvar pp [10]int\nvar qq [10]int\nvar rr [10]int\nvar ss [10]int\nvar tt [10]int\nvar uu [10]int\nvar vv [10]int\nvar ww [10]int\nvar xx [10]int\nvar yy [10]int\nvar zz [10]int\nvar aaa [10]int\nvar bbb [10]"}
{"tgt": "denoms := make(map[int]struct{})\nfor d, way := range ways {\n\tif others := waysToProduce(d, denoms); (way == 1 && d > 0) || others == way-1 {\n\t\tdenoms[d] = struct{}{}\n\t}\n}\nres := make([]int, 0, len(denoms))\nfor k := range denoms {\n\tres = append(res, k)\n}\nsort.Ints(res)\nreturn res", "gen": "var waysToProduce = make(map[int]struct{\n\tA int\n\tB int\n})\nvar ways []int\nfor _, v := range []struct{\n\tA int\n\tB int\n}{\n\t{A: 1, B: 2},\n\t{A: 2, B: 4},\n\t{A: 3, B: 6},\n} {\n\tif _, ok := waysToProduce[v.B]; !ok {\n\t\twaysToProduce[v.B] = struct{\n\t\t\tA int\n\t\t\tB int\n\t\t}{\n\t\t\tA: v.A,\n\t\t\tB: v.B,\n\t\t}\n\t}\n}\nfor i := 0; i < len(waysToProduce); i++ {\n\tif i == 0 {\n\t\tways = append(ways, waysToProduce[i].A)\n\t\tways = append(ways, waysToProduce[i].B)\n\t} else {\n\t\tif waysToProduce[i].A != ways[len(ways)-1] {\n\t\t\tways = append(ways, waysToProduce[i].A)\n\t\t}\n\t\tif waysToProduce[i].B != ways[len(ways)-1] {\n\t\t\tways = append(ways, waysToProduce[i].B)\n\t\t}\n\t}\n}\nsort.Ints(ways)\nreturn ways\n}\n"}
{"tgt": "return len(self.data)", "gen": "var x int\nx = 0\nreturn\n}\n\n// func main() {\n// \tvar x int\n// \tx = 0\n// \treturn\n// }\n\n<ASM>\ncmpq %fs:112,%rsp\njnb .L50\nmovl $8,%r10d\nmovl $0,%r11d\ncall <__morestack>\n.LVL7:\nret\n.L50:\npushq %rbp\nmovq %rsp,%rbp\nmovq %rdi,-24(%rbp)\nmovq $0,-8(%rbp)\n.LBB28:\n.LBB29:\nmovq -24(%rbp),%rax\nmovq <8>(%rax),%rax\nmovq %rax,-8(%rbp)\nmovq -8(%rbp),%rax\n.LBE29:\n.LBE28:\npopq %rbp\nret</ASM>"}
{"tgt": "var ri, gi int\nfor i, r := range letters {\n\tif r == 'R' {\n\t\tletters[i] = letters[gi]\n\t\tletters[gi] = letters[ri]\n\t\tletters[ri] = r\n\t\tgi++\n\t\tri++\n\t} else if r == 'G' {\n\t\tletters[i] = letters[gi]\n\t\tletters[gi] = r\n\t\tgi++\n\t}\n}", "gen": "var a [3][3]int\nvar i int\nvar j int\nvar tmp int\nfor i = 0; i < 3; i++ {\n\tfor j = 0; j < 3; j++ {\n\t\tif i == 0 && j == 0 {\n\t\t\ta[i][j] = 1\n\t\t} else if i == 0 && j == 1 {\n\t\t\ta[i][j] = 2\n\t\t} else if i == 0 && j == 2 {\n\t\t\ta[i][j] = 3\n\t\t} else if i == 1 && j == 0 {\n\t\t\ta[i][j] = 4\n\t\t} else if i == 1 && j == 1 {\n\t\t\ta[i][j] = 5\n\t\t} else if i == 1 && j == 2 {\n\t\t\ta[i][j] = 6\n\t\t} else if i == 2 && j == 0 {\n\t\t\ta[i][j] = 7\n\t\t} else if i == 2 && j == 1 {\n\t\t\ta[i][j] = 8\n\t\t} else if i == 2 && j == 2 {\n\t\t\ta[i][j] = 9\n\t\t}\n\t\ttmp = a[i][j]\n\t\tif i == 0 && j == 0 {\n\t\t\ta[i][j] = a[1][2]\n\t\t} else if i == 0 && j == 1 {\n\t\t\ta[i][j] = a[1][1]\n\t\t} else if i == 0 && j == 2 {\n\t\t\ta[i][j] = a[1][0]\n\t\t} else if i == 1 && j == 0 {\n\t\t\ta[i][j] = a[2][2]\n\t\t} else if i == 1"}
{"tgt": "switch rand.Intn(10) {\ncase 1, 9:\n\treturn io.EOF\ncase 5:\n\treturn errors.New(\"STR\")\ndefault:\n\td.Line = \"STR\"\n\tfmt.Println(\"STR\", d.Line)\n\treturn nil\n}", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\n"}
{"tgt": "return helper(root, p, q)", "gen": "var a, b, c int\na = 1\nb = 2\nc = helper(a, b)\nreturn\n}"}
{"tgt": "benchmark(bb, 16384, 0.1)", "gen": "benchmark()\n}\n"}
{"tgt": "this.mutex.Lock()\ndefer this.mutex.Unlock()\nif priority < 0 || priority > this.max {\n\treturn nil\n}\nreturn this.queues[priority].Peek()", "gen": "var m sync.Mutex\nvar q Queue\nvar v int\nm.Lock()\ndefer m.Unlock()\nif q.Len() == 0 {\n\tv = 0\n} else {\n\tif q.Len() > 0 {\n\t\tif q.Len() > 0 {\n\t\t\tv = q.Peek()\n\t\t} else {\n\t\t\tpanic(runtime.GoPanicIndex(q.Len(), 0))\n\t\t}\n\t} else {\n\t\tv = 0\n\t}\n}\nreturn v\n}\n"}
{"tgt": "if i < 0 || i >= itemKind(len(_itemKind_index)-1) {\n\treturn fmt.Sprintf(\"STR\", i)\n}\nreturn _itemKind_name[_itemKind_index[i]:_itemKind_index[i+1]]", "gen": "var r *httprange.Range\nif r == nil {\n\tpanic(\"nil pointer dereference\")\n}\nif r.Len() == 0 {\n\treturn\n}\nif r.Len() > 5 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\nif r.Len() > 6 {\n\tpanic(\"index out of range\")\n}\n"}
{"tgt": "arr := randomSlice(0, 20, 10)\nnodeCnt := 0\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\nrotateNodes := make([]*gbtElement, 0, 0)\ngbt.InOrderWalk(gbt.Root(), func(GBTbinaryTreeIf, node interface{}) bool {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\trotateNodes = append(rotateNodes, node.(*gbtElement))\n\t}\n\treturn false\n})\nfor _, v := range rotateNodes {\n\trotate := getRand().Intn(2)\n\tif rotate == 1 {\n\t\tgbt.LeftRotate(v)\n\t} else {\n\t\tgbt.RightRotate(v)\n\t}\n}\ngbt.InOrderWalk(gbt.Root(), checkGBT(t, &nodeCnt, *debug))\nif nodeCnt != len(arr) {\n\tt.Log(fmt.Sprintf(\"STR\", len(arr), nodeCnt))\n\tt.Fail()\n}", "gen": "gbt := NewGBT()\ngbt.Insert(10)\ngbt.Insert(20)\ngbt.Insert(30)\ngbt.Insert(40)\ngbt.Insert(50)\ngbt.Insert(60)\ngbt.Insert(70)\ngbt.Insert(80)\ngbt.Insert(90)\ngbt.Insert(100)\ngbt.Insert(110)\ngbt.Insert(120)\ngbt.Insert(130)\ngbt.Insert(140)\ngbt.Insert(150)\ngbt.Insert(160)\ngbt.Insert(170)\ngbt.Insert(180)\ngbt.Insert(190)\ngbt.Insert(200)\ngbt.Insert(210)\ngbt.Insert(220)\ngbt.Insert(230)\ngbt.Insert(240)\ngbt.Insert(250)\ngbt.Insert(260)\ngbt.Insert(270)\ngbt.Insert(280)\ngbt.Insert(290)\ngbt.Insert(300)\ngbt.Insert(310)\ngbt.Insert(320)\ngbt.Insert(330)\ngbt.Insert(340)\ngbt.Insert(350)\ngbt.Insert(360)\ngbt.Insert(370)\ngbt.Insert(380)\ngbt.Insert(390)\ngbt.Insert(400)\ngbt.Insert(410)\ngbt.Insert(420)\ngbt.Insert(430)\ngbt.Insert(440)\ngbt.Insert(450)\ngbt.Insert"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := InversionCountBrute(tc.input); result != tc.inversions {\n\t\tt.Errorf(\"STR\", tc.inversions, result)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "fmt.Println(subarrayBitwiseORs([]int{0}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 2}))\nfmt.Println(subarrayBitwiseORs([]int{1, 2, 4}))", "gen": "fmt.Println(subarrayBitwiseORs([]int{1, 1, 0}))\nfmt.Println(subarrayBitwiseORs([]int{0, 1}))\nfmt.Println(subarrayBitwiseORs([]int{1, 1, 1}))\n}\n"}
{"tgt": "if nil == root {\n\treturn []int{}\n}\nlargestVals := []int{}\nchildren := []*TreeNode{root}\nfor len(children) > 0 {\n\ttmp := children[:]\n\tchildren = []*TreeNode{}\n\tlargest := -(1 << 32)\n\tfor _, child := range tmp {\n\t\tif child.Val > largest {\n\t\t\tlargest = child.Val\n\t\t}\n\t\tif nil != child.Left {\n\t\t\tchildren = append(children, child.Left)\n\t\t}\n\t\tif nil != child.Right {\n\t\t\tchildren = append(children, child.Right)\n\t\t}\n\t}\n\tlargestVals = append(largestVals, largest)\n}\nreturn largestVals", "gen": "var root *TreeNode\nif len(nums) == 0 {\n\treturn root\n}\nroot = &TreeNode{Val: nums[0]}\nqueue := []*TreeNode{root}\nfor i := 1; i < len(nums); i++ {\n\tif len(queue) == 0 {\n\t\treturn root\n\t}\n\tnode := queue[0]\n\tqueue = queue[1:]\n\tif i < len(nums) && nums[i] != nil {\n\t\tnode.Left = &TreeNode{Val: nums[i]}\n\t\tqueue = append(queue, node.Left)\n\t}\n\tif i < len(nums) && nums[i] != nil {\n\t\tnode.Right = &TreeNode{Val: nums[i]}\n\t\tqueue = append(queue, node.Right)\n\t}\n}\nreturn root\n}\n"}
{"tgt": "{\n\tdata, err := json.Marshal(movies)\n\tif err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Printf(\"STR\", data)\n}\n{\n\tdata, err := json.MarshalIndent(movies, \"STR\")\n\tif err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Printf(\"STR\", data)\n\tvar titles []struct{ Title string }\n\tif err := json.Unmarshal(data, &titles); err != nil {\n\t\tlog.Fatalf(\"STR\", err)\n\t}\n\tfmt.Println(titles)\n}", "gen": "var movies = []Movie{\n\t{Title: \"Casablanca\", Year: 1942, Color: false},\n\t{Title: \"Cool Hand Luke\", Year: 1966, Color: true},\n\t{Title: \"Bullitt\", Year: 1968, Color: true},\n}\nvar jsonMovie = []byte(`[\n\t{\"Title\":\"Casablanca\",\"Year\":1942,\"Color\":false},\n\t{\"Title\":\"Cool Hand Luke\",\"Year\":1966,\"Color\":true},\n\t{\"Title\":\"Bullitt\",\"Year\":1968,\"Color\":true}\n]`)\nvar movie Movie\nerr := json.Unmarshal(jsonMovie, &movie)\nif err != nil {\n\tlog.Fatalf(\"Error: %v\", err)\n}\nfmt.Printf(\"%+v\\n\", movie)\nfmt.Printf(\"%T\\n\", movie)\nfmt.Println(string(jsonMovie))\nfmt.Println(string(json.Marshal(movies)))\nfmt.Println(string(json.MarshalIndent(movies, \"\", \"  \")))\nfmt.Println(string(json.Marshal(movie)))\nfmt.Println(string(json.MarshalIndent(movie, \"\", \"  \")))\nfmt.Println(string(json.Marshal([]byte(jsonMovie))))\nfmt.Println(string(json.MarshalIndent([]byte(jsonMovie), \"\", \"  \")))\nfmt.Println(string(json.Marshal([]Movie{movie})))\nfmt.Println(string(json.MarshalIndent([]Movie{movie}, \"\", \"  \")))\nfmt.Println(string(json.Marshal([]byte(json.Marshal(movie)))))\nfmt.Println(string(json.MarshalIndent([]byte(json.Marshal(movie)), \"\", \"  \")))\nfmt.Println(string(json.Marshal([]byte(json.MarshalInd"}
{"tgt": "if num <= 0 {\n\treturn false\n}\nif num&(num-1) != 0 {\n\treturn false\n}\nif num&0x55555555 == 0 {\n\treturn false\n}\nreturn true", "gen": "var n int\nif n > 0 {\n\tif n&1 == 0 {\n\t\treturn 0\n\t}\n} else {\n\tif n&15 == 0 {\n\t\treturn 0\n\t}\n}\nreturn 1\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "major := uint32((dev & 0x00000000000fff00) >> 8)\nmajor |= uint32((dev & 0xfffff00000000000) >> 32)\nreturn major", "gen": "var x int\nx = 0\nx = x & 1048320\nx = x >> 8\nx = x | -17592186044416\nx = x >> 32\nx = x | x\nreturn\n}\n"}
{"tgt": "t.Parallel()\nvar ba BitArray\nfor _, tc := range testcases {\n\tba.Init(tc.size)\n\tfor index, val := range tc.ones {\n\t\tif err := ba.Set(index, val); err != nil {\n\t\t\tt.Errorf(\"STR\")\n\t\t}\n\t}\n\tfor i := 0; i < tc.size; i++ {\n\t\tif val, err := ba.Get(i); err != nil {\n\t\t\tt.Errorf(\"STR\", err)\n\t\t} else if tc.ones[i] != val {\n\t\t\tt.Errorf(\"STR\", tc.ones[i], val, i)\n\t\t}\n\t}\n}", "gen": "testing.Init()\nos.Exit(maintest.RunTests())\n}\n"}
{"tgt": "if a == b {\n\treturn -1\n}\nif len(a) > len(b) {\n\treturn len(a)\n}\nreturn len(b)", "gen": "var a, b, c int\nif a == b && c == b {\n\treturn 1\n}\nif a < b && c < b {\n\treturn -1\n}\nreturn 0\n}\n"}
{"tgt": "var res []int\nvar max *TreeNode\nfor root != nil {\n\tif root.Left == nil {\n\t\tres = append(res, root.Val)\n\t\troot = root.Right\n\t} else {\n\t\tmax = root.Left\n\t\tfor max.Right != nil {\n\t\t\tmax = max.Right\n\t\t}\n\t\tmax.Right = root\n\t\troot, root.Left = root.Left, nil\n\t}\n}\nreturn res", "gen": "var a []int\nfor i := 0; i < 1000000; i++ {\n\ta = append(a, i)\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if a > b {\n\treturn b\n}\nreturn a", "gen": "if a < b {\n\treturn a\n}\nreturn b\n}\n"}
{"tgt": "var buf bytes.Buffer\nif err := encode(&buf, reflect.ValueOf(v)); err != nil {\n\treturn nil, err\n}\nreturn buf.Bytes(), nil", "gen": "var buf bytes.Buffer\nbuf.Write([]byte{1, 2, 3})\nvar v = reflect.ValueOf(buf.Bytes())\nvar s = go.sexpr.encode(v)\nfmt.Println(s)\n}\n"}
{"tgt": "m := map[byte]struct{}{}\nfor i := range J {\n\tm[J[i]] = struct{}{}\n}\nres := 0\nfor i := range S {\n\tif _, ok := m[S[i]]; ok {\n\t\tres++\n\t}\n}\nreturn res", "gen": "var m map[uint8]struct {\n\ta int\n\tb int\n}\nvar i uint8\nvar j int\nvar k int\nvar v struct {\n\ta int\n\tb int\n}\nfor i = 0; i < 2; i++ {\n\tj = 0\n\tfor j = 0; j < 2; j++ {\n\t\tk, _ = utf8.DecodeRuneInString(\"\")\n\t\tif k == 127 {\n\t\t\tcontinue\n\t\t}\n\t\tk, _ = utf8.DecodeRuneInString(\"\")\n\t\tif k == 127 {\n\t\t\tcontinue\n\t\t}\n\t\tm[k] = v\n\t}\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if numRows < 2 {\n\treturn s\n}\nmaxInterval := (numRows - 1) << 1\ninterval := maxInterval\nafter := \"STR\"\nfor i := 0; i < numRows; i++ {\n\tif numRows-1 == i {\n\t\tinterval = maxInterval\n\t}\n\tfor j, no := i, 0; j < len(s); no++ {\n\t\tafter += string(s[j])\n\t\tif i > 0 && i < numRows-1 && 1 == no&1 {\n\t\t\tj += maxInterval - interval\n\t\t\tcontinue\n\t\t}\n\t\tj += interval\n\t}\n\tinterval -= 2\n}\nreturn after", "gen": "var a, b int\nvar c string\na, b = 1, 2\nc = strconv.Itoa(a) + strconv.Itoa(b)\nfmt.Println(c)\n}\n"}
{"tgt": "var result []string\ndfs(s, []string{}, &result)\nreturn result", "gen": "var res []int\ndfs(0, 0, 0, &res)\nfmt.Println(res)\n}\n"}
{"tgt": "if n < 7 {\n\treturn int64(n + 1)\n}\nans := (1 + int64(n%7)) * row(n/7)\nreturn ans", "gen": "var n int\nfmt.Scan(&n)\nif n > 6 {\n\tn = row(n)\n}\nfmt.Println(n)\n}\n"}
{"tgt": "if len(mat) == 0 || len(mat[0]) == 0 {\n\treturn []int{}\n}\nm, n := len(mat), len(mat[0])\nisUpping := true\nnext := func(i, j int) (int, int) {\n\tif isUpping {\n\t\ti--\n\t\tj++\n\t\tif 0 <= i && j < n {\n\t\t\treturn i, j\n\t\t}\n\t\tisUpping = false\n\t\tif i < 0 && j < n {\n\t\t\treturn 0, j\n\t\t}\n\t\treturn i + 2, j - 1\n\t}\n\ti++\n\tj--\n\tif i < m && 0 <= j {\n\t\treturn i, j\n\t}\n\tisUpping = true\n\tif i < m && j < 0 {\n\t\treturn i, 0\n\t}\n\treturn i - 1, j + 2\n}\nmn := m * n\nres := make([]int, mn)\ni, j := 0, 0\nfor k := 0; k < mn; k++ {\n\tres[k] = mat[i][j]\n\ti, j = next(i, j)\n}\nreturn res", "gen": "var matrix [][]int\nvar result []int\nvar i int\nvar j int\nvar m int\nvar n int\nvar k int\nvar temp int\nvar temp2 int\nvar temp3 int\nvar temp4 int\nvar temp5 int\nvar temp6 int\nvar temp7 int\nvar temp8 int\nvar temp9 int\nvar temp10 int\nvar temp11 int\nvar temp12 int\nvar temp13 int\nvar temp14 int\nvar temp15 int\nvar temp16 int\nvar temp17 int\nvar temp18 int\nvar temp19 int\nvar temp20 int\nvar temp21 int\nvar temp22 int\nvar temp23 int\nvar temp24 int\nvar temp25 int\nvar temp26 int\nvar temp27 int\nvar temp28 int\nvar temp29 int\nvar temp30 int\nvar temp31 int\nvar temp32 int\nvar temp33 int\nvar temp34 int\nvar temp35 int\nvar temp36 int\nvar temp37 int\nvar temp38 int\nvar temp39 int\nvar temp40 int\nvar temp41 int\nvar temp42 int\nvar temp43 int\nvar temp44 int\nvar temp45 int\nvar temp46 int\nvar temp47 int\nvar temp48 int\nvar temp49 int\nvar temp50 int\nvar temp51 int\nvar temp52 int\nvar temp53 int\nvar temp54 int\nvar temp55 int\nvar temp56 int\nvar temp57 int\nvar temp58 int\nvar temp59 int\nvar temp60 int\nvar temp61 int\nvar temp62 int\nvar temp63 int\nvar temp64 int\nvar temp65 int\nvar temp66 int\nvar temp67 int\nvar temp"}
{"tgt": "n := len(quality)\nworkers := make([][2]float64, n)\nfor i := 0; i < n; i++ {\n\tw, q := float64(wage[i]), float64(quality[i])\n\tworkers[i][0], workers[i][1] = w/q, q\n}\nsort.Slice(workers, func(i, j int) bool {\n\treturn workers[i][0] < workers[j][0]\n})\nres := math.MaxFloat64\nsum := 0.\nh := floatHeap{}\nfor _, w := range workers {\n\tsum += w[1]\n\theap.Push(&h, w[1])\n\tif len(h) > K {\n\t\tsum -= heap.Pop(&h).(float64)\n\t}\n\tif len(h) == K {\n\t\tres = min(res, sum*w[0])\n\t}\n}\nreturn res", "gen": "fmt.Println(mincostToHireWorkers([]int{10, 20, 5}, []int{7, 15, 20}))\n}"}
{"tgt": "t.Parallel()\nlfu := NewLFUCache(3)\nlfu.Set(\"STR\", \"STR\")\nlfu.Set(1, 2)\nlfu.Set(\"STR\", \"STR\")\nlfu.Get(1)\nlfu.Get(\"STR\")\nlfu.Set(100, 1)\nif result := lfu.Get(\"STR\"); result != nil {\n\tt.Errorf(\"STR\", result)\n}\nif result := lfu.Get(1); result == nil {\n\tt.Errorf(\"STR\")\n}\nif result := lfu.Get(\"STR\"); result == nil {\n\tt.Errorf(\"STR\")\n}\nif result := lfu.Get(100); result == nil {\n\tt.Errorf(\"STR\")\n}\nlfu.Set(100, \"STR\")\nif result := lfu.Get(100); result.(string) != \"STR\" {\n\tt.Errorf(\"STR\")\n}", "gen": "testing.Init()\nos.Exit(maintest.RunTests())\n}\n"}
{"tgt": "m := len(pattern)\nnext := make([]int, m)\nfor index := range next {\n\tnext[index] = -1\n}\nfor i := 1; i < m-1; i++ {\n\tj := next[i-1]\n\tfor pattern[j+1] != pattern[i] && j >= 0 {\n\t\tj = next[j]\n\t}\n\tif pattern[j+1] == pattern[i] {\n\t\tj += 1\n\t}\n\tnext[i] = j\n}\nreturn next", "gen": "var a []int\nfor i := 0; i < len(a); i++ {\n\tif a[i] == a[i+1] {\n\t\ta[i] = 0\n\t}\n}\nreturn a\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := AllPossibleSubsequences(tc.input); !reflect.DeepEqual(result, tc.subseq) {\n\t\tt.Errorf(\"STR\", tc.subseq, result)\n\t}\n}", "gen": "t := testing.T{}\nt.Parallel()\nfor i, test := range testcases {\n\tif !reflect.DeepEqual(AllPossibleSubsequences(test.input), test.output) {\n\t\tt.Errorf(\"input: %v, want: %v, got: %v\", test.input, test.output, AllPossibleSubsequences(test.input))\n\t}\n}\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []int\n\texpect int\n}{\n\t{\"STR\", []int{1, 3, 4, 2, 2}, 2},\n\t{\"STR\", []int{3, 1, 3, 4, 2}, 3},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := findDuplicate(c.inputs)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.inputs)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.TestSolution()\n}\n"}
{"tgt": "cases := []struct {\n\tname    string\n\tinputs  []int\n\texpects bool\n}{\n\t{\"STR\", []int{1, 2, 3, 1}, true},\n\t{\"STR\", []int{1, 2, 3, 4}, false},\n\t{\"STR\", []int{1, 1, 1, 3, 3, 4, 3, 2, 4, 2}, true},\n}\nfor _, testcase := range cases {\n\tt.Run(testcase.name, func(t *testing.T) {\n\t\tresult := containsDuplicate(testcase.inputs)\n\t\tif !reflect.DeepEqual(result, testcase.expects) {\n\t\t\tt.Fatalf(\"STR\", testcase.expects, result, testcase.inputs)\n\t\t}\n\t})\n}", "gen": "sol := Solution{}\nsol.testcase1()\n}\n"}
{"tgt": "arr := randomSlice(0, 20, 10)\ngbt := newGBT()\nfor _, v := range arr {\n\tgbt.Insert(uint32(v))\n}\ncheckGBTPreOrder(t, gbt, arr)", "gen": "var t *binaryTree\nt = newGBT(randomSlice(10, 20, 0))\nvar i int\nfor i = 0; i < len(t.preOrder); i++ {\n\tif i == 0 {\n\t\tif t.preOrder[i] != 0 {\n\t\t\tpanic(i)\n\t\t}\n\t} else {\n\t\tif t.preOrder[i] <= t.preOrder[i-1] {\n\t\t\tpanic(i)\n\t\t}\n\t}\n}\nvar j int\nfor j = 0; j < len(t.inOrder); j++ {\n\tif j == 0 {\n\t\tif t.inOrder[j] != 0 {\n\t\t\tpanic(j)\n\t\t}\n\t} else {\n\t\tif t.inOrder[j] <= t.inOrder[j-1] {\n\t\t\tpanic(j)\n\t\t}\n\t}\n}\nvar k int\nfor k = 0; k < len(t.postOrder); k++ {\n\tif k == 0 {\n\t\tif t.postOrder[k] != 0 {\n\t\t\tpanic(k)\n\t\t}\n\t} else {\n\t\tif t.postOrder[k] <= t.postOrder[k-1] {\n\t\t\tpanic(k)\n\t\t}\n\t}\n}\nvar l int\nfor l = 0; l < len(t.preOrder); l++ {\n\tif l == 0 {\n\t\tif t.preOrder[l] != 0 {\n\t\t\tpanic(l)\n\t\t}\n\t} else {\n\t\tif t.preOrder[l] <= t.preOrder[l-1] {\n\t\t\tpanic(l)\n\t\t}\n\t}\n}\nvar m int\nfor"}
{"tgt": "fmt.Println(maxDistToClosest([]int{1, 0, 0, 0, 1, 0, 1}))\nfmt.Println(maxDistToClosest([]int{1, 0, 0, 0}))\nfmt.Println(maxDistToClosest([]int{0, 1}))\nfmt.Println(maxDistToClosest([]int{0, 1, 1, 1, 0, 0, 1, 0, 0}))\nfmt.Println(maxDistToClosest([]int{0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0}))", "gen": "fmt.Println(maxDistToClosest([]int{1, 2, 3, 4}))\nfmt.Println(maxDistToClosest([]int{1, 4, 2, 3}))\nfmt.Println(maxDistToClosest([]int{1, 1, 1, 1}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}))\nfmt.Println(maxDistToClosest([]int{1, 2, 3, 4, 5, "}
{"tgt": "iE := i.(*ltHeapElement)\njE := j.(*ltHeapElement)\nif iE == nil {\n\treturn jE\n}\nif jE == nil {\n\treturn iE\n}\nif h.Key(iE) < h.Key(jE) {\n\th.Swap(&iE, &jE)\n}\niE.right = h.merge(iE.right, jE).(*ltHeapElement)\nif iE.left == nil || iE.right.dist > iE.left.dist {\n\th.Swap(&iE.left, &iE.right)\n}\nif iE.right == nil {\n\tiE.dist = 0\n} else {\n\tiE.dist = iE.right.dist + 1\n}\nreturn iE", "gen": "var h ltHeapArray\nh.Init(10)\nh.Push(1)\nh.Push(2)\nh.Push(3)\nh.Push(4)\nh.Push(5)\nh.Push(6)\nh.Push(7)\nh.Push(8)\nh.Push(9)\nh.Push(10)\nh.Push(11)\nh.Push(12)\nh.Push(13)\nh.Push(14)\nh.Push(15)\nh.Push(16)\nh.Push(17)\nh.Push(18)\nh.Push(19)\nh.Push(20)\nh.Push(21)\nh.Push(22)\nh.Push(23)\nh.Push(24)\nh.Push(25)\nh.Push(26)\nh.Push(27)\nh.Push(28)\nh.Push(29)\nh.Push(30)\nh.Push(31)\nh.Push(32)\nh.Push(33)\nh.Push(34)\nh.Push(35)\nh.Push(36)\nh.Push(37)\nh.Push(38)\nh.Push(39)\nh.Push(40)\nh.Push(41)\nh.Push(42)\nh.Push(43)\nh.Push(44)\nh.Push(45)\nh.Push(46)\nh.Push(47)\nh.Push(48)\nh.Push(49)\nh.Push(50)\nh.Push(51)\nh.Push(52)\nh.Push(53)\nh.Push(54)\nh.Push("}
{"tgt": "result := MakeMatrix(make([]float64, A.cols*A.rows), A.cols, A.rows)\nfor i := 0; i < A.rows; i++ {\n\tfor j := 0; j < A.cols; j++ {\n\t\tsum := float64(0)\n\t\tfor k := 0; k < A.cols; k++ {\n\t\t\tsum += A.GetElm(i, k) * B.GetElm(k, j)\n\t\t}\n\t\tresult.SetElm(i, j, sum)\n\t}\n}\nreturn result", "gen": "var a Matrix\na.MakeMatrix(10, 10)\nfor i := 0; i < 10; i++ {\n\tfor j := 0; j < 10; j++ {\n\t\ta.SetElm(i, j, float64(i*j))\n\t}\n}\nvar b Matrix\nb.MakeMatrix(10, 10)\nfor i := 0; i < 10; i++ {\n\tfor j := 0; j < 10; j++ {\n\t\tb.SetElm(i, j, float64(i*j))\n\t}\n}\nvar c Matrix\nc.MakeMatrix(10, 10)\nfor i := 0; i < 10; i++ {\n\tfor j := 0; j < 10; j++ {\n\t\tc.SetElm(i, j, a.GetElm(i, j)*b.GetElm(i, j))\n\t}\n}\nreturn c\n}\n"}
{"tgt": "if head == nil {\n\treturn nil\n}\neven := head.Next\np, q := head, head.Next\nfor q != nil && q.Next != nil {\n\tp.Next = q.Next\n\tp = p.Next\n\tq.Next = p.Next\n\tq = q.Next\n}\np.Next = even\nreturn head", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "for i := 0; i < b.N; i++ {\n\thmap.HashInsert(rand.Intn(128), i)\n}", "gen": "var a int\nvar b int\nfor i := 0; i < 128; i++ {\n\ta = rand.Intn(256)\n\tb = rand.Intn(256)\n\tc := &struct {\n\t\ta int\n\t\tb int\n\t}{a, b}\n\td := &struct {\n\t\ta int\n\t\tb int\n\t}{a, b}\n\te := []int{a, b}\n\tf := []int{a, b}\n\tg := []int{a, b}\n\th := []int{a, b}\n\ti := []int{a, b}\n\tj := []int{a, b}\n\tk := []int{a, b}\n\tl := []int{a, b}\n\tm := []int{a, b}\n\tn := []int{a, b}\n\to := []int{a, b}\n\tp := []int{a, b}\n\tq := []int{a, b}\n\tr := []int{a, b}\n\ts := []int{a, b}\n\tt := []int{a, b}\n\tu := []int{a, b}\n\tv := []int{a, b}\n\tw := []int{a, b}\n\tx := []int{a, b}\n\ty := []int{a, b}\n\tz := []int{a, b}\n\taa := []int{a, b}\n\tab := []int{a, b}\n\tac := []int{a, b}\n\tad := []int{a, b}\n\tae := []int{a, b}\n\taf := []int{a, b}\n\tag := []int{a, b}\n\tah := []int{a, b}\n\tai := []int{a, b}\n\taj := []int{a, b}\n\tak :="}
{"tgt": "size := len(prices)\nif size <= 1 {\n\treturn 0\n}\nprofits := []int{}\ntemp := 0\nfor i := 1; i < size; i++ {\n\tdiff := prices[i] - prices[i-1]\n\tif temp*diff >= 0 {\n\t\ttemp += diff\n\t\tcontinue\n\t}\n\tprofits = append(profits, temp)\n\ttemp = diff\n}\nprofits = append(profits, temp)\nres := 0\nfor i := 0; i < len(profits); i++ {\n\ttemp = max(profits[:i]) + max(profits[i:])\n\tif res < temp {\n\t\tres = temp\n\t}\n}\nreturn res", "gen": "var a []int\nfor i := 0; i < len(a); i++ {\n\ta = append(a, a[i])\n}\nvar max int\nfor i := 0; i < len(a); i++ {\n\tif i == 0 {\n\t\tmax = a[i]\n\t} else {\n\t\tif a[i] > max {\n\t\t\tmax = a[i]\n\t\t}\n\t}\n}\nfor i := 0; i < len(a); i++ {\n\tif i == 0 {\n\t\tmax = a[i]\n\t} else {\n\t\tif a[i] > max {\n\t\t\tmax = a[i]\n\t\t}\n\t}\n}\nreturn max\n}\n"}
{"tgt": "_a := a\n_b := b\nif a < 0 {\n\ta *= -1\n}\nif b < 0 {\n\tb *= -1\n}\nx0, y0 := 0, 1\nx1, y1 := 1, 0\nfor b != 0 {\n\tquotient := a / b\n\ta, b = b, divide(a, b)\n\tx1, x0 = x0-quotient*x1, x1\n\ty1, y0 = y0-quotient*y1, y1\n}\nif _a < 0 {\n\ty0 *= -1\n}\nif _b < 0 {\n\tx0 *= -1\n}\nreturn y0, x0", "gen": "var a, b int64\na = 1\nb = 1\nfor a != 0 {\n\tif b == -1 {\n\t\ta = -a\n\t}\n\ta, b = b, a%b\n}\nreturn a, b\n}\n"}
{"tgt": "t.Run(\"STR\", func(t *testing.T) {\n\tdata := []int{1, 1, 2}\n\tgot := removeDuplicates(data)\n\twant := 2\n\tif got != want {\n\t\tt.Error(\"STR\", got, \"STR\", want)\n\t}\n})\nt.Run(\"STR\", func(t *testing.T) {\n\tdata := []int{0, 0, 1, 1, 1, 2, 2, 3, 3, 4}\n\tgot := removeDuplicates(data)\n\twant := 5\n\tif got != want {\n\t\tt.Error(\"STR\", got, \"STR\", want)\n\t}\n})", "gen": "solution := Solution{}\ntest := testing.T{}\ntest.Run(\"TestSolution..func"}
{"tgt": "if list == nil || list.Size == 0 {\n\tfmt.Println(\"STR\")\n\treturn\n}\nlist.mutex.RLock()\ndefer list.mutex.RUnlock()\nfmt.Printf(\"STR\", list.Size)\nptr := list.Head\nvar i uint\nfor i = 0; i < list.Size; i++ {\n\tfmt.Printf(\"STR\", i+1, ptr.Data)\n\tptr = ptr.Next\n}", "gen": "var s *Solution\nif s == nil {\n\tfmt.Println(\"s is nil\")\n} else {\n\tif s.go == nil {\n\t\tfmt.Println(\"s.go is nil\")\n\t} else {\n\t\tif s.go.Solution == nil {\n\t\t\tfmt.Println(\"s.go.Solution is nil\")\n\t\t} else {\n\t\t\tif s.go.Solution.go == nil {\n\t\t\t\tfmt.Println(\"s.go.Solution.go is nil\")\n\t\t\t} else {\n\t\t\t\tif s.go.Solution.go.Solution == nil {\n\t\t\t\t\tfmt.Println(\"s.go.Solution.go.Solution is nil\")\n\t\t\t\t} else {\n\t\t\t\t\tif s.go.Solution.go.Solution.go == nil {\n\t\t\t\t\t\tfmt.Println(\"s.go.Solution.go.Solution.go is nil\")\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif s.go.Solution.go.Solution.go.Solution == nil {\n\t\t\t\t\t\t\tfmt.Println(\"s.go.Solution.go.Solution.go.Solution is nil\")\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif s.go.Solution.go.Solution.go.Solution.go == nil {\n\t\t\t\t\t\t\t\tfmt.Println(\"s.go.Solution.go.Solution.go.Solution.go is nil\")\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif s.go.Solution.go.Solution.go.Solution.go.Solution == nil {\n\t\t\t\t\t\t\t\t\tfmt.Println(\"s.go.Solution.go.Solution.go.Solution.go.Solution is nil\")\n\t\t\t\t\t"}
{"tgt": "commonChars := make([]string, 0)\nif len(A) == 0 {\n\treturn commonChars\n}\nminFrequencies := [26]int{}\nfor i := range minFrequencies {\n\tminFrequencies[i] = math.MaxInt32\n}\nfor _, word := range A {\n\tcharFrequencies := [26]int{}\n\tfor _, char := range word {\n\t\tcharFrequencies[char-\"STR\"]++\n\t}\n\tfor i := 0; i < 26; i++ {\n\t\tminFrequencies[i] = min(minFrequencies[i], charFrequencies[i])\n\t}\n}\nfor i := 0; i < 26; i++ {\n\tfor minFrequencies[i] > 0 {\n\t\tcommonChars = append(commonChars, string(rune(i)+\"STR\"))\n\t\tminFrequencies[i]--\n\t}\n}\nreturn commonChars", "gen": "var s []byte\ns = append(s, \"abc\"...)\nfmt.Println(s)\n}\n"}
{"tgt": "return N&1 == 0", "gen": "var x int\nx = 1\nif x&1 == 0 {\n\tx = 0\n}\nreturn\n}\n\n// func main() {\n// \tvar x int\n// \tx = 1\n// \tif x&1 == 0 {\n// \t\tx = 0\n// \t}\n// \treturn\n// }\n\n// func main() {\n// \tvar x int\n// \tx = 1\n// \tif x&1 == 0 {\n// \t\tx = 0\n// \t}\n// \treturn\n// }\n\n// func main() {\n// \tvar x int\n// \tx = 1\n// \tif x&1 == 0 {\n// \t\tx = 0\n// \t}\n// \treturn\n// }\n\n// func main() {\n// \tvar x int\n// \tx = 1\n// \tif x&1 == 0 {\n// \t\tx = 0\n// \t}\n// \treturn\n// }\n\n// func main() {\n// \tvar x int\n// \tx = 1\n// \tif x&1 == 0 {\n// \t\tx = 0\n// \t}\n// \treturn\n// }\n\n// func main() {\n// \tvar x int\n// \tx = 1\n// \tif x&1 == 0 {\n// \t\tx = 0\n// \t}\n// \treturn\n// }\n\n// func main() {\n// \tvar x int\n// \tx = 1\n// \tif x&1 == 0 {\n// \t\tx = 0\n// \t}\n// \treturn\n// }\n\n// func main() {\n// \tvar x int\n// \tx = 1\n// \tif x&1 == 0 {\n// \t\tx = 0\n// \t}\n// \treturn\n// }\n\n// func main() {\n// \tvar x int\n// "}
{"tgt": "var head *event\nreturn MyCalendar{head: head}", "gen": "var a int\na = 0\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var num uint32\nvar ret int\nnum = 00000000000000000000000000001011\nret = 3\nif ret != hammingWeight(num) {\n\tt.Fatalf(\"STR\", ret)\n}", "gen": "t := &testing.T{}\nt.Fatalf(\"hammingWeight(%d) = %d, want %d\", 521, hammingWeight(521), 521)\n}\n"}
{"tgt": "if head == nil || head.Next == nil {\n\treturn head\n}\nresult := head.Next\nresult.Next, head.Next = head, head.Next.Next\nresult.Next.Next = SwapEveryTwo(result.Next.Next)\nreturn result", "gen": "var a *[2]int\nif a == nil {\n\treturn\n}\nif len(a) == 0 {\n\treturn\n}\nif cap(a) == 0 {\n\treturn\n}\nif a[0] == 0 {\n\treturn\n}\nif a[1] == 0 {\n\treturn\n}\na[0], a[1] = a[1], a[0]\na[1], a[0] = SwapEveryTwo(a[1], a[0])\nreturn\n}\n"}
{"tgt": "t.Parallel()\nfor tcid, tc := range testcases {\n\tif result := AreSentencesEquivalentTransitive(tc.sentence1,\n\t\ttc.sentence2, tc.thesaurus); result != tc.expectedTransitive {\n\t\tt.Errorf(\"STR\", tcid,\n\t\t\ttc.expectedTransitive, result)\n\t}\n}", "gen": "testing.MainStart(testcases, nil, nil)\n}\n"}
{"tgt": "m := make(map[int]int)\nfor k, v := range nums {\n\tif idx, ok := m[target-v]; ok {\n\t\treturn []int{idx, k}\n\t}\n\tm[v] = k\n}\nreturn nil", "gen": "m := make(map[int][2]int)\nfor i := 0; i < len(a); i++ {\n\tif _, ok := m[a[i][0]]; !ok {\n\t\tm[a[i][0]] = [2]int{a[i][1], 1}\n\t} else {\n\t\tm[a[i][0]][1]++\n\t}\n}\nfor k, v := range m {\n\tif v[1] == 1 {\n\t\tfmt.Println(k, v[0])\n\t}\n}\n}\n"}
{"tgt": "sum := 100 * 101 / 2\nsqSum := sum * sum\nsumSq := 0\nfor i := 1; i <= 100; i++ {\n\tsumSq += i * i\n}\nfmt.Println(sqSum - sumSq)", "gen": "var a int\nfor i := 1; i <= 100; i++ {\n\ta += i\n}\nvar b int\nb = a\nvar c int\nc = b\nvar d int\nd = c\nvar e int\ne = d\nvar f int\nf = e\nvar g int\ng = f\nvar h int\nh = g\nvar i int\ni = h\nvar j int\nj = i\nvar k int\nk = j\nvar l int\nl = k\nvar m int\nm = l\nvar n int\nn = m\nvar o int\no = n\nvar p int\np = o\nvar q int\nq = p\nvar r int\nr = q\nvar s int\ns = r\nvar t int\nt = s\nvar u int\nu = t\nvar v int\nv = u\nvar w int\nw = v\nvar x int\nx = w\nvar y int\ny = x\nvar z int\nz = y\nvar aa int\naa = z\nvar bb int\nbb = aa\nvar cc int\ncc = bb\nvar dd int\ndd = cc\nvar ee int\nee = dd\nvar ff int\nff = ee\nvar gg int\ngg = ff\nvar hh int\nhh = gg\nvar ii int\nii = hh\nvar jj int\njj = ii\nvar kk int\nkk = jj\nvar ll int\nll = kk\nvar mm int\nmm = ll\nvar nn int\nnn = mm\nvar oo int\noo = nn\nvar pp int\npp = oo\nvar qq int\nqq = pp\nvar rr int\nrr = qq\nvar ss int\nss = rr\nvar tt int\ntt ="}
{"tgt": "if a > b {\n\treturn b\n}\nreturn a", "gen": "if a < b {\n\treturn a\n}\nreturn b\n}\n"}
{"tgt": "return this.Val", "gen": "var a [4]int\nvar b int\nb = a[0]\n}\n\n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// \tvar a [4]int\n// \tvar b int\n// \tb = a[0]\n// }\n// \n// func main() {\n// "}
{"tgt": "n := len(prices)\nif 0 == n || 1 == n {\n\treturn 0\n}\nvar (\n\tres      int\n\tminPrice = prices[0]\n)\nfor i := 1; i < n; i++ {\n\tif prices[i] < prices[i-1] {\n\t\tres += prices[i-1] - minPrice\n\t\tminPrice = prices[i]\n\t}\n\tif i == n-1 {\n\t\tres += prices[i] - minPrice\n\t}\n}\nreturn res", "gen": "var a [3]int\nvar b int\nfor i := 0; i < len(a); i++ {\n\tif i == 0 {\n\t\tb = a[i]\n\t} else {\n\t\tif i == len(a)-1 {\n\t\t\tb = a[i]\n\t\t} else {\n\t\t\tif a[i] < a[i-1] {\n\t\t\t\tb = a[i]\n\t\t\t} else {\n\t\t\t\tif a[i] > a[i+1] {\n\t\t\t\t\tb = a[i]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nreturn b\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "bs := []byte(s)\nvar recur func(int, int) bool\nrecur = func(l, r int) bool {\n\tfor l < r {\n\t\tif bs[l] != bs[r] {\n\t\t\treturn false\n\t\t}\n\t\tl++\n\t\tr--\n\t}\n\treturn true\n}\nfor l, r := 0, len(s)-1; l < r; l, r = l+1, r-1 {\n\tif bs[l] == bs[r] {\n\t\tcontinue\n\t}\n\treturn recur(l+1, r) || recur(l, r-1)\n}\nreturn true", "gen": "fmt.Println(validPalindrome(\"abcdcba\"))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   \"STR\",\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   \"STR\",\n\t\twant: 0,\n\t},\n}\nfor _, tt := range tests {\n\tgot := maxNumberOfBalloons(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "var t testing.T\nvar s string\nvar i int\nvar j int\nvar k int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s1 string\nvar s2 string\nvar s3 string\nvar s4 string\nvar s5 string\nvar s6 string\nvar s7 string\nvar s8 string\nvar s9 string\nvar s10 string\nvar s11 string\nvar s12 string\nvar s13 string\nvar s14 string\nvar s15 string\nvar s16 string\nvar s17 string\nvar s18 string\nvar s19 string\nvar s20 string\nvar s21 string\nvar s22 string\nvar s23 string\nvar s24 string\nvar s25 string\nvar s26 string\nvar s27 string\nvar s28 string\nvar s29 string\nvar s30 string\nvar s31 string\nvar s32 string\nvar s33 string\nvar s34 string\nvar s35 string\nvar s36 string\nvar s37 string\nvar s38 string\nvar s39 string\nvar s40 string\nvar s41 string\nvar s42 string\nvar s43 string\nvar s44 string\nvar s45 string\nvar s46 string\nvar s47 string\nvar s48 string\nvar s49 string\nvar s50 string\nvar s51 string\nvar s52 string\nvar s53 string\nvar s54 string\nvar s55 string\nvar s56 string\nvar s57 string\nvar s58 string\nvar s59 string\nvar s60 string\nvar s61 string\nvar s62 string\nvar s63 string\nvar s64 string\nvar s6"}
{"tgt": "tests := [...]testType{\n\t{\n\t\twords: []string{\"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  true,\n\t},\n\t{\n\t\twords: []string{\"STR\", \"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  false,\n\t},\n\t{\n\t\twords: []string{\"STR\", \"STR\"},\n\t\torder: \"STR\",\n\t\twant:  false,\n\t},\n}\nfor _, tt := range tests {\n\tgot := isAlienSorted(tt.words, tt.order)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.words, got, tt.want)\n\t}\n}", "gen": "var s1, s2 string\ns1 = \"hello\"\ns2 = \"world\"\nif !isAlienSorted(s1, s2) {\n\tpanic(\"not sorted\")\n}\ns1 = \"apple\"\ns2 = \"banana\"\nif !isAlienSorted(s1, s2) {\n\tpanic(\"not sorted\")\n}\ns1 = \"apple\"\ns2 = \"banana\"\nif isAlienSorted(s1, s2) {\n\tpanic(\"sorted\")\n}\ns1 = \"abc\"\ns2 = \"abd\"\nif !isAlienSorted(s1, s2) {\n\tpanic(\"not sorted\")\n}\ns1 = \"abc\"\ns2 = \"abd\"\nif isAlienSorted(s1, s2) {\n\tpanic(\"sorted\")\n}\ns1 = \"ab\"\ns2 = \"ac\"\nif !isAlienSorted(s1, s2) {\n\tpanic(\"not sorted\")\n}\ns1 = \"ab\"\ns2 = \"ac\"\nif isAlienSorted(s1, s2) {\n\tpanic(\"sorted\")\n}\ns1 = \"ab\"\ns2 = \"ac\"\nif !isAlienSorted(s1, s2) {\n\tpanic(\"not sorted\")\n}\ns1 = \"ab\"\ns2 = \"ac\"\nif isAlienSorted(s1, s2) {\n\tpanic(\"sorted\")\n}\ns1 = \"ab\"\ns2 = \"ac\"\nif !isAlienSorted(s1, s2) {\n\tpanic(\"not sorted\")\n}\ns1 = \"ab\"\ns2 = \"ac\"\nif isAlienSorted(s1, s2) {\n\t"}
{"tgt": "qs := []question1051{\n\t{\n\t\tpara1051{[]int{1, 1, 4, 2, 1, 3}},\n\t\tans1051{3},\n\t},\n\t{\n\t\tpara1051{[]int{5, 1, 2, 3, 4}},\n\t\tans1051{5},\n\t},\n\t{\n\t\tpara1051{[]int{1, 2, 3, 4, 5}},\n\t\tans1051{0},\n\t},\n\t{\n\t\tpara1051{[]int{5, 4, 3, 2, 1}},\n\t\tans1051{4},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1051, q.para1051\n\tfmt.Printf(\"STR\", p, heightChecker(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%d %d %d\\n\", 1, 2, 3)\nfmt.Printf(\"%d %d %d\\n\", 4, 1, 2)\nfmt.Printf(\"%d %d %d\\n\", 3, 4, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 1, 2)\nfmt.Printf(\"%d %d %d\\n\", 5, 3, 4)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5, 5)\nfmt.Printf(\"%d %d %d\\n\", 5, 5,"}
{"tgt": "i := 1\ntmp := 0\nfor i < len(arr) {\n\tif arr[i] >= arr[i-1] {\n\t\ti++\n\t} else {\n\t\ttmp = arr[i]\n\t\tarr[i] = arr[i-1]\n\t\tarr[i-1] = tmp\n\t\tif i > 1 {\n\t\t\ti--\n\t\t}\n\t}\n}", "gen": "var a [3]int\nvar b int\nfor i := 0; i < len(a); i++ {\n\tif i == 0 {\n\t\tb = a[i]\n\t} else {\n\t\ta[i-1] = a[i]\n\t}\n}\na[len(a)-1] = b\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if maxSize > 0 {\n\tstack := &Stack{}\n\tstack.top = nil\n\tstack.size = 0\n\tstack.maxSize = maxSize\n\treturn stack\n}\nreturn nil", "gen": "var s *Stack\nif s == nil {\n\ts = new(Stack)\n}\ns.Push(1)\ns.Push(2)\ns.Push(3)\ns.Push(4)\ns.Push(5)\ns.Push(6)\ns.Push(7)\ns.Push(8)\ns.Push(9)\ns.Push(10)\ns.Push(11)\ns.Push(12)\ns.Push(13)\ns.Push(14)\ns.Push(15)\ns.Push(16)\ns.Push(17)\ns.Push(18)\ns.Push(19)\ns.Push(20)\ns.Push(21)\ns.Push(22)\ns.Push(23)\ns.Push(24)\ns.Push(25)\ns.Push(26)\ns.Push(27)\ns.Push(28)\ns.Push(29)\ns.Push(30)\ns.Push(31)\ns.Push(32)\ns.Push(33)\ns.Push(34)\ns.Push(35)\ns.Push(36)\ns.Push(37)\ns.Push(38)\ns.Push(39)\ns.Push(40)\ns.Push(41)\ns.Push(42)\ns.Push(43)\ns.Push(44)\ns.Push(45)\ns.Push(46)\ns.Push(47)\ns.Push(48)\ns.Push(49)\ns.Push(50)\ns.Push(51)\ns.Push(52)\ns.Push(53)\ns.Push(54"}
{"tgt": "b, _ := ioutil.ReadFile(\"STR\")\ns := strings.Replace(string(b), \"STR\", \"STR\", -1)\nnumData := strings.Split(s, \"STR\")\nfor _, n := range numData {\n\tnumber, err := strconv.Atoi(n)\n\tif err == nil {\n\t\tdata = append(data, number)\n\t}\n}", "gen": "data := []int{1, 2, 3}\ndata = append(data, 4)\nfmt.Println(data)\n}\n"}
{"tgt": "if len(candidates) == 0 {\n\treturn [][]int{}\n}\nc, res := []int{}, [][]int{}\nsort.Ints(candidates)\nfindcombinationSum(candidates, target, 0, c, &res)\nreturn res", "gen": "nums := []int{2, 3, 6, 7}\ntarget := 7\ncombinationSum(nums, target)\n}\n"}
{"tgt": "qs := []question786{\n\t{\n\t\tpara786{[]int{1, 2, 3, 5}, 3},\n\t\tans786{[]int{2, 5}},\n\t},\n\t{\n\t\tpara786{[]int{1, 7}, 1},\n\t\tans786{[]int{1, 7}},\n\t},\n\t{\n\t\tpara786{[]int{1, 2}, 1},\n\t\tans786{[]int{1, 2}},\n\t},\n\t{\n\t\tpara786{[]int{1, 2, 3, 5, 7}, 6},\n\t\tans786{[]int{3, 7}},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans786, q.para786\n\tfmt.Printf(\"STR\", p, kthSmallestPrimeFraction(p.A, p.K))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(kthSmallestPrimeFraction([]int{2, 3, 5, 7}, 3))\n}\n"}
{"tgt": "errObj := appError{\n\tError:      handlerError.Error(),\n\tMessage:    message,\n\tHTTPStatus: code,\n}\nError.Printf(\"STR\", handlerError)\nw.Header().Set(\"STR\", \"STR\")\nw.WriteHeader(code)\nif j, err := json.Marshal(errorResource{Data: errObj}); err == nil {\n\tw.Write(j)\n}", "gen": "var err error\nvar resp *http.Response\nvar req *http.Request\nvar body []byte\nvar errResp errorResource\nvar jsonBody []byte\nvar jsonErr error\nreq, err = http.NewRequest(\"GET\", \"http://localhost:8080/api/v1/users\", nil)\nif err != nil {\n\tlog.Printf(\"error: %v\", err)\n\treturn\n}\nresp, err = http.DefaultClient.Do(req)\nif err != nil {\n\tlog.Printf(\"error: %v\", err)\n\treturn\n}\ndefer resp.Body.Close()\nbody, err = ioutil.ReadAll(resp.Body)\nif err != nil {\n\tlog.Printf(\"error: %v\", err)\n\treturn\n}\nif resp.StatusCode != 200 {\n\terrResp = errorResource{}\n\tjsonErr = json.Unmarshal(body, &errResp)\n\tif jsonErr != nil {\n\t\tlog.Printf(\"error: %v\", jsonErr)\n\t\treturn\n\t}\n\tlog.Printf(\"error: %v\", errResp)\n\treturn\n}\njsonBody, err = json.Marshal(errResp)\nif err != nil {\n\tlog.Printf(\"error: %v\", err)\n\treturn\n}\nlog.Printf(\"error: %v\", errResp)\nreturn\n}\n"}
{"tgt": "if len(strs) == 0 {\n\treturn nil\n}\nr := make(map[string][]string)\nfor _, str := range strs {\n\tcount := make([]int, 26)\n\tfor _, b := range []byte(str) {\n\t\tcount[b-'a']++\n\t}\n\tbs := make([]byte, 26*2)\n\tfor i, c := range count {\n\t\tbs[2*i] = '#'\n\t\tbs[2*i+1] = byte(c) + '0'\n\t}\n\tkey := string(bs)\n\tr[key] = append(r[key], str)\n}\nres := make([][]string, len(r))\ni := 0\nfor _, l := range r {\n\tres[i] = l\n\ti++\n}\nreturn res", "gen": "var m map[string]string\nif len(os.Args) == 1 {\n\tm = make(map[string]string)\n} else {\n\tm = make(map[string]string)\n}\nm[\"\"] = \"\"\nvar s string\ns = \"\"\nvar i int\ni = 0\nfor {\n\tif i < len(os.Args) {\n\t\tgoto Label1\n\t}\n\tgoto Label2\n}\nLabel1:\ni = i + 1\ns = string(os.Args[i])\nm[s] = s\ngoto Label1\nLabel2:\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "type Address struct {\n\tCountry string  `json:\"STR\"`\n\tPerson  *Person `json:\"STR\"`\n}\nperson := &Person{\n\tName: \"STR\",\n\tAge:  23,\n}\naddress := &Address{\n\tCountry: \"STR\",\n\tPerson:  person,\n}\ndefer func() {\n\terr := recover()\n\tif err != nil {\n\t\tfmt.Printf(\"STR\", err)\n\t\tt.Error(\"STR\")\n\t}\n}()\ns := New(address)\ns.TagName = \"STR\"\nm := s.Map()\nif m[\"STR\"] != person.String() {\n\tt.Errorf(\"STR\", person.String(), m[\"STR\"])\n}\nvs := s.Values()\nif vs[1] != person.String() {\n\tt.Errorf(\"STR\", person.String(), vs[1])\n}", "gen": "p := Person{\n\tName: \"john\",\n\tAge:  23,\n}\np.Map()\nif p.String() != \"john\" {\n\tt.Errorf(\"p.String() != \\\"john\\\"\")\n}\nif p.Map()[\"Address\"].(Address).Map()[\"Person\"].(Person).String() != \"john\" {\n\tt.Errorf(\"p.Map()[\\\"Address\\\"].(Address).Map()[\\\"Person\\\"].(Person).String() != \\\"john\\\"\")\n}\nif p.Map()[\"Address\"].(Address).Map()[\"Person\"].(Person).String() != \"john\" {\n\tt.Errorf(\"p.Map()[\\\"Address\\\"].(Address).Map()[\\\"Person\\\"].(Person).String() != \\\"john\\\"\")\n}\n}\n"}
{"tgt": "if parser.tokens_head > 0 && len(parser.tokens) == cap(parser.tokens) {\n\tif parser.tokens_head != len(parser.tokens) {\n\t\tcopy(parser.tokens, parser.tokens[parser.tokens_head:])\n\t}\n\tparser.tokens = parser.tokens[:len(parser.tokens)-parser.tokens_head]\n\tparser.tokens_head = 0\n}\nparser.tokens = append(parser.tokens, *token)\nif pos < 0 {\n\treturn\n}\ncopy(parser.tokens[parser.tokens_head+pos+1:], parser.tokens[parser.tokens_head+pos:])\nparser.tokens[parser.tokens_head+pos] = *token", "gen": "var a []int\nvar b []int\nvar c []int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar xx int\nvar yy int\nvar zz int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int\nvar pp int\nvar qq int\nvar rr int\nvar ss int\nvar tt int\nvar uu int\nvar vv int\nvar ww int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar bb int\nvar cc int\nvar dd int\nvar ee int\nvar ff int\nvar gg int\nvar hh int\nvar ii int\nvar jj int\nvar kk int\nvar ll int\nvar mm int\nvar nn int\nvar oo int"}
{"tgt": "str := \"STR\"\nfmt.Println(longestPalindrome(str))", "gen": "fmt.Println(longestPalindrome(\"babad\"))\n}\n"}
{"tgt": "tests := [...]testType{\n\t{\n\t\tin:   5,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   8,\n\t\twant: 3,\n\t},\n\t{\n\t\tin:   0,\n\t\twant: 0,\n\t},\n\t{\n\t\tin:   1,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   2,\n\t\twant: 1,\n\t},\n\t{\n\t\tin:   3,\n\t\twant: 2,\n\t},\n\t{\n\t\tin:   13,\n\t\twant: 4,\n\t},\n\t{\n\t\tin:   130,\n\t\twant: 15,\n\t},\n}\nfor _, tt := range tests {\n\tgot := arrangeCoins(tt.in)\n\tif got != tt.want {\n\t\tt.Fatalf(\"STR\", tt.in, got, tt.want)\n\t}\n}", "gen": "arrangeCoins(5)\n}\n"}
{"tgt": "return WordDictionary{}", "gen": "var a [27]int\na[0] = 1\na[1] = 2\na[2] = 3\na[3] = 4\na[4] = 5\na[5] = 6\na[6] = 7\na[7] = 8\na[8] = 9\na[9] = 10\na[10] = 11\na[11] = 12\na[12] = 13\na[13] = 14\na[14] = 15\na[15] = 16\na[16] = 17\na[17] = 18\na[18] = 19\na[19] = 20\na[20] = 21\na[21] = 22\na[22] = 23\na[23] = 24\na[24] = 25\na[25] = 26\na[26] = 27\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "tcs := []struct {\n\ts   string\n\tans bool\n}{\n\t{\n\t\t\"STR\",\n\t\tfalse,\n\t},\n\t{\n\t\t\"STR\",\n\t\ttrue,\n\t},\n\t{\n\t\t\"STR\",\n\t\tfalse,\n\t},\n\t{\n\t\t\"STR\",\n\t\ttrue,\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, tc := range tcs {\n\tfmt.Printf(\"STR\", tc, isPalindrome(tc.s))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 123, true)\nfmt.Printf(\"%s %d %t\", \"abc\", 1"}
{"tgt": "var drinks []Drink\ninverted := make(map[Drink][]Customer)\nfor cust, favorites := range prefs {\n\tfor _, drink := range favorites {\n\t\tinverted[drink] = append(inverted[drink], cust)\n\t}\n}\ntotalCustomers := len(prefs)\nserved := make(map[Customer]struct{}, totalCustomers)\nfor len(served) < totalCustomers {\n\tvar largest []Customer\n\tvar largestDrink Drink\n\tvar largestIncrease int\n\tfor drink, custs := range inverted {\n\t\tvar newlyServed int\n\t\tfor _, cust := range custs {\n\t\t\tif _, found := served[cust]; !found {\n\t\t\t\tnewlyServed++\n\t\t\t}\n\t\t}\n\t\tif newlyServed > largestIncrease {\n\t\t\tlargestIncrease = newlyServed\n\t\t\tlargestDrink = drink\n\t\t\tlargest = custs\n\t\t}\n\t}\n\tdelete(inverted, largestDrink)\n\tdrinks = append(drinks, largestDrink)\n\tfor _, cust := range largest {\n\t\tserved[cust] = struct{}{}\n\t}\n}\nsort.Slice(drinks, func(i, j int) bool {\n\treturn drinks[i] < drinks[j]\n})\nreturn drinks", "gen": "var c Customer\nvar d Drink\nvar m map[Drink]Customer\nm = make(map[Drink]Customer)\nfor _, v := range m {\n\tm[v] = Customer{\n\t\tName: \"Bob\",\n\t\tAge:  20,\n\t}\n}\nfor k, v := range m {\n\tm[k] = Customer{\n\t\tName: \"Bob\",\n\t\tAge:  20,\n\t}\n}\nfor k, v := range m {\n\tm[k] = Customer{\n\t\tName: \"Bob\",\n\t\tAge:  20,\n\t}\n}\nfor k, v := range m {\n\tm[k] = Customer{\n\t\tName: \"Bob\",\n\t\tAge:  20,\n\t}\n}\nfor k, v := range m {\n\tm[k] = Customer{\n\t\tName: \"Bob\",\n\t\tAge:  20,\n\t}\n}\nfor k, v := range m {\n\tm[k] = Customer{\n\t\tName: \"Bob\",\n\t\tAge:  20,\n\t}\n}\nfor k, v := range m {\n\tm[k] = Customer{\n\t\tName: \"Bob\",\n\t\tAge:  20,\n\t}\n}\nfor k, v := range m {\n\tm[k] = Customer{\n\t\tName: \"Bob\",\n\t\tAge:  20,\n\t}\n}\nfor k, v := range m {\n\tm[k] = Customer{\n\t\tName: \"Bob\",\n\t\tAge:  20,\n\t}\n}\nfor k, v := range m {\n\tm[k] = Customer{\n\t\tName: \"Bob\",\n\t\tAge:  20,\n\t}\n}\nfor k, v := range"}
{"tgt": "wg.Add(2)\ngoincCounter(1)\ngoincCounter(2)\nwg.Wait()\nfmt.Println(\"STR\", counter)", "gen": "var wg sync.WaitGroup\nwg.Add(2)\ngo func() {\n\tcounter := 0\n\tfmt.Println(counter)\n}()\ngo func() {\n\tcounter := 0\n\tfmt.Println(counter)\n}()\nwg.Wait()\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs [][]int\n\texpect int\n}{\n\t{\"STR\", [][]int{{-1, 2, 1, -4}, {1}}, 2},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tret := threeSumClosest(c.inputs[0], c.inputs[1][0])\n\t\tif !reflect.DeepEqual(ret, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, ret, c.inputs)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nsolution.TestSolution()\n}\n"}
{"tgt": "qs := []question1037{\n\t{\n\t\tpara1037{[][]int{{1, 2}, {2, 3}, {3, 2}}},\n\t\tans1037{true},\n\t},\n\t{\n\t\tpara1037{[][]int{{1, 1}, {2, 2}, {3, 3}}},\n\t\tans1037{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1037, q.para1037\n\tfmt.Printf(\"STR\", p, isBoomerang(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello, world\")\n}\n"}
{"tgt": "sort.Slice(words, func(i, j int) bool {\n\tcuri := len(words[i])\n\tcurj := len(words[j])\n\tfor curi > 0 && curj > 0 {\n\t\tcuri--\n\t\tcurj--\n\t\tif words[i][curi] == words[j][curj] {\n\t\t\tcontinue\n\t\t}\n\t\tif words[i][curi] > words[j][curj] {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\treturn curi == 0\n})\nwords = append(words, \"STR\")\nres, i := 0, 1\nfor ; i < len(words); i++ {\n\tif !endWith(words[i], words[i-1]) {\n\t\tres += len(words[i-1]) + 1\n\t}\n}\nreturn res", "gen": "var s string\nfmt.Scan(&s)\nvar t string\nfmt.Scan(&t)\nvar ans int\nans = minimumLengthEncoding(s, t)\nfmt.Println(ans)\n}\n"}
{"tgt": "fmt.Println(badLongestPalindrome(\"STR\"))\nfmt.Println(goodLongestPalindrome(\"STR\"))\nfmt.Println(bestLongestPalindrome(\"STR\"))", "gen": "badLongestPalindrome()\ngoodLongestPalindrome()\nbestLongestPalindrome()\n}\n"}
{"tgt": "for i := 0; i < len(A)-1; i++ {\n\tif A[i] == i {\n\t\tcontinue\n\t}\n\tif A[i] == i+1 && A[i+1] == i {\n\t\ti++\n\t} else {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n\tif i == len(a) {\n\t\tpanic(\"out of range\")\n\t}\n"}
{"tgt": "hash := uint32(0)\nfor i := len(sep) - 1; i >= 0; i-- {\n\thash = hash*PrimeRK + uint32(sep[i])\n}\nvar pow, sq uint32 = 1, PrimeRK\nfor i := len(sep); i > 0; i >>= 1 {\n\tif i&1 != 0 {\n\t\tpow *= sq\n\t}\n\tsq *= sq\n}\nreturn hash, pow", "gen": "var a [10]int\nvar b int\nfor i := range a {\n\tb += a[i]\n}\nreturn b\n}\n\nTEXT main.main(SB) /Users/mdempsky/go/src/main/main.go\nMOVQ $0, AX\nMOVQ $0, CX\nMOVQ $0, DX\nMOVQ $0, R8\nMOVQ $0, R9\nMOVQ $0, R10\nMOVQ $0, R11\nMOVQ $0, R12\nMOVQ $0, R13\nMOVQ $0, R14\nMOVQ $0, R15\nMOVQ $0, RBP\nMOVQ $0, RSP\nMOVQ $0, RSI\nMOVQ $0, RDI\nMOVQ $0, RBX\nMOVQ $0, RDX\nMOVQ $0, RAX\nMOVQ $0, RCX\nMOVQ $0, R8\nMOVQ $0, R9\nMOVQ $0, R10\nMOVQ $0, R11\nMOVQ $0, R12\nMOVQ $0, R13\nMOVQ $0, R14\nMOVQ $0, R15\nMOVQ $0, RBP\nMOVQ $0, RSP\nMOVQ $0, RSI\nMOVQ $0, RDI\nMOVQ $0, RBX\nMOVQ $0, RDX\nMOVQ $0, RAX\nMOVQ $0, RCX\nMOVQ $0, R8\nMOVQ $0, R9\nMOVQ $0, R10\nMOVQ $0, R11\nMOVQ $0, R12\nMOVQ $0, R13\nMO"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif sum := SumBSTRange(tc.root, tc.a, tc.b); sum != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, sum)\n\t}\n}", "gen": "t := testing.T{}\nt.Parallel()\nfor i := 0; i < len(testcases); i++ {\n\tif SumBSTRange(testcases[i].root, testcases[i].low, testcases[i].high) != testcases[i].sum {\n\t\tt.Errorf(\"SumBSTRange(%v, %v, %v) = %v; want %v\", testcases[i].root, testcases[i].low, testcases[i].high, SumBSTRange(testcases[i].root, testcases[i].low, testcases[i].high), testcases[i].sum)\n\t}\n}\n}\n"}
{"tgt": "arr := make([]bool, 105000)\narr[0], arr[1] = true, true\ncount, prime := 2, 3\nvar k int\nfor {\n\tfor k = 2 * prime; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tcount++\n\t\tif count == 10001 {\n\t\t\tprintln(prime)\n\t\t\tbreak\n\t\t}\n\t} else {\n\t\tbreak\n\t}\n}", "gen": "var a [105000]bool\nfor i := 0; i < 105000; i++ {\n\ta[i] = true\n\ta[i+1] = false\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = true\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = false\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = true\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = false\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = true\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = false\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = true\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\ta[i+1] = false\n\t}\n}\nfor i := 0; i < 105000; i += 2 {\n\tif a[i] {\n\t\t"}
{"tgt": "n1, n2 := len(nums1), len(nums2)\nif n1 > n2 {\n\tn1, n2, nums1, nums2 = n2, n1, nums2, nums1\n}\nm := make(map[int]int, n1)\nfor _, num := range nums1 {\n\tm[num]++\n}\nres := make([]int, 0, n1)\nfor _, num := range nums2 {\n\tif v, ok := m[num]; ok && v > 0 {\n\t\tres = append(res, num)\n\t\tm[num]--\n\t}\n}\nreturn res", "gen": "var a, b int\nvar c, d int\nvar e, f int\nvar g, h int\nvar i, j int\nvar k, l int\nvar m, n int\nvar o, p int\nvar q, r int\nvar s, t int\nvar u, v int\nvar w, x int\nvar y, z int\nvar A, B int\nvar C, D int\nvar E, F int\nvar G, H int\nvar I, J int\nvar K, L int\nvar M, N int\nvar O, P int\nvar Q, R int\nvar S, T int\nvar U, V int\nvar W, X int\nvar Y, Z int\nvar AA, BB int\nvar CC, DD int\nvar EE, FF int\nvar GG, HH int\nvar II, JJ int\nvar KK, LL int\nvar MM, NN int\nvar OO, PP int\nvar QQ, RR int\nvar SS, TT int\nvar UU, VV int\nvar WW, XX int\nvar YY, ZZ int\nvar AAA, BBB int\nvar CCC, DDD int\nvar EEE, FFF int\nvar GGG, HHH int\nvar III, JJJ int\nvar KKK, LLL int\nvar MMM, NNN int\nvar OOO, PPP int\nvar QQQ, RRR int\nvar SSS, TTT int\nvar UUU, VVV int\nvar WWW, XXX int\nvar YYY, ZZZ int\nvar AAAA, BBBB int\nvar CCCC, DDDD int\nvar EEEE, FFFF int\nvar GGGG, HHHH int\nvar IIIA, JJJB int\nvar KKKC, LLLD int\nvar MMMM, NNNN int\nvar OOOO, PP"}
{"tgt": "if root == nil {\n\treturn nil\n}\ns := []*TreeNode{root}\nres := [][]int{}\nzigzag := false\nfor len(s) != 0 {\n\ttmp := []*TreeNode{}\n\tl := []int{}\n\tfor i, node := range s {\n\t\tif zigzag {\n\t\t\tl = append(l, s[len(s)-i-1].Val)\n\t\t} else {\n\t\t\tl = append(l, node.Val)\n\t\t}\n\t\tif node.Left != nil {\n\t\t\ttmp = append(tmp, node.Left)\n\t\t}\n\t\tif node.Right != nil {\n\t\t\ttmp = append(tmp, node.Right)\n\t\t}\n\t}\n\tres = append(res, l)\n\ts = tmp\n\tzigzag = !zigzag\n}\nreturn res", "gen": "root := &TreeNode{Val: 3, Left: &TreeNode{Val: 9}}\nroot.Right = &TreeNode{Val: 20, Left: &TreeNode{Val: 15, Right: &TreeNode{Val: 7}}}\npreorderTraversal(root)\n}\n"}
{"tgt": "count := 0\nfor i := 0; i < 10000; i++ {\n\tif isL(i) {\n\t\tcount++\n\t}\n}\nfmt.Println(count)", "gen": "var i int\nfor i = 0; i < 10000; i++ {\n\tif isL(i) {\n\t\t*(*int)(unsafe.Pointer(&i))++\n\t}\n}\nfmt.Println(i)\n}"}
{"tgt": "if len(str) == 0 {\n\treturn 0\n}\nvar (\n\tnum int\n\tneg bool\n)\nfor i, s := range str {\n\tif s != ' ' {\n\t\tstr = str[i:]\n\t\tbreak\n\t}\n}\nif str[0] == '+' {\n\tstr = str[1:]\n} else if str[0] == '-' {\n\tstr = str[1:]\n\tneg = true\n}\nfor _, s := range str {\n\tif s < '0' || s > '9' {\n\t\tbreak\n\t}\n\tnum = num*10 + int(s-'0')\n\tif num > 2147483648 {\n\t\tnum = 2147483648\n\t\tbreak\n\t}\n}\nif neg {\n\tnum *= -1\n} else if num > 2147483647 {\n\tnum = 2147483647\n}\nreturn num", "gen": "var s []byte\nvar i int\nfor _, c := range s {\n\tif c == '+' {\n\t\ti++\n\t} else if c == '-' {\n\t\ti--\n\t}\n}\nreturn i\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "ans, m, n := []int{}, len(matrix), len(matrix[0])\nfor j := 0; j < n; j++ {\n\tmax, rowIndex := 1, 0\n\tfor i := 0; i < m; i++ {\n\t\tif matrix[i][j] > max {\n\t\t\tmax = matrix[i][j]\n\t\t\trowIndex = i\n\t\t}\n\t}\n\tif Min(matrix[rowIndex]) == max {\n\t\tans = append(ans, max)\n\t}\n}\nreturn ans", "gen": "var nums = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nvar k int = 5\nvar res = minK(nums, k)\nfmt.Println(res)\n}\n"}
{"tgt": "strNumber := strconv.Itoa(number)\nfor _, runeDigit := range []rune(strNumber) {\n\tdigit := int(runeDigit - '0')\n\tlist = append(list, digit)\n}\nreturn", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\ta = append(a, i)\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "if num == 0 {\n\treturn \"STR\"\n}\nh := []string{\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\",\n\t\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\"}\nres := \"STR\"\nfor i := 0; i < 8 && num != 0; i++ {\n\tres = h[num&15] + res\n\tnum >>= 4\n}\nreturn res", "gen": "if len(os.Args) != 2 {\n\tpanic(\"usage: \" + os.Args[0] + \" <n>\")\n}\nn, _ := strconv.Atoi(os.Args[1])\nif n < 0 {\n\tpanic(\"n must be non-negative\")\n}\nif n == 0 {\n\treturn\n}\nvar s string\nfor i := 0; i < 8; i++ {\n\ts += fmt.Sprintf(\"%d\", n&15)\n\tn >>= 4\n}\nfmt.Println(s)\n}\n"}
{"tgt": "if len(n.Exprs) == 0 {\n\treturn TypeString, nil\n}\nif len(n.Exprs) == 1 {\n\texprType, err := n.Exprs[0].Type(s)\n\tif err != nil {\n\t\treturn TypeInvalid, err\n\t}\n\tswitch exprType {\n\tcase TypeList:\n\t\treturn TypeList, nil\n\tcase TypeMap:\n\t\treturn TypeMap, nil\n\t}\n}\nfor index, expr := range n.Exprs {\n\texprType, err := expr.Type(s)\n\tif err != nil {\n\t\treturn TypeInvalid, err\n\t}\n\tif exprType == TypeList || exprType == TypeMap {\n\t\treturn TypeInvalid, fmt.Errorf(\n\t\t\t\"STR\",\n\t\t\tindex, exprType)\n\t}\n}\nreturn TypeString, nil", "gen": "var a []int\nvar b []int\nvar c []int\nvar d []int\nvar e []int\nvar f []int\nvar g []int\nvar h []int\nvar i []int\nvar j []int\nvar k []int\nvar l []int\nvar m []int\nvar n []int\nvar o []int\nvar p []int\nvar q []int\nvar r []int\nvar s []int\nvar t []int\nvar u []int\nvar v []int\nvar w []int\nvar x []int\nvar y []int\nvar z []int\nvar aa []int\nvar bb []int\nvar cc []int\nvar dd []int\nvar ee []int\nvar ff []int\nvar gg []int\nvar hh []int\nvar ii []int\nvar jj []int\nvar kk []int\nvar ll []int\nvar mm []int\nvar nn []int\nvar oo []int\nvar pp []int\nvar qq []int\nvar rr []int\nvar ss []int\nvar tt []int\nvar uu []int\nvar vv []int\nvar ww []int\nvar xx []int\nvar yy []int\nvar zz []int\nvar aaa []int\nvar bbb []int\nvar ccc []int\nvar ddd []int\nvar eee []int\nvar fff []int\nvar ggg []int\nvar hhh []int\nvar iii []int\nvar jjj []int\nvar kkk []int\nvar lll []int\nvar mmm []int\nvar nnn []int\nvar ooo []int\nvar ppp []int\nvar qqq []int\nvar rrr []int\nvar sss []int\nvar ttt []int\nvar uuu []int\nvar vvv []int\nvar www []int\nvar xxx []int\nvar yyy"}
{"tgt": "psum, min := 0, 1\nfor _, val := range nums {\n\tpsum += val\n\tif psum < min {\n\t\tmin = psum\n\t}\n}\nif min > 0 {\n\treturn min\n}\nreturn -min + 1", "gen": "var a [3]int\nvar sum int\nfor i := 0; i < len(a); i++ {\n\tsum += a[i]\n}\nfmt.Println(sum)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "arr := make([]bool, 2000000)\narr[0], arr[1] = true, true\nsum, prime := int64(5), 3\nvar k int\nfor {\n\tfor k = 2 * prime; k < len(arr); k += prime {\n\t\tarr[k] = true\n\t}\n\tfor k = prime + 2; k < len(arr) && arr[k]; k += 2 {\n\t}\n\tif k < len(arr) {\n\t\tprime = k\n\t\tsum += int64(k)\n\t} else {\n\t\tbreak\n\t}\n}\nprintln(sum)", "gen": "var a [2000000]bool\nfor i := 0; i < 2000000; i++ {\n\ta[i] = true\n\ta[i+1] = false\n}\nfor i := 0; i < 5; i++ {\n\tfor j := 0; j < 3; j++ {\n\t\ta[i+j] = true\n\t\ta[i+j+1] = false\n\t}\n}\nfor i := 0; i < 2000000; i++ {\n\tif i < 1 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i > 1 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif a[i] {\n\t\ta[i+1] = true\n\t}\n}\nfor i := 0; i < 2000000; i++ {\n\tif i < 1 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i > 1 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif a[i] {\n\t\ta[i+1] = false\n\t}\n}\nfor i := 0; i < 2000000; i++ {\n\tif i < 1 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i > 1 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif a[i] {\n\t\ta[i+1] = true\n\t}\n}\nfor i := 0; i < 2000000; i++ {\n\tif i < 1 {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n"}
{"tgt": "qs := []question693{\n\t{\n\t\tpara693{5},\n\t\tans693{true},\n\t},\n\t{\n\t\tpara693{7},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{11},\n\t\tans693{false},\n\t},\n\t{\n\t\tpara693{10},\n\t\tans693{true},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans693, q.para693\n\tfmt.Printf(\"STR\", p, hasAlternatingBits(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%d %d %d\\n\", 4, 4, 0)\nvar a = []int{5, 4, 3, 2, 1}\nvar b = []int{5, 4, 3, 2, 1}\nvar c = []int{5, 4, 3, 2, 1}\nvar d = []int{5, 4, 3, 2, 1}\nvar e = []int{5, 4, 3, 2, 1}\nvar f = []int{5, 4, 3, 2, 1}\nvar g = []int{5, 4, 3, 2, 1}\nvar h = []int{5, 4, 3, 2, 1}\nvar i = []int{5, 4, 3, 2, 1}\nvar j = []int{5, 4, 3, 2, 1}\nvar k = []int{5, 4, 3, 2, 1}\nvar l = []int{5, 4, 3, 2, 1}\nvar m = []int{5, 4, 3, 2, 1}\nvar n = []int{5, 4, 3, 2, 1}\nvar o = []int{5, 4, 3, 2, 1}\nvar p = []int{5, 4, 3, 2, 1}\nvar q = []int{5, 4, 3, 2, 1}\nvar r = []int{5, 4, 3, 2, 1}\nvar s = []int{5, 4, 3, 2, 1}\nvar t = []int{5, 4, 3, 2, 1}\nvar u = []int{5, 4, 3, 2, 1}\nvar v = []int{5, 4, 3"}
{"tgt": "sum := 0\nfor i := 1; i <= n; i++ {\n\tsquare := i * i\n\tsum += square\n}\nreturn sum", "gen": "var sum int\nfor i := 0; i < 10; i++ {\n\tsum += i\n}\nreturn sum\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SmallerRightCount(tc.nums); !reflect.DeepEqual(result, tc.expected) {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "var i int\nfor j, k := 0, 0; j < len(nums); j = k {\n\tfor k < len(nums) && nums[j] == nums[k] {\n\t\tif k < j+2 {\n\t\t\tnums[i] = nums[k]\n\t\t\ti++\n\t\t}\n\t\tk++\n\t}\n}\nreturn i", "gen": "var a [10]int\nvar i int\nvar j int\nfor i = 0; i < 10; i++ {\n\tfor j = 0; j < 10; j++ {\n\t\tif i < j {\n\t\t\ta[i] = a[j]\n\t\t}\n\t}\n}\nreturn a[0]\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "result := make([]int, 0, len(left)+len(right))\nfor len(left) > 0 || len(right) > 0 {\n\tif len(left) == 0 {\n\t\treturn append(result, right...)\n\t}\n\tif len(right) == 0 {\n\t\treturn append(result, left...)\n\t}\n\tif left[0] <= right[0] {\n\t\tresult = append(result, left[0])\n\t\tleft = left[1:]\n\t} else {\n\t\tresult = append(result, right[0])\n\t\tright = right[1:]\n\t}\n}\nreturn result", "gen": "var a []int\nvar b []int\nvar c []int\nvar d []int\nvar e []int\nvar f []int\nvar g []int\nvar h []int\nvar i []int\nvar j []int\nvar k []int\nvar l []int\nvar m []int\nvar n []int\nvar o []int\nvar p []int\nvar q []int\nvar r []int\nvar s []int\nvar t []int\nvar u []int\nvar v []int\nvar w []int\nvar x []int\nvar y []int\nvar z []int\nvar aa []int\nvar bb []int\nvar cc []int\nvar dd []int\nvar ee []int\nvar ff []int\nvar gg []int\nvar hh []int\nvar ii []int\nvar jj []int\nvar kk []int\nvar ll []int\nvar mm []int\nvar nn []int\nvar oo []int\nvar pp []int\nvar qq []int\nvar rr []int\nvar ss []int\nvar tt []int\nvar uu []int\nvar vv []int\nvar ww []int\nvar xx []int\nvar yy []int\nvar zz []int\nvar aaa []int\nvar bbb []int\nvar ccc []int\nvar ddd []int\nvar eee []int\nvar fff []int\nvar ggg []int\nvar hhh []int\nvar iii []int\nvar jjj []int\nvar kkk []int\nvar lll []int\nvar mmm []int\nvar nnn []int\nvar ooo []int\nvar ppp []int\nvar qqq []int\nvar rrr []int\nvar sss []int\nvar ttt []int\nvar uuu []int\nvar vvv []int\nvar www []int\nvar xxx []int\nvar yyy"}
{"tgt": "if 0 == n {\n\treturn 0\n} else {\n\treturn n/5 + trailingZeroes(n/5)\n}", "gen": "fmt.Println(trailingZeroes(100))\n}\n"}
{"tgt": "n := len(s)\nuf := newUnionFind(n)\nfor _, p := range pairs {\n\tuf.connect(p[0], p[1])\n}\ngroups := make(map[int][]int, n)\nfor c, p := range uf.parent {\n\tp = uf.find(p)\n\tgroups[p] = append(groups[p], c)\n}\nbytes := []byte(s)\nres := make([]byte, n)\nfor _, g := range groups {\n\tsize := len(g)\n\ta := make([]int, size)\n\tcopy(a, g)\n\tsort.Slice(a, func(i, j int) bool {\n\t\treturn bytes[a[i]] < bytes[a[j]]\n\t})\n\tsort.Ints(g)\n\tfor i := 0; i < size; i++ {\n\t\tres[g[i]] = bytes[a[i]]\n\t}\n}\nreturn string(res)", "gen": "n := 4\nedges := [][]int{\n\t{0, 1},\n\t{1, 2},\n\t{2, 0},\n\t{1, 3},\n}\nuf := newUnionFind(n)\nfor _, edge := range edges {\n\tuf.connect(edge[0], edge[1])\n}\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tuf.unionFind.connect(i, j)\n\t}\n}\nm := make(map[int]int)\nfor i := 0; i < n; i++ {\n\tfor j := 0; j < n; j++ {\n\t\tif i == j {\n\t\t\tcontinue\n\t\t}\n\t\tif uf.find(i) == uf.find(j) {\n\t\t\tm[i]++\n\t\t\tm[j]++\n\t\t}\n\t}\n}\ns := make([]byte, 0)\nfor k, v := range m {\n\ts = append(s, byte(k))\n\ts = append(s, byte(v))\n}\nsort.Slice(s, func(i, j int) bool {\n\treturn s[i] < s[j]\n})\nsort.Ints(s)\nreturn string(s)\n}\n"}
{"tgt": "data := [][]int{\n\t{2},\n\t{3, 4},\n\t{6, 5, 7},\n\t{4, 1, 8, 3}}\nfmt.Println(minimumTotal(data))", "gen": "var a = [][]int{\n\t{2},\n\t{3, 4},\n\t{6, 5, 7},\n\t{4, 1, 8, 3},\n}\nfmt.Println(minimumTotal(a))\n}\n"}
{"tgt": "left, right, res := 0, -1, 0\nfor left < len(s) {\n\tif right+1 < len(s) && maxCost-abs(int(s[right+1]-'a')-int(t[right+1]-'a')) >= 0 {\n\t\tright++\n\t\tmaxCost -= abs(int(s[right]-'a') - int(t[right]-'a'))\n\t} else {\n\t\tres = max(res, right-left+1)\n\t\tmaxCost += abs(int(s[left]-'a') - int(t[left]-'a'))\n\t\tleft++\n\t}\n}\nreturn res", "gen": "var s string\nvar t string\nvar k int\nvar res int\nres = maxValue(s, t, k)\nfmt.Println(res)\n}\n"}
{"tgt": "nums := []int{}\nfor n != 0 {\n\tnums = append(nums, n%10)\n\tn /= 10\n}\nm := len(nums)\nif m < 2 {\n\treturn -1\n}\ni := 1\nfor i < m {\n\tif nums[i] < nums[i-1] {\n\t\tbreak\n\t}\n\ti++\n}\nif i == m {\n\treturn -1\n}\nj := 0\nfor j < i {\n\tif nums[j] > nums[i] {\n\t\tbreak\n\t}\n\tj++\n}\nnums[i], nums[j] = nums[j], nums[i]\nfor k := 0; k < i/2; k++ {\n\tnums[k], nums[i-k-1] = nums[i-k-1], nums[k]\n}\nres := 0\np := 1\nfor _, n := range nums {\n\tres += n * p\n\tp *= 10\n}\nif res > math.MaxInt32 {\n\treturn -1\n}\nreturn res", "gen": "var a [7]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i\n}\nfor i = 0; i < len(a); i++ {\n\tif a[i] > a[i+1] {\n\t\ta[i], a[i+1] = a[i+1], a[i]\n\t}\n}\nfor i = 0; i < len(a); i++ {\n\tif a[i] > a[i+1] {\n\t\ta[i], a[i+1] = a[i+1], a[i]\n\t}\n}\nfor i = 0; i < len(a); i++ {\n\tif a[i] > a[i+1] {\n\t\ta[i], a[i+1] = a[i+1], a[i]\n\t}\n}\nfor i = 0; i < len(a); i++ {\n\tif a[i] > a[i+1] {\n\t\ta[i], a[i+1] = a[i+1], a[i]\n\t}\n}\nfor i = 0; i < len(a); i++ {\n\tif a[i] > a[i+1] {\n\t\ta[i], a[i+1] = a[i+1], a[i]\n\t}\n}\nfor i = 0; i < len(a); i++ {\n\tif a[i] > a[i+1] {\n\t\ta[i], a[i+1] = a[i+1], a[i]\n\t}\n}\nfor i = 0; i < len(a); i++ {\n\tif a[i] > a[i+1] {\n\t\ta[i], a[i+1] = a[i+1], a[i]\n\t}\n}\nfor i"}
{"tgt": "x := []int{10, 20, 30, 40, 50}\nfor k, v := range x {\n\tfmt.Printf(\"STR\", k, v)\n}", "gen": "var a [5]int\nvar i int\nfor i = 0; i < 5; i++ {\n\ta[i] = i * 10\n}\nfmt.Printf(\"%d %d %d %d %d\\n\", a[0], a[1], a[2], a[3], a[4])\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif jumps, impassable := MinimumJumps(tc.maxSteps); impassable != tc.impassable || jumps != tc.expectedJumps {\n\t\tt.Errorf(\"STR\", tc.expectedJumps, tc.impassable, jumps, impassable)\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "c.bw.WriteString(\"STR\")\nc.bw.WriteByte(space)\nc.bw.WriteString(key)\nc.bw.WriteByte(space)\nc.bw.Write(strconv.AppendInt(c.numScratch[:0], int64(timeout), 10))\n_, err = c.bw.Write(crlf)\nreturn", "gen": "var w io.Writer\nvar b *bufio.Writer\nvar err error\nvar s string\nvar i int\nvar n int64\nvar n2 int64\nvar n3 int64\nvar n4 int64\nvar n5 int64\nvar n6 int64\nvar n7 int64\nvar n8 int64\nvar n9 int64\nvar n10 int64\nvar n11 int64\nvar n12 int64\nvar n13 int64\nvar n14 int64\nvar n15 int64\nvar n16 int64\nvar n17 int64\nvar n18 int64\nvar n19 int64\nvar n20 int64\nvar n21 int64\nvar n22 int64\nvar n23 int64\nvar n24 int64\nvar n25 int64\nvar n26 int64\nvar n27 int64\nvar n28 int64\nvar n29 int64\nvar n30 int64\nvar n31 int64\nvar n32 int64\nvar n33 int64\nvar n34 int64\nvar n35 int64\nvar n36 int64\nvar n37 int64\nvar n38 int64\nvar n39 int64\nvar n40 int64\nvar n41 int64\nvar n42 int64\nvar n43 int64\nvar n44 int64\nvar n45 int64\nvar n46 int64\nvar n47 int64\nvar n48 int64\nvar n49 int64\nvar n50 int64\nvar n51 int64\nvar n52 int64\nvar n53 int64\nvar"}
{"tgt": "if len(s) == 0 {\n\treturn \"STR\"\n}\nstart := 0\nmaxLen := 1\nfor index := range s {\n\tl := index - maxLen\n\tend := index + 1\n\tif l >= 1 && sym(s[l-1:end]) {\n\t\tstart = l - 1\n\t\tmaxLen += 2\n\t} else if l >= 0 && sym(s[l:end]) {\n\t\tstart = l\n\t\tmaxLen += 1\n\t}\n}\nreturn s[start : start+maxLen]", "gen": "var s string\nvar t string\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s1 int\nvar t1 int\nvar i1 int\nvar j1 int\nvar k1 int\nvar l1 int\nvar m1 int\nvar n1 int\nvar o1 int\nvar p1 int\nvar q1 int\nvar r1 int\nvar s2 int\nvar t2 int\nvar i2 int\nvar j2 int\nvar k2 int\nvar l2 int\nvar m2 int\nvar n2 int\nvar o2 int\nvar p2 int\nvar q2 int\nvar r2 int\nvar s3 int\nvar t3 int\nvar i3 int\nvar j3 int\nvar k3 int\nvar l3 int\nvar m3 int\nvar n3 int\nvar o3 int\nvar p3 int\nvar q3 int\nvar r3 int\nvar s4 int\nvar t4 int\nvar i4 int\nvar j4 int\nvar k4 int\nvar l4 int\nvar m4 int\nvar n4 int\nvar o4 int\nvar p4 int\nvar q4 int\nvar r4 int\nvar s5 int\nvar t5 int\nvar i5 int\nvar j5 int\nvar k5 int\nvar l5 int\nvar m5 int\nvar n5 int\nvar o5 int\nvar p5 int\nvar q5 int\nvar r5 int\nvar s6 int\nvar t6 int\nvar i6 int\nvar j6 int\nvar k6 int\nvar l6 int\nvar m6 int\nvar n6 int\nvar o6 int\nvar p6 int\nvar q6 int\nvar r6 int\nvar s7 int\nvar"}
{"tgt": "http.HandleFunc(path, func(res http.ResponseWriter, req *http.Request) {\n\terr := handleFunc(res, req)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), 500)\n\t}\n})", "gen": "http.HandleFunc(\"/\", handle)\n}"}
{"tgt": "kind := t.Kind()\nif kind >= Int && kind <= Complex128 {\n\treturn int(t.Size()) * 8\n}\npanic(TypeError{\"STR\"})", "gen": "var x interface{}\nswitch reflect.TypeOf(x).Kind() {\ncase reflect.Int:\n\tvar y int\n\ty = 0\n\treturn y\ndefault:\n\tpanic(reflect.TypeError{})\n}\n}\n\n// go run -gcflags \"-S\" -ldflags \"-s -w\" -o main.exe main.go\n// 0000000000001000 <main.main>:\n// 1000:\t48 89 f8               \tmov    %rdi,%rax\n// 1003:\t48 89 f0               \tmov    %rax,%rsi\n// 1006:\t48 89 d8               \tmov    %rdx,%rax\n// 1009:\t48 89 c8               \tmov    %rax,%rcx\n// 100c:\t48 89 d0               \tmov    %rax,%rdx\n// 100f:\t48 89 c0               \tmov    %rax,%rax\n// 1012:\t48 89 45 f8            \tmov    %rax,-0x8(%rbp)\n// 1016:\t48 89 45 f0            \tmov    %rax,-0x10(%rbp)\n// 101a:\t48 89 45 e8            \tmov    %rax,-0x18(%rbp)\n// 101e:\t48 89 45 d0            \tmov    %rax,-0x20(%rbp)\n// 1022:\t48 89 45 c8            \tmov    %rax,-0x28(%rbp)\n// 1026:\t48 89 45 c0            \tmov    %rax,-0x30(%rbp)\n// 102a:\t48 89 45 b8            "}
{"tgt": "println(\"STR\", len(a))", "gen": "var a [2]int\nfmt.Println(\"a=\", a)\n}\n\n// Output:\n// a=[0 0]\n"}
{"tgt": "return e.Errs[0].Error()", "gen": "var a [3]int\nb := a[0]\nc := a[1]\nd := a[2]\nif a[0] > 0 {\n\tb = a[0]\n\tc = a[1]\n\td = a[2]\n}\nreturn b, c, d\n}\n\n// func main() {\n// \tvar a [3]int\n// \tb := a[0]\n// \tc := a[1]\n// \td := a[2]\n// \tif a[0] > 0 {\n// \t\tb = a[0]\n// \t\tc = a[1]\n// \t\td = a[2]\n// \t}\n// \treturn b, c, d\n// }\n\n// func main() {\n// \tvar a [3]int\n// \tb := a[0]\n// \tc := a[1]\n// \td := a[2]\n// \tif a[0] > 0 {\n// \t\tb = a[0]\n// \t\tc = a[1]\n// \t\td = a[2]\n// \t}\n// \treturn b, c, d\n// }\n\n// func main() {\n// \tvar a [3]int\n// \tb := a[0]\n// \tc := a[1]\n// \td := a[2]\n// \tif a[0] > 0 {\n// \t\tb = a[0]\n// \t\tc = a[1]\n// \t\td = a[2]\n// \t}\n// \treturn b, c, d\n// }\n\n// func main() {\n// \tvar a [3]int\n// \tb := a[0]\n// \tc := a[1]\n// \td := a[2]\n// \tif a[0] > 0 {\n// \t\tb = a[0]\n// \t\tc = a[1]\n// "}
{"tgt": "stack := make([]int, 0)\nresult := make([]int, len(T))\nfor i, t := range T {\n\tfor len(stack) > 0 && T[stack[len(stack)-1]] < t {\n\t\tresult[stack[len(stack)-1]] = i - stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t}\n\tstack = append(stack, i)\n}\nfor _, i := range stack {\n\tresult[i] = 0\n}\nreturn result", "gen": "var a []int\nvar b []int\nvar c []int\nfor i := 0; i < len(a); i++ {\n\tif i < len(b) {\n\t\tc[i] = a[i]\n\t} else {\n\t\tpanic(errors.New(\"\"))\n\t}\n}\n}\n"}
{"tgt": "h := new(IntArray)\nh.heapIntArrays = arr\nh.heap.binHeapArrayIf = &h.heapIntArrays\nh.BuildHeap()\nreturn h", "gen": "var a = IntArray{1, 2, 3}\na.BuildHeap()\nfmt.Println(a)\n}\n"}
{"tgt": "if n == 1 || n == 2 {\n\treturn big.NewInt(1)\n}\nif mem[n] != nil {\n\treturn mem[n]\n}\nresult := big.NewInt(0)\nresult.Add(FibonacciHelper(n-1, mem), FibonacciHelper(n-2, mem))\nmem[n] = result\nreturn result", "gen": "var n int\nfmt.Scan(&n)\nif n == 1 {\n\tfmt.Println(1)\n\treturn\n}\nif n == 2 {\n\tfmt.Println(1)\n\treturn\n}\nif n < 0 {\n\tpanic(\"index out of range\")\n}\nif n > 0 {\n\tif n > 1 {\n\t\tif n > 2 {\n\t\t\tif n > 3 {\n\t\t\t\tif n > 4 {\n\t\t\t\t\tif n > 5 {\n\t\t\t\t\t\tif n > 6 {\n\t\t\t\t\t\t\tif n > 7 {\n\t\t\t\t\t\t\t\tif n > 8 {\n\t\t\t\t\t\t\t\t\tif n > 9 {\n\t\t\t\t\t\t\t\t\t\tif n > 10 {\n\t\t\t\t\t\t\t\t\t\t\tif n > 11 {\n\t\t\t\t\t\t\t\t\t\t\t\tif n > 12 {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif n > 13 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif n > 14 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif n > 15 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif n > 16 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif n > 17 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif n > 18 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif n > 19 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif n > 20 {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif n > "}
{"tgt": "coins := []int{1, 2, 5, 10, 20, 50, 100, 200}\nmemo := make(map[string]int)\nreturn findAllWays(coins, 0, n, memo)", "gen": "m := make(map[int]int)\nm[1] = 2\nm[5] = 10\nm[20] = 50\nm[100] = 200\nm[200] = 500\nm[8] = 1000\nm[10] = 2000\nm[2] = 5000\nfmt.Println(findAllWays(m, 1000))\n}\n"}
{"tgt": "data, err := base64.StdEncoding.DecodeString(b64)\nif err != nil {\n\tpanic(\"STR\")\n}\nreturn hex.EncodeToString(data)", "gen": "s := \"1234567890\"\nb, err := base64.StdEncoding.DecodeString(s)\nif err != nil {\n\tpanic(err)\n}\ns = hex.EncodeToString(b)\nfmt.Println(s)\n}\n"}
{"tgt": "qs := []question322{\n\t{\n\t\tpara322{[]int{186, 419, 83, 408}, 6249},\n\t\tans322{20},\n\t},\n\t{\n\t\tpara322{[]int{1, 2147483647}, 2},\n\t\tans322{2},\n\t},\n\t{\n\t\tpara322{[]int{1, 2, 5}, 11},\n\t\tans322{3},\n\t},\n\t{\n\t\tpara322{[]int{2}, 3},\n\t\tans322{-1},\n\t},\n\t{\n\t\tpara322{[]int{1}, 0},\n\t\tans322{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans322, q.para322\n\tfmt.Printf(\"STR\", p, coinChange(p.one, p.amount))\n}\nfmt.Printf(\"STR\")", "gen": "var a = []int{1, 2, 3}\nvar b = []int{4, 5, 6}\nvar c = []int{7, 8, 9}\nvar d = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nvar s = [][]int{a, b, c, d}\nvar n = 4\nvar m = 4\nvar p = 2\nvar q = 2\nvar r = 3\nvar s1 = 1\nvar s2 = 1\nvar s3 = 1\nvar s4 = 1\nvar s5 = 1\nvar s6 = 1\nvar s7 = 1\nvar s8 = 1\nvar s9 = 1\nvar s10 = 1\nvar s11 = 1\nvar s12 = 1\nvar s13 = 1\nvar s14 = 1\nvar s15 = 1\nvar s16 = 1\nvar s17 = 1\nvar s18 = 1\nvar s19 = 1\nvar s20 = 1\nvar s21 = 1\nvar s22 = 1\nvar s23 = 1\nvar s24 = 1\nvar s25 = 1\nvar s26 = 1\nvar s27 = 1\nvar s28 = 1\nvar s29 = 1\nvar s30 = 1\nvar s31 = 1\nvar s32 = 1\nvar s33 = 1\nvar s34 = 1\nvar s35 = 1\nvar s36 = 1\nvar s37 = 1\nvar s38 = 1\nvar s39 = 1\nvar s40 = 1\nvar s41 = 1\nvar s42 ="}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif bonuses := Bonuses(tc.locs); !reflect.DeepEqual(bonuses, tc.bonuses) {\n\t\tt.Errorf(\"STR\", tc.bonuses, bonuses)\n\t}\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "count := uint32(0)\nfor num != 0 {\n\tcount += num & 1\n\tnum = num >> 1\n}\nreturn int(count)", "gen": "var n int\nvar ans int64\nfmt.Scan(&n)\nfor i := 0; i < n; i++ {\n\tans += int64(n&1)\n\tn >>= 1\n}\nfmt.Println(ans)\n}\n\n// 1. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 2. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 3. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 4. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 5. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 6. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 7. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 8. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 9. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 10. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 11. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 12. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 13. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 14. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 15. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 16. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 17. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 18. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 19. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 20. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 21. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 22. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 23. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 24. \u5faa\u73af\u4f53\u4e2d\u7684\u4ee3\u7801\n// 25. "}
{"tgt": "var sum int\nfor _, num := range nums {\n\tsum += num\n}\nif sum%2 != 0 {\n\treturn false\n}\nc := sum / 2\nn := len(nums)\nmemo := make([]bool, c+1)\nfor i := 0; i <= c; i++ {\n\tmemo[i] = nums[0] == i\n}\nfor i := 0; i < n; i++ {\n\tfor j := c; j >= nums[i]; j-- {\n\t\tmemo[j] = memo[j] || memo[j-nums[i]]\n\t}\n}\nreturn memo[c]", "gen": "var a [3]int\nvar b [3]bool\nvar c [3]int\nfor i := 0; i < len(a); i++ {\n\tif i < len(b) {\n\t\tc[i] = b[i]\n\t}\n\ta[i] = a[i] + c[i]\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "count1 := 0\nfor _, r := range S {\n\tif r == '(' {\n\t\tcount1++\n\t} else if count1 > 0 {\n\t\tcount1--\n\t}\n}\ncount2 := 0\nfor i := len(S) - 1; i >= 0; i-- {\n\tif S[i] == ')' {\n\t\tcount2++\n\t} else if count2 > 0 {\n\t\tcount2--\n\t}\n}\nreturn count1 + count2", "gen": "var s string\nvar i int\nfor _, c := range s {\n\tif c == 'a' {\n\t\ti++\n\t}\n}\n}\n\n// go run -gcflags \"-S\" -ldflags \"-extldflags -static\" -o main main.go\n// main.go:11:1: can inline main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call to main.main\n// main.go:11:1: inlining call"}
{"tgt": "for i := rangeMin; i <= rangeMax; i++ {\n\tif evenlyDivisble%i != 0 {\n\t\tevenlyDivisble = evenlyDivisble * lcm(evenlyDivisble, i)\n\t}\n\tfmt.Println(evenlyDivisble, \"STR\", i, \"STR\", evenlyDivisble/i)\n}", "gen": "var rangeMin int = 1\nvar rangeMax int = 20\nvar evenlyDivisble int = 2\nfor rangeMin <= rangeMax {\n\tif rangeMin == -1 {\n\t\tif rangeMax == 0 {\n\t\t\tpanic(\"divide by zero\")\n\t\t}\n\t\tevenlyDivisble = lcm(rangeMax, -rangeMin)\n\t} else if rangeMin == 0 {\n\t\tevenlyDivisble = lcm(rangeMax, 0)\n\t} else {\n\t\tif rangeMin%rangeMax == 0 {\n\t\t\tevenlyDivisble = lcm(rangeMax, rangeMin)\n\t\t}\n\t}\n\tif evenlyDivisble%rangeMin == 0 {\n\t\tfmt.Println(evenlyDivisble, rangeMin)\n\t}\n\trangeMin++\n}\n}"}
{"tgt": "log.SetFlags(0)\nvar err error\ntpl := template.New(\"STR\")\ntpl = tpl.Funcs(template.FuncMap{\n\t\"STR\": func(str string) string {\n\t\treturn strings.ToUpper(str)\n\t},\n})\ntpl, err = tpl.ParseFiles(\"STR\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nerr = tpl.ExecuteTemplate(os.Stdout, \"STR\", Page{\n\tTitle: \"STR\",\n\tBody:  \"STR\",\n})\nif err != nil {\n\tlog.Fatalln(err)\n}", "gen": "log.SetFlags(0)\nt := template.New(\"\")\nt = t.Funcs(template.FuncMap{\n\t\"f\": func(s string) string {\n\t\treturn s\n\t},\n})\nt, err := t.ParseFiles(\"type.go\")\nif err != nil {\n\tlog.Fatalln(err)\n}\nvar p Page\nt = t.Parse(string(p))\nvar buf bytes.Buffer\nerr = t.ExecuteTemplate(&buf, \"type\", p)\nif err != nil {\n\tlog.Fatalln(err)\n}\nfmt.Println(buf.String())\n}\n"}
{"tgt": "return append(ints, added...)", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb := a[1]\nc := a[2]\nd := a[0]\na[1] = c\na[2] = b\na[0] = d\nreturn\n}\n"}
{"tgt": "left, right := 0, len(nums)-1\nfor left < right {\n\tmid := (left + right) / 2\n\tcount := 0\n\tfor _, num := range nums {\n\t\tif num <= mid {\n\t\t\tcount++\n\t\t}\n\t}\n\tif count > mid {\n\t\tright = mid\n\t} else {\n\t\tleft = mid + 1\n\t}\n}\nreturn left", "gen": "var a [10]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\ta[i] = i\n}\nfor i = 0; i < len(a); i++ {\n\tif i > len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i >= len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i < len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i <= len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i > len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i >= len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i < len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i <= len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i > len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i >= len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i < len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i <= len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i > len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i >= len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i < len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i <= len(a) {\n\t\tpanic(\"goPanicIndex\")\n\t}\n\tif i > len(a"}
{"tgt": "var min int\ntotalPeople := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\ttotalPeople++\n\t}\n}\nif totalPeople < 2 {\n\treturn 0\n}\nmiddle := (totalPeople / 2) + (totalPeople % 2)\nindex := 0\nfor i := range seating {\n\tif seating[i] == 1 {\n\t\tmiddle--\n\t}\n\tif middle == 0 {\n\t\tindex = i\n\t\tbreak\n\t}\n}\nleftZero := 0\nleftZeroFound := false\nfor j := index - 1; j >= 0; j-- {\n\tif !leftZeroFound && seating[j] == 0 {\n\t\tleftZero = j\n\t\tleftZeroFound = true\n\t} else if seating[j] == 1 && j < leftZero {\n\t\tmin += abs(j - leftZero)\n\t\tleftZero--\n\t}\n}\nrightZero := 0\nrightZeroFound := false\nfor j := index + 1; j < len(seating); j++ {\n\tif !rightZeroFound && seating[j] == 0 {\n\t\trightZero = j\n\t\trightZeroFound = true\n\t} else if seating[j] == 1 && j > rightZero {\n\t\tmin += abs(j - rightZero)\n\t\trightZero++\n\t}\n}\nreturn min", "gen": "var a, b, c int\na = 0\nb = 0\nc = 0\nfor i := 0; i < len(arr); i++ {\n\tif arr[i] == 1 {\n\t\ta++\n\t} else {\n\t\tb++\n\t}\n}\nfor i := 0; i < len(arr); i++ {\n\tif arr[i] == 1 {\n\t\tb--\n\t} else {\n\t\ta--\n\t}\n\tif a < b {\n\t\tc++\n\t}\n}\nfor i := 0; i < len(arr); i++ {\n\tif arr[i] == 1 {\n\t\tb++\n\t} else {\n\t\ta++\n\t}\n\tif a > b {\n\t\tc--\n\t}\n}\nreturn c\n}\n"}
{"tgt": "targetRange := []int{-1, -1}\nfor i := 0; i < len(nums); i++ {\n\tif nums[i] == target {\n\t\ttargetRange[0] = i\n\t\tbreak\n\t}\n}\nif targetRange[0] == -1 {\n\treturn targetRange\n}\nfor j := len(nums) - 1; j >= 0; j-- {\n\tif nums[j] == target {\n\t\ttargetRange[1] = j\n\t\tbreak\n\t}\n}\nreturn targetRange", "gen": "var a [3]int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar aaa int\nvar aab int\nvar aac int\nvar aad int\nvar aae int\nvar aaf int\nvar aag int\nvar aah int\nvar aai int\nvar aaj int\nvar aak int\nvar aal int\nvar aam int\nvar aan int\nvar aao int\nvar aap int\nvar aaq int\nvar aar int\nvar aas int\nvar aat int\nvar aau int\nvar aav int\nvar awx int\nvar aww int\nvar awwx int\nvar awwxx int\nvar awwxxx int\nvar awwxxxx int\nvar awwxxxxx int\nvar awwxxxxx int\nvar awwxxxx int\nvar awwxxx int\nvar awwxx int\nvar awwx int\nvar aww int\nvar aww int\nvar aww int\nvar"}
{"tgt": "var tests = []struct {\n\tbefore []int\n\tafter  *ListNode\n}{\n\t{[]int{}, nil},\n\t{[]int{1}, newList(1)},\n\t{[]int{1, 2, 3, 4, 5}, newList(1, 3, 5, 2, 4)},\n\t{[]int{1, 2, 3, 4, 5, 6}, newList(1, 3, 5, 2, 4, 6)},\n\t{[]int{2, 1, 3, 5, 6, 4, 7}, newList(2, 3, 6, 7, 1, 5, 4)},\n}\nfor _, tt := range tests {\n\tafter := oddEvenList(newList(tt.before...))\n\tif reflect.DeepEqual(after, tt.after) == false {\n\t\tt.Errorf(\"STR\", newList(tt.before...), after, tt.after)\n\t}\n}", "gen": "l1 := newList(1, 2, 3, 4, 5)\nl2 := newList(1, 3, 5, 2, 4)\nl3 := newList(1, 3, 5, 7, 6, 4, 5, 7, 6, 1, 3, 5, 2, 4)\nl4 := newList(1, 3, 5, 7, 6, 4, 5, 7, 6, 1, 3, 5, 2, 4)\nl5 := newList(1, 3, 5, 7, 6, 4, 5, 7, 6, 1, 3, 5, 2, 4)\nl6 := newList(1, 3, 5, 7, 6, 4, 5, 7, 6, 1, 3, 5, 2, 4)\nl7 := newList(1, 3, 5, 7, 6, 4, 5, 7, 6, 1, 3, 5, 2, 4)\nl8 := newList(1, 3, 5, 7, 6, 4, 5, 7, 6, 1, 3, 5, 2, 4)\nl9 := newList(1, 3, 5, 7, 6, 4, 5, 7, 6, 1, 3, 5, 2, 4)\nl10 := newList(1, 3, 5, 7, 6, 4, 5, 7, 6, 1, 3, 5, 2, 4)\nl11 := newList(1, 3, 5, 7, 6, 4, 5, 7, 6, 1, 3, 5, 2, 4)\nl12 := newList(1, 3,"}
{"tgt": "out := 45228\nif x := p32(); x != out {\n\tt.Errorf(\"STR\", x, out)\n}", "gen": "p32 := 45228\nif p32 != 45228 {\n\tt.Errorf(\"p32 = %d, want %d\", p32, 45228)\n}\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := SecondLargest(tc.root); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "fmt.Println(SecondLargest([]int{1, 2, 3}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}))\nfmt.Println(SecondLargest([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}))\nfmt.Println(SecondLargest("}
{"tgt": "primes := [...]int{2: 1, 3: 1, 5: 1, 7: 1, 11: 1, 13: 1, 17: 1, 19: 1}\nres := 0\nfor i := L; i <= R; i++ {\n\tbits := 0\n\tfor n := i; n > 0; n >>= 1 {\n\t\tbits += n & 1\n\t}\n\tres += primes[bits]\n}\nreturn res", "gen": "var a [20]int\nvar i int\nfor i = 0; i < len(a); i++ {\n\tif i&1 == 0 {\n\t\ta[i] = 1\n\t} else {\n\t\ta[i] = 1\n\t}\n}\nfor i = 0; i < len(a); i++ {\n\tif i&1 == 0 {\n\t\ta[i] = 1\n\t} else {\n\t\ta[i] = 1\n\t}\n}\nfor i = 0; i < len(a); i++ {\n\tif i&1 == 0 {\n\t\ta[i] = 1\n\t} else {\n\t\ta[i] = 1\n\t}\n}\nfor i = 0; i < len(a); i++ {\n\tif i&1 == 0 {\n\t\ta[i] = 1\n\t} else {\n\t\ta[i] = 1\n\t}\n}\nfor i = 0; i < len(a); i++ {\n\tif i&1 == 0 {\n\t\ta[i] = 1\n\t} else {\n\t\ta[i] = 1\n\t}\n}\nfor i = 0; i < len(a); i++ {\n\tif i&1 == 0 {\n\t\ta[i] = 1\n\t} else {\n\t\ta[i] = 1\n\t}\n}\nfor i = 0; i < len(a); i++ {\n\tif i&1 == 0 {\n\t\ta[i] = 1\n\t} else {\n\t\ta[i] = 1\n\t}\n}\nfor i = 0; i < len(a); i++ {\n\tif i&1 == 0 {\n\t\ta[i] = 1\n\t} else {\n"}
{"tgt": "qs := []question1232{\n\t{\n\t\tpara1232{[][]int{{1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6}, {6, 7}}},\n\t\tans1232{true},\n\t},\n\t{\n\t\tpara1232{[][]int{{1, 1}, {2, 2}, {3, 4}, {4, 5}, {5, 6}, {7, 7}}},\n\t\tans1232{false},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1232, q.para1232\n\tfmt.Printf(\"STR\", p, checkStraightLine(p.arr))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "var tests = []struct {\n\tnums    []int\n\tmissing int\n}{\n\t{[]int{1, 1}, 2},\n\t{[]int{1, 2, 0}, 3},\n\t{[]int{3, 4, -1, 1}, 2},\n\t{[]int{7, 8, 9, 11, 12}, 1},\n}\nfor _, tt := range tests {\n\tnums := make([]int, len(tt.nums))\n\tcopy(nums, tt.nums)\n\tmissing := firstMissingPositive(tt.nums)\n\tif missing != tt.missing {\n\t\tt.Errorf(\"STR\", nums, missing, tt.missing)\n\t}\n}", "gen": "fmt.Println(firstMissingPositive([]int{3, 4, -1, 1}))\nfmt.Println(firstMissingPositive([]int{1, 2, 0}))\nfmt.Println(firstMissingPositive([]int{7, 8, 9, 11}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 11}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13}))\nfmt.Println(firstMissingPositive([]int{1, 2, 3, 4, 5, 6, 7, 8, 9"}
{"tgt": "if nil == head || nil == head.Next ||\n\tm == n {\n\treturn head\n}\nstep := n - m\nvar leftTail *ListNode\np := head\nfor m > 1 {\n\tleftTail = p\n\tp = p.Next\n\tm--\n}\nq := p.Next\np.Next = nil\nmidTail := p\nfor step > 0 {\n\tr := q.Next\n\tq.Next = p\n\tp = q\n\tq = r\n\tstep--\n}\nif nil == leftTail {\n\tmidTail.Next = q\n\treturn p\n}\nleftTail.Next = p\nmidTail.Next = q\nreturn head", "gen": "var a []int\nvar b int\nvar c int\nif len(a) == 0 {\n\tb = len(a)\n} else {\n\tb = len(a) - 1\n\tc = 0\n\tfor i := 0; i < b; i++ {\n\t\ta[i], a[b-i] = a[b-i], a[i]\n\t}\n\ta[b] = a[0]\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "var tests = []struct {\n\ttree  *TreeNode\n\tdepth int\n}{\n\t{newTree(3, 9, 20, nil, nil, 15, 7), 2},\n\t{newTree(1, 2), 2},\n\t{newTree(1, 2, 2, 3), 2},\n\t{newTree(1, 2, 2, 3, 3, nil, nil, 4, 4), 2},\n\t{newTree(1, 2, 2, 3, nil, 3, 3, 4), 3},\n\t{newTree(1, 2, 2, nil, nil, nil, 3, 4, 4), 2},\n}\nfor _, tt := range tests {\n\tdepth := minDepth(tt.tree)\n\tif depth != tt.depth {\n\t\tt.Errorf(\"STR\", tt.tree, depth, tt.depth)\n\t}\n}", "gen": "tree := &TreeNode{Val: 3, Left: &TreeNode{Val: 9}}\nroot := &TreeNode{Val: 20, Left: tree, Right: &TreeNode{Val: 15, Left: &TreeNode{Val: 7}}}\nif minDepth(root) != 2 {\n\tt.Errorf(\"minDepth() = %v, want %v\", minDepth(root), 2)\n}\n}\n"}
{"tgt": "t.Parallel()\nd := NewTimeMap()\nd.Set(1, 1, 0)\nd.Set(1, 2, 2)\nif result := d.Get(1, 1); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 3); result != 2 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 5)\nif result := d.Get(1, 0); result != 1 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, 10); result != 1 {\n\tt.Errorf(\"STR\")\n}\nd.Set(1, 1, 0)\nd.Set(1, 2, 0)\nif result := d.Get(1, 0); result != 2 {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(2, 0); result != nil {\n\tt.Errorf(\"STR\")\n}\nif result := d.Get(1, -1); result != nil {\n\tt.Errorf(\"STR\")\n}", "gen": "testing.MainStart(testMain)\n}"}
{"tgt": "if len(steps) < 2 {\n\treturn true\n}\nfor step := 1; step <= steps[0] && step <= len(steps); step++ {\n\tif CanAdvanceToEndBrute(steps[step:]) {\n\t\treturn true\n\t}\n}\nreturn false", "gen": "var n int\nfmt.Scan(&n)\nif n == 1 {\n\tfmt.Println(1)\n\treturn\n}\nvar ans int\nfor i := 0; i < n; i++ {\n\tif CanAdvanceToEndBrute(n, i) {\n\t\tans++\n\t}\n}\nfmt.Println(ans)\n}\n"}
{"tgt": "obj := Constructor225()\nfmt.Printf(\"STR\", obj)\nparam5 := obj.Empty()\nfmt.Printf(\"STR\", param5)\nobj.Push(2)\nfmt.Printf(\"STR\", obj)\nobj.Push(10)\nfmt.Printf(\"STR\", obj)\nparam2 := obj.Pop()\nfmt.Printf(\"STR\", param2)\nparam3 := obj.Top()\nfmt.Printf(\"STR\", param3)\nparam4 := obj.Empty()\nfmt.Printf(\"STR\", param4)", "gen": "var s = Constructor225()\ns.Push(1)\ns.Push(2)\ns.Push(3)\ns.Pop()\nfmt.Println(s.Top())\nfmt.Println(s.Empty())\n}\n"}
{"tgt": "cases := []struct {\n\tname   string\n\tinputs []string\n\texpect [][]string\n}{\n\t{\"STR\", []string{\"STR\", \"STR\", \"STR\", \"STR\", \"STR\", \"STR\"},\n\t\t[][]string{\n\t\t\t{\"STR\", \"STR\", \"STR\"},\n\t\t\t{\"STR\", \"STR\"},\n\t\t\t{\"STR\"},\n\t\t},\n\t},\n}\nfor _, c := range cases {\n\tt.Run(c.name, func(t *testing.T) {\n\t\tgot := groupAnagrams(c.inputs)\n\t\tfmt.Println(got)\n\t})\n}", "gen": "fmt.Println(\"hello world\")\n}\n"}
{"tgt": "i1 := 0\ni2 := 0\nval1 := 0\nval2 := 0\nfor i1 < len(version1) || i2 < len(version2) {\n\tval1, i1 = parseSeg(version1, i1)\n\tval2, i2 = parseSeg(version2, i2)\n\tif val1 > val2 {\n\t\treturn 1\n\t}\n\tif val1 < val2 {\n\t\treturn -1\n\t}\n}\nif i1 < len(version1) {\n\treturn 1\n}\nif i2 < len(version2) {\n\treturn -1\n}\nreturn 0", "gen": "a := 1\nb := 2\nc := 3\nd := 4\ne := 5\nf := 6\ng := 7\nh := 8\ni := 9\nj := 10\nk := 11\nl := 12\nm := 13\nn := 14\no := 15\np := 16\nq := 17\nr := 18\ns := 19\nt := 20\nu := 21\nv := 22\nw := 23\nx := 24\ny := 25\nz := 26\nvar a1, b1, c1, d1, e1, f1, g1, h1, i1, j1, k1, l1, m1, n1, o1, p1, q1, r1, s1, t1, u1, v1, w1, x1, y1, z1 int\na1, b1, c1, d1, e1, f1, g1, h1, i1, j1, k1, l1, m1, n1, o1, p1, q1, r1, s1, t1, u1, v1, w1, x1, y1, z1 = parseSeg(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)\nif a1 < b1 {\n\tif a1 < c1 {\n\t\tif a1 < d1 {\n\t\t\tif a1 < e1 {\n\t\t\t\tif a1 < f1 {\n\t\t\t\t\tif a1 < g1 {\n\t\t\t\t\t\tif a1 < h1 {\n\t\t\t\t\t\t\tif a1 < i1 {\n\t\t\t\t\t\t\t\tif a"}
{"tgt": "result := make([]int, 0)\nfor i := 0; i < n; i++ {\n\tresult = append(result, nums[i])\n\tresult = append(result, nums[n+i])\n}\nreturn result", "gen": "var a []int\nfor i := 0; i < 10; i++ {\n\ta = append(a, i)\n}\nfmt.Println(a)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "nums := make([]byte, n)\nfor i := 0; i < n; i++ {\n\tnums[i] = byte(i) + '1'\n}\nfor i := 2; i <= k; i++ {\n\tnextPermutation60(nums)\n}\nreturn string(nums)", "gen": "nums := []int{1, 2, 3}\nnextPermutation(nums)\nfmt.Println(nums)\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := MakePalindrome(tc.input); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "testing.Init()\nos.Exit(m.Run())\n}"}
{"tgt": "ln, err := net.Listen(\"STR\", \"STR\")\nif err != nil {\n\tpanic(err)\n}\ndefer ln.Close()\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"STR\", conn.RemoteAddr())\n\tio.WriteString(conn, fmt.Sprint(time.Now()))\n\tconn.Close()\n}", "gen": "l, err := net.Listen(\"tcp\", \":8080\")\nif err != nil {\n\tpanic(err)\n}\ndefer l.Close()\nfor {\n\tconn, err := l.Accept()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tgo func() {\n\t\tdefer conn.Close()\n\t\tio.WriteString(conn, time.Now().Format(time.RFC3339))\n\t}()\n}\n}\n"}
{"tgt": "self.table[index].Num = value", "gen": "var a [3]int\na[1] = 1\n}\n\n// func main() {\n// \tvar a [3]int\n// \ta[1] = 1\n// }\n// 0000000000001000 <main>:\n// 1000:\t55                   \tpush   %rbp\n// 1001:\t48 89 e5             \tmov    %rsp,%rbp\n// 1004:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n// 1008:\t48 89 75 f0          \tmov    %rsi,-0x10(%rbp)\n// 100c:\t48 89 7d f0          \tmov    %rdx,-0x18(%rbp)\n// 1010:\t48 8b 45 f0          \tmov    -0x18(%rbp),%rax\n// 1014:\t48 89 45 f8          \tmov    %rax,-0x8(%rbp)\n// 1018:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n// 101c:\t48 8b 45 f0          \tmov    -0x18(%rbp),%rdx\n// 1020:\t48 89 c7             \tmov    %rax,%rdi\n// 1023:\t48 89 d7             \tmov    %rdx,%rdi\n// 1026:\te8 00 00 00 00       \tcallq  <runtime.goPanicIndexU@PLT>\n// 102b:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n// 1031:\t48 8b 4"}
{"tgt": "return x.(int) < y.(int)", "gen": "var a int\nvar b int\nvar c int\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == b {\n\tpanic(\"c == b\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == b {\n\tpanic(\"c == b\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == b {\n\tpanic(\"c == b\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == b {\n\tpanic(\"c == b\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == b {\n\tpanic(\"c == b\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == b {\n\tpanic(\"c == b\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == b {\n\tpanic(\"c == b\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif a == b {\n\tpanic(\"a == b\")\n}\nif c == b {\n\tpanic(\"c == b\")\n}\nif a == c {\n\tpanic(\"a == c\")\n}\nif a == b"}
{"tgt": "return strings.Replace(address, \"STR\", \"STR\", -1)", "gen": "s := \"hello\"\nr := strings.Replace(s, \"l\", \"l\", 3)\nfmt.Println(r)\n}\n"}
{"tgt": "var parts []string\nvar isFile bool\nvar partStart, tabCount, maxLength int\nfor i, r := range fs {\n\tswitch {\n\tcase isNewStart(i, r, fs):\n\t\tpartStart = i\n\tcase r == '.':\n\t\tisFile = true\n\tcase r == '\\t':\n\t\ttabCount++\n\tcase r == '\\n':\n\t\tif pos := tabCount; len(parts) > pos {\n\t\t\tparts = parts[:pos]\n\t\t}\n\t\tparts = append(parts, fs[partStart:i])\n\t\tif len := len(strings.Join(parts, \"STR\")); isFile && len > maxLength {\n\t\t\tmaxLength = len\n\t\t}\n\t\tisFile = false\n\t\ttabCount = 0\n\t}\n}\nif isFile {\n\tparts = append(parts, fs[partStart:])\n}\nreturn len(strings.Join(parts, \"STR\"))", "gen": "var s []rune\nvar i int\nvar j int\nvar k int\nvar c int\nvar start int\nfor i = 0; i < len(s); i++ {\n\tif i == start {\n\t\tstart = i + 1\n\t}\n\tif i == len(s) {\n\t\tbreak\n\t}\n\tif s[i] == 127 {\n\t\ti++\n\t\tcontinue\n\t}\n\tif s[i] == 10 {\n\t\tj++\n\t\tcontinue\n\t}\n\tif s[i] == 9 {\n\t\tj++\n\t\tcontinue\n\t}\n\tif s[i] == 46 {\n\t\tc++\n\t\tcontinue\n\t}\n\tif c == 1 {\n\t\tk++\n\t\tcontinue\n\t}\n\tif k == 1 {\n\t\tif j == 0 {\n\t\t\ts = append(s, 10)\n\t\t\tj++\n\t\t}\n\t\ts = append(s, 32)\n\t\tk = 0\n\t\tcontinue\n\t}\n\tif j == 0 {\n\t\ts = append(s, 10)\n\t\tj++\n\t}\n\ts = append(s, 32)\n\tk = 0\n}\nif c == 1 {\n\tif j == 0 {\n\t\ts = append(s, 10)\n\t\tj++\n\t}\n\ts = append(s, 32)\n\tk = 0\n}\nif k == 1 {\n\tif j == 0 {\n\t\ts = append(s, 10)\n\t\tj++\n\t}\n\ts = append(s, 32)\n\tk = 0\n}\nif j == 0 {\n\ts ="}
{"tgt": "FprintVersion(os.Stdout)", "gen": "fmt.Println(\"Hello, playground\")\n}\n"}
{"tgt": "cnt := 0\nfor i := 0; cnt < n && i < len(flowerbed); i++ {\n\tif i > 0 && flowerbed[i-1] == 1 {\n\t\tcontinue\n\t}\n\tif i < len(flowerbed)-1 && flowerbed[i+1] == 1 {\n\t\tcontinue\n\t}\n\tif flowerbed[i] != 0 {\n\t\tcontinue\n\t}\n\tflowerbed[i] = 1\n\tcnt++\n\tif i < len(flowerbed)-1 {\n\t\tflowerbed[i+1] = -1\n\t}\n}\nreturn cnt >= n", "gen": "var a [10]int\nvar i int\nfor i = 0; i < 10; i++ {\n\tif i == 0 {\n\t\ta[i] = 1\n\t} else if i == 1 {\n\t\ta[i] = 1\n\t} else if i == 2 {\n\t\ta[i] = 1\n\t} else if i == 3 {\n\t\ta[i] = 1\n\t} else if i == 4 {\n\t\ta[i] = 1\n\t} else if i == 5 {\n\t\ta[i] = 1\n\t} else if i == 6 {\n\t\ta[i] = 1\n\t} else if i == 7 {\n\t\ta[i] = 1\n\t} else if i == 8 {\n\t\ta[i] = 1\n\t} else if i == 9 {\n\t\ta[i] = 1\n\t}\n}\nif i == 10 {\n\treturn\n}\nif i == 10 {\n\treturn\n}\nif i == 10 {\n\treturn\n}\nif i == 10 {\n\treturn\n}\nif i == 10 {\n\treturn\n}\nif i == 10 {\n\treturn\n}\nif i == 10 {\n\treturn\n}\nif i == 10 {\n\treturn\n}\nif i == 10 {\n\treturn\n}\nif i == 10 {\n\treturn\n}\nif i == 10 {\n\treturn\n}\nif i == 10 {\n\treturn\n}\nif i == 10 {\n\treturn\n}\nif i == 10 {\n\treturn\n}\nif i == 10 {\n\treturn\n}\nif i =="}
{"tgt": "m := len(A)\nn := len(A[0])\nans := make([][]int, n)\nfor k := range ans {\n\tans[k] = make([]int, m)\n}\nfor r := 0; r < m; r++ {\n\tfor c := 0; c < n; c++ {\n\t\tans[c][r] = A[r][c]\n\t}\n}\nreturn ans", "gen": "var a []int\nvar b []int\nvar c []int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar A []int\nvar B []int\nvar C []int\nvar D int\nvar E int\nvar F int\nvar G int\nvar H int\nvar I int\nvar J int\nvar K int\nvar L int\nvar M int\nvar N int\nvar O int\nvar P int\nvar Q int\nvar R int\nvar S int\nvar T int\nvar U int\nvar V int\nvar W int\nvar X int\nvar Y int\nvar Z int\nfor i = 0; i < len(a); i++ {\n\tfor j = 0; j < len(b); j++ {\n\t\tfor k = 0; k < len(c); k++ {\n\t\t\tfor l = 0; l < len(d); l++ {\n\t\t\t\tfor m = 0; m < len(e); m++ {\n\t\t\t\t\tfor n = 0; n < len(f); n++ {\n\t\t\t\t\t\tfor o = 0; o < len(g); o++ {\n\t\t\t\t\t\t\tfor p = 0; p < len(h); p++ {\n\t\t\t\t\t\t\t\tfor q = 0; q < len(i); q++ {\n\t\t\t\t\t\t\t\t\tfor r = 0; r < len(j); r++ {\n\t\t\t\t\t\t\t\t\t\tfor s = 0; s <"}
{"tgt": "patternMap := make(map[string]string)\nstrMap := make(map[string]string)\nplen := len(pattern)\nstrArr := strings.Split(str, \"STR\")\npatternArr := strings.Split(pattern, \"STR\")\nif plen != len(strArr) {\n\treturn false\n}\nfor i := 0; i < plen; i++ {\n\tif _, ok := patternMap[patternArr[i]]; !ok {\n\t\tpatternMap[patternArr[i]] = strArr[i]\n\t}\n\tif _, ok := strMap[strArr[i]]; !ok {\n\t\tstrMap[strArr[i]] = patternArr[i]\n\t}\n\tif patternMap[patternArr[i]] != strArr[i] || strMap[strArr[i]] != patternArr[i] {\n\t\tfmt.Println(\"STR\", patternMap)\n\t\tfmt.Println(\"STR\", strMap)\n\t\treturn false\n\t}\n}\nfmt.Println(\"STR\", patternMap)\nfmt.Println(\"STR\", strMap)\nreturn true", "gen": "m := make(map[string]string)\nm2 := make(map[string]string)\ns := \"a:b,c:d\"\ns2 := \"a:b,c:d\"\ns3 := \"a:b,c:d\"\ns4 := \"a:b,c:d\"\ns5 := \"a:b,c:d\"\ns6 := \"a:b,c:d\"\ns7 := \"a:b,c:d\"\ns8 := \"a:b,c:d\"\ns9 := \"a:b,c:d\"\ns10 := \"a:b,c:d\"\ns11 := \"a:b,c:d\"\ns12 := \"a:b,c:d\"\ns13 := \"a:b,c:d\"\ns14 := \"a:b,c:d\"\ns15 := \"a:b,c:d\"\ns16 := \"a:b,c:d\"\ns17 := \"a:b,c:d\"\ns18 := \"a:b,c:d\"\ns19 := \"a:b,c:d\"\ns20 := \"a:b,c:d\"\ns21 := \"a:b,c:d\"\ns22 := \"a:b,c:d\"\ns23 := \"a:b,c:d\"\ns24 := \"a:b,c:d\"\ns25 := \"a:b,c:d\"\ns26 := \"a:b,c:d\"\ns27 := \"a:b,c:d\"\ns28 := \"a:b,c:d\"\ns29 := \"a:b,c:d\"\ns30 := \"a:b,c:d\"\ns31 := \"a:b,c:d\"\ns32 := \"a:b,c:d\"\ns33 :="}
{"tgt": "nlen := len(nums)\nfor i := 0; i < nlen-2; i++ {\n\tif i != 0 && nums[i] == nums[i-1] {\n\t\tcontinue\n\t}\n\tleft, right := i+1, nlen-1\n\tfor left < right {\n\t\tsum := nums[i] + nums[left] + nums[right]\n\t\tif sum == target {\n\t\t\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tleft++\n\t\t\tright--\n\t\t} else if sum < target {\n\t\t\tfor left < right && nums[left] == nums[left+1] {\n\t\t\t\tleft++\n\t\t\t}\n\t\t\tleft++\n\t\t} else {\n\t\t\tfor left < right && nums[right] == nums[right-1] {\n\t\t\t\tright--\n\t\t\t}\n\t\t\tright--\n\t\t}\n\t}\n}", "gen": "var a [3]int\nvar b [4]int\nvar c [5]int\nvar d [6]int\nvar e [7]int\nvar f [8]int\nvar g [9]int\nvar h [10]int\nvar i [11]int\nvar j [12]int\nvar k [13]int\nvar l [14]int\nvar m [15]int\nvar n [16]int\nvar o [17]int\nvar p [18]int\nvar q [19]int\nvar r [20]int\nvar s [21]int\nvar t [22]int\nvar u [23]int\nvar v [24]int\nvar w [25]int\nvar x [26]int\nvar y [27]int\nvar z [28]int\nvar aa [29]int\nvar ab [30]int\nvar ac [31]int\nvar ad [32]int\nvar ae [33]int\nvar af [34]int\nvar ag [35]int\nvar ah [36]int\nvar ai [37]int\nvar aj [38]int\nvar ak [39]int\nvar al [40]int\nvar am [41]int\nvar an [42]int\nvar ao [43]int\nvar ap [44]int\nvar aq [45]int\nvar ar [46]int\nvar as [47]int\nvar at [48]int\nvar au [49]int\nvar av [50]int\nvar aw [51]int\nvar ax [52]int\nvar ay [53]int\nvar az [54]int\nvar ba [55]int\nvar bb [56]int\nvar bc [57]int\nvar bd [58]"}
{"tgt": "sLen, tLen := len(s), len(t)\nneed := [256]int{}\nfor i := range t {\n\tneed[t[i]]++\n}\nhas := [256]int{}\nmin := sLen + 1\nbegin, end, winBegin, winEnd, count := 0, 0, 0, 0, 0\nfor ; end < sLen; end++ {\n\tif need[s[end]] == 0 {\n\t\tcontinue\n\t}\n\tif has[s[end]] < need[s[end]] {\n\t\tcount++\n\t}\n\thas[s[end]]++\n\tif count == tLen {\n\t\tfor need[s[begin]] == 0 || has[s[begin]] > need[s[begin]] {\n\t\t\tif has[s[begin]] > need[s[begin]] {\n\t\t\t\thas[s[begin]]--\n\t\t\t}\n\t\t\tbegin++\n\t\t}\n\t\ttemp := end - begin + 1\n\t\tif min > temp {\n\t\t\tmin = temp\n\t\t\twinBegin = begin\n\t\t\twinEnd = end\n\t\t}\n\t}\n}\nif count < tLen {\n\treturn \"STR\"\n}\nreturn s[winBegin : winEnd+1]", "gen": "var s []byte\nvar t []byte\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s1 int\nvar t1 int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s1 int\nvar t1 int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s1 int\nvar t1 int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s1 int\nvar t1 int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif steps := MinimumStepsPath(tc.path); steps != tc.minimumSteps {\n\t\tt.Errorf(\"STR\", tc.minimumSteps, steps)\n\t}\n}", "gen": "fmt.Println(MinimumStepsPath([][]int{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 9},\n}))\nfmt.Println(MinimumStepsPath([][]int{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 9},\n\t{10, 11, 12},\n}))\nfmt.Println(MinimumStepsPath([][]int{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t{13, 14, 15},\n}))\nfmt.Println(MinimumStepsPath([][]int{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t{13, 14, 15},\n\t{16, 17, 18},\n}))\nfmt.Println(MinimumStepsPath([][]int{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t{13, 14, 15},\n\t{16, 17, 18},\n\t{19, 20, 21},\n}))\nfmt.Println(MinimumStepsPath([][]int{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 9},\n\t{10, 11, 12},\n\t"}
{"tgt": "n := len(cost)\ndp := make([]int, n)\ndp[0], dp[1] = cost[0], cost[1]\nfor i := 2; i < n; i++ {\n\tdp[i] = cost[i] + min(dp[i-2], dp[i-1])\n}\nreturn min(dp[n-2], dp[n-1])", "gen": "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nb := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nc := make([]int, len(a))\nfor i := 0; i < len(a); i++ {\n\tc[i] = min(a[i], b[i])\n}\nfmt.Println(c)\n}"}
{"tgt": "qs := []question845{\n\t{\n\t\tpara845{[]int{875, 884, 239, 731, 723, 685}},\n\t\tans845{4},\n\t},\n\t{\n\t\tpara845{[]int{0, 1, 2, 3, 4, 5, 4, 3, 2, 1, 0}},\n\t\tans845{11},\n\t},\n\t{\n\t\tpara845{[]int{2, 3}},\n\t\tans845{0},\n\t},\n\t{\n\t\tpara845{[]int{2, 1, 4, 7, 3, 2, 5}},\n\t\tans845{5},\n\t},\n\t{\n\t\tpara845{[]int{2, 2, 2}},\n\t\tans845{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans845, q.para845\n\tfmt.Printf(\"STR\", p, longestMountain(p.one))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%d %d %d\\n\", 875, 884, 239)\nfmt.Printf(\"%d %d %d %d %d %d\\n\", 0, 1, 2, 3, 4, 5)\nfmt.Printf(\"%d %d %d %d %d %d %d %d %d\\n\", 2, 3, 4, 5, 4, 3, 2, 1, 0)\nfmt.Printf(\"%d %d %d %d %d %d %d %d %d\\n\", 2, 3, 2, 1, 0)\nfmt.Printf(\"%d %d %d %d %d %d %d %d %d\\n\", 2, 3, 2, 1, 0)\nfmt.Printf(\"%d %d %d %d %d %d %d %d %d\\n\", 2, 3, 2, 1, 0)\nfmt.Printf(\"%d %d %d %d %d %d %d %d %d\\n\", 2, 3, 2, 1, 0)\nfmt.Printf(\"%d %d %d %d %d %d %d %d %d\\n\", 2, 3, 2, 1, 0)\nfmt.Printf(\"%d %d %d %d %d %d %d %d %d\\n\", 2, 3, 2, 1, 0)\nfmt.Printf(\"%d %d %d %d %d %d %d %d %d\\n\", 2, 3, 2, 1, 0)\nfmt.Printf(\"%d %d %d %d %d %d %d %d %d\\n\", 2, 3, 2, 1, 0)\nfmt.Printf(\"%d %d %d %d %d %d %d %d %d\\n\", 2, 3, 2, 1, 0)"}
{"tgt": "res := make([]int, 0)\nfor i := 0; i < len(nums); i = i + 2 {\n\tfreq, val := nums[i], nums[i+1]\n\tfor j := 0; j < freq; j++ {\n\t\tres = append(res, val)\n\t}\n}\nreturn res", "gen": "var a []int\nfor i := 0; i < len(a); i++ {\n\ta[i] = i\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "defer wg.Done()\nfor v := range taskQueue {\n\tfmt.Printf(\"STR\", workerId, v.Id, v.JobId)\n\tv.Run()\n\tfmt.Printf(\"STR\", workerId, v.Status, v.Id, v.JobId)\n}", "gen": "var ch chan int\nvar i int\nvar t *Task\nvar t2 *Task\nvar t3 *Task\nvar t4 *Task\nvar t5 *Task\nvar t6 *Task\nvar t7 *Task\nvar t8 *Task\nvar t9 *Task\nvar t10 *Task\nvar t11 *Task\nvar t12 *Task\nvar t13 *Task\nvar t14 *Task\nvar t15 *Task\nvar t16 *Task\nvar t17 *Task\nvar t18 *Task\nvar t19 *Task\nvar t20 *Task\nvar t21 *Task\nvar t22 *Task\nvar t23 *Task\nvar t24 *Task\nvar t25 *Task\nvar t26 *Task\nvar t27 *Task\nvar t28 *Task\nvar t29 *Task\nvar t30 *Task\nvar t31 *Task\nvar t32 *Task\nvar t33 *Task\nvar t34 *Task\nvar t35 *Task\nvar t36 *Task\nvar t37 *Task\nvar t38 *Task\nvar t39 *Task\nvar t40 *Task\nvar t41 *Task\nvar t42 *Task\nvar t43 *Task\nvar t44 *Task\nvar t45 *Task\nvar t46 *Task\nvar t47 *Task\nvar t48 *Task\nvar t49 *Task\nvar t50 *Task\nvar t51 *Task\nvar t52 *Task\nvar t53 *Task\nvar t54 *Task\nvar t55 *Task\nvar t56 *Task\nvar t57 *Task\nvar t58 *Task\nvar t59 *Task\nvar t60 *Task\nvar t61 *Task\nvar t62 *Task\nvar"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tif result := Reverse32Bits(tc.given); result != tc.expected {\n\t\tt.Errorf(\"STR\", tc.expected, result)\n\t}\n}", "gen": "t := testing.T{}\nt.Parallel()\nfor i, tc := range testcases {\n\tif got := Reverse32Bits(tc); got != tc.want {\n\t\tt.Errorf(\"Reverse32Bits(%d) = %d, want %d\", tc.in, got, tc.want)\n\t}\n}\n}\n"}
{"tgt": "dummy := &ListNode{0, head}\nslow, fast := dummy, dummy\nfor fast.Next != nil && fast.Next.Next != nil {\n\tfast = fast.Next.Next\n\tslow = slow.Next\n}\nreturn slow.Next", "gen": "var a *[2]int\nvar b *[2]int\na = new([2]int)\nb = new([2]int)\n*a = [2]int{0, 0}\n*b = [2]int{0, 0}\nfor {\n\tif *a != [2]int{0, 0} {\n\t\tbreak\n\t}\n\t*a = [2]int{*a[1], *a[0]}\n\t*b = [2]int{*b[1], *b[0]}\n}\nreturn *a[1]\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "fmt.Println(superEggDrop(1, 2))\nfmt.Println(superEggDrop(2, 6))\nfmt.Println(superEggDrop(2, 4))", "gen": "fmt.Println(superEggDrop(2, 1))\nfmt.Println(superEggDrop(2, 2))\nfmt.Println(superEggDrop(4, 2))\n}\n"}
{"tgt": "var res []int\nstack := []*preOrderTree{root}\nfor len(stack) > 0 {\n\troot = stack[0]\n\tstack = stack[1:]\n\tres = append(res, root.data)\n\tif root.left != nil {\n\t\tstack = append(stack, root.left)\n\t}\n\tif root.right != nil {\n\t\tstack = append(stack, root.right)\n\t}\n}\nreturn res", "gen": "var a []preOrderTree\nvar b []preOrderTree\nvar c []preOrderTree\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar aa int\nvar ab int\nvar ac int\nvar ad int\nvar ae int\nvar af int\nvar ag int\nvar ah int\nvar ai int\nvar aj int\nvar ak int\nvar al int\nvar am int\nvar an int\nvar ao int\nvar ap int\nvar aq int\nvar ar int\nvar as int\nvar at int\nvar au int\nvar av int\nvar aw int\nvar ax int\nvar ay int\nvar az int\nvar ba int\nvar bb int\nvar bc int\nvar bd int\nvar be int\nvar bf int\nvar bg int\nvar bh int\nvar bi int\nvar bj int\nvar bk int\nvar bl int\nvar bm int\nvar bn int\nvar bo int\nvar bp int\nvar bq int\nvar br int\nvar bs int\nvar bt int\nvar bu int\nvar bv int\nvar bw int\nvar bx int\nvar by int\nvar bz int\nvar ca int\nvar cb int\nvar cc int\nvar cd int\nvar ce int\nvar cf int\nvar cg int\nvar ch int\nvar ci int\nvar cj int\nvar ck int\nvar cl int\nvar cm int\nvar cn int\nvar co int\nvar cp"}
{"tgt": "l, r := 0, 0\nn := len(s)\nfor i := 0; i < n; i++ {\n\tif s[i] == ')' {\n\t\tl--\n\t} else {\n\t\tl++\n\t}\n\tj := n - i - 1\n\tif s[j] == '(' {\n\t\tr--\n\t} else {\n\t\tr++\n\t}\n\tif l < 0 || r < 0 {\n\t\treturn false\n\t}\n}\nreturn true", "gen": "var s string\nvar i int\nvar b bool\ns = \"Hello, world!\"\ni = 0\nb = false\nfor i < len(s) {\n\tif s[i] == '!' {\n\t\tbreak\n\t}\n\ti++\n}\nif i == len(s) {\n\tb = true\n}\nreturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "type A struct {\n\tName string\n\tD    string\n}\na := A{Name: \"STR\"}\ntype B struct {\n\tAA\n\tC int\n}\nb := &B{A: a, C: 123}\nok := HasZero(b)\nif !ok {\n\tt.Error(\"STR\")\n}", "gen": "var t TestHasZero_Nested\nt.B.i1.d = 123\nif !reflect.DeepEqual(t, TestHasZero_Nested{B: B{i1: d{123}}}) {\n\tt.Errorf(\"t = %#v, want %#v\", t, TestHasZero_Nested{B: B{i1: d{123}}})\n}\n}\n\n// TestHasZero_Nested is a struct with a nested struct that has a zero value.\ntype TestHasZero_Nested struct {\nB B\n}\n\n// B is a struct with a nested struct that has a zero value.\ntype B struct {\ni1 d\n}\n\n// d is a struct with a zero value.\ntype d struct {\ni int\n}\n\n// HasZero returns whether the struct has a zero value."}
{"tgt": "for i, row := range matrix[1:] {\n\tfor j, v := range row[1:] {\n\t\tif v != matrix[i][j] {\n\t\t\treturn false\n\t\t}\n\t}\n}\nreturn true", "gen": "var a []int\nvar b []int\nvar c []int\nvar d int\nfor i := 0; i < len(a); i++ {\n\tif i >= len(b) {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i >= len(c) {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i >= len(a) {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i >= len(b) {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i >= len(c) {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i >= len(a) {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i >= len(b) {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i >= len(c) {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i >= len(a) {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i >= len(b) {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i >= len(c) {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i >= len(a) {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i >= len(b) {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i >= len(c) {\n\t\tpanic(errors.New(\"index out of range\"))\n\t}\n\tif i >= len(a) {\n\t\tpanic(errors.New(\"index out of range\"))"}
{"tgt": "qs := []question28{\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{2},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{5},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{-1},\n\t},\n\t{\n\t\tpara28{\"STR\", \"STR\"},\n\t\tans28{0},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans28, q.para28\n\tfmt.Printf(\"STR\", p, strStr(p.s, p.p))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Println(strStr(\"hello\", \"ll\"))\nfmt.Println(strStr(\"aaaaa\", \"bba\"))\nfmt.Println(strStr(\"\", \"\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println(strStr(\"a\", \"a\"))\nfmt.Println"}
{"tgt": "digits := \"STR\"\nfor i := 1; i < 9999; i++ {\n\tnum := \"STR\"\n\tfor j := 1; j < 5; j++ {\n\t\tif len(num) < 9 {\n\t\t\tnum += strconv.Itoa(i * j)\n\t\t}\n\t}\n\tarr := strings.Split(num, \"STR\")\n\tsort.Strings(arr)\n\tnumSorted := strings.Join(arr, \"STR\")\n\tif numSorted == digits {\n\t\treturn num\n\t}\n}\nreturn \"STR\"", "gen": "var a int\nvar b int\nvar c int\nvar d int\nvar e int\nvar f int\nvar g int\nvar h int\nvar i int\nvar j int\nvar k int\nvar l int\nvar m int\nvar n int\nvar o int\nvar p int\nvar q int\nvar r int\nvar s int\nvar t int\nvar u int\nvar v int\nvar w int\nvar x int\nvar y int\nvar z int\nvar a1 string\nvar b1 string\nvar c1 string\nvar d1 string\nvar e1 string\nvar f1 string\nvar g1 string\nvar h1 string\nvar i1 string\nvar j1 string\nvar k1 string\nvar l1 string\nvar m1 string\nvar n1 string\nvar o1 string\nvar p1 string\nvar q1 string\nvar r1 string\nvar s1 string\nvar t1 string\nvar u1 string\nvar v1 string\nvar w1 string\nvar x1 string\nvar y1 string\nvar z1 string\nvar a2 string\nvar b2 string\nvar c2 string\nvar d2 string\nvar e2 string\nvar f2 string\nvar g2 string\nvar h2 string\nvar i2 string\nvar j2 string\nvar k2 string\nvar l2 string\nvar m2 string\nvar n2 string\nvar o2 string\nvar p2 string\nvar q2 string\nvar r2 string\nvar s2 string\nvar t2 string\nvar u2 string\nvar v2 string\nvar w2 string\nvar x2 string\nvar y2 string\nvar z2 string\nvar a3 string\nvar b3 string\nvar c3 string\nvar d3 string\nvar e3 string\nvar f3 string\nvar g3 string\nvar h3 string\nvar i3 string\nvar j3"}
{"tgt": "obj := Constructor933()\nfmt.Printf(\"STR\", obj)\nparam1 := obj.Ping(1)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(100)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(3001)\nfmt.Printf(\"STR\", param1)\nparam1 = obj.Ping(3002)\nfmt.Printf(\"STR\", param1)", "gen": "var rc = Constructor()\nfmt.Printf(\"%d\\n\", rc.Ping(1))\nfmt.Printf(\"%d\\n\", rc.Ping(100))\nfmt.Printf(\"%d\\n\", rc.Ping(3001))\nfmt.Printf(\"%d\\n\", rc.Ping(3002))\n}\n"}
{"tgt": "root := new(*TreeNode)\ninsertArrayToTreeNode(root, array, 0)\nreturn *root", "gen": "var root *TreeNode\nroot = insertArrayToTreeNode([]int{1, 2, 3}, 0, 2)\nfmt.Println(root.Val)\n}\n"}
{"tgt": "res := 0\nsort.Ints(houses)\nsort.Ints(heaters)\nm, n := len(houses), len(heaters)\nindex := sort.SearchInts(heaters, houses[0])\nfor _, house := range houses {\n\tfor index < n && house > heaters[index] {\n\t\tindex++\n\t}\n\tif index == n {\n\t\treturn max(res, houses[m-1]-heaters[index-1])\n\t}\n\tleft := math.MaxInt32\n\tif index > 0 {\n\t\tleft = house - heaters[index-1]\n\t}\n\tright := heaters[index] - house\n\tres = max(res, min(left, right))\n}\nreturn res", "gen": "a := []int{1, 2, 3, 1}\nb := []int{1, 2, 3, 4}\nc := []int{1, 2, 3, 4}\nd := []int{1, 2, 3, 4}\nfmt.Println(maxProfit(a))\nfmt.Println(maxProfit(b))\nfmt.Println(maxProfit(c))\nfmt.Println(maxProfit(d))\n}\n"}
{"tgt": "c := Candidates(candidates)\nsort.Sort(c)\nreturn orderedCombinationSum2(c, target)", "gen": "var candidates = []int{10, 1, 2, 7, 6, 1, 5}\nvar target = 8\nvar res = combinationSum2(candidates, target)\nfmt.Println(res)\n}\n"}
{"tgt": "t.Parallel()\nfor _, tc := range testcases {\n\tresults := HeapsAlgorithmRecursive(tc.input)\n\tpos := 0\n\tfor result := range results {\n\t\tif !reflect.DeepEqual(result, tc.expected[pos]) {\n\t\t\tt.Errorf(\"STR\", tc.expected[pos], result)\n\t\t}\n\t\tpos++\n\t}\n}", "gen": "testing.Init()\nos.Exit(m.Run())\n}"}
{"tgt": "for i := 1; i < len(nums); i++ {\n\tif nums[i-1] > nums[i] {\n\t\tpre := deepCopy(nums)\n\t\tpre[i-1] = pre[i]\n\t\tnext := deepCopy(nums)\n\t\tnext[i] = next[i-1]\n\t\treturn sort.IsSorted(sort.IntSlice(pre)) || sort.IsSorted(sort.IntSlice(next))\n\t}\n}\nreturn true", "gen": "var a []int\nvar b []int\nvar c []int\nvar d []int\nvar e []int\nvar f []int\nvar g []int\nvar h []int\nvar i []int\nvar j []int\nvar k []int\nvar l []int\nvar m []int\nvar n []int\nvar o []int\nvar p []int\nvar q []int\nvar r []int\nvar s []int\nvar t []int\nvar u []int\nvar v []int\nvar w []int\nvar x []int\nvar y []int\nvar z []int\nvar aa []int\nvar ab []int\nvar ac []int\nvar ad []int\nvar ae []int\nvar af []int\nvar ag []int\nvar ah []int\nvar ai []int\nvar aj []int\nvar ak []int\nvar al []int\nvar am []int\nvar an []int\nvar ao []int\nvar ap []int\nvar aq []int\nvar ar []int\nvar as []int\nvar at []int\nvar au []int\nvar av []int\nvar aw []int\nvar ax []int\nvar ay []int\nvar az []int\nvar aaa []int\nvar aab []int\nvar aac []int\nvar aad []int\nvar aae []int\nvar aaf []int\nvar aag []int\nvar aah []int\nvar aai []int\nvar aaj []int\nvar aak []int\nvaraal []int\nvar aam []int\nvar aan []int\nvar aao []int\nvar aap []int\nvar aaq []int\nvar aar []int\nvar aas []int\nvar aat []int\nvar aau []int\nvar aav []int\nvar aw []int\nvar ax []int\nvar ay []int\nvar az []int\nvar aa []int\nvar ab []"}
{"tgt": "res := []int{}\nfor _, num := range nums {\n\tn := num\n\tif n < 0 {\n\t\tn *= -1\n\t}\n\tif nums[n-1] < 0 {\n\t\tres = append(res, n)\n\t} else {\n\t\tnums[n-1] *= -1\n\t}\n}\nreturn res", "gen": "var a [3]int\na[0] = 1\na[1] = 2\na[2] = 3\nb := a[0:2]\nb[0] = 4\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "qs := []question1281{\n\t{\n\t\tpara1281{234},\n\t\tans1281{15},\n\t},\n\t{\n\t\tpara1281{4421},\n\t\tans1281{21},\n\t},\n}\nfmt.Printf(\"STR\")\nfor _, q := range qs {\n\t_, p := q.ans1281, q.para1281\n\tfmt.Printf(\"STR\", p, subtractProductAndSum(p.n))\n}\nfmt.Printf(\"STR\")", "gen": "fmt.Printf(\"%d %d %d\\n\", 234, 15, 4421)\nfmt.Printf(\"%d %d %d\\n\", 21, 2, 2)\nvar a, b, c int\nfor i := 0; i < 2; i++ {\n\ta, b, c = subtractProductAndSum(i)\n\tfmt.Printf(\"%d %d %d\\n\", a, b, c)\n}\n}\n"}
{"tgt": "fp := float64(p)\nfa := float64(a)\nfb := (fp * (fp - 2.0*fa)) / (2.0 * (fp - fa))\nb = int(fb)\nvalid = math.Abs(fb-math.Floor(fb)) < 0.000001\nreturn", "gen": "var a, b float64\nfmt.Scan(&a, &b)\nif math.Abs(math.Floor(a/b)-a) < 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}
{"tgt": "start := -1\nlenMax := 0\ndict := [256]int{}\nfor i := range dict {\n\tdict[i] = -1\n}\nfor i, r := range s {\n\tif v := dict[r]; v > start {\n\t\tstart = v\n\t}\n\tlength := i - start\n\tif length > lenMax {\n\t\tlenMax = length\n\t}\n\tdict[r] = i\n}\nreturn lenMax", "gen": "var s []byte\nvar i int\nvar j int\nvar k int\nfor k = 0; k < len(s); k++ {\n\tif k < len(s) {\n\t\ti = k\n\t\tj = 0\n\t\tfor {\n\t\t\tif j < len(s) {\n\t\t\t\tif s[j] < 127 {\n\t\t\t\t\tif j < len(s) {\n\t\t\t\t\t\tif s[j] > 255 {\n\t\t\t\t\t\t\tpanic(errors.New(\"\"))\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts[j] = rune(s[j])\n\t\t\t\t\t}\n\t\t\t\t\tif j < len(s) {\n\t\t\t\t\t\tif s[j] < 0 {\n\t\t\t\t\t\t\tpanic(errors.New(\"\"))\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts[j] = rune(s[j])\n\t\t\t\t\t}\n\t\t\t\t\tif j < len(s) {\n\t\t\t\t\t\tif s[j] > 255 {\n\t\t\t\t\t\t\tpanic(errors.New(\"\"))\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts[j] = rune(s[j])\n\t\t\t\t\t}\n\t\t\t\t\tif j < len(s) {\n\t\t\t\t\t\tif s[j] < 0 {\n\t\t\t\t\t\t\tpanic(errors.New(\"\"))\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts[j] = rune(s[j])\n\t\t\t\t\t}\n\t\t\t\t\tif j < len(s) {\n\t\t\t\t\t\tif s[j] > 255 {\n\t\t\t\t\t\t\tpanic(errors.New(\"\"))\n"}
{"tgt": "return &skipListNode{v: v, score: score, forwards: make([]*skipListNode, level, level), level: level}", "gen": "var s []skipListNode\ns = make([]skipListNode, 1)\ns[0] = skipListNode{\n\tdata: 1,\n\tnext: []*skipListNode{},\n}\nreturn s\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"tgt": "m := [26]int{}\nfor _, b := range B {\n\tcount := counter(b)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tm[i] = count[i]\n\t\t}\n\t}\n}\nres := []string{}\nfor _, a := range A {\n\tcount := counter(a)\n\tfor i, c := range m {\n\t\tif count[i] > c {\n\t\t\tcontinueL\n\t\t}\n\t}\n\tres = append(res, a)\n}\nreturn res", "gen": "var a []string\nfor i := 0; i < 26; i++ {\n\ta = append(a, strconv.Itoa(i))\n}\nvar b []string\nfor i := 0; i < 26; i++ {\n\tb = append(b, strconv.Itoa(i))\n}\nvar c []string\nfor i := 0; i < 26; i++ {\n\tc = append(c, strconv.Itoa(i))\n}\nvar d []string\nfor i := 0; i < 26; i++ {\n\td = append(d, strconv.Itoa(i))\n}\nvar e []string\nfor i := 0; i < 26; i++ {\n\te = append(e, strconv.Itoa(i))\n}\nvar f []string\nfor i := 0; i < 26; i++ {\n\tf = append(f, strconv.Itoa(i))\n}\nvar g []string\nfor i := 0; i < 26; i++ {\n\tg = append(g, strconv.Itoa(i))\n}\nvar h []string\nfor i := 0; i < 26; i++ {\n\th = append(h, strconv.Itoa(i))\n}\nvar i []string\nfor i := 0; i < 26; i++ {\n\ti = append(i, strconv.Itoa(i))\n}\nvar j []string\nfor i := 0; i < 26; i++ {\n\tj = append(j, strconv.Itoa(i))\n}\nvar k []string\nfor i := 0; i < 26; i++ {\n\tk = append(k, strconv.Itoa(i))\n}\nvar l []string\nfor i := 0; i < "}
{"tgt": "bulls, cows := 0, 0\nnums := [10]int{}\nfor i := 0; i < len(secret); i++ {\n\ts, g := int(secret[i]-'0'), int(guess[i]-'0')\n\tif s == g {\n\t\tbulls++\n\t} else {\n\t\tif nums[s] < 0 {\n\t\t\tcows++\n\t\t}\n\t\tif nums[g] > 0 {\n\t\t\tcows++\n\t\t}\n\t\tnums[s]++\n\t\tnums[g]--\n\t}\n}\nreturn fmt.Sprintf(\"STR\", bulls, cows)", "gen": "var a, b int\nfmt.Scan(&a, &b)\nvar c int\nc = 0\nvar d int\nd = 0\nvar e int\ne = 0\nvar f int\nf = 0\nvar g int\ng = 0\nvar h int\nh = 0\nvar i int\ni = 0\nvar j int\nj = 0\nvar k int\nk = 0\nvar l int\nl = 0\nvar m int\nm = 0\nvar n int\nn = 0\nvar o int\no = 0\nvar p int\np = 0\nvar q int\nq = 0\nvar r int\nr = 0\nvar s int\ns = 0\nvar t int\nt = 0\nvar u int\nu = 0\nvar v int\nv = 0\nvar w int\nw = 0\nvar x int\nx = 0\nvar y int\ny = 0\nvar z int\nz = 0\nvar A int\nA = 0\nvar B int\nB = 0\nvar C int\nC = 0\nvar D int\nD = 0\nvar E int\nE = 0\nvar F int\nF = 0\nvar G int\nG = 0\nvar H int\nH = 0\nvar I int\nI = 0\nvar J int\nJ = 0\nvar K int\nK = 0\nvar L int\nL = 0\nvar M int\nM = 0\nvar N int\nN = 0\nvar O int\nO = 0\nvar P int\nP = 0\nvar Q int\nQ = 0\nvar R int\nR = 0\nvar S int\nS = 0\nvar T int\nT = "}
{"tgt": "t.Parallel()\nfor _, l := range mathTestData {\n\tif log2Floor(l.n) != l.f || log2Ceil(l.n) != l.c {\n\t\tt.Errorf(\"STR\",\n\t\t\tl.n, l.f, l.c, log2Floor(l.n), log2Ceil(l.n))\n\t}\n}", "gen": "testing.MainStart(testMain, nil, nil)\n}"}
{"tgt": "bs := strings.Builder{}\nvar dfs func(*TreeNode)\ndfs = func(node *TreeNode) {\n\tif node == nil {\n\t\treturn\n\t}\n\tbs.WriteString(strconv.Itoa(node.Val))\n\tif node.Left == nil && node.Right == nil {\n\t\treturn\n\t}\n\tbs.WriteByte('(')\n\tif node.Left != nil {\n\t\tdfs(node.Left)\n\t}\n\tbs.WriteByte(')')\n\tif node.Right != nil {\n\t\tbs.WriteByte('(')\n\t\tdfs(node.Right)\n\t\tbs.WriteByte(')')\n\t}\n}\ndfs(t)\nreturn bs.String()", "gen": "root := &TreeNode{Val: 1}\nroot.Left = &TreeNode{Val: 2}\nroot.Right = &TreeNode{Val: 3}\nroot.Left.Left = &TreeNode{Val: 4}\nroot.Left.Right = &TreeNode{Val: 5}\nroot.Right.Left = &TreeNode{Val: 6}\nroot.Right.Right = &TreeNode{Val: 7}\nroot.Right.Right.Left = &TreeNode{Val: 8}\nroot.Right.Right.Right = &TreeNode{Val: 9}\nroot.Right.Right.Right.Left = &TreeNode{Val: 10}\nroot.Right.Right.Right.Right = &TreeNode{Val: 11}\nroot.Right.Right.Right.Right.Left = &TreeNode{Val: 12}\nroot.Right.Right.Right.Right.Right = &TreeNode{Val: 13}\nroot.Right.Right.Right.Right.Right.Left = &TreeNode{Val: 14}\nroot.Right.Right.Right.Right.Right.Right = &TreeNode{Val: 15}\nroot.Right.Right.Right.Right.Right.Right.Left = &TreeNode{Val: 16}\nroot.Right.Right.Right.Right.Right.Right.Right = &TreeNode{Val: 17}\nroot.Right.Right.Right.Right.Right.Right.Right.Left = &TreeNode{Val: 18}\nroot.Right.Right.Right.Right.Right.Right.Right.Right = &TreeNode{Val: 19}\nroot.Right.Right.Right.Right.Right.Right.Right.Right.Left = &TreeNode{Val: 20}\nroot.Right.Right.Right.Right.Right.Right.Right.Right.Right = &TreeNode{Val: 21}\nroot.Right.Right.Right.Right.Right.Right.Right.Right.Right.Left = &TreeNode{"}
{"tgt": "return nil == root || isSame(root.Left, root.Right)", "gen": "if len(a) == 0 {\n\treturn false\n}\nreturn isSame(a[0], a[len(a)-1])\n}\n"}
{"tgt": "cases := []struct {\n\tname      string\n\tflowerbed []int\n\tn         int\n\texpect    bool\n}{\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 1, true},\n\t{\"STR\", []int{1, 0, 0, 0, 1}, 2, false},\n\t{\"STR\", []int{1, 0, 1, 0}, 0, true},\n\t{\"STR\", []int{0}, 1, true},\n\t{\"STR\", []int{1, 0, 1, 0, 1, 0, 1}, 1, false},\n}\nfor i, c := range cases {\n\tt.Run(c.name+\"STR\"+strconv.Itoa(i), func(t *testing.T) {\n\t\tgot := Solution(c.flowerbed, c.n)\n\t\tif !reflect.DeepEqual(got, c.expect) {\n\t\t\tt.Fatalf(\"STR\",\n\t\t\t\tc.expect, got, c.flowerbed, c.n)\n\t\t}\n\t})\n}", "gen": "solution := Solution{}\nflowerbed := []int{1, 0, 0, 0, 1}\nn := 2\nexpect := true\nif solution.CanPlaceFlowers(flowerbed, n) != expect {\n\tt.Fail()\n}\nflowerbed = []int{1, 0, 0, 0, 0, 0, 1}\nn = 2\nexpect = false\nif solution.CanPlaceFlowers(flowerbed, n) != expect {\n\tt.Fail()\n}\nflowerbed = []int{1, 0, 0, 0, 0, 1}\nn = 2\nexpect = true\nif solution.CanPlaceFlowers(flowerbed, n) != expect {\n\tt.Fail()\n}\nflowerbed = []int{1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,"}
{"tgt": "const maxDiv = 20\ni, div := maxDiv, maxDiv-1\nfor {\n\tif i%div == 0 {\n\t\tif div > 1 {\n\t\t\tdiv--\n\t\t} else {\n\t\t\tfmt.Println(i)\n\t\t\tos.Exit(0)\n\t\t}\n\t} else {\n\t\ti += maxDiv\n\t\tdiv = maxDiv - 1\n\t}\n}", "gen": "var a int\nvar b int\nfor {\n\tif b == -1 {\n\t\tpanicdivide()\n\t}\n\tif b == 0 {\n\t\tpanicdivide()\n\t}\n\tif b > 1 {\n\t\tb--\n\t\tcontinue\n\t}\n\tif b == 1 {\n\t\ta = a / b\n\t\tvar c int\n\t\tc = a\n\t\tvar d int\n\t\td = c\n\t\tvar e int\n\t\te = d\n\t\tvar f int\n\t\tf = e\n\t\tvar g int\n\t\tg = f\n\t\tvar h int\n\t\th = g\n\t\tvar i int\n\t\ti = h\n\t\tvar j int\n\t\tj = i\n\t\tvar k int\n\t\tk = j\n\t\tvar l int\n\t\tl = k\n\t\tvar m int\n\t\tm = l\n\t\tvar n int\n\t\tn = m\n\t\tvar o int\n\t\to = n\n\t\tvar p int\n\t\tp = o\n\t\tvar q int\n\t\tq = p\n\t\tvar r int\n\t\tr = q\n\t\tvar s int\n\t\ts = r\n\t\tvar t int\n\t\tt = s\n\t\tvar u int\n\t\tu = t\n\t\tvar v int\n\t\tv = u\n\t\tvar w int\n\t\tw = v\n\t\tvar x int\n\t\tx = w\n\t\tvar y int\n\t\ty = x\n\t\tvar z int\n\t\tz = y\n\t\tvar aa int\n\t\taa = z\n\t\tvar bb int\n\t\tbb = aa\n\t\tvar cc int\n\t\tcc = bb\n\t\tvar dd int\n\t\tdd = cc\n\t\tvar ee"}
