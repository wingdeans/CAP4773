fmt . Println ( mostCommonWord (" STR ", [] string {" STR ", " STR "}))
if nil == nums || len ( nums ) == 0 { # return # } # # insertPos := 0 # for _ , values := range nums { # if 0 != values { # nums [ insertPos ] = values # insertPos ++ # } # } # # for insertPos < len ( nums ) { # nums [ insertPos ] = 0 # insertPos ++ # }
cases := [] struct { # a , b , expected int # }{ # { # a : 0 , # b : 0 , # expected : 0 , # }, # { # a : 1 , # b : 1 , # expected : 1 , # }, # { # a : - 1 , # b : 1 , # expected : - 1 , # }, # { # a : 1 , # b : - 1 , # expected : - 1 , # }, # { # a : 1 0 , # b : 2 , # expected : 2 , # }, # } # # for _ , c := range cases { # actual := Min ( c . a , c . b ) # if actual != c . expected { # t . Errorf (" STR ", c . expected , actual ) # } # }
ma := 0 # if len ( heights ) < 0 { # return 0 # } # # var stack [] int # for i := 0 ; i < len ( heights ); i ++ { # if i == 0 { # stack = append ( stack , heights [ i ]) # m := maxArea ( stack ) # ma = max ( m , ma ) # continue # } # # if heights [ i - 1 ] > heights [ i ] { # m := maxArea ( stack ) # ma = max ( m , ma ) # stack = changeStack ( stack , heights [ i ]) # } # # stack = append ( stack , heights [ i ]) # # if i + 1 == len ( heights ) { # m := maxArea ( stack ) # ma = max ( m , ma ) # continue # } # } # # return ma
min := func ( a , b int ) int { # return int ( math . Min ( float 6 4 ( a ), float 6 4 ( b ))) # } # # dp := make ([] int , 2 ) # dp [ 0 ], dp [ 1 ] = cost [ 0 ], cost [ 1 ] # for i := 2 ; i < len ( cost ); i ++ { # dp [ i % 2 ] = cost [ i ] + min ( dp [ 0 ], dp [ 1 ]) # } # # return min ( dp [ 0 ], dp [ 1 ])
temp , mask := num , 0 # # for temp > 0 { # mask = mask * 2 + 1 # temp /= 2 # } # return mask ^ num
listNode 1 := & ListNode { # Val : 4 , # Next : & ListNode { # Val : 1 , # Next : & ListNode { # Val : 4 , # Next : nil , # }, # }, # } # listNode 2 := & ListNode { # Val : 1 , # Next : & ListNode { # Val : 8 , # Next : & ListNode { # Val : 4 , # Next : nil , # }, # }, # } # getIntersectionNode ( listNode 1 , listNode 2 )
switch { # case isIPv 4 ( IP ): # return " STR " # case isIPv 6 ( IP ): # return " STR " # default : # return " STR " # }
l := len ( preorder ) # if l == 0 { # return nil # } # for 1 < l && preorder [ 0 ] < preorder [ l - 1 ] { # l -- # } # return & TreeNode { # Val : preorder [ 0 ], # Left : bstFromPreorder ( preorder [ 1 : l ]), # Right : bstFromPreorder ( preorder [ l :]), # }
sort . Slice ( costs , func ( i , j int ) bool { # return abs ( costs [ i ][ 0 ]- costs [ i ][ 1 ]) > abs ( costs [ j ][ 0 ]- costs [ j ][ 1 ]) # }) # cost , a , b , n := 0 , 0 , 0 , len ( costs )/ 2 # for _ , c := range costs { # if ( c [ 0 ] < c [ 1 ] && a < n ) || b == n { # cost += c [ 0 ] # a ++ # } else { # cost += c [ 1 ] # b ++ # } # } # return cost
println (" STR ") # println (" STR ", v 1 ) # println (" STR ", v 2 . x , v 2 . y ) # println (" STR ", len ( v 3 ), cap ( v 3 ), v 3 [ 0 ], v 3 [ 3 ]) # println (" STR ", len ( v 4 ), v 4 == nil ) # println (" STR ", len ( v 5 ), v 5 == nil ) # println (" STR ", v 6 ) # println (" STR ", cap ( v 7 ), string ( v 7 )) # # println ( uint 8 SliceSrc [ 0 ]) # println ( uint 8 SliceDst [ 0 ]) # println ( intSliceSrc [ 0 ]) # println ( intSliceDst [ 0 ])
words := strings . Fields ( s ) # return strings . Join ( reverseSlice ( words ), " STR ")
cases := [] struct { # name string # inputs [] int # expect bool # }{ # {" STR ", [] int { 1 , 2 , 2 , 3 }, true }, # {" STR ", [] int { 4 , 3 , 3 , 2 }, true }, # {" STR ", [] int { 1 , 3 , 2 }, false }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
indexs := make ([] int , 1 2 3 ) # for i , c := range order { # indexs [ c ] = i # } # # less := func ( i , j int ) bool { # si , sj := len ( words [ i ]), len ( words [ j ]) # for k := 0 ; k < si && k < sj ; k ++ { # ii , ij := indexs [ words [ i ][ k ]], indexs [ words [ j ][ k ]] # switch { # case ii < ij : # return true # case ii > ij : # return false # } # } # return si <= sj # } # # for i := 1 ; i < len ( words ); i ++ { # if ! less ( i - 1 , i ) { # return false # } # } # return true
row := len ( grid ) # col := len ( grid [ 0 ]) # # dp := make ([][] int , row ) # for i := 0 ; i < row ; i ++ { # dp [ i ] = make ([] int , col ) # } # # dp [ 0 ][ 0 ] = grid [ 0 ][ 0 ] # # for i := 1 ; i < row ; i ++ { # dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ] + grid [ i ][ 0 ] # } # # for i := 1 ; i < col ; i ++ { # dp [ 0 ][ i ] = dp [ 0 ][ i - 1 ] + grid [ 0 ][ i ] # } # # for i := 1 ; i < row ; i ++ { # for j := 1 ; j < col ; j ++ { # dp [ i ][ j ] = Min ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]) + grid [ i ][ j ] # } # } # return dp [ row - 1 ][ col - 1 ]
fmt . Fprint ( w , " STR ")
l := len ( nums ) # k %= l # s := make ([] int , l ) # copy ( s , nums ) # for i , v := range s [ l - k :] { # nums [ i ] = v # } # for i , v := range s [: l - k ] { # nums [ k + i ] = v # }
if p == nil || q == nil { # return p == q # } # return isSameTree ( p . Left , q . Left ) && p . Val == q . Val && isSameTree ( p . Right , q . Right )
for cur := t . root ; cur != nil ; { # if cur . Key == key { # return cur # } else if key < cur . Key { # cur = cur . left # } else { # cur = cur . right # } # } # return nil
s := [] int {} # for _ , asteroid := range asteroids { # for len ( s ) != 0 && s [ len ( s )- 1 ] > 0 && s [ len ( s )- 1 ] < - asteroid { # s = s [: len ( s )- 1 ] # } # if len ( s ) == 0 || asteroid > 0 || s [ len ( s )- 1 ] < 0 { # s = append ( s , asteroid ) # } else if asteroid < 0 && s [ len ( s )- 1 ] == - asteroid { # s = s [: len ( s )- 1 ] # } # } # return s
sum := 0 # sunday := 5 # year := 1 9 0 1 # is_leap := false # for year < 2 0 0 1 { # checker := month_len # if is_leap { # checker = leap_len # } # tally := sunday # for _ , v := range checker { # if tally == 0 { # sum += 1 # } # if tally < v { # break # } # if tally >= v { # tally -= v # } # } # sunday += 7 # if is_leap && sunday >= 3 6 6 { # year ++ # sunday = sunday % 3 6 6 # is_leap = false # } else if ! is_leap && sunday >= 3 6 5 { # year ++ # sunday = sunday % 3 6 5 # if year % 4 == 0 { # is_leap = true # } # } # } # fmt . Printf (" STR ", year , sum )
max , winner := 0 , 0 # for i := 1 ; i < 1 0 0 0 0 0 0 ; i ++ { # terms := collatz ( i ) # if terms > max { # max = terms # winner = i # } # } # fmt . Println (" STR ", max , " STR ", winner )
return fmt . Sprintf (" STR ", c . FirstName , c . LastName , c . Email )
e . lgu = lgu # e . mixin = mixin # e . cluster = make ( map [ interface {}]* rsVEBTreeElement ) # if e . lgu > 1 { # e . summaryLgu = ( e . lgu + 1 ) / 2 # e . clusterLgu = e . lgu - e . summaryLgu # e . summary = new ( rsVEBTreeElement ). init ( e . summaryLgu , e . mixin ) # } else { # e . summaryLgu = 0 # e . clusterLgu = 0 # } # return e
if isValid := checkHorizontal ( puzzle ); ! isValid { # return false # } # if isValid := checkVertical ( puzzle ); ! isValid { # return false # } # if isValid := checkReachable ( puzzle ); ! isValid { # return false # } # if isValid := checkRotationallySymmetric ( puzzle ); ! isValid { # return false # } # return true
b . Run (" STR ", func ( b * testing . B ) { # b . ResetTimer () # got := multiply (" STR ", " STR ") # want := " STR " # if got != want { # b . Error (" STR ") # } # }) # b . Run (" STR ", func ( b * testing . B ) { # b . ResetTimer () # got := multiply (" STR ", " STR ") # want := " STR " # if got != want { # b . Error (" STR ") # } # }) # b . Run (" STR ", func ( b * testing . B ) { # b . ResetTimer () # got := multiply (" STR ", " STR ") # want := " STR " # if got != want { # b . Error (" STR ") # } # }) # b . Run (" STR ", func ( b * testing . B ) { # b . ResetTimer () # got := multiply (" STR ", " STR ") # want := " STR " # if got != want { # b . Error (" STR ") # } # })
t . Parallel () # # for tcid , tc := range testcases { # if result := SumRevLLNum ( tc . first , tc . second ); ! equal ( result , tc . sum ) { # t . Errorf (" STR ", # tcid , String ( result ), String ( tc . sum )) # } # }
type A struct { # Name string # D string # } # a := A { Name : " STR "} # # type B struct { # A A ` structs :" STR "` # C int # } # b := & B { A : a , C : 1 2 3 } # # ok := HasZero ( b ) # if ok { # t . Error (" STR ") # }
nums := [] int { 1 , 1 , 2 , 2 , 3 , 3 } # # fmt . Println ( distributeCandies ( nums )) # # nums 2 := [] int { 1 , 1 , 2 , 3 } # fmt . Println ( distributeCandies ( nums 2 ))
i , j := start , len ( nums )- 1 # for i < j { # nums [ i ], nums [ j ] = nums [ j ], nums [ i ] # i ++ # j -- # }
var val int # for n := uint ( 0 ); num != 0 ; num >>= 1 { # val |= ( 1 - ( num & 1 )) << n # n ++ # } # return val
size := len ( A ) # res := make ([] int , size ) # even , odd := 0 , 1 # # for _ , a := range A { # if a % 2 == 0 { # res [ even ] = a # even += 2 # } else { # res [ odd ] = a # odd += 2 # } # } # # return res
slow , fast := head , head # for fast != nil && fast . Next != nil { # slow = slow . Next # fast = fast . Next . Next # } # var prev * ListNode # for slow != nil { # next := slow . Next # slow . Next = prev # prev , slow = slow , next # } # # for p , q := head , prev ; p != q ; p , q = q , p { # next := p . Next # p . Next = q # p = next # }
for _ , p := range perm 6 ([] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }) { # valid := true # for _ , g := range guesses { # var count int # for i := 0 ; i < len ( p ); i ++ { # if p [ i ] == g . Code [ i ] { # count ++ # } # } # if count != g . Score { # valid = false # break # } # } # if valid { # return true # } # } # return false
for i := 0 ; i < 1 0 0 0 0 0 ; i ++ { # if i % 3 0 0 == 0 { # array := GetArrayOfSize ( i ) # # if len ( array ) != i { # fmt . Println ( array ) # t . Error () # } # } # }
parent := this # for _ , ch := range prefix { # if child , ok := parent . Children [ ch ]; ok { # parent = child # continue # } # return false # } # return true
sema <- struct {}{} # b := balance # <- sema # return b
pairs := [...][ 2 ] int {{ 1 0 , 7 }, { 1 0 0 0 , 9 8 3 }} # for _ , pair := range pairs { # in , out := pair [ 0 ], pair [ 1 ] # if x := p 2 6 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # } # }
for i := 0 ; i < n ; i ++ { # if len ( squares ) != i { # println (" STR ", len ( squares ), " STR ", i ) # } # squares [ i ] = i * i # for j := 0 ; j <= i ; j ++ { # if v , ok := squares [ j ]; ! ok || v != j * j { # if ! ok { # println (" STR ", j ) # } else { # println (" STR ", j , v ) # } # return # } # } # }
for _ , word := range words { # remainNum [ word ] = 0 # } # for _ , word := range words { # remainNum [ word ]++ # } # return 0
ad := admin { # user : user { # name : " STR ", # email : " STR ", # }, # level : " STR ", # } # # ad . user . notify () # # ad . notify ()
if ! ok { # panic (" STR ") # }
sum := 0 # # prev := 1 # curr := 1 # # for curr <= 4 e 6 { # prev , curr = curr , prev + curr # # if curr % 2 == 0 { # sum += curr # } # } # # fmt . Println ( sum )
dist := func ( i int ) int { # x , y := points [ i ][ 0 ], points [ i ][ 1 ] # return x * x + y * y # } # partition := func ( l , r int ) int { # pivot , pdist := l , dist ( l ) # # points [ pivot ], points [ r ] = points [ r ], points [ pivot ] # divider := l # for i := l ; i < r ; i ++ { # if dist ( i ) < pdist { # points [ i ], points [ divider ] = points [ divider ], points [ i ] # divider ++ # } # } # points [ divider ], points [ r ] = points [ r ], points [ divider ] # return divider # } # l , r := 0 , len ( points )- 1 # for l < r { # i := partition ( l , r ) # if i == K { # break # } else if i > K { # r = i - 1 # } else { # l = i + 1 # } # } # return points [: K ]
if c < 0 { # return false # } # l , r := 0 , mySqrt ( c ) # for l <= r { # cur := l * l + r * r # if cur < c { # l ++ # } else if cur > c { # r -- # } else { # return true # } # } # return false
n := len ( edges ) # parent := make ([] int , n + 1 ) # for i := 0 ; i < n ; i ++ { # parent [ i ] = i # } # # var i int # var e [] int # for i , e = range edges { # f , t := e [ 0 ], e [ 1 ] # pf := find ( parent , f ) # pt := find ( parent , t ) # if pf == pt { # break # } # parent [ pf ] = pt # } # return edges [ i ]
var bin strings . Builder # for head != nil { # bin . WriteString ( strconv . Itoa ( head . Val )) # head = head . Next # } # i , _ := strconv . ParseInt ( bin . String (), 2 , 6 4 ) # return int ( i )
if n == 0 { # return 0 # } # return n / 5 + trailingZeroes ( n / 5 )
t . Parallel () # for tcid , tc := range testcases { # puzzle := make ([][] rune , len ( tc . puzzle )) # for i := range puzzle { # puzzle [ i ] = [] rune ( tc . puzzle [ i ]) # } # if result := FindWordLD ( puzzle , [] rune ( tc . target )); result != tc . expected { # t . Errorf (" STR ", tcid , tc . expected , result ) # } # }
start := 0 # end := len ( s ) - 1 # # for start < end { # s [ start ], s [ end ] = s [ end ], s [ start ] # # start ++ # end -- # } # # return s
if m == 0 { # return 1 # } # # switch n { # case 1 : # return 2 # case 2 : # if m == 1 { # return 3 # } # return 4 # default : # switch m { # case 1 : # return 4 # case 2 : # return 7 # default : # return 8 # } # }
last , n := 0 , len ( s ) # for i := 1 ; i < n ; i ++ { # if s [ i - 1 ] == s [ i ] { # continue # } # for l := 0 ; i + l < n ; l ++ { # if s [ last + l ] < s [ i + l ] { # last = i # break # } # if s [ last + l ] > s [ i + l ] { # break # } # } # } # return s [ last :]
fmt . Println ( checkPerfectNumber ( 6 )) # fmt . Println ( checkPerfectNumber ( 2 8 )) # fmt . Println ( checkPerfectNumber ( 3 0 ))
t . Parallel () # for tcid , tc := range testcases { # if result := EqualWithShifting ( tc . A , tc . B ); result != tc . expected { # t . Errorf (" STR ", tcid , tc . expected , result ) # } # }
s = strings . TrimSpace ( s ) # _ , err := strconv . ParseFloat ( s , 6 4 ) # return err == nil || err .(* strconv . NumError ). Err != strconv . ErrSyntax
qs := [] question 7 6 { # # { # para 7 6 {" STR ", " STR "}, # ans 7 6 {" STR "}, # }, # # { # para 7 6 {" STR ", " STR "}, # ans 7 6 {" STR "}, # }, # # { # para 7 6 {" STR ", " STR "}, # ans 7 6 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 6 , q . para 7 6 # fmt . Printf (" STR ", p , minWindow ( p . s , p . p )) # } # fmt . Printf (" STR ")
cases := [] struct { # name string # nums 1 [] int # nums 2 [] int # expect int # }{ # {" STR ", [] int { 1 , 2 , 3 , 2 , 1 }, [] int { 3 , 2 , 1 , 4 , 7 }, 3 }, # {" STR ", [] int { 0 , 0 , 0 , 0 , 0 }, [] int { 0 , 0 , 0 , 0 , 0 }, 5 }, # {" STR ", [] int { 0 , 0 , 0 , 0 , 1 }, [] int { 1 , 0 , 0 , 0 , 0 }, 4 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . nums 1 , c . nums 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . nums 1 , c . nums 2 ) # } # }) # }
return strings . ReplaceAll ( r . element . Name , " STR ", "")
result := Mul 3 And 5 ( 5 ) # if result != 3 { # t . Errorf (" STR ", result , 3 ) # } # # result = Mul 3 And 5 ( 6 ) # if result != 8 { # t . Errorf (" STR ", result , 8 ) # } # # result = Mul 3 And 5 ( 7 ) # if result != 1 4 { # t . Errorf (" STR ", result , 1 4 ) # } # # result = Mul 3 And 5 ( 1 0 ) # if result != 2 3 { # t . Errorf (" STR ", result , 2 3 ) # } # # result = Mul 3 And 5 ( 1 1 ) # if result != 3 3 { # t . Errorf (" STR ", result , 3 3 ) # }
qs := [] question 1 1 0 8 { # # { # para 1 1 0 8 {" STR "}, # ans 1 1 0 8 {" STR "}, # }, # # { # para 1 1 0 8 {" STR "}, # ans 1 1 0 8 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 1 0 8 , q . para 1 1 0 8 # fmt . Printf (" STR ", p , defangIPaddr ( p . one )) # } # fmt . Printf (" STR ")
if root == nil { # return nil # } # if root . Key == key { # return root # } else if root . Key < key { # root = root . Right # } else { # root = root . Left # } # return Get ( root , key )
tests := [...] testType { # { # in : [] int { 1 , 2 , 2 , 3 , 1 }, # want : 2 , # }, # { # in : [] int { 1 , 2 , 2 , 3 , 1 , 4 , 2 }, # want : 6 , # }, # { # in : [] int { 1 }, # want : 1 , # }, # { # in : [] int { 2 , 1 , 1 , 2 , 1 , 3 , 3 , 3 , 1 , 3 , 1 , 3 , 2 }, # want : 7 , # }, # { # in : [] int { 1 , 2 , 2 , 3 , 1 }, # want : 2 , # }, # } # for _ , tt := range tests { # got := findShortestSubArray ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
fmt . Println ( runtime . GOOS , runtime . GOARCH )
result := make ([] string , 0 ) # start := - 1 # end := - 1 # for i , num := range nums { # if i > 0 && num == nums [ i - 1 ]+ 1 { # end = i # } else { # if i > 0 { # result = appendRanges ( result , nums , start , end ) # } # # start = i # end = i # } # } # # if end >= 0 { # result = appendRanges ( result , nums , start , end ) # } # # return result
pigs := 0 # for mypow ( minutesToTest / minutesToDie + 1 , pigs ) < buckets { # pigs ++ # } # return pigs
qs := [] question 4 7 0 { # # { # para 4 7 0 {}, # ans 4 7 0 { 2 }, # }, # # { # para 4 7 0 {}, # ans 4 7 0 { 0 }, # }, # # { # para 4 7 0 {}, # ans 4 7 0 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 7 0 , q . para 4 7 0 # fmt . Printf (" STR ", p , rand 1 0 ()) # } # fmt . Printf (" STR ")
if s == nil { # return false # } # return isSubtree ( s . Left , t ) || isSameTree ( s , t ) || isSubtree ( s . Right , t )
if p := e . r ; e . list != nil && p != & e . list . root { # return p # } # return nil
switch { # case one == nil && two == nil : # return nil # case one == nil : # return & BinaryTree { two . Val , # MergeBinaryTrees ( nil , two . Left ), # MergeBinaryTrees ( nil , two . Right ), # } # case two == nil : # return & BinaryTree { one . Val , # MergeBinaryTrees ( one . Left , nil ), # MergeBinaryTrees ( one . Right , nil ), # } # } # return & BinaryTree { one . Val + two . Val , # MergeBinaryTrees ( one . Left , two . Left ), # MergeBinaryTrees ( one . Right , two . Right ), # }
rets := make ([][] int , numRows ) # if numRows == 0 { # return rets # } # rets [ 0 ] = [] int { 1 } # for i := 1 ; i < numRows ; i ++ { # rets [ i ] = make ([] int , i + 1 ) # rets [ i ][ 0 ] = 1 # rets [ i ][ i ] = 1 # for j := 1 ; j < i ; j ++ { # rets [ i ][ j ] = rets [ i - 1 ][ j - 1 ] + rets [ i - 1 ][ j ] # } # } # return rets
i , l := 0 , len ( bits )- 1 # for i < l { # i += bits [ i ] + 1 # } # return i == l
fname , lname := " STR ", " STR " # age := 3 5 # fmt . Println ( Title ) # fmt . Println (" STR ", fname ) # fmt . Println (" STR ", lname ) # fmt . Println (" STR ", age ) # fmt . Println (" STR ", Country )
for i := 0 ; i < b . N ; i ++ { # Sum ( 7 , 8 , 1 0 ) # }
dec := xml . NewDecoder ( os . Stdin ) # var stack [] string # for { # tok , err := dec . Token () # if err == io . EOF { # break # } else if err != nil { # fmt . Fprintf ( os . Stderr , " STR ", err ) # os . Exit ( 1 ) # } # switch tok := tok .( type ) { # case xml . StartElement : # stack = append ( stack , tok . Name . Local ) # case xml . EndElement : # stack = stack [: len ( stack )- 1 ] # case xml . CharData : # if containsAll ( stack , os . Args [ 1 :]) { # fmt . Printf (" STR ", strings . Join ( stack , " STR "), tok ) # } # } # }
var sentences [] string # var start int # spaceDelimited := strings . Split ( text , " STR ") # possibleSentence := false # for i , part := range spaceDelimited { # runes := [] rune ( part ) # if part == " STR " || ! isValid ( runes ) { # possibleSentence = false # continue # } # if runes [ 0 ] >= ' A ' && runes [ 0 ] <= ' Z ' { # possibleSentence = true # start = i # continue # } # if last := runes [ len ( runes )- 1 ]; last == '.' || last == '!' || last == '?' { # if possibleSentence { # sentences = append ( sentences , strings . Join ( spaceDelimited [ start : i + 1 ], " STR ")) # } # } # } # return sentences
arr := randomSlice ( 0 , 2 0 , 1 0 ) # deleteSequence := randomSlice ( 0 , 1 0 , 1 0 ) # nodeCnt := 0 # rbt := newRBT () # for _ , v := range arr { # rbt . Insert ( uint 3 2 ( v )) # } # for i , v := range deleteSequence { # rbt . Delete ( uint 3 2 ( arr [ v ])) # stop := rbt . PreOrderWalk ( rbt . Root (), checkGBT ( t , & nodeCnt , * debug )) # if stop { # return # } # if nodeCnt != len ( deleteSequence )- 1 - i { # t . Log (" STR ", len ( deleteSequence )- 1 - i , " STR ", nodeCnt ) # t . Fail () # } # nodeCnt = 0 # if i != len ( deleteSequence )- 1 { # stop = checkRBT ( t , rbt ) # if stop { # return # } # } # }
ans := make ([] int , len ( nums )) # for i , idx := range index { # copy ( ans [ idx + 1 :], ans [ idx :]) # ans [ idx ] = nums [ i ] # } # return ans
min , max := A [ 0 ], A [ 0 ] # for _ , a := range A { # if a < min { # min = a # } # if a > max { # max = a # } # } # if max - min <= K + K { # return 0 # } # return max - min - K - K
left := 0 # right := len ( numbers ) - 1 # for left != right { # if numbers [ left ]+ numbers [ right ] == target { # break # } # if numbers [ left ]+ numbers [ right ] > target { # right -- # } # if numbers [ left ]+ numbers [ right ] < target { # left ++ # } # } # return [] int { left + 1 , right + 1 }
for a != nil && b != nil { # if a . Value != b . Value { # return false # } # # a = a . Next # b = b . Next # } # # return a == nil && b == nil
return func ( tree binaryTreeIf , node interface {}) bool { # n := node .(* gbtElement ) # if ! tree . IsNil ( n . Left ) && n . Left . Key >= n . Key { # t . Log ( fmt . Sprintf (" STR ", n . Left , n )) # t . Fail () # return true # } # if ! tree . IsNil ( n . Right ) && n . Right . Key <= n . Key { # t . Log ( fmt . Sprintf (" STR ", n . Right , n )) # t . Fail () # return true # } # if debug { # fmt . Println ( n ) # } # * nodeCnt ++ # return false # }
n := len ( A ) # if n == 0 { # return A # } # abs := func ( num int ) int { return int ( math . Abs ( float 6 4 ( num ))) } # ans := make ([] int , n ) # i , j , k := 0 , n - 1 , n - 1 # for i <= j { # if abs ( A [ i ]) > abs ( A [ j ]) { # ans [ k ] = A [ i ] * A [ i ] # i ++ # } else { # ans [ k ] = A [ j ] * A [ j ] # j -- # } # k -- # } # return ans
t . Parallel () # for _ , tc := range testcases { # if denoms := EgyptianFractions ( tc . numerator , tc . denominator ); ! reflect . DeepEqual ( tc . denominators , denoms ) { # t . Errorf (" STR ", tc . denominators , denoms ) # } # }
nums 1 := [] int { 2 } # nums 2 := [] int {} # merge ( nums 1 , 1 , nums 2 , 0 ) # fmt . Println ( nums 1 )
result := 0 # for num != 0 { # result ++ # num = num & ( num - 1 ) # } # # return result
qs := [] question 4 4 8 { # # { # para 4 4 8 {[] int { 4 , 3 , 2 , 7 , 8 , 2 , 3 , 1 }}, # ans 4 4 8 {[] int { 5 , 6 }}, # }, # # { # para 4 4 8 {[] int { 4 , 3 , 2 , 1 0 , 9 , 2 , 3 , 1 , 1 , 1 , 1 }}, # ans 4 4 8 {[] int { 5 , 6 , 7 , 8 , 1 1 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 4 8 , q . para 4 4 8 # fmt . Printf (" STR ", p , findDisappearedNumbers ( p . one )) # } # fmt . Printf (" STR ")
flag . Parse () # roots := flag . Args () # if len ( roots ) == 0 { # roots = [] string {" STR "} # } # # fileSizes := make ( chan int 6 4 ) # go func () { # for _ , root := range roots { # walkDir ( root , fileSizes ) # } # close ( fileSizes ) # }() # # var nfiles , nbytes int 6 4 # for size := range fileSizes { # nfiles ++ # nbytes += size # } # printDiskUsage ( nfiles , nbytes )
return toString [ t ]
for step := len ( nums ) / 2 ; step > 0 ; step /= 2 { # for i := step ; i < len ( nums ); i ++ { # for j := i - step ; j >= 0 && nums [ j + step ] < nums [ j ]; j -= step { # nums [ j ], nums [ j + step ] = nums [ j + step ], nums [ j ] # } # } # } # return nums
var tests = [] struct { # tree * TreeNode # vals [] int # }{ # { newTree ( 1 , 2 , 3 , nil , 5 , nil , 4 ), [] int { 1 , 3 , 4 }}, # { newTree ( 1 , 2 , 3 , 4 , 5 , nil , 6 , nil , 7 , nil , nil , 8 , nil , nil , 9 , nil , nil , nil , 1 0 ), [] int { 1 , 3 , 6 , 8 , 9 , 1 0 }}, # } # # for _ , tt := range tests { # vals := rightSideView ( tt . tree ) # if reflect . DeepEqual ( vals , tt . vals ) == false { # t . Errorf (" STR ", tt . tree , vals , tt . vals ) # } # }
nodes := [] int { # 1 , 2 , 3 , 4 , 5 , 6 , # } # # edges := [][] bool { # { false , true , true , false , false , false }, # { true , false , false , true , false , false }, # { true , false , false , true , false , false }, # { false , true , true , false , true , false }, # { false , false , false , true , false , true }, # { false , false , false , false , true , false }, # } # start := 1 # end := 6 # route , _ := dfs ( start , end , nodes , edges ) # fmt . Println ( route )
if target < 0 { # target = - target # } # k := 0 # for target > 0 { # k ++ # target -= k # } # if target % 2 == 0 { # return k # } # return k + 1 + k % 2
if mod == 1 { # return 0 , nil # } # # if exponent < 0 { # return - 1 , ErrorNegativeExponent # } # _ , err := Multiply 6 4 BitInt ( mod - 1 , mod - 1 ) # # if err != nil { # return - 1 , err # } # # var result int 6 4 = 1 # # base = base % mod # # for exponent > 0 { # if exponent % 2 == 1 { # result = ( result * base ) % mod # } # exponent = exponent >> 1 # base = ( base * base ) % mod # } # return result , nil
for n := 0 ; n < 3 2 ; n ++ { # square [ n ] = gf 2 MatrixTimes ( mat , mat [ n ]) # }
return n . Ns == nil
n := len ( p ) # destination := n * n # # squares := make ([] int , 4 0 0 ) # isChecked := [ 4 0 1 ] bool {} # # squares [ 0 ] = 1 # isChecked [ 1 ] = true # # steps := 0 # # for len ( squares ) > 0 { # steps ++ # size := len ( squares ) # for j := 0 ; j < size ; j ++ { # s := squares [ j ] # for i := 1 ; i <= 6 ; i ++ { # si := s + i # x , y := position ( si , n ) # if p [ x ][ y ] != - 1 { # isChecked [ si ] = true # si = p [ x ][ y ] # } # if si == destination { # return steps # } # if ! isChecked [ si ] { # squares = append ( squares , si ) # isChecked [ si ] = true # } # } # } # squares = squares [ size :] # } # # return - 1
return & linkLoop { # Head : & linkLoopNode {}, # }
return bindataRead ( # _dataCustomersJson , # " STR ", # )
m := len ( matrix ) # if m == 0 { # return 0 # } # n := len ( matrix [ 0 ]) # if n == 0 { # return 0 # } # # maxEdge := 0 # dp := make ([][] int , m + 1 ) # for i := range dp { # dp [ i ] = make ([] int , n + 1 ) # } # # for i := 1 ; i <= m ; i ++ { # for j := 1 ; j <= n ; j ++ { # if matrix [ i - 1 ][ j - 1 ] == ' 1 ' { # dp [ i ][ j ] = 1 + min ( dp [ i - 1 ][ j - 1 ], min ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ])) # maxEdge = max ( maxEdge , dp [ i ][ j ]) # } # } # } # # return maxEdge * maxEdge
return x * y
if len ( a ) != len ( b ) { # return false # } # for i , v := range a { # if v != b [ i ] { # return false # } # } # return true
if len ( s ) <= 1 { # return s # } # # i := getIndex ( s + " STR " + reverse ( s )) # # return reverse ( s [ i :]) + s
sorted := make ([] int , 0 , m + n ) # p , q := 0 , 0 # for { # if p == m { # sorted = append ( sorted , nums 2 [ q :]...) # break # } # if q == n { # sorted = append ( sorted , nums 1 [ p :]...) # break # } # if nums 1 [ p ] < nums 2 [ q ] { # sorted = append ( sorted , nums 1 [ p ]) # p ++ # } else { # sorted = append ( sorted , nums 2 [ q ]) # q ++ # } # } # copy ( nums 1 , sorted )
freq := make ( map [ rune ] int ) # for _ , r := range s { # freq [ r ]++ # } # type frequency struct { # r rune # count int # } # letters := make ([]* frequency , 0 , len ( freq )) # for letter , count := range freq { # letters = append ( letters , & frequency { letter , count }) # } # sort . Slice ( letters , func ( i , j int ) bool { # return letters [ i ]. count > letters [ j ]. count # }) # var sb strings . Builder # for len ( letters ) != 0 { # if len ( letters ) == 1 && letters [ 0 ]. count > 1 { # return " STR " # } # for _ , f := range letters { # sb . WriteRune ( f . r ) # f . count -- # } # for len ( letters ) != 0 && letters [ len ( letters )- 1 ]. count == 0 { # letters = letters [: len ( letters )- 1 ] # } # } # return sb . String ()
n := len ( A ) # # for i := n - 2 ; i >= 0 ; i -- { # A [ i ] += A [ i + 1 ] # } # # # mem := [ 1 0 1 ][ 3 3 ] int {} # # var dp func ( int , int ) int # dp = func ( i , m int ) int { # if i + 2 * m >= n { # return A [ i ] # } # if mem [ i ][ m ] > 0 { # return mem [ i ][ m ] # } # res := 0 # for x := 1 ; x <= 2 * m ; x ++ { # res = max ( # res , # A [ i ]- dp ( i + x , max ( m , x )), # ) # } # mem [ i ][ m ] = res # return res # } # # return dp ( 0 , 1 )
if n <= 2 { # return n # } # # var dp [ 2 ] int # dp [ 0 ], dp [ 1 ] = 1 , 2 # for i := 2 ; i < n ; i ++ { # dp [ i % 2 ] = dp [ i % 2 ] + dp [( i - 1 )% 2 ] # } # # return dp [( n - 1 )% 2 ]
email = strings . TrimSpace ( email ) # email = strings . ToLower ( email ) # # h := md 5 . New () # io . WriteString ( h , email ) # finalBytes := h . Sum ( nil ) # finalString := hex . EncodeToString ( finalBytes ) # return finalString
tests := [...] testType { # { # in : " STR ", # want : false , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : false , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : false , # }, { # in : " STR ", # want : true , # }, # } # for _ , tt := range tests { # got := repeatedSubstringPattern ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
tests := [...] testType { # { # in : 3 , # want : 2 , # }, # { # in : 7 , # want : 3 , # }, # { # in : 8 , # want : 1 , # }, # { # in : 0 x 5 5 5 5 , # want : 8 , # }, # } # for _ , tt := range tests { # got := hammingWeight ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
return bindataRead ( # _assetsHomeCatJpg , # " STR ", # )
b . table = make ( map [ string ]* entry , capacity ) # b . priorityQueue = make ([]* entry , 0 , capacity ) # b . lruList . Init () # b . freeList . Init () # heap . Init (& b . priorityQueue ) # # arrayOfEntries := make ([] entry , capacity ) # for i := uint ( 0 ); i < capacity ; i ++ { # e := & arrayOfEntries [ i ] # e . element . Value = e # e . index = - 1 # b . freeList . PushElementBack (& e . element ) # }
list . rear = nil
h := newLinkedHeap () # benchmarkHeap ( b , h )
close ( p . work ) # p . wg . Wait ()
res := 0 # factor := 1 # size := len ( s ) # for i := 0 ; i < size ; i ++ { # if s [ i ] == '(' { # factor *= 2 # } else { # factor /= 2 # } # if s [ i ] == '(' && s [ i + 1 ] == ')' { # res += factor / 2 # } # } # return res
qs := [] question 4 5 4 { # # { # para 4 5 4 {[] int { 1 , 2 }, [] int {- 2 , - 1 }, [] int {- 1 , 2 }, [] int { 0 , 2 }}, # ans 4 5 4 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 5 4 , q . para 4 5 4 # fmt . Printf (" STR ", p , fourSumCount ( p . a , p . b , p . c , p . d )) # } # fmt . Printf (" STR ")
for i := range langs { # language := langs [ i ] # if strings . EqualFold ( language . Lang , str ) { # return & language # } # } # return nil
sort . Ints ( houses ) # sort . Ints ( heaters ) # # i , ans := 0 , 0 # for _ , house := range houses { # for i < len ( heaters )- 1 && heaters [ i ]+ heaters [ i + 1 ] <= house * 2 { # i ++ # } # ans = maxInt ( ans , absInt ( heaters [ i ]- house )) # } # return ans
return h . FromHexString ( string ( b ))
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", [][] int { # { 1 0 , 1 6 }, # { 2 , 8 }, # { 1 , 6 }, # { 7 , 1 2 }, # }, 2 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := findMinArrowShots ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if n < 2 { # return false # } # for i := 2 ; i < n ; i ++ { # # if n % i == 0 { # return false # } # } # return true
tests := [...] testType { # { # in : [] int { 5 , 3 , 4 , 5 }, # want : true , # }, # { # in : [] int { 2 , 5 , 7 , 3 }, # want : true , # }, # } # for _ , tt := range tests { # got := stoneGame ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
return self . code
if N == 1 { # return 0 # } # # if K % 2 == 1 { # return kthGrammar ( N - 1 , ( K + 1 )/ 2 ) # } # # return opposite ( kthGrammar ( N - 1 , K / 2 ))
tests := [...] testType { # { # a : " STR ", # b : " STR ", # want : true , # }, # { # a : " STR ", # b : " STR ", # want : true , # }, # { # a : " STR ", # b : " STR ", # want : false , # }, # { # a : " STR ", # b : " STR ", # want : true , # }, # { # a : " STR ", # b : " STR ", # want : false , # }, # { # a : " STR ", # b : " STR ", # want : false , # }, # { # a : " STR ", # b : " STR ", # want : false , # }, # } # for _ , tt := range tests { # got := buddyStrings ( tt . a , tt . b ) # if got != tt . want { # t . Fatalf (" STR ", tt . a , tt . b , got , tt . want ) # } # }
ope := [][] int { # { 2 , 2 }, # { 3 , 3 }} # # fmt . Println ( maxCount ( 3 , 3 , ope ))
qs := [] question 2 7 4 { # # { # para 2 7 4 {[] int { 3 , 6 , 9 , 1 }}, # ans 2 7 4 { 3 }, # }, # { # para 2 7 4 {[] int { 1 }}, # ans 2 7 4 { 1 }, # }, # # { # para 2 7 4 {[] int {}}, # ans 2 7 4 { 0 }, # }, # # { # para 2 7 4 {[] int { 3 , 0 , 6 , 1 , 5 }}, # ans 2 7 4 { 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 7 4 , q . para 2 7 4 # fmt . Printf (" STR ", p , hIndex ( p . one )) # } # fmt . Printf (" STR ")
sort . Strings ( words ) # mp := make ( map [ string ] bool ) # var res string # for _ , word := range words { # size := len ( word ) # if size == 1 || mp [ word [: size - 1 ]] { # if size > len ( res ) { # res = word # } # mp [ word ] = true # } # } # return res
longestCenter , longestLength := 0 , 0 # for i , v := range P { # if v > longestLength { # longestLength = v # longestCenter = i # } # } # offset := ( longestCenter - longestLength ) / 2 # return s [ offset : offset + longestLength ]
for j := 1 ; j <= 2 0 ; j ++ { # if num % j != 0 { # return false # } # } # return true
n := node .(* bstElement ) # if n == nil { # return nil # } # if n . right != nil { # return t . Min ( n . right ) # } # cur := n # for cur . parent != nil && cur . parent . left != cur { # cur = cur . parent # } # return cur . parent #
var r [][] int # for i := begin ; i <= end ; i ++ { # if 1 == k { # r = append ( r , [] int { i }) # continue # } # suf := comb ( i + 1 , end , k - 1 ) # for _ , j := range suf { # r = append ( r , append ([] int { i }, j ...)) # } # } # return r
b . lock . Lock () # defer b . lock . Unlock () # # e := b . table [ key ] # if e == nil { # return nil , false # } # # if e . expire . Before ( now ) { # if b . ExpireGracePeriod == 0 || e . expire . Sub ( now ) > b . ExpireGracePeriod { # b . removeEntry ( e ) # } # return nil , false # } # # b . touchEntry ( e ) # return e . value , true
if root == nil { # return 0 # } # # result := 0 # if root . Val >= L && root . Val <= R { # result += root . Val # } # # if root . Val >= L { # result += rangeSumBST ( root . Left , L , R ) # } # # if root . Val <= R { # result += rangeSumBST ( root . Right , L , R ) # } # # return result
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", [][] int {{ 1 , 1 }, { 3 , 2 }, { 5 , 3 }, { 4 , 1 }, { 2 , 3 }, { 1 , 4 }}, 4 }, # {" STR ", [][] int {{ 1 , 1 }, { 2 , 2 }, { 3 , 3 }}, 3 }, # {" STR ", [][] int {{ 0 , 0 }, { 4 , 5 }, { 7 , 8 }, { 8 , 9 }, { 5 , 6 }, { 3 , 4 }, { 1 , 1 }}, 5 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if tree . root == nil { # return nil , false # } # currentNode := tree . root # for currentNode != nil { # if i == currentNode . data { # return currentNode , true # } else if i > currentNode . data { # currentNode = currentNode . right # } else if i < currentNode . data { # currentNode = currentNode . left # } # } # return nil , false
length := len ( nums ) # if length == 0 || length == 1 && nums [ 0 ] != target { # return [] int {- 1 , - 1 } # } # return searchRangeI ( nums , 0 , length - 1 , target )
var ( # l int # r = len ( nums ) - 1 # ) # # for l <= r { # mid := l + ( r - l )/ 2 # if target == nums [ mid ] { # return mid # } # if nums [ mid ] >= nums [ l ] && nums [ mid ] > nums [ r ] { # if target >= nums [ l ] && target < nums [ mid ] { # r = mid - 1 # } else { # l = mid + 1 # } # } else { # if target > nums [ mid ] && target <= nums [ r ] { # l = mid + 1 # } else { # r = mid - 1 # } # } # } # return - 1
if squares < 3 { # return 1 # } # # if answer , ok := memo [ squares ]; ok { # return answer # } # # total := int 6 4 ( 1 ) # # for size := 3 ; size <= squares ; size ++ { # for start := 0 ; start <= squares - size ; start ++ { # answer := int 6 4 ( 1 ) # # answer *= ways ( squares - start - size - 1 ) # # total += answer # } # # } # # memo [ squares ] = total # # return total
return & CircularBuffer { # buffer : make ([] interface {}, size ), # size : size , # avail : make ( chan bool , size ), # }
return uint 3 2 (( dev >> 8 ) & 0 xff )
tests := [...] testType { # { # in : " STR ", # want : 2 , # }, # { # in : " STR ", # want : 4 , # }, # { # in : " STR ", # want : 6 , # }, # { # in : " STR ", # want : 6 , # }, # } # for _ , tt := range tests { # got := longestValidParentheses ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
iterator := func () <- chan VertexId { # ch := make ( chan VertexId ) # go func () { # if connected , ok := g . edges [ vertex ]; ok { # for VertexId , _ := range connected { # if g . IsEdge ( vertex , VertexId ) { # ch <- VertexId # } # } # } # close ( ch ) # }() # return ch # } # # return VerticesIterable (& vertexIterableHelper { iterFunc : iterator })
ans := 0 # for ; x != 0 ; x /= 1 0 { # ans = ans * 1 0 + x % 1 0 # } # # if ans < math . MinInt 3 2 || ans > math . MaxInt 3 2 { # return 0 # } # # return ans
i , size := 0 , len ( s ) # ss := make ([] string , numRows ) # for i < size { # for j := 0 ; j < numRows && i < size ; j ++ { # ss [ j ] += string ( s [ i ]) # i ++ # } # for j := numRows - 2 ; j > 0 && i < size ; j -- { # ss [ j ] += string ( s [ i ]) # i ++ # } # } # var ret string # for j := 0 ; j < numRows ; j ++ { # ret += ss [ j ] # } # return ret
sum := big . NewInt ( 0 ) # for i := int 6 4 ( 1 ); i <= 1 0 0 0 ; i ++ { # val := big . NewInt ( i ) # sum . Add ( sum , pow ( val , i )) # } # fmt . Println (" STR ", sum . String ())
for l , r := 0 , len ( A )- 1 ; ; { # m := ( l + r ) / 2 # if A [ m ] < A [ m + 1 ] { # l = m # } else if A [ m - 1 ] > A [ m ] { # r = m # } else { # return m # } # }
max := 1 0 0 0 # sum := 0 # for i := 1 ; i < max ; i ++ { # if ( i % 3 == 0 ) || ( i % 5 == 0 ) { # sum += i # } # } # fmt . Println ( sum )
if k < 0 || len ( nums ) == 0 { # return 0 # } # var count int # m := make ( map [ int ] int , len ( nums )) # for _ , value := range nums { # m [ value ]++ # } # for key := range m { # if k == 0 && m [ key ] > 1 { # count ++ # continue # } # if k > 0 && m [ key + k ] > 0 { # count ++ # } # } # return count
parentMap , countMap := make ( map [ int ] int ), make ( map [ int ] int ) # for _ , num := range nums { # if _ , exists := parentMap [ num ]; exists { # continue # } # # parentMap [ num ], countMap [ num ] = num , 1 # neighbors := [ 2 ] int { num - 1 , num + 1 } # for _ , n := range neighbors { # if _ , exists := parentMap [ n ]; exists { # count 1 := countMap [ getParent 1 2 8 ( n , parentMap )] # count 2 := countMap [ getParent 1 2 8 ( num , parentMap )] # # union 1 2 8 ( n , num , parentMap ) # countMap [ getParent 1 2 8 ( num , parentMap )] = count 1 + count 2 # } # } # } # # max := 0 # for _ , count := range countMap { # if count > max { # max = count # } # } # # return max
sort . Ints ( people ) # # thin , fat := 0 , len ( people )- 1 # # res := 0 # # for thin <= fat { # if people [ thin ]+ people [ fat ] <= limit { # thin ++ # } # fat -- # res ++ # } # # return res
tests := [...] testType { # { # in : [] int { 1 , 8 , 6 , 2 , 5 , 4 , 8 , 3 , 7 }, # want : 4 9 , # }, # { # in : [] int { 1 , 8 , 6 , 3 0 , 2 0 , 6 , 9 , 1 0 , 1 }, # want : 4 8 , # }, # } # for _ , tt := range tests { # got := maxArea ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
count , k := make ([] int , 1 2 8 ), len ( s )/ 4 # for _ , v := range s { # count [ int ( v )]++ # } # left , right , res := 0 , - 1 , len ( s ) # for left < len ( s ) { # if count [' Q '] > k || count [' W '] > k || count [' E '] > k || count [' R '] > k { # if right + 1 < len ( s ) { # right ++ # count [ s [ right ]]-- # } else { # break # } # } else { # res = min ( res , right - left + 1 ) # count [ s [ left ]]++ # left ++ # } # } # return res
http . HandleFunc (" STR ", handler )
pairs := [...][ 2 ] int {{ 1 5 , 2 6 }, { 1 0 0 0 , 1 3 6 6 }} # for _ , pair := range pairs { # in , out := pair [ 0 ], pair [ 1 ] # if x := p 1 6 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # } # }
n := len ( matrix ) # # l , r := matrix [ 0 ][ 0 ], matrix [ n - 1 ][ n - 1 ] # for l < r { # m := ( l + r ) / 2 # count := 0 # for i := 0 ; i < n ; i ++ { # j := n - 1 # for j >= 0 && matrix [ i ][ j ] > m { # j -- # } # count += j + 1 # } # # if count < k { # l = m + 1 # } else { # r = m # } # } # return l
tests := [...] testType { # { # m : 3 , # n : 3 , # ops : [][] int { # { 2 , 2 }, # { 3 , 3 }, # }, # want : 4 , # }, # } # for _ , tt := range tests { # got := maxCount ( tt . m , tt . n , tt . ops ) # if got != tt . want { # t . Fatalf (" STR ", tt . m , got , tt . want ) # } # }
t . Parallel () # for _ , tc := range testcases { # if isPartite := IsBipartiteGraph ( tc . g ); isPartite != tc . isPartite { # t . Errorf (" STR ", tc . isPartite , isPartite ) # } # }
var i int # length := len ( nums ) # # if length <= 1 { # return # } # # for i = length - 1 ; i >= 1 ; i -- { # if nums [ i ] > nums [ i - 1 ] { # break # } # } # # if i > 0 { # sort . Ints ( nums [ i :]) # for j := i - 1 ; j < length ; j ++ { # if nums [ j ] > nums [ i - 1 ] { # nums [ i - 1 ], nums [ j ] = nums [ j ], nums [ i - 1 ] # return # } # } # } # # sort . Ints ( nums ) #
return LoadUint 6 4 (& r . Reg )
var tests = [] struct { # number int # title string # }{ # { 1 , " STR "}, # { 2 8 , " STR "}, # { 7 0 1 , " STR "}, # } # # for _ , tt := range tests { # title := convertToTitle ( tt . number ) # if title != tt . title { # t . Errorf (" STR ", tt . number , title , tt . title ) # } # }
empty := countBucket {} # for i , _ := range ss . olist { # delete ( ss . hash , ss . olist [ i ]. key ) # ss . olist [ i ] = empty # }
t . Parallel () # # for _ , tc := range testcases { # result := EloGames ( tc . scores , tc . kFactor , tc . matches ) # for i := range result { # result [ i ] = math . Round ( result [ i ]* tc . tolerance ) / tc . tolerance # } # # if ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
l . insert ( e , & l . root )
if root == nil { # return 0 # } # # max := height ( root . Left ) # if h := height ( root . Right ); h > max { # max = h # } # return max + 1
qs := [] question 5 9 8 { # # { # para 5 9 8 { 3 , 3 , [][] int {{ 2 , 2 }, { 3 , 3 }}}, # ans 5 9 8 { 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 9 8 , q . para 5 9 8 # fmt . Printf (" STR ", p , maxCount ( p . m , p . n , p . ops )) # } # fmt . Printf (" STR ")
var tests = [] struct { # nums [] int # target int # indices [] int # }{ # {[] int { 2 , 7 , 1 1 , 1 5 }, 9 , [] int { 0 , 1 }}, # {[] int { 2 , 3 , 4 , 6 }, 6 , [] int { 0 , 2 }}, # {[] int { 2 , 3 , 4 , 7 }, 8 , nil }, # { nil , 8 , nil }, # } # # for _ , tt := range tests { # indices := twoSum ( tt . nums , tt . target ) # if reflect . DeepEqual ( indices , tt . indices ) == false { # t . Errorf (" STR ", tt . nums , tt . target , indices , tt . indices ) # } # }
if isSquare ( n ) { # return 1 # } # # for n % 4 == 0 { # n /= 4 # } # # if n % 8 == 7 { # return 4 # } # for i := 1 ; i <= mySqrt ( n ); i ++ { # if isSquare ( n - i * i ) { # return 2 # } # } # return 3
if N < 3 { # return N # } else if N == 3 { # return 5 # } # mod := 1 0 0 0 0 0 0 0 0 7 # dp := make ([] int , N + 1 ) # dp [ 1 ], dp [ 2 ], dp [ 3 ] = 1 , 2 , 5 # for i := 4 ; i <= N ; i ++ { # dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 3 ] # dp [ i ] %= mod # } # return dp [ N ]
stack := [] byte {} # for i := range num { # digit := num [ i ] # for k > 0 && len ( stack ) > 0 && digit < stack [ len ( stack )- 1 ] { # stack = stack [: len ( stack )- 1 ] # k -- # } # stack = append ( stack , digit ) # } # stack = stack [: len ( stack )- k ] # ans := strings . TrimLeft ( string ( stack ), " STR ") # if ans == " STR " { # ans = " STR " # } # return ans
if e . element . list != & b . freeList { # panic (" STR ") # } # # if ! e . expire . IsZero () { # heap . Push (& b . priorityQueue , e ) # } # b . freeList . Remove (& e . element ) # b . lruList . PushElementFront (& e . element ) # b . table [ e . key ] = e
in := make ([] int , N ) # out := make ([] int , N ) # # for _ , pair := range trust { # out [ pair [ 0 ]- 1 ]++ # in [ pair [ 1 ]- 1 ]++ # } # # for i := 0 ; i < N ; i ++ { # if in [ i ] == N - 1 && out [ i ] == 0 { # return i + 1 # } # } # # return - 1
cases := [] struct { # name string # inputs int # expect int # }{ # {" STR ", 2 , 1 }, # {" STR ", 3 , 2 }, # {" STR ", 4 , 3 }, # {" STR ", 0 , 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
return xtime . Unix ( int 6 4 ( jt ), 0 ), nil
if len ( name ) == 0 && len ( typed ) == 0 { # return true # } # if ( len ( name ) == 0 && len ( typed ) != 0 ) || ( len ( name ) != 0 && len ( typed ) == 0 ) { # return false # } # # j := 0 # for i := 0 ; i < len ( name ); i ++ { # if j < len ( typed ) && name [ i ] == typed [ j ] { # j ++ # continue # } else { # if i > 0 && j < len ( typed ) && name [ i - 1 ] == typed [ j ] { # j ++ # i -- # } else { # return false # } # } # } # return true
var i , j , tmp int # for i = 1 ; i < len ( arr ); i ++ { # tmp = arr [ i ] # for j = i ; j > 0 && arr [ j - 1 ] > tmp ; j -- { # arr [ j ] = arr [ j - 1 ] # } # arr [ j ] = tmp # } # return arr
res = [][] string {} # if len ( s ) < 1 { # return res # } # helper ( s , 0 , [] string {}) # return res
if from == to { # return errors . New (" STR ") # } # # if ! g . CheckVertex ( from ) || ! g . CheckVertex ( to ) { # return errors . New (" STR ") # } # # i , _ := g . edges [ from ][ to ] # j , _ := g . edges [ to ][ from ] # # if i > 0 || j > 0 { # return errors . New (" STR ") # } # # g . TouchVertex ( from ) # g . TouchVertex ( to ) # # g . edges [ from ][ to ] = weight # # if ! g . isDirected { # g . edges [ to ][ from ] = weight # } # # g . edgesCount ++ # # return nil
i := 0 # defer fmt . Println (" STR ", i ) # defer fmt . Println (" STR ") # defer fmt . Println (" STR ") # i ++ # fmt . Println (" STR ", i )
maxIndex := [ 2 6 ] int {} # for i , b := range S { # maxIndex [ b -' a '] = i # } # # begin := 0 # end := maxIndex [ S [ begin ]-' a '] # res := make ([] int , 0 , len ( S )) # # for i , b := range S { # if i < end { # end = max ( end , maxIndex [ b -' a ']) # continue # } # # res = append ( res , i - begin + 1 ) # begin = i + 1 # if begin < len ( S ) { # end = maxIndex [ S [ begin ]-' a '] # } # } # # return res
FirstNumber := 1 # SecondNumber := 2 # nextNumber := 0 # sum := SecondNumber # for ; nextNumber < 4 0 0 0 0 0 0 ; { # nextNumber = FirstNumber + SecondNumber # if ( nextNumber % 2 == 0 ) { # sum = sum + nextNumber # } # FirstNumber = SecondNumber # SecondNumber = nextNumber # } # fmt . Println (" STR ", sum ," STR ")
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", # [][] int { # { 2 }, # { 3 , 4 }, # { 6 , 5 , 7 }, # { 4 , 1 , 8 , 3 }, # }, # 1 1 }, # {" STR ", # [][] int { # { 1 }, # { 2 , 3 }, # }, # 3 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := minimumTotal ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
timeDelta := now . Sub ( r . lastTimestamp ) # return r . Ewma . Update ( nanosec / float 6 4 ( timeDelta . Nanoseconds ()), now )
if list . head == nil { # return false # } # if list . head . data == i { # list . head = list . head . next # return true # } # current := list . head # for current . next != nil { # if current . next . data == i { # current . next = current . next . next # return true # } # current = current . next # } # return false
mySet := make ( map [ int ] int , 0 ) # # for _ , v := range candies { # mySet [ v ]++ # } # # if len ( mySet ) >= len ( candies )/ 2 { # return len ( candies ) / 2 # } # return len ( mySet )
a := [] float 6 4 { 1 , 2 , 3 , 4 , 5 , 6 } # A := MakeMatrix ( a , 3 , 2 ) # # if A . cols != 2 || # A . rows != 3 || # ! FloatArrayEquals ( A . Elements , a ) { # t . Error () # }
count := 0 # for _ , c := range word { # if unicode . IsUpper ( c ) { # count ++ # } # } # return count == 0 || count == len ( word ) || ( count == 1 && unicode . IsUpper ( rune ( word [ 0 ])))
p . mu . Lock () # active := p . active # p . mu . Unlock () # return active
select { # case r , ok := <- p . resources : # log . Println (" STR ", " STR ") # if ! ok { # return nil , ErrPoolClosed # } # return r , nil # # default : # log . Println (" STR ", " STR ") # return p . factory () # }
err := ioutil . WriteFile ( path , [] byte ( content ), 0 7 5 5 ) # if err != nil { # log . Fatal ( err ) # }
tree := New ( compare ) # # tree . Insert ( 1 ) # tree . Insert ( 2 ) # tree . Insert ( 3 ) # # findTree := tree . Search ( 2 ) # if findTree . node != 2 { # t . Error (" STR ") # } # # findNilTree := tree . Search ( 1 0 0 ) # # if findNilTree != nil { # t . Error (" STR ") # }
l := new ( ListNode ) # n := l # # var extra int # for l 1 != nil || l 2 != nil { # n . Next = new ( ListNode ) # n = n . Next # # if l 1 != nil { # extra += l 1 . Val # l 1 = l 1 . Next # } # if l 2 != nil { # extra += l 2 . Val # l 2 = l 2 . Next # } # # n . Val = extra % 1 0 # extra /= 1 0 # } # if extra > 0 { # n . Next = & ListNode { Val : extra } # } # # return l . Next
empty := 0 # hold := - 1 << 6 3 # # for _ , p := range prices { # temp := empty # empty = max ( empty , hold + p ) # hold = max ( hold , temp - p - fee ) # } # # return empty
for _ , tt := range tests { # t . Run ( tt . name , func ( t * testing . T ) { # if got := largestOverlap ( tt . args . A , tt . args . B ); got != tt . want { # t . Errorf (" STR ", got , tt . want ) # } # }) # }
tests := [...] testType { # { # in : 5 , # want : 2 , # }, # { # in : 7 , # want : 0 , # }, # { # in : 1 0 , # want : 5 , # }, # { # in : 0 , # want : 1 , # }, # } # for _ , tt := range tests { # got := bitwiseComplement ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
syscall . Exit ( code )
if len ( input ) == 0 { # return true # } # # if len ( input )% 2 != 0 { # return false # } # # var stack [] byte # # for i := 0 ; i < len ( input ); i ++ { # if input [ i ] == " STR " || input [ i ] == " STR " || input [ i ] == " STR " { # stack = append ( stack , input [ i ]) # } else { # if len ( stack ) > 0 { # pair := string ( stack [ len ( stack )- 1 ]) + string ( input [ i ]) # stack = stack [: len ( stack )- 1 ] # # if pair != " STR " && pair != " STR " && pair != " STR " { # return false # } # } else { # return false # } # } # } # # return len ( stack ) == 0
qs := [] question 1 2 0 8 { # # { # para 1 2 0 8 {" STR ", " STR ", 3 }, # ans 1 2 0 8 { 3 }, # }, # # { # para 1 2 0 8 {" STR ", " STR ", 3 }, # ans 1 2 0 8 { 1 }, # }, # # { # para 1 2 0 8 {" STR ", " STR ", 0 }, # ans 1 2 0 8 { 1 }, # }, # # { # para 1 2 0 8 {" STR ", " STR ", 1 1 }, # ans 1 2 0 8 { 3 }, # }, # # { # para 1 2 0 8 {" STR ", " STR ", 1 9 }, # ans 1 2 0 8 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 0 8 , q . para 1 2 0 8 # fmt . Printf (" STR ", p , equalSubstring ( p . s , p . t , p . maxCost )) # } # fmt . Printf (" STR ")
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 2 4 1 2 3 , 1 3 4 2 5 , 1 2 3 , 6 5 , 1 , 5 4 3 6 2 , 1 3 4 , 6 5 4 3 , 2 1 3 }, 3 }, # {" STR ", [] int {}, 0 }, # {" STR ", [] int { 4 2 5 3 6 2 6 7 5 6 , 3 2 4 5 8 7 6 , 2 3 4 5 8 9 7 , 2 3 4 9 0 }, 1 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if len ( sorted ) == 0 { # return nil # } # mid := len ( sorted ) / 2 # root := & BST { Value : sorted [ mid ]} # root . Left = SortedSliceToBST ( sorted [: mid ]) # root . Right = SortedSliceToBST ( sorted [ mid + 1 :]) # return root
negative := false # if num < 0 { # negative = true # num = - num # } # # bf := bytes . NewBufferString (" STR ") # for num >= 7 { # mod := num % 7 # num /= 7 # bf . WriteByte ( byte ( mod ) + 4 8 ) # } # # bf . WriteByte ( byte ( num ) + 4 8 ) # if negative { # bf . WriteByte ('-') # } # # bs := bf . Bytes () # for s , e := 0 , len ( bs )- 1 ; s < e ; s , e = s + 1 , e - 1 { # bs [ s ], bs [ e ] = bs [ e ], bs [ s ] # } # return string ( bs )
s = strings . ToLower ( s ) # i , j := 0 , len ( s )- 1 # for i < j { # for i < j && ! isChar ( s [ i ]) { # i ++ # } # for i < j && ! isChar ( s [ j ]) { # j -- # } # if s [ i ] != s [ j ] { # return false # } # i ++ # j -- # } # return true
n := len ( nums ) # tmp := make ([] int , n ) # copy ( tmp , nums ) # for i := 0 ; i < n ; i ++ { # nums [( i + k )% n ] = tmp [ i ] # }
random := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # array := make ([] int , random . Intn ( 1 0 0 - 1 0 )+ 1 0 ) # for i := range array { # array [ i ] = random . Intn ( 1 0 0 ) # } # SortArray ( array ) # for _ , value := range array { # result := ExponentialSearch ( array , value ) # if result == - 1 { # t . Fail () # } # }
t . Parallel () # for _ , tc := range testcases { # if result := MinimumPartitionPalindrome ( tc . input ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
obj := Constructor 7 3 2 () # fmt . Printf (" STR ", obj . Book ( 1 0 , 2 0 )) # fmt . Printf (" STR ", obj . Book ( 5 0 , 6 0 )) # fmt . Printf (" STR ", obj . Book ( 1 0 , 4 0 )) # fmt . Printf (" STR ", obj . Book ( 5 , 1 5 )) # fmt . Printf (" STR ", obj . Book ( 5 , 1 0 )) # fmt . Printf (" STR ", obj . Book ( 2 5 , 5 5 ))
if a == nil && b == nil { # return true # } # # if len ( a ) != len ( b ) { # return false # } # # for i := range a { # if a [ i ] != b [ i ] { # return false # } # } # # return true
val := " STR " # for i := 1 ; i < n ; i ++ { # var ( # c int # v byte # str string # ) # for j := 0 ; j < len ( val ); j ++ { # if val [ j ] == v { # c ++ # continue # } # if c != 0 { # str += string ( c +' 0 ') + string ( v ) # } # c , v = 1 , val [ j ] # } # val = str + string ( c +' 0 ') + string ( v ) # } # return val
res := 0 # # if n != 0 { # rightMostBitInt := n & - n # nextHigherSetBitInt := n + rightMostBitInt # d := n ^ nextHigherSetBitInt # d /= rightMostBitInt # d >>= 2 # res = nextHigherSetBitInt | d # } # # return res
if len ( nums ) == 0 || len ( nums ) < k { # return make ([] int , 0 ) # } # queue := make ([] int , 0 , k ) # ans := make ([] int , len ( nums )- k + 1 ) # # for left , right := 1 - k , 0 ; right < len ( nums ); left , right = left + 1 , right + 1 { # if left > 0 && queue [ 0 ] == nums [ left - 1 ] { # queue = queue [ 1 : len ( queue )] # } # for len ( queue ) != 0 && queue [ len ( queue )- 1 ] < nums [ right ] { # queue = queue [: len ( queue )- 1 ] # } # queue = append ( queue , nums [ right ]) # if left >= 0 { # ans [ left ] = queue [ 0 ] # } # } # return ans
n := len ( intervals ) # if n == 0 { # return [] Interval {} # } else if n == 1 { # return intervals # } # sort . Slice ( intervals , func ( i , j int ) bool { # return intervals [ i ]. Start < intervals [ j ]. Start # }) # # res := [] Interval { intervals [ 0 ]} # # for _ , cur := range intervals [ 1 :] { # previous := res [ len ( res )- 1 ] # if cur . Start <= previous . End { # end := previous . End # if cur . End > end { # end = cur . End # } # res = append ( res [: len ( res )- 1 ], Interval { Start : previous . Start , End : end }) # } else { # res = append ( res , cur ) # } # } # return res
max := 9 9 9 9 # # biggestPandigital := 0 # var numberMultiplied int # for i := max ; i > 0 ; i -- { # numberMultiplied = i # for j := 1 ; len ( digits ( numberMultiplied )) <= 9 ; j ++ { # numberMultiplied = concatenMultiplication ( i , j ) # if IsPandigital ( numberMultiplied ) && numberMultiplied > biggestPandigital { # fmt . Println ( numberMultiplied ) # biggestPandigital = numberMultiplied # } # } # }
n := len ( pushed ) # s := make ([] int , 0 , n ) # i := 0 # for _ , x := range pushed { # s = append ( s , x ) # for len ( s ) != 0 && s [ len ( s )- 1 ] == popped [ i ] { # s = s [: len ( s )- 1 ] # i ++ # } # } # return i == n
testCases := [][] int { # { 1 , 2 , 3 , 1 }, # { 1 , 0 , 1 , 1 }, # { 1 , 2 , 3 , 1 , 2 , 3 }, # } # ks := [] int { 3 , 1 , 2 } # expected := [] bool { true , true , false } # # for index , nums := range testCases { # if res := containsNearbyDuplicate ( nums , ks [ index ]); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
item := req . URL . Query (). Get (" STR ") # if price , ok := db [ item ]; ok { # fmt . Fprintf ( w , " STR ", price ) # } else { # w . WriteHeader ( http . StatusNotFound ) # fmt . Fprintf ( w , " STR ", item ) # }
l , r := & maxHeap {}, & minHeap {} # heap . Init ( l ) # heap . Init ( r ) # return MedianFinder { l , r }
var buf [ 3 2 ] byte # i := len ( buf ) - 1 # for val >= 1 0 { # buf [ i ] = byte ( val % 1 0 + " STR ") # i -- # val /= 1 0 # } # buf [ i ] = byte ( val + " STR ") # return string ( buf [ i :])
if len ( nums 1 ) == 0 || len ( nums 2 ) == 0 { # return [] int {} # } # num 1 Map := make ( map [ int ] bool ) # # for i := range nums 1 { # num 1 Map [ nums 1 [ i ]] = true # } # num 2 Map := make ( map [ int ] bool ) # var res [] int # for i := range nums 2 { # if _ , ok 1 := num 1 Map [ nums 2 [ i ]]; ok 1 && ! num 2 Map [ nums 2 [ i ]] { # num 2 Map [ nums 2 [ i ]] = true # res = append ( res , nums 2 [ i ]) # } # } # return res
var ret [][] int # var nums [] int # # nums = [] int {- 1 , 0 , 1 , 2 , - 1 , - 4 } # ret = [][] int {{- 1 , - 1 , 2 }, {- 1 , 0 , 1 }} # for k , num := range threeSum ( nums ) { # for i , v := range num { # if v != ret [ k ][ i ] { # t . Fatalf (" STR ", ret ) # } # } # }
dist := make ([] int , N + 1 ) # for i := 0 ; i < len ( dist ); i ++ { # dist [ i ] = math . MaxInt 3 2 # } # dist [ K ] = 0 # for i := 0 ; i < N ; i ++ { # for _ , t := range times { # u , v , w := t [ 0 ], t [ 1 ], t [ 2 ] # if dist [ u ] != math . MaxInt 3 2 && dist [ v ] > dist [ u ]+ w { # dist [ v ] = dist [ u ] + w # } # } # } # mx := 0 # for i := 1 ; i <= N ; i ++ { # if mx < dist [ i ] { # mx = dist [ i ] # } # } # if mx == math . MaxInt 3 2 { # return - 1 # } # return mx
dat , err := ioutil . ReadFile (" STR ") # if err != nil { # panic ( err ) # } # namesList := string ( dat ) # namesList = strings . Replace ( namesList , " STR ", " STR ", - 1 ) # # names := strings . Split ( namesList , " STR ") # sort . Strings ( names ) # # namesScore := 0 # for index , name := range names { # namesScore += nameScore ( name ) * ( index + 1 ) # } # fmt . Println ( namesScore )
var matrix [][] int # # matrix = [][] int { # { 1 , 2 , 3 }, # { 4 , 5 , 6 }, # { 7 , 8 , 9 }, # } # rotate ( matrix )
curr := n # for _ , c := range s { # next , ok := curr . children [ c ] # if ! ok { # next = NewNode () # curr . children [ c ] = next # } # curr = next # } # curr . isLeaf = true
t . Parallel () # # for _ , tc := range testcases { # if result := MinimizeQux ( tc . input ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
sum := 0 # for i := 2 ; i < 9 9 9 9 9 9 ; i ++ { # if isSumOfFivePowerOfDigitsEqualToNumber ( i ) { # sum += i # } # } # # return sum
if l 1 == nil { # return l 2 # } # if l 2 == nil { # return l 1 # } # ret := & ListNode {} # if l 1 . Val <= l 2 . Val { # ret = l 1 # ret . Next = mergeTwoLists 1 ( l 1 . Next , l 2 ) # } else { # ret = l 2 # ret . Next = mergeTwoLists 1 ( l 1 , l 2 . Next ) # } # return ret
a := int ( math . Log 1 0 ( float 6 4 ( number ))) + 1 # result := 0 # for i := 1 ; i <= a ; i ++ { # result += digit ( number , i ) * int ( math . Pow 1 0 ( a - i )) # } # return result
maxans := 0 # dp := make ([] int , len ( s )) # # for i := 1 ; i < len ( s ); i ++ { # if s [ i ] == " STR " { # if s [ i - 1 ] == " STR " { # if i >= 2 { # dp [ i ] = dp [ i - 2 ] + 2 # } else { # dp [ i ] = 2 # } # } else if i - dp [ i - 1 ] > 0 && s [ i - dp [ i - 1 ]- 1 ] == " STR " { # if i - dp [ i - 1 ] >= 2 { # dp [ i ] = dp [ i - 1 ] + dp [ i - dp [ i - 1 ]- 2 ] + 2 # } else { # dp [ i ] = dp [ i - 1 ] + 2 # } # } # } # maxans = Max ( maxans , dp [ i ]) # } # return maxans
s . lock . Lock () # defer s . lock . Unlock () # # l := len ( s . nodes ) # if l == 0 { # return nil , errors . New (" STR ") # } # # node := s . nodes [ l - 1 ] # s . nodes = s . nodes [: l - 1 ] # # return node , nil
max 1 , max 2 , max 3 , min 1 , min 2 := - 1 0 0 1 , - 1 0 0 1 , - 1 0 0 1 , 1 0 0 1 , 1 0 0 1 # # for _ , v := range nums { # if v > max 1 { # max 3 = max 2 # max 2 = max 1 # max 1 = v # } else if v > max 2 { # max 3 = max 2 # max 2 = v # } else if v > max 3 { # max 3 = v # } # # if v < min 1 { # min 2 = min 1 # min 1 = v # } else if v < min 2 { # min 2 = v # } # # } # return max ( max 1 * min 1 * min 2 , max 1 * max 2 * max 3 )
h := fnv . New 6 4 a () # _ , _ = h . Write ([] byte ( fmt . Sprintf (" STR ", key ))) # # hashValue := h . Sum 6 4 () # # return ( hm . capacity - 1 ) & ( hashValue ^ ( hashValue >> 1 6 ))
arr := make ([] int , n + 1 , n + 1 ) # arr [ 0 ] = 0 # arr [ 1 ] = 1 # for x := 2 ; x <= n ; x ++ { # arr [ x ] = - 1 # } # return fibonacciDyamic ( n , arr )
* ss = Count { # olist : make ([] countBucket , size ), # hash : make ( map [ string ] uint 3 2 , size ), # } # return ss
if len ( nums ) == 0 { # return 0 # } else if len ( nums ) == 1 { # return nums [ 0 ] # } # # max := func ( m , n int ) int { # if m > n { # return m # } # # return n # } # # dp := [] int { nums [ 0 ], max ( nums [ 0 ], nums [ 1 ])} # for i := 2 ; i < len ( nums ); i ++ { # dp [ i % 2 ] = max ( dp [( i - 1 )% 2 ], nums [ i ]+ dp [ i % 2 ]) # } # # return dp [( len ( nums )- 1 )% 2 ]
t . Parallel () # for _ , tc := range testcases { # if result := CanHopToEnd ( tc . hops ); result != tc . expected { # t . Errorf (" STR ", tc . hops , tc . expected , result ) # } # }
n := NewNode () # # insertWords := [...] string { # " STR ", # " STR ", # } # checkWords := map [ string ] bool { # " STR ": false , # " STR ": false , # " STR ": true , # } # # for _ , w := range insertWords { # n . Insert ( w ) # t . Logf ( # " STR ", # w , # ) # } # # for k , v := range checkWords { # ok := n . Find ( k ) # if ok != v { # t . Fatalf ( # " STR ", # k , # map [ bool ] string { true : " STR " NOT "}[ v ], # ) # } # t . Logf ( # " STR ", # k , # map [ bool ] string { true : " STR " NOT "}[ ok ], # ) # }
if cl . Size > 0 { # if places < 0 { # multiple := cl . Size - 1 - places / cl . Size # places += multiple * cl . Size # } # places %= cl . Size # # if places > cl . Size / 2 { # places = cl . Size - places # for i := 0 ; i < places ; i ++ { # cl . Head = cl . Head . Prev # } # } else if places == 0 { # return # } else { # for i := 0 ; i < places ; i ++ { # cl . Head = cl . Head . Next # } # # } # }
s . lock . Lock () # defer s . lock . Unlock () # # return s . len
return fmt . Sprintf (" STR ", p . Name , p . Age )
if n < 2 { # return 1 # } # # rec := make ([] int , n + 1 ) # rec [ 0 ], rec [ 1 ] = 1 , 1 # # for i := 2 ; i <= n ; i ++ { # rec [ i ] = rec [ i - 1 ] + rec [ i - 2 ] # } # # return rec [ n ]
n := len ( nums ) # if n == 0 { # return 0 # } # if n == 1 { # return nums [ 0 ] # } # # tmp := nums [ 0 ] # max := tmp # for i := 1 ; i < n ; i ++ { # if tmp < 0 { # tmp = nums [ i ] # } else { # tmp += nums [ i ] # } # if max < tmp { # max = tmp # } # } # return max
return syscall . Getgid ()
cases := [] struct { # name string # arr 1 [] int # arr 2 [] int # d int # expect int # }{ # {" STR ", [] int { 4 , 5 , 8 }, [] int { 1 0 , 9 , 1 , 8 }, 2 , 2 }, # {" STR ", [] int { 1 , 4 , 2 , 3 }, [] int {- 4 , - 3 , 6 , 1 0 , 2 0 , 3 0 }, 3 , 2 }, # {" STR ", [] int { 2 , 1 , 1 0 0 , 3 }, [] int {- 5 , - 2 , 1 0 , - 3 , 7 }, 6 , 1 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . arr 1 , c . arr 2 , c . d ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . arr 1 , c . arr 2 , c . d ) # } # }) # }
if h . Count != 0 { # for i := 0 ; i < int ( h . Cap ); i ++ { # hashValue := h . hash ( key , uint 3 2 ( i )) # if h . backets [ hashValue ] != nil && h . backets [ hashValue ]. Key == key { # return h . backets [ hashValue ]. Value , h . backets [ hashValue ]. exist # } # } # } # return nil , false
l 1 := len ( board ) # if l 1 == 0 { # return # } # l 2 := len ( board [ 0 ]) # if l 2 == 0 { # return # } # visit := make ([][] bool , l 1 ) # for i := 0 ; i < l 1 ; i ++ { # visit [ i ] = make ([] bool , l 2 ) # } # for i := 0 ; i < l 1 ; i ++ { # for j := 0 ; j < l 2 ; j ++ { # if ! visit [ i ][ j ] { # helper ( board , visit , i , j ) # } # } # }
return me [ 0 ] == " STR "
if len ( intervals ) <= 1 { # return intervals # } # # sort . Slice ( intervals , func ( i , j int ) bool { # return intervals [ i ][ 0 ] <= intervals [ j ][ 0 ] # }) # # result := make ([][] int , 0 ) # cur := intervals [ 0 ] # for i := 1 ; i < len ( intervals ); i ++ { # if intervals [ i ][ 0 ] > cur [ 1 ] { # result = append ( result , cur ) # cur = intervals [ i ] # } else { # cur [ 1 ] = int ( math . Max ( float 6 4 ( cur [ 1 ]), float 6 4 ( intervals [ i ][ 1 ]))) # } # } # # result = append ( result , cur ) # return result
return Frame {}, false
dist := [ 2 0 0 ][][] int {} # for r := 0 ; r < R ; r ++ { # for c := 0 ; c < C ; c ++ { # d := abs ( r - r 0 ) + abs ( c - c 0 ) # dist [ d ] = append ( dist [ d ], [] int { r , c }) # } # } # begin , end := 0 , 0 # for d := 0 ; len ( dist [ d ]) > 0 ; d ++ { # begin , end = end , end + len ( dist [ d ]) # copy ( res [ begin : end ], dist [ d ]) # } # return res [: end ]
n , err := io . Copy ( h , r ) # if err != nil { # return err # } # if n != fSize { # return errReadSizeMismatch # } # # return nil
if max . Sign () <= 0 { # panic (" STR ") # } # n = new ( big . Int ) # n . Sub ( max , n . SetUint 6 4 ( 1 )) # bitLen := n . BitLen () # if bitLen == 0 { # return # } # k := ( bitLen + 7 ) / 8 # b := uint ( bitLen % 8 ) # if b == 0 { # b = 8 # } # # bytes := make ([] byte , k ) # # for { # _ , err = io . ReadFull ( rand , bytes ) # if err != nil { # return nil , err # } # # bytes [ 0 ] &= uint 8 ( int ( 1 << b ) - 1 ) # # n . SetBytes ( bytes ) # if n . Cmp ( max ) < 0 { # return # } # }
s := " STR " # # fmt . Println ( reverseString ( s ))
tests := [...] testType { # { # nums : [] int { 1 , 2 , 3 , 1 }, # k : 3 , # want : true , # }, # { # nums : [] int { 1 , 0 , 1 , 1 }, # k : 1 , # want : true , # }, # { # nums : [] int { 1 , 2 , 3 , 1 , 2 , 3 }, # k : 2 , # want : false , # }, # } # for _ , tt := range tests { # got := containsNearbyDuplicate ( tt . nums , tt . k ) # if got != tt . want { # t . Fatalf (" STR ", tt . nums , tt . k , got , tt . want ) # } # }
for V > 0 { # V -- # if ! isDroppedLeft ( heights , K ) && ! isDroppedRight ( heights , K ) { # heights [ K ]++ # } # } # return heights
qs := [] question 2 3 1 { # # { # para 2 3 1 { 1 }, # ans 2 3 1 { true }, # }, # # { # para 2 3 1 { 1 6 }, # ans 2 3 1 { true }, # }, # # { # para 2 3 1 { 2 1 8 }, # ans 2 3 1 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 3 1 , q . para 2 3 1 # fmt . Printf (" STR ", p , isPowerOfTwo ( p . one )) # } # fmt . Printf (" STR ")
m := map [ string ] struct {}{} # for _ , email := range emails { # n := len ( email ) # bs := strings . Builder {} # ignore := false # for i := 0 ; i < n ; i ++ { # if email [ i ] == '@' { # bs . WriteString ( email [ i :]) # break # } # if ignore || email [ i ] == '.' { # continue # } # if email [ i ] == '+' { # ignore = true # continue # } # bs . WriteByte ( email [ i ]) # } # m [ bs . String ()] = struct {}{} # } # return len ( m )
cases := [] struct { # name string # input 1 string # input 2 string # expect bool # }{ # {" STR ", " STR ", " STR ", false }, # {" STR ", " STR ", " STR ", false }, # {" STR ", " STR ", " STR ", true }, # {" STR ", " STR ", " STR ", true }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := canConstruct 2 ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 , c . input 2 ) # } # }) # }
for { # switch r := l . next (); { # case unicode . IsNumber ( r ): # case r == " STR ": # l . backup () # l . emit ( itemEnd ) # l . chomp () # return byteRangeSet # case r == eof : # l . emit ( itemEnd ) # return byteRangeSet # default : # return l . error (" STR ") # } # }
var res byte # for i := 0 ; i < len ( s ); i ++ { # res ^= s [ i ] # } # for i := 0 ; i < len ( t ); i ++ { # res ^= t [ i ] # } # return res
var s int # for _ , c := range m . cache { # s += c . Expire () # } # return s
if len ( num ) <= 1 { # return # } # # for i := len ( num ) - 1 ; i > 0 ; i -- { # if num [ i - 1 ] < num [ i ] { # j := len ( num ) - 1 # for num [ i - 1 ] >= num [ j ] { # j -- # } # # num [ j ], num [ i - 1 ] = num [ i - 1 ], num [ j ] # reverse ( num [ i :]) # fmt . Println ( num ) # return # } # # if i == 1 { # return # } # } #
words := map [ string ] struct {}{} # cap , vowel := map [ string ] string {}, map [ string ] string {} # for _ , word := range wordlist { # words [ word ] = struct {}{} # lower := strings . ToLower ( word ) # if _ , ok := cap [ lower ]; ! ok { # cap [ lower ] = word # if _ , ok = vowel [ todev ( lower )]; ! ok { # vowel [ todev ( lower )] = word # } # } # } # for i , query := range queries { # if _ , ok := words [ query ]; ok { # continue # } # lower := strings . ToLower ( query ) # if word , ok := cap [ lower ]; ok { # queries [ i ] = word # } else if word , ok = vowel [ todev ( lower )]; ok { # queries [ i ] = word # } else { # queries [ i ] = " STR " # } # } # return queries
return c . name
qs := [] question 9 8 4 { # # { # para 9 8 4 { 1 , 2 }, # ans 9 8 4 {" STR "}, # }, # # { # para 9 8 4 { 4 , 1 }, # ans 9 8 4 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 8 4 , q . para 9 8 4 # fmt . Printf (" STR ", p , strWithout 3 a 3 b ( p . a , p . b )) # } # fmt . Printf (" STR ")
var sum int # for i := start ; i < end ; i ++ { # sum += l [ i ] # } # return sum
arr := make ([] bool , 1 0 0 0 0 0 0 ) # arr [ 1 ] = true # prime := 3 # count := 1 3 # var k , tmp , localCount int # var str string # primeloop : # for { # for k = prime * 2 ; k < len ( arr ); k += prime { # arr [ k ] = true # } # for k = prime + 2 ; k < len ( arr ) && arr [ k ]; k += 2 { # } # if k < len ( arr ) { # prime = k # str = strconv . Itoa ( prime ) # if prime > 1 0 0 { # localCount = 1 # for i := 0 ; i < len ( str )- 1 ; i ++ { # str = str [ 1 :] + str [ 0 : 1 ] # tmp , _ = strconv . Atoi ( str ) # if tmp > prime { # continue primeloop # } else if ! arr [ tmp ] && tmp % 2 != 0 { # localCount ++ # } else { # continue primeloop # } # } # count += localCount # } # } else { # break # } # } # println ( count )
count := make ( map [ string ] int , len ( words )) # for _ , w := range words { # count [ w ]++ # } # # fw := make ( freWords , 0 , len ( count )) # for w , c := range count { # fw = append ( fw , & entry { # word : w , # frequence : c , # }) # } # # sort . Sort ( fw ) # # res := make ([] string , k ) # for i := 0 ; i < k ; i ++ { # res [ i ] = fw [ i ]. word # } # # return res
str 1 := " STR " # fmt . Println ( largeGroupPositions ( str 1 )) # # str 2 := " STR " # fmt . Println ( largeGroupPositions ( str 2 )) # # str 3 := " STR " # fmt . Println ( largeGroupPositions ( str 3 )) # # str 4 := " STR " # fmt . Println ( largeGroupPositions ( str 4 ))
list := NewCyclic () # fillList ( list , 3 ) # # want := 1 # got := list . Walk () # # if got . Val != want { # t . Errorf (" STR ", got ) # }
m := make ( map [ int ] struct {}) # for _ , num := range nums 1 { # m [ num ] = struct {}{} # } # # nums := make ([] int , 0 ) # for _ , num := range nums 2 { # if _ , ok := m [ num ]; ok { # nums = append ( nums , num ) # delete ( m , num ) # } # } # return nums
factorial := new ( big . Int ). MulRange ( 1 , 1 0 0 ) # bytes := factorial . Append ([] byte {}, 1 0 ) # sum := 0 # for b := range bytes { # sum += int ( bytes [ b ] - ' 0 ') # } # fmt . Println (" STR ", sum )
qs := [] question 1 0 0 3 { # # { # para 1 0 0 3 {" STR "}, # ans 1 0 0 3 { true }, # }, # # { # para 1 0 0 3 {" STR "}, # ans 1 0 0 3 { true }, # }, # # { # para 1 0 0 3 {" STR "}, # ans 1 0 0 3 { false }, # }, # # { # para 1 0 0 3 {" STR "}, # ans 1 0 0 3 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 0 3 , q . para 1 0 0 3 # fmt . Printf (" STR ", p , isValid 1 0 0 3 ( p . s )) # } # fmt . Printf (" STR ")
var v * error # return v
m := map [ string ] int {} # rets := [] string {} # for i := 0 ; i <= len ( s )- 1 0 ; i ++ { # sub := string ( s [ i : i + 1 0 ]) # m [ sub ]++ # if m [ sub ] == 2 { # rets = append ( rets , sub ) # } # } # return rets
q [ i ], q [ j ] = q [ j ], q [ i ]
runes := [] rune ( s ) # length := len ( runes ) # if length <= 1 { # return s # } # maxRune := runes [ 0 : 1 ] # for i := 0 ; i < length - 1 ; i ++ { # tmpRune := findPalindrome ( runes , i , i ) # if len ( tmpRune ) > len ( maxRune ) { # maxRune = tmpRune # } # if runes [ i ] == runes [ i + 1 ] { # tmpRune = findPalindrome ( runes , i , i + 1 ) # if len ( tmpRune ) > len ( maxRune ) { # maxRune = tmpRune # } # } # } # return string ( maxRune )
stack , j , N := [] int {}, 0 , len ( pushed ) # for _ , x := range pushed { # stack = append ( stack , x ) # fmt . Printf (" STR ", stack , j ) # for len ( stack ) != 0 && j < N && stack [ len ( stack )- 1 ] == popped [ j ] { # stack = stack [ 0 : len ( stack )- 1 ] # j ++ # } # fmt . Printf (" STR ", stack , j ) # } # return j == N
return numDistinctBytes ([] byte ( s ), [] byte ( t ))
return key 1 .( int ) < key 2 .( int )
return x != y
for prime := range sig ( a ) { # if sig ( b )[ prime ] { # return false # } # } # return true
var low , mid , high int = 0 , len ( sorted ) / 2 , len ( sorted ) # for low < high { # curr := sorted [ mid ] # switch { # case curr == target : # return mid # case inRange ( sorted [ mid : high ], target ): # low = mid # mid = ( low + high ) / 2 # default : # high = mid # mid = ( low + high ) / 2 # } # } # return - 1
if n < sumOfProperDivisors ( n ) { # return true # } # return false
ss := [] string { S } # for i := 0 ; i < len ( S ); i ++ { # if S [ i ] < ' 0 ' || S [ i ] > ' 9 ' { # for _ , s := range ss { # b := [] byte ( s ) # letterCase ( b , i ) # ss = append ( ss , string ( b )) # } # } # } # return ss
digits := convert ( N + 1 ) # bits := len ( digits ) # # noRepeat := 0 # for b := 1 ; b < bits ; b ++ { # noRepeat += 9 * count ( 9 , b - 1 ) # } # # hasSeen := make ( map [ int ] bool , 1 0 ) # for b := 0 ; b < bits ; b ++ { # d := 0 # if b == 0 { # d = 1 # } # for ; d < digits [ b ]; d ++ { # if ! hasSeen [ d ] { # noRepeat += count ( 9 - b , bits - b - 1 ) # } # } # if hasSeen [ digits [ b ]] { # break # } # hasSeen [ digits [ b ]] = true # } # return N - noRepeat
b := NewLRUCache ( 1 0 0 0 ) # for i := 0 ; i < 1 0 0 0 ; i ++ { # b . Set ( randomString ( 2 ), " STR ", expire ) # } # return b
h := & IntMaxHeap {} # heap . Init ( h ) # heap . Push ( h , 7 ) # heap . Push ( h , 3 ) # heap . Push ( h , 2 ) # heap . Push ( h , 1 ) # heap . Push ( h , 5 ) # heap . Push ( h , 5 ) # heap . Push ( h , 6 ) # heap . Push ( h , 7 ) # fmt . Printf (" STR ", (* h )) # # # for h . Len () > 0 { # fmt . Printf (" STR ", heap . Pop ( h )) # }
return MyCalendar { # books : make ([] seg , 0 ), # }
var buf bytes . Buffer # buf . WriteByte (" STR ") # for i , word := range s . words { # if word == 0 { # continue # } # for j := 0 ; j < 6 4 ; j ++ { # if word &( 1 << uint ( j )) != 0 { # if buf . Len () > len (" STR ") { # buf . WriteByte (" STR ") # } # fmt . Fprintf (& buf , " STR ", 6 4 * i + j ) # } # } # } # buf . WriteByte (" STR ") # return buf . String ()
matrix := [][] int { # { 5 , 1 , 9 , 1 1 }, # { 2 , 4 , 8 , 1 0 }, # { 1 3 , 3 , 6 , 7 }, # { 1 5 , 1 4 , 1 2 , 1 6 }, # } # matrix = rotate ( matrix ) # for _ , nums := range matrix { # for _ , num := range nums { # fmt . Print ( num , " STR ") # } # fmt . Println () # }
return MyQueue { # list : list . New (), # }
res := sizeOfLargestBST ( tree ) # return res . AnsPtr
sort . Ints ( candidates ) # var res [][] int # dfs ( candidates , nil , target , 0 , & res ) # return res
tests := [...] testType { # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : false , # }, # } # for _ , tt := range tests { # got := checkRecord ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
for i := 1 ; i < len ( arr ); i ++ { # value := arr [ i ] # j := i - 1 # for j >= 0 && arr [ j ] > value { # arr [ j + 1 ] = arr [ j ] # j = j - 1 # } # arr [ j + 1 ] = value # }
var nums [] int # var ret bool # # nums = [] int { 1 , 2 , 3 , 1 } # ret = true # if ret != containsDuplicate ( nums ) { # t . Fatalf (" STR ", ret ) # } # # nums = [] int { 1 , 2 , 3 , 4 } # ret = false # if ret != containsDuplicate ( nums ) { # t . Fatalf (" STR ", ret ) # }
switch { # case head . Left == nil && head . Right == nil : # return head . Value # case head . Left != nil && head . Right != nil : # left := head . Value + MinPathSum ( head . Left ) # right := head . Value + MinPathSum ( head . Right ) # return min ( left , right ) # case head . Left != nil : # return head . Value + MinPathSum ( head . Left ) # default : # return head . Value + MinPathSum ( head . Right ) # }
sets := make ([][] int , 1 , 1 << uint ( len ( nums ))) # for _ , num := range nums { # for _ , set := range sets { # s := make ([] int , len ( set ), len ( set )+ 1 ) # copy ( s , set ) # sets = append ( sets , append ( s , num )) # } # } # return sets
out := 1 0 0 # if x := p 3 3 (); x != out { # t . Errorf (" STR ", x , out ) # }
steps := countSteps ([] int { 0 , 0 }, target ) # for _ , g := range ghosts { # if steps >= countSteps ( g , target ) { # return false # } # } # return true
t . Parallel () # for _ , tc := range testcases { # if result := CourseOrder ( tc . prereqs ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
if nil == root || k <= 0 { # return nil # } # # var target * BinaryTreeNode # if root . left != nil { # target = kthNode ( root . left , k ) # } # # if target == nil { # if 1 == k { # target = root # } else { # k -- # } # } # # if target == nil && root . right != nil { # target = kthNode ( root . right , k ) # } # return target
nums := [] int { 0 , 0 , 1 , 2 } # fmt . Println ( dominantIndex ( nums ))
if root == nil { # return nil # } # if root . Val < L { # return trimBST ( root . Right , L , R ) # } # if root . Val > R { # return trimBST ( root . Left , L , R ) # } # root . Left = trimBST ( root . Left , L , R ) # root . Right = trimBST ( root . Right , L , R ) # return root
length := len ( matrix ) # for i := 0 ; 2 * i < length - 1 ; i ++ { # for j := i ; j < length - i - 1 ; j ++ { # matrix [ i ][ j ], matrix [ j ][ length - i - 1 ], matrix [ length - i - 1 ][ length - j - 1 ], matrix [ length - j - 1 ][ i ] = # matrix [ length - j - 1 ][ i ], matrix [ i ][ j ], matrix [ j ][ length - i - 1 ], matrix [ length - i - 1 ][ length - j - 1 ] # } # }
p = len ( postorder ) - 1 # idxMap = make ( map [ int ] int ) # for i , v := range inorder { # idxMap [ v ] = i # } # return build ( 0 , len ( inorder ) - 1 , postorder )
sum := 0 # for i := 0 ; i < 1 0 0 0 ; i ++ { # if ( i % 3 == 0 ) || ( i % 5 == 0 ) { # sum += i # } # } # fmt . Print ( sum , " STR ")
qs := [] question 8 5 6 { # { # para 8 5 6 {" STR "}, # ans 8 5 6 { 1 }, # }, # # { # para 8 5 6 {" STR "}, # ans 8 5 6 { 2 }, # }, # # { # para 8 5 6 {" STR "}, # ans 8 5 6 { 2 }, # }, # # { # para 8 5 6 {" STR "}, # ans 8 5 6 { 6 }, # }, # # { # para 8 5 6 {" STR "}, # ans 8 5 6 { 3 }, # }, # # { # para 8 5 6 {" STR "}, # ans 8 5 6 { 8 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 5 6 , q . para 8 5 6 # fmt . Printf (" STR ", p , scoreOfParentheses ( p . one )) # } # fmt . Printf (" STR ")
const ( # xmin , ymin , xmax , ymax = - 2 , - 2 , + 2 , + 2 # width , height = 1 0 2 4 , 1 0 2 4 # ) # # img := image . NewRGBA ( image . Rect ( 0 , 0 , width , height )) # for py := 0 ; py < height ; py ++ { # y := float 6 4 ( py )/ height *( ymax - ymin ) + ymin # for px := 0 ; px < width ; px ++ { # x := float 6 4 ( px )/ width *( xmax - xmin ) + xmin # z := complex ( x , y ) # img . Set ( px , py , mandelbrot ( z )) # } # } # png . Encode ( os . Stdout , img )
t . Parallel () # for _ , tc := range testcases { # if start , end := BusiestBuildingTimes ( tc . moves ); start != tc . start || end != tc . end { # t . Errorf (" STR ", tc . start , tc . end , start , end ) # } # }
n := len ( cost ) # dp := make ([] int , n + 1 ) # for i := 2 ; i <= n ; i ++ { # dp [ i ] = min ( dp [ i - 1 ]+ cost [ i - 1 ], dp [ i - 2 ]+ cost [ i - 2 ]) # } # return dp [ n ]
return new ( runningSchTaskList ). init ( tasks )
return area ( A , B , C , D ) + area ( E , F , G , H ) - area ( max ( A , E ), max ( B , F ), min ( C , G ), min ( D , H ))
r , err := http . Get ( os . Args [ 1 ]) # if err != nil { # fmt . Println ( err ) # return # } # # io . Copy ( os . Stdout , r . Body ) # if err := r . Body . Close (); err != nil { # fmt . Println ( err ) # }
qs := [] question 1 3 0 4 { # # { # para 1 3 0 4 { 5 }, # ans 1 3 0 4 {[] int {- 7 , - 1 , 1 , 3 , 4 }}, # }, # # { # para 1 3 0 4 { 0 }, # ans 1 3 0 4 {[] int {}}, # }, # # { # para 1 3 0 4 { 3 }, # ans 1 3 0 4 {[] int {- 1 , 0 , 1 }}, # }, # # { # para 1 3 0 4 { 1 }, # ans 1 3 0 4 {[] int { 0 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 3 0 4 , q . para 1 3 0 4 # fmt . Printf (" STR ", p , sumZero ( p . one )) # } # fmt . Printf (" STR ")
cases := [] struct { # name string # nums [] int # index [] int # expect [] int # }{ # {" STR ", [] int { 0 , 1 , 2 , 3 , 4 }, [] int { 0 , 1 , 2 , 2 , 1 }, [] int { 0 , 4 , 1 , 3 , 2 }}, # {" STR ", [] int { 1 , 2 , 3 , 4 , 0 }, [] int { 0 , 1 , 2 , 3 , 0 }, [] int { 0 , 1 , 2 , 3 , 4 }}, # {" STR ", [] int { 1 }, [] int { 0 }, [] int { 1 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . nums , c . index ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . nums , c . index ) # } # }) # }
tests := [...] testType { # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : false , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : false , # }, # } # for _ , tt := range tests { # got := isRobotBounded ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
seen := make ( map [ string ] struct {}) # for _ , tier := range al { # for _ , v := range tier { # if _ , ok := seen [ v ]; ! ok { # seen [ v ] = struct {}{} # ret = append ( ret , v ) # } # } # } # return
return h . tasks [ i ]. r < h . tasks [ j ]. r
return xtime . Unix ( int 6 4 ( jt ), 0 )
return RandomizedSet { # l : [] int {}, # m : make ( map [ int ] int ), # }
return TypeInt , nil
return createSkyline ( buildings , 0 , len ( buildings )- 1 )
var res [] int # var max * TreeNode # for root != nil { # if root . Left == nil { # res = append ( res , root . Val ) # root = root . Right # } else { # max = root . Left # for max . Right != nil && max . Right != root { # max = max . Right # } # # if max . Right == nil { # max . Right = root # root = root . Left # } else { # res = append ( res , root . Val ) # root = root . Right # max . Right = nil # } # } # } # return res
_ , err := os . Open (" STR ") # if ! os . IsNotExist ( err ) { # panic (" STR ") # } # # f , err := os . Open (" STR ") # if err != nil { # panic ( err ) # } # # defer func () { # if err := f . Close (); err != nil { # panic ( err ) # } # # _ , err := f . Read ( make ([] byte , 1 0 )) # if err == nil { # panic (" STR ") # } # }() # # data , err := ioutil . ReadAll ( f ) # if err != nil { # panic ( err ) # } # # print ( string ( data )) #
start , total , tank := 0 , 0 , 0 # for i , g := range gas { # tank += g - cost [ i ] # if tank < 0 { # start = i + 1 # total += tank # tank = 0 # } # } # if total + tank < 0 { # return - 1 # } # return start
fmt . Println ( btree . Data )
n := len ( num ) # res := [] string {} # var dfs func ( string , int , int , int ) # dfs = func ( path string , index , result , pre int ) { # if index == n && result == target { # res = append ( res , path ) # return # } # # for i := index ; i < n ; i ++ { # if num [ index ] == ' 0 ' && i != index { # return # } # currStr := num [ index : i + 1 ] # curr , _ := strconv . Atoi ( currStr ) # if index == 0 { # dfs ( currStr , i + 1 , curr , curr ) # } else { # dfs ( path +" STR "+ currStr , i + 1 , result + curr , curr ) # dfs ( path +" STR "+ currStr , i + 1 , result - curr , - curr ) # dfs ( path +" STR "+ currStr , i + 1 , result - pre + pre * curr , pre * curr ) # } # } # } # dfs (" STR ", 0 , 0 , 0 ) # return res
tests := [...] testType { # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := defangIPaddr ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
t . Parallel () # # for _ , tc := range testcases { # if res := Base 6 4 DecodeDelegate ( tc . base 6 4 ); res != tc . decoded { # t . Errorf (" STR ", tc . decoded , res ) # } # }
qs := [] question 1 2 0 7 { # # { # para 1 2 0 7 {[] int { 1 , 2 , 2 , 1 , 1 , 3 }}, # ans 1 2 0 7 { true }, # }, # # { # para 1 2 0 7 {[] int { 1 , 2 }}, # ans 1 2 0 7 { false }, # }, # # { # para 1 2 0 7 {[] int {- 3 , 0 , 1 , - 3 , 1 , 1 , 1 , - 3 , 1 0 , 0 }}, # ans 1 2 0 7 { true }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 0 7 , q . para 1 2 0 7 # fmt . Printf (" STR ", p , uniqueOccurrences ( p . arr )) # } # fmt . Printf (" STR ")
max := - 1 0 0 1 # max 1 := - 1 0 0 1 # max 2 := - 1 0 0 1 # min 1 := 1 0 0 1 # min 2 := 1 0 0 1 # # for _ , n := range nums { # switch { # case n > max : # max 2 , max 1 , max = max 1 , max , n # case n > max 1 : # max 2 , max 1 = max 1 , n # case n > max 2 : # max 2 = n # } # # switch { # case n < min 1 : # min 2 , min 1 = min 1 , n # case n < min 2 : # min 2 = n # } # } # # return bigger ( max 1 * max 2 , min 1 * min 2 ) * max
var ret float 6 4 # var x float 6 4 # var n int # ret = 0 # x = 0 . 0 0 0 0 1 # n = 2 1 4 7 4 8 3 6 4 7 # if ret != myPow ( x , n ) { # t . Fatalf (" STR ", ret ) # } # # ret = 1 . 0 0 0 0 # x = 2 # n = 0 # if ret != myPow ( x , n ) { # t . Fatalf (" STR ", ret ) # } # # ret = 1 0 . 0 0 0 0 # x = 1 0 . 0 0 0 0 # n = 1 # if ret != myPow ( x , n ) { # t . Fatalf (" STR ", ret ) # } # # ret = 0 . 2 5 0 0 0 # x = 2 . 0 0 0 0 # n = - 2 # if ret != myPow ( x , n ) { # t . Fatalf (" STR ", ret ) # }
for len ( w . data ) > 0 && w . data [ len ( w . data )- 1 ] < n { # w . data = w . data [ 0 : len ( w . data )- 1 ] # } # w . data = append ( w . data , n )
n := 0 # tmp := head # for tmp != nil { # n ++ # tmp = tmp . Next # } # return helper (& head , 0 , n - 1 )
const templ = `< p > A : {{. A }}</ p >< p > B : {{. B }}</ p >` # t := template . Must ( template . New (" STR "). Parse ( templ )) # var data struct { # A string # B template . HTML # } # data . A = " STR " # data . B = " STR " # if err := t . Execute ( os . Stdout , data ); err != nil { # log . Fatal ( err ) # }
if len ( A ) == len ( A [ 0 ]) { # for i := 0 ; i < len ( A ); i ++ { # for j := 0 ; j < len ( A ); j ++ { # if i == j { # break # } # A [ i ][ j ], A [ j ][ i ] = A [ j ][ i ], A [ i ][ j ] # } # } # return A # } # res := make ([][] int , len ( A [ 0 ])) # for i := 0 ; i < len ( res ); i ++ { # res [ i ] = make ([] int , len ( A )) # for j := 0 ; j < len ( A ); j ++ { # res [ i ][ j ] = A [ j ][ i ] # } # } # return res
out := make ( map [ string ] string ) # main_pieces := strings . Split ( s , sep 1 ) # for _ , piece := range main_pieces { # minor_pieces := strings . Split ( piece , sep 2 ) # out [ minor_pieces [ 0 ]] = minor_pieces [ 1 ] # } # return out
t . Parallel () # for _ , tc := range testcases { # if result := CountLargerAndSmallerBrute ( tc . mat , tc . i 1 , tc . j 1 , tc . i 2 , tc . j 2 ); result != tc . count { # t . Errorf (" STR ", tc . count , result ) # } # }
size := len ( a ) # # lo , hi := 0 , size - 1 # var miD , miA int # for lo <= hi { # miD = ( lo + hi ) / 2 # miA = size - miD - 1 # if a [ miA ] > miD { # lo = miD + 1 # } else { # hi = miD - 1 # } # } # # return lo
l 1 , l 2 := [] int {}, [] int {} # dfs ( root 1 , & l 1 ) # dfs ( root 2 , & l 2 ) # if len ( l 1 ) != len ( l 2 ) { # return false # } # for i , _ := range l 1 { # if l 1 [ i ] != l 2 [ i ] { # return false # } # } # return true
t . Parallel () # for _ , tc := range testcases { # if result , err := ShortestRunnerPath ( tc . elevations , tc . paths ); result != tc . shortestRoute || err != tc . err { # t . Errorf (" STR ", tc . shortestRoute , tc . err , result , err ) # } # }
m := map [ string ][] string { # " STR ": [] string {" STR ", " STR ", " STR "}, # " STR ": [] string {" STR ", " STR ", " STR "}, # " STR ": [] string {" STR ", " STR ", " STR "}, # " STR ": [] string {" STR ", " STR ", " STR "}, # " STR ": [] string {" STR ", " STR ", " STR "}, # " STR ": [] string {" STR ", " STR ", " STR ", " STR "}, # " STR ": [] string {" STR ", " STR ", " STR "}, # " STR ": [] string {" STR ", " STR ", " STR ", " STR "}, # " STR ": [] string {" STR "}, # } # slices := [][] string {} # for index := range digits { # digit := string ( digits [ index ]) # if _ , ok := m [ digit ]; ok { # slices = append ( slices , m [ digit ]) # } # } # return generateCombinations ( slices )
sLen , pLen := len ( s ), len ( p ) # dp := make ([][] bool , sLen + 1 ) # # for i := range dp { # dp [ i ] = make ([] bool , pLen + 1 ) # } # # dp [ sLen ][ pLen ] = true # for i := sLen ; i > - 1 ; i -- { # for j := pLen - 1 ; j > - 1 ; j -- { # # firstMatch := i < sLen && ( p [ j ] == s [ i ] || p [ j ] == '.') # if j + 1 < pLen && p [ j + 1 ] == '*' { # dp [ i ][ j ] = dp [ i ][ j + 2 ] || firstMatch && dp [ i + 1 ][ j ] # } else { # dp [ i ][ j ] = firstMatch && dp [ i + 1 ][ j + 1 ] # } # } # } # return dp [ 0 ][ 0 ]
sort . Slice ( intervals , func ( i , j int ) bool { # return intervals [ i ]. End < intervals [ j ]. End # }) # count := 0 # current := - int (^ uint ( 0 )>> 1 ) - 1 # for _ , interval := range intervals { # if interval . Start >= current { # count ++ # current = interval . End # } # } # return len ( intervals ) - count
i := len ( nums ) - 2 # for i >= 0 && nums [ i ] >= nums [ i + 1 ] { # i -- # } # # j , k := i + 1 , len ( nums )- 1 # for j < k { # nums [ j ], nums [ k ] = nums [ k ], nums [ j ] # j , k = j + 1 , k - 1 # } # # if i >= 0 { # j = i + 1 # for nums [ j ] <= nums [ i ] { # j ++ # } # # nums [ i ], nums [ j ] = nums [ j ], nums [ i ] # }
denoms := make ( map [ int ] struct {}) # # for d , way := range ways { # if others := waysToProduce ( d , denoms ); ( way == 1 && d > 0 ) || others == way - 1 { # denoms [ d ] = struct {}{} # } # } # # res := make ([] int , 0 , len ( denoms )) # # for k := range denoms { # res = append ( res , k ) # } # # sort . Ints ( res ) # # return res
return len ( self . data )
var ri , gi int # for i , r := range letters { # if r == ' R ' { # letters [ i ] = letters [ gi ] # letters [ gi ] = letters [ ri ] # letters [ ri ] = r # gi ++ # ri ++ # } else if r == ' G ' { # letters [ i ] = letters [ gi ] # letters [ gi ] = r # gi ++ # } # }
switch rand . Intn ( 1 0 ) { # case 1 , 9 : # return io . EOF # # case 5 : # return errors . New (" STR ") # # default : # d . Line = " STR " # fmt . Println (" STR ", d . Line ) # return nil # }
return helper ( root , p , q )
benchmark ( bb , 1 6 3 8 4 , 0 . 1 )
this . mutex . Lock () # defer this . mutex . Unlock () # # if priority < 0 || priority > this . max { # return nil # } # # return this . queues [ priority ]. Peek ()
if i < 0 || i >= itemKind ( len ( _itemKind_index )- 1 ) { # return fmt . Sprintf (" STR ", i ) # } # return _itemKind_name [ _itemKind_index [ i ]: _itemKind_index [ i + 1 ]]
arr := randomSlice ( 0 , 2 0 , 1 0 ) # nodeCnt := 0 # gbt := newGBT () # for _ , v := range arr { # gbt . Insert ( uint 3 2 ( v )) # } # rotateNodes := make ([]* gbtElement , 0 , 0 ) # gbt . InOrderWalk ( gbt . Root (), func ( GBT binaryTreeIf , node interface {}) bool { # rotate := getRand (). Intn ( 2 ) # if rotate == 1 { # rotateNodes = append ( rotateNodes , node .(* gbtElement )) # } # return false # }) # for _ , v := range rotateNodes { # rotate := getRand (). Intn ( 2 ) # if rotate == 1 { # gbt . LeftRotate ( v ) # } else { # gbt . RightRotate ( v ) # } # } # gbt . InOrderWalk ( gbt . Root (), checkGBT ( t , & nodeCnt , * debug )) # if nodeCnt != len ( arr ) { # t . Log ( fmt . Sprintf (" STR ", len ( arr ), nodeCnt )) # t . Fail () # }
t . Parallel () # for _ , tc := range testcases { # if result := InversionCountBrute ( tc . input ); result != tc . inversions { # t . Errorf (" STR ", tc . inversions , result ) # } # }
fmt . Println ( subarrayBitwiseORs ([] int { 0 })) # fmt . Println ( subarrayBitwiseORs ([] int { 1 , 1 , 2 })) # fmt . Println ( subarrayBitwiseORs ([] int { 1 , 2 , 4 }))
if nil == root { # return [] int {} # } # # largestVals := [] int {} # children := []* TreeNode { root } # for len ( children ) > 0 { # tmp := children [:] # children = []* TreeNode {} # largest := -( 1 << 3 2 ) # for _ , child := range tmp { # if child . Val > largest { # largest = child . Val # } # if nil != child . Left { # children = append ( children , child . Left ) # } # if nil != child . Right { # children = append ( children , child . Right ) # } # } # largestVals = append ( largestVals , largest ) # } # return largestVals
{ # data , err := json . Marshal ( movies ) # if err != nil { # log . Fatalf (" STR ", err ) # } # fmt . Printf (" STR ", data ) # } # # { # data , err := json . MarshalIndent ( movies , " STR " ") # if err != nil { # log . Fatalf (" STR ", err ) # } # fmt . Printf (" STR ", data ) # # var titles [] struct { Title string } # if err := json . Unmarshal ( data , & titles ); err != nil { # log . Fatalf (" STR ", err ) # } # fmt . Println ( titles ) # }
t . Parallel () # for _ , tc := range testcases { # q := NewQueueFLA ( 5 ) # for _ , action := range tc . actions { # switch action . act { # case " STR ": # if err := q . Enqueue ( action . data ); err != action . err { # t . Errorf (" STR ", action . err , err ) # } # case " STR ": # if item , err := q . Dequeue (); item != action . data || err != action . err { # t . Errorf (" STR ", action . data , action . err , item , err ) # } # case " STR ": # if s := q . Size (); s != action . data { # t . Errorf (" STR ", action . data , s ) # } # } # } # }
if num <= 0 { # return false # } # # if num &( num - 1 ) != 0 { # return false # } # # if num & 0 x 5 5 5 5 5 5 5 5 == 0 { # return false # } # # return true
major := uint 3 2 (( dev & 0 x 0 0 0 0 0 0 0 0 0 0 0 fff 0 0 ) >> 8 ) # major |= uint 3 2 (( dev & 0 xfffff 0 0 0 0 0 0 0 0 0 0 0 ) >> 3 2 ) # return major
t . Parallel () # var ba BitArray # for _ , tc := range testcases { # ba . Init ( tc . size ) # for index , val := range tc . ones { # if err := ba . Set ( index , val ); err != nil { # t . Errorf (" STR ") # } # } # for i := 0 ; i < tc . size ; i ++ { # if val , err := ba . Get ( i ); err != nil { # t . Errorf (" STR ", err ) # } else if tc . ones [ i ] != val { # t . Errorf (" STR ", tc . ones [ i ], val , i ) # } # } # }
if a == b { # return - 1 # } # # if len ( a ) > len ( b ) { # return len ( a ) # } # return len ( b )
var res [] int # var max * TreeNode # # for root != nil { # if root . Left == nil { # res = append ( res , root . Val ) # root = root . Right # } else { # max = root . Left # for max . Right != nil { # max = max . Right # } # # max . Right = root # root , root . Left = root . Left , nil # } # } # return res
if a > b { # return b # } # return a
var buf bytes . Buffer # if err := encode (& buf , reflect . ValueOf ( v )); err != nil { # return nil , err # } # return buf . Bytes (), nil
m := map [ byte ] struct {}{} # for i := range J { # m [ J [ i ]] = struct {}{} # } # res := 0 # for i := range S { # if _ , ok := m [ S [ i ]]; ok { # res ++ # } # } # return res
if numRows < 2 { # return s # } # maxInterval := ( numRows - 1 ) << 1 # interval := maxInterval # after := " STR " # for i := 0 ; i < numRows ; i ++ { # if numRows - 1 == i { # interval = maxInterval # } # for j , no := i , 0 ; j < len ( s ); no ++ { # after += string ( s [ j ]) # if i > 0 && i < numRows - 1 && 1 == no & 1 { # j += maxInterval - interval # continue # } # j += interval # } # interval -= 2 # } # return after
var result [] string # dfs ( s , [] string {}, & result ) # return result
if n < 7 { # return int 6 4 ( n + 1 ) # } # # ans := ( 1 + int 6 4 ( n % 7 )) * row ( n / 7 ) # # return ans
if len ( mat ) == 0 || len ( mat [ 0 ]) == 0 { # return [] int {} # } # m , n := len ( mat ), len ( mat [ 0 ]) # # isUpping := true # next := func ( i , j int ) ( int , int ) { # if isUpping { # i -- # j ++ # if 0 <= i && j < n { # return i , j # } # # isUpping = false # # if i < 0 && j < n { # return 0 , j # } # return i + 2 , j - 1 # } # # i ++ # j -- # if i < m && 0 <= j { # return i , j # } # # isUpping = true # # if i < m && j < 0 { # return i , 0 # } # return i - 1 , j + 2 # } # # mn := m * n # res := make ([] int , mn ) # # i , j := 0 , 0 # for k := 0 ; k < mn ; k ++ { # res [ k ] = mat [ i ][ j ] # i , j = next ( i , j ) # } # # return res
n := len ( quality ) # # workers := make ([][ 2 ] float 6 4 , n ) # for i := 0 ; i < n ; i ++ { # w , q := float 6 4 ( wage [ i ]), float 6 4 ( quality [ i ]) # workers [ i ][ 0 ], workers [ i ][ 1 ] = w / q , q # } # sort . Slice ( workers , func ( i , j int ) bool { # return workers [ i ][ 0 ] < workers [ j ][ 0 ] # }) # # res := math . MaxFloat 6 4 # sum := 0 . # # h := floatHeap {} # # for _ , w := range workers { # sum += w [ 1 ] # heap . Push (& h , w [ 1 ]) # # if len ( h ) > K { # sum -= heap . Pop (& h ).( float 6 4 ) # } # # if len ( h ) == K { # res = min ( res , sum * w [ 0 ]) # } # } # return res
t . Parallel () # lfu := NewLFUCache ( 3 ) # lfu . Set (" STR ", " STR ") # lfu . Set ( 1 , 2 ) # lfu . Set (" STR ", " STR ") # lfu . Get ( 1 ) # lfu . Get (" STR ") # lfu . Set ( 1 0 0 , 1 ) # if result := lfu . Get (" STR "); result != nil { # t . Errorf (" STR ", result ) # } # if result := lfu . Get ( 1 ); result == nil { # t . Errorf (" STR ") # } # if result := lfu . Get (" STR "); result == nil { # t . Errorf (" STR ") # } # if result := lfu . Get ( 1 0 0 ); result == nil { # t . Errorf (" STR ") # } # lfu . Set ( 1 0 0 , " STR ") # if result := lfu . Get ( 1 0 0 ); result .( string ) != " STR " { # t . Errorf (" STR ") # }
m := len ( pattern ) # next := make ([] int , m ) # for index := range next { # next [ index ] = - 1 # } # for i := 1 ; i < m - 1 ; i ++ { # j := next [ i - 1 ] # for pattern [ j + 1 ] != pattern [ i ] && j >= 0 { # j = next [ j ] # } # if pattern [ j + 1 ] == pattern [ i ] { # j += 1 # } # next [ i ] = j # } # # return next
t . Parallel () # # for _ , tc := range testcases { # if result := AllPossibleSubsequences ( tc . input ); ! reflect . DeepEqual ( result , tc . subseq ) { # t . Errorf (" STR ", tc . subseq , result ) # } # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 3 , 4 , 2 , 2 }, 2 }, # {" STR ", [] int { 3 , 1 , 3 , 4 , 2 }, 3 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := findDuplicate ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
cases := [] struct { # name string # inputs [] int # expects bool # }{ # {" STR ", [] int { 1 , 2 , 3 , 1 }, true }, # {" STR ", [] int { 1 , 2 , 3 , 4 }, false }, # {" STR ", [] int { 1 , 1 , 1 , 3 , 3 , 4 , 3 , 2 , 4 , 2 }, true }, # } # # for _ , testcase := range cases { # t . Run ( testcase . name , func ( t * testing . T ) { # result := containsDuplicate ( testcase . inputs ) # if ! reflect . DeepEqual ( result , testcase . expects ) { # t . Fatalf (" STR ", testcase . expects , result , testcase . inputs ) # } # # }) # }
arr := randomSlice ( 0 , 2 0 , 1 0 ) # gbt := newGBT () # for _ , v := range arr { # gbt . Insert ( uint 3 2 ( v )) # } # checkGBTPreOrder ( t , gbt , arr )
fmt . Println ( maxDistToClosest ([] int { 1 , 0 , 0 , 0 , 1 , 0 , 1 })) # fmt . Println ( maxDistToClosest ([] int { 1 , 0 , 0 , 0 })) # fmt . Println ( maxDistToClosest ([] int { 0 , 1 })) # fmt . Println ( maxDistToClosest ([] int { 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 })) # fmt . Println ( maxDistToClosest ([] int { 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 }))
iE := i .(* ltHeapElement ) # jE := j .(* ltHeapElement ) # if iE == nil { # return jE # } # if jE == nil { # return iE # } # if h . Key ( iE ) < h . Key ( jE ) { # h . Swap (& iE , & jE ) # } # iE . right = h . merge ( iE . right , jE ).(* ltHeapElement ) # if iE . left == nil || iE . right . dist > iE . left . dist { # h . Swap (& iE . left , & iE . right ) # } # if iE . right == nil { # iE . dist = 0 # } else { # iE . dist = iE . right . dist + 1 # } # return iE
result := MakeMatrix ( make ([] float 6 4 , A . cols * A . rows ), A . cols , A . rows ) # # for i := 0 ; i < A . rows ; i ++ { # for j := 0 ; j < A . cols ; j ++ { # sum := float 6 4 ( 0 ) # for k := 0 ; k < A . cols ; k ++ { # sum += A . GetElm ( i , k ) * B . GetElm ( k , j ) # } # result . SetElm ( i , j , sum ) # } # } # # return result
if head == nil { # return nil # } # # even := head . Next # p , q := head , head . Next # for q != nil && q . Next != nil { # p . Next = q . Next # p = p . Next # q . Next = p . Next # q = q . Next # } # p . Next = even # return head
for i := 0 ; i < b . N ; i ++ { # hmap . HashInsert ( rand . Intn ( 1 2 8 ), i ) # }
size := len ( prices ) # if size <= 1 { # return 0 # } # # profits := [] int {} # temp := 0 # for i := 1 ; i < size ; i ++ { # diff := prices [ i ] - prices [ i - 1 ] # # if temp * diff >= 0 { # temp += diff # continue # } # # profits = append ( profits , temp ) # temp = diff # } # profits = append ( profits , temp ) # # res := 0 # for i := 0 ; i < len ( profits ); i ++ { # temp = max ( profits [: i ]) + max ( profits [ i :]) # if res < temp { # res = temp # } # } # # return res
_a := a # _b := b # # if a < 0 { # a *= - 1 # } # if b < 0 { # b *= - 1 # } # # x 0 , y 0 := 0 , 1 # x 1 , y 1 := 1 , 0 # # for b != 0 { # quotient := a / b # a , b = b , divide ( a , b ) # x 1 , x 0 = x 0 - quotient * x 1 , x 1 # y 1 , y 0 = y 0 - quotient * y 1 , y 1 # } # # if _a < 0 { # y 0 *= - 1 # } # if _b < 0 { # x 0 *= - 1 # } # # return y 0 , x 0
t . Run (" STR ", func ( t * testing . T ) { # data := [] int { 1 , 1 , 2 } # got := removeDuplicates ( data ) # want := 2 # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # }) # # t . Run (" STR ", func ( t * testing . T ) { # data := [] int { 0 , 0 , 1 , 1 , 1 , 2 , 2 , 3 , 3 , 4 } # got := removeDuplicates ( data ) # want := 5 # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # }) #
if list == nil || list . Size == 0 { # fmt . Println (" STR ") # return # } # list . mutex . RLock () # defer list . mutex . RUnlock () # fmt . Printf (" STR ", list . Size ) # ptr := list . Head # var i uint # for i = 0 ; i < list . Size ; i ++ { # fmt . Printf (" STR ", i + 1 , ptr . Data ) # ptr = ptr . Next # }
commonChars := make ([] string , 0 ) # if len ( A ) == 0 { # return commonChars # } # minFrequencies := [ 2 6 ] int {} # for i := range minFrequencies { # minFrequencies [ i ] = math . MaxInt 3 2 # } # for _ , word := range A { # charFrequencies := [ 2 6 ] int {} # for _ , char := range word { # charFrequencies [ char -" STR "]++ # } # for i := 0 ; i < 2 6 ; i ++ { # minFrequencies [ i ] = min ( minFrequencies [ i ], charFrequencies [ i ]) # } # } # for i := 0 ; i < 2 6 ; i ++ { # for minFrequencies [ i ] > 0 { # commonChars = append ( commonChars , string ( rune ( i )+" STR ")) # minFrequencies [ i ]-- # } # } # return commonChars
return N & 1 == 0
var head * event # return MyCalendar { head : head }
var num uint 3 2 # var ret int # # num = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 # ret = 3 # # if ret != hammingWeight ( num ) { # t . Fatalf (" STR ", ret ) # }
if head == nil || head . Next == nil { # return head # } # result := head . Next # result . Next , head . Next = head , head . Next . Next # result . Next . Next = SwapEveryTwo ( result . Next . Next ) # return result
t . Parallel () # for tcid , tc := range testcases { # if result := AreSentencesEquivalentTransitive ( tc . sentence 1 , # tc . sentence 2 , tc . thesaurus ); result != tc . expectedTransitive { # t . Errorf (" STR ", tcid , # tc . expectedTransitive , result ) # } # }
m := make ( map [ int ] int ) # for k , v := range nums { # if idx , ok := m [ target - v ]; ok { # return [] int { idx , k } # } # m [ v ] = k # } # return nil
sum := 1 0 0 * 1 0 1 / 2 # sqSum := sum * sum # # sumSq := 0 # for i := 1 ; i <= 1 0 0 ; i ++ { # sumSq += i * i # } # # fmt . Println ( sqSum - sumSq )
if a > b { # return b # } # return a
return this . Val
n := len ( prices ) # # if 0 == n || 1 == n { # return 0 # } # # var ( # res int # minPrice = prices [ 0 ] # ) # for i := 1 ; i < n ; i ++ { # if prices [ i ] < prices [ i - 1 ] { # res += prices [ i - 1 ] - minPrice # minPrice = prices [ i ] # } # if i == n - 1 { # res += prices [ i ] - minPrice # } # } # return res
bs := [] byte ( s ) # var recur func ( int , int ) bool # recur = func ( l , r int ) bool { # for l < r { # if bs [ l ] != bs [ r ] { # return false # } # l ++ # r -- # } # return true # } # for l , r := 0 , len ( s )- 1 ; l < r ; l , r = l + 1 , r - 1 { # if bs [ l ] == bs [ r ] { # continue # } # return recur ( l + 1 , r ) || recur ( l , r - 1 ) # } # return true
tests := [...] testType { # { # in : " STR ", # want : 1 , # }, # { # in : " STR ", # want : 2 , # }, # { # in : " STR ", # want : 0 , # }, # { # in : " STR ", # want : 0 , # }, # } # for _ , tt := range tests { # got := maxNumberOfBalloons ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
tests := [...] testType { # { # words : [] string {" STR ", " STR "}, # order : " STR ", # want : true , # }, # { # words : [] string {" STR ", " STR ", " STR "}, # order : " STR ", # want : false , # }, # { # words : [] string {" STR ", " STR "}, # order : " STR ", # want : false , # }, # } # for _ , tt := range tests { # got := isAlienSorted ( tt . words , tt . order ) # if got != tt . want { # t . Fatalf (" STR ", tt . words , got , tt . want ) # } # }
qs := [] question 1 0 5 1 { # # { # para 1 0 5 1 {[] int { 1 , 1 , 4 , 2 , 1 , 3 }}, # ans 1 0 5 1 { 3 }, # }, # # { # para 1 0 5 1 {[] int { 5 , 1 , 2 , 3 , 4 }}, # ans 1 0 5 1 { 5 }, # }, # # { # para 1 0 5 1 {[] int { 1 , 2 , 3 , 4 , 5 }}, # ans 1 0 5 1 { 0 }, # }, # # { # para 1 0 5 1 {[] int { 5 , 4 , 3 , 2 , 1 }}, # ans 1 0 5 1 { 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 5 1 , q . para 1 0 5 1 # fmt . Printf (" STR ", p , heightChecker ( p . one )) # } # fmt . Printf (" STR ")
i := 1 # tmp := 0 # for ; i < len ( arr ) ; { # if arr [ i ] >= arr [ i - 1 ] { # i ++ # } else { # tmp = arr [ i ] # arr [ i ] = arr [ i - 1 ] # arr [ i - 1 ] = tmp # # if i > 1 { # i -- # } # } # }
if maxSize > 0 { # stack := & Stack {} # stack . top = nil # stack . size = 0 # stack . maxSize = maxSize # return stack # } # return nil
b , _ := ioutil . ReadFile (" STR ") # s := strings . Replace ( string ( b ), " STR ", " STR ", - 1 ) # numData := strings . Split ( s , " STR ") # # for _ , n := range numData { # number , err := strconv . Atoi ( n ) # if err == nil { # data = append ( data , number ) # } # }
if len ( candidates ) == 0 { # return [][] int {} # } # c , res := [] int {}, [][] int {} # sort . Ints ( candidates ) # findcombinationSum ( candidates , target , 0 , c , & res ) # return res
qs := [] question 7 8 6 { # # { # para 7 8 6 {[] int { 1 , 2 , 3 , 5 }, 3 }, # ans 7 8 6 {[] int { 2 , 5 }}, # }, # # { # para 7 8 6 {[] int { 1 , 7 }, 1 }, # ans 7 8 6 {[] int { 1 , 7 }}, # }, # # { # para 7 8 6 {[] int { 1 , 2 }, 1 }, # ans 7 8 6 {[] int { 1 , 2 }}, # }, # # { # para 7 8 6 {[] int { 1 , 2 , 3 , 5 , 7 }, 6 }, # ans 7 8 6 {[] int { 3 , 7 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 8 6 , q . para 7 8 6 # fmt . Printf (" STR ", p , kthSmallestPrimeFraction ( p . A , p . K )) # } # fmt . Printf (" STR ")
errObj := appError { # Error : handlerError . Error (), # Message : message , # HTTPStatus : code , # } # Error . Printf (" STR ", handlerError ) # w . Header (). Set (" STR ", " STR ") # w . WriteHeader ( code ) # if j , err := json . Marshal ( errorResource { Data : errObj }); err == nil { # w . Write ( j ) # }
if len ( strs ) == 0 { # return nil # } # r := make ( map [ string ][] string ) # for _ , str := range strs { # count := make ([] int , 2 6 ) # for _ , b := range [] byte ( str ) { # count [ b -' a ']++ # } # # bs := make ([] byte , 2 6 * 2 ) # for i , c := range count { # bs [ 2 * i ] = '#' # bs [ 2 * i + 1 ] = byte ( c ) + ' 0 ' # } # key := string ( bs ) # r [ key ] = append ( r [ key ], str ) # } # res := make ([][] string , len ( r )) # i := 0 # for _ , l := range r { # res [ i ] = l # i ++ # } # return res
type Address struct { # Country string ` json :" STR "` # Person * Person ` json :" STR "` # } # # person := & Person { # Name : " STR ", # Age : 2 3 , # } # # address := & Address { # Country : " STR ", # Person : person , # } # # defer func () { # err := recover () # if err != nil { # fmt . Printf (" STR ", err ) # t . Error (" STR ") # } # }() # # s := New ( address ) # # s . TagName = " STR " # m := s . Map () # # if m [" STR "] != person . String () { # t . Errorf (" STR ", person . String (), m [" STR "]) # } # # vs := s . Values () # if vs [ 1 ] != person . String () { # t . Errorf (" STR ", person . String (), vs [ 1 ]) # }
if parser . tokens_head > 0 && len ( parser . tokens ) == cap ( parser . tokens ) { # if parser . tokens_head != len ( parser . tokens ) { # copy ( parser . tokens , parser . tokens [ parser . tokens_head :]) # } # parser . tokens = parser . tokens [: len ( parser . tokens )- parser . tokens_head ] # parser . tokens_head = 0 # } # parser . tokens = append ( parser . tokens , * token ) # if pos < 0 { # return # } # copy ( parser . tokens [ parser . tokens_head + pos + 1 :], parser . tokens [ parser . tokens_head + pos :]) # parser . tokens [ parser . tokens_head + pos ] = * token
l = bytes . TrimSpace ( l ) # if len ( l ) == 0 || bytes . HasPrefix ( l , [] byte (" STR ")) { # return # } # colon := bytes . LastIndexAny ( l , " STR ") # if colon == - 1 { # err = errors . New (" STR ") # return # } # hyphen := bytes . IndexByte ( l [ colon + 1 :], " STR ") # if hyphen == - 1 { # err = errors . New (" STR ") # return # } # hyphen += colon + 1 # r . Description = string ( l [: colon ]) # r . First = net . ParseIP ( string ( l [ colon + 1 : hyphen ])) # minifyIP (& r . First ) # r . Last = net . ParseIP ( string ( l [ hyphen + 1 :])) # minifyIP (& r . Last ) # if r . First == nil || r . Last == nil || len ( r . First ) != len ( r . Last ) { # err = errors . New (" STR ") # return # } # ok = true # return
str := " STR " # # fmt . Println ( longestPalindrome ( str )) #
tests := [...] testType { # { # in : 5 , # want : 2 , # }, # { # in : 8 , # want : 3 , # }, # { # in : 0 , # want : 0 , # }, # { # in : 1 , # want : 1 , # }, # { # in : 2 , # want : 1 , # }, # { # in : 3 , # want : 2 , # }, # { # in : 1 3 , # want : 4 , # }, # { # in : 1 3 0 , # want : 1 5 , # }, # } # for _ , tt := range tests { # got := arrangeCoins ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
return WordDictionary {}
tcs := [] struct { # s string # ans bool # }{ # # { # " STR ", # false , # }, # # { # " STR ", # true , # }, # # { # " STR ", # false , # }, # # { # " STR ", # true , # }, # } # fmt . Printf (" STR ") # # for _ , tc := range tcs { # fmt . Printf (" STR ", tc , isPalindrome ( tc . s )) # } # fmt . Printf (" STR ")
var drinks [] Drink # inverted := make ( map [ Drink ][] Customer ) # for cust , favorites := range prefs { # for _ , drink := range favorites { # inverted [ drink ] = append ( inverted [ drink ], cust ) # } # } # totalCustomers := len ( prefs ) # served := make ( map [ Customer ] struct {}, totalCustomers ) # for len ( served ) < totalCustomers { # var largest [] Customer # var largestDrink Drink # var largestIncrease int # for drink , custs := range inverted { # var newlyServed int # for _ , cust := range custs { # if _ , found := served [ cust ]; ! found { # newlyServed ++ # } # } # if newlyServed > largestIncrease { # largestIncrease = newlyServed # largestDrink = drink # largest = custs # } # } # delete ( inverted , largestDrink ) # drinks = append ( drinks , largestDrink ) # for _ , cust := range largest { # served [ cust ] = struct {}{} # } # } # sort . Slice ( drinks , func ( i , j int ) bool { # return drinks [ i ] < drinks [ j ] # }) # return drinks
wg . Add ( 2 ) # # go incCounter ( 1 ) # go incCounter ( 2 ) # # wg . Wait () # # fmt . Println (" STR ", counter )
graph := make ( map [ int ][] int ) # inCounts := make ( map [ int ] int ) # for i := 0 ; i < numCourses ; i ++ { # graph [ i ] = make ([] int , 0 ) # inCounts [ i ] = 0 # } # # for _ , pair := range prerequisites { # graph [ pair [ 1 ]] = append ( graph [ pair [ 1 ]], pair [ 0 ]) # inCounts [ pair [ 0 ]]++ # } # # queue := make ([] int , 0 ) # for k , count := range inCounts { # if count == 0 { # queue = append ( queue , k ) # } # } # # order := make ([] int , 0 ) # for len ( queue ) > 0 { # course := queue [ 0 ] # order = append ( order , course ) # queue = queue [ 1 :] # # for _ , neighbor := range graph [ course ] { # inCounts [ neighbor ]-- # # if inCounts [ neighbor ] == 0 { # queue = append ( queue , neighbor ) # } # } # } # # if len ( order ) < numCourses { # return make ([] int , 0 ) # } # # return order
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", [][] int {{- 1 , 2 , 1 , - 4 }, { 1 }}, 2 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := threeSumClosest ( c . inputs [ 0 ], c . inputs [ 1 ][ 0 ]) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
qs := [] question 1 0 3 7 { # { # para 1 0 3 7 {[][] int {{ 1 , 2 }, { 2 , 3 }, { 3 , 2 }}}, # ans 1 0 3 7 { true }, # }, # # { # para 1 0 3 7 {[][] int {{ 1 , 1 }, { 2 , 2 }, { 3 , 3 }}}, # ans 1 0 3 7 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 3 7 , q . para 1 0 3 7 # fmt . Printf (" STR ", p , isBoomerang ( p . one )) # } # fmt . Printf (" STR ")
sort . Slice ( words , func ( i , j int ) bool { # curi := len ( words [ i ]) # curj := len ( words [ j ]) # for curi > 0 && curj > 0 { # curi -- # curj -- # if words [ i ][ curi ] == words [ j ][ curj ] { # continue # } # if words [ i ][ curi ] > words [ j ][ curj ] { # return true # } # return false # } # return curi == 0 # }) # # words = append ( words , " STR ") # res , i := 0 , 1 # for ; i < len ( words ); i ++ { # if ! endWith ( words [ i ], words [ i - 1 ]) { # res += len ( words [ i - 1 ]) + 1 # } # } # # return res
fmt . Println ( badLongestPalindrome (" STR ")) # fmt . Println ( goodLongestPalindrome (" STR ")) # fmt . Println ( bestLongestPalindrome (" STR "))
for i := 0 ; i < len ( A )- 1 ; i ++ { # if A [ i ] == i { # continue # } # if A [ i ] == i + 1 && A [ i + 1 ] == i { # i ++ # } else { # return false # } # } # return true
hash := uint 3 2 ( 0 ) # for i := len ( sep ) - 1 ; i >= 0 ; i -- { # hash = hash * PrimeRK + uint 3 2 ( sep [ i ]) # } # var pow , sq uint 3 2 = 1 , PrimeRK # for i := len ( sep ); i > 0 ; i >>= 1 { # if i & 1 != 0 { # pow *= sq # } # sq *= sq # } # return hash , pow
t . Parallel () # for _ , tc := range testcases { # if sum := SumBSTRange ( tc . root , tc . a , tc . b ); sum != tc . expected { # t . Errorf (" STR ", tc . expected , sum ) # } # }
arr := make ([] bool , 1 0 5 0 0 0 ) # arr [ 0 ], arr [ 1 ] = true , true # count , prime := 2 , 3 # var k int # for { # for k = 2 * prime ; k < len ( arr ); k += prime { # arr [ k ] = true # } # for k = prime + 2 ; k < len ( arr ) && arr [ k ]; k += 2 { # } # if k < len ( arr ) { # prime = k # count ++ # if count == 1 0 0 0 1 { # println ( prime ) # break # } # } else { # break # } # }
n 1 , n 2 := len ( nums 1 ), len ( nums 2 ) # if n 1 > n 2 { # n 1 , n 2 , nums 1 , nums 2 = n 2 , n 1 , nums 2 , nums 1 # } # m := make ( map [ int ] int , n 1 ) # for _ , num := range nums 1 { # m [ num ]++ # } # # res := make ([] int , 0 , n 1 ) # for _ , num := range nums 2 { # if v , ok := m [ num ]; ok && v > 0 { # res = append ( res , num ) # m [ num ]-- # } # } # return res
if root == nil { # return nil # } # s := []* TreeNode { root } # res := [][] int {} # zigzag := false # for len ( s ) != 0 { # tmp := []* TreeNode {} # l := [] int {} # for i , node := range s { # if zigzag { # l = append ( l , s [ len ( s )- i - 1 ]. Val ) # } else { # l = append ( l , node . Val ) # } # if node . Left != nil { # tmp = append ( tmp , node . Left ) # } # if node . Right != nil { # tmp = append ( tmp , node . Right ) # } # } # res = append ( res , l ) # s = tmp # zigzag = ! zigzag # } # return res
for i := 0 ; i < len ( problems ); i ++ { # log . Printf (" STR ", problems [ i ]. Stat . FrontendQuestionID ) # # if problems [ i ]. Stat . QuestionID == 0 { # log . Printf (" STR ", problems [ i ]. Stat . FrontendQuestionID ) # } # # if problems [ i ]. PaidOnly { # log . Printf (" STR ", problems [ i ]. Stat . FrontendQuestionID ) # continue # } # # if is_DirExists , _ := PathExists ( SOLUTIONS_PATH + problems [ i ]. PathName ); is_DirExists { # log . Println (" STR ", SOLUTIONS_PATH + problems [ i ]. PathName ) # } else { # err := os . Mkdir ( SOLUTIONS_PATH + problems [ i ]. PathName , os . ModePerm ) # if err != nil { # log . Printf (" STR ", err . Error ()) # } else { # log . Println (" STR ") # copy ( SOURCE_SOLUTION_FILE_PATH , SOLUTIONS_PATH + problems [ i ]. PathName +" STR ") # copy ( SOURCE_SOLUTION_TEST_FILE_PATH , SOLUTIONS_PATH + problems [ i ]. PathName +" STR ") # GenerateReadme ( problems [ i ]) # } # } # # }
count := 0 # for i := 0 ; i < 1 0 0 0 0 ; i ++ { # if isL ( i ) { # count ++ # } # } # fmt . Println ( count )
if len ( str ) == 0 { # return 0 # } # var ( # num int # neg bool # ) # for i , s := range str { # if s != ' ' { # str = str [ i :] # break # } # } # if str [ 0 ] == '+' { # str = str [ 1 :] # } else if str [ 0 ] == '-' { # str = str [ 1 :] # neg = true # } # for _ , s := range str { # if s < ' 0 ' || s > ' 9 ' { # break # } # num = num * 1 0 + int ( s -' 0 ') # if num > 2 1 4 7 4 8 3 6 4 8 { # num = 2 1 4 7 4 8 3 6 4 8 # break # } # } # if neg { # num *= - 1 # } else if num > 2 1 4 7 4 8 3 6 4 7 { # num = 2 1 4 7 4 8 3 6 4 7 # } # return num
ans , m , n := [] int {}, len ( matrix ), len ( matrix [ 0 ]) # for j := 0 ; j < n ; j ++ { # max , rowIndex := 1 , 0 # for i := 0 ; i < m ; i ++ { # if matrix [ i ][ j ] > max { # max = matrix [ i ][ j ] # rowIndex = i # } # } # if Min ( matrix [ rowIndex ]) == max { # ans = append ( ans , max ) # } # } # return ans
strNumber := strconv . Itoa ( number ) # for _ , runeDigit := range [] rune ( strNumber ) { # digit := int ( runeDigit - ' 0 ') # list = append ( list , digit ) # } # return
if num == 0 { # return " STR " # } # h := [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", # " STR ", " STR ", " STR ", " STR ", " STR ", " STR "} # res := " STR " # for i := 0 ; i < 8 && num != 0 ; i ++ { # res = h [ num & 1 5 ] + res # num >>= 4 # } # return res
if len ( n . Exprs ) == 0 { # return TypeString , nil # } # # if len ( n . Exprs ) == 1 { # exprType , err := n . Exprs [ 0 ]. Type ( s ) # if err != nil { # return TypeInvalid , err # } # switch exprType { # case TypeList : # return TypeList , nil # case TypeMap : # return TypeMap , nil # } # } # # for index , expr := range n . Exprs { # exprType , err := expr . Type ( s ) # if err != nil { # return TypeInvalid , err # } # if exprType == TypeList || exprType == TypeMap { # return TypeInvalid , fmt . Errorf ( # " STR ", # index , exprType ) # } # } # # return TypeString , nil
psum , min := 0 , 1 # for _ , val := range nums { # psum += val # if psum < min { # min = psum # } # } # if min > 0 { # return min # } # return - min + 1
arr := make ([] bool , 2 0 0 0 0 0 0 ) # arr [ 0 ], arr [ 1 ] = true , true # sum , prime := int 6 4 ( 5 ), 3 # var k int # for { # for k = 2 * prime ; k < len ( arr ); k += prime { # arr [ k ] = true # } # for k = prime + 2 ; k < len ( arr ) && arr [ k ]; k += 2 { # } # if k < len ( arr ) { # prime = k # sum += int 6 4 ( k ) # } else { # break # } # } # println ( sum )
qs := [] question 6 9 3 { # # { # para 6 9 3 { 5 }, # ans 6 9 3 { true }, # }, # # { # para 6 9 3 { 7 }, # ans 6 9 3 { false }, # }, # # { # para 6 9 3 { 1 1 }, # ans 6 9 3 { false }, # }, # # { # para 6 9 3 { 1 0 }, # ans 6 9 3 { true }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 9 3 , q . para 6 9 3 # fmt . Printf (" STR ", p , hasAlternatingBits ( p . one )) # } # fmt . Printf (" STR ")
sum := 0 # for i := 1 ; i <= n ; i ++ { # square := i * i # sum += square # } # return sum
t . Parallel () # for _ , tc := range testcases { # if result := SmallerRightCount ( tc . nums ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
var i int # for j , k := 0 , 0 ; j < len ( nums ); j = k { # for k < len ( nums ) && nums [ j ] == nums [ k ] { # if k < j + 2 { # nums [ i ] = nums [ k ] # i ++ # } # k ++ # } # } # return i
result := make ([] int , 0 , len ( left ) + len ( right )) # # for len ( left ) > 0 || len ( right ) > 0 { # if len ( left ) == 0 { # return append ( result , right ...) # } # if len ( right ) == 0 { # return append ( result , left ...) # } # if left [ 0 ] <= right [ 0 ] { # result = append ( result , left [ 0 ]) # left = left [ 1 :] # } else { # result = append ( result , right [ 0 ]) # right = right [ 1 :] # } # } # # return result
if 0 == n { # return 0 # } else { # return n / 5 + trailingZeroes ( n / 5 ) # }
n := len ( s ) # uf := newUnionFind ( n ) # # for _ , p := range pairs { # uf . connect ( p [ 0 ], p [ 1 ]) # } # # groups := make ( map [ int ][] int , n ) # for c , p := range uf . parent { # p = uf . find ( p ) # groups [ p ] = append ( groups [ p ], c ) # } # # bytes := [] byte ( s ) # res := make ([] byte , n ) # for _ , g := range groups { # size := len ( g ) # a := make ([] int , size ) # copy ( a , g ) # sort . Slice ( a , func ( i , j int ) bool { # return bytes [ a [ i ]] < bytes [ a [ j ]] # }) # sort . Ints ( g ) # for i := 0 ; i < size ; i ++ { # res [ g [ i ]] = bytes [ a [ i ]] # } # } # # return string ( res )
data := [][] int { # { 2 }, # { 3 , 4 }, # { 6 , 5 , 7 }, # { 4 , 1 , 8 , 3 }} # # fmt . Println ( minimumTotal ( data ))
left , right , res := 0 , - 1 , 0 # for left < len ( s ) { # if right + 1 < len ( s ) && maxCost - abs ( int ( s [ right + 1 ]-' a ')- int ( t [ right + 1 ]-' a ')) >= 0 { # right ++ # maxCost -= abs ( int ( s [ right ]-' a ') - int ( t [ right ]-' a ')) # } else { # res = max ( res , right - left + 1 ) # maxCost += abs ( int ( s [ left ]-' a ') - int ( t [ left ]-' a ')) # left ++ # } # } # return res
nums := [] int {} # for n != 0 { # nums = append ( nums , n % 1 0 ) # n /= 1 0 # } # m := len ( nums ) # if m < 2 { # return - 1 # } # # i := 1 # for i < m { # if nums [ i ] < nums [ i - 1 ] { # break # } # i ++ # } # # if i == m { # return - 1 # } # # j := 0 # for j < i { # if nums [ j ] > nums [ i ] { # break # } # j ++ # } # nums [ i ], nums [ j ] = nums [ j ], nums [ i ] # for k := 0 ; k < i / 2 ; k ++ { # nums [ k ], nums [ i - k - 1 ] = nums [ i - k - 1 ], nums [ k ] # } # res := 0 # p := 1 # for _ , n := range nums { # res += n * p # p *= 1 0 # } # if res > math . MaxInt 3 2 { # return - 1 # } # return res
x := [] int { 1 0 , 2 0 , 3 0 , 4 0 , 5 0 } # for k , v := range x { # fmt . Printf (" STR ", k , v ) # }
t . Parallel () # for _ , tc := range testcases { # if jumps , impassable := MinimumJumps ( tc . maxSteps ); impassable != tc . impassable || jumps != tc . expectedJumps { # t . Errorf (" STR ", tc . expectedJumps , tc . impassable , jumps , impassable ) # } # }
c . bw . WriteString (" STR ") # c . bw . WriteByte ( space ) # c . bw . WriteString ( key ) # c . bw . WriteByte ( space ) # c . bw . Write ( strconv . AppendInt ( c . numScratch [: 0 ], int 6 4 ( timeout ), 1 0 )) # _ , err = c . bw . Write ( crlf ) # return
if len ( s ) == 0 { # return " STR " # } # start := 0 # maxLen := 1 # for index := range s { # l := index - maxLen # end := index + 1 # if l >= 1 && sym ( s [ l - 1 : end ]) { # start = l - 1 # maxLen += 2 # } else if l >= 0 && sym ( s [ l : end ]) { # start = l # maxLen += 1 # } # } # return s [ start : start + maxLen ]
http . HandleFunc ( path , func ( res http . ResponseWriter , req * http . Request ) { # err := handleFunc ( res , req ) # if err != nil { # http . Error ( res , err . Error (), 5 0 0 ) # } # })
kind := t . Kind () # if kind >= Int && kind <= Complex 1 2 8 { # return int ( t . Size ()) * 8 # } # panic ( TypeError {" STR "})
println (" STR ", len ( a ))
return e . Errs [ 0 ]. Error ()
stack := make ([] int , 0 ) # result := make ([] int , len ( T )) # for i , t := range T { # for len ( stack ) > 0 && T [ stack [ len ( stack )- 1 ]] < t { # result [ stack [ len ( stack )- 1 ]] = i - stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # } # # stack = append ( stack , i ) # } # # for _ , i := range stack { # result [ i ] = 0 # } # # return result
h := new ( IntArray ) # h . heapIntArrays = arr # h . heap . binHeapArrayIf = & h . heapIntArrays # h . BuildHeap () # return h
if n == 1 || n == 2 { # return big . NewInt ( 1 ) # } # if mem [ n ] != nil { # return mem [ n ] # } # result := big . NewInt ( 0 ) # result . Add ( FibonacciHelper ( n - 1 , mem ), FibonacciHelper ( n - 2 , mem )) # mem [ n ] = result # return result
coins := [] int { 1 , 2 , 5 , 1 0 , 2 0 , 5 0 , 1 0 0 , 2 0 0 } # memo := make ( map [ string ] int ) # return findAllWays ( coins , 0 , n , memo )
data , err := base 6 4 . StdEncoding . DecodeString ( b 6 4 ) # if err != nil { # panic (" STR ") # } # # return hex . EncodeToString ( data )
qs := [] question 3 2 2 { # # { # para 3 2 2 {[] int { 1 8 6 , 4 1 9 , 8 3 , 4 0 8 }, 6 2 4 9 }, # ans 3 2 2 { 2 0 }, # }, # # { # para 3 2 2 {[] int { 1 , 2 1 4 7 4 8 3 6 4 7 }, 2 }, # ans 3 2 2 { 2 }, # }, # # { # para 3 2 2 {[] int { 1 , 2 , 5 }, 1 1 }, # ans 3 2 2 { 3 }, # }, # { # para 3 2 2 {[] int { 2 }, 3 }, # ans 3 2 2 {- 1 }, # }, # # { # para 3 2 2 {[] int { 1 }, 0 }, # ans 3 2 2 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 2 2 , q . para 3 2 2 # fmt . Printf (" STR ", p , coinChange ( p . one , p . amount )) # } # fmt . Printf (" STR ")
t . Parallel () # for _ , tc := range testcases { # if bonuses := Bonuses ( tc . locs ); ! reflect . DeepEqual ( bonuses , tc . bonuses ) { # t . Errorf (" STR ", tc . bonuses , bonuses ) # } # }
count := uint 3 2 ( 0 ) # for num != 0 { # count += num & 1 # # num = num >> 1 # } # return int ( count )
var sum int # for _ , num := range nums { # sum += num # } # # if sum % 2 != 0 { # return false # } # # c := sum / 2 # n := len ( nums ) # memo := make ([] bool , c + 1 ) # # for i := 0 ; i <= c ; i ++ { # memo [ i ] = nums [ 0 ] == i # } # # for i := 0 ; i < n ; i ++ { # for j := c ; j >= nums [ i ]; j -- { # memo [ j ] = memo [ j ] || memo [ j - nums [ i ]] # } # } # return memo [ c ]
count 1 := 0 # for _ , r := range S { # if r == '(' { # count 1 ++ # } else if count 1 > 0 { # count 1 -- # } # } # # count 2 := 0 # for i := len ( S ) - 1 ; i >= 0 ; i -- { # if S [ i ] == ')' { # count 2 ++ # } else if count 2 > 0 { # count 2 -- # } # } # # return count 1 + count 2
for i := rangeMin ; i <= rangeMax ; i ++ { # if evenlyDivisble % i != 0 { # evenlyDivisble = evenlyDivisble * lcm ( evenlyDivisble , i ) # } # fmt . Println ( evenlyDivisble , " STR ", i , " STR ", evenlyDivisble / i ) # }
log . SetFlags ( 0 ) # # var err error # # tpl := template . New (" STR ") # tpl = tpl . Funcs ( template . FuncMap { # " STR ": func ( str string ) string { # return strings . ToUpper ( str ) # }, # }) # tpl , err = tpl . ParseFiles (" STR ") # if err != nil { # log . Fatalln ( err ) # } # err = tpl . ExecuteTemplate ( os . Stdout , " STR ", Page { # Title : " STR ", # Body : " STR ", # }) # if err != nil { # log . Fatalln ( err ) # }
return append ( ints , added ...)
left , right := 0 , len ( nums )- 1 # for left < right { # mid := ( left + right ) / 2 # count := 0 # for _ , num := range nums { # if num <= mid { # count ++ # } # } # if count > mid { # right = mid # } else { # left = mid + 1 # } # } # return left
var min int # totalPeople := 0 # for i := range seating { # if seating [ i ] == 1 { # totalPeople ++ # } # } # if totalPeople < 2 { # return 0 # } # middle := ( totalPeople / 2 ) + ( totalPeople % 2 ) # index := 0 # for i := range seating { # if seating [ i ] == 1 { # middle -- # } # if middle == 0 { # index = i # break # } # } # leftZero := 0 # leftZeroFound := false # for j := index - 1 ; j >= 0 ; j -- { # if ! leftZeroFound && seating [ j ] == 0 { # leftZero = j # leftZeroFound = true # } else if seating [ j ] == 1 && j < leftZero { # min += abs ( j - leftZero ) # leftZero -- # } # } # rightZero := 0 # rightZeroFound := false # for j := index + 1 ; j < len ( seating ); j ++ { # if ! rightZeroFound && seating [ j ] == 0 { # rightZero = j # rightZeroFound = true # } else if seating [ j ] == 1 && j > rightZero { # min += abs ( j - rightZero ) # rightZero ++ # } # } # return min
targetRange := [] int {- 1 , - 1 } # # for i := 0 ; i < len ( nums ); i ++ { # if nums [ i ] == target { # targetRange [ 0 ] = i # break # } # } # if targetRange [ 0 ] == - 1 { # return targetRange # } # # for j := len ( nums ) - 1 ; j >= 0 ; j -- { # if nums [ j ] == target { # targetRange [ 1 ] = j # break # } # } # return targetRange
var tests = [] struct { # before [] int # after * ListNode # }{ # {[] int {}, nil }, # {[] int { 1 }, newList ( 1 )}, # {[] int { 1 , 2 , 3 , 4 , 5 }, newList ( 1 , 3 , 5 , 2 , 4 )}, # {[] int { 1 , 2 , 3 , 4 , 5 , 6 }, newList ( 1 , 3 , 5 , 2 , 4 , 6 )}, # {[] int { 2 , 1 , 3 , 5 , 6 , 4 , 7 }, newList ( 2 , 3 , 6 , 7 , 1 , 5 , 4 )}, # } # # for _ , tt := range tests { # after := oddEvenList ( newList ( tt . before ...)) # if reflect . DeepEqual ( after , tt . after ) == false { # t . Errorf (" STR ", newList ( tt . before ...), after , tt . after ) # } # }
out := 4 5 2 2 8 # if x := p 3 2 (); x != out { # t . Errorf (" STR ", x , out ) # }
t . Parallel () # for _ , tc := range testcases { # if result := SecondLargest ( tc . root ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
primes := [...] int { 2 : 1 , 3 : 1 , 5 : 1 , 7 : 1 , 1 1 : 1 , 1 3 : 1 , 1 7 : 1 , 1 9 : 1 } # # res := 0 # for i := L ; i <= R ; i ++ { # bits := 0 # for n := i ; n > 0 ; n >>= 1 { # bits += n & 1 # } # res += primes [ bits ] # } # # return res
qs := [] question 1 2 3 2 { # # { # para 1 2 3 2 {[][] int {{ 1 , 2 }, { 2 , 3 }, { 3 , 4 }, { 4 , 5 }, { 5 , 6 }, { 6 , 7 }}}, # ans 1 2 3 2 { true }, # }, # # { # para 1 2 3 2 {[][] int {{ 1 , 1 }, { 2 , 2 }, { 3 , 4 }, { 4 , 5 }, { 5 , 6 }, { 7 , 7 }}}, # ans 1 2 3 2 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 3 2 , q . para 1 2 3 2 # fmt . Printf (" STR ", p , checkStraightLine ( p . arr )) # } # fmt . Printf (" STR ")
var tests = [] struct { # nums [] int # missing int # }{ # {[] int { 1 , 1 }, 2 }, # {[] int { 1 , 2 , 0 }, 3 }, # {[] int { 3 , 4 , - 1 , 1 }, 2 }, # {[] int { 7 , 8 , 9 , 1 1 , 1 2 }, 1 }, # } # # for _ , tt := range tests { # nums := make ([] int , len ( tt . nums )) # copy ( nums , tt . nums ) # # missing := firstMissingPositive ( tt . nums ) # if missing != tt . missing { # t . Errorf (" STR ", nums , missing , tt . missing ) # } # }
m := len ( matrix ) # if m == 0 { # return nil # } # # n := len ( matrix [ 0 ]) # if n == 0 { # return nil # } # # if m == 1 { # return matrix [ 0 ] # } # # res := make ([] int , 0 , m * n ) # # res = append ( res , matrix [ 0 ]...) # for i := 1 ; i < m - 1 ; i ++ { # res = append ( res , matrix [ i ][ n - 1 ]) # } # for i := n - 1 ; i >= 0 ; i -- { # res = append ( res , matrix [ m - 1 ][ i ]) # } # for i := m - 2 ; i > 0 && n > 1 ; i -- { # res = append ( res , matrix [ i ][ 0 ]) # } # # if m == 2 || n <= 2 { # return res # } # # next := make ([][] int , m - 2 ) # for i := 0 ; i < m - 2 ; i ++ { # next [ i ] = matrix [ i + 1 ][ 1 : n - 1 ] # } # return append ( res , spiralOrder ( next )...)
if nil == head || nil == head . Next || # m == n { # return head # } # # step := n - m # var leftTail * ListNode # p := head # for m > 1 { # leftTail = p # p = p . Next # m -- # } # # q := p . Next # p . Next = nil # midTail := p # for step > 0 { # r := q . Next # q . Next = p # p = q # q = r # step -- # } # # if nil == leftTail { # midTail . Next = q # return p # } # # leftTail . Next = p # midTail . Next = q # return head
var tests = [] struct { # tree * TreeNode # depth int # }{ # { newTree ( 3 , 9 , 2 0 , nil , nil , 1 5 , 7 ), 2 }, # { newTree ( 1 , 2 ), 2 }, # { newTree ( 1 , 2 , 2 , 3 ), 2 }, # { newTree ( 1 , 2 , 2 , 3 , 3 , nil , nil , 4 , 4 ), 2 }, # { newTree ( 1 , 2 , 2 , 3 , nil , 3 , 3 , 4 ), 3 }, # { newTree ( 1 , 2 , 2 , nil , nil , nil , 3 , 4 , 4 ), 2 }, # } # # for _ , tt := range tests { # depth := minDepth ( tt . tree ) # if depth != tt . depth { # t . Errorf (" STR ", tt . tree , depth , tt . depth ) # } # }
t . Parallel () # d := NewTimeMap () # d . Set ( 1 , 1 , 0 ) # d . Set ( 1 , 2 , 2 ) # if result := d . Get ( 1 , 1 ); result != 1 { # t . Errorf (" STR ") # } # if result := d . Get ( 1 , 3 ); result != 2 { # t . Errorf (" STR ") # } # d . Set ( 1 , 1 , 5 ) # if result := d . Get ( 1 , 0 ); result != 1 { # t . Errorf (" STR ") # } # if result := d . Get ( 1 , 1 0 ); result != 1 { # t . Errorf (" STR ") # } # d . Set ( 1 , 1 , 0 ) # d . Set ( 1 , 2 , 0 ) # if result := d . Get ( 1 , 0 ); result != 2 { # t . Errorf (" STR ") # } # if result := d . Get ( 2 , 0 ); result != nil { # t . Errorf (" STR ") # } # if result := d . Get ( 1 , - 1 ); result != nil { # t . Errorf (" STR ") # }
if len ( steps ) < 2 { # return true # } # for step := 1 ; step <= steps [ 0 ] && step <= len ( steps ); step ++ { # if CanAdvanceToEndBrute ( steps [ step :]) { # return true # } # } # return false
obj := Constructor 2 2 5 () # fmt . Printf (" STR ", obj ) # param 5 := obj . Empty () # fmt . Printf (" STR ", param 5 ) # obj . Push ( 2 ) # fmt . Printf (" STR ", obj ) # obj . Push ( 1 0 ) # fmt . Printf (" STR ", obj ) # param 2 := obj . Pop () # fmt . Printf (" STR ", param 2 ) # param 3 := obj . Top () # fmt . Printf (" STR ", param 3 ) # param 4 := obj . Empty () # fmt . Printf (" STR ", param 4 )
cases := [] struct { # name string # inputs [] string # expect [][] string # }{ # {" STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # [][] string { # {" STR ", " STR ", " STR "}, # {" STR ", " STR "}, # {" STR "}, # }, # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := groupAnagrams ( c . inputs ) # fmt . Println ( got ) # }) # }
i 1 := 0 # i 2 := 0 # val 1 := 0 # val 2 := 0 # # for i 1 < len ( version 1 ) || i 2 < len ( version 2 ) { # val 1 , i 1 = parseSeg ( version 1 , i 1 ) # val 2 , i 2 = parseSeg ( version 2 , i 2 ) # # if val 1 > val 2 { # return 1 # } # # if val 1 < val 2 { # return - 1 # } # } # # if i 1 < len ( version 1 ) { # return 1 # } # # if i 2 < len ( version 2 ) { # return - 1 # } # # return 0
result := make ([] int , 0 ) # for i := 0 ; i < n ; i ++ { # result = append ( result , nums [ i ]) # result = append ( result , nums [ n + i ]) # } # return result
nums := make ([] byte , n ) # for i := 0 ; i < n ; i ++ { # nums [ i ] = byte ( i ) + ' 1 ' # } # # for i := 2 ; i <= k ; i ++ { # nextPermutation 6 0 ( nums ) # } # # return string ( nums )
t . Parallel () # for _ , tc := range testcases { # if result := MakePalindrome ( tc . input ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
ln , err := net . Listen (" STR ", " STR ") # if err != nil { # panic ( err ) # } # defer ln . Close () # # for { # conn , err := ln . Accept () # if err != nil { # panic ( err ) # } # # fmt . Println (" STR ", conn . RemoteAddr ()) # # io . WriteString ( conn , fmt . Sprint ( time . Now ())) # # conn . Close () # }
self . table [ index ]. Num = value
return x .( int ) < y .( int )
return strings . Replace ( address , " STR ", " STR ", - 1 )
var parts [] string # var isFile bool # var partStart , tabCount , maxLength int # for i , r := range fs { # switch { # case isNewStart ( i , r , fs ): # partStart = i # case r == '.': # isFile = true # case r == '\ t ': # tabCount ++ # case r == '\ n ': # if pos := tabCount ; len ( parts ) > pos { # parts = parts [: pos ] # } # parts = append ( parts , fs [ partStart : i ]) # if len := len ( strings . Join ( parts , " STR ")); isFile && len > maxLength { # maxLength = len # } # isFile = false # tabCount = 0 # } # } # if isFile { # parts = append ( parts , fs [ partStart :]) # } # return len ( strings . Join ( parts , " STR "))
FprintVersion ( os . Stdout )
cnt := 0 # for i := 0 ; cnt < n && i < len ( flowerbed ); i ++ { # if i > 0 && flowerbed [ i - 1 ] == 1 { # continue # } # if i < len ( flowerbed )- 1 && flowerbed [ i + 1 ] == 1 { # continue # } # if flowerbed [ i ] != 0 { # continue # } # flowerbed [ i ] = 1 # cnt ++ # if i < len ( flowerbed )- 1 { # flowerbed [ i + 1 ] = - 1 # } # } # return cnt >= n
m := len ( A ) # n := len ( A [ 0 ]) # ans := make ([][] int , n ) # for k := range ans { # ans [ k ] = make ([] int , m ) # } # for r := 0 ; r < m ; r ++ { # for c := 0 ; c < n ; c ++ { # ans [ c ][ r ] = A [ r ][ c ] # } # } # return ans
patternMap := make ( map [ string ] string ) # strMap := make ( map [ string ] string ) # # plen := len ( pattern ) # strArr := strings . Split ( str , " STR ") # patternArr := strings . Split ( pattern , " STR ") # # if plen != len ( strArr ) { # return false # } # # for i := 0 ; i < plen ; i ++ { # # if _ , ok := patternMap [ patternArr [ i ]]; ! ok { # # patternMap [ patternArr [ i ]] = strArr [ i ] # # } # # if _ , ok := strMap [ strArr [ i ]]; ! ok { # # strMap [ strArr [ i ]] = patternArr [ i ] # # } # # if patternMap [ patternArr [ i ]] != strArr [ i ] || strMap [ strArr [ i ]] != patternArr [ i ] { # fmt . Println (" STR ", patternMap ) # fmt . Println (" STR ", strMap ) # return false # } # } # fmt . Println (" STR ", patternMap ) # fmt . Println (" STR ", strMap ) # return true
nlen := len ( nums ) # for i := 0 ; i < nlen - 2 ; i ++ { # if i != 0 && nums [ i ] == nums [ i - 1 ] { # continue # } # # left , right := i + 1 , nlen - 1 # for left < right { # sum := nums [ i ] + nums [ left ] + nums [ right ] # if sum == target { # * res = append (* res , [] int { first , nums [ i ], nums [ left ], nums [ right ]}) # for left < right && nums [ left ] == nums [ left + 1 ] { # left ++ # } # for left < right && nums [ right ] == nums [ right - 1 ] { # right -- # } # left ++ # right -- # } else if sum < target { # for left < right && nums [ left ] == nums [ left + 1 ] { # left ++ # } # left ++ # } else { # for left < right && nums [ right ] == nums [ right - 1 ] { # right -- # } # right -- # } # } # }
sLen , tLen := len ( s ), len ( t ) # # need := [ 2 5 6 ] int {} # for i := range t { # need [ t [ i ]]++ # } # # has := [ 2 5 6 ] int {} # # min := sLen + 1 # begin , end , winBegin , winEnd , count := 0 , 0 , 0 , 0 , 0 # # for ; end < sLen ; end ++ { # if need [ s [ end ]] == 0 { # continue # } # # if has [ s [ end ]] < need [ s [ end ]] { # count ++ # } # has [ s [ end ]]++ # # if count == tLen { # for need [ s [ begin ]] == 0 || has [ s [ begin ]] > need [ s [ begin ]] { # if has [ s [ begin ]] > need [ s [ begin ]] { # has [ s [ begin ]]-- # } # begin ++ # } # # temp := end - begin + 1 # if min > temp { # min = temp # winBegin = begin # winEnd = end # } # } # } # # if count < tLen { # return " STR " # } # # return s [ winBegin : winEnd + 1 ]
t . Parallel () # for _ , tc := range testcases { # if steps := MinimumStepsPath ( tc . path ); steps != tc . minimumSteps { # t . Errorf (" STR ", tc . minimumSteps , steps ) # } # }
n := len ( cost ) # dp := make ([] int , n ) # dp [ 0 ], dp [ 1 ] = cost [ 0 ], cost [ 1 ] # for i := 2 ; i < n ; i ++ { # dp [ i ] = cost [ i ] + min ( dp [ i - 2 ], dp [ i - 1 ]) # } # return min ( dp [ n - 2 ], dp [ n - 1 ])
qs := [] question 8 4 5 { # { # para 8 4 5 {[] int { 8 7 5 , 8 8 4 , 2 3 9 , 7 3 1 , 7 2 3 , 6 8 5 }}, # ans 8 4 5 { 4 }, # }, # # { # para 8 4 5 {[] int { 0 , 1 , 2 , 3 , 4 , 5 , 4 , 3 , 2 , 1 , 0 }}, # ans 8 4 5 { 1 1 }, # }, # # { # para 8 4 5 {[] int { 2 , 3 }}, # ans 8 4 5 { 0 }, # }, # # { # para 8 4 5 {[] int { 2 , 1 , 4 , 7 , 3 , 2 , 5 }}, # ans 8 4 5 { 5 }, # }, # # { # para 8 4 5 {[] int { 2 , 2 , 2 }}, # ans 8 4 5 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 4 5 , q . para 8 4 5 # fmt . Printf (" STR ", p , longestMountain ( p . one )) # } # fmt . Printf (" STR ")
res := make ([] int , 0 ) # for i := 0 ; i < len ( nums ); i = i + 2 { # freq , val := nums [ i ], nums [ i + 1 ] # for j := 0 ; j < freq ; j ++ { # res = append ( res , val ) # } # } # return res
defer wg . Done () # for v := range taskQueue { # fmt . Printf (" STR ", workerId , v . Id , v . JobId ) # v . Run () # fmt . Printf (" STR ", workerId , v . Status , v . Id , v . JobId ) # }
t . Parallel () # for _ , tc := range testcases { # if result := Reverse 3 2 Bits ( tc . given ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
dummy := & ListNode { 0 , head } # slow , fast := dummy , dummy # for fast . Next != nil && fast . Next . Next != nil { # fast = fast . Next . Next # slow = slow . Next # } # # return slow . Next
fmt . Println ( superEggDrop ( 1 , 2 )) # fmt . Println ( superEggDrop ( 2 , 6 )) # fmt . Println ( superEggDrop ( 2 , 4 ))
var res [] int # stack := []* preOrderTree { root } # for len ( stack ) > 0 { # root = stack [ 0 ] # stack = stack [ 1 :] # res = append ( res , root . data ) # if root . left != nil { # stack = append ( stack , root . left ) # } # if root . right != nil { # stack = append ( stack , root . right ) # } # } # return res
l , r := 0 , 0 # n := len ( s ) # for i := 0 ; i < n ; i ++ { # if s [ i ] == ')' { # l -- # } else { # l ++ # } # # j := n - i - 1 # if s [ j ] == '(' { # r -- # } else { # r ++ # } # # if l < 0 || r < 0 { # return false # } # } # # return true
type A struct { # Name string # D string # } # a := A { Name : " STR "} # # type B struct { # A A # C int # } # b := & B { A : a , C : 1 2 3 } # # ok := HasZero ( b ) # if ! ok { # t . Error (" STR ") # }
for i , row := range matrix [ 1 :] { # for j , v := range row [ 1 :] { # if v != matrix [ i ][ j ] { # return false # } # } # } # return true
qs := [] question 2 8 { # # { # para 2 8 {" STR ", " STR "}, # ans 2 8 { 0 }, # }, # # { # para 2 8 {" STR ", " STR "}, # ans 2 8 { 2 }, # }, # # { # para 2 8 {" STR ", " STR "}, # ans 2 8 { 0 }, # }, # # { # para 2 8 {" STR ", " STR "}, # ans 2 8 { 5 }, # }, # # { # para 2 8 {" STR ", " STR "}, # ans 2 8 {- 1 }, # }, # # { # para 2 8 {" STR ", " STR "}, # ans 2 8 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 8 , q . para 2 8 # fmt . Printf (" STR ", p , strStr ( p . s , p . p )) # } # fmt . Printf (" STR ")
digits := " STR " # # for i := 1 ; i < 9 9 9 9 ; i ++ { # num := " STR "; # for j := 1 ; j < 5 ; j ++ { # if len ( num ) < 9 { # num += strconv . Itoa ( i * j ) # } # } # arr := strings . Split ( num , " STR ") # sort . Strings ( arr ) # numSorted := strings . Join ( arr , " STR ") # # if numSorted == digits { # return num # } # } # # # return " STR "
obj := Constructor 9 3 3 () # fmt . Printf (" STR ", obj ) # param 1 := obj . Ping ( 1 ) # fmt . Printf (" STR ", param 1 ) # param 1 = obj . Ping ( 1 0 0 ) # fmt . Printf (" STR ", param 1 ) # param 1 = obj . Ping ( 3 0 0 1 ) # fmt . Printf (" STR ", param 1 ) # param 1 = obj . Ping ( 3 0 0 2 ) # fmt . Printf (" STR ", param 1 )
root := new (* TreeNode ) # insertArrayToTreeNode ( root , array , 0 ) # return * root
res := 0 # # sort . Ints ( houses ) # sort . Ints ( heaters ) # # m , n := len ( houses ), len ( heaters ) # # index := sort . SearchInts ( heaters , houses [ 0 ]) # for _ , house := range houses { # for index < n && house > heaters [ index ] { # index ++ # } # # if index == n { # return max ( res , houses [ m - 1 ]- heaters [ index - 1 ]) # } # left := math . MaxInt 3 2 # if index > 0 { # left = house - heaters [ index - 1 ] # } # right := heaters [ index ] - house # res = max ( res , min ( left , right )) # } # return res
c := Candidates ( candidates ) # sort . Sort ( c ) # return orderedCombinationSum 2 ( c , target )
t . Parallel () # for _ , tc := range testcases { # results := HeapsAlgorithmRecursive ( tc . input ) # pos := 0 # for result := range results { # if ! reflect . DeepEqual ( result , tc . expected [ pos ]) { # t . Errorf (" STR ", tc . expected [ pos ], result ) # } # pos ++ # } # }
for i := 1 ; i < len ( nums ); i ++ { # if nums [ i - 1 ] > nums [ i ] { # pre := deepCopy ( nums ) # pre [ i - 1 ] = pre [ i ] # next := deepCopy ( nums ) # next [ i ] = next [ i - 1 ] # return sort . IsSorted ( sort . IntSlice ( pre )) || sort . IsSorted ( sort . IntSlice ( next )) # } # } # # return true
res := [] int {} # for _ , num := range nums { # n := num # if n < 0 { # n *= - 1 # } # if nums [ n - 1 ] < 0 { # res = append ( res , n ) # } else { # nums [ n - 1 ] *= - 1 # } # } # return res
qs := [] question 1 2 8 1 { # # { # para 1 2 8 1 { 2 3 4 }, # ans 1 2 8 1 { 1 5 }, # }, # # { # para 1 2 8 1 { 4 4 2 1 }, # ans 1 2 8 1 { 2 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 8 1 , q . para 1 2 8 1 # fmt . Printf (" STR ", p , subtractProductAndSum ( p . n )) # } # fmt . Printf (" STR ")
fp := float 6 4 ( p ) # fa := float 6 4 ( a ) # # fb := ( fp * ( fp - 2 . 0 * fa )) / ( 2 . 0 * ( fp - fa )) # b = int ( fb ) # valid = math . Abs ( fb - math . Floor ( fb )) < 0 . 0 0 0 0 0 1 # # return
start := - 1 # lenMax := 0 # dict := [ 2 5 6 ] int {} # for i := range dict { # dict [ i ] = - 1 # } # for i , r := range s { # if v := dict [ r ]; v > start { # start = v # } # length := i - start # if length > lenMax { # lenMax = length # } # dict [ r ] = i # } # return lenMax
return & skipListNode { v : v , score : score , forwards : make ([]* skipListNode , level , level ), level : level }
m := [ 2 6 ] int {} # for _ , b := range B { # count := counter ( b ) # for i , c := range m { # if count [ i ] > c { # m [ i ] = count [ i ] # } # } # } # res := [] string {} # L : # for _ , a := range A { # count := counter ( a ) # for i , c := range m { # if count [ i ] > c { # continue L # } # } # res = append ( res , a ) # } # return res
bulls , cows := 0 , 0 # nums := [ 1 0 ] int {} # for i := 0 ; i < len ( secret ); i ++ { # s , g := int ( secret [ i ]-' 0 '), int ( guess [ i ]-' 0 ') # if s == g { # bulls ++ # } else { # # if nums [ s ] < 0 { # cows ++ # } # if nums [ g ] > 0 { # cows ++ # } # nums [ s ]++ # nums [ g ]-- # } # } # return fmt . Sprintf (" STR ", bulls , cows )
t . Parallel () # # for _ , l := range mathTestData { # if log 2 Floor ( l . n ) != l . f || log 2 Ceil ( l . n ) != l . c { # t . Errorf (" STR ", # l . n , l . f , l . c , log 2 Floor ( l . n ), log 2 Ceil ( l . n )) # } # }
bs := strings . Builder {} # # var dfs func (* TreeNode ) # dfs = func ( node * TreeNode ) { # if node == nil { # return # } # bs . WriteString ( strconv . Itoa ( node . Val )) # if node . Left == nil && node . Right == nil { # return # } # bs . WriteByte ('(') # if node . Left != nil { # dfs ( node . Left ) # } # bs . WriteByte (')') # if node . Right != nil { # bs . WriteByte ('(') # dfs ( node . Right ) # bs . WriteByte (')') # } # } # dfs ( t ) # return bs . String ()
return nil == root || isSame ( root . Left , root . Right )
cases := [] struct { # name string # flowerbed [] int # n int # expect bool # }{ # {" STR ", [] int { 1 , 0 , 0 , 0 , 1 }, 1 , true }, # {" STR ", [] int { 1 , 0 , 0 , 0 , 1 }, 2 , false }, # {" STR ", [] int { 1 , 0 , 1 , 0 }, 0 , true }, # {" STR ", [] int { 0 }, 1 , true }, # {" STR ", [] int { 1 , 0 , 1 , 0 , 1 , 0 , 1 }, 1 , false }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . flowerbed , c . n ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . flowerbed , c . n ) # } # }) # }
const maxDiv = 2 0 # i , div := maxDiv , maxDiv - 1 # # for { # if i % div == 0 { # if div > 1 { # div -- # } else { # fmt . Println ( i ) # os . Exit ( 0 ) # } # } else { # i += maxDiv # div = maxDiv - 1 # } # }
o := make ([] int , len ( nums )) # n := make ([] int , len ( nums )) # copy ( o , nums ) # copy ( n , nums ) # return Solution { origNums : o , nums : n }
conn , err := net . Dial (" STR ", " STR ") # if err != nil { # log . Fatal ( err ) # } # done := make ( chan struct {}) # go func () { # io . Copy ( os . Stdout , conn ) # log . Println (" STR ") # done <- struct {}{} # }() # mustCopy ( conn , os . Stdin ) # conn . Close () # <- done
if m == n { # return head # } # # headPre := & ListNode {} # headPre . Next = head # m ++ # n ++ # # mPre , mNode , nNext := split ( headPre , m , n ) # h , e := reverse ( mNode ) # mPre . Next = h # e . Next = nNext # return headPre . Next
l , err := net . Listen (" STR ", " STR ") # if err != nil { # log . Fatal ( err ) # } # for { # conn , err := l . Accept () # if err != nil { # log . Print ( err ) # continue # } # go handleConn ( conn ) # }
expected := map [ int ] int { # 1 : 1 , # 2 : 3 , # 3 : 6 , # 4 : 1 0 , # 5 : 1 5 , # 6 : 2 1 , # } # # actual := make ( map [ int ] int ) # # for x := 1 ; x <= 6 ; x ++ { # actual [ x ] = GetTriangular ( x ) # } # # if reflect . DeepEqual ( expected , actual ) == false { # t . Errorf (" STR ", expected , actual ) # }
var tests = [] struct { # tree * TreeNode # val int # subtree * TreeNode # }{ # { newTree ( 4 , 2 , 7 , 1 , 3 ), 2 , newTree ( 2 , 1 , 3 )}, # { newTree ( 4 , 2 , 7 , 1 , 3 ), 5 , nil }, # } # # for _ , tt := range tests { # subtree := searchBST ( tt . tree , tt . val ) # if reflect . DeepEqual ( subtree , tt . subtree ) == false { # t . Errorf (" STR ", tt . tree , tt . val , subtree , tt . subtree ) # } # }
defer wg . Done () # # for count := 0 ; count < 2 ; count ++ { # mutex . Lock () # { # value := counter # # runtime . Gosched () # # value ++ # # counter = value # } # mutex . Unlock () # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # { # " STR ", # [] int { 1 , 3 , 5 , 4 , 7 }, # 3 , # }, # { # " STR ", # [] int { 2 , 2 , 2 , 2 , 2 }, # 1 , # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := findLengthOfLCIS ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", c . expect , got , c . inputs ) # } # }) # }
tests := [...] testType { # { # in : [] int { 3 , 2 , 3 }, # want : 3 , # }, # { # in : [] int { 2 , 2 , 1 , 1 , 1 , 2 , 2 }, # want : 2 , # }, # { # in : [] int { 2 , 2 , 2 , 2 , 1 , 1 , 1 }, # want : 2 , # }, # { # in : [] int { 1 }, # want : 1 , # }, # } # for _ , tt := range tests { # got := majorityElement ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
last = nil # return dfs ( root )
length := len ( nums ) # if length == 0 { # return # } # # temp := nums [ 0 ] # nums [ 0 ] = 1 # # i , j , k := 0 , 1 , length - 1 # for j <= k { # switch { # case nums [ j ] < 1 : # nums [ i ], nums [ j ] = nums [ j ], nums [ i ] # i ++ # j ++ # case 1 < nums [ j ]: # nums [ j ], nums [ k ] = nums [ k ], nums [ j ] # k -- # default : # j ++ # } # } # # switch temp { # case 0 : # nums [ i ] = temp # case 2 : # nums [ k ] = temp # } # # return
if left > right { # return nil # } # root := & TreeNode { Val : postorder [ p ]} # p -- # idx := idxMap [ root . Val ] # root . Right = build ( idx + 1 , right , postorder ) # root . Left = build ( left , idx - 1 , postorder ) # return root
if b == 0 { # return a # } # sum := a ^ b # carry := ( a & b ) << 1 # return getSum ( sum , carry )
if l . len == 0 { # return nil # } # return l . root . l
timeAsString := " STR " # timeAsTime , _ := time . Parse (" STR ", timeAsString ) # # fmt . Println ( timeAsTime . Format ( time . UnixDate )) #
qs := [] question 8 9 6 { # # { # para 8 9 6 {[] int { 2 , 1 , 3 }}, # ans 8 9 6 { false }, # }, # # { # para 8 9 6 {[] int { 1 , 2 , 2 , 3 }}, # ans 8 9 6 { true }, # }, # # { # para 8 9 6 {[] int { 6 , 5 , 4 , 4 }}, # ans 8 9 6 { true }, # }, # # { # para 8 9 6 {[] int { 1 , 3 , 2 }}, # ans 8 9 6 { false }, # }, # # { # para 8 9 6 {[] int { 1 , 2 , 4 , 5 }}, # ans 8 9 6 { true }, # }, # # { # para 8 9 6 {[] int { 1 , 1 , 1 }}, # ans 8 9 6 { true }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 9 6 , q . para 8 9 6 # fmt . Printf (" STR ", p , isMonotonic ( p . one )) # } # fmt . Printf (" STR ")
carry , ans := 0 , [] int {} # for i , j := len ( arr 1 )- 1 , len ( arr 2 )- 1 ; i >= 0 || j >= 0 || carry != 0 ; { # if i >= 0 { # carry += arr 1 [ i ] # i -- # } # if j >= 0 { # carry += arr 2 [ j ] # j -- # } # ans = append ([] int { carry & 1 }, ans ...) # carry = -( carry >> 1 ) # } # for idx , num := range ans { # if num != 0 { # return ans [ idx :] # } # } # return [] int { 0 }
if root == nil { # return " STR " # } # if root . Left == root . Right { # return strconv . Itoa ( root . Val ) # } # if root . Left == nil { # return strconv . Itoa ( root . Val ) + " STR " + tree 2 str ( root . Left ) + " STR " # } # return strconv . Itoa ( root . Val ) + " STR " + tree 2 str ( root . Left ) + " STR " + " STR " + tree 2 str ( root . Right ) + " STR "
cases := [] struct { # name string # inputs * ListNode # val int # expect * ListNode # }{ # {" STR ", & ListNode { # Val : 1 , Next : & ListNode { # Val : 2 , Next : & ListNode { # Val : 6 , Next : & ListNode { # Val : 3 , Next : & ListNode { # Val : 4 , Next : & ListNode { # Val : 5 , Next : & ListNode { # Val : 6 , Next : nil , # }, # }, # }, # }, # }}}, 6 , & ListNode {}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := removeElements ( c . inputs , c . val ) # for got != nil { # fmt . Print ( got . Val , " STR ") # got = got . Next # } # # }) # }
i , j := 0 , len ( n . keyValue )- 1 # for i != j { # mid := ( j - i )/ 2 + i # if key == n . keyValue [ mid ]. key { # i = mid # j = mid # } else if n . LessByKey ( key , n . keyValue [ mid ]. key ) { # j = mid # } else { # i = mid + 1 # } # } # return i
return MinStack { # stack : make ([] int , 0 ), # minStack : make ([] int , 0 ), # }
if n == 0 { # return " STR " # } # res := " STR " # if n == 1 { # return res # } # bs := [] byte {} # for i := 1 ; i < n ; i ++ { # for j , count := 0 , 1 ; j < len ( res ); j ++ { # if j + 1 == len ( res ) || res [ j ] != res [ j + 1 ] { # bs = append ( bs , byte ( count +' 0 ')) # bs = append ( bs , res [ j ]) # count = 1 # } else { # count ++ # } # } # res = string ( bs ) # bs = bs [: 0 ] # } # return res
for i , d := range data { # if err := s . Store ( d ); err != nil { # return i , err # } # } # # return len ( data ), nil
if row == n { # * result ++ # return # } # for col := 0 ; col < n ; col ++ { # columns [ row ] = col # if valid ( columns , row ) { # totalNQueensHelper ( n , row + 1 , columns , result ) # } # }
arr := randomSlice ( 0 , 2 0 , 1 0 ) # nodeCnt := 0 # bst := newBstRecrusive () # for _ , v := range arr { # bst . Insert ( uint 3 2 ( v )) # } # delNum := getRand (). Intn ( 1 0 ) + 1 # if * debug { # fmt . Println ( delNum ) # } # for i := 0 ; i < delNum ; i ++ { # bst . Delete ( uint 3 2 ( arr [ i ])) # } # bst . InOrderWalk ( bst . root , checkBst ( t , & nodeCnt , * debug )) # if nodeCnt != len ( arr )- delNum { # t . Log ( fmt . Sprintf (" STR ", len ( arr )- delNum , nodeCnt )) # t . Fail () # } #
res := x ^ y # ret := 0 # for res > 0 { # res &= res - 1 # ret ++ # } # return ret
for a := 1 ; a < 3 3 3 ; a ++ { # for b := a + 1 ; a + b < 6 6 6 ; b ++ { # c := 1 0 0 0 - a - b # # if a * a + b * b == c * c { # fmt . Println ( a * b * c ) # return # } # } # }
m := map [ int ] struct {}{} # l := make ([] int , 0 , len ( timePoints )) # for _ , timePoint := range timePoints { # i := Ttoi ( timePoint ) # if _ , ok := m [ i ]; ok { # return 0 # } # m [ i ] = struct {}{} # l = append ( l , i ) # } # sort . Ints ( l ) # # n := len ( l ) # res := l [ 0 ] - l [ n - 1 ] + 2 4 * 6 0 # for i := 1 ; i < n ; i ++ { # res = min ( res , l [ i ]- l [ i - 1 ]) # } # return res
if n == 1 { # return 1 # } # # pos := make ([] int , len ( primes )) # candidates := make ([] int , len ( primes )) # copy ( candidates , primes ) # # dp := make ([] int , n ) # # dp [ 0 ] = 1 # # for i := 1 ; i < n ; i ++ { # dp [ i ] = min ( candidates ) # for j := 0 ; j < len ( primes ); j ++ { # if dp [ i ] == candidates [ j ] { # pos [ j ]++ # candidates [ j ] = dp [ pos [ j ]] * primes [ j ] # } # } # } # # return dp [ n - 1 ]
min , data := [] int {}, [] int {} # return MinStack { # cur : - 1 , # min : min , # data : data , # }
var n int # var tail * DoublyLL # for tail = head ; tail . Next != nil ; tail = tail . Next { # n ++ # } # n ++ # for i := 0 ; i < n / 2 ; i ++ { # if head . Value != tail . Value { # return false # } # head = head . Next # tail = tail . Prev # } # return true
var inorder func (* TreeNode , * TreeNode ) * TreeNode # inorder = func ( node , tail * TreeNode ) * TreeNode { # if node == nil { # return tail # } # res := inorder ( node . Left , node ) # node . Left = nil # node . Right = inorder ( node . Right , tail ) # return res # } # return inorder ( root , nil )
return len ( ints )
bigInt := big . NewInt ( 2 ) # # bigInt . Exp ( bigInt , big . NewInt ( 1 0 0 0 ), big . NewInt ( 0 )) # # s := [] byte ( bigInt . String ()) # # sum := 0 # # for i := 0 ; i < len ( s ); i ++ { # # integer , _ := strconv . Atoi ( string ( s [ i ])) # # sum += integer # } # # fmt . Println ( sum )
cases := [] struct { # name string # order string # str string # expect string # }{ # {" STR ", " STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR ", " STR "}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . order , c . str ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . order , c . str ) # } # }) # }
left , right := 0 , len ( nums )- 1 # # for left <= right { # mid := left + ( right - left )/ 2 # if nums [ mid ] == target { # left = mid + 1 # } else if nums [ mid ] < target { # left = mid + 1 # # } else if nums [ mid ] > target { # right = mid - 1 # } # } # if right < 0 || nums [ right ] != target { # return - 1 # } # return right
fmt . Println ( sumSubseqWidths ([] int { 2 , 1 , 3 }))
gapValue := len ( array ) # swapCount := 1 # for gapValue >= 1 && swapCount != 0 { # if gapValue != 1 { # gapValue = int ( float 6 4 ( gapValue ) / float 6 4 ( 1 . 3 )) # } # swapCount = 0 # firstItem := 0 # secondItem := gapValue # for secondItem != len ( array ) { # if array [ firstItem ] > array [ secondItem ] { # array [ firstItem ], array [ secondItem ] = array [ secondItem ], array [ firstItem ] # swapCount += 1 # } # firstItem += 1 # secondItem += 1 # } # }
strList := strings . Split ( str , " STR ") # patternByte := [] byte ( pattern ) # if pattern == " STR " || len ( patternByte ) != len ( strList ) { # return false # } # # pMap := map [ byte ] string {} # sMap := map [ string ] byte {} # for index , b := range patternByte { # if _ , ok := pMap [ b ]; ! ok { # if _ , ok = sMap [ strList [ index ]]; ! ok { # pMap [ b ] = strList [ index ] # sMap [ strList [ index ]] = b # } else { # if sMap [ strList [ index ]] != b { # return false # } # } # } else { # if pMap [ b ] != strList [ index ] { # return false # } # } # } # return true
cases := [] struct { # name string # inputs [][] int # expect [][] int # }{ # {" STR ", # [][] int {{ 2 , 3 , 6 , 7 }, { 7 }}, # [][] int {{ 7 }, { 2 , 2 , 3 }}, # }, # {" STR ", # [][] int {{ 2 , 3 , 5 }, { 8 }}, # [][] int {{ 2 , 2 , 2 , 2 }, { 2 , 3 , 3 }, { 3 , 5 }}, # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := combinationSum ( c . inputs [ 0 ], c . inputs [ 1 ][ 0 ]) # # if ! IsEuqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
callback ( subtree . data ) # if subtree . left != nil { # tree . PreorderTraversal ( subtree . left , callback ) # } # if subtree . right != nil { # tree . PreorderTraversal ( subtree . right , callback ) # }
n := len ( num ) # digits := n - k # stack := make ([] byte , n ) # top := 0 # # for i := 0 ; i < n ; i ++ { # for top > 0 && stack [ top - 1 ] > num [ i ] && k > 0 { # top -- # k -- # } # stack [ top ] = num [ i ] # top ++ # } # # i := 0 # for i < digits && stack [ i ] == ' 0 ' { # i ++ # } # if i == digits { # return " STR " # } # return string ( stack [ i : digits ])
self . slots [ self . top ]. Ref = value # self . top ++
defer wg . Done () # for v := range webResponses { # fmt . Println ( v . requestUrl ) # if v . error != nil { # fmt . Println (" STR ", v . error ) # } # fmt . Println (" STR ", v . status ) # fmt . Println (" STR ", v . responseText ) # # }
qs := [] question 1 1 5 4 { # # { # para 1 1 5 4 {" STR "}, # ans 1 1 5 4 { 9 }, # }, # # { # para 1 1 5 4 {" STR "}, # ans 1 1 5 4 { 4 1 }, # }, # # { # para 1 1 5 4 {" STR "}, # ans 1 1 5 4 { 6 0 }, # }, # # { # para 1 1 5 4 {" STR "}, # ans 1 1 5 4 { 6 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 1 5 4 , q . para 1 1 5 4 # fmt . Printf (" STR ", p , dayOfYear ( p . one )) # } # fmt . Printf (" STR ")
b . lock . Lock () # defer b . lock . Unlock () # # l := len ( b . priorityQueue ) # for i := 0 ; i < l ; i ++ { # b . removeEntry ( b . priorityQueue [ 0 ]) # } # # r := b . lruList . Len () # for i := 0 ; i < r ; i ++ { # b . removeEntry ( b . leastUsedEntry ()) # } # return l + r
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 0 , 9 , 2 , 5 , 3 , 7 , 1 0 1 , 1 8 }, 4 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := lengthOfLIS ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
testCases := [] int { # 1 2 3 , - 1 2 3 , 1 0 , 0 , 1 2 2 3 9 9 9 9 9 9 9 9 9 9 , # } # expected := [] int { 3 2 1 , - 3 2 1 , 1 , 0 , 0 } # # for index , data := range testCases { # if res := reverse ( data ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
n := len ( nums ) # if 0 == n || 1 == n { # return n # } # # var ( # res = 2 # i = 2 # index = nextDifferentCharacterIndex ( nums , i , 2 ) # ) # # for index < n { # res ++ # nums [ i ] = nums [ index ] # i ++ # index = nextDifferentCharacterIndex ( nums , i , index + 1 ) # } # return res
return 4 2
tests := [...] testType { # { # in : 0 , # want : false , # }, # { # in : 1 , # want : true , # }, # { # in : 1 2 , # want : false , # }, # { # in : 1 6 , # want : true , # }, # { # in : 2 1 8 , # want : false , # }, # } # for _ , tt := range tests { # got := isPowerOfTwo ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if len ( matrix ) == 0 || len ( matrix [ 0 ]) == 0 { # return false # } # row , col := 0 , len ( matrix [ 0 ])- 1 # for row <= len ( matrix )- 1 && col >= 0 { # if matrix [ row ][ col ] == target { # return true # } # for row <= len ( matrix )- 1 && col >= 0 && matrix [ row ][ col ] < target { # row ++ # } # for row <= len ( matrix )- 1 && col >= 0 && matrix [ row ][ col ] > target { # col -- # } # } # return false
size := len ( A ) # # indexs := make ([] int , size ) # for i := range indexs { # indexs [ i ] = i # } # # sort . Slice ( indexs , func ( i int , j int ) bool { # if A [ indexs [ i ]] == A [ indexs [ j ]] { # return indexs [ i ] < indexs [ j ] # } # return A [ indexs [ i ]] < A [ indexs [ j ]] # }) # # nextHigher := nextIndex ( indexs ) # # ascToDes ( A , indexs ) # # nextLower := nextIndex ( indexs ) # # higher , lower := make ([] int , size ), make ([] int , size ) # higher [ size - 1 ], lower [ size - 1 ] = 1 , 1 # for i := size - 2 ; i >= 0 ; i -- { # higher [ i ], lower [ i ] = lower [ nextHigher [ i ]], higher [ nextLower [ i ]] # } # return sum ( higher )
return & ast . BasicLit { # ValuePos : t . curPos , # Kind : t . curToken , # Value : t . curValue , # }, nil
max := - 1 # for i := len ( arr ) - 1 ; i >= 0 ; i -- { # t := arr [ i ] # arr [ i ] = max # if t > max { # max = t # } # } # return arr
tests := [...] testType { # { # in : [] int { 1 , 2 , 3 }, # want : [] int { 1 , 2 , 4 }, # }, # { # in : [] int { 4 , 3 , 2 , 1 }, # want : [] int { 4 , 3 , 2 , 2 }, # }, # { # in : [] int { 1 , 2 , 9 , 9 }, # want : [] int { 1 , 3 , 0 , 0 }, # }, # { # in : [] int { 9 , 9 }, # want : [] int { 1 , 0 , 0 }, # }, # } # # for _ , tt := range tests { # got := plusOne ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if n == nil { # return depth # } # return Max ( calculateDepth ( n . left , depth + 1 ), calculateDepth ( n . right , depth + 1 ))
numMap := make ( map [ int ] int , len ( nums )) # for _ , v := range nums { # numMap [ v ] = v # } # for index := 1 ; index < len ( nums )+ 1 ; index ++ { # if _ , ok := numMap [ index ]; ! ok { # return index # } # } # return len ( nums ) + 1
nums := [] int {- 2 , 0 , 3 , - 5 , 2 , - 1 } # # obj := Constructor ( nums ) # fmt . Println ( obj . data ) # fmt . Println ( obj . SumRange ( 0 , 2 ))
n := len ( needle ) # if n == 0 { # return 0 # } # for i := 0 ; i < len ( haystack )- n + 1 ; i ++ { # j := 0 # for j < n { # if haystack [ i + j ] != needle [ j ] { # break # } # j ++ # } # if j == n { # return i # } # } # return - 1
qs := [] question 2 6 { # # { # para 2 6 {[] int { 1 , 1 , 2 }}, # ans 2 6 { 2 }, # }, # # { # para 2 6 {[] int { 0 , 0 , 1 , 1 , 1 , 1 , 2 , 3 , 4 , 4 }}, # ans 2 6 { 5 }, # }, # # { # para 2 6 {[] int { 0 , 0 , 0 , 0 , 0 }}, # ans 2 6 { 1 }, # }, # # { # para 2 6 {[] int { 1 }}, # ans 2 6 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 6 , q . para 2 6 # fmt . Printf (" STR ", p . one , removeDuplicates ( p . one )) # } # fmt . Printf (" STR ")
res := make ([] string , 0 ) # if n == 0 { # res = append ( res , " STR ") # } else { # for i := 0 ; i < n ; i ++ { # for _ , left := range generateParenthesis ( i ) { # for _ , right := range generateParenthesis ( n - 1 - i ) { # res = append ( res , " STR "+ left +" STR "+ right ) # } # } # } # } # return res
qs := [] question 6 9 { # # { # para 6 9 { 4 }, # ans 6 9 { 2 }, # }, # # { # para 6 9 { 8 }, # ans 6 9 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 9 , q . para 6 9 # fmt . Printf (" STR ", p , mySqrt 1 ( p . one )) # } # fmt . Printf (" STR ")
var ipAddress [] string # if len ( s ) < 4 { # return ipAddress # } # for x := 1 ; x <= 3 && x <= len ( s )- 3 ; x ++ { # if ! checkIP ( s [: x ]) { # continue # } # for y := 1 ; y <= 3 && y <= len ( s )- x - 2 ; y ++ { # if ! checkIP ( s [ x : x + y ]) { # continue # } # for z := 1 ; z <= 3 && z <= len ( s )- x - y - 1 ; z ++ { # if ! checkIP ( s [ x + y : x + y + z ]) || ! checkIP ( s [ x + y + z :]) { # continue # } # ip := s [: x ] + " STR " + s [ x : x + y ] + " STR " + s [ x + y : x + y + z ] + " STR " + s [ x + y + z :] # ipAddress = append ( ipAddress , ip ) # } # } # } # # return ipAddress
largest := 0 # # for n := 0 ; n < 9 8 8 ; n ++ { # # prod := 1 # # numSlice := [] rune ( numAsString [ n : n + 1 3 ]) # # for i := 0 ; i < len ( numSlice ); i ++ { # integer , _ := strconv . Atoi ( string ( numSlice [ i ])) # # prod = prod * integer # # } # # if prod > largest { # largest = prod # } # # } # # fmt . Println ( largest ) #
if len ( prices ) < 1 { # return 0 # } # # ans := 0 # for i := 1 ; i < len ( prices ); i ++ { # if prices [ i ] > prices [ i - 1 ] { # ans += prices [ i ] - prices [ i - 1 ] # } # } # return ans
var boundsMap = map [ int ] bounds {} # var recordMap = map [ int ] bool {} # var maxLen = 0 # # for _ , num := range nums { # if recordMap [ num ] == true { # continue # } # # left := num - 1 # right := num + 1 # newBounds := bounds { # lowerBound : num , # upperBound : num , # } # # if _ , ok := boundsMap [ left ]; ok { # leftBounds := boundsMap [ left ] # if leftBounds . upperBound >= num { # continue # } # # if leftBounds . upperBound == left { # newBounds . lowerBound = leftBounds . lowerBound # delete ( boundsMap , left ) # } # } # # if _ , ok := boundsMap [ right ]; ok { # rightBounds := boundsMap [ right ] # if rightBounds . lowerBound <= num { # continue # } # # if rightBounds . lowerBound == right { # newBounds . upperBound = rightBounds . upperBound # delete ( boundsMap , right ) # } # } # # boundsMap [ newBounds . lowerBound ] = newBounds # boundsMap [ newBounds . upperBound ] = newBounds # currentLen := newBounds . upperBound - newBounds . lowerBound + 1 # if currentLen > maxLen { # maxLen = currentLen # } # recordMap [ num ] = true # } # return maxLen
for i := 0 ; i < len ( lists ); { # if lists [ i ] == nil { # lists = append ( lists [ 0 : i ], lists [ i + 1 :]...) # } else { # i ++ # } # } # if 0 == len ( lists ) { # return nil # } # # head := & ListNode {} # cur := head # for len ( lists ) > 0 { # for i := ( len ( lists ) - 1 ) / 2 ; i >= 0 ; i -- { # siftUp ( lists , len ( lists ), i ) # } # cur . Next = & ListNode { Val : lists [ 0 ]. Val } # cur = cur . Next # lists [ 0 ] = lists [ 0 ]. Next # if lists [ 0 ] == nil { # lists = lists [ 1 :] # } # } # return head . Next
return & Cache { # maxBytes : maxBytes , # ll : list . New (), # cache : make ( map [ string ]* list . Element ), # OnEvicted : onEvicted , # }
nodes := [] int { # 1 , 2 , 3 , 4 , 5 , 6 , # } # # edges := [][] bool { # { false , true , true , false , false , false }, # { true , false , false , true , false , false }, # { true , false , false , true , false , false }, # { false , true , true , false , true , false }, # { false , false , false , true , false , true }, # { false , false , false , false , true , false }, # } # # start := 1 # end := 7 # # actual , actualIsFound := DepthFirstSearch ( start , end , nodes , edges ) # var expected [] int # expectedIsFound := false # t . Run (" STR ", func ( t * testing . T ) { # if ! reflect . DeepEqual ( expected , actual ) || ! reflect . DeepEqual ( actualIsFound , expectedIsFound ) { # t . Errorf (" STR ", actual , expected ) # t . Errorf (" STR ", actualIsFound , expectedIsFound ) # } # })
qs := [] question 6 4 { # # { # para 6 4 {[][] int { # { 1 , 3 , 1 }, # { 1 , 5 , 1 }, # { 4 , 2 , 1 }, # }}, # ans 6 4 { 7 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 4 , q . para 6 4 # fmt . Printf (" STR ", p , minPathSum ( p . og )) # } # fmt . Printf (" STR ")
node := _bintree # if len ( name ) != 0 { # cannonicalName := strings . Replace ( name , " STR ", " STR ", - 1 ) # pathList := strings . Split ( cannonicalName , " STR ") # for _ , p := range pathList { # node = node . Children [ p ] # if node == nil { # return nil , fmt . Errorf (" STR ", name ) # } # } # } # if node . Func != nil { # return nil , fmt . Errorf (" STR ", name ) # } # rv := make ([] string , 0 , len ( node . Children )) # for childName := range node . Children { # rv = append ( rv , childName ) # } # return rv , nil
fmt . Printf (" STR ") # for _ , tc := range tcs { # fmt . Printf (" STR ", tc ) # } # fmt . Printf (" STR ")
cases := [] struct { # name string # inputs string # expect int # }{ # {" STR ", " STR ", 3 }, # {" STR ", " STR ", 4 }, # {" STR ", " STR ", 9 }, # {" STR ", " STR ", 5 8 }, # {" STR ", " STR ", 1 9 9 4 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := romanToInt 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
fmt . Println ( findNthDigit ( 3 )) # fmt . Println ( findNthDigit ( 1 1 )) # fmt . Println ( findNthDigit ( 3 1 ))
if len ( nums ) < 2 { # return 0 # } # # min , max := findMinAndMax ( nums ) # size := ( max - min ) / ( len ( nums ) - 1 ) # if size < 1 { # size = 1 # } # # buckets := make ([]* bucket , ( max - min )/ size + 1 ) # for _ , num := range nums { # i := ( num - min ) / size # if buckets [ i ] == nil { # buckets [ i ] = & bucket { min : num , max : num } # continue # } # if num < buckets [ i ]. min { # buckets [ i ]. min = num # } else if num > buckets [ i ]. max { # buckets [ i ]. max = num # } # } # # var gap int # prevMax := buckets [ 0 ]. max # for i := 1 ; i < len ( buckets ); i ++ { # if buckets [ i ] != nil { # if buckets [ i ]. min - prevMax > gap { # gap = buckets [ i ]. min - prevMax # } # prevMax = buckets [ i ]. max # } # } # return gap
j , k := 0 , 0 # fact := make ([] int , n ) # perm := make ([] int , n ) # fact [ k ] = 1 # k ++ # i -- # for k < n { # fact [ k ] = fact [ k - 1 ] * k # k ++ # } # for k = 0 ; k < n ; k ++ { # perm [ k ] = i / fact [ n - 1 - k ] # i = i % fact [ n - 1 - k ] # } # for k = n - 1 ; k > 0 ; k -- { # for j = k - 1 ; j >= 0 ; j -- { # if perm [ j ] <= perm [ k ] { # perm [ k ]++ # } # } # } # result := 0 # for k = 0 ; k < n ; k ++ { # result = ( result + perm [ k ]) * 1 0 # } # return result / 1 0
tests := [...] testType { # { # nums : [] int { 1 , 3 , 1 , 5 , 4 }, # k : 0 , # want : 1 , # }, # { # nums : [] int { 3 , 1 , 4 , 1 , 5 }, # k : 2 , # want : 2 , # }, # { # nums : [] int { 1 , 2 , 3 , 4 , 5 }, # k : 1 , # want : 4 , # }, # { # nums : [] int { 1 , 2 , 3 , 4 , 5 }, # k : - 1 , # want : 0 , # }, # } # for _ , tt := range tests { # got := findPairs ( tt . nums , tt . k ) # if got != tt . want { # t . Fatalf (" STR ", tt . nums , tt . k , got , tt . want ) # } # }
return big . NewInt ( 0 ). Mul ( a , b )
if len ( nums ) <= 1 { # return len ( nums ) - 1 # } # sum := 0 # for i := 0 ; i < len ( nums ); i ++ { # sum += nums [ i ] # } # if sum == nums [ 0 ] { # return 0 # } # before := 0 # for i := 1 ; i < len ( nums ); i ++ { # before += nums [ i - 1 ] # if sum - nums [ i ]- before == before { # return i # } # } # return - 1
index := 0 # for i := 0 ; i < len ( s ); i ++ { # flag := false # for ; index < len ( t ); index ++ { # if s [ i ] == t [ index ] { # flag = true # break # } # } # if flag == true { # index ++ # continue # } else { # return false # } # } # return true
if m == 0 || n == 0 { # return 0 # } # # dp := make ([] int , n ) # for i := range dp { # dp [ i ] = 1 # } # # for i := 1 ; i < m ; i ++ { # for j := 1 ; j < n ; j ++ { # dp [ j ] += dp [ j - 1 ] # } # } # # return dp [ n - 1 ]
return syscall . Getpagesize ()
return fmt . Sprintf (" STR ", string ( pe ))
n := len ( s ) # if n == 0 { # return true # } # for i , j := 0 , 0 ; j < len ( t ); j ++ { # if s [ i ] == t [ j ] { # i ++ # if i == n { # return true # } # } # } # return false
sum , al := 0 , ( e / 3 )+ 1 # n := make ([] int , al ) # n [ al - 2 ], n [ al - 1 ] = 2 , 0 # # for a := 1 ; a < e ; a ++ { # for i := 0 ; i < al - 1 ; i ++ { # if n [ i + 1 ] > 4 { # n [ i ] = (( 2 * n [ i ]) % 1 0 ) + 1 # } else { # n [ i ] = ( 2 * n [ i ]) % 1 0 # } # } # } # for b := 0 ; b < al - 1 ; b ++ { # sum = sum + n [ b ] # } # return sum
n := len ( s ) # f := make ([] int , n + 1 ) # f [ 0 ] = 1 # for i := 1 ; i <= n ; i ++ { # if s [ i - 1 ] != " STR " { # f [ i ] += f [ i - 1 ] # } # if i >= 2 { # t := ( s [ i - 2 ]-" STR ")* 1 0 + s [ i - 1 ] - " STR " # if t >= 1 0 && t <= 2 6 { # f [ i ] += f [ i - 2 ] # } # } # } # return f [ n ]
size := len ( a ) # # sums := make ([] int , size + 1 ) # s := 0 # for i , n := range a { # if n == K { # return 1 # } # s += n # sums [ i + 1 ] = s # } # # initialValue := size * 2 # res := initialValue # # deque := make ([] int , size + 1 ) # deque [ 0 ] = 0 # first , last := 0 , 0 # # for i := 1 ; i <= size ; i ++ { # for first <= last && sums [ i ]- sums [ deque [ first ]] >= K { # res = min ( res , i - deque [ first ]) # first ++ # } # for first <= last && sums [ i ] <= sums [ deque [ last ]] { # last -- # } # last ++ # deque [ last ] = i # } # # if res == initialValue { # return - 1 # } # return res
res := 1 # for i := range s { # res *= prime [ s [ i ]-" STR "] # } # return res
fmt . Println (" STR ") # tick := time . Tick ( 1 * time . Second ) # for countdown := 1 0 ; countdown > 0 ; countdown -- { # fmt . Println ( countdown ) # <- tick # } # launch ()
qs := [] question 3 9 4 { # # { # para 3 9 4 {" STR "}, # ans 3 9 4 {" STR "}, # }, # # { # para 3 9 4 {" STR "}, # ans 3 9 4 {" STR "}, # }, # # { # para 3 9 4 {" STR "}, # ans 3 9 4 {" STR "}, # }, # # { # para 3 9 4 {" STR "}, # ans 3 9 4 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 9 4 , q . para 3 9 4 # fmt . Printf (" STR ", p , decodeString ( p . s )) # } # fmt . Printf (" STR ")
qs := [] question 6 0 { # # { # para 6 0 { 3 , 3 }, # ans 6 0 {" STR "}, # }, # # { # para 6 0 { 4 , 9 }, # ans 6 0 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 0 , q . para 6 0 # fmt . Printf (" STR ", p , getPermutation ( p . n , p . k )) # } # fmt . Printf (" STR ")
pairs := [...][ 2 ] uint {{ 1 0 , 2 5 2 0 }, { 2 0 , 2 3 2 7 9 2 5 6 0 }} # for _ , pair := range pairs { # in , out := pair [ 0 ], pair [ 1 ] # if x := p 5 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # } # }
left , right := 0 , 0 # for _ , v := range nums { # right += v # } # for i , v := range nums { # if right -= v ; left == right { # return i # } # left += v # } # return - 1
n := 0 # for node := root ; node != nil ; node = node . Next { # n ++ # } # l , r := n / k , n % k # res := make ([]* ListNode , k ) # var prev * ListNode # node := root # for i := 0 ; node != nil && i < k ; i , r = i + 1 , r - 1 { # res [ i ] = node # ll := l # if r > 0 { # ll ++ # } # for j := 0 ; j < ll ; j ++ { # prev = node # node = node . Next # } # prev . Next = nil # } # return res
defer n . Done () # for _ , entry := range dirents ( dir ) { # if entry . IsDir () { # n . Add ( 1 ) # subdir := filepath . Join ( dir , entry . Name ()) # go walkDir ( subdir , n , fileSizes ) # } else { # fileSizes <- entry . Size () # } # }
m , n := len ( mat ), len ( mat [ 0 ]) # # for i := 0 ; i + 1 < m ; i ++ { # for j := 0 ; j + 1 < n ; j ++ { # if mat [ i ][ j ] != mat [ i + 1 ][ j + 1 ] { # return false # } # } # } # # return true
sum := 0 # for i := 3 ; i < 9 9 9 9 9 ; i ++ { # if isSumOfFactorials ( i ) { # sum += i # fmt . Println (" STR ", sum ) # } # } # fmt . Println ( sum )
tbl := [] brfmt { # {" STR ", [] Bytes {{ 2 , 1 , 0 , false }}, ""}, # {" STR ", [] Bytes {{- 1 , 1 , 0 , false }}, ""}, # {" STR ", [] Bytes {{- 1 1 , - 1 0 , 0 , false }}, ""}, # {" STR ", [] Bytes {}, ""}, # } # for _ , f := range tbl { # f := f # t . Run ( f . Name , func ( t * testing . T ) { # t . Parallel () # t . Log ( f . In ) # got , err := FormatRequest ( f . In ...) # if err == nil { # t . Errorf (" STR ", got ) # } # }) # }
if 1 == num { # return false # } # # sum := 1 # for i := 2 ; i <= int ( math . Sqrt ( float 6 4 ( num ))); i ++ { # if 0 == num % i { # sum += i + num / i # } # } # # return sum == num
input := " STR " # for i := 0 ; i < 9 9 9 ; i ++ { # input = multipyByTwo ( input ) # } # println ( sumUpDigits ( input ))
http . HandleFunc (" STR ", handler ) # http . ListenAndServe (" STR ", nil )
var scale float 6 4 = 1 # var sum float 6 4 # var px [ 3 ] float 6 4 # # if z < 0 . 0 0 0 0 { # return p . Noise 2 D ( x , y ) # } # px [ 0 ] = x # px [ 1 ] = y # px [ 2 ] = z # # for i := 0 ; i < p . n ; i ++ { # val := p . noise 3 ( px ) # sum += val / scale # scale *= p . alpha # px [ 0 ] *= p . beta # px [ 1 ] *= p . beta # px [ 2 ] *= p . beta # } # return sum
n := items [ len ( items )- 1 ] # nn := 0 # # if n == 1 { # return items # } else { # if n % 2 == 0 { # nn = n / 2 # } else { # nn = 3 * n + 1 # } # items = append ( items , nn ) # items = Chain ( items ) # } # return items
n := len ( citations ) # buckets := make ([] int , n + 1 ) # for _ , c := range citations { # if c >= n { # buckets [ n ]++ # } else { # buckets [ c ]++ # } # } # count := 0 # for i := n ; i >= 0 ; i -- { # count += buckets [ i ] # if count >= i { # return i # } # } # return 0
qs := [] question 7 9 3 { # # { # para 7 9 3 { 0 }, # ans 7 9 3 { 5 }, # }, # # { # para 7 9 3 { 5 }, # ans 7 9 3 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 9 3 , q . para 7 9 3 # fmt . Printf (" STR ", p , preimageSizeFZF ( p . one )) # } # fmt . Printf (" STR ")
test 1 := [] string {" STR "} # fmt . Println ( subdomainVisits ( test 1 )) # # test 2 := [] string {" STR ", " STR ", " STR ", " STR "} # fmt . Println ( subdomainVisits ( test 2 ))
sema <- struct {}{} # balance = balance + amount # <- sema
t . Parallel () # # for _ , tc := range testcases { # if result := PerfectNth ( tc . n ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
d := newDisc () # c := newTestCacheModel ( 4 , d ) # for i := 0 ; i < 8 ; i ++ { # c . write ( uint 3 2 ( i ), string ( i )) # } # for i := 0 ; i < 8 ; i ++ { # data , _ := c . read ( uint 3 2 ( i )) # if string ( i ) != data { # t . Log ( i , data ) # t . Fail () # } # } # expOrder := [] int { 7 , 6 , 5 , 4 } # for item , i := c . pq . Front (), 0 ; item != nil ; item = item . Next () { # if item . Value .(* cacheItem ). key != expOrder [ i ] { # t . Log ( i , fmt . Sprintf (" STR ", item . Value )) # t . Fail () # } # i ++ # }
_ , exist = g . edges [ vertex ] # # return
list := & List {} # list . len = 0 # return list
var profit int # pl := len ( prices ) # # for i := 1 ; i < pl ; i ++ { # p := prices [ i ] - prices [ i - 1 ] # if p > 0 { # profit += p # } # } # return profit
arr := [] byte ( z . String ()) # result := 0 # for _ , v := range arr { # char := string ( v ) # number , _ := strconv . Atoi ( char ) # result += number # } # # return result
if root != nil { # println ( root . Val ) # preorder ( root . Left ) # preorder ( root . Right ) # }
r := 0 # pre := ' x ' # for i := start ; i < end ; i ++ { # c := chars [ i ] # if i > start { # pre = chars [ i - 1 ] # } # switch c { # case '(': # depth := 1 # start = i + 1 # for i = start ; i < end && 0 != depth ; i ++ { # switch chars [ i ] { # case '(': # depth ++ # case ')': # depth -- # } # } # switch pre { # case ' x ', '+': # r += calc ( chars , start , i ) # case '-': # r -= calc ( chars , start , i ) # } # case '+', '-': # default : # v := 0 # for ; i < end && chars [ i ] >= ' 0 ' && chars [ i ] <= ' 9 '; i ++ { # v = v * 1 0 + int ( chars [ i ]-' 0 ') # } # switch pre { # case ' x ', '+': # r += v # case '-': # r -= v # } # } # } # return r
return ( k 1 .( uint 3 2 ) & (( 1 << uint 3 2 ( lgu )) - 1 )) < ( k 2 .( uint 3 2 ) & (( 1 << uint 3 2 ( lgu )) - 1 ))
in := make ([] int , numCourses ) # frees := make ([][] int , numCourses ) # next := make ([] int , 0 , numCourses ) # for _ , v := range prerequisites { # in [ v [ 0 ]]++ # frees [ v [ 1 ]] = append ( frees [ v [ 1 ]], v [ 0 ]) # } # for i := 0 ; i < numCourses ; i ++ { # if in [ i ] == 0 { # next = append ( next , i ) # } # } # for i := 0 ; i != len ( next ); i ++ { # c := next [ i ] # v := frees [ c ] # for _ , vv := range v { # in [ vv ]-- # if in [ vv ] == 0 { # next = append ( next , vv ) # } # } # } # if len ( next ) == numCourses { # return next # } # return [] int {}
var b [] byte # for i := 3 2 ; i > 0 ; i -= 4 { # hex := num >> uint ( i - 4 ) & 0 xF # if b == nil && hex > 0 { # b = make ([] byte , 0 , i / 4 ) # } # if b != nil { # b = append ( b , toByte ( hex )) # } # } # if b == nil { # return " STR " # } # return string ( b )
qs := [] question 4 2 { # # { # para 4 2 {[] int { 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 }}, # ans 4 2 { 6 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 2 , q . para 4 2 # fmt . Printf (" STR ", p , trap ( p . one )) # } # fmt . Printf (" STR ")
t . Parallel () # # for _ , tc := range testcases { # if result := FindTwoSumKInBST ( tc . head , tc . k ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
pairs := [...][ 2 ] int 6 4 {{ 1 3 1 9 5 , 2 9 }, { 6 0 0 8 5 1 4 7 5 1 4 3 , 6 8 5 7 }} # for _ , pair := range pairs { # in , out := pair [ 0 ], int ( pair [ 1 ]) # if x := p 3 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # } # }
processes := [] string {" STR ", " STR ", " STR ", " STR "} # for _ , p := range processes { # Sum ( p ) # } # # wg . Wait () # fmt . Println (" STR ", sum )
if root == nil { # return root # } # if root . Val > R { # return trimBST ( root . Left , L , R ) # } # if root . Val < L { # return trimBST ( root . Right , L , R ) # } # root . Left = trimBST ( root . Left , L , R ) # root . Right = trimBST ( root . Right , L , R ) # return root
dp := make ([] int , n + 1 ) # dp [ 0 ], dp [ 1 ] = 1 , 1 # for i := 1 ; i <= n ; i ++ { # for j := 1 ; j < i ; j ++ { # dp [ i ] = max ( dp [ i ], j * max ( dp [ i - j ], i - j )) # } # } # return dp [ n ]
expected := [] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 1 , 1 2 , 1 5 , 2 2 } # if res := selfDividingNumbers ( 1 , 2 2 ); ! reflect . DeepEqual ( res , expected ) { # t . Errorf (" STR ", expected , res ) # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 3 , 3 , 5 , 0 , 0 , 3 , 1 , 4 }, 6 }, # {" STR ", [] int { 1 , 2 , 3 , 4 , 5 }, 4 }, # {" STR ", [] int { 7 , 6 , 4 , 3 , 1 }, 0 }, # } # # for i , c := range cases { # t . Run ( c . name + strconv . Itoa ( i ), func ( t * testing . T ) { # got := maxProfit 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
nextOdd := makeOddGenerator () # fmt . Println ( nextOdd ()) # fmt . Println ( nextOdd ()) # fmt . Println ( nextOdd ())
var row [] int # var ret [][] int # for i := 1 ; i <= numRows ; i ++ { # for j := i - 1 ; j >= 2 ; j -- { # row [ j - 1 ] += row [ j - 2 ] # } # row = append ( row , 1 ) # val := make ([] int , len ( row )) # copy ( val , row ) # ret = append ( ret , val ) # } # return ret
var si , ti int # # for si < len ( s ) && ti < len ( t ) { # if s [ si ] == t [ ti ] { # si ++ # ti ++ # } else { # ti ++ # } # } # return si == len ( s )
v |= v >> 1 # v |= v >> 2 # v |= v >> 4 # v |= v >> 8 # v |= v >> 1 6 # return multiplyDeBruijnBitPosition [ uint 3 2 ( v * 0 x 0 7 C 4 ACDD )>> 2 7 ]
defer fmt . Println (" STR ") # defer func () { # fmt . Println (" STR ") # if e := recover (); e != nil { # fmt . Println (" STR ", e ) # } # }() # panic (" STR ") # fmt . Println (" STR ")
if x == len ( matrix ) - 1 && y == len ( matrix [ x ]) - 1 { # return matrix [ x ][ y ] # } # if mem [ x ][ y ] != 0 { # return mem [ x ][ y ] # } # down , right , here := 0 , 0 , matrix [ x ][ y ] # if x < len ( matrix ) - 1 { # right = MinimalPathSumHelper ( matrix , mem , x + 1 , y ) # } # if y < len ( matrix [ x ]) - 1 { # down = MinimalPathSumHelper ( matrix , mem , x , y + 1 ) # } # sum := here # if right != 0 && down > right || down == 0 { # sum += right # } else { # sum += down # } # mem [ x ][ y ] = sum # return sum
if n == 0 { # return 1 # } # if n > 1 0 { # n = 1 0 # } # dp := make ([] int , n ) # dp [ 0 ] = 1 0 # num , accum := 9 , 9 # for i := 1 ; i < n ; i ++ { # accum *= num # num -- # dp [ i ] += accum + dp [ i - 1 ] # } # return dp [ n - 1 ]
l , r := 0 , len ( a )- 1 # # for l <= r { # m := ( l + r ) / 2 # switch { # case a [ m ] < target : # l = m + 1 # case target < a [ m ]: # r = m - 1 # default : # return m # } # } # # return - 1
defer wg . Done () # # for count := 0 ; count < 2 ; count ++ { # atomic . AddInt 6 4 (& counter , 1 ) # # runtime . Gosched () # }
sum := 0 # for i := 2 ; i <= 9 9 9 9 9 9 ; i ++ { # if i == fifthPowerSum ( i ) { # sum += i # } # } # fmt . Println (" STR ", sum )
type A struct { # Name string # D string # } # a := A { Name : " STR "} # # type B struct { # A A # C int # } # b := & B { A : a , C : 1 2 3 } # # ok := IsZero ( b ) # if ok { # t . Error (" STR ") # } # # aZero := A {} # bZero := & B { A : aZero } # # ok = IsZero ( bZero ) # if ! ok { # t . Error (" STR ") # } #
if e . min == nil { # return nil , nil # } # return e . min . key , e . min . value
var ret [] string # if len ( nums ) == 0 { # return ret # } # if len ( nums ) == 1 { # return [] string { strconv . Itoa ( nums [ 0 ])} # } # var i int # var j int = 1 # for ; j < len ( nums ); j ++ { # if nums [ j ] == nums [ j - 1 ]+ 1 { # continue # } # if nums [ j ] != nums [ j - 1 ]+ 1 { # if j - 1 == i { # ret = append ( ret , strconv . Itoa ( nums [ i ])) # } else { # ret = append ( ret , strconv . Itoa ( nums [ i ])+" STR "+ strconv . Itoa ( nums [ j - 1 ])) # } # i = j # } # } # if j - 1 == i { # ret = append ( ret , strconv . Itoa ( nums [ i ])) # } else { # ret = append ( ret , strconv . Itoa ( nums [ i ])+" STR "+ strconv . Itoa ( nums [ j - 1 ])) # } # return ret
expMap := map [ string ] int { # " STR ": 1 , # " STR ": 2 , # " STR ": 9 9 9 , # " STR ": 1 6 , # " STR ": 9 0 , # " STR ": 9 0 , # " STR ": 1 , # " STR ": 2 , # " STR ": 9 9 9 , # " STR ": 1 6 , # " STR ": 9 0 , # " STR ": 9 0 , # } # for i , v := range expMap { # hmap .( hashMap ). HashInsert ( i , v ) # }
if x <= 1 { # return x # } # # low := 1 # high := x # for low < high { # mid := ( low + high ) / 2 # sq := mid * mid # if sq > x { # high = mid # } else if sq < x { # low = mid + 1 # } else { # return mid # } # } # # return high - 1
max := 9 # # max , power := 9 , 1 # for sumOfDigitFactorials ( max ) > max { # max += 9 * int ( math . Pow 1 0 ( power )) # power ++ # } # # sum := 0 # for i := 3 ; i < max ; i ++ { # if sumOfDigitFactorials ( i ) == i { # sum += i # } # } # fmt . Println ( sum )
if nil == root { # return - 1 # } # # return findCore ( root , root . Val )
i = h . root . Value # h . root = h . merge ( h . root . left , h . root . right ).(* ltHeapElement ) # h . len -- # return
if root == nil { # return 0 # } # # _ , _ , result := helper 1 2 4 ( root ) # return result
var max * TreeNode # for root != nil { # if root . Left == nil { # if root == p { # root = root . Right # if root == nil { # return nil # } # for root . Left != nil { # root = root . Left # } # return root # } # root = root . Right # } else { # max = root . Left # for max . Right != nil { # max = max . Right # } # # max . Right = root # root , root . Left = root . Left , nil # # } # } # return nil
qs := [] question 7 2 6 { # # { # para 7 2 6 {" STR "}, # ans 7 2 6 {" STR "}, # }, # # { # para 7 2 6 {" STR "}, # ans 7 2 6 {" STR "}, # }, # # { # para 7 2 6 {" STR "}, # ans 7 2 6 {" STR "}, # }, # # { # para 7 2 6 {" STR "}, # ans 7 2 6 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 2 6 , q . para 7 2 6 # fmt . Printf (" STR ", p , countOfAtoms ( p . one )) # } # fmt . Printf (" STR ")
mod := 1 0 0 0 0 0 0 0 0 7 # sort . Ints ( A ) # # n , p := len ( A ), 1 # res := 0 # for i , a := range A { # res = ( res + ( a - A [ n - i - 1 ])* p ) % mod # p = p * 2 % mod # } # return res
defer TimeTaken ( time . Now (), " STR ") # # fibo := [] int { 1 , 2 } # value := 0 # # for latest := fibo [ len ( fibo )- 1 ]; latest < 3 9 9 9 9 9 9 ; latest = fibo [ len ( fibo )- 1 ]{ # fibo = append ( fibo , ( fibo )[ len ( fibo )- 1 ] + ( fibo )[ len ( fibo )- 2 ]) # if latest % 2 == 0 { # value = value + latest # } # } # fmt . Println ( value )
counts := [] int { 0 , 0 , 0 , 0 , 0 , 0 , 2 0 0 } # # length := len ( values ) # pennies := length - 1 # tot := 2 # # # # for x := 0 ; counts [ 0 ] < 2 ; x ++ { # if counts [ pennies ] < 2 { # for i := pennies - 1 ; i > 0 ; i -- { # if counts [ i ] > 0 && ( counts [ i - 1 ]* values [ i - 1 ]) < 2 0 0 { # counts [ i - 1 ]++ # counts [ pennies ] += ( values [ i ] * counts [ i ]) - ( values [ i - 1 ]) # counts [ i ] = 0 # if counts [ pennies ] >= 0 { # tot += 1 # } # break # } # } # } # for i := pennies - 1 ; i >= 0 ; i -- { # if values [ i ] <= counts [ pennies ] { # counts [ i ] += 1 # counts [ pennies ] -= values [ i ] # tot += 1 # break # } # } # } # # fmt . Println ( tot ) #
h . UpScale () # for i := 0 ; i < int ( h . Cap ); i ++ { # hashValue := h . hash ( key , uint 3 2 ( i )) # if h . backets [ hashValue ] == nil { # h . backets [ hashValue ] = & openHashElement { exist : false } # } # exist := h . existKey ( hashValue ) # if exist && h . backets [ hashValue ]. Key == key { # h . backets [ hashValue ]. Value = value # return # } else if ! exist { # h . backets [ hashValue ]. Key = key # h . backets [ hashValue ]. Value = value # h . backets [ hashValue ]. exist = true # h . Count ++ # return # } # }
ints := make ([] int , len ( num 1 )+ len ( num 2 )) # for i := 0 ; i < len ( num 1 ); i ++ { # for j := 0 ; j < len ( num 2 ); j ++ { # ints [ i + j + 1 ] += int ( num 1 [ i ]-' 0 ') * int ( num 2 [ j ]-' 0 ') # } # } # # for i := len ( ints ) - 1 ; i > 0 ; i -- { # ints [ i - 1 ] += ints [ i ] / 1 0 # ints [ i ] %= 1 0 # } # return intsToString ( ints )
es := strings . Split ( equation , " STR ") # la , lb := evaluate ( es [ 0 ]) # ra , rb := evaluate ( es [ 1 ]) # a , b := la - ra , rb - lb # # if a == 0 { # if b == 0 { # return " STR " # } # return " STR " # } # return " STR " + strconv . Itoa ( b / a )
l := 0 # for _ , v := range nums { # if v != val { # nums [ l ] = v # l ++ # } # } # # return l
log . Println (" STR ") # # log . Fatalln (" STR ") # # log . Panicln (" STR ")
if n != nil { # InOrder ( n . left ) # fmt . Print ( n . val , " STR ") # InOrder ( n . right ) # }
input , expected := [] int { 7 , 8 , 1 0 }, 2 5 # result := Sum ( input ...) # if result != expected { # # t . Errorf (" STR ", result , expected ) # } #
fmt . Println (" STR " + content + " STR ")
A := new ( Matrix ) # A . rows = rows # A . cols = cols # A . step = cols # A . Elements = Elements # # return A
n := len ( s ) # if n <= 1 { # return n # } # # dp := make ([][] int , n ) # for i := range dp { # dp [ i ] = make ([] int , n ) # dp [ i ][ i ] = 1 # } # # for Len := 2 ; Len <= n ; Len ++ { # for i := 0 ; i + Len - 1 < n ; i ++ { # j := i + Len - 1 # dp [ i ][ j ] = dp [ i ][ j - 1 ] + 1 # if s [ j - 1 ] == s [ j ] { # dp [ i ][ j ]-- # } # for k := i + 1 ; k <= j ; k ++ { # if s [ k - 1 ] == s [ j ] { # dp [ i ][ j ] = min ( dp [ i ][ j ], dp [ i ][ k - 1 ]+ dp [ k ][ j ]- 1 ) # } # } # } # } # # return dp [ 0 ][ n - 1 ]
testData := [] args { # { # g : [] int { 1 , 2 , 3 }, # s : [] int { 1 , 1 }, # }, # { # g : [] int { 1 , 2 }, # s : [] int { 1 , 2 , 3 }, # }, # } # expectedData := [] int { 1 , 2 } # # for index , data := range testData { # if res := findContentChildren ( data . g , data . s ); res != expectedData [ index ] { # t . Errorf (" STR ", expectedData [ index ], res ) # } # }
var tests = [] struct { # A [] int # K int # D int # }{ # {[] int { 1 }, 0 , 0 }, # {[] int { 0 , 1 0 }, 2 , 6 }, # {[] int { 1 0 , 0 }, 2 , 6 }, # {[] int { 1 , 3 , 6 }, 3 , 0 }, # } # # for _ , tt := range tests { # D := smallestRangeI ( tt . A , tt . K ) # if D != tt . D { # t . Errorf (" STR ", tt . A , tt . K , D , tt . D ) # } # }
if nil == root { # return false # } # # dict := make ( map [ int ] bool , 0 ) # return dfs ( root , k , dict )
size := len ( n ) # # candidates := getBitChangeCandidates ( size ) # candidates = append ( candidates , getCanidates ( n )...) # # num , _ := strconv . Atoi ( n ) # delta := func ( x int ) int { # if x > num { # return x - num # } # return num - x # } # # res := 1 << 6 3 - 1 # for _ , cand := range candidates { # if cand == num { # continue # } # # if delta ( cand ) < delta ( res ) || # ( delta ( cand ) == delta ( res ) && cand < res ) { # res = cand # } # } # # return strconv . Itoa ( res )
r := this . Raw [ this . idx ]. GetInteger () # this . idx ++ # return r
self . stack . Push ( frame )
if nil == t { # return " STR " # } # # ans := strconv . Itoa ( t . Val ) # strLeft := tree 2 str ( t . Left ) # strRight := tree 2 str ( t . Right ) # # if " STR " == strLeft && " STR " == strRight { # return ans # } # if " STR " == strLeft { # return ans + " STR " + " STR " + strRight + " STR " # } # if " STR " == strRight { # return ans + " STR " + strLeft + " STR " # } # return ans + " STR " + strLeft + " STR " + " STR " + strRight + " STR "
if k == 0 || head == nil || head . Next == nil { # return head # } # l := 1 # tmp := head # for tmp . Next != nil { # l ++ # tmp = tmp . Next # } # if k >= l { # k %= l # } # if k == 0 { # return head # } # tmp . Next = head # k = l - k # for k --; k != 0 ; k -- { # head = head . Next # } # tmp = head . Next # head . Next = nil # return tmp
ans := 0 # # for i := 0 ; i < len ( s ); i ++ { # for j := i + 1 ; j <= len ( s ); j ++ { # if allUnique ( s , i , j ) { # ans = Max ( ans , j - i ) # } # } # } # return ans
reversed := make ( AdjacencyMatrix , len ( g )) # for a := range g { # for b := range g [ a ] { # if _ , found := reversed [ b ]; ! found { # reversed [ b ] = make ( map [ rune ] struct {}) # } # reversed [ b ][ a ] = struct {}{} # } # } # return reversed
ans := 0 # for i := 2 ; i <= n ; i ++ { # ans = ( m + ans ) % i # } # return ans
if power < 0 && math . Floor ( float 6 4 ( power )) == float 6 4 ( power ) { # return uint 3 2 ( math . NaN ()), errors . New (" STR ") # } # # if power == 0 { # return 1 , nil # } # # var factor uint 3 2 # var result uint 3 2 # # mul := func ( v uint 3 2 ) { # if result == 0 { # result = v # } else { # result *= v # } # } # # for factor = n ; power > 0 ; power , factor = power >> 1 , factor * factor { # if power & 1 == 1 { # mul ( factor ) # } # } # # return result , nil
m := make ( map [ int ] bool ) # for _ , v := range A { # if m [ v ] { # return v # } # m [ v ] = true # } # return 0
const iterations = 2 0 0 # const contrast = 1 5 # # var v complex 1 2 8 # for n := uint 8 ( 0 ); n < iterations ; n ++ { # v = v * v + z # if cmplx . Abs ( v ) > 2 { # return color . Gray { 2 5 5 - contrast * n } # } # } # return color . Black
cases := [] struct { # name string # inputs [][] int # expect bool # }{ # {" STR ", [][] int {{ 1 , 2 }, { 2 , 3 }, { 3 , 4 }, { 4 , 5 }, { 5 , 6 }, { 6 , 7 }}, true }, # {" STR ", [][] int {{ 1 , 1 }, { 2 , 2 }, { 3 , 4 }, { 4 , 5 }, { 5 , 6 }, { 7 , 7 }}, false }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
qs := [] question 2 9 0 { # # { # para 2 9 0 {" STR ", " STR "}, # ans 2 9 0 { true }, # }, # # { # para 2 9 0 {" STR ", " STR "}, # ans 2 9 0 { false }, # }, # # { # para 2 9 0 {" STR ", " STR "}, # ans 2 9 0 { false }, # }, # # { # para 2 9 0 {" STR ", " STR "}, # ans 2 9 0 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 9 0 , q . para 2 9 0 # fmt . Printf (" STR ", p , wordPattern ( p . one , p . two )) # } # fmt . Printf (" STR ")
h . tasks = tasks # h . Interface = self # for i := range h . tasks { # heap . Fix ( h , h . Len ()- 1 - i ) # } # return h
carry := 0 # tmp 1 , tmp 2 := l 1 , l 2 # head := new ( ListNode ) # var walk * ListNode # first := true # for tmp 1 != nil && tmp 2 != nil { # walk , carry = step ( walk , head , first , tmp 1 . Val + tmp 2 . Val + carry ) # first = false # tmp 1 , tmp 2 = tmp 1 . Next , tmp 2 . Next # } # var remain * ListNode # if tmp 1 != nil { # remain = tmp 1 # } else { # remain = tmp 2 # } # for remain != nil { # walk , carry = step ( walk , head , first , remain . Val + carry ) # first = false # remain = remain . Next # } # if carry != 0 { # walk . Next = & ListNode { Val : carry } # } # return head
for i := 0 ; i < len ( A ); i ++ { # for a , b := 0 , len ( A [ i ])- 1 ; a < b ; a , b = a + 1 , b - 1 { # A [ i ][ a ], A [ i ][ b ] = A [ i ][ b ], A [ i ][ a ] # } # for a := 0 ; a < len ( A [ i ]); a ++ { # A [ i ][ a ] = ( A [ i ][ a ] + 1 ) % 2 # } # } # return A
ps := make ([] int , 1 , 1 0 0 0 0 ) # ds := make ([] int , 1 , 1 0 0 0 0 ) # ps [ 0 ] = 1 << 6 3 - 1 # ds [ 0 ] = - 1 # return StockSpanner { # prices : ps , # days : ds , # }
ans , i , j , l := 0 , 0 , 0 , len ( A )- 1 # for i < l - 1 { # j = i + 1 # for j < l && A [ j + 1 ]- A [ j ] == A [ j ]- A [ j - 1 ] { # j ++ # } # i , j = j , j - i # ans += j * ( j - 1 ) / 2 # } # return ans
avg , sum := 0 , 0 # for _ , v := range A { # sum += v # } # if sum % 3 != 0 { # return false # } # avg , sum , count := sum / 3 , 0 , 0 # for _ , v := range A { # sum += v # if sum == avg { # count , sum = count + 1 , 0 # } # } # return count == 3
var ( # l int # r = x # ) # # for l <= r { # mid := l + ( r - l )>> 1 # if mid * mid == x { # return mid # } # # if mid * mid < x { # if ( mid + 1 )*( mid + 1 ) > x { # return mid # } # l = mid + 1 # } else { # r = mid - 1 # } # } # return x
w . Header (). Set ( # " STR ", # " STR ", # ) # html := # `< doctype html > # < html > # < head > # < title > Hello Gopher </ title > # </ head > # < body > # < b > Hello Gopher !</ b > # < p > # < a href =" STR "> Welcome </ a > | < a href =" STR "> Message </ a > # </ p > # </ body > # </ html >` # fmt . Fprintf ( w , html ) #
flowerbed := [] int { 1 , 0 , 0 , 0 , 1 } # # fmt . Println ( canPlaceFlowers ( flowerbed , 1 )) # fmt . Println ( canPlaceFlowers ( flowerbed , 2 ))
n := len ( s ) # if n == 0 { # return 0 # } # # dp := make ([] int , n + 1 ) # dp [ 0 ], dp [ 1 ] = 1 , one ( s [ 0 : 1 ]) # # for i := 2 ; i <= n ; i ++ { # w 1 , w 2 := one ( s [ i - 1 : i ]), two ( s [ i - 2 : i ]) # dp [ i ] = dp [ i - 1 ]* w 1 + dp [ i - 2 ]* w 2 # if dp [ i ] == 0 { # return 0 # } # dp [ i ] %= MOD # } # # return dp [ n ]
sum := 0 # for _ , p := range piles { # sum += p # } # l := ( sum + H - 1 ) / H # r := l * 2 # for l < r { # m := ( l + r ) / 2 # h := H # for _ , p := range piles { # h -= ( p + m - 1 ) / m # if h < 0 { # break # } # } # if h < 0 { # l = m + 1 # } else { # r = m # } # } # return l
str := [] rune ( strconv . Itoa ( N )) # m := len ( str ) # for i := len ( str ) - 1 ; i > 0 ; i -- { # if str [ i ] < str [ i - 1 ] { # m = i # str [ i - 1 ] = rune ( str [ i - 1 ] - 1 ) # } # } # for i := m ; i < len ( str ); i ++ { # str [ i ] = ' 9 ' # } # ret , _ := strconv . Atoi ( string ( str )) # return ret
qs := [] question 2 3 9 { # # { # para 2 3 9 {[] int { 1 , 3 , - 1 , - 3 , 5 , 3 , 6 , 7 }, 3 }, # ans 2 3 9 {[] int { 3 , 3 , 5 , 5 , 6 , 7 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 3 9 , q . para 2 3 9 # fmt . Printf (" STR ", p , maxSlidingWindow ( p . one , p . k )) # } # fmt . Printf (" STR ")
if nums == nil { # return nil # } # if len ( nums ) == 1 { # return [][] int {{ nums [ 0 ]}} # } # var ret [][] int # for i , n := range nums { # sub := make ([] int , len ( nums )- 1 ) # copy ( sub , nums [: i ]) # copy ( sub [ i :], nums [ i + 1 :]) # for _ , r := range permute ( sub ) { # ret = append ( ret , append ([] int { n }, r ...)) # } # } # return ret
if value == nil { # m . value . Init () # } else { # if listE := m . getListElement ( value ); listE != nil { # m . value . Remove ( listE ) # } # } # return m . value . Len ()
if len ( nums ) == 0 { # return 0 # } # res , left , right , prod := 0 , 0 , 0 , 1 # for left < len ( nums ) { # if right < len ( nums ) && prod * nums [ right ] < k { # prod = prod * nums [ right ] # right ++ # } else if left == right { # left ++ # right ++ # } else { # res += right - left # prod = prod / nums [ left ] # left ++ # } # } # return res
const times = 1 0 0 0 0 # # var tests = [] struct { # vals [] int # }{ # {[] int { 1 , 2 , 3 }}, # {[] int { 1 , 2 , 3 , 4 , 5 }}, # {[] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 0 }}, # } # # for _ , tt := range tests { # cnt := make ( map [ int ] int , len ( tt . vals )) # # s := Constructor ( newList ( tt . vals ...)) # for i := 0 ; i < times ; i ++ { # cnt [ s . GetRandom ()]++ # } # # want := 1 / float 6 4 ( len ( tt . vals )) # for v , n := range cnt { # got := float 6 4 ( n ) / times # if math . Abs ( got - want ) > 1 e - 2 { # t . Errorf (" STR ", tt . vals , v , got , want ) # } # } # }
location := [ 2 5 6 ] int {} # for i := range location { # location [ i ] = - 1 # } # # maxLen , left := 0 , 0 # # for i := 0 ; i < len ( s ); i ++ { # if location [ s [ i ]] >= left { # left = location [ s [ i ]] + 1 # } else if i + 1 - left > maxLen { # maxLen = i + 1 - left # } # location [ s [ i ]] = i # } # # return maxLen
tests := [...] testType { # { # in : 3 , # want : 1 , # }, # { # in : 4 , # want : 2 , # }, # { # in : 5 , # want : 2 , # }, # } # for _ , tt := range tests { # got := bulbSwitch ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
slow , fast := n , squareSum ( n ) # for fast != 1 && slow != fast { # slow = squareSum ( slow ) # fast = squareSum ( squareSum ( fast )) # } # return fast == 1
t . Parallel () # # for _ , tc := range testcases { # if depth := StringTreeDepth ( tc . tree ); depth != tc . depth { # t . Errorf (" STR ", tc . tree , tc . depth , depth ) # } # }
var freq [ 2 5 6 ] int # result := [] int {} # if len ( s ) == 0 || len ( s ) < len ( p ) { # return result # } # for i := 0 ; i < len ( p ); i ++ { # freq [ p [ i ]-' a ']++ # } # left , right , count := 0 , 0 , len ( p ) # # for right < len ( s ) { # if freq [ s [ right ]-' a '] >= 1 { # count -- # } # freq [ s [ right ]-' a ']-- # right ++ # if count == 0 { # result = append ( result , left ) # } # if right - left == len ( p ) { # if freq [ s [ left ]-' a '] >= 0 { # count ++ # } # freq [ s [ left ]-' a ']++ # left ++ # } # # } # return result
t . Parallel () # var sloth Sloth # var industrious Industrious # if msg := AskPolymorph ( sloth ); msg != slothMsg { # t . Errorf (" STR ", msg , slothMsg ) # } # if msg := AskPolymorph ( industrious ); msg != industriousMsg { # t . Errorf (" STR ", msg , industriousMsg ) # }
sum := 0 # fact 1 0 0 := factorial ( 1 0 0 ). String () # # for _ , digit := range fact 1 0 0 { # if n , err := strconv . Atoi ( string ( digit )); err == nil { # sum += n # } # } # # fmt . Println ( sum )
cases := [] struct { # name string # inputs string # expect [] string # }{ # {" STR ", " STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := breadthSolution ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
if target < 0 { # target = - target # } # n := int ( math . Ceil (( math . Sqrt ( 8 * float 6 4 ( target )+ 1 ) - 1 ) / 2 )) # sum := n * ( n + 1 ) / 2 # if sum == target { # return n # } # x := sum - target # if x & 1 == 0 { # return n # } # if n & 1 == 1 { # return n + 2 # } # return n + 1
if h . Count != 0 { # hashKey := h . hash ( key ) # if h . backets [ hashKey ] == nil { # return nil , false # } # le , exist := h . existInList ( key , h . backets [ hashKey ]) # if exist { # return le . Value .( hashElement ). Value , true # } # } # return nil , false
if len ( s ) == 0 { # return true # } # # if res , ok := dict [ s ]; ok { # return res # } # # for _ , word := range wordDict { # if len ( word ) > len ( s ) || word != s [: len ( word )] { # continue # } # # if dfs ( s [ len ( word ):], wordDict , dict ) { # dict [ s ] = true # return true # } # # } # dict [ s ] = false # # return false
var tests = [] struct { # n int # b bool # }{ # { 1 , true }, # { 1 6 , true }, # { 2 1 8 , false }, # } # # for _ , tt := range tests { # b := isPowerOfTwo ( tt . n ) # if b != tt . b { # t . Errorf (" STR ", tt . n , b , tt . b ) # } # }
kl := KthLargest { # heap : make ([] int , 1 , k + 1 ), # k : k , # } # for _ , num := range nums { # kl . Add ( num ) # } # return kl
testCases := [][] string { # {" STR ", " STR ", " STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # } # # expected := [] int { 9 , 6 , 2 2 , 1 } # # for index , tokens := range testCases { # if res := evalRPN ( tokens ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
if ( e [ n ] != n ){ # e [ n ] = getParant ( e , e [ n ]); # } # return e [ n ];
start := 0 # end := len ( nums ) - 1 # for start <= end { # mid := ( start + end ) / 2 # if target == nums [ mid ] { # return mid # } # if nums [ start ] <= nums [ end ] { # if target < nums [ mid ] { # end = mid - 1 # } else { # start = mid + 1 # } # } else { # if target >= nums [ start ] { # if nums [ mid ] >= nums [ start ] && # target > nums [ mid ] { # start = mid + 1 # } else { # end = mid - 1 # } # } else { # if nums [ mid ] >= nums [ start ] { # start = mid + 1 # } else { # if target < nums [ mid ] { # start ++ # end = mid - 1 # } else { # start = mid + 1 # } # } # } # } # } # return - 1
var c map [ string ] interface {} # err := json . Unmarshal ([] byte ( JSON ), & c ) # if err != nil { # log . Println (" STR ", err ) # return # } # # fmt . Println (" STR ", c [" STR "]) # fmt . Println (" STR ", c [" STR "]) # fmt . Println (" STR ") # fmt . Println (" STR ", c [" STR "].( map [ string ] interface {})[" STR "]) # fmt . Println (" STR ", c [" STR "].( map [ string ] interface {})[" STR "])
memo := & Memo { requests : make ( chan request )} # go memo . server ( f ) # return memo
return new ( testBTree ). init ( t )
return *(* float 6 4 )( unsafe . Pointer (& b ))
length := len ( arr ) # for i := 0 ; i < length ; i ++ { # swapFlag := false # for j := i ; j < length ; j ++ { # if arr [ i ] > arr [ j ] { # tmp := arr [ i ] # arr [ i ] = arr [ j ] # arr [ j ] = tmp # swapFlag = true # } # } # if ! swapFlag { # break # } # } # return arr
ans := [] int {} # if len ( nums 1 ) == 0 && len ( nums 2 ) == 0 { # return ans # } # if len ( nums 1 ) == 0 { # return nums 2 [: k ] # } # if len ( nums 2 ) == 0 { # return nums 1 [: k ] # } # for i := 0 ; i < k ; i ++ { # if i > len ( nums 1 ) || k - i > len ( nums 2 ) { # continue # } # m := mergeArray ( maxArray ( nums 1 , i ), maxArray ( nums 2 , k - i )) # if arrayToStr ( ans ) < arrayToStr ( m ) { # ans = m # } # } # return ans
var sum int # dfs ( root , & sum ) # return root
var A = struct { # X string ` aa :" STR "` # }{" STR "} # # aStruct := New ( A ) # aStruct . TagName = " STR " # # var B = struct { # X string ` bb :" STR "` # }{" STR "} # # bStruct := New ( B ) # bStruct . TagName = " STR " # # a , b := aStruct . Map (), bStruct . Map () # if ! reflect . DeepEqual ( a , map [ string ] interface {}{" STR ": " STR "}) { # t . Error (" STR ") # } # # if ! reflect . DeepEqual ( b , map [ string ] interface {}{" STR ": " STR "}) { # t . Error (" STR ") # }
tails := make ([] int , len ( nums )) # var result int # for x := 0 ; x < len ( nums ); x ++ { # var i , j int = 0 , result # for i != j { # m := ( i + j ) / 2 # if tails [ m ] < nums [ x ] { # i = m + 1 # } else { # j = m # } # } # tails [ i ] = nums [ x ] # if i == result { # result ++ # } # } # return result
n := len ( nums ) # res := [] int {} # for i := 0 ; i < n ; i ++ { # k := abs ( nums [ i ]) - 1 # if nums [ k ] > 0 { # nums [ k ] = - nums [ k ] # } # } # for i := 0 ; i < n ; i ++ { # if nums [ i ] > 0 { # res = append ( res , i + 1 ) # } # } # return res
Points := make ([] point , 1 0 ) # for i := 0 ; i < 1 0 ; i ++ { # a := makePoint ( float 6 4 ( i ), float 6 4 ( i * i )) # # Points [ i ] = * a # } # # A := makePoint ( float 6 4 ( 0 ), float 6 4 ( 0 )) # B := makePoint ( float 6 4 ( 1 ), float 6 4 ( 1 )) # P := DivideAndConquer ( Points ) # if P . point 1 != * A || P . point 2 != * B { # fmt . Println ( Points ) # fmt . Println ( P ) # t . Error () # }
b := & Bag {} # b . bag = make ([] int , 0 ) # return b
low , high := 0 , int ( math . Sqrt ( float 6 4 ( c ))) # for low <= high { # if low * low + high * high < c { # low ++ # } else if low * low + high * high > c { # high -- # } else { # return true # } # } # return false
rec := make ([] int , 2 6 ) # for i := range s { # rec [ s [ i ]-' a ']-- # rec [ t [ i ]-' a ']++ # } # rec [ t [ len ( t )- 1 ]-' a ']++ # # var i int # for i = 0 ; i < 2 6 ; i ++ { # if rec [ i ] == 1 { # break # } # } # # return byte (' a ' + i )
sort . Slice ( people , func ( i , j int ) bool { # if people [ i ][ 0 ] == people [ j ][ 0 ] { # return people [ i ][ 1 ] < people [ j ][ 1 ] # } # return people [ i ][ 0 ] > people [ j ][ 0 ] # }) # res := make ([][] int , 0 , len ( people )) # # insert := func ( idx int , person [] int ) { # res = append ( res , person ) # if len ( res )- 1 == idx { # return # } # copy ( res [ idx + 1 :], res [ idx :]) # res [ idx ] = person # } # for _ , p := range people { # insert ( p [ 1 ], p ) # } # return res
week := 7 * 2 4 * time . Hour # end := time . Date ( 2 0 0 0 , time . December , 3 1 , 0 , 0 , 0 , 0 , time . UTC ) # count := 0 # for start := time . Date ( 1 9 0 1 , time . January , 6 , 0 , 0 , 0 , 0 , time . UTC ); start . Before ( end ) ; start = start . Add ( week ) { # if start . Day () == 1 { # count ++ # } # } # fmt . Println ( count )
return CQueue { # stack 1 : list . New (), # stack 2 : list . New (), # }
return len ( n . keyValue ) <= n . t - 1
seven := 7 # return SIX * seven
if ans , ok := randMemo [ k ]; ok { # return ans # } # # if k <= 5 5 { # kay := int 6 4 ( k ) # temp := ( 1 0 0 0 0 3 - ( 2 0 0 0 0 3 * kay ) + ( 3 0 0 0 0 7 * kay * kay * kay )) % 1 0 0 0 0 0 0 # if temp < 0 { # fmt . Println ( k , temp ) # } # randMemo [ k ] = int ( temp ) # return S ( k ) # } # # randMemo [ k ] = ( S ( k - 2 4 ) + S ( k - 5 5 )) % 1 0 0 0 0 0 0 # return S ( k )
n := len ( stones ) # if n == 0 || stones [ 1 ] != 1 { # return false # } # # if n == 1 || n == 2 { # return true # } # # last := stones [ n - 1 ] # m := make ( map [ int ] struct {}, n ) # # for i := 0 ; i < n ; i ++ { # if i > 3 && stones [ i ] > stones [ i - 1 ]* 2 { # return false # } # m [ stones [ i ]] = struct {}{} # } # # var dfs func ( int , int ) bool # dfs = func ( index , jump int ) bool { # tmp := index + jump # if tmp - 1 == last || tmp == last || tmp + 1 == last { # return true # } # for i := 1 ; - 1 <= i ; i -- { # if jump + i > 0 { # if _ , ok := m [ tmp + i ]; ok && dfs ( tmp + i , jump + i ) { # return true # } # } # } # return false # } # return dfs ( 1 , 1 )
for _ , num_val := range prime_pairs { # var is_prime bool = IsPrime ( num_val . number ) # # if is_prime != num_val . val { # t . Errorf (" STR ", num_val . number ) # } # }
sideLength := 3 # primesInSideLength := 3 # diagonalValue := 9 # addition := 4 # # for float 3 2 ( primesInSideLength )/ float 3 2 (( sideLength - 1 )* 2 + 1 ) >= 0 . 1 { # for i := 0 ; i < 4 ; i ++ { # diagonalValue += addition # # if big . NewInt ( int 6 4 ( diagonalValue )). ProbablyPrime ( 2 0 ) { # primesInSideLength += 1 # } # } # sideLength += 2 # addition += 2 # } # # fmt . Println ( sideLength )
i , c , sum := [...] int { 1 , 1 }, 0 , 0 # for c < 4 e 6 { # c = i [ 0 ] + i [ 1 ]; i [ 0 ] = i [ 1 ]; i [ 1 ] = c # if c % 2 == 0 { sum += c } # } # fmt . Printf (" STR ", sum )
tbl := [] brfmt { # {" STR ", [] Bytes {{ 0 , 1 , 0 , false }}, " STR "}, # {" STR ", [] Bytes {{- 4 2 , - 1 , 0 , false }}, " STR "}, # {" STR ", [] Bytes {{ 0 , - 1 , 0 , false }}, " STR "}, # {" STR ", [] Bytes { # { 0 , 1 , 0 , false }, # {- 4 2 , - 1 , 0 , false }, # { 0 , - 1 , 0 , false }, # }, " STR "}, # } # for _ , f := range tbl { # f := f # t . Run ( f . Name , func ( t * testing . T ) { # t . Parallel () # got , err := FormatRequest ( f . In ...) # if err != nil { # t . Error ( err ) # } # if want , got := f . Out , got ; want != got { # t . Errorf (" STR ", want , got ) # } # }) # }
res , max , cur , counter = [] int {}, 0 , 0 , 0 # dfs ( root ) # return res
if num <= 0 { # return false # } # # var sum , i int # for i = 1 ; i * i < num ; i ++ { # if num % i == 0 { # sum += i + num / i # } # } # if i * i == num { # sum += i # } # # return sum - num == num
if n == 0 { # return 1 # } else if n < 0 { # n = - n # } # # return int ( math . Log 1 0 ( float 6 4 ( n ))) + 1
fmt . Println ( isMonotonic ([] int { 1 , 2 , 2 , 3 })) # fmt . Println ( isMonotonic ([] int { 1 }))
if len ( height ) == 0 { # return 0 # } # # n , ans := len ( height ), 0 # leftMax , rightMax := make ([] int , n ), make ([] int , n ) # # leftMax [ 0 ] = height [ 0 ] # for i := 1 ; i < n ; i ++ { # leftMax [ i ] = max ( leftMax [ i - 1 ], height [ i ]) # } # rightMax [ n - 1 ] = height [ n - 1 ] # for i := n - 2 ; i >= 0 ; i -- { # rightMax [ i ] = max ( rightMax [ i + 1 ], height [ i ]) # } # # for i := 0 ; i < n ; i ++ { # fmt . Println ( i , leftMax [ i ], rightMax [ i ], height [ i ]) # ans += min ( leftMax [ i ], rightMax [ i ]) - height [ i ] # } # # return ans
b . lock . Lock () # defer b . lock . Unlock () # # e := b . table [ key ] # if e == nil { # return nil , false , false # } # # b . touchEntry ( e ) # return e . value , true , e . expire . Before ( now )
occ := make ( map [ rune ] int , len ( letters )) # for _ , r := range letters { # occ [ r ]++ # } # # result := str # start := 0 # # for end , r := range str { # if _ , found := occ [ r ]; found { # occ [ r ]-- # if allFound ( occ ) { # for { # if count , found := occ [ rune ( str [ start ])]; found && count + 1 > 0 { # break # } else if found { # occ [ rune ( str [ start ])]++ # } # start ++ # } # # result = candidate ( str [ start : end + 1 ], result ) # } # } # } # # return answer ( result , ! allFound ( occ ))
m , n := len ( A ), len ( A [ 0 ]) # sorted := make ([] bool , m - 1 ) # res := 0 # # L : # for j := 0 ; j < n ; j ++ { # i := 0 # for ; i < m - 1 ; i ++ { # if ! sorted [ i ] && A [ i ][ j ] > A [ i + 1 ][ j ] { # res ++ # continue L # } # } # for i = 0 ; i < m - 1 ; i ++ { # if A [ i ][ j ] < A [ i + 1 ][ j ] { # sorted [ i ] = true # } # } # } # return res
if nodes == nil || len ( nodes ) < 1 { # return & Node {} # } # node := & Node {} # head := node # node . Val = nodes [ 0 ] # for i := 1 ; i < len ( nodes ); i ++ { # node . Next = & Node { Val : nodes [ i ], Prev : node } # node = node . Next # } # return head
http . Handle (" STR ", loggingHandler ( http . HandlerFunc ( index ))) # http . ListenAndServe (" STR ", nil )
n := len ( nums ) # if n < 2 { # return 0 # } # l , r := 0 , n - 1 # for l < n - 1 { # if nums [ l ] > nums [ l + 1 ] { # break # } # l ++ # } # for r > 0 { # if nums [ r ] < nums [ r - 1 ] { # break # } # r -- # } # if l >= r { # return 0 # } # mi , ma := math . MaxInt 3 2 , math . MinInt 3 2 # for i := l ; i <= r ; i ++ { # mi = min ( mi , nums [ i ]) # ma = max ( ma , nums [ i ]) # } # for l >= 0 && mi < nums [ l ] { # l -- # } # for r < n && ma > nums [ r ] { # r ++ # } # return r - l - 1
a , b , c = sort ( a , b , c ) # if c - a == 2 { # return zerozero # } # minM , maxM := 2 , c - a - 2 # if min ( b - a , c - b ) <= 2 { # minM = 1 # } # return [] int { minM , maxM }
l := len ( nums ) # if l < 1 { # return 0 # } # p , rank = initialize ( nums ) # hash := make ( map [ int ] int ) # for _ , v := range nums { # hash [ v ] = 1 # if _ , ok := hash [ v - 1 ]; ok { # union ( v , v - 1 ) # } # if _ , ok := hash [ v + 1 ]; ok { # union ( v , v + 1 ) # } # } # # ans := 0 # for _ , v := range rank { # if v > ans { # ans = v # } # } # return ans
return traverse ( nums , map [ int ] bool {}, [] int {})
q := new ( Queue ) # q . list = list . New () # q . cond = sync . NewCond (& q . mutex ) # return q
a , b := 1 , 1 # # for n > 0 { # b += a # a = b - a # n -- # } # return a
m := make ( map [ int ] int ) # s := [] int {} # for _ , num := range nums { # for len ( s ) != 0 && s [ len ( s )- 1 ] < num { # m [ s [ len ( s )- 1 ]] = num # s = s [: len ( s )- 1 ] # } # s = append ( s , num ) # } # # res := make ([] int , len ( findNums )) # for i , num := range findNums { # if v , ok := m [ num ]; ok { # res [ i ] = v # } else { # res [ i ] = - 1 # } # } # return res
s := [] int {} # # for i := range ops { # switch ops [ i ] { # case " STR ": # s = append ( s , s [ len ( s )- 1 ]+ s [ len ( s )- 2 ]) # case " STR ": # s = append ( s , 2 * s [ len ( s )- 1 ]) # case " STR ": # s = s [: len ( s )- 1 ] # default : # point , _ := strconv . Atoi ( ops [ i ]) # s = append ( s , point ) # } # } # # res := 0 # for _ , p := range s { # res += p # } # return res
x , t := nums [ 0 ], 1 # # for i := 1 ; i < len ( nums ); i ++ { # switch { # case x == nums [ i ]: # t ++ # case t > 0 : # t -- # default : # x = nums [ i ] # t = 1 # } # } # # return x
ans := 0 # dict := make ( map [ uint 8 ] bool , len ( J )) # for i := 0 ; i < len ( J ); i ++ { # dict [ J [ i ]] = true # } # for i := 0 ; i < len ( S ); i ++ { # if dict [ S [ i ]] { # ans ++ # } # } # return ans
return dfs ( nil , 0 , root )
i , n := 0 , len ( nums ) # # for i < n { # if nums [ i ] > 0 && nums [ i ] <= n && nums [ nums [ i ]- 1 ] != nums [ i ] { # nums [ i ], nums [ nums [ i ]- 1 ] = nums [ nums [ i ]- 1 ], nums [ i ] # } else { # i ++ # } # } # # for k := 0 ; k < n ; k ++ { # if nums [ k ] != k + 1 { # return k + 1 # } # } # return n + 1
var res [][] int # var cand [] int # recursiveTreePath ( root , cand , res ) # return res
n := len ( row ) # partner := make ([] int , n ) # indexs := make ([] int , n ) # for i := 0 ; i < n ; i ++ { # if i % 2 == 0 { # partner [ i ] = i + 1 # } else { # partner [ i ] = i - 1 # } # indexs [ row [ i ]] = i # } # # res := 0 # for i := 0 ; i < n ; i ++ { # for j := partner [ indexs [ partner [ row [ i ]]]]; i != j ; j = partner [ indexs [ partner [ row [ i ]]]] { # row [ i ], row [ j ] = row [ j ], row [ i ] # indexs [ row [ i ]], indexs [ row [ j ]] = indexs [ row [ j ]], indexs [ row [ i ]] # res ++ # } # } # return res
qs := [] question 1 2 9 2 { # # { # para 1 2 9 2 {[][] int {{ 1 , 1 , 3 , 2 , 4 , 3 , 2 }, { 1 , 1 , 3 , 2 , 4 , 3 , 2 }, { 1 , 1 , 3 , 2 , 4 , 3 , 2 }}, 4 }, # ans 1 2 9 2 { 2 }, # }, # # { # para 1 2 9 2 {[][] int {{ 2 , 2 , 2 , 2 , 2 }, { 2 , 2 , 2 , 2 , 2 }, { 2 , 2 , 2 , 2 , 2 }, { 2 , 2 , 2 , 2 , 2 }, { 2 , 2 , 2 , 2 , 2 }}, 1 }, # ans 1 2 9 2 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 9 2 , q . para 1 2 9 2 # fmt . Printf (" STR ", p , maxSideLength ( p . mat , p . threshold )) # } # fmt . Printf (" STR ")
var cnt int # for h := height ( root ) - 1 ; root != nil ; h -- { # rh := height ( root . Right ) # # if h == rh { # cnt += 1 << uint ( h ) # root = root . Right # h = rh # } else { # cnt += 1 << uint ( rh ) # root = root . Left # } # } # return cnt
sum := 1 # for i := 3 ; i <= size ; i += 2 { # sum += 4 * i * i - 6 * ( i - 1 ) # } # return sum
t . Parallel () # # for _ , tc := range testcases { # if res , err := LowestFixedPoint ( tc . input ); res != tc . expected || err != tc . expectedErr { # t . Errorf (" STR ", tc . expected , tc . expectedErr , res , err ) # } # }
n := len ( prices ) # if n == 0 { # return 0 # } # # buy := make ([] int , n + 1 ) # sel := make ([] int , n + 1 ) # buy [ 1 ] -= prices [ 0 ] # # for i := 2 ; i < n + 1 ; i ++ { # buy [ i ] = max ( buy [ i - 1 ], sel [ i - 2 ]- prices [ i - 1 ]) # sel [ i ] = max ( sel [ i - 1 ], buy [ i - 1 ]+ prices [ i - 1 ]) # } # return sel [ n ]
sort . Ints ( nums ) # n := len ( nums ) # return max ( nums [ n - 1 ]* nums [ n - 2 ]* nums [ n - 3 ], nums [ n - 1 ]* nums [ 0 ]* nums [ 1 ])
cases := [] struct { # name string # inputs string # expect [] string # }{ # {" STR ", " STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := letterCombinations ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
if me . unread { # me . unread = false # return me . b [ 0 ], nil # } # n , err := me . r . Read ( me . b [:]) # if n == 1 { # err = nil # } # return me . b [ 0 ], err
ransom := " STR " # magazine := " STR " # # fmt . Println ( canConstruct ( ransom , magazine ))
var res [] int # if root == nil { # return res # } # var stack = []* Node { root } # for 0 < len ( stack ) { # res = append ( res , root . Val ) # for _ , n := range root . Children { # stack = append ( stack , n ) # } # # root = stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # } # # l := len ( res ) - 1 # for i := 0 ; i < l / 2 + 1 ; i ++ { # res [ i ], res [ l - i ] = res [ l - i ], res [ i ] # } # return res
t . Parallel () # for _ , tc := range testcases { # if result := ReversePolishCalculator ( tc . input ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
fmt . Println ( findDuplicates ([] int { 4 , 3 , 2 , 7 , 8 , 2 , 3 , 1 }))
t . Parallel () # result := MaxPathSum ( tree ) # if result != 2 7 { # t . Errorf (" STR ", result ) # }
res := " STR " # for n > 0 { # n -- # res = string ( byte ( n % 2 6 )+' A ') + res # n /= 2 6 # } # return res
line , err := c . readLine () # if err != nil { # return c . fatal ( err ) # } # switch { # case bytes . Equal ( line , replyStored ): # return nil # case bytes . Equal ( line , replyNotStored ): # return ErrNotStored # case bytes . Equal ( line , replyExists ): # return ErrExists # case bytes . Equal ( line , replyNotFound ): # return ErrNotFound # } # return protocolError (" STR ")
count := make ( map [ string ] int , len ( strs )) # for _ , s := range strs { # count [ s ]++ # } # # strs = strs [: 0 ] # for s := range count { # strs = append ( strs , s ) # } # # sort . Sort ( stringSlice ( strs )) # # for i , s := range strs { # if count [ s ] > 1 { # continue # } # if ! isSubOf ( s , strs [: i ]) { # return len ( s ) # } # } # # return - 1
if k == 0 || len ( nums ) == 0 { # return # } # k = k % len ( nums ) # if k == 0 { # return # } # tmp := nums # nums = append ( nums [ len ( nums )- k :], nums [ 0 : len ( nums )- k ]...) # for i := 0 ; i < len ( tmp ); i ++ { # tmp [ i ] = nums [ i ] # } # return
if err == nil { # return # } # # switch code := err .( type ) { # case exitCode : # exitFunc ( int ( code )) # default : # panic ( err ) # }
m := len ( wall ) # # count := make ( map [ int ] int , m ) # # for i := 0 ; i < m ; i ++ { # sum := wall [ i ][ 0 ] # for j := 1 ; j < len ( wall [ i ]); j ++ { # count [ sum ]++ # sum += wall [ i ][ j ] # } # } # # max := 0 # for _ , edges := range count { # if max < edges { # max = edges # } # } # # return m - max
queue := make ([] int , 0 ) # discovered := make ([] int , nodes ) # discovered [ start ] = 1 # queue = append ( queue , start ) # for len ( queue ) > 0 { # v := queue [ 0 ] # if len ( queue ) > 0 { # queue = queue [ 1 :] # } # for i := 0 ; i < len ( edges [ v ]); i ++ { # if discovered [ i ] == 0 && edges [ v ][ i ] > 0 { # if i == end { # return true , discovered [ v ] # } # discovered [ i ] = discovered [ v ] + 1 # queue = append ( queue , i ) # } # } # } # return false , 0
var items [] int # current := list . rear # for current != nil { # items = append ( items , current . data ) # current = current . next # } # return items
n , m := len ( indexes ), len ( S ) # es := make ([]* entry , n ) # for i , index := range indexes { # es [ i ] = & entry { # i : index , # s : sources [ i ], # t : targets [ i ], # } # } # sort . Slice ( es , func ( i , j int ) bool { # return es [ i ]. i < es [ j ]. i # }) # bs := strings . Builder {} # i , j := 0 , 0 # for _ , e := range es { # i = j # bs . WriteString ( S [ i : e . i ]) # j = min ( m , e . i + len ( e . s )) # s := S [ e . i : j ] # if s == e . s { # bs . WriteString ( e . t ) # } else { # bs . WriteString ( s ) # } # } # if j < m { # bs . WriteString ( S [ j :]) # } # return bs . String ()
if power == 0 { # return 1 # } # var temp = RecursivePower ( n , power / 2 ) # if power % 2 == 0 { # return temp * temp # } # return n * temp * temp
return dp (" STR ", 0 , n * 2 )
if a < b { # return b # } # return a
benchmark ( bb , 1 6 3 8 4 , 1 )
remainNum [ s [ index : index + wordLen ]]++ # count -- # index += wordLen # return index , count
ans , prev , cur := 0 , 0 , 1 # for i := 1 ; i < len ( s ); i ++ { # if s [ i - 1 ] != s [ i ] { # ans += min ( prev , cur ) # prev = cur # cur = 1 # } else { # cur ++ # } # } # return ans + min ( prev , cur )
f , err := os . OpenFile (" STR ", os . O_RDWR | os . O_CREATE | os . O_APPEND , 0 6 6 6 ) # if err != nil { # log . Fatalf (" STR ", err . Error ()) # } # # switch level { # case TRACE : # initLog ( f , f , f , f , true ) # return # # case INFO : # initLog ( ioutil . Discard , f , f , f , true ) # return # # case WARNING : # initLog ( ioutil . Discard , ioutil . Discard , f , f , true ) # return # case ERROR : # initLog ( ioutil . Discard , ioutil . Discard , ioutil . Discard , f , true ) # return # # default : # initLog ( ioutil . Discard , ioutil . Discard , ioutil . Discard , ioutil . Discard , false ) # f . Close () # return # # }
result := & weightedQU {} # result . IDs = make ([] int , n ) # result . Weights = make ([] int , n ) # for x := range result . IDs { # result . IDs [ x ] = x # result . Weights [ x ] = 1 # } # return result
return NewPerlinRandSource ( alpha , beta , n , rand . NewSource ( seed ))
count := make ( map [ int ] int , len ( A )) # for _ , a := range A { # count [ a ]++ # } # hasSeen := make ( map [ int ] bool , len ( count )) # for _ , c := range count { # if hasSeen [ c ] { # return false # } # hasSeen [ c ] = true # } # return true
benchmarkFramework ( b , Mergesort )
t . Run (" STR ", func ( t * testing . T ) { # tree := conFromPreStr (" STR ") # # fmt . Println ( dumpTreeToString ( tree )) # })
rw . write . Wait () # # rw . readerControl . Acquire ( 1 )
if num < 1 { # return false # } # # for num % 4 == 0 { # num /= 4 # } # return num == 1
var vals [] int # # var stack []* TreeNode # for p := root ; p != nil || len ( stack ) > 0 ; p = p . Right { # for p != nil { # stack = append ( stack , p ) # p = p . Left # } # n := len ( stack ) - 1 # p = stack [ n ] # stack = stack [: n ] # # vals = append ( vals , p . Val ) # } # # return vals
if n == 0 || n == 1 { # return 1 # } # return fib ( n - 1 ) + fib ( n - 2 )
if numRows == 1 || len ( s ) <= numRows { # return s # } # # res := bytes . Buffer {} # p := numRows * 2 - 2 # # for i := 0 ; i < len ( s ); i += p { # res . WriteByte ( s [ i ]) # } # # for r := 1 ; r <= numRows - 2 ; r ++ { # res . WriteByte ( s [ r ]) # # for k := p ; k - r < len ( s ); k += p { # res . WriteByte ( s [ k - r ]) # if k + r < len ( s ) { # res . WriteByte ( s [ k + r ]) # } # } # } # # for i := numRows - 1 ; i < len ( s ); i += p { # res . WriteByte ( s [ i ]) # } # # return res . String ()
if len ( S ) < 3 { # return [] int {} # } # res , isComplete := [] int {}, false # for firstEnd := 0 ; firstEnd < len ( S )/ 2 ; firstEnd ++ { # if S [ 0 ] == ' 0 ' && firstEnd > 0 { # break # } # first , _ := strconv . Atoi ( S [: firstEnd + 1 ]) # if first >= 1 << 3 1 { # break # } # for secondEnd := firstEnd + 1 ; max ( firstEnd , secondEnd - firstEnd ) <= len ( S )- secondEnd ; secondEnd ++ { # if S [ firstEnd + 1 ] == ' 0 ' && secondEnd - firstEnd > 1 { # break # } # second , _ := strconv . Atoi ( S [ firstEnd + 1 : secondEnd + 1 ]) # if second >= 1 << 3 1 { # break # } # findRecursiveCheck ( S , first , second , secondEnd + 1 , & res , & isComplete ) # } # } # return res
A := [] int { 1 , 2 } # B := [] int {- 2 , - 1 } # C := [] int {- 1 , 2 } # D := [] int { 0 , 2 } # # expectedData := 2 # # if res := fourSumCount ( A , B , C , D ); res != expectedData { # t . Errorf (" STR ", expectedData , res ) # }
tails := make ([] int , 0 , len ( nums )) # # for _ , n := range nums { # at := sort . SearchInts ( tails , n ) # if at == len ( tails ) { # tails = append ( tails , n ) # } else if tails [ at ] > n { # tails [ at ] = n # } # } # # return len ( tails )
t . Parallel () # # for _ , tc := range testcases { # if q , r := DivisionBrute ( tc . dividend , tc . divisor ); q != tc . quotient || r != tc . remainder { # t . Errorf (" STR ", tc . quotient , tc . remainder , q , r ) # } # }
set := make ( map [ int ] struct {}, len ( G )) # for _ , g := range G { # set [ g ] = struct {}{} # } # # var num int # for prev := false ; head != nil ; head = head . Next { # _ , ok := set [ head . Val ] # if ok && ! prev { # num ++ # } # prev = ok # } # return num
prod := big . NewInt ( 1 ) # # for n := int 6 4 ( 1 0 0 ); n > 0 ; n -- { # # prod . Mul ( prod , big . NewInt ( n )) # # } # # bytes := [] byte ( prod . String ()) # # var ints = make ([] int , len ( bytes )) # # for i , s := range bytes { # # integer , err := strconv . Atoi ( string ( s )) # if err != nil { # panic ( err ) # } # # ints [ i ] = integer # } # # sum := 0 # # for i := 0 ; i < len ( ints ); i ++ { # sum += ints [ i ] # } # # fmt . Println ( sum ) #
uri := " http : # # resp , err := http . Get ( uri ) # if err != nil { # log . Println (" STR ", err ) # return # } # defer resp . Body . Close () # # var gr gResponse # err = json . NewDecoder ( resp . Body ). Decode (& gr ) # if err != nil { # log . Println (" STR ", err ) # return # } # # fmt . Println ( gr ) # # pretty , err := json . MarshalIndent ( gr , " STR " ") # if err != nil { # log . Println (" STR ", err ) # return # } # # fmt . Println ( string ( pretty ))
n := len ( nums ) # if n == 0 { # return nil # } # # sort . Ints ( nums ) # dp := make ([] int , n ) # for i := 0 ; i < n ; i ++ { # dp [ i ] = 1 # } # # next := make ([] int , n ) # max , index := 1 , 0 # # for i := n - 2 ; i >= 0 ; i -- { # for j := n - 1 ; j > i ; j -- { # if nums [ j ]% nums [ i ] != 0 { # continue # } # if dp [ j ]+ 1 > dp [ i ] { # dp [ i ] = dp [ j ] + 1 # next [ i ] = j # } # if dp [ i ] > max { # max = dp [ i ] # index = i # } # } # # } # # res := make ([] int , max ) # for i := 0 ; i < max ; i ++ { # res [ i ] = nums [ index ] # index = next [ index ] # } # return res
qs := [] question 5 5 { # # { # para 5 5 {[] int { 2 , 3 , 1 , 1 , 4 }}, # ans 5 5 { true }, # }, # { # para 5 5 {[] int { 3 , 2 , 1 , 0 , 4 }}, # ans 5 5 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 5 , q . para 5 5 # fmt . Printf (" STR ", p , canJump ( p . one )) # } # fmt . Printf (" STR ")
permutations := [][] int { nums } # for i := 0 ; i + 1 < len ( nums ); i ++ { # instances := permutations # for j := i + 1 ; j < len ( nums ); j ++ { # for _ , instance := range instances { # permutation := make ([] int , len ( instance )) # copy ( permutation , instance ) # permutation [ i ], permutation [ j ] = permutation [ j ], permutation [ i ] # permutations = append ( permutations , permutation ) # } # } # } # return permutations
arity , ok := numParams [ c . fn ] # if ! ok { # return fmt . Errorf (" STR ", c . fn ) # } # if len ( c . args ) != arity { # return fmt . Errorf (" STR ", # c . fn , len ( c . args ), arity ) # } # for _ , arg := range c . args { # if err := arg . Check ( vars ); err != nil { # return err # } # } # return nil
n , m := 5 , 3 # fmt . Println ( lastRemaining ( n , m ))
x := rand . Float 6 4 () # for i := 0 ; i < bb . N ; i += 1 { # math . Exp ( x ) # }
if n == 1 { # return 1 # } # # pos := make ([] int , len ( primes )) # candidates := make ([] int , len ( primes )) # copy ( candidates , primes ) # # res := make ([] int , n ) # # res [ 0 ] = 1 # # for i := 1 ; i < n ; i ++ { # res [ i ] = min ( candidates ) # for j := 0 ; j < len ( primes ); j ++ { # if res [ i ] == candidates [ j ] { # pos [ j ]++ # candidates [ j ] = res [ pos [ j ]] * primes [ j ] # } # } # } # # return res [ n - 1 ]
maxCount := 0 # l := 0 # var r int # count := make ([] int , 2 6 ) # for r = 0 ; r < len ( s ); r ++ { # count [ s [ r ]-' A ']++ # maxCount = int ( math . Max ( float 6 4 ( maxCount ), float 6 4 ( count [ s [ r ]-' A ']))) # if r - l + 1 - maxCount > k { # count [ s [ l ]-' A ']-- # l ++ # } # } # return r - l
rw := readerWriter { # name : name , # shutdown : make ( chan struct {}), # maxReads : maxReads , # maxReaders : maxReaders , # readerControl : make ( semaphore , maxReads ), # } # # rw . reportShutdown . Add ( maxReaders ) # for goroutine := 0 ; goroutine < maxReaders ; goroutine ++ { # go rw . reader ( goroutine ) # } # # rw . reportShutdown . Add ( 1 ) # go rw . writer () # # return & rw
res := [] string {} # temp := [] string {} # width := 0 # isLast := false # # for ! isLast { # words , temp , width , isLast = split ( words , maxWidth ) # res = append ( res , combine ( temp , width , maxWidth , isLast )) # } # # return res
var tests = [] struct { # tree * TreeNode # count int # }{ # { newTree ( 1 ), 1 }, # { newTree ( 1 , 2 , 3 , 4 ), 4 }, # { newTree ( 1 , 2 , 3 , 4 , 5 , 6 ), 6 }, # } # # for _ , tt := range tests { # count := countNodes ( tt . tree ) # if count != tt . count { # t . Errorf (" STR ", tt . tree , count , tt . count ) # } # }
for n := 0 ; n < b . N ; n ++ { # main () # }
if x > y { # return y # } # # return x
if len ( r ) == 0 { # return " STR " no ranges provided ") # } # b := bytes . NewBuffer ([] byte (" STR ")) # for i , br := range r { # if i != 0 { # b . WriteString (" STR ") # } # re , err := br . fmtRequest () # if err != nil { # return "", err # } # b . WriteString ( re ) # } # return b . String (), nil
qs := [] question 7 1 4 { # # { # para 7 1 4 {[] int {}, 0 }, # ans 7 1 4 { 0 }, # }, # # { # para 7 1 4 {[] int { 7 , 1 , 5 , 3 , 6 , 4 }, 0 }, # ans 7 1 4 { 7 }, # }, # # { # para 7 1 4 {[] int { 7 , 6 , 4 , 3 , 1 }, 0 }, # ans 7 1 4 { 0 }, # }, # # { # para 7 1 4 {[] int { 1 , 3 , 2 , 8 , 4 , 9 }, 2 }, # ans 7 1 4 { 8 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 1 4 , q . para 7 1 4 # fmt . Printf (" STR ", p , maxProfit 7 1 4 ( p . one , p . f )) # } # fmt . Printf (" STR ")
na := NumArray { segmentTree : make ([] int , len ( nums )* 4 ), data : nums [:]} # na . buildSegmentTree ( 0 , 0 , len ( na . data )- 1 ) # return na
if root == nil { # return nil # } # # for root != nil { # if p . Val > root . Val && q . Val > root . Val { # root = root . Right # } else if p . Val < root . Val && q . Val < root . Val { # root = root . Left # } else { # return root # } # } # return nil #
if t == nil { # t = new ( tree ) # t . value = value # return t # } # if value < t . value { # t . left = add ( t . left , value ) # } else { # t . right = add ( t . right , value ) # } # return t
prefixParseFns = map [ token . Token ] func (* tokenizer ) ( ast . Expr , * scanner . Error ){ # token . IDENT : parseIdent , # token . INT : parseBasicLit , # token . FLOAT : parseBasicLit , # token . STRING : parseBasicLit , # token . CHAR : parseBasicLit , # token . LPAREN : parseParenExpr , # token . SUB : parseUnaryExpr , # }
return h . n
leftHead := & SinglyLL {} # rightHead := & SinglyLL {} # left := leftHead # right := rightHead # for head != nil { # if head . Value < k { # left . Next = & SinglyLL { Value : head . Value } # left = left . Next # } else { # right . Next = & SinglyLL { Value : head . Value } # right = right . Next # } # head = head . Next # } # left . Next = rightHead . Next # return leftHead . Next
s 1 , s 2 := [] int {}, [] int {} # for l 1 != nil { # s 1 = append ( s 1 , l 1 . Val ) # l 1 = l 1 . Next # } # for l 2 != nil { # s 2 = append ( s 2 , l 2 . Val ) # l 2 = l 2 . Next # } # # sum := 0 # head := & ListNode { Val : 0 } # # for len ( s 1 ) > 0 || len ( s 2 ) > 0 { # if len ( s 1 ) > 0 { # sum += s 1 [ len ( s 1 )- 1 ] # s 1 = s 1 [: len ( s 1 )- 1 ] # } # if len ( s 2 ) > 0 { # sum += s 2 [ len ( s 2 )- 1 ] # s 2 = s 2 [: len ( s 2 )- 1 ] # } # head . Val = sum % 1 0 # tmp := & ListNode { Val : sum / 1 0 } # tmp . Next = head # head = tmp # # sum /= 1 0 # } # if head . Val == 0 { # return head . Next # } # return head
if len ( r . nodeList ) == 0 { # return # } # sum := 0 # for _ , node := range r . nodeList { # sum = sum + node . weight # node . current += node . weight # if selectNode == nil || node . current > selectNode . current { # selectNode = node # } # } # if selectNode == nil { # return # } # selectNode . current -= sum # return
largest := 1 # # largest *= 2 * 2 * 2 * 2 # largest *= 3 * 3 # largest *= 5 # largest *= 7 # largest *= 1 1 # largest *= 1 3 # largest *= 1 7 # largest *= 1 9 # # fmt . Println ( largest )
s := math . Sqrt ( v [ 0 ]* v [ 0 ] + v [ 1 ]* v [ 1 ]) # v [ 0 ] = v [ 0 ] / s # v [ 1 ] = v [ 1 ] / s
return RecentCounter 9 3 3 { # queue : make ([] int , 0 ), # }
size := len ( A ) # A [ size - 1 ] += K # for i := size - 1 ; i > 0 && A [ i ] > 9 ; i -- { # A [ i - 1 ] += A [ i ] / 1 0 # A [ i ] %= 1 0 # } # # if A [ 0 ] < 1 0 { # return A # } # # A 0 := num 2 ints ( A [ 0 ]) # return append ( A 0 , A [ 1 :]...)
n := big . NewInt ( 0 ) # two := big . NewInt ( 2 ) # exp := big . NewInt ( 1 0 0 0 ) # # n = n . Exp ( two , exp , nil ) # # sum := 0 # for _ , digit := range strings . Split ( n . String (), " STR ") { # d , _ := strconv . Atoi ( digit ) # sum += d # } # # fmt . Println ( sum )
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 7 , 1 , 5 , 3 , 6 , 4 }, 7 }, # {" STR ", [] int { 1 , 2 , 3 , 4 , 5 }, 4 }, # {" STR ", [] int { 7 , 6 , 4 , 3 , 1 }, 0 }, # } # # for i , c := range cases { # t . Run ( c . name + strconv . Itoa ( i ), func ( t * testing . T ) { # got := maxProfit ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
t . Parallel () # # for _ , tc := range testcases { # if result := Sqrt ( tc . n ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
mu . Lock () # fmt . Fprintf ( w , " STR ", count ) # mu . Unlock ()
return NewTimeoutReaderSize ( reader , timeout , closeOnTimeout , 0 )
for i := range datas { # for j := range datas [ i ] { # vEBT . Insert ( i , datas [ i ][ j ]) # } # }
if root != nil { # postorder ( root . Left ) # postorder ( root . Right ) # println ( root . Val ) # }
if n . Cmp ( c ) == 0 || n . Cmp ( c ) == - 1 { # return c # } # # result = new ( big . Int ) # result . Set ( n ) # result . Mul ( result , Factorial ( n . Sub ( n , c ))) # # return result
group := make ( map [ int ] int ) # for i := 1 ; i <= n ; i ++ { # s := 0 # for x := i ; x > 0 ; x /= 1 0 { # s += x % 1 0 # } # group [ s ]++ # } # ans , max := 0 , 0 # for _ , v := range group { # if v == max { # ans ++ # } else if v > max { # ans , max = 1 , v # } # } # return ans
if node . Right != nil { # node = node . Right # for node . Left != nil { # node = node . Left # } # return node # } else { # for node . Parent != nil { # if node . Parent . Left == node { # return node . Parent # } # node = node . Parent # } # } # return nil
return A . cols
val := binary . BigEndian . Uint 1 6 ( self . data ) # self . data = self . data [ 2 :] # return val
return uint 3 2 (( dev >> 2 4 ) & 0 xff )
if numRows < 1 { # return nil # } # # ans := make ([][] int , 0 ) # # for i := 0 ; i < numRows ; i ++ { # oneLine := make ([] int , i + 1 ) # oneLine [ 0 ] = 1 # oneLine [ i ] = 1 # # for j := 1 ; j < i ; j ++ { # oneLine [ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ] # } # # ans = append ( ans , oneLine ) # } # return ans
sum := 0 # for _ , num := range nums { # sum += num # } # if sum % 2 == 1 { # return false # } # sum /= 2 # # sort . Sort ( sort . Reverse ( sort . IntSlice ( nums ))) # n := len ( nums ) # var can func ( int , int ) bool # can = func ( index , currSum int ) bool { # if n <= index { # return false # } # tmpSum := currSum + nums [ index ] # if tmpSum == sum { # return true # } # if tmpSum > sum { # return false # } # index ++ # return can ( index , tmpSum ) || can ( index , currSum ) # } # return can ( 0 , 0 )
oldColor := image [ sr ][ sc ] # if oldColor == newColor { # return image # } # # m , n := len ( image ), len ( image [ 0 ]) # # coordinates := make ([][] int , 1 , m * n ) # coordinates [ 0 ] = [] int { sr , sc } # # for len ( coordinates ) > 0 { # c := coordinates [ 0 ] # coordinates = coordinates [ 1 :] # image [ c [ 0 ]][ c [ 1 ]] = newColor # # for i := 0 ; i < 4 ; i ++ { # x := c [ 0 ] + dx [ i ] # y := c [ 1 ] + dy [ i ] # if 0 <= x && x < m && # 0 <= y && y < n && # image [ x ][ y ] == oldColor { # coordinates = append ( coordinates , [] int { x , y }) # } # } # } # # return image
ans := make ([] int , len ( A )) # for i , v := range A { # ans [ i ] = v * v # } # sort . Ints ( ans ) # return ans
line , err := c . readLine () # if err != nil { # return 0 , c . fatal ( err ) # } # switch { # case bytes . Equal ( line , replyNotFound ): # return 0 , ErrNotFound # case bytes . HasPrefix ( line , replyClientErrorPrefix ): # errMsg := line [ len ( replyClientErrorPrefix ):] # return 0 , protocolError ( errMsg ) # } # val , err := strconv . ParseUint ( string ( line ), 1 0 , 6 4 ) # if err != nil { # return 0 , err # } # return val , nil
r , err := FormatResponse ( Bytes { Start : 0 , End : 4 0 9 5 , Length : 4 0 9 6 , Satisfied : true }) # if err != nil { # panic ( err ) # } # fmt . Println ( r )
if x == 0 || x == 1 { # return x # } # # var ( # xn float 6 4 = 1 # n_ int 6 4 = int 6 4 ( n ) # ) # if n < 0 { # n_ = - n_ # } # # for n_ > 0 { # if n_ & 1 == 1 { # xn *= x # } # x *= x # n_ >>= 1 # } # # if n < 0 { # xn = 1 / xn # } # return xn
var tests = [] struct { # nums [] int # single int # }{ # {[] int { 2 , 2 , 3 , 2 }, 3 }, # {[] int { 0 , 1 , 0 , 1 , 0 , 1 , 9 9 }, 9 9 }, # } # # for _ , tt := range tests { # single := singleNumber ( tt . nums ) # if single != tt . single { # t . Errorf (" STR ", tt . nums , single , tt . single ) # } # }
favorites = append ( favorites , favorite )
var vals [] int # # var stack []* TreeNode # for p := root ; p != nil || len ( stack ) > 0 ; p = p . Left { # if p == nil { # n := len ( stack ) - 1 # p = stack [ n ] # stack = stack [: n ] # } # vals = append ( vals , p . Val ) # if p . Right != nil { # stack = append ( stack , p . Right ) # } # } # # return vals
m := map [ int ] bool {} # for i := range nums { # if m [ nums [ i ]] { # return true # } # m [ nums [ i ]] = true # } # return false
qs := [] question 1 2 5 2 { # # { # para 1 2 5 2 { 2 , 3 , [][] int {{ 0 , 1 }, { 1 , 1 }}}, # ans 1 2 5 2 { 6 }, # }, # # { # para 1 2 5 2 { 2 , 2 , [][] int {{ 1 , 1 }, { 0 , 0 }}}, # ans 1 2 5 2 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 5 2 , q . para 1 2 5 2 # fmt . Printf (" STR ", p , oddCells ( p . n , p . m , p . indices )) # } # fmt . Printf (" STR ")
startingSundays , dayOfWeek := 0 , 1 # for year := 1 9 0 0 ; year <= 2 0 0 0 ; year ++ { # setFebruaryDays ( year ) # for month := 0 ; month < 1 2 ; month ++ { # if dayOfWeek % 7 == 0 && year >= 1 9 0 1 { # startingSundays ++ # } # dayOfWeek += daysPerMonth [ month ] # } # } # fmt . Println (" STR ", startingSundays )
var tests = [] struct { # before [] interface {} # after * TreeNode # }{ # {[] interface {}{ 1 , 2 , 5 , 3 , 4 , nil , 6 }, newTree ( 1 , nil , 2 , nil , 3 , nil , 4 , nil , 5 , nil , 6 )}, # } # # for _ , tt := range tests { # after := newTree ( tt . before ...) # flatten ( after ) # if reflect . DeepEqual ( after , tt . after ) == false { # t . Errorf (" STR ", newTree ( tt . before ...), after , tt . after ) # } # }
names := make ([] string , 0 , len ( ps . Packages )) # for name := range ps . Packages { # names = append ( names , name ) # } # sort . Strings ( names ) # return names
return MyHashSet { # s : make ([] bool , 1 0 0 0 0 , 1 0 0 0 0 0 1 ), # len : 1 0 0 0 0 , # cap : 1 0 0 0 0 0 1 , # }
if name == typed { # return true # } # # nameSize := len ( name ) # typedSize := len ( typed ) # # i , j := 0 , 0 # # for i < nameSize && j < typedSize { # c := name [ i ] # need , pressed := 0 , 0 # # for i < nameSize && name [ i ] == c { # need ++ # i ++ # } # # for j < typedSize && typed [ j ] == c { # pressed ++ # j ++ # } # # if pressed < need { # return false # } # # } # # return i == nameSize && j == typedSize
srcFile , err := os . Open (" STR ") # if err != nil { # log . Fatalln ( err ) # } # defer srcFile . Close () # # longest := LongestWord ( srcFile ) # fmt . Println ( longest )
s . lock . Lock () # defer s . lock . Unlock () # # return s . stack [ 0 ]
return subarraysWithKDistinctSlideWindow ( A , K ) - subarraysWithKDistinctSlideWindow ( A , K - 1 )
t . Parallel () # for tcid , tc := range testcases { # if result := SumRevLLNum ( tc . first , tc . second ); ! equal ( result , tc . sum ) { # t . Errorf (" STR ", # tcid , String ( result ), String ( tc . sum )) # } # }
dp := make ([] int , len ( cost )) # dp [ 0 ], dp [ 1 ] = cost [ 0 ], cost [ 1 ] # for i := 2 ; i < len ( cost ); i ++ { # dp [ i ] = cost [ i ] + min ( dp [ i - 2 ], dp [ i - 1 ]) # } # return min ( dp [ len ( cost )- 2 ], dp [ len ( cost )- 1 ])
c := & VariableAccess { Name : " STR "} # scope := & BasicScope { # VarMap : map [ string ] Variable { # " STR ": Variable { Type : TypeString }, # }, # } # # _ , err := c . Type ( scope ) # if err == nil { # t . Fatal (" STR ") # }
go recover ()
n := len ( board ) # nn := n * n # dist := map [ int ] int { 1 : 0 } # queue := [] int { 1 } # for len ( queue ) != 0 { # count := len ( queue ) # for i := 0 ; i < count ; i ++ { # cur := queue [ i ] # if cur >= nn { # return dist [ cur ] # } # for j := 1 ; j < 7 ; j ++ { # index := cur + j # if index > nn { # break # } # x , y := getCoord ( n , index ) # next := board [ x ][ y ] # if next == - 1 { # next = index # } # if _ , ok := dist [ next ]; ! ok { # dist [ next ] = dist [ cur ] + 1 # queue = append ( queue , next ) # } # } # } # queue = queue [ count :] # } # return - 1
benchmark ( bb , 3 2 7 6 8 , 1 )
if len ( inorder ) == 0 { # return nil # } # rootIndex := & Index { len ( postorder ) - 1 } # return buildTreeR ( inorder , postorder , 0 , len ( postorder )- 1 , rootIndex )
left , right := 0 , 0 # for right = range A { # K -= 1 ^ A [ right ] # if K < 0 { # K += 1 ^ A [ left ] # left ++ # } # } # return right - left + 1
if t 1 == nil { # return t 2 # } else if t 2 == nil { # return t 1 # } # t 1 . Val = t 1 . Val + t 2 . Val # t 1 . Left = mergeTrees ( t 1 . Left , t 2 . Left ) # t 1 . Right = mergeTrees ( t 1 . Right , t 2 . Right ) # return t 1
t . Parallel () # # for _ , tc := range testcases { # if result := MinimumRooms ( tc . lectures ); result != tc . roomsNeeded { # t . Errorf (" STR ", tc . roomsNeeded , result ) # } # }
if len ( s ) < len ( t ) { # return 0 # } # n := len ( s ) # m := len ( t ) # subArr := make ([] int , m + 1 ) # subArr [ 0 ] = 1 # for i := 1 ; i < n + 1 ; i ++ { # for k := 0 ; k < m ; k ++ { # j := m - k # if s [ i - 1 ] == t [ j - 1 ] { # subArr [ j ] = subArr [ j ] + subArr [ j - 1 ] # } # } # } # return subArr [ m ]
t . Run (" STR ", func ( t * testing . T ) { # got := isPalindrome ( 1 2 1 1 2 1 ) # want := true # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # }) # # t . Run (" STR ", func ( t * testing . T ) { # got := isPalindrome (- 1 2 1 ) # want := false # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # }) # # t . Run (" STR ", func ( t * testing . T ) { # got := isPalindrome ( 1 0 ) # want := false # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # }) #
if length == 1 { # return 1 0 - int 6 4 ( start ) # } # # if answer , ok := memo [[ 2 ] int { length , start }]; ok { # return answer # } # # answer := int 6 4 ( 0 ) # for i := start ; i < 1 0 ; i ++ { # answer += increasing ( length - 1 , i ) # } # # memo [[ 2 ] int { length , start }] = answer # # return answer #
maxArea , stack , height := 0 , [] int {}, 0 # for i := 0 ; i <= len ( heights ); i ++ { # if i == len ( heights ) { # height = 0 # } else { # height = heights [ i ] # } # if len ( stack ) == 0 || height >= heights [ stack [ len ( stack )- 1 ]] { # stack = append ( stack , i ) # } else { # tmp := stack [ len ( stack )- 1 ] # fmt . Printf (" STR ", tmp , stack ) # stack = stack [: len ( stack )- 1 ] # length := 0 # if len ( stack ) == 0 { # length = i # } else { # length = i - 1 - stack [ len ( stack )- 1 ] # fmt . Printf (" STR ", length , stack , i ) # } # maxArea = max ( maxArea , heights [ tmp ]* length ) # fmt . Printf (" STR ", maxArea , heights [ tmp ]* length ) # i -- # } # } # return maxArea
b := make ([] byte , size ) # n , err := r . Read ( b ) # if err != nil { # return err # } # if int 6 4 ( n ) != size { # return errReadSizeMismatch # } # if h != nil { # h . Write ( b ) # } # return nil
count := make ( map [ rune ] int ) # for _ , c := range s { # count [ c ]++ # } # for i , c := range s { # if count [ c ] == 1 { # return i # } # } # return - 1
i , n := 0 , len ( nums ) # for i < n { # if nums [ i ] == val { # nums [ i ] = nums [ n - 1 ] # n -- # } else { # i ++ # } # } # return n
a := [] float 6 4 { 1 , 2 , 3 , 4 , 5 , 6 } # A := MakeMatrix ( a , 3 , 2 ) # # A . SetElm ( 0 , 0 , 1 0 ) # # if A . GetElm ( 0 , 0 ) != 1 0 { # t . Error () # }
if r . Right != nil { # dfs ( nums , r . Right ) # } # if r != nil { # * nums = append (* nums , r . Val ) # } # if r . Left != nil { # dfs ( nums , r . Left ) # } # return * nums
n , m := len ( candies ), make ( map [ int ] struct {}, len ( candies )) # for _ , candy := range candies { # m [ candy ] = struct {}{} # } # res := len ( m ) # if n / 2 < res { # return n / 2 # } # return res
if n < 3 { # return 0 # } # # isComposite := make ([] bool , n ) # count := n / 2 # # for i := 3 ; i * i < n ; i += 2 { # if isComposite [ i ] { # continue # } # # for j := i * i ; j < n ; j += 2 * i { # if ! isComposite [ j ] { # count -- # isComposite [ j ] = true # } # } # } # # return count
t . Parallel () # for _ , tc := range testcases { # if result := AlternatingCoinsFirst ( tc . coins ); result != tc . maxProfit { # t . Errorf (" STR ", tc . maxProfit , result ) # } # }
if start < 0 || end > len ( slice ) { # panic (" STR ") # } # return append ( slice [: start ], slice [ end :]...)
var queue * Queue = new ( Queue ) # # queue . depth = 0 # # return queue
res = [] string {} # if root == nil { # return res # } # dfs ( root , nil ) # return res
sort . Ints ( nums ) # var ret [][] int # for i := 0 ; i < len ( nums )- 3 ; i ++ { # if i > 0 && nums [ i - 1 ] == nums [ i ] { # continue # } # for j := i + 1 ; j < len ( nums )- 2 ; j ++ { # if j > i + 1 && nums [ j - 1 ] == nums [ j ] { # continue # } # left , right := j + 1 , len ( nums )- 1 # for left < right { # if left > j + 1 && nums [ left - 1 ] == nums [ left ] { # left ++ # continue # } # if nums [ i ]+ nums [ j ]+ nums [ left ]+ nums [ right ] == target { # ret = append ( ret , [] int { nums [ i ], nums [ j ], nums [ left ], nums [ right ]}) # left ++ # right -- # } else if nums [ i ]+ nums [ j ]+ nums [ left ]+ nums [ right ] < target { # left ++ # } else { # right -- # } # } # } # } # return ret
mod := 1 0 0 0 0 0 0 0 0 7 # n := len ( S ) # index := [ 2 6 ][ 2 ] int {} # for i := 0 ; i < 2 6 ; i ++ { # index [ i ][ 0 ], index [ i ][ 1 ] = - 1 , - 1 # } # res := 0 # for i := 0 ; i < n ; i ++ { # c := int ( S [ i ] - ' A ') # res += ( i - index [ c ][ 1 ]) * ( index [ c ][ 1 ] - index [ c ][ 0 ]) # index [ c ][ 0 ], index [ c ][ 1 ] = index [ c ][ 1 ], i # } # for i := 0 ; i < 2 6 ; i ++ { # res += ( n - index [ i ][ 1 ]) * ( index [ i ][ 1 ] - index [ i ][ 0 ]) # } # return res % mod
max , sum = 0 , 0 # dfs ( root , 0 ) # return sum
const MinInt = - int (^ uint ( 0 )>> 1 ) - 1 # result := MinInt # maxPathSum ( tree , & result ) # return result
h , m := - 1 , - 1 # res := " STR " # for _ , p := range permutations { # a , b , c , d := A [ p [ 0 ]], A [ p [ 1 ]], A [ p [ 2 ]], A [ p [ 3 ]] # ab , cd := a * 1 0 + b , c * 1 0 + d # if ab > 2 3 || # cd > 5 9 || # ab * 6 0 + cd <= h * 6 0 + m { # continue # } # h , m = ab , cd # res = fmt . Sprintf (" STR ", h , m ) # } # return res
return convert ( clean ( s ))
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 2 , 2 , 3 , 2 }, 3 }, # {" STR ", [] int { 0 , 1 , 0 , 1 , 0 , 1 , 9 9 }, 9 9 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := singleNumber ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
zero , two := 0 , len ( nums )- 1 # for one := 0 ; one <= two ; { # switch nums [ one ] { # case 0 : # nums [ one ], nums [ zero ] = nums [ zero ], nums [ one ] # zero ++ # one ++ # case 1 : # one ++ # case 2 : # nums [ one ], nums [ two ] = nums [ two ], nums [ one ] # two -- # } # }
minIndex := 0 # maxIndex := len ( array ) - 1 # for minIndex <= maxIndex && number >= array [ minIndex ] && number <= array [ maxIndex ] { # midIndex := minIndex + ( number - array [ minIndex ])*( maxIndex - minIndex )/( array [ maxIndex ]- array [ minIndex ]) # midItem := array [ midIndex ] # if midItem == number { # return midIndex # } else if midItem < number { # minIndex = midIndex + 1 # } else if midItem > number { # maxIndex = midIndex - 1 # } # } # return - 1
t . Parallel () # for _ , tc := range testcases { # if start , end := SmallestWindowThatMustBeSorted ( tc . nums ); start != tc . start || end != tc . end { # t . Errorf (" STR ", tc . start , tc . end , start , end ) # } # }
val := binary . BigEndian . Uint 3 2 ( self . data ) # self . data = self . data [ 4 :] # return val
return levels [ l ]
result , checker := 0 , [] int {} # checker = append ( checker , heights ...) # sort . Ints ( checker ) # for i := 0 ; i < len ( heights ); i ++ { # if heights [ i ] != checker [ i ] { # result ++ # } # } # return result
if n <= 2 { # return n # } # aux := make ([] int , n + 1 ) # aux [ 1 ] = 1 # aux [ 2 ] = 2 # for i := 3 ; i <= n ; i ++ { # aux [ i ] = aux [ i - 1 ] + aux [ i - 2 ] # } # return aux [ n ]
tests := [...] testType { # { # in : " STR ", # want : 5 , # }, # { # in : " STR ", # want : 0 , # }, # { # in : " STR ", # want : 0 , # }, # { # in : " STR ", # want : 1 , # }, # { # in : " STR ", # want : 2 , # }, # { # in : " STR ", # want : 4 , # }, # } # for _ , tt := range tests { # got := countSegments ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
for idx , val := range nums { # if idx == val { # continue # } # if nums [ val ] == val { # return val # } # nums [ val ], nums [ idx ] = nums [ idx ], nums [ val ] # } # return 0
var tests = [] struct { # l 1 , l 2 * ListNode # sum * ListNode # }{ # { newList ( 2 , 4 , 6 ), newList ( 5 , 6 , 4 ), newList ( 7 , 0 , 1 , 1 )}, # { newList ( 2 , 4 , 3 ), newList ( 5 , 6 , 4 ), newList ( 7 , 0 , 8 )}, # { newList ( 2 , 4 ), newList ( 5 , 6 , 4 ), newList ( 7 , 0 , 5 )}, # { newList ( 2 ), newList ( 5 , 6 , 4 ), newList ( 7 , 6 , 4 )}, # { newList ( 2 ), newList ( 5 , 6 ), newList ( 7 , 6 )}, # { newList ( 2 ), newList ( 5 ), newList ( 7 )}, # } # # for _ , tt := range tests { # sum := addTwoNumbers ( tt . l 1 , tt . l 2 ) # if reflect . DeepEqual ( sum , tt . sum ) == false { # t . Errorf (" STR ", tt . l 1 , tt . l 2 , sum , tt . sum ) # } # }
if t 1 == nil && t 2 == nil { # return nil # } # if t 1 == nil { # return t 2 # } # if t 2 == nil { # return t 1 # } # node := & TreeNode { Val : t 1 . Val + t 2 . Val } # node . Left = mergeTrees ( t 1 . Left , t 2 . Left ) # node . Right = mergeTrees ( t 1 . Right , t 2 . Right ) # return node
cases := [] struct { # name string # inputs * ListNode # inputs 1 int # expect * ListNode # }{ # {" STR ", # & ListNode { Val : 1 , Next : & ListNode { Val : 2 , Next : & ListNode { Val : 3 , Next : & ListNode { Val : 4 , Next : & ListNode { Val : 5 , Next : nil }}}}}, # 2 , # & ListNode { Val : 1 , Next : & ListNode { Val : 2 , Next : & ListNode { Val : 3 , Next : & ListNode { Val : 5 , Next : nil }}}}, # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := removeNthFromEnd ( c . inputs , c . inputs 1 ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
reg := regexp . MustCompile ( p ) # res := reg . FindAllString ( s , 1 ) # return len ( res ) == 1 && res [ 0 ] == s
ctx , cancel := context . WithTimeout ( context . Background (), 5 * time . Second ) # # counter := make ( chan int ) # defer cancel () # go generateValues ( ctx , counter ) # for n := range counter { # fmt . Println ( n ) # }
kthLarges := Constructor 1 ( 1 , [] int {}) # # fmt . Println ( kthLarges . Add (- 3 )) # fmt . Println ( kthLarges . Add (- 2 )) # fmt . Println ( kthLarges . Add (- 4 )) # fmt . Println ( kthLarges . Add ( 0 )) # fmt . Println ( kthLarges . Add ( 4 ))
qs := [] question 1 0 4 0 { # { # para 1 0 4 0 {[] int { 7 , 4 , 9 }}, # ans 1 0 4 0 {[] int { 1 , 2 }}, # }, # # { # para 1 0 4 0 {[] int { 6 , 5 , 4 , 3 , 1 0 }}, # ans 1 0 4 0 {[] int { 2 , 3 }}, # }, # # { # para 1 0 4 0 {[] int { 1 0 0 , 1 0 1 , 1 0 4 , 1 0 2 , 1 0 3 }}, # ans 1 0 4 0 {[] int { 0 , 0 }}, # }, # # { # para 1 0 4 0 {[] int { 1 , 3 , 5 , 7 , 1 0 }}, # ans 1 0 4 0 {[] int { 2 , 4 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 4 0 , q . para 1 0 4 0 # fmt . Printf (" STR ", p , numMovesStonesII ( p . one )) # } # fmt . Printf (" STR ")
var tests = [] struct { # nums [] int # peak int # }{ # {[] int { 1 }, 0 }, # {[] int { 1 , 2 , 3 , 1 }, 2 }, # {[] int { 1 , 2 , 3 , 4 }, 3 }, # {[] int { 1 , 2 , 1 , 3 , 5 , 6 , 4 }, 5 }, # } # # for _ , tt := range tests { # peak := findPeakElement ( tt . nums ) # if peak != tt . peak { # t . Errorf (" STR ", tt . nums , peak , tt . peak ) # } # }
if n == 1 { # return false # } # if ( n == 2 || n == 3 ){ # return true # } # for i := 2 ; i <= int ( math . Sqrt ( float 6 4 ( n ))); i ++{ # if n % i == 0 { # return false # } # } # return true
s := strings . TrimSpace ( str ) # if len ( s ) == 0 { # return 0 # } # # sign , x := getSign ( s ) # # x = trim ( x ) # # return convert ( sign , x )
if root == nil { # return nil # } # if key < root . Val { # root . Left = deleteNode ( root . Left , key ) # } else if root . Val < key { # root . Right = deleteNode ( root . Right , key ) # } else { # if root . Left == nil { # return root . Right # } # if root . Right == nil { # return root . Left # } # min := root . Right # for min . Left != nil { # min = min . Left # } # min . Left = root . Left # root = root . Right # } # return root
for i := n + m - 1 ; i >= n ; i -- { # nums 1 [ i ] = nums 1 [ i - n ] # } # # var ( # i = n # j = 0 # k = 0 # ) # # for k < n + m { # if i >= n + m { # nums 1 [ k ] = nums 2 [ j ] # k ++ # j ++ # } else if j >= n { # break # } else if nums 1 [ i ] < nums 2 [ j ] { # nums 1 [ k ] = nums 1 [ i ] # i ++ # k ++ # } else { # nums 1 [ k ] = nums 2 [ j ] # k ++ # j ++ # } # }
err := read ( r , hSize , h ) # if err != nil { # return err # } # return read ( r , hSize , h )
return & node { # key : key , # value : value , # }
if m . keyL . Len () == 0 { # return nil # } # return m . keyL . Back (). Value
v := reflect . ValueOf ( x ) # t := v . Type () # fmt . Printf (" STR ", t ) # # for i := 0 ; i < v . NumMethod (); i ++ { # methType := v . Method ( i ). Type () # fmt . Printf (" STR ", t , t . Method ( i ). Name , # strings . TrimPrefix ( methType . String (), " STR ")) # }
listener , err := net . Listen (" STR ", " STR ") # if err != nil { # log . Fatal ( err ) # } # for { # conn , err := listener . Accept () # if err != nil { # log . Print ( err ) # continue # } # handleConn ( conn ) # }
head := & ListNode {} # tmp := head # # for l 1 != nil && l 2 != nil { # if l 1 . Val < l 2 . Val { # tmp . Next = l 1 # l 1 = l 1 . Next # } else { # tmp . Next = l 2 # l 2 = l 2 . Next # } # tmp = tmp . Next # } # if l 1 != nil { # tmp . Next = l 1 # } else { # tmp . Next = l 2 # } # # return head . Next
coins := [] int { 1 , 2 , 5 , 1 0 , 2 0 , 5 0 , 1 0 0 , 2 0 0 } # ways := make ([] int , n + 1 ) # ways [ 0 ] = 1 # for i := range coins { # for j := coins [ i ]; j <= n ; j ++ { # ways [ j ] = ways [ j ] + ways [ j - coins [ i ]] # } # } # return ways [ n ]
mod := 1 0 0 0 0 0 0 0 0 7 # end := [ 2 6 ] int {} # res := 0 # for i := 0 ; i < len ( S ); i ++ { # c := S [ i ] - ' a ' # tmp := ( res + 1 - end [ c ]) % mod # res = ( res + tmp ) % mod # end [ c ] = ( end [ c ] + tmp ) % mod # } # return ( res + mod ) % mod
if size == len ( board ) { # return 1 # } # var count int # for i := 0 ; i < size ; i ++ { # board = append ( board , i ) # if isValid ( board ) { # count += NQueens ( size , board ) # } # board = board [: len ( board )- 1 ] # } # return count
(* h )[ i .( int )], (* h )[ j .( int )] = (* h )[ j .( int )], (* h )[ i .( int )]
if n == 0 { # return len ( tasks ) # } # # rec := [ 2 6 ] int {} # for _ , c := range tasks { # rec [ c -' A ']++ # } # # most := 0 # for _ , num := range rec { # if most < num { # most = num # } # } # # idles := ( most - 1 ) * ( n + 1 ) # # for _ , num := range rec { # idles -= min ( most - 1 , num ) # } # # return len ( tasks ) + max ( 0 , idles )
qs := [] question 9 7 5 { # # { # para 9 7 5 {[] int { 1 0 , 1 3 , 1 2 , 1 4 , 1 5 }}, # ans 9 7 5 { 2 }, # }, # # { # para 9 7 5 {[] int { 2 , 3 , 1 , 1 , 4 }}, # ans 9 7 5 { 3 }, # }, # # { # para 9 7 5 {[] int { 5 , 1 , 3 , 4 , 2 }}, # ans 9 7 5 { 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 7 5 , q . para 9 7 5 # fmt . Printf (" STR ", p , oddEvenJumps ( p . A )) # } # fmt . Printf (" STR ")
n := len ( nums ) # sort . Ints ( nums ) # # res := 0 # for i := n - 1 ; i >= 2 ; i -- { # for j , k := 0 , i - 1 ; j < k ; { # if nums [ j ]+ nums [ k ] > nums [ i ] { # res += k - j # k -- # } else { # j ++ # } # } # } # return res
ans , b , x := 0 , 1 , 0 # for b <= n { # x = n / b # ans += ( x + 8 ) / 1 0 * b # if x % 1 0 == 1 { # ans += n % b + 1 # } # b *= 1 0 # } # return ans
n := len ( exp ) # # bytes := make ([] byte , 1 , n * 2 ) # bytes [ 0 ] = exp [ 0 ] # pre := exp [ 0 ] # for i := 1 ; i < n ; i ++ { # cur := exp [ i ] # if ( isLetter ( pre ) && cur == '{') || # ( pre == '}' && cur == '{') || # ( pre == '}' && isLetter ( cur )) { # bytes = append ( bytes , '*') # } # if cur == ',' { # bytes = append ( bytes , '+') # } else { # bytes = append ( bytes , cur ) # } # pre = cur # } # exp = string ( bytes ) # # return unique ( doAdd ( exp ))
i , j , ss := 0 , len ( s )- 1 , [] byte ( s ) # for i < j { # if ! isVowel ( ss [ i ]) { # i ++ # } else if ! isVowel ( ss [ j ]) { # j -- # } else { # ss [ i ], ss [ j ] = ss [ j ], ss [ i ] # i ++ # j -- # } # } # return string ( ss )
fmt . Println ( buddyStrings (" STR ", " STR ")) # fmt . Println ( buddyStrings (" STR ", " STR ")) # fmt . Println ( buddyStrings (" STR ", " STR ")) # fmt . Println ( buddyStrings (" STR ", " STR ")) # fmt . Println ( buddyStrings (" STR ", " STR "))
m , res := make ([] int , len ( nums )), make ([] int , 2 ) # for _ , n := range nums { # if m [ n - 1 ] == 0 { # m [ n - 1 ] = 1 # } else { # res [ 0 ] = n # } # } # for i := range m { # if m [ i ] == 0 { # res [ 1 ] = i + 1 # break # } # } # return res
if len ( nums ) == 0 { # return 0 # } # dp , ans := make ([] int , len ( nums )), 1 # # for i := 0 ; i < len ( nums ); i ++ { # dp [ i ] = 1 # } # # for i := 1 ; i < len ( nums ); i ++ { # for j := 0 ; j < i ; j ++ { # if nums [ i ] > nums [ j ] { # dp [ i ] = max ( dp [ i ], dp [ j ]+ 1 ) # } # } # ans = max ( dp [ i ], ans ) # } # return ans
var elemBiggerMap = map [ int ] int {} # for i := 0 ; i < len ( nums ); i ++ { # biggerIdx := - 1 # for j := i + 1 ; j < len ( nums ); j ++ { # if nums [ j ] > nums [ i ] { # biggerIdx = nums [ j ] # break # } # } # elemBiggerMap [ nums [ i ]] = biggerIdx # } # var res [] int # for i := 0 ; i < len ( findNums ); i ++ { # res = append ( res , elemBiggerMap [ findNums [ i ]]) # } # return res
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", [][] int {{ 1 , 2 }, { 2 , 1 }, { 3 , 4 }, { 5 , 6 }, { 2 , 1 }, { 5 , 6 }, { 6 , 5 }}, 6 }, # {" STR ", [][] int {{ 1 , 2 }}, 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
return int ( math . Max ( float 6 4 ( a ), float 6 4 ( b )))
count , res := make ([] int , 2 6 ), 0 # for i := 0 ; i < len ( chars ); i ++ { # count [ chars [ i ]-' a ']++ # } # for _ , w := range words { # if canBeFormed ( w , count ) { # res += len ( w ) # } # } # return res
var diameter int # # var f func (* TreeNode ) int # f = func ( root * TreeNode ) int { # if root == nil { # return 0 # } # # dl := f ( root . Left ) # dr := f ( root . Right ) # if dl + dr > diameter { # diameter = dl + dr # } # # depth := dl # if dr > depth { # depth = dr # } # return depth + 1 # } # f ( root ) # # return diameter
for N = ( N - 1 )% 1 4 + 1 ; N > 0 ; N -- { # tmp := make ([] int , 8 ) # for i := 1 ; i < 7 ; i ++ { # if cells [ i - 1 ] == cells [ i + 1 ] { # tmp [ i ] = 1 # } # } # cells = tmp # } # return cells
sum := 0 # for i := 0 ; i < 1 0 0 0 ; i ++ { # sum += lengthNumber ( i ) # } # return sum + len (" STR ")
if len ( matrix ) == 0 { # return false # } # m , low , high := len ( matrix [ 0 ]), 0 , len ( matrix [ 0 ])* len ( matrix )- 1 # for low <= high { # mid := low + ( high - low )>> 1 # if matrix [ mid / m ][ mid % m ] == target { # return true # } else if matrix [ mid / m ][ mid % m ] > target { # high = mid - 1 # } else { # low = mid + 1 # } # } # return false
dp := make ([] bool , len ( s )+ 1 ) # dp [ 0 ] = true # # for i := 0 ; i < len ( dp ); i ++ { # if dp [ i ] { # for _ , word := range wordDict { # if i + len ( word ) <= len ( s ) && s [ i : i + len ( word )] == word { # dp [ i + len ( word )] = true # } # } # } # } # return dp [ len ( s )]
sort . Ints ( A ) # # n := len ( A ) # mx , mn := A [ n - 1 ], A [ 0 ] # res := mx - mn # # for i := 0 ; i + 1 < n ; i ++ { # mx = max ( mx , A [ i ]+ 2 * k ) # mn = min ( A [ i + 1 ], A [ 0 ]+ 2 * k ) # res = min ( res , mx - mn ) # } # # return res
b . lock . Lock () # defer b . lock . Unlock () # # e := b . table [ key ] # if e == nil { # return nil , false # } # # value := e . value # b . removeEntry ( e ) # return value , true
m := make ( map [ int ] bool ) # m [ 3 ] = false # m [ 4 ] = true # m [ 5 ] = false # # if v , ok := m [ version ]; ok { # return v # } # # return false
qs := [] question 1 1 { # # { # para 1 1 {[] int { 1 , 8 , 6 , 2 , 5 , 4 , 8 , 3 , 7 }}, # ans 1 1 { 4 9 }, # }, # # { # para 1 1 {[] int { 1 , 1 }}, # ans 1 1 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 1 , q . para 1 1 # fmt . Printf (" STR ", p . one , maxArea ( p . one )) # } # fmt . Printf (" STR ")
if ( queue . depth > 0 ) { # item := queue . current . item # queue . current = queue . current . prev # queue . depth -- # # return item # } # # return nil
return string ( h [:])
if id != p . ID { # return ErrInconsistentIDs # } # s . mtx . Lock () # defer s . mtx . Unlock () # s . m [ id ] = p # return nil
problems := GetProblemsInstance () # problem_string , err := json . MarshalIndent ( problems , " STR ", " STR ") # if err != nil { # log . Fatalln (" STR ", err . Error ()) # } # # return string ( problem_string )
var i , n int # for i = 0 ; n < K ; i ++ { # if S [ i ] <= ' 9 ' { # n *= int ( S [ i ] - ' 0 ') # } else { # n ++ # } # } # for { # i -- # if S [ i ] <= ' 9 ' { # n /= int ( S [ i ] - ' 0 ') # K %= n # } else { # if K == 0 || K == n { # return string ( S [ i ]) # } # n -- # } # }
l . start = l . pos
cmap := newChainedHashMap () # testHashMapResize ( t , cmap ) # if ! reflect . DeepEqual ( cmap . Cap , uint 3 2 ( 1 6 )) { # t . Log ( fmt . Sprintf (" STR ", uint 3 2 ( 1 6 )) + fmt . Sprintf (" STR ", cmap . Cap )) # t . Fail () # }
t . Parallel () # # for _ , tc := range testcases { # if result := ValidSentences ( tc . text ); ! reflect . DeepEqual ( result , tc . sentences ) { # t . Errorf (" STR ", tc . sentences , result ) # } # }
if n <= 0 { # return 0 # } # x := math . Sqrt ( 2 * float 6 4 ( n )+ 0 . 2 5 ) - 0 . 5 # return int ( x )
var tests = [] struct { # array [] int # min int # }{ # {[] int { 1 , 2 , 3 , 4 , 5 }, 1 }, # {[] int { 2 , 3 , 4 , 5 , 1 }, 1 }, # {[] int { 3 , 4 , 5 , 1 , 2 }, 1 }, # {[] int { 4 , 5 , 1 , 2 , 3 }, 1 }, # {[] int { 5 , 1 , 2 , 3 , 4 }, 1 }, # {[] int { 4 , 5 , 6 , 7 , 0 , 1 , 2 }, 0 }, # } # # for _ , tt := range tests { # min := findMin ( tt . array ) # if min != tt . min { # t . Errorf (" STR ", tt . array , min , tt . min ) # } # }
type A struct { # Name string # D string # } # a := A { Name : " STR "} # # type B struct { # A # C int # } # b := & B { C : 1 2 3 } # b . A = a # # ok := IsZero ( b ) # if ok { # t . Error (" STR ") # } # # aZero := A {} # bZero := & B {} # bZero . A = aZero # # ok = IsZero ( bZero ) # if ! ok { # t . Error (" STR ") # }
t . Parallel () # for _ , tc := range testcases { # if result := LengthLongestConsecutiveRunOnesBitShift ( tc . n ); result != tc . longestConsecutiveOnes { # t . Errorf (" STR ", tc . n , tc . longestConsecutiveOnes , result ) # } # }
var tr float 6 4 = 0 # for i := 0 ; i < A . cols ; i ++ { # tr += A . GetElm ( i , i ) # } # return tr
sum := 0 # for i := 1 ; i <= n ; i ++ { # sum += i # } # return sum
if sum == target { # ret = append ( ret , now ) # fmt . Println ( now ) # } # if sum > target { # return # } # for i := idx + 1 ; i < len ( c ); i ++{ # if i > idx + 1 && c [ i ] == c [ i - 1 ]{ # continue # } # if c [ i ] > target { # break # } # now = append ( now , c [ i ]) # help ( ret , c , now , sum + c [ i ], target , i ) # now = now [: len ( now )- 1 ] # } #
var i int 6 4 = 2 # for ; i < x ; i ++ { # if x % i == 0 { return false } # } # return true
return ( r . Get () & value ) > 0
return 1 + ( num - 1 )% 9
for _ , tc := range testcases { # if result , err := SolveArithmeticEquations ( tc . equations ); ! reflect . DeepEqual ( result , tc . expected ) || # err != tc . expectedErr { # t . Errorf (" STR ", tc . expected , tc . expectedErr , result , err ) # } # }
pos , find := [] position {}, false # for i := 0 ; i < len ( board ); i ++ { # for j := 0 ; j < len ( board [ 0 ]); j ++ { # if board [ i ][ j ] == '.' { # pos = append ( pos , position { x : i , y : j }) # } # } # } # putSudoku (& board , pos , 0 , & find )
return ( offset + alignment - 1 ) &^ ( alignment - 1 )
if len ( p . pendingBytes ) > 0 { # p . queue <- queueItem { bs : p . pendingBytes } # p . pendingBytes = nil # }
for i := 0 ; i < len ( arr ); i ++ { # if arr [ i ] == 0 && i + 1 < len ( arr ) { # arr = append ( arr [: i + 1 ], arr [ i : len ( arr )- 1 ]...) # i ++ # } # }
sum , a , b , c := 0 , 1 , 1 , 2 # for c < n { # sum += c # a = b + c # b = c + a # c = a + b # } # return sum
node 2 1 := TreeNode { Val : 2 , Left : nil , Right : nil } # node 2 := TreeNode { Val : 2 , Left : & node 2 1 , Right : nil } # node 1 := TreeNode { Val : 1 , Left : nil , Right : & node 2 } # # fmt . Println ( findMode (& node 1 ))
if len ( str ) == 0 { # return nil # } # palindrome := make ([][] bool , len ( str )) # for i := range palindrome { # palindrome [ i ] = make ([] bool , len ( str )) # palindrome [ i ][ i ] = true # } # for l := 2 ; l <= len ( str ); l ++ { # for i := 0 ; i < len ( str )- l + 1 ; i ++ { # j := i + l - 1 # if l == 2 { # palindrome [ i ][ j ] = str [ i ] == str [ j ] # } else { # palindrome [ i ][ j ] = ( str [ i ] == str [ j ]) && palindrome [ i + 1 ][ j - 1 ] # } # } # } # cuts := findCutsBFS ( str , palindrome ) # result := make ([] string , 0 , len ( cuts )) # prev := 0 # for _ , cut := range cuts { # result = append ( result , str [ prev : cut ]) # prev = cut # } # return result
var result [] int # for i := 0 ; i < Height ( tree ); i ++ { # result = append ( result , GetLevel ( tree , i )...) # } # return result
result := 0 # d := - 1 # if b < 0 { # d = 1 # } # for ; b != 0 ; b += d { # result += d # } # return result
tests := [...] testType { # { # in : [] int { 1 , 0 , 0 }, # want : true , # }, # { # in : [] int { 1 , 1 , 1 , 0 }, # want : false , # }, # } # for _ , tt := range tests { # got := isOneBitCharacter ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
fmt . Println (" STR ", os . Stdin . Name ()) # fmt . Println (" STR ", os . Stdout . Name ()) # fmt . Println (" STR ", os . Stderr . Name ()) # # syscall . Getuid () # syscall . Geteuid () # syscall . Getgid () # syscall . Getegid () # syscall . Getpid () # syscall . Getppid () # # fmt . Println (" STR ", rand . Int 3 1 ()) # # fmt . Println (" STR ", strings . IndexByte (" STR ", " STR ")) # fmt . Println (" STR ", strings . Replace (" STR ", " STR ", " STR ", - 1 )) # # os . Exit ( 0 )
for head != nil { # # # head = head . Next # } # return false
if nil == ops || len ( ops ) == 0 { # return m * n # } # # row , col := ops [ 0 ][ 0 ], ops [ 0 ][ 1 ] # for _ , v := range ops { # row = myMin ( row , v [ 0 ]) # col = myMin ( col , v [ 1 ]) # } # return row * col
l := len ( a ) # left , right := make ([] int , l ), make ([] int , l ) # # left [ 0 ], right [ l - 1 ] = 1 , 1 # left [ 1 ], right [ l - 2 ] = a [ 0 ], a [ l - 1 ] # # for i := 2 ; i < l ; i ++ { # left [ i ] = a [ i - 1 ] * left [ i - 1 ] # right [ l - i - 1 ] = a [ l - i ] * right [ l - i ] # } # # res := make ([] int , l ) # for i := 0 ; i < l ; i ++ { # res [ i ] = left [ i ] * right [ i ] # } # # return res
memo := make ([][] int , m ) # for i := 0 ; i < m ; i ++ { # memo [ i ] = append ( memo [ i ], 1 ) # } # # for i := 1 ; i < n ; i ++ { # memo [ 0 ] = append ( memo [ 0 ], 1 ) # } # # for i := 1 ; i < m ; i ++ { # for j := 1 ; j < n ; j ++ { # memo [ i ] = append ( memo [ i ], memo [ i - 1 ][ j ]+ memo [ i ][ j - 1 ]) # } # } # return memo [ m - 1 ][ n - 1 ]
n := len ( nums ) # # for i , v := range nums { # for j := i + 1 ; j < n ; j ++ { # if v + nums [ j ] == target { # return [] int { i , j } # } # } # } # # return nil
arr := make ([] bool , 1 0 0 0 0 ) # prime := 2 # finished := false # var i int # for ! finished { # for i = 2 * prime ; i < 1 0 0 0 0 ; i += prime { # arr [ i ] = true # } # for i = prime + 1 ; i < 1 0 0 0 0 && arr [ i ]; i ++ { # } # if i < 1 0 0 0 0 { # prime = i # } else { # finished = true # } # } # outer : # for i := 1 0 0 0 ; i < len ( arr ); i ++ { # for j := i + 1 ; j < len ( arr ); j ++ { # if i != 1 4 8 7 && ! arr [ i ] && ! arr [ j ] && isPerm ( i , j ) && 2 * j - i < 1 0 0 0 0 && ! arr [ 2 * j - i ] && isPerm ( i , 2 * j - i ) { # print ( i ) # print ( j ) # print ( 2 * j - i ) # break outer # } # } # } # println ()
if len ( edges ) == 0 { # return [] int {} # } # parent , candidate 1 , candidate 2 := make ([] int , len ( edges )+ 1 ), [] int {}, [] int {} # for _ , edge := range edges { # if parent [ edge [ 1 ]] == 0 { # parent [ edge [ 1 ]] = edge [ 0 ] # } else { # candidate 1 = append ( candidate 1 , parent [ edge [ 1 ]]) # candidate 1 = append ( candidate 1 , edge [ 1 ]) # candidate 2 = append ( candidate 2 , edge [ 0 ]) # candidate 2 = append ( candidate 2 , edge [ 1 ]) # edge [ 1 ] = 0 # } # } # for i := 1 ; i <= len ( edges ); i ++ { # parent [ i ] = i # } # for _ , edge := range edges { # if edge [ 1 ] == 0 { # continue # } # u , v := edge [ 0 ], edge [ 1 ] # pu := findRoot (& parent , u ) # if pu == v { # if len ( candidate 1 ) == 0 { # return edge # } # return candidate 1 # } # parent [ v ] = pu # } # return candidate 2
return len ( queue . array ) == 0
return this . Sum [ j + 1 ] - this . Sum [ i ]
if n <= 1 { # return false # } # lim := int ( math . Sqrt ( float 6 4 ( n ))) + 1 # for i := 2 ; i < lim ; i ++ { # if n % i == 0 { # return false # } # } # # return true
numToCount := make ( map [ int ] int ) # for _ , num := range nums { # count := numToCount [ num ] # numToCount [ num ] = count + 1 # } # # pairs := 0 # for num , count := range numToCount { # if ( k == 0 && count > 1 ) || ( k > 0 && numToCount [ num - k ] > 0 ) { # pairs ++ # } # } # # return pairs
tests := [...] testType { # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := longestPalindrome ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
type A struct { # Name string # D string # } # a := A { Name : " STR "} # # type B struct { # A # C int # } # b := & B { C : 1 2 3 } # b . A = a # # ok := HasZero ( b ) # if ! ok { # t . Error (" STR ") # }
qs := [] question 3 0 6 { # # { # para 3 0 6 {" STR "}, # ans 3 0 6 { true }, # }, # # { # para 3 0 6 {" STR "}, # ans 3 0 6 { true }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 0 6 , q . para 3 0 6 # fmt . Printf (" STR ", p , isAdditiveNumber ( p . one )) # } # fmt . Printf (" STR ")
tests := [...] testType { # { # left : 1 , # right : 2 2 , # want : [] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 1 , 1 2 , 1 5 , 2 2 }, # }, # } # for _ , tt := range tests { # got := selfDividingNumbers ( tt . left , tt . right ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . left , tt . right , got , tt . want ) # } # }
stack := make ([] int , 0 ) # for i , num := range A { # if len ( stack ) == 0 || A [ stack [ len ( stack )- 1 ]] > num { # stack = append ( stack , i ) # } # } # # max := 0 # for i := len ( A ) - 1 ; i >= 0 ; i -- { # for len ( stack ) > 0 && A [ stack [ len ( stack )- 1 ]] <= A [ i ] { # index := stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # if max < i - index { # max = i - index # } # } # } # # return max
fileContent , _ := ioutil . ReadFile ( filename ) # content := string ( bytes . Replace ( fileContent , [] byte (`"`), [] byte (``), - 1 )) # list := strings . Split ( content , " STR ") # sort . Sort ( sort . StringSlice ( list )) # return list
t . Parallel () # result := Car ( Cons ( 3 , 4 )) # if result != 3 { # t . Errorf (" STR ", result ) # }
for v := range in { # fmt . Println ( v ) # }
if nil == nums || len ( nums ) == 0 || k < 0 { # return 0 # } # # dict := make ( map [ int ] int , 0 ) # for _ , v := range nums { # dict [ v ]++ # } # # ans := 0 # for key , value := range dict { # if 0 == k { # if value >= 2 { # ans ++ # } # } else { # if _ , ok := dict [ key + k ]; ok { # ans ++ # } # } # } # return ans
if i > 1 && j > 1 && ldc . seq 0 [ i ] == ldc . seq 1 [ j - 1 ] && ldc . seq 0 [ i - 1 ] == ldc . seq 1 [ j ] { # return ldc . cost [ i - 2 ][ j - 2 ] + t . cost # } # return math . MaxInt 3 2
var res [] int # var max * TreeNode # for root != nil { # if root . Left == nil { # res = append ( res , root . Val ) # root = root . Right # } else { # max = root . Left # for max . Right != nil && max . Right != root . Right { # max = max . Right # } # # if max . Right == nil { # res = append ( res , root . Val ) # max . Right = root . Right # root = root . Left # } else { # root = root . Right # max . Right = nil # } # } # } # return res
if len ( nums ) == 0 { # return - 1 # } # low , high := 0 , len ( nums )- 1 # for low <= high { # mid := low + ( high - low )>> 1 # if nums [ mid ] == target { # return mid # } else if nums [ mid ] > nums [ low ] { # if nums [ low ] <= target && target < nums [ mid ] { # high = mid - 1 # } else { # low = mid + 1 # } # } else if nums [ mid ] < nums [ high ] { # if nums [ mid ] < target && target <= nums [ high ] { # low = mid + 1 # } else { # high = mid - 1 # } # } else { # if nums [ low ] == nums [ mid ] { # low ++ # } # if nums [ high ] == nums [ mid ] { # high -- # } # } # } # return - 1
res := [] int { 1 } # tmp := [] int {} # for len ( res ) < N { # for _ , i := range res { # if i * 2 - 1 <= N { # tmp = append ( tmp , i * 2 - 1 ) # } # } # for _ , i := range res { # if i * 2 <= N { # tmp = append ( tmp , i * 2 ) # } # } # res , tmp = tmp , res # tmp = tmp [: 0 ] # } # return res
var tests = [] struct { # A [][] int # T [][] int # }{ # { # [][] int { # { 1 , 2 , 3 }, # { 4 , 5 , 6 }, # }, # [][] int { # { 1 , 4 }, # { 2 , 5 }, # { 3 , 6 }, # }, # }, # { # [][] int { # { 1 , 2 , 3 }, # { 4 , 5 , 6 }, # { 7 , 8 , 9 }, # }, # [][] int { # { 1 , 4 , 7 }, # { 2 , 5 , 8 }, # { 3 , 6 , 9 }, # }, # }, # } # # for _ , tt := range tests { # T := transpose ( tt . A ) # if reflect . DeepEqual ( T , tt . T ) == false { # t . Errorf (" STR ", tt . A , T , tt . T ) # } # }
num := 0 # # for i := 1 ; i < 1 0 0 0 0 0 0 0 ; i ++ { # chainTermination := doChain ( i ) # if chainTermination == 8 9 { # num ++ # } # } # # println ( num )
if power < 0 && math . Floor ( float 6 4 ( power )) == float 6 4 ( power ) { # return uint 3 2 ( math . NaN ()), errors . New (" STR ") # } # # a := uint 3 2 ( 1 ) # for i := 0 ; i < power ; i ++ { # a *= n # } # return a , nil
if list . head == nil { # return false # } # if list . head . data == i { # list . head = list . head . next # list . head . prev = nil # return true # } # if list . tail . data == i { # list . tail = list . tail . prev # list . tail . next = nil # return true # } # current := list . head # for current . next != nil { # if current . next . data == i { # if current . next . next != nil { # current . next . next . prev = current # } # current . next = current . next . next # return true # } # current = current . next # } # return false
if N <= 4 { # return answers [ N ] # } # a := N *( N - 1 )/( N - 2 ) + ( N - 3 ) # b := ( N - 4 ) * max ( 1 , ( N - 5 )) / max ( 1 , ( N - 6 )) # return a - 2 * b + clumsy ( N - 4 )
var length int # for p := head ; p != nil ; p = p . Next { # length ++ # } # # var f func ( int ) * TreeNode # f = func ( n int ) * TreeNode { # if n == 0 { # return nil # } # n -- # mid := n / 2 # # node := new ( TreeNode ) # # node . Left = f ( n - mid ) # node . Val = head . Val # head = head . Next # node . Right = f ( mid ) # # return node # } # return f ( length )
res := 1 # k -- # for k > 0 { # count := 0 # start , end := res , res + 1 # for start <= n { # count += min ( n + 1 , end ) - start # start *= 1 0 # end *= 1 0 # } # if count <= k { # k -= count # res ++ # } else { # k -- # res *= 1 0 # } # } # return res
swapped , _ := strconv . Atoi ( bubbleSort ( strconv . Itoa ( input ))) # return swapped #
qs := [] question 7 8 { # # { # para 7 8 {[] int {}}, # ans 7 8 {[][] int {{}}}, # }, # # { # para 7 8 {[] int { 1 , 2 , 3 }}, # ans 7 8 {[][] int {{}, { 1 }, { 2 }, { 3 }, { 1 , 2 }, { 2 , 3 }, { 1 , 3 }, { 1 , 2 , 3 }}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 8 , q . para 7 8 # fmt . Printf (" STR ", p , subsets ( p . one )) # } # fmt . Printf (" STR ")
tests := [...] testType { # { # in : [][] int { # { 4 , 3 , 8 , 4 }, # { 9 , 5 , 1 , 9 }, # { 2 , 7 , 6 , 2 }, # }, # want : 1 , # }, # { # in : [][] int { # { 5 , 5 , 5 }, # { 5 , 5 , 5 }, # { 5 , 5 , 5 }, # }, # want : 0 , # }, # { # in : [][] int { # { 1 , 8 , 6 }, # { 1 0 , 5 , 0 }, # { 4 , 2 , 9 }, # }, # want : 0 , # }, # } # for _ , tt := range tests { # got := numMagicSquaresInside ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
hs := [] int { 8 , 4 , 2 , 1 } # ms := [] int { 3 2 , 1 6 , 8 , 4 , 2 , 1 } # res := [] string {} # for i := 0 ; i <= 4 && i <= num ; i ++ { # if num - i > 6 { # continue # } # l 1 , l 2 := gen ( hs , i ), gen ( ms , num - i ) # for _ , h := range l 1 { # if h >= 1 2 { # continue # } # for _ , m := range l 2 { # if m >= 6 0 { # continue # } # res = append ( res , fmt . Sprintf (" STR ", h , m )) # } # } # } # return res
t . Parallel () # for _ , tc := range testcases { # if result := FewestBricksCut ( tc . bricks ); result != tc . fewest { # t . Errorf (" STR ", tc . fewest , result ) # } # }
if h . GetAlpha () <= 0 . 1 2 5 { # if h . Count == 0 { # h . hashMap . Init ( 0 ) # return # } # if h . Cap > defalutcap { # h . Move ( h . Cap >> 1 ) # } # }
s . lock . Lock () # defer s . lock . Unlock () # # return s . len == 0
res := " STR " # # for n > 0 { # n -- # res = string ( byte ( n % 2 6 )+' A ') + res # n /= 2 6 # } # # return res
b := createFilledBucket ( time . Time {}) # # cpu := runtime . GOMAXPROCS ( 0 ) # ch := make ( chan bool ) # worker := func () { # for i := 0 ; i < bb . N / cpu ; i ++ { # b . Set ( randomString ( 2 ), " STR ", time . Time {}) # } # ch <- true # } # for i := 0 ; i < cpu ; i ++ { # go worker () # } # for i := 0 ; i < cpu ; i ++ { # _ = <- ch # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 7 , 3 , 6 , 5 , 6 }, 3 }, # {" STR ", [] int { 1 , 2 , 3 }, - 1 }, # {" STR ", [] int {}, - 1 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
tests := [...] testType { # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := sortString ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
qs := [] question 3 9 2 { # # { # para 3 9 2 {" STR ", " STR "}, # ans 3 9 2 { true }, # }, # # { # para 3 9 2 {" STR ", " STR "}, # ans 3 9 2 { false }, # }, # # { # para 3 9 2 {" STR ", " STR "}, # ans 3 9 2 { false }, # }, # # { # para 3 9 2 {" STR ", " STR "}, # ans 3 9 2 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 9 2 , q . para 3 9 2 # fmt . Printf (" STR ", p , isSubsequence ( p . one , p . two )) # } # fmt . Printf (" STR ")
p := [ 1 0 0 1 ] int {} # a , b := 1 , 1 # for perimeter ( a , a ) <= 1 0 0 0 . { # for perimeter ( a , b ) <= 1 0 0 0 . { # if math . Mod ( perimeter ( a , b ), 1 .) == 0 . { # fmt . Printf (" STR ", a , b , int ( math . Sqrt ( float 6 4 ( a * a + b * b ))), int ( perimeter ( a , b ))) # p [ int ( perimeter ( a , b ))]++ # } # b ++ # } # a ++ # b = a # } # # var max , maxPosition int # for i := 0 ; i < len ( p ); i ++ { # if p [ i ] > max { # max = p [ i ] # maxPosition = i # } # } # fmt . Println ( maxPosition )
request , err := http . Get ( GITHUB_CONTRIBUTOR_API_URL ) # # if err != nil { # log . Panicln (" STR ", err ) # } # # if request . StatusCode != 2 0 0 { # log . Panicln (" STR ", err ) # } # # body , _ := ioutil . ReadAll ( request . Body ) # return body
fmt . Println ( hasGroupsSizeX ([] int { 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 })) # fmt . Println ( hasGroupsSizeX ([] int { 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 2 , 2 })) #
if maxItems <= 0 { # return nil # } # switch strategy { # case LimitStrategyReject , LimitStrategyCycle : # default : # return nil # } # # q := new ( LimitQueue ) # q . list = list . New () # q . maxItems = maxItems # q . strategy = strategy # q . cond = sync . NewCond (& q . mutex ) # # return q
return MapSum { # m : map [ string ] int {}, # keys : [] string {}, # }
sort . Strings ( words ) # m := make ( map [ string ] bool , len ( words )) # # res := words [ 0 ] # # for _ , w := range words { # n := len ( w ) # if n == 1 { # m [ w ] = true # } else if m [ w [: n - 1 ]] { # m [ w ] = true # if len ( res ) < len ( w ) { # res = w # } # } # } # # return res
m , n := len ( A ), len ( A [ 0 ]) # # toggleRow := func ( i int ) { # for j := 0 ; j < n ; j ++ { # A [ i ][ j ] ^= 1 # } # } # # countCol := func ( j int ) int { # c := 0 # for i := 0 ; i < m ; i ++ { # c += A [ i ][ j ] # } # return c # } # # for i := 0 ; i < m ; i ++ { # if A [ i ][ 0 ] == 0 { # toggleRow ( i ) # } # } # # res := m # # for j := 1 ; j < n ; j ++ { # c := countCol ( j ) # if 2 * c < m { # c = m - c # } # res = res * 2 + c # } # # return res
c , _ := strconv . Atoi ( v ) # zero := new ( big . Int ) # ten := new ( big . Int ). SetUint 6 4 ( 1 0 ) # exp := new ( big . Int ) # total := new ( big . Int ) # modulus := new ( big . Int ) # x := new ( big . Int ). SetUint 6 4 ( 2 ) # y := new ( big . Int ). SetUint 6 4 ( uint 6 4 ( c )) # exp = exp . Exp ( x , y , nil ) # for exp . Cmp ( zero ) == 1 { # exp . DivMod ( exp , ten , modulus ) # total . Add ( total , modulus ) # } # return total . String ()
headPtr := & SinglyLL { Value : nil , Next : head } # front := headPtr # follower := headPtr # # for i := 0 ; i <= kth ; i ++ { # if front == nil { # panic (" STR ") # } # # front = front . Next # } # # for ; front != nil ; front = front . Next { # follower = follower . Next # } # # follower . Next = follower . Next . Next # # return headPtr . Next
self . slots [ self . top ] = slot # self . top ++
total := 0 # for _ , num := range nums { # total += num # } # return total
ones := 0 # for i := len ( bits ) - 2 ; i >= 0 && 1 == bits [ i ]; i -- { # ones ++ # } # # if ones % 2 != 0 { # return false # } # return true
return len ( s )
if ( t >> 4 )% 2 != 0 { # namedTypeNum := t >> 5 # n := *(* uintptr )( unsafe . Pointer ( uintptr ( unsafe . Pointer (& namedNonBasicTypesSidetable )) + uintptr ( namedTypeNum )* unsafe . Sizeof ( uintptr ( 0 )))) # return rawType ( n ) # } # return t >> 5
return & linkedQueue { # head : nil , # tail : nil , # realLength : 0 , # size : size , # }
sort . Ints ( deck ) # # size := len ( deck ) # # t := make ([] int , 0 , size * 2 ) # b := 0 # # for i := size - 1 ; i >= 0 ; i -- { # t = append ( t , deck [ i ]) # if i > 0 { # t = append ( t , t [ b ]) # b ++ # } # } # # for i , j := b , len ( t )- 1 ; i < j ; i , j = i + 1 , j - 1 { # t [ i ], t [ j ] = t [ j ], t [ i ] # } # # return t [ b :]
rns := [] rune ( s ) # # for i , j := 0 , len ( rns )- 1 ; i < j ; i , j = i + 1 , j - 1 { # # rns [ i ], rns [ j ] = rns [ j ], rns [ i ] # } # # return string ( rns )
bill := user {" STR ", " STR "} # sendNotification (& bill ) # # lisa := admin {" STR ", " STR "} # sendNotification (& lisa )
if head == nil { # return nil # } # # slow := head . Next # var fast * ListNode # if slow != nil { # fast = slow . Next # } # # for fast != nil { # if slow == fast { # break # } # # slow = slow . Next # fast = fast . Next # if fast != nil { # fast = fast . Next # } # } # # if fast == nil { # return nil # } # # slow = head # for slow != fast { # slow = slow . Next # fast = fast . Next # } # # return fast
t . Parallel () # # for _ , tc := range testcases { # if res := SortStringByCharFreq ( tc . input ); res != tc . expected { # t . Errorf (" STR ", tc . expected , res ) # } # }
for i := 2 8 5 + 1 ; ; i ++ { # tI := genTri ( i ) # if isPent ( tI ) && isHex ( tI ) { # fmt . Println (" STR ", tI , " STR ", i ) # return # } # }
m := make ( map [ int ] int ) # for _ , v := range nums { # if _ , ok := m [ v ]; ok { # m [ v ]++ # } else { # m [ v ] = 1 # } # } # ret := [] int {} # for k , v := range m { # if v == 2 { # ret = append ( ret , k ) # } # } # return ret
cases := [] struct { # name string # input 1 string # input 2 [] string # expect [] int # }{ # {" STR ", # " STR ", # [] string {" STR ", " STR "}, # [] int { 0 , 9 }, # }, # {" STR ", # " STR ", # [] string {" STR ", " STR "}, # [] int {}, # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := findSubstring ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . input 1 ) # } # }) # }
notPrime := make ([] bool , n ) # count := 0 # # for i := 2 ; i < n ; i ++ { # if ! notPrime [ i ] { # count ++ # # if temp := i * i ; temp < n { # for j := temp ; j < n ; j += i { # notPrime [ j ] = true # } # } # } # } # return count
return sl . stack . Len () == 0
freqMap , start := make ( map [ string ] int ), - 1 # for i , c := range paragraph { # if c == ' ' || c == '!' || c == '?' || c == '\'' || c == ',' || c == ';' || c == '.' { # if start > - 1 { # word := strings . ToLower ( paragraph [ start : i ]) # freqMap [ word ]++ # } # start = - 1 # } else { # if start == - 1 { # start = i # } # } # } # if start != - 1 { # word := strings . ToLower ( paragraph [ start :]) # freqMap [ word ]++ # } # for _ , bannedWord := range banned { # delete ( freqMap , bannedWord ) # } # mostFreqWord , mostFreqCount := " STR ", 0 # for word , freq := range freqMap { # if freq > mostFreqCount { # mostFreqWord = word # mostFreqCount = freq # } # } # return mostFreqWord
if len ( nums ) == 0 { # return 0 # } # index := 0 # for ; index < len ( nums ); { # if nums [ index ] == val { # nums = append ( nums [: index ], nums [ index + 1 :]...) # continue # } # index ++ # } # return len ( nums )
cases := [] struct { # name string # segs [] seg # res [] bool # expect bool # }{ # {" STR ", [] seg {{ 2 , 6 }, { 1 2 , 1 5 }, { 8 , 9 }, { 9 , 1 0 }}, [] bool { true , true , true , true }, true }, # {" STR ", [] seg {{ 1 0 , 2 0 }, { 1 5 , 2 5 }, { 2 0 , 3 0 }}, [] bool { true , false , true }, true }, # {" STR ", [] seg {{ 3 7 , 5 0 }, { 3 3 , 5 0 }, { 4 , 1 7 }, { 3 5 , 4 8 }, { 8 , 2 5 }}, [] bool { true , false , true , false , false }, true }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . segs , c . res ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . segs , c . res ) # } # }) # }
qs := [] question 1 2 1 7 { # # { # para 1 2 1 7 {[] int { 1 , 2 , 3 }}, # ans 1 2 1 7 { 1 }, # }, # # { # para 1 2 1 7 {[] int { 2 , 2 , 2 , 3 , 3 }}, # ans 1 2 1 7 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 1 7 , q . para 1 2 1 7 # fmt . Printf (" STR ", p , minCostToMoveChips ( p . arr )) # } # fmt . Printf (" STR ")
res := make ([] string , 0 , len ( S )) # s := S [ 1 : len ( S )- 1 ] # for i := 1 ; i < len ( s ); i ++ { # lefts , rights := addDot ( s [: i ]), addDot ( s [ i :]) # for _ , l := range lefts { # for _ , r := range rights { # res = append ( res , connect ( l , r )) # } # } # } # return res
for i := max ; ; i += max { # found := true # for j := 2 ; j < max ; j ++ { # if i % j != 0 { # found = false # break # } # } # if found { # fmt . Println ( i ) # break # } # }
fmt . Println ( strconv . Itoa ( 1 )) # fmt . Println ( strings . Compare (" STR ", " STR ")) # fmt . Println ( math . Abs ( 1 . 0 )) # fmt . Println ( unicode . IsDigit (' 1 ')) # fmt . Println ( sort . IsSorted ( nil )) # fmt . Println ( regexp . QuoteMeta (" STR "))
var capitals int # for i := 0 ; i < len ( word ); i ++ { # if isCapital ( word [ i ]) { # capitals ++ # } # } # return capitals == 0 || capitals == len ( word ) || ( capitals == 1 && isCapital ( word [ 0 ]))
fmt . Println ( 2 );
runtime . GOMAXPROCS ( 1 ) # # wg . Add ( 2 ) # # fmt . Println (" STR ") # go printPrime (" STR ") # go printPrime (" STR ") # # fmt . Println (" STR ") # wg . Wait () # # fmt . Println (" STR ")
return New ( s ). Values ()
result := make ([] int , 0 ) # num := make ([] byte , 0 ) # start := 1 # if N == 1 { # start = 0 # } # # for i := start ; i <= 9 ; i ++ { # num = append ( num , byte ( i )+' 0 ') # numsSameConsecDiffCore ( N , K , 0 , byte ( i )+' 0 ', num , & result ) # num = num [ 0 : len ( num )- 1 ] # } # # return result
if node == nil { # return false # } # for i := range node . c { # if stop := bt . inOrderWalk ( node . c [ i ], callback ); stop { # return true # } # if i < node . Len () { # if stop := callback ( bt , node , i ); stop { # return true # } # } # } # # return false
res := [] string {} # var dfs func ( string , int , int , [ 2 ] byte ) # dfs = func ( s string , i , j int , par [ 2 ] byte ) { # c := 0 # for x := i ; x < len ( s ); x ++ { # if s [ x ] == par [ 0 ] { # c ++ # } else if s [ x ] == par [ 1 ] { # c -- # } # if c >= 0 { # continue # } # for y := j ; y <= x ; y ++ { # if s [ y ] == par [ 1 ] && ( y == j || s [ y - 1 ] != par [ 1 ]) { # dfs ( s [: y ]+ s [ y + 1 :], x , y , par ) # } # } # return # } # r := reverse ( s ) # if par [ 0 ] == '(' { # dfs ( r , 0 , 0 , [ 2 ] byte {')', '('}) # } else { # res = append ( res , r ) # } # } # dfs ( s , 0 , 0 , [ 2 ] byte {'(', ')'}) # return res
m := len ( matrix ) # if m == 0 { # return false # } # n := len ( matrix [ 0 ]) # # i , j := m - 1 , 0 # for 0 <= i && j < n { # if matrix [ i ][ j ] == target { # return true # } else if matrix [ i ][ j ] < target { # j ++ # } else { # i -- # } # } # return false
ans := 0 # n 0 := 0 # n 1 := strings . Count ( s , " STR ") # for _ , v := range s [: len ( s )- 1 ] { # if v == ' 1 ' { # n 1 -- # } else { # n 0 ++ # } # if ans < n 0 + n 1 { # ans = n 0 + n 1 # } # } # return ans
return MyHashMap { make ( map [ int ] int , 0 )}
r , err := FormatRequest ( Bytes { Start : 0 , End : 1 }, Bytes { Start : 4 0 9 5 , End : 4 0 9 6 }) # if err != nil { # panic ( err ) # } # fmt . Println ( r )
if root == nil || root . Val < val { # node := TreeNode { # Val : val , # } # # node . Left = root # return & node # } # # root . Right = insertIntoMaxTree ( root . Right , val ) # return root
problems := GetProblemsInstance () # problems = sortProblems ( problems ) # return problems
if x < 0 || ( x != 0 && x % 1 0 == 0 ) { # return false # } # halfReverseX := 0 # for ; x > halfReverseX ; x /= 1 0 { # halfReverseX = halfReverseX * 1 0 + x % 1 0 # # } # return x == halfReverseX || halfReverseX / 1 0 == x
if n < m { # return R ( m , n ) # } # # if n == 0 { # return 1 # } # # if ans , ok := memo [[ 2 ] int { n , m }]; ok { # return ans # } # # if !( n == 1 && m == 0 ) { # ans += inter ( 1 , 0 , n , m ) # ans %= mod # } # # for i := 1 ; i <= n ; i ++ { # for j := 1 ; j <= m ; j ++ { # # if !( i == n && j == m ) { # ans += inter ( i , j , n , m ) # ans %= mod # # } # # } # } # # big := twoPow ( n * m ) # ans = big - ans # # for ans < 0 { # ans += mod # } # # memo [[ 2 ] int { n , m }] = ans # return R ( n , m ) #
t . Parallel () # cases := [] struct { # name string # text string # want string # }{ # { # name : " STR ", text : " STR ", want : " STR ", # }, # { # name : " STR ", text : " STR ", want : " STR ", # }, # } # const ( # size = 5 # characters = " STR " # key = " STR " # ) # p , err := NewPolybius ( key , size , characters ) # if err != nil { # t . Fatalf (" STR ", err ) # } # for _ , tc := range cases { # t . Run ( tc . name , func ( t * testing . T ) { # encrypted , err := p . Encrypt ( tc . text ) # if err != nil { # if err . Error () != tc . want { # t . Errorf (" STR ", err ) # } # } else if encrypted != tc . want { # t . Errorf (" STR ", encrypted , tc . want ) # } # }) # }
ans := make ([] rune , len ( s )* 3 ) # # i := 0 # for _ , v := range s { # if v != " STR " { # ans [ i ] = v # i ++ # } else { # ans [ i ], ans [ i + 1 ], ans [ i + 2 ] = " STR ", " STR ", " STR " # i += 3 # } # } # return string ( ans )[: i ]
t . Parallel () # for _ , tc := range testcases { # if result := LazyBartender ( tc . prefs ); ! reflect . DeepEqual ( result , tc . memorizedDrinks ) { # t . Errorf (" STR ", tc . memorizedDrinks , result ) # } # }
data := [] int { 9 , 1 1 , 8 , 5 , 7 , 1 2 , 1 6 , 1 4 } # fmt . Println ( maxDiff ( data ))
arr := randomSlice ( 0 , 2 0 , 1 0 ) # bst := newBstRecrusive () # for _ , v := range arr { # bst . Insert ( uint 3 2 ( v )) # } # checkBstPostOrder ( t , bst )
return & fib { # val : make ( map [ int ] int , n ), # }
for num > 9 { # cur := 0 # for num != 0 { # cur += num % 1 0 # num /= 1 0 # } # num = cur # } # return num
res := [] int {} # var valMap = map [ int ] bool {} # for i := 0 ; i < len ( nums 1 ); i ++{ # valMap [ nums 1 [ i ]]= true # } # # for i := 0 ; i < len ( nums 2 ); i ++{ # if valMap [ nums 2 [ i ]] == true { # res = append ( res , nums 2 [ i ]) # valMap [ nums 2 [ i ]] = false # } # } # return res
w . Header (). Set ( # " STR ", # " STR ", # ) # html := # `< doctype html > # < html > # < head > # < title > Hello Gopher </ title > # </ head > # < body > # < b > Hello Gopher !</ b > # < p > # < a href =" STR "> Welcome </ a > | < a href =" STR "> Message </ a > # </ p > # </ body > # </ html >` # fmt . Fprintf ( w , html )
if p := e . l ; e . list != nil && p != & e . list . root { # return p # } # return nil
res := make ([][] int , 0 , len ( words )) # size := len ( words ) # if size < 2 { # return res # } # # hash := make ( map [ string ] int , size ) # # for i := 0 ; i < size ; i ++ { # hash [ words [ i ]] = i # } # # for i := 0 ; i < len ( words ); i ++ { # for k := 0 ; k <= len ( words [ i ]); k ++ { # right := words [ i ][ k :] # left := words [ i ][: k ] # # if isPalindrome ( right ) { # leftRev := reverse ( left ) # if j , ok := hash [ leftRev ]; ok && i != j { # res = append ( res , [] int { i , j }) # } # } # # if len ( left ) != 0 && isPalindrome ( left ) { # rightRev := reverse ( right ) # if j , ok := hash [ rightRev ]; ok && i != j { # res = append ( res , [] int { j , i }) # } # } # # } # } # # return res
if num == 0 { # return false # } # # for _ , n := range [] int { 2 , 3 , 5 } { # for num % n == 0 { # num /= n # } # } # return num == 1
ans := make ([] rune , len ( s )* 3 ) # # i := 0 # for _ , v := range s { # if v != ' ' { # ans [ i ] = v # i ++ # } else { # ans [ i ], ans [ i + 1 ], ans [ i + 2 ] = '%', ' 2 ', ' 0 ' # i += 3 # } # } # return string ( ans )[: i ]
for _ , tc := range testCases { # t . Run ( tc . name , func ( t * testing . T ) { # actual := AhoCorasick ( tc . text , tc . words ) # if ! reflect . DeepEqual ( actual , tc . expected ) { # actualString := convertToString ( actual ) # expectedString := convertToString ( tc . expected ) # t . Errorf (" STR ", # tc . words , tc . text , actualString , expectedString ) # } # }) # }
sum := k . Absum () # w := k . Width # h := k . Height # nk := NewKernel ( w , h ) # # if sum == 0 { # sum = 1 # } # # for i := 0 ; i < w * h ; i ++ { # nk . Matrix [ i ] = k . Matrix [ i ] / sum # } # # return nk
var max * TreeNode # var res [] int # for root != nil { # if root . Left == nil { # res = append ( res , root . Val ) # root = root . Right # } else { # max = root . Left # for max . Right != nil { # max = max . Right # } # # root . Right , max . Right = root . Left , root . Right # root . Left = nil # } # } # return res
sort . Slice ( people , func ( i , j int ) bool { # return people [ i ] > people [ j ] # }) # # var totalBoat = 0 # var maxIdx = len ( people ) - 1 # var minIdx = 0 # for minIdx < maxIdx { # totalBoat ++ # if people [ maxIdx ]+ people [ minIdx ] <= limit { # minIdx ++ # maxIdx -- # continue # } # minIdx ++ # } # if minIdx == maxIdx { # totalBoat ++ # } # # return totalBoat
if len ( nums ) == 0 { # return [] int {} # } # max := nums [ 0 ] # var left_res , right_res , res [] int # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] > max { # left_res = append ( left_res , nums [ i ]) # } else { # right_res = append ( right_res , nums [ i ]) # } # } # left_res = Sort ( left_res ) # right_res = Sort ( right_res ) # res = append ( res , left_res ...) # res = append ( res , max ) # res = append ( res , right_res ...) # return res
var x int 6 4 = 1 0 0 # var d time . Duration = 1 0 * time . Nanosecond # fmt . Println (" STR ") # fmt . Println ( Any ( x )) # fmt . Println ( Any ( d )) # fmt . Println ( Any ([] int 6 4 { x })) # fmt . Println ( Any ([] time . Duration { d })) #
qs := [] question 8 7 5 { # # { # para 8 7 5 {[] int { 3 , 6 , 7 , 1 1 }, 8 }, # ans 8 7 5 { 4 }, # }, # # { # para 8 7 5 {[] int { 3 0 , 1 1 , 2 3 , 4 , 2 0 }, 5 }, # ans 8 7 5 { 3 0 }, # }, # # { # para 8 7 5 {[] int { 3 0 , 1 1 , 2 3 , 4 , 2 0 }, 6 }, # ans 8 7 5 { 2 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 7 5 , q . para 8 7 5 # fmt . Printf (" STR ", p , minEatingSpeed ( p . piles , p . H )) # } # fmt . Printf (" STR ")
cases := [] struct { # name string # inputs string # expect [] string # }{ # {" STR ", " STR ", [] string {" STR ", " STR "}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := restoreIpAddresses ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
r := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # r . Shuffle ( len ( cards ), func ( i , j int ) { # cards [ i ], cards [ j ] = cards [ j ], cards [ i ] # })
for i := 0 ; i < len ( arr ); i ++ { # if arr [ i ] == key { # return i # } # } # return - 1
if m > n { # m , n = n , m # } # for i := m + 1 ; m != 0 && i <= n ; i ++ { # m &= i # } # return m
fmt . Println ( combinationSum ([] int { 2 , 3 , 6 , 7 }, 7 ))
mod := 1 0 0 0 0 0 0 0 0 7 # n := len ( group ) # dp := make ([][] int , P + 1 ) # for i := 0 ; i < P + 1 ; i ++ { # dp [ i ] = make ([] int , G + 1 ) # } # dp [ 0 ][ 0 ] = 1 # for k := 0 ; k < n ; k ++ { # for i := P ; i >= 0 ; i -- { # ip := min ( i + profit [ k ], P ) # for j := G - group [ k ]; j >= 0 ; j -- { # dp [ ip ][ j + group [ k ]] += dp [ i ][ j ] # dp [ ip ][ j + group [ k ]] %= mod # } # } # } # res := 0 # for i := 0 ; i < G + 1 ; i ++ { # res += dp [ P ][ i ] # } # return res % mod
type A struct { # Name string # Value int ` structs :" STR "` # } # # a := A { Name : " STR "} # s := Values ( a ) # # if len ( s ) != 1 { # t . Errorf (" STR ") # } # # if s [ 0 ].( string ) != " STR " { # t . Errorf (" STR ") # }
l , r , res := 0 , len ( height )- 1 , 0 # lMax , rMax := 0 , 0 # for l < r { # if height [ l ] < height [ r ] { # if height [ l ] >= lMax { # lMax = height [ l ] # } else { # res += lMax - height [ l ] # } # l ++ # } else { # if height [ r ] >= rMax { # rMax = height [ r ] # } else { # res += rMax - height [ r ] # } # r -- # } # } # return res
var max , n , sum int # for _ , n = range nums { # sum += n # if max < n { # max = n # } # } # # if m == 1 { # return sum # } # # isBigger := func ( guess int ) bool { # count , subSum := 1 , 0 # for _ , n = range nums { # subSum += n # if subSum > guess { # subSum = n # count ++ # if count > m { # return false # } # } # } # return true # } # # l , r := max , sum # var mid int # for l <= r { # mid = l + ( r - l )>> 1 # if isBigger ( mid ) { # r = mid - 1 # } else { # l = mid + 1 # } # } # # return l
N := len ( grid ) # res := 0 # for i := 0 ; i < N ; i ++ { # for j := 0 ; j < N ; j ++ { # v := grid [ i ][ j ] # if v == 0 { # continue # } # res += v * 6 - ( v - 1 )* 2 # if j + 1 < N { # res -= min ( v , grid [ i ][ j + 1 ]) * 2 # } # if i + 1 < N { # res -= min ( v , grid [ i + 1 ][ j ]) * 2 # } # } # } # return res
var sum uint 6 4 = 0 # # for i := 0 ; i < 3 6 2 8 8 0 0 ; i ++ { # p := buildPermutation ( factoradic ( i )) # sum += substringDivisible ( p ) # } # # fmt . Println ( sum )
var s string # var ret string # s = " STR " # ret = " STR " # if ret != reverseWords ( s ) { # t . Fatalf (" STR ", ret ) # }
result := LargestPalindromeProduct ( 2 ) # if result != 9 0 0 9 { # t . Errorf (" STR ", result , 9 0 0 9 ) # } # # result = LargestPalindromeProduct ( 1 ) # if result != 9 { # t . Errorf (" STR ", result , 9 ) # }
fmt . Println ( getPalindromeByDigitCount ( 2 )) # fmt . Println ( getPalindromeByDigitCount ( 3 ))
tmp := 0 # for _ , num := range nums { # tmp ^= num # } # div := 1 # # for div & tmp == 0 { # div <<= 1 # } # a , b := 0 , 0 # # for _ , num := range nums { # if div & num == 0 { # a ^= num # } else { # b ^= num # } # } # return [] int { a , b }
var newh ListNode # for head != nil { # newh . Next , head . Next , head = head , newh . Next , head . Next # } # return newh . Next #
tmp := & ListNode {} # # tmp . Next = head # # for p := tmp ; p != nil ; { # if p . Next != nil && p . Next . Val == val { # p . Next = p . Next . Next # # } else { # p = p . Next # } # } # return tmp . Next
if words == nil || len ( words ) == 0 { # return 0 # } # length , value , maxProduct := len ( words ), make ([] int , len ( words )), 0 # for i := 0 ; i < length ; i ++ { # tmp := words [ i ] # value [ i ] = 0 # for j := 0 ; j < len ( tmp ); j ++ { # value [ i ] |= 1 << ( tmp [ j ] - ' a ') # } # } # for i := 0 ; i < length ; i ++ { # for j := i + 1 ; j < length ; j ++ { # if ( value [ i ]& value [ j ]) == 0 && ( len ( words [ i ])* len ( words [ j ]) > maxProduct ) { # maxProduct = len ( words [ i ]) * len ( words [ j ]) # } # } # } # return maxProduct
index := 0 # # for i , num := range nums { # if num != 0 { # nums [ i ] = 0 # nums [ index ] = num # index ++ # } # }
if root == nil { # return true # } # # if ( lowerBound != - 1 && root . Val <= lowerBound ) || ( upperBound != - 1 && root . Val >= upperBound ) { # return false # } # # leftUpperBound := root . Val # if upperBound != - 1 && upperBound <= leftUpperBound { # leftUpperBound = upperBound # } # # rightLowerBound := root . Val # if lowerBound != - 1 && lowerBound >= rightLowerBound { # rightLowerBound = lowerBound # } # # return isValidBSTWithBounds ( root . Left , lowerBound , leftUpperBound ) && # isValidBSTWithBounds ( root . Right , rightLowerBound , upperBound ) #
for idx , ele := range nestedList { # if ele . IsInteger () { # * raw = append (* raw , nestedList [ idx ]) # continue # } # deepTraverse ( ele . GetList (), raw ) # }
inputArr := [] int {- 7 , - 8 , - 1 , - 2 , - 4 , 1 , 4 , 9 , 3 , 6 } # return inputArr
cases := [] struct { # name string # inputs [] int # expect [] int # }{ # {" STR ", [] int { 1 , 2 , 3 , 4 }, [] int { 2 , 4 , 4 , 4 }}, # {" STR ", [] int { 1 , 1 , 2 , 3 }, [] int { 1 , 3 , 3 }}, # {" STR ", [] int {}, [] int {}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
primes := [] int { 2 , 3 , 5 , 7 , 1 1 , 1 3 , 1 7 , 1 9 } # # product := 1 # for _ , prime := range primes { # product *= prime # } # # for i := 2 ; i <= 2 0 ; i ++ { # n := i # for _ , prime := range primes { # for n % prime == 0 && product % i != 0 { # product *= prime # n /= prime # } # } # } # # fmt . Println ( product )
n := len ( matrix ) # for i := 0 ; i < n / 2 ; i ++ { # for j := i ; j < n - i - 1 ; j ++ { # matrix [ i ][ j ], matrix [ n - j - 1 ][ i ], matrix [ n - i - 1 ][ n - j - 1 ], matrix [ j ][ n - i - 1 ] = # matrix [ n - j - 1 ][ i ], matrix [ n - i - 1 ][ n - j - 1 ], matrix [ j ][ n - i - 1 ], matrix [ i ][ j ] # } # }
if n <= 2 { # return n # } # dp := [] int { 1 , 1 , 2 } # for i := 3 ; i <= n ; i ++{ # t := 0 # for j := 1 ; j <= i ; j ++{ # t += dp [ j - 1 ]* dp [ i - j ] # } # dp = append ( dp , t ) # } # return dp [ n ]
h . linkedHeapList = h . linkedHeapList . Union (&( i .(* linkedHeap ). linkedHeapList )).( linkedHeapList ) # h . heap . BuildHeap () # return h
if _ , ok := this . cache [ key ]; ! ok { # return - 1 # } # node := this . cache [ key ] # this . moveToHead ( node ) # return node . value
largestPrime := 0 # for i := 2 ; i < Number / 2 ; i ++ { # isPrime := true ; # if ( Number % i == 0 ) { # for j := 2 ; j < i / 2 ; j ++ { # if ( i % j == 0 ) { # isPrime = false # break # } # } # if ( isPrime ) { # largestPrime = i ; # } # } # } # fmt . Println (" STR ", Number ," STR ", largestPrime ," STR ")
c , found = sc . m . Load ().( map [ reflect . Type ]* cStruct )[ key ] # return
result := Factorial ( big . NewInt ( 0 )) # expected := big . NewInt ( 1 ) # # if result . Cmp ( expected ) != 0 { # t . Errorf (" STR ", result ) # }
return a + b
if root == nil { # return false # } # # sum -= root . Val # if root . Left == nil && root . Right == nil { # return sum == 0 # } # # return hasPathSum ( root . Left , sum ) || hasPathSum ( root . Right , sum )
var numbers int # var sumOfSquares , squareOfSums int # # numbers = 1 0 0 # # for i := 0 ; i <= numbers ; i ++ { # sumOfSquares = sumOfSquares + i * i # } # fmt . Println (" STR ", sumOfSquares ) # for i := 0 ; i <= numbers ; i ++ { # squareOfSums = squareOfSums + i # } # squareOfSums = squareOfSums * squareOfSums # fmt . Println (" STR ", squareOfSums ) # # fmt . Println (" STR ", squareOfSums - sumOfSquares )
tests := [...] testType { # { # in : 1 5 , # want : [] string { # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # }, # }, # { # in : 5 , # want : [] string { # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # }, # }, # { # in : 1 0 , # want : [] string { # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # }, # }, # } # # for _ , tt := range tests { # got := fizzBuzz ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
for testNo , test := range testVectorEwma { # e := NewEwma ( time . Duration ( 1 * time . Minute )) # # ts := time . Now () # e . Update ( 0 , ts ) # # if e . Current != 0 { # t . Errorf (" STR ") # } # # for lineNo , l := range test { # ts = ts . Add ( time . Duration ( l . delay * float 6 4 ( time . Second . Nanoseconds ()))) # e . Update ( l . v , ts ) # if e . Current != l . cur { # t . Errorf (" STR ", # testNo , lineNo , e . Current , l . cur ) # } # } # }
qs := [] question 4 7 7 { # # { # para 4 7 7 {[] int { 4 , 1 4 , 2 }}, # ans 4 7 7 { 6 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 7 7 , q . para 4 7 7 # fmt . Printf (" STR ", p , totalHammingDistance ( p . one )) # } # fmt . Printf (" STR ")
if len ( nums ) == 0 { # return # } # p 0 := 0 # p 2 := len ( nums ) - 1 # curr := 0 # for curr <= p 2 { # switch nums [ curr ] { # case 0 : # nums [ p 0 ], nums [ curr ] = nums [ curr ], nums [ p 0 ] # p 0 ++ # curr ++ # case 1 : # curr ++ # case 2 : # nums [ p 2 ], nums [ curr ] = nums [ curr ], nums [ p 2 ] # p 2 -- # } # # }
size := len ( a ) # # i := 2 # # for j := i ; j < size ; j ++ { # if a [ i - 2 ] != a [ j ] { # a [ i ] = a [ j ] # i ++ # } # } # # return i
if root == nil { # return nil , true # } # # leftNode , delLeft := pruneTreeAux ( root . Left ) # rightNode , delRight := pruneTreeAux ( root . Right ) # delSelf := true # n := & TreeNode {} # if ! delLeft { # delSelf = false # n . Left = leftNode # } # if ! delRight { # delSelf = false # n . Right = rightNode # } # # delSelf = root . Val == 0 && delSelf # if delSelf { # return nil , delSelf # } # n . Val = root . Val # n . Left , n . Right = leftNode , rightNode # return n , delSelf
data := [] int { 3 , 4 , 0 , 5 , 1 } # fmt . Println ( isContinuous ( data ))
ans := make ([] int , 0 , 1 0 ) # for node != nil { # ans = append ( ans , node . Val ) # node = node . Next # } # return ans
return buildBstFromPreOrder ( preorder )
if a == b { # return 0 # } # # hasSeen := make ( map [ string ] bool , 4 0 9 6 ) # hasSeen [ a ] = true # queue := make ([] string , 1 , 4 0 9 6 ) # queue [ 0 ] = a # # strSize := len ( a ) # res := 0 # # for { # res ++ # for countDown := len ( queue ); countDown > 0 ; countDown -- { # s := queue [ 0 ] # queue = queue [ 1 :] # # i := 0 # for s [ i ] == b [ i ] { # i ++ # } # for j := i + 1 ; j < strSize ; j ++ { # if s [ j ] == b [ j ] || # s [ i ] != b [ j ] { # continue # } # # temp := swap ( s , i , j ) # if temp == b { # return res # } # # if ! hasSeen [ temp ] { # hasSeen [ temp ] = true # queue = append ( queue , temp ) # } # } # } # }
sort . Ints ( nums ) # i , j := 0 , len ( nums )- 1 # count := 0 # for i < j { # count += nums [ j ] - nums [ i ] # i ++ # j -- # } # return count
result := strobogrammaticNumber ( digits , digits ) # sort . Strings ( result ) # return result
ret := make ([] int , len ( t )) # st := [ 3 0 0 0 1 ] int {} # idx := 0 # for i := 0 ; i < len ( t ); i ++ { # for idx > 0 && t [ st [ idx - 1 ]] < t [ i ] { # ret [ st [ idx - 1 ]] = i - st [ idx - 1 ] # idx -- # } # st [ idx ] = i # idx ++ # } # return ret
if list . head == nil { # return false # } # if i < 0 { # return false # } # if i == 0 { # list . head . prev = nil # list . head = list . head . next # return true # } # current := list . head # for u := 1 ; u < i ; u ++ { # if current . next . next == nil { # return false # } # current = current . next # } # if current . next . next != nil { # current . next . next . prev = current # } # current . next = current . next . next # return true
if head == nil { # return nil # } else if head . Val == val { # return head . Next # } # # ans := head # for head . Next . Val != val { # head = head . Next # } # head . Next = head . Next . Next # return ans
count := 0 # for i := range A [ 0 ] { # prev := byte (' a ') # for _ , str := range A { # if str [ i ] < prev { # count ++ # break # } # # prev = str [ i ] # } # } # # return count
sum := 0 . 0 # for i := range path { # if i > 0 { # sum += path [ i - 1 ]. Distance ( path [ i ]) # } # } # return sum
qs := [] question 1 0 1 1 { # # { # para 1 0 1 1 {[] int { 7 , 2 , 5 , 1 0 , 8 }, 2 }, # ans 1 0 1 1 { 1 8 }, # }, # # { # para 1 0 1 1 {[] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 0 }, 5 }, # ans 1 0 1 1 { 1 5 }, # }, # # { # para 1 0 1 1 {[] int { 3 , 2 , 2 , 4 , 1 , 4 }, 3 }, # ans 1 0 1 1 { 6 }, # }, # # { # para 1 0 1 1 {[] int { 1 , 2 , 3 , 1 , 1 }, 4 }, # ans 1 0 1 1 { 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 1 1 , q . para 1 0 1 1 # fmt . Printf (" STR ", p , shipWithinDays ( p . weights , p . D )) # } # fmt . Printf (" STR ")
var tests = [] struct { # grid [][] int # perimeter int # }{ # { # [][] int { # { 0 , 1 , 0 , 0 }, # { 1 , 1 , 1 , 0 }, # { 0 , 1 , 0 , 0 }, # { 1 , 1 , 0 , 0 }, # }, 1 6 , # }, # } # # for _ , tt := range tests { # perimeter := islandPerimeter ( tt . grid ) # if perimeter != tt . perimeter { # t . Errorf (" STR ", tt . grid , perimeter , tt . perimeter ) # } # }
item := x .(* ListNode ) # * q = append (* q , item )
t . Parallel () # for _ , tc := range testcases { # if bridges := FindAllBridges ( tc . graph ); ! reflect . DeepEqual ( bridges , tc . bridges ) { # t . Errorf (" STR ", tc . bridges , bridges ) # } # }
switch tt { # case yaml_NO_TOKEN : # return " STR " # case yaml_STREAM_START_TOKEN : # return " STR " # case yaml_STREAM_END_TOKEN : # return " STR " # case yaml_VERSION_DIRECTIVE_TOKEN : # return " STR " # case yaml_TAG_DIRECTIVE_TOKEN : # return " STR " # case yaml_DOCUMENT_START_TOKEN : # return " STR " # case yaml_DOCUMENT_END_TOKEN : # return " STR " # case yaml_BLOCK_SEQUENCE_START_TOKEN : # return " STR " # case yaml_BLOCK_MAPPING_START_TOKEN : # return " STR " # case yaml_BLOCK_END_TOKEN : # return " STR " # case yaml_FLOW_SEQUENCE_START_TOKEN : # return " STR " # case yaml_FLOW_SEQUENCE_END_TOKEN : # return " STR " # case yaml_FLOW_MAPPING_START_TOKEN : # return " STR " # case yaml_FLOW_MAPPING_END_TOKEN : # return " STR " # case yaml_BLOCK_ENTRY_TOKEN : # return " STR " # case yaml_FLOW_ENTRY_TOKEN : # return " STR " # case yaml_KEY_TOKEN : # return " STR " # case yaml_VALUE_TOKEN : # return " STR " # case yaml_ALIAS_TOKEN : # return " STR " # case yaml_ANCHOR_TOKEN : # return " STR " # case yaml_TAG_TOKEN : # return " STR " # case yaml_SCALAR_TOKEN : # return " STR " # } # return " STR "
res , color := [] int {}, make ([] int , len ( graph )) # for i := range graph { # if dfsEventualSafeNodes ( graph , i , color ) { # res = append ( res , i ) # } # } # return res
l 1 , l 2 := len ( nums 1 ), len ( nums 2 ) # total := l 1 + l 2 # if total % 2 == 1 { # return float 6 4 ( findKthNum ( nums 1 , nums 2 , total / 2 + 1 )) # } else { # return 0 . 5 * float 6 4 ( findKthNum ( nums 1 , nums 2 , total / 2 )+ findKthNum ( nums 1 , nums 2 , total / 2 + 1 )) # }
return errors . New (" STR " + tool )
tests := [...] testType { # { # in : [] int { 1 , 2 , 2 , 3 }, # want : true , # }, # { # in : [] int { 6 , 5 , 4 , 4 }, # want : true , # }, # { # in : [] int { 1 , 3 , 2 }, # want : false , # }, # { # in : [] int { 1 , 2 , 4 , 5 }, # want : true , # }, # { # in : [] int { 1 , 1 , 1 }, # want : true , # }, # { # in : [] int { 1 , 2 , 3 , 3 , 3 , 2 , 1 }, # want : false , # }, # } # for _ , tt := range tests { # got := isMonotonic ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
for i := 0 ; i < len ( A ); i ++ { # mid := ( len ( A [ i ]) + 1 ) / 2 # for j := 0 ; j < mid ; j ++ { # k := len ( A [ i ]) - 1 - j # A [ i ][ j ], A [ i ][ k ] = 1 - A [ i ][ k ], 1 - A [ i ][ j ] # } # # } # # return A
if strings . Contains ( IP , " STR ") && isIPv 4 ( IP ) { # return " STR " # } # # if isIPv 6 ( strings . ToLower ( IP )) { # return " STR " # } # # return " STR "
n := len ( nums ) # if n > 1 { # for z , nz := 0 , 0 ; nz < n ; nz ++ { # if nums [ nz ] != 0 { # nums [ z ], nums [ nz ] = nums [ nz ], nums [ z ] # z ++ # } # } # } # return nums
for head != nil && head . Val == val { # head = head . Next # } # # if head == nil { # return nil # } # # cur := head # for cur . Next != nil { # if cur . Next . Val == val { # cur . Next = cur . Next . Next # } else { # cur = cur . Next # } # } # # return head
low , mid , high := 0 , 0 , len ( nums )- 1 # for low <= high { # mid = ( low + high ) / 1 # if nums [ mid ] == target { # return mid # } else if nums [ mid ] >= nums [ low ] { # if nums [ low ] <= target && target < nums [ mid ] { # high = mid - 1 # } else { # low = mid + 1 # } # } else { # if nums [ mid ] < target && target <= nums [ high ] { # low = mid + 1 # } else { # high = mid - 1 # } # } # } # return - 1
stack := make ([]* TreeNode , 0 ) # result := make ([] int , 0 ) # node := root # for node != nil || len ( stack ) != 0 { # for node != nil { # stack = append ( stack , node ) # node = node . Left # } # # node = stack [ len ( stack )- 1 ] # result = append ( result , node . Val ) # stack = stack [: len ( stack )- 1 ] # # node = node . Right # } # # return result
return fmt . Sprintf (" STR ", e . File , e . Line , e . Msg )
factors := [] int { 2 , 3 , 5 } # for num > 1 { # var factor int # for _ , v := range factors { # if num >= v && num % v == 0 { # factor = v # break # } # } # if factor == 0 { # return false # } # num /= factor # } # return num == 1
lo , hi := 0 , x # for lo < hi { # mid := hi - ( hi - lo )/ 2 # # m 2 := mid * mid # switch { # case m 2 > x : # hi = mid - 1 # case m 2 < x : # lo = mid # default : # return mid # } # } # return lo
dp , ans := make ([] int , len ( nums )), nums [ 0 ] # dp [ 0 ] = nums [ 0 ] # # for i := 1 ; i < len ( nums ); i ++ { # dp [ i ] = max ( nums [ i ], nums [ i ]+ dp [ i - 1 ]) # ans = max ( dp [ i ], ans ) # } # return ans
if len ( nums ) <= 1 { # return len ( nums ) # } # # res := 1 # i := 1 # for ; i < len ( nums ); i ++ { # if nums [ i ] == nums [ i - 1 ] { # continue # } # if res != i { # nums [ res ] = nums [ i ] # } # # res ++ # } # # return res
product := 1 # x_split := strings . Split ( x , " STR ") # for i := 0 ; i < len ( x_split ); i += 1 { # asInt , _ := strconv . Atoi ( x_split [ i ]) # product *= asInt # } # return product
var nums [] int # for i := left ; i <= right ; i ++ { # if isSelfDividingNumber ( i ) { # nums = append ( nums , i ) # } # } # return nums
var sb strings . Builder # result := str # for len ( str ) > 0 { # smallest := rune ( str [ 0 ]) # smallestIndex := 0 # for i , r := range str { # if i < k && r < smallest { # smallest = r # smallestIndex = i # } # } # str = str [: smallestIndex ] + str [ smallestIndex + 1 :] # sb . WriteString ( string ( smallest )) # if candidate := str + sb . String (); candidate < result { # result = candidate # } # } # return result
var prev * ListNode # # for head != nil { # temp := head . Next # head . Next = prev # prev = head # head = temp # } # # return prev
cases := [] struct { # name string # inputs [] string # expect int # }{ # {" STR ", [] string {" STR ", " STR "}, 3 }, # {" STR ", [] string {" STR ", " STR "}, 5 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # }) # }
sort . Slice ( ps , func ( i , j int ) bool { # if ps [ i ][ 1 ] == ps [ j ][ 1 ] { # return ps [ i ][ 0 ] > ps [ j ][ 0 ] # } # return ps [ i ][ 1 ] < ps [ j ][ 1 ] # }) # # res := 0 # b := - 1 << 3 2 # for i := 0 ; i < len ( ps ); i ++ { # c := ps [ i ][ 0 ] # if b < c { # res ++ # b = ps [ i ][ 1 ] # } # } # # return res
if i == len ( triangle )- 1 { # sum += triangle [ i ][ j ] # path += strconv . Itoa ( triangle [ i ][ j ]) + " STR " # fmt . Println ( path + " STR " + strconv . Itoa ( sum )) # # if sum < minSum { # minSum = sum # fmt . Println ( minSum ) # } # return sum # } # # sum += triangle [ i ][ j ] # path += strconv . Itoa ( triangle [ i ][ j ]) + " STR " # # _dfs ( triangle , i + 1 , j , path , sum ) # _dfs ( triangle , i + 1 , j + 1 , path , sum ) # # return 0
m := make ([] int , 2 6 ) # for _ , b := range s { # m [ b -' a ']++ # } # # for i , b := range s { # if m [ b -' a '] == 1 { # return i # } # } # return - 1
return fmt . Sprintf (" STR ", * n )
low := int 3 2 ( value ) # high := int 3 2 ( value >> 3 2 ) # self . slots [ self . top ]. Num = low # self . slots [ self . top + 1 ]. Num = high # self . top += 2
cId := make ([] int , 0 ) # for i := 0 ; i < len ( S ); i ++ { # if S [ i ] == C { # cId = append ( cId , i ) # } # } # # ans := make ([] int , 0 ) # for i := 0 ; i < len ( S ); i ++ { # if S [ i ] == C { # ans = append ( ans , 0 ) # } else { # minDistance := getMinDistance ( cId , i ) # ans = append ( ans , minDistance ) # } # } # return ans
qs := [] question 5 0 3 { # # { # para 5 0 3 {[] int {}}, # ans 5 0 3 {[] int {}}, # }, # # { # para 5 0 3 {[] int { 1 }}, # ans 5 0 3 {[] int {- 1 }}, # }, # # { # para 5 0 3 {[] int { 1 , 2 , 1 }}, # ans 5 0 3 {[] int { 2 , - 1 , 2 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 0 3 , q . para 5 0 3 # fmt . Printf (" STR ", p , nextGreaterElements ( p . one )) # } # fmt . Printf (" STR ")
for i := 0 ; i < b . N ; i ++ { # iter ( 1 3 1 3 1 3 1 3 1 , 1 2 3 4 3 5 4 5 ) # }
var sum int # sort . Ints ( nums ) # for i , n := range nums { # if i % 2 == 0 { # sum += n # } # } # return sum
if n == 0 { # return 0 # } # # cols := make ([] bool , n ) # d 1 := make ([] bool , 2 * n ) # d 2 := make ([] bool , 2 * n ) # # res := 0 # # dfs ( 0 , cols , d 1 , d 2 , & res ) # # return res
return AllOne { m : make ( map [ string ]* entry ), # max : maxPQ {}, # min : minPQ {}, # }
mapper := make ( map [ byte ] int ) # for i := range order { # mapper [ order [ i ]] = i - 2 6 # } # res := [] byte ( str ) # sort . Slice ( res , func ( i , j int ) bool { # return mapper [ res [ i ]] < mapper [ res [ j ]] # }) # return string ( res )
deleteNonCompletedNode := func ( node * gbtElement ) { # var reConnectedNode * gbtElement # if t . IsNil ( node . Left ) { # reConnectedNode = node . Right # } else { # reConnectedNode = node . Left # } # if ! t . IsNil ( reConnectedNode ) { # reConnectedNode . Parent = node . Parent # } # if t . IsNil ( node . Parent ) { # t . NilNode . Left = reConnectedNode # t . NilNode . Right = reConnectedNode # } else if node . Parent . Right == node { # node . Parent . Right = reConnectedNode # } else { # node . Parent . Left = reConnectedNode # } # } # node := t . Search ( key ).(* gbtElement ) # if t . IsNil ( node ) { # return node # } # if t . IsNil ( node . Left ) || t . IsNil ( node . Right ) { # deleteNonCompletedNode ( node ) # } else { # successor := t . Successor ( node , t . Root ()).(* gbtElement ) # _key , _value := successor . Key , successor . Value # node . Key , node . Value = _key , _value # deleteNonCompletedNode ( successor ) # } # return node
cp := self . classpath # if cp != "" { # return cp , nil # } # return " STR ", nil
tags := [] struct { # opts string # has bool # }{ # {" STR ", false }, # {" STR ", true }, # {" STR ", false }, # {" STR ", true }, # {" STR ", false }, # } # # for _ , tag := range tags { # _ , opts := parseTag ( tag . opts ) # # if opts . Has (" STR ") != tag . has { # t . Errorf (" STR ", tag ) # } # }
if iter ( 1 4 , 7 ) != 7 || # iter ( 4 , 2 ) != 2 || # iter ( 3 1 , 2 ) != 1 || # iter ( 3 3 , 1 1 ) != 1 1 { # t . Error () # }
for i := 0 ; i < len ( nums ); i ++ { # # # for 0 <= nums [ i ]- 1 && nums [ i ]- 1 < len ( nums ) && nums [ i ] != nums [ nums [ i ]- 1 ] { # nums [ i ], nums [ nums [ i ]- 1 ] = nums [ nums [ i ]- 1 ], nums [ i ] # # # } # } # # for k := range nums { # if nums [ k ] != k + 1 { # return k + 1 # } # } # return len ( nums ) + 1
pNode := head # for nil != pNode { # pCloned := new ( complexListNode ) # pCloned . value = pNode . value # pCloned . next = pNode . next # pNode . next = pCloned # pNode = pCloned . next # } #
if head == nil || head . Next == nil { # return head # } # # node := head . Next # head . Next = swapPairs ( node . Next ) # node . Next = head # return node
dummy := & ListNode { # Next : head , # } # # node := dummy # for node != nil && node . Next != nil { # first := node . Next # i , cur := 1 , first # for i < k && cur != nil { # cur = cur . Next # i ++ # } # # if cur == nil { # break # } # # last , after := cur , cur . Next # cur = first # var prev , next * ListNode # for cur != after { # next = cur . Next # cur . Next = prev # prev = cur # cur = next # } # # first . Next , node . Next = after , last # node = first # } # # return dummy . Next
stack := [] rune {} # for _ , s := range S { # if len ( stack ) == 0 || len ( stack ) > 0 && stack [ len ( stack )- 1 ] != s { # stack = append ( stack , s ) # } else { # stack = stack [: len ( stack )- 1 ] # } # } # return string ( stack )
return & Doubly { nil }
t . Parallel () # for _ , tc := range testcases { # if result := IsValidUTF 8 ( tc . bits ); result != tc . valid { # t . Errorf (" STR ", tc . bits , tc . valid , result ) # } # }
fmt . Println ( Gaussian ( 0 . 0 , 1 . 0 )) # fmt . Println ( Gaussian ( 1 . 0 , 1 . 0 )) # fmt . Println ( Gaussian (- 1 . 0 , 0 . 5 ))
var p Pool # if p . Get () != nil { # t . Fatal (" STR ") # } # p . Put (" STR ") # p . Put (" STR ") # if g := p . Get (); g != " STR " { # t . Fatalf (" STR ", g ) # } # if g := p . Get (); g != " STR " { # t . Fatalf (" STR ", g ) # } # if g := p . Get (); g != nil { # t . Fatalf (" STR ", g ) # } # # p . Put (" STR ") # p . Drain () # if g := p . Get (); g != nil { # t . Fatalf (" STR ", g ) # }
if n == 0 { # return [] string {} # } # res := [] string {} # findGenerateParenthesis ( n , n , " STR ", & res ) # return res
data , ok := m . mem [ id ] # return data , ok
if x > y { # return y # } # return x
answer := 2 5 2 0 # for divisible := false ; divisible != true ; answer ++ { # for div , isAnswer := 2 , false ; div <= 2 0 ; div ++ { # if answer % div == 0 { # isAnswer = true # } else { # isAnswer = false # } # if ! isAnswer { # break # } # if div == 2 0 { # divisible = true # } # } # } # fmt . Println ( answer - 1 ) #
var result string # buf := bytes . NewBuffer ( data .([] byte )) # dec := gob . NewDecoder ( buf ) # dec . Decode (& result ) # return result
res := 0 # size := len ( a ) # # for m := 0 ; m < size ; m ++ { # for n := 0 ; n < size ; n ++ { # ta := 0 # tb := 0 # for i := 0 ; i < size && i + m < size ; i ++ { # for j := 0 ; j < size && j + n < size ; j ++ { # if a [ i ][ j ] == 1 && b [ i + m ][ j + n ] == 1 { # ta ++ # } # if b [ i ][ j ] == 1 && a [ i + m ][ j + n ] == 1 { # tb ++ # } # } # } # res = max ( res , max ( ta , tb )) # } # } # # return res
res := make ([] int , 1 , rowIndex + 1 ) # res [ 0 ] = 1 # if rowIndex == 0 { # return res # } # # for i := 0 ; i < rowIndex ; i ++ { # res = append ( res , 1 ) # for j := len ( res ) - 2 ; j > 0 ; j -- { # res [ j ] += res [ j - 1 ] # } # } # # return res
input , expected := [] int { 7 , 8 , 1 0 }, 8 . 3 3 # result := Average ( input ...) # if result != expected { # # t . Errorf (" STR ", result , expected ) # }
res := [] int {} # for i := 0 ; i < len ( nums ); i += 2 { # for j := 0 ; j < nums [ i ]; j ++ { # res = append ( res , nums [ i + 1 ]) # } # } # return res
if k == len ( num ) { # return " STR " # } # res := [] byte {} # for i := 0 ; i < len ( num ); i ++ { # c := num [ i ] # for k > 0 && len ( res ) > 0 && c < res [ len ( res )- 1 ] { # res = res [: len ( res )- 1 ] # k -- # } # res = append ( res , c ) # } # res = res [: len ( res )- k ] # # for len ( res ) > 1 && res [ 0 ] == ' 0 ' { # res = res [ 1 :] # } # return string ( res )
prevMax , prevMin , ret := nums [ 0 ], nums [ 0 ], nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i - 1 ] == 0 { # prevMax , prevMin = nums [ i ], nums [ i ] # } else { # curMax := max ( nums [ i ], max ( nums [ i ]* prevMax , nums [ i ]* prevMin )) # curMin := min ( nums [ i ], min ( nums [ i ]* prevMax , nums [ i ]* prevMin )) # prevMax , prevMin = curMax , curMin # } # ret = max ( prevMax , ret ) # } # return ret
tests := [...] testType { # { # j : " STR ", # s : " STR ", # want : 3 , # }, # { # j : " STR ", # s : " STR ", # want : 0 , # }, # { # j : " STR ", # s : " STR ", # want : 2 , # }, # } # # for _ , tt := range tests { # got := numJewelsInStones ( tt . j , tt . s ) # if got != tt . want { # t . Fatalf (" STR ", tt . j , tt . s , got , tt . want ) # } # }
if len ( digits ) == 0 { # return [] int {} # } # carry := 1 # for i := len ( digits ) - 1 ; i >= 0 ; i -- { # if digits [ i ]+ carry > 9 { # digits [ i ] = 0 # carry = 1 # } else { # digits [ i ] += carry # carry = 0 # } # } # if digits [ 0 ] == 0 && carry == 1 { # digits = append ([] int { 1 }, digits ...) # } # return digits
tests := [...] testType { # { # in : " STR ", # want : 1 , # }, # { # in : " STR ", # want : 2 , # }, # { # in : " STR ", # want : 2 , # }, # { # in : " STR ", # want : 0 , # }, # { # in : " STR ", # want : 2 , # }, # } # for _ , tt := range tests { # got := removePalindromeSub ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
n := 0 # for _ , v := range nums { # n ^= v # } # return n
paths := strings . Split ( input , " STR ") # stack := make ([] int , len ( paths )+ 1 ) # res := 0 # for _ , s := range paths { # lev := strings . LastIndex ( s , " STR ") + 1 # stack [ lev + 1 ] = stack [ lev ] + len ( s ) - lev + 1 # if strings . Contains ( s , " STR ") { # if stack [ lev + 1 ]- 1 > res { # res = stack [ lev + 1 ] - 1 # } # } # } # return res
deser := Constructor () # ans := deser . deserialize (" STR ") # fmt . Println ( ans )
cases := [] struct { # name string # inputs [] string # expect string # }{ # {" STR ", [] string {" STR ", " STR "}, " STR "}, # {" STR ", [] string {" STR ", " STR "}, " STR "}, # {" STR ", [] string {" STR ", " STR "}, " STR "}, # {" STR ", [] string {" STR ", " STR "}, " STR "}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := multiply ( c . inputs [ 0 ], c . inputs [ 1 ]) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
var n , count int # for _ , num := range nums { # if count == 0 { # count ++ # n = num # } else { # if num == n { # count ++ # } else { # count -- # } # } # } # return n
wordMap , que , depth := getWordMap ( bank , start ), [] string { start }, 0 # for len ( que ) > 0 { # depth ++ # qlen := len ( que ) # for i := 0 ; i < qlen ; i ++ { # word := que [ 0 ] # que = que [ 1 :] # candidates := getCandidates 4 3 3 ( word ) # for _ , candidate := range candidates { # if _ , ok := wordMap [ candidate ]; ok { # if candidate == end { # return depth # } # delete ( wordMap , candidate ) # que = append ( que , candidate ) # } # } # } # } # return - 1
t . Parallel () # for _ , tc := range testcases { # if result := MinPaintingCost ( tc . houses ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
if _ , exists := matchers [ feedType ]; exists { # log . Fatalln ( feedType , " STR ") # } # # log . Println (" STR ", feedType , " STR ") # matchers [ feedType ] = matcher
qs := [] question 8 1 5 { # # { # para 8 1 5 {[][] int {{ 1 , 2 , 7 }, { 3 , 6 , 7 }}, 1 , 6 }, # ans 8 1 5 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 1 5 , q . para 8 1 5 # fmt . Printf (" STR ", p , numBusesToDestination ( p . r , p . s , p . t )) # } # fmt . Printf (" STR ")
if num <= 1 { # return num # } # return fibo ( num - 1 ) + fibo ( num - 2 )
if n < 0 { # panic (" STR ") # } else if n == 0 { # return [] int {} # } # result := make ([] int , n ) # result [ 0 ] = 1 # var i 2 , i 3 , i 5 int # next 2 , next 3 , next 5 := 2 , 3 , 5 # for i := 1 ; i < n ; i ++ { # result [ i ] = min ( next 2 , next 3 , next 5 ) # if result [ i ] == next 2 { # i 2 ++ # next 2 = result [ i 2 ] * 2 # } # if result [ i ] == next 3 { # i 3 ++ # next 3 = result [ i 3 ] * 3 # } # if result [ i ] == next 5 { # i 5 ++ # next 5 = result [ i 5 ] * 5 # } # } # return result
val := self . data [: n ] # self . data = self . data [ n :] # return val
return len ( A ) == len ( B ) && # strings . Contains ( A + A , B )
n := len ( matrix ) # for i := 0 ; i < n ; i ++ { # for j := i ; j < n ; j ++ { # matrix [ j ][ i ], matrix [ i ][ j ] = matrix [ i ][ j ], matrix [ j ][ i ] # } # } # for i := 0 ; i < n ; i ++ { # reversed := make ([] int , n ) # for j := 0 ; j < n ; j ++ { # reversed [ j ] = matrix [ i ][ n - j - 1 ] # } # matrix [ i ] = reversed # }
panic ( exitCode ( code ))
primes := [] int { 2 , 3 , 5 , 7 , 1 1 , 1 3 , 1 7 , 1 9 } # result := 1 # var divisor int # for i := range primes { # divisor = primes [ i ] # for divisor <= 2 0 { # divisor *= primes [ i ] # } # divisor /= primes [ i ] # result *= divisor # } # println ( result )
for _ , f := range factors { # if x % f != 0 { # return false # } # } # return true
a := big . NewInt ( 1 ) # # res := big . NewInt ( 1 ) # # for a . Int 6 4 () <= 1 0 0 { # res . Mul ( res , a ) # a . Add ( a , big . NewInt ( 1 )) # } # # strNum := res . String () # # sum := 0 # for _ , i := range [] byte ( strNum ) { # sum += int ( i - ' 0 ') # } # # return sum
slow , fast := head , head # var tail * ListNode # for fast != nil && fast . Next != nil { # tail = slow # slow = slow . Next # fast = fast . Next . Next # } # if tail != nil { # tail . Next = nil # } # var secondHead * ListNode # fast = slow # for fast != nil { # slow = fast # fast = fast . Next # slow . Next = secondHead # secondHead = slow # } # firstHead := head # var p 1 , p 2 * ListNode # for firstHead != nil && secondHead != nil { # p 1 = firstHead . Next # p 2 = secondHead . Next # firstHead . Next = secondHead # secondHead . Next = p 1 # if p 1 == nil { # secondHead . Next = p 2 # break # } # firstHead = p 1 # secondHead = p 2 # } # return
return uint ( c . R )<< 3 + uint ( c . G )<< 6 + uint ( c . B )<< 1
sum := 0 # for i := 0 ; i < k ; i ++ { # sum += nums [ i ] # } # m := sum # for i := k ; i < len ( nums ); i ++ { # sum = sum - nums [ i - k ] + nums [ i ] # if sum > m { # m = sum # } # } # return float 6 4 ( m ) / float 6 4 ( k )
total := 0 . 0 # for _ , v := range xs { # total += v # } # return total
qs := [] question 1 2 8 7 { # # { # para 1 2 8 7 {[] int { 1 , 2 , 2 , 6 , 6 , 6 , 6 , 7 , 1 0 }}, # ans 1 2 8 7 { 6 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 8 7 , q . para 1 2 8 7 # fmt . Printf (" STR ", p , findSpecialInteger ( p . one )) # } # fmt . Printf (" STR ")
colors := make ( map [ Node ] color , len ( g )) # var n Node # for n 1 := range g { # n = n 1 # break # } # result := isBipartiteGraph ( g , n , colors ) # return result && len ( colors ) == len ( g )
return & Memo { f : f , cache : make ( map [ string ]* entry )}
var value int # if len ( this . dequeue ) == 0 { # this . dequeue = this . enqueue # this . enqueue = [] int {} # # for i , j := 0 , len ( this . dequeue )- 1 ; i < len ( this . dequeue ) && j > i ; i , j = i + 1 , j - 1 { # this . dequeue [ i ], this . dequeue [ j ] = this . dequeue [ j ], this . dequeue [ i ] # # } # } # if len ( this . dequeue ) > 0 { # value = this . dequeue [ 0 ] # if len ( this . dequeue ) == 1 { # this . dequeue = [] int {} # } else { # this . dequeue = this . dequeue [ 1 :] # } # # } # return value
t . Parallel () # for _ , tc := range testcases { # if result := LargestPossibleInteger ( tc . nums ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
if len ( nums ) == 0 { # return 0 # } # ans := math . MaxInt 3 2 # sum := 0 # start := 0 # # for end := 0 ; end < len ( nums ); end ++ { # sum += nums [ end ] # for sum >= s { # ans = min ( end - start + 1 , ans ) # sum -= nums [ start ] # start ++ # } # } # if ans == math . MaxInt 3 2 { # return 0 # } # return ans
return rx * q [ 0 ] + ry * q [ 1 ]
ret := 0 # for i := 1 ; i < n ; i ++ { # if n % i == 0 { # ret += i # } # } # # return ret
moves := R * C # # res := make ([][] int , 1 , moves ) # res [ 0 ] = [] int { x , y } # moves -- # # round := 2 # dx , dy := 0 , 1 # # for moves > 0 { # for m := round / 2 ; m > 0 ; m -- { # x += dx # y += dy # if 0 <= x && x < R && 0 <= y && y < C { # res = append ( res , [] int { x , y }) # moves -- # } # } # round ++ # # dx , dy = dy , - dx # } # # return res
next := buildNext ( numCourses , prerequisites ) # pres := buildPres ( next ) # # return check ( next , pres , numCourses )
cases := [] struct { # name string # numbers [] int # target int # expect [] int # }{ # {" STR ", [] int { 2 , 7 , 1 1 , 1 5 }, 9 , [] int { 1 , 2 }}, # {" STR ", [] int { 2 , 7 , 1 1 , 1 5 }, 2 2 , [] int { 2 , 4 }}, # {" STR ", [] int { 2 , 7 , 1 1 , 1 5 }, 2 6 , [] int { 3 , 4 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . numbers , c . target ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . numbers , c . target ) # } # }) # }
n := len ( s ) # # dp := make ([][] int , n ) # for i := 0 ; i < n ; i ++ { # dp [ i ] = make ([] int , n ) # dp [ i ][ i ] = 1 # } # # before := make ([][] int , n ) # after := make ([][] int , n ) # # indexOfBefore := [] int { n , n , n , n } # indexOfAfter := [] int {- 1 , - 1 , - 1 , - 1 } # # for i := 0 ; i < n ; i ++ { # j := n - i - 1 # # before [ i ] = make ([] int , 4 ) # after [ j ] = make ([] int , 4 ) # # indexOfBefore [ s [ i ]-' a '] = i # indexOfAfter [ s [ j ]-' a '] = j # for c := 0 ; c < 4 ; c ++ { # before [ i ][ c ] = indexOfBefore [ c ] # after [ j ][ c ] = indexOfAfter [ c ] # } # # } # # return helper ( dp , before , after , 0 , n - 1 )
var result [ 4 ] int # # if p == 1 { # return A # } # # if cache , ok := memo [ p ]; ok { # return cache # } # # result = _raiseToPower ( A , p / 2 , memo ) # R := _multiplyMatrix ( result , result ) # # memo [ p ] = R # # return R
res := 0 # for i := range nums { # tmp := 1 # for nums [ i ] != i { # nums [ i ], nums [ nums [ i ]] = nums [ nums [ i ]], nums [ i ] # tmp ++ # } # # if tmp > res { # res = tmp # } # } # return res
q . queue = append ( q . queue , el ) # q . len ++ # # return
for i := 0 ; i < b . N ; i ++ { # a := big . NewInt ( 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 ) # k_multiply ( a , a ) # }
h . root = h . root . MergeRightList ( h 1 . root ) # if h . less ( h 1 . min , h . min ) { # h . min = h 1 . min # } # h . n += h 1 . n # return h
sort . Ints ( nums ) # ans , length := make ([][] int , 0 ), len ( nums ) # for i := 0 ; i < length - 2 ; i ++ { # if nums [ i ] <= 0 && ( i == 0 || nums [ i ] != nums [ i - 1 ]) { # l , r := i + 1 , length - 1 # for l < r { # sum := nums [ i ] + nums [ l ] + nums [ r ] # if sum < 0 { # l ++ # } else if sum > 0 { # r -- # } else { # ans = append ( ans , [] int { nums [ i ], nums [ l ], nums [ r ]}) # l , r = l + 1 , r - 1 # for l < r && nums [ l ] == nums [ l - 1 ] { # l ++ # } # for l < r && nums [ r ] == nums [ r + 1 ] { # r -- # } # } # } # } # } # return ans
if num == 0 { # return false # } # # if num == 1 { # return true # } # # for num % 2 == 0 { # num /= 2 # fmt . Println (" STR ", num ) # } # # for num % 3 == 0 { # num /= 3 # fmt . Println (" STR ", num ) # } # # for num % 5 == 0 { # num /= 5 # fmt . Println (" STR ", num ) # } # # return num == 1 #
arr := randomSlice ( 0 , 2 0 , 1 0 ) # gbt := newGBT () # for _ , v := range arr { # gbt . Insert ( uint 3 2 ( v )) # } # checkGBTPostOrder ( t , gbt , arr )
if node == nil { # return # } # preTraversal ( node . Left , which ) # preTraversal ( node . Right , which ) # # if node . Left == nil && node . Right == nil { # if which == 1 { # tree 1 LeafArr = append ( tree 1 LeafArr , node . Val ) # } else { # tree 2 LeafArr = append ( tree 2 LeafArr , node . Val ) # } # } #
var tests = [] struct { # tree * TreeNode # width int # }{ # { newTree ( 1 , 3 , 2 , 5 , 3 , nil , 9 ), 4 }, # { newTree ( 1 , 3 , nil , 5 , 3 ), 2 }, # { newTree ( 1 , 3 , 2 , 5 ), 2 }, # { newTree ( 1 , 3 , 2 , 5 , nil , nil , 9 , 6 , nil , nil , 7 ), 8 }, # } # # for _ , tt := range tests { # width := widthOfBinaryTree ( tt . tree ) # if width != tt . width { # t . Errorf (" STR ", tt . tree , width , tt . width ) # } # }
result := strobogrammaticNumber ( digits , digits ) # sort . Strings ( result ) # # return result
arr := randomSlice ( 0 , 2 0 , 1 0 ) # gbt := newGBT () # for _ , v := range arr { # gbt . Insert ( uint 3 2 ( v )) # } # sort . Ints ( arr ) # key := getRand (). Intn ( len ( arr )- 2 ) + 1 # result := int ( gbt . Predecessor ( gbt . Search ( uint 3 2 ( arr [ key ])), gbt . Root ()).(* gbtElement ). Key ) # if result != arr [ key - 1 ] { # t . Log ( fmt . Sprintf (" STR ", arr [ key ], arr [ key - 1 ], result )) # t . Fail () # }
var tests = [] struct { # nums [] int # moved [] int # }{ # {[] int { 0 , 1 , 0 , 3 , 1 2 }, [] int { 1 , 3 , 1 2 , 0 , 0 }}, # } # # for _ , tt := range tests { # nums := make ([] int , len ( tt . nums )) # copy ( nums , tt . nums ) # # moveZeroes ( tt . nums ) # if reflect . DeepEqual ( tt . nums , tt . moved ) == false { # t . Errorf (" STR ", nums , tt . nums , tt . moved ) # } # }
if len ( heights ) == 0 { # return 0 # } # # stack := make ([] int , 0 ) # maxArea := 0 # for i , height := range heights { # for len ( stack ) > 0 && heights [ stack [ len ( stack )- 1 ]] > height { # top := stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # left := - 1 # if len ( stack ) > 0 { # left = stack [ len ( stack )- 1 ] # } # # area := ( i - left - 1 ) * heights [ top ] # maxArea = int ( math . Max ( float 6 4 ( maxArea ), float 6 4 ( area ))) # } # # stack = append ( stack , i ) # } # # prev , last := - 1 , stack [ len ( stack )- 1 ] # for _ , index := range stack { # area := heights [ index ] * ( last - prev ) # prev = index # maxArea = int ( math . Max ( float 6 4 ( maxArea ), float 6 4 ( area ))) # } # # return maxArea
cases := [] struct { # name string # inputs InputCase # expect [] int # }{ # { # " STR ", # InputCase { # [] int { 1 , 2 , 3 , 4 , 5 }, # 2 , # 4 , # }, # [] int { 1 , 4 , 3 , 2 , 5 }, # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := Solution ( UnmarshalListBySlice ( c . inputs . element ), c . inputs . m , c . inputs . n ) # if ! isEqual ( ret , UnmarshalListBySlice ( c . expect )) { # PrintList ( ret ) # PrintList ( UnmarshalListBySlice ( c . expect )) # t . Fatalf (" STR ", c . expect , ret , c . inputs ) # } # }) # }
res = 0 # s = sum # fall ( root ) # return res
http . HandleFunc (" STR ", index ) # http . HandleFunc (" STR ", welcome ) # http . HandleFunc (" STR ", message ) # server := & http . Server { # Addr : " STR ", # } # log . Println (" STR ") # server . ListenAndServe ()
var total float 6 4 # for _ , v := range o . OrderItems { # total += v . Total () # } # return total
qs := [] question 3 1 8 { # # { # para 3 1 8 {[] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 3 1 8 { 1 6 }, # }, # # { # para 3 1 8 {[] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 3 1 8 { 4 }, # }, # # { # para 3 1 8 {[] string {" STR ", " STR ", " STR ", " STR "}}, # ans 3 1 8 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 1 8 , q . para 3 1 8 # fmt . Printf (" STR ", p , maxProduct 3 1 8 ( p . one )) # } # fmt . Printf (" STR ")
if A . cols != B . cols && A . rows != B . rows { # return errors . New (" STR ") # } # for i := 0 ; i < A . rows ; i ++ { # for j := 0 ; j < A . cols ; j ++ { # A . SetElm ( i , j , A . GetElm ( i , j )- B . GetElm ( i , j )) # } # } # # return nil
r , err := FormatRequest ( Bytes { Start : - 4 0 9 6 , End : - 1 }) # if err != nil { # panic ( err ) # } # fmt . Println ( r )
req , err := http . NewRequest (" STR ", url , nil ) # if err != nil { # return nil , err # } # return Do ( http . DefaultClient , req )
qs := [] question 1 1 6 0 { # # { # para 1 1 6 0 {[] string {" STR ", " STR ", " STR ", " STR "}, " STR "}, # ans 1 1 6 0 { 6 }, # }, # # { # para 1 1 6 0 {[] string {" STR ", " STR ", " STR "}, " STR "}, # ans 1 1 6 0 { 1 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 1 6 0 , q . para 1 1 6 0 # fmt . Printf (" STR ", p , countCharacters ( p . words , p . chars )) # } # fmt . Printf (" STR ")
for _ , element := range array { # tree . root = insert ( tree . root , element ) # } # index := 0 # inorderCopy ( tree . root , array , & index )
s := newStruct () # # e := s . Field (" STR "). Field (" STR ") # # val , ok := e . Value ().( string ) # if ! ok { # t . Error (" STR ") # } # # if val != " STR " { # t . Errorf (" STR ", val ) # } # # defer func () { # err := recover () # if err == nil { # t . Error (" STR ") # } # }() # # _ = s . Field (" STR "). Field (" STR ")
node := root # for node != nil { # if node . Left != nil { # tmp := node . Left # for tmp . Right != nil { # tmp = tmp . Right # } # tmp . Right = node . Right # node . Right = node . Left # node . Left = nil # } # node = node . Right # }
t . r , t . p , t . id = r , p , id # return t
node 6 := ListNode { Val : 6 , Next : nil } # node 5 := ListNode { Val : 5 , Next : & node 6 } # node 4 := ListNode { Val : 4 , Next : & node 5 } # node 3 := ListNode { Val : 3 , Next : & node 4 } # node 2 := ListNode { Val : 2 , Next : & node 3 } # node 1 := ListNode { Val : 1 , Next : & node 2 } # node 2 2 := ListNode { Val : 2 2 , Next : & node 4 } # node 1 1 := ListNode { Val : 1 1 , Next : & node 2 2 } # # fmt . Println ( getIntersectionNode (& node 1 1 , & node 1 ). Val )
for i := 1 ; i <= 2 0 ; i ++ { # addWordLength ( numbers [ i ]) # } # # for i := 2 1 ; i <= 9 9 ; i ++ { # text := spellTens ( i ) # addWordLength ( text ) # } # # addWordLength (" STR " + numbers [ 1 0 0 ]) # # for i := 1 0 1 ; i <= 9 9 9 ; i ++ { # text := spellHundreds ( i ) # addWordLength ( text ) # } # # addWordLength ( numbers [ 1 0 0 0 ]) # # fmt . Println ( length ) #
prev , cur := 0 , 1 # res := 0 # for i := 1 ; i < len ( s ); i ++ { # if s [ i ] == s [ i - 1 ] { # cur ++ # } else { # prev = cur # cur = 1 # } # if prev >= cur { # res ++ # } # } # return res
size := len ( words ) # # masks := make ([] int , size ) # for i := 0 ; i < size ; i ++ { # for _ , b := range words [ i ] { # masks [ i ] |= ( 1 << uint 3 2 ( b -' a ')) # } # } # # var max int # for i := 0 ; i < size - 1 ; i ++ { # for j := i + 1 ; j < size ; j ++ { # if masks [ i ]& masks [ j ] != 0 { # continue # } # temp := len ( words [ i ]) * len ( words [ j ]) # if max < temp { # max = temp # } # } # } # # return max
var h intHeap # if len ( nums ) < k { # h = intHeap ( nums ) # heap . Init (& h ) # } else { # h = intHeap ( nums [: k ]) # heap . Init (& h ) # for i := k ; i < len ( nums ); i ++ { # if nums [ i ] > h . min () { # heap . Pop (& h ) # heap . Push (& h , nums [ i ]) # } # } # } # return KthLargest { # k : k , # h : h , # }
var tests = [] struct { # nums [] int # wiggle [] int # }{ # {[] int { 1 , 5 , 1 , 1 , 6 , 4 }, [] int { 1 , 5 , 1 , 4 , 1 , 6 }}, # {[] int { 1 , 3 , 2 , 2 , 3 , 1 }, [] int { 2 , 3 , 1 , 3 , 1 , 2 }}, # {[] int { 6 , 5 , 4 , 3 , 2 , 1 }, [] int { 3 , 5 , 1 , 4 , 2 , 6 }}, # {[] int { 1 }, [] int { 1 }}, # } # # for _ , tt := range tests { # nums := make ([] int , len ( tt . nums )) # copy ( nums , tt . nums ) # # wiggleSort ( tt . nums ) # if reflect . DeepEqual ( tt . nums , tt . wiggle ) == false { # t . Errorf (" STR ", nums , tt . nums , tt . wiggle ) # } # }
type arg struct { # nums [] int # k int # } # # testCases := [] arg { # { nums : [] int { 3 , 2 , 1 , 5 , 6 , 4 }, k : 2 }, # { nums : [] int { 3 , 2 , 3 , 1 , 2 , 4 , 5 , 5 , 6 }, k : 4 }, # } # # expected := [] int { 5 , 4 } # # for index , data := range testCases { # if res := findKthLargest ( data . nums , data . k ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
if maxLocals > 0 { # localVars := & LocalVariables {} # localVars . table = make ([] Slot , maxLocals ) # return localVars # } # return nil
sum := big . NewInt ( 0 ) # # for _ , str := range numStrs { # n := & big . Int {} # fmt . Sscan ( str , n ) # sum . Add ( sum , n ) # } # # fmt . Println ( sum . String ()[: 1 0 ])
c := NewCircularBuffer ( 1 0 ) # # c . NBPush ( 3 ) # c . NBPush ( 2 ) # c . NBPush ( 1 ) # c . NBPush ( 0 ) # # for i := 0 ; i < 4 ; i ++ { # v := c . Pop ().( int ) # if i != v { # t . Error ( v ) # } # } # # if c . verifyIsEmpty () != true { # t . Error (" STR ") # }
l := & LinkedRev { # Value : " STR ", # Next : nil , # } # for i := 0 ; i < 6 ; i ++ { # nextNode := & LinkedRev { # Value : i , # Next : nil , # } # l . Next = nextNode # l = l . Next # } # return l
cases := [] struct { # name string # inputs * ListNode # expect [] int # }{ # {" STR ", MakeListNode ([] int { 2 , 1 , 5 }), [] int { 5 , 5 , 0 }}, # {" STR ", MakeListNode ([] int { 2 , 7 , 4 , 3 , 5 }), [] int { 7 , 0 , 5 , 5 , 0 }}, # {" STR ", MakeListNode ([] int { 1 , 7 , 5 , 1 , 9 , 2 , 5 , 1 }), [] int { 7 , 9 , 9 , 9 , 0 , 5 , 0 , 0 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if n == 0 || n == 1 { # return n # } # return ( fib ( n - 1 ) + fib ( n - 2 )) % 1 0 0 0 0 0 0 0 0 7
var tests = [] struct { # prices [] int # profit int # }{ # {[] int { 7 , 1 , 5 , 3 , 6 , 4 }, 7 }, # {[] int { 1 , 2 , 3 , 4 , 5 }, 4 }, # {[] int { 7 , 6 , 4 , 3 , 1 }, 0 }, # {[] int { 4 , 6 , 7 , 2 , 8 }, 9 }, # {[] int { 4 , 2 , 6 , 5 , 8 }, 7 }, # {[] int { 1 , 9 }, 8 }, # {[] int { 9 , 9 }, 0 }, # {[] int { 1 }, 0 }, # { nil , 0 }, # } # # for _ , tt := range tests { # profit := maxProfit ( tt . prices ) # if profit != tt . profit { # t . Errorf (" STR ", tt . prices , profit , tt . profit ) # } # }
t . Parallel () # for _ , tc := range testcases { # if result := MinimumTowerRange ( tc . listeners , tc . towers ); result != tc . minRange { # t . Errorf (" STR ", tc . minRange , result ) # } # }
return inorder ( head , head , k , [] int {})
t . Parallel () # # for _ , tc := range testcases { # if result , err := FastFibonnaci ( tc . n ); result != tc . fib || err != tc . err { # t . Errorf (" STR ", tc . n , tc . fib , tc . err , result , err ) # } # }
a := uint 3 2 ( 2 ) # # for i := 0 ; i < b . N ; i ++ { # fast_power ( a , 1 0 0 0 0 0 ) # }
qs := [] question 8 8 0 { # # { # para 8 8 0 {" STR ", 4 1 }, # ans 8 8 0 {" STR "}, # }, # # { # para 8 8 0 {" STR ", 5 5 4 }, # ans 8 8 0 {" STR "}, # }, # # { # para 8 8 0 {" STR ", 1 0 }, # ans 8 8 0 {" STR "}, # }, # # { # para 8 8 0 {" STR ", 5 }, # ans 8 8 0 {" STR "}, # }, # # { # para 8 8 0 {" STR ", 1 }, # ans 8 8 0 {" STR "}, # }, # # { # para 8 8 0 {" STR ", 2 2 2 2 8 0 3 6 9 }, # ans 8 8 0 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 8 0 , q . para 8 8 0 # fmt . Printf (" STR ", p , decodeAtIndex ( p . s , p . k )) # } # fmt . Printf (" STR ")
for i := len ( digits ) - 1 ; i >= 0 ; i -- { # digits [ i ]++ # if digits [ i ] < 1 0 { # break # } # digits [ i ] = 0 # } # if digits [ 0 ] == 0 { # digits = append ([] int { 1 }, digits ...) # } # return digits
number := strconv . FormatInt ( int 6 4 ( value ), base ) # center := int ( len ( number ) / 2 ) # equalNumbers := 0 # for i := 0 ; i < center ; i ++ { # if number [ i ] == number [ len ( number )-( i + 1 )] { # equalNumbers ++ # } else { # return false # } # } # return true
n := len ( temperatures ) # s := make ([] int , n ) # top := - 1 # res := make ([] int , n ) # for i := 0 ; i < n ; i ++ { # for top > - 1 && temperatures [ i ] > temperatures [ s [ top ]] { # res [ s [ top ]] = i - s [ top ] # top -- # } # top ++ # s [ top ] = i # } # return res
node 4 4 := TreeNode { Val : 4 4 } # node 5 0 := TreeNode { Val : 5 0 , Left : & node 4 4 } # node 5 8 := TreeNode { Val : 5 8 , Left : & node 5 0 } # node 3 4 := TreeNode { Val : 3 4 , Right : & node 5 8 } # node 2 7 := TreeNode { Val : 2 7 , Right : & node 3 4 } # # fmt . Println ( minDiffInBST (& node 2 7 ))
target := t . Root ().(* gbtElement ) # n , isNode := node .(* gbtElement ) # if ! isNode { # n = new ( gbtElement ) # n . Key = node .( uint 3 2 ) # n . Left = t . NilNode # n . Right = t . NilNode # n . Parent = t . NilNode # } # for cur := t . Root ().(* gbtElement ); ! t . IsNil ( cur ); { # target = cur # if n . Key < cur . Key { # cur = cur . Left # } else { # cur = cur . Right # } # } # n . Parent = target # if t . IsNil ( target ) { # t . NilNode . Left = n # t . NilNode . Right = n # } else if n . Key < target . Key { # target . Left = n # } else { # target . Right = n # } # # return n
go func ( x int ) { # }( 5 )
sort . Ints ( nums ) # combinationSum 2 Helper ( nums , nil , target , 0 , 0 , & result ) # return result
if ! b . Satisfied { # if b . Length < 0 { # return " STR " invalid response length ") # } # return " STR " + strconv . FormatInt ( b . Length , 1 0 ), nil # } # if ( b . Start < 0 || b . End < 0 ) || # ( b . End < b . Start ) { # return " STR " invalid response range ") # } # s , e := strconv . FormatInt ( b . Start , 1 0 ), strconv . FormatInt ( b . End , 1 0 ) # if b . Length < 0 { # return " STR " + s + " STR " + e + " STR ", nil # } # if ( b . Length < b . Start ) || # ( b . Length < b . End ) { # return " STR " invalid response range ") # } # return " STR " + s + " STR " + e + " STR " + strconv . FormatInt ( b . Length , 1 0 ), nil
var res int # dfs ( root , 0 , & res ) # return res
if ds . count () > 0 { # item := ds . cache [ key ] # return item # } # return ""
var res [][] int # if root == nil { # return res # } # queue := []* TreeNode { root } # var level int = 0 # for len ( queue ) != 0 { # temp := []* TreeNode {} # res = append ( res , [] int {}) # for _ , v := range queue { # res [ level ] = append ( res [ level ], v . Val ) # if v . Left != nil { # temp = append ( temp , v . Left ) # } # if v . Right != nil { # temp = append ( temp , v . Right ) # } # } # level ++ # queue = temp # } # return res
tests := map [ string ] int { # " STR ": 3 , # " STR ": 4 , # " STR ": 9 , # " STR ": 5 8 , # " STR ": 1 9 9 4 , # } # # for in , want := range tests { # got := romanToInt ( in ) # if got != want { # t . Fatalf (" STR ", in , got , want ) # } # }
TemplateBenchmarkExtendedGCD ( b , ExtendedRecursive )
for _ , tc := range testCases { # t . Run ( tc . name , func ( t * testing . T ) { # actual := RecursivePower 1 ( tc . base , tc . power ) # if actual != tc . expected { # t . Errorf (" STR ", tc . base , tc . power , tc . expected , actual ) # } # }) # }
low , high := 1 , maxInArr ( piles ) # for low < high { # mid := low + ( high - low )>> 1 # if ! isPossible ( piles , mid , H ) { # low = mid + 1 # } else { # high = mid # } # } # return low
t . Parallel () # for _ , tc := range testcases { # if result := SwapEvenOddBits ( tc . ui ); result != tc . expected { # t . Errorf (" STR ", tc . ui , tc . expected , result ) # } # }
StoreUint 3 2 (& r . Reg , LoadUint 3 2 (& r . Reg )&^( mask << pos )| value << pos )
dp := make ([] bool , len ( s )+ 1 ) # dp [ 0 ] = true # # for i := 1 ; i <= len ( s ); i ++ { # for j := 0 ; j <= i - 1 ; j ++ { # if dp [ j ] == true { # for _ , word := range wordDict { # if s [ j : i ] == word { # dp [ i ] = true # break # } # } # } # # } # } # return dp [ len ( s )]
if n == 0 { # return " STR " # } # if n == 1 { # return " STR " # } # count := 1 # var r [] byte # s := countAndSay ( n - 1 ) # for i := 1 ; i < len ( s ); i ++ { # if s [ i ] != s [ i - 1 ] { # r = append ( r , [] byte ( strconv . Itoa ( count ))...) # r = append ( r , s [ i - 1 ]) # count = 1 # continue # } # count ++ # } # r = append ( r , [] byte ( strconv . Itoa ( count ))...) # r = append ( r , s [ len ( s )- 1 ]) # return string ( r )
res := x # for res * res > x { # res = ( res + x / res ) / 2 # } # return res
cases := [] struct { # name string # inputs int # expect [] int # }{ # {" STR ", 2 , [] int { 0 , 1 , 1 }}, # {" STR ", 5 , [] int { 0 , 1 , 1 , 2 , 1 , 2 }}, # {" STR ", 1 0 , [] int { 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if len ( obstacleGrid ) == 0 { # return 0 # } # m , n := len ( obstacleGrid )- 1 , len ( obstacleGrid [ 0 ])- 1 # if obstacleGrid [ m ][ n ] == 1 { # return 0 # } # matrix := make ([][] int , m + 1 ) # for i := range matrix { # matrix [ i ] = make ([] int , n + 1 ) # } # for i := 0 ; i <= m ; i ++ { # for j := 0 ; j <= n ; j ++ { # if obstacleGrid [ i ][ j ] == 1 { # continue # } # if i == 0 && j == 0 { # matrix [ i ][ j ] = 1 - obstacleGrid [ 0 ][ 0 ] # } else if i == 0 { # matrix [ i ][ j ] = matrix [ i ][ j - 1 ] # } else if j == 0 { # matrix [ i ][ j ] = matrix [ i - 1 ][ j ] # } else { # matrix [ i ][ j ] = matrix [ i - 1 ][ j ] + matrix [ i ][ j - 1 ] # } # } # } # return matrix [ m ][ n ]
if node 1 == nil && node 2 == nil { # return true # } # # if node 1 == nil || node 2 == nil { # return false # } # # return node 1 . Val == node 2 . Val && # isSame 1 0 1 ( node 1 . Left , node 2 . Right ) && # isSame 1 0 1 ( node 1 . Right , node 2 . Left )
qs := [] question 7 5 3 { # # { # para 7 5 3 { 1 , 2 }, # ans 7 5 3 {" STR "}, # }, # # { # para 7 5 3 { 2 , 2 }, # ans 7 5 3 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 5 3 , q . para 7 5 3 # fmt . Printf (" STR ", p , crackSafe ( p . n , p . k )) # } # fmt . Printf (" STR ")
alphabet := strings . Split (" STR ", " STR ") # valuedAlphabet := make ( map [ string ] int ) # for i := 0 ; i < len ( alphabet ); i ++ { # valuedAlphabet [ alphabet [ i ]] = i + 1 # } # # dat , err := ioutil . ReadFile (" STR ") # if err != nil { # panic ( err ) # } # text := string ( dat ) # text = strings . Replace ( text , " STR ", " STR ", - 1 ) # text = strings . ToLower ( text ) # words := strings . Split ( text , " STR ") # # triangleWords := 0 # var wordLetters [] string # var wordValue int # for i := 0 ; i < len ( words ); i ++ { # wordLetters = strings . Split ( words [ i ], " STR ") # wordValue = 0 # for j := 0 ; j < len ( wordLetters ); j ++ { # wordValue += valuedAlphabet [ wordLetters [ j ]] # } # if isTriangleNumber ( wordValue ) { # triangleWords ++ # } # } # fmt . Println ( triangleWords )
m := len ( dp ) # n := len ( dp [ 0 ]) # if dp [ 0 ][ 0 ] == 1 { # return 0 # } # dp [ 0 ][ 0 ] = 1 # for i := 1 ; i < m ; i ++ { # if dp [ i ][ 0 ] != 1 { # dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ] # } else { # dp [ i ][ 0 ] = 0 # } # } # for i := 1 ; i < n ; i ++ { # if dp [ 0 ][ i ] != 1 { # dp [ 0 ][ i ] = dp [ 0 ][ i - 1 ] # } else { # dp [ 0 ][ i ] = 0 # } # } # for i := 1 ; i < m ; i ++ { # for j := 1 ; j < n ; j ++ { # if dp [ i ][ j ] != 1 { # dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ] # } else { # dp [ i ][ j ] = 0 # } # } # } # return dp [ m - 1 ][ n - 1 ]
head := & ListNode { 0 , nil } # node := head # # for { # if l 1 != nil && l 2 != nil { # if l 1 . Val < l 2 . Val { # node . Next = l 1 # node , l 1 = node . Next , l 1 . Next # } else { # node . Next = l 2 # node , l 2 = node . Next , l 2 . Next # } # } else { # if l 1 == nil { # node . Next = l 2 # } else { # node . Next = l 1 # } # break # } # } # return head . Next
t . Parallel () # for _ , tc := range testcases { # if result := LongestIncreasingSubsequence ( tc . input ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
tmpRets := [][] int {} # if root == nil { # return tmpRets # } # stack := []* TreeNode { root } # for len ( stack ) != 0 { # tmps := []* TreeNode {} # ret := [] int {} # for i := range stack { # ret = append ( ret , stack [ i ]. Val ) # if stack [ i ]. Left != nil { # tmps = append ( tmps , stack [ i ]. Left ) # } # if stack [ i ]. Right != nil { # tmps = append ( tmps , stack [ i ]. Right ) # } # } # tmpRets = append ( tmpRets , ret ) # stack = tmps # } # rets := make ([][] int , len ( tmpRets )) # for i := range tmpRets { # rets [ len ( tmpRets )- 1 - i ] = tmpRets [ i ] # } # return rets
return RecentCounter { # times : make ([] int , 0 , 1 0 0 0 0 ), # }
stack := make ([]* TreeNode , 0 , 1 2 8 ) # res := BSTIterator { # stack : stack , # } # res . push ( root ) # return res
return helper ( convert ( arr ))
node . Val = node . Next . Val # node . Next = node . Next . Next
var res [][] int # if len ( intervals ) == 0 { # return res # } # if len ( intervals ) == 1 { # return intervals # } # sort . Slice ( intervals , func ( i , j int ) bool { # return intervals [ i ][ 0 ] < intervals [ j ][ 0 ] # }) # tmp := intervals [ 0 ] # flag := false # for _ , nums := range intervals [ 1 :] { # if tmp [ 1 ] >= nums [ 0 ] && tmp [ 0 ] <= nums [ 1 ] { # if tmp [ 1 ] < nums [ 1 ] { # tmp [ 1 ] = nums [ 1 ] # } # if tmp [ 0 ] > nums [ 0 ] { # tmp [ 0 ] = nums [ 0 ] # } # flag = true # } else { # res = append ( res , tmp ) # flag = false # tmp = nums # } # } # if flag == true || tmp [ 0 ] == intervals [ len ( intervals )- 1 ][ 0 ] { # res = append ( res , tmp ) # } # return res
if n < 1 { # return false # } # # return 0 != n % 4
c 1 := make ( chan string ) # c 2 := make ( chan string ) # # go func () { # time . Sleep ( time . Second * 1 ) # c 1 <- " STR " # }() # go func () { # time . Sleep ( time . Second * 2 ) # c 2 <- " STR " # }() # # for i := 0 ; i < 2 ; i ++ { # select { # case msg 1 := <- c 1 : # fmt . Println (" STR ", msg 1 ) # case msg 2 := <- c 2 : # fmt . Println (" STR ", msg 2 ) # } # }
if root == nil || root == p || root == q { # return root # } # left := lowestCommonAncestor ( root . Left , p , q ) # right := lowestCommonAncestor ( root . Right , p , q ) # # if left != nil && right != nil { # return root # } # if left != nil { # return left # } # return right
if numRows == 0 { # return nil # } # res := make ([][] int , numRows ) # res [ 0 ] = [] int { 1 } # for i := 1 ; i < numRows ; i ++ { # tmp := make ([] int , i + 1 ) # tmp [ 0 ], tmp [ i ] = 1 , 1 # for j := 1 ; j < i ; j ++ { # tmp [ j ] = res [ i - 1 ][ j - 1 ] + res [ i - 1 ][ j ] # } # res [ i ] = tmp # } # return res
max 1 , max 2 , max 3 := math . MinInt 6 4 , math . MinInt 6 4 , math . MinInt 6 4 # for _ , n := range nums { # if n == max 1 || n == max 2 { # continue # } # # switch { # case max 1 < n : # max 3 , max 2 , max 1 = max 2 , max 1 , n # case max 2 < n : # max 3 , max 2 = max 2 , n # case max 3 < n : # max 3 = n # } # } # # if max 3 == math . MinInt 6 4 { # return max 1 # } # # return max 3
if len ( nums ) < 2 { # return len ( nums ) # } # const BEGIN , UP , DOWN = 0 , 1 , 2 # STATE , maxLength := BEGIN , 1 # # for i := 1 ; i < len ( nums ); i ++ { # switch STATE { # case BEGIN : # if nums [ i - 1 ] < nums [ i ] { # STATE = UP # maxLength ++ # } else if nums [ i - 1 ] > nums [ i ] { # STATE = DOWN # maxLength ++ # } # case UP : # if nums [ i - 1 ] > nums [ i ] { # STATE = DOWN # maxLength ++ # } # case DOWN : # if nums [ i - 1 ] < nums [ i ] { # STATE = UP # maxLength ++ # } # } # } # return maxLength
fmt . Println ( containsNearbyDuplicate ([] int { 1 , 0 , 1 , 1 }, 1 ))
var res = & ListNode {} # cur := res # for { # if l 1 != nil { # cur . Val += l 1 . Val # l 1 = l 1 . Next # } # # if l 2 != nil { # cur . Val += l 2 . Val # l 2 = l 2 . Next # } # # if l 1 == nil && l 2 == nil { # break # } # # cur . Next = & ListNode {} # cur = cur . Next # } # # cur = res # for cur != nil { # if cur . Val >= 1 0 { # if cur . Next == nil { # cur . Next = & ListNode {} # } # # cur . Val = cur . Val - 1 0 # cur . Next . Val ++ # } # # cur = cur . Next # } # # return res
t . Parallel () # for _ , tc := range testcases { # if result , _ := Solver ( tc . board , tc . n ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
n = n / 2 # return 8 * n *( n + 1 )*( 2 * n + 1 )/ 3 + 2 * n *( n + 1 ) + 4 * n + 1
if name == "" { # return false # } # c := name [ 0 ] # return " STR " <= c && c <= " STR " || " STR " <= c && c <= " STR " || " STR " <= c && c <= " STR " || c == " STR " || c == " STR " || c == " STR " || c >= utf 8 . RuneSelf
var result [] Pair # for i , first := range words { # for j , second := range words { # if i == j { # continue # } # combined := first + second # if isPalindrome ( combined ) { # result = append ( result , Pair { i , j }) # } # } # } # return result
increasing , decreasing := true , true # for i := 1 ; i < len ( A ); i ++ { # if A [ i ] > A [ i - 1 ] { # decreasing = false # } # if A [ i ] < A [ i - 1 ] { # increasing = false # } # } # return increasing || decreasing
sort . Ints ( nums ) # res := [][] int {} # var dfs func ( int , [] int ) # dfs = func ( index int , tmp [] int ) { # t := make ([] int , len ( tmp )) # copy ( t , tmp ) # res = append ( res , t ) # # for i := index ; i < len ( nums ); i ++ { # if i == index || nums [ i ] != nums [ i - 1 ] { # dfs ( i + 1 , append ( tmp , nums [ i ])) # } # } # } # # dfs ( 0 , make ([] int , 0 , len ( nums ))) # return res
p . work <- w
if len ( nums ) == 0 { # return 0 # } # p := 1 # for q := 1 ; q < len ( nums ); q ++ { # if nums [ q - 1 ] != nums [ q ] { # nums [ p ] = nums [ q ] # p ++ # } # } # return p
w := checkWriter ( writer ) # writeId ( w , event . Id ) # writeEvent ( w , event . Event ) # writeRetry ( w , event . Retry ) # return writeData ( w , event . Data )
if len ( A ) <= 1 { # return true # } # if A [ 0 ] < A [ 1 ] { # return inc ( A [ 1 :]) # } # if A [ 0 ] > A [ 1 ] { # return dec ( A [ 1 :]) # } # return inc ( A [ 1 :]) || dec ( A [ 1 :])
m := len ( matrix ) # if m == 0 { # return false # } # # n := len ( matrix [ 0 ]) # if n == 0 { # return false # } # # if target < matrix [ 0 ][ 0 ] || target > matrix [ m - 1 ][ n - 1 ] { # return false # } # # r := 0 # for r < m && matrix [ r ][ 0 ] <= target { # r ++ # } # r -- # # i , j := 0 , n - 1 # for i <= j { # middle := ( i + j ) / 2 # if matrix [ r ][ middle ] == target { # return true # } else if matrix [ r ][ middle ] > target { # j = middle - 1 # } else { # i = middle + 1 # } # } # return false
size := len ( A ) # # indexs := make ([] int , 0 , size ) # for i , val := range A { # if val == 1 { # indexs = append ( indexs , i ) # } # } # # count := len ( indexs ) # # if count == 0 { # return [] int { 0 , 2 } # } # # if count % 3 != 0 { # return noPossible # } # # c 1 , c 2 := count / 3 , count / 3 * 2 # s 0 , s 1 , s 2 := indexs [ 0 ], indexs [ c 1 ], indexs [ c 2 ] # # for s 2 < size && # A [ s 0 ] == A [ s 1 ] && # A [ s 1 ] == A [ s 2 ] { # s 0 ++ # s 1 ++ # s 2 ++ # } # # if s 2 == size { # return [] int { s 0 - 1 , s 1 } # } # # return noPossible
for i := 0 ; i < len ( input )/ 2 ; i ++ { # if input [ i ] != input [ len ( input )- 1 - i ] { # return false # } # } # return true
t . Parallel () # for _ , tc := range testcases { # if result := Itinerary ( tc . segments , tc . start ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
pairs := [...][ 2 ] int {{ 1 1 1 , 1 1 1 }, { 7 3 3 7 , 7 3 3 7 }, { 9 0 6 6 0 9 , 9 0 6 6 0 9 }} # for _ , pair := range pairs { # in , out := pair [ 0 ], int ( pair [ 1 ]) # if x := reverse ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # } # }
benchmarkHashMapGet ( b , newChainedHashMap ())
return q . len
p . X *= factor # p . Y *= factor
ans , dst := 0 , make ([] int , len ( heights )) # copy ( dst , heights ) # sort . Ints ( dst ) # for i , v := range dst { # if heights [ i ] != v { # ans ++ # } # } # return ans
t . Parallel () # for _ , tc := range testcases { # if angle := AngleClockHands ( tc . hh , tc . mm ); angle != tc . angle { # t . Errorf (" STR ", tc . angle , angle ) # } # }
if head == nil { # return head # } # # end := head # for end . Next != nil { # end = end . Next # } # # return helper 1 4 8 ( head , end )
return list . head
var tests = [] struct { # citations [] int # h int # }{ # { nil , 0 }, # {[] int { 1 }, 1 }, # {[] int { 1 , 1 }, 1 }, # {[] int { 3 , 0 , 6 , 1 , 5 }, 3 }, # } # # for _ , tt := range tests { # h := hIndex ( tt . citations ) # if h != tt . h { # t . Errorf (" STR ", tt . citations , h , tt . h ) # } # }
return uint 3 2 ( i )
if node == nil { # return # } # # if node . Left != nil && node . Left . Left == nil && node . Left . Right == nil { # * sum += node . Left . Val # } # traverse ( node . Left , sum ) # traverse ( node . Right , sum )
fmt . Println ( removeElement 1 ([] int { 3 , 2 , 2 , 3 }, 3 )) # fmt . Println ( removeElement 2 ([] int { 0 , 1 , 2 , 2 , 3 , 0 , 4 , 2 }, 2 ))
record := make ( map [ int ] bool , len ( nums )) # for _ , n := range nums { # if _ , found := record [ n ]; found { # return true # } # record [ n ] = true # } # return false
var c Contact # err := json . Unmarshal ([] byte ( JSON ), & c ) # if err != nil { # log . Println (" STR ", err ) # return # } # # fmt . Println ( c )
var b bytes . Buffer # for _ , expr := range n . Exprs { # b . WriteString ( fmt . Sprintf (" STR ", expr )) # } # # return b . String ()
if len ( s ) == 0 { # return s # } # # vowels := " STR " # chars := [] rune ( s ) # # for start , end := 0 , len ( chars )- 1 ; start < end ; { # for start < end && ! strings . ContainsRune ( vowels , chars [ start ]) { # start ++ # } # # for start < end && ! strings . ContainsRune ( vowels , chars [ end ]) { # end -- # } # # chars [ start ], chars [ end ] = chars [ end ], chars [ start ] # start ++ # end -- # } # return string ( chars )
var nums [] int # var ret int # # nums = [] int { 3 , 2 , 3 } # ret = 3 # if ret != majorityElement ( nums ) { # t . Fatalf (" STR ", ret ) # } # # nums = [] int { 2 , 2 , 1 , 1 , 1 , 2 , 2 } # ret = 2 # if ret != majorityElement ( nums ) { # t . Fatalf (" STR ", ret ) # } # # nums = [] int {} # ret = 0 # if ret != majorityElement ( nums ) { # t . Fatalf (" STR ", ret ) # }
for m := 3 0 ; m > 1 ; m -- { # for n := m - 1 ; n > 0 ; n -- { # a , b , c := ( m * m )-( n * n ), 2 * m * n , ( m * m )+( n * n ) # if a + b + c == 1 0 0 0 { # fmt . Printf (" STR ", a , b , c ) # fmt . Println ( a * b * c ) # break # } # } # }
qs := [] question 7 4 6 { # # { # para 7 4 6 {[] int { 1 0 , 1 5 , 2 0 }}, # ans 7 4 6 { 1 5 }, # }, # # { # para 7 4 6 {[] int { 1 , 1 0 0 , 1 , 1 , 1 , 1 0 0 , 1 , 1 , 1 0 0 , 1 }}, # ans 7 4 6 { 6 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 4 6 , q . para 7 4 6 # fmt . Printf (" STR ", p , minCostClimbingStairs ( p . c )) # } # fmt . Printf (" STR ")
for _ , test := range [] struct { expr , wantErr string }{ # {" STR ", " STR "}, # {" STR ", " STR "}, # {" STR ", " STR "}, # {`" STR "`, " STR "'"}, # {" STR ", ` unknown function " STR "`}, # {" STR ", " STR "}, # } { # expr , err := Parse ( test . expr ) # if err == nil { # vars := make ( map [ Var ] bool ) # err = expr . Check ( vars ) # if err == nil { # t . Errorf (" STR ", test . expr ) # continue # } # } # fmt . Printf (" STR ", test . expr , err ) # if err . Error () != test . wantErr { # t . Errorf (" STR ", err , test . wantErr ) # } # }
t . Fail () # t . Logf (" STR ", " STR ")
return uint 3 2 ( int ( p . a )* n + int ( p . b )* n )
used = make ([] bool , 1 0 ) # for i := range used { # used [ i ] = false # } # remaining := 9 9 9 9 9 9 # perm := 1 # index := 0 # for i := 9 ; i > 0 ; i -- { # perm = 1 # for j := i ; j > 0 ; j -- { # perm *= j # } # index = remaining / perm # remaining = remaining % perm # j := 0 # for j = 0 ; j < index || used [ j ]; j ++ { # if used [ j ] { # index ++ # } # } # used [ j ] = true # print ( j ) # } # println ( remaining )
b := [] byte {' 1 '} # for n > 1 { # b = say ( b ) # n -- # } # return string ( b )
if ! lq . Empty () { # element := lq . queue . Front () # lq . queue . Remove ( element ) # # return nil # } # # return fmt . Errorf (" STR ")
if e . p != e { # e . p = FindSet ( e . p ) # } # return e . p
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 3 , 2 , 3 }, 3 }, # {" STR ", [] int { 2 , 2 , 1 , 1 , 1 , 2 , 2 }, 2 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := majorityElement 3 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if len ( s 1 ) > len ( s 2 ) { # s 1 , s 2 = s 2 , s 1 # } # # n 1 , n 2 := len ( s 1 ), len ( s 2 ) # a 1 , a 2 := [] byte ( s 1 ), [] byte ( s 2 ) # # carry := byte ( 0 ) # # buf := make ([] byte , n 2 + 1 ) # buf [ 0 ] = ' 1 ' # # i := 1 # for i <= n 2 { # if i <= n 1 { # buf [ n 2 + 1 - i ] = a 1 [ n 1 - i ] - ' 0 ' # } # buf [ n 2 + 1 - i ] += a 2 [ n 2 - i ] + carry # # if buf [ n 2 + 1 - i ] > ' 9 ' { # buf [ n 2 + 1 - i ] -= 1 0 # carry = byte ( 1 ) # } else { # carry = byte ( 0 ) # } # # i ++ # } # # if carry == 1 { # return string ( buf ) # } # return string ( buf [ 1 :])
t . Parallel () # for _ , tc := range testcases { # if itinerary , price := CheapestItinerary ( tc . flights , tc . origin , # tc . destination , tc . connections ); ! reflect . DeepEqual ( tc . itinerary , itinerary ) || # tc . cost != price { # t . Errorf (" STR ", tc . itinerary , tc . cost , itinerary , price ) # } # }
qs := [] question 7 0 4 { # # { # para 7 0 4 {[] int {- 1 , 0 , 3 , 5 , 9 , 1 2 }, 9 }, # ans 7 0 4 { 4 }, # }, # # { # para 7 0 4 {[] int {- 1 , 0 , 3 , 5 , 9 , 1 2 }, 2 }, # ans 7 0 4 {- 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 0 4 , q . para 7 0 4 # fmt . Printf (" STR ", p , search 7 0 4 ( p . nums , p . target )) # } # fmt . Printf (" STR ")
tests := [...] testType { # { # in : " STR ", # want : [][] int { # { 3 , 6 }, # }, # }, # { # in : " STR ", # want : [][] int {}, # }, # { # in : " STR ", # want : [][] int { # { 3 , 5 }, # { 6 , 9 }, # { 1 2 , 1 4 }, # }, # }, # { # in : " STR ", # want : [][] int { # { 3 , 5 }, # }, # }, # } # for _ , tt := range tests { # got := largeGroupPositions ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
value := 6 0 0 8 5 1 4 7 5 1 4 3 # for i := 2 ; i < value / 2 ; i ++ { # if value % i == 0 { # value /= i # } # } # fmt . Println ( value )
t := newTokenizer ( pos , fset , value ) # expr , err := parseConstExpr ( t , precedenceLowest ) # t . Next () # if t . curToken != token . EOF { # return nil , & scanner . Error { # Pos : t . fset . Position ( t . curPos ), # Msg : " STR " + t . curToken . String () + " STR ", # } # } # return expr , err
return 4 *( n - 1 )*( n - 1 ) + 4 *( a + b + c - 1 )*( n - 1 ) + 2 *( a * b + a * c + b * c )
node . prev = this . head # node . next = this . head . next # this . head . next . prev = node # this . head . next = node
var div 3 or 5 [] int # # for i := 1 ; i < 1 0 0 0 ; i ++ { # # if i % 3 == 0 || i % 5 == 0 { # # div 3 or 5 = append ( div 3 or 5 , i ) # # } # # } # # var sum int # # for _ , num := range div 3 or 5 { # sum += num # } # # fmt . Println ( sum ) #
res := [][] int {} # # recur ( nums , [] int {}, & res ) # # return res
index , indexAns := 0 , 0 # for index < len ( chars ) { # currentChar := chars [ index ] # count := 0 # for index < len ( chars ) && chars [ index ] == currentChar { # index ++ # count ++ # } # chars [ indexAns ] = currentChar # indexAns ++ # if 1 != count { # for _ , v := range [] byte ( strconv . Itoa ( count )) { # chars [ indexAns ] = v # indexAns ++ # } # } # } # return indexAns
if rpcQueueSize <= 0 && flushInterval <= 0 { # rpcQueueSize = 1 # } # if dialTimeout == 0 { # dialTimeout = 1 0 * time . Second # } # res = & Conf { # ZkRoot : zkRoot , # Zkquorum : zkquorum , # Master : master , # Meta : meta , # ZkTimeout : zkTimeout , # RpcQueueSize : rpcQueueSize , # FlushInterval : flushInterval , # DialTimeout : dialTimeout , # } # # return
if len ( heights ) == 0 { # return 0 # } # heights = append ( heights , 0 ) # maxArea := 0 # stack := [] int { 0 } # for i := 1 ; i < len ( heights ); i ++ { # if heights [ i ] < heights [ stack [ len ( stack )- 1 ]] { # j := len ( stack ) - 1 # for ; j >= 0 ; j -- { # if heights [ stack [ j ]] < heights [ i ] { # break # } # var width int # if j == 0 { # width = i # } else { # width = i - stack [ j - 1 ] - 1 # } # area := width * heights [ stack [ j ]] # if area > maxArea { # maxArea = area # } # } # stack = stack [: j + 1 ] # } # stack = append ( stack , i ) # } # return maxArea
in , out := 2 0 0 , 7 3 6 8 2 # if x := p 3 1 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # }
qs := [] question 5 6 6 { # # { # para 5 6 6 {[][] int {{ 1 , 2 }, { 3 , 4 }}, 1 , 4 }, # ans 5 6 6 {[][] int {{ 1 , 2 , 3 , 4 }}}, # }, # # { # para 5 6 6 {[][] int {{ 1 , 2 }, { 3 , 4 }}, 2 , 4 }, # ans 5 6 6 {[][] int {{ 1 , 2 }, { 3 , 4 }}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 6 6 , q . para 5 6 6 # fmt . Printf (" STR ", p , matrixReshape ( p . nums , p . r , p . c )) # } # fmt . Printf (" STR ")
x := s . stack [ len ( s . stack )- 1 ] # s . stack [ len ( s . stack )- 1 ] = nil # s . stack = s . stack [: len ( s . stack )- 1 ] # return x
swapCount := 1 # for swapCount > 0 { # swapCount = 0 # for itemIndex := 0 ; itemIndex < len ( array )- 1 ; itemIndex ++ { # if array [ itemIndex ] > array [ itemIndex + 1 ] { # array [ itemIndex ], array [ itemIndex + 1 ] = array [ itemIndex + 1 ], array [ itemIndex ] # swapCount += 1 # } # } # }
nums := merge ( nums 1 , nums 2 ) # n := len ( nums ) # m := n / 2 # if n % 2 == 0 { # return float 6 4 ( nums [ m - 1 ]+ nums [ m ]) / 2 # } # return float 6 4 ( nums [ m ])
p := person {" STR ", " STR "} # e := employee ( p ) # fmt . Println ( e ) #
if l . Len () == 0 { # return errors . New (" STR ") # } # # if l . Head . Value == value { # l . Head = l . Head . Next # l . Length -- # return nil # } # # found := 0 # for n := l . Head ; n != nil ; n = n . Next { # # if * n . Value .(* Node ) == value && found == 0 { # n . Next . Prev , n . Prev . Next = n . Prev , n . Next # l . Length -- # found ++ # } # } # # if found == 0 { # return errors . New (" STR ") # } # # return nil
n := len ( mx ) # if n == 0 { # return [] int {} # } # if n <= 1 { # return mx [ 0 ] # } # m := len ( mx [ 0 ]) # ret := make ([] int , m * n ) # idx , max := 0 , m * n # for i := 0 ; idx < max ; i ++ { # for j := i ; j < m - i && idx < max ; j ++ { # ret [ idx ] = mx [ i ][ j ] # idx ++ # } # for j := i + 1 ; j < n - i && idx < max ; j ++ { # ret [ idx ] = mx [ j ][ m - i - 1 ] # idx ++ # } # for j := m - i - 2 ; j >= i && idx < max ; j -- { # ret [ idx ] = mx [ n - i - 1 ][ j ] # idx ++ # } # for j := n - i - 2 ; j > i && idx < max ; j -- { # ret [ idx ] = mx [ j ][ i ] # idx ++ # } # } # return ret
fmt . Println ( countBinarySubstrings (" STR "))
i , n := 0 , len ( nums ) # for i < n { # if nums [ i ] == val { # n -- # nums [ i ] = nums [ n ] # } else { # i ++ # } # } # return n
if ! ok { # panic (" STR " + typ ) # }
return helper ( input , map [ string ][] int {})
var maxStreak , current int # # for _ , r := range tree { # switch r { # case '(': # current ++ # case ')': # current -- # } # # if current > maxStreak { # maxStreak = current # } # } # # return maxStreak
result := MakeMatrix ( make ([] float 6 4 , A . cols * A . rows ), A . cols , A . rows ) # # for i := 0 ; i < A . rows ; i ++ { # for j := 0 ; j < A . cols ; j ++ { # result . SetElm ( i , j , A . GetElm ( i , j )- B . GetElm ( i , j )) # } # } # # return result
if left == nil && right == nil { # return true # } # if left == nil || right == nil { # return left == right # } # # if left . Val != right . Val { # return false # } # return isSymmetricHelper ( left . Left , right . Right ) && # isSymmetricHelper ( left . Right , right . Left )
if len ( arr ) == 0 { # return arr # } # # res := make ([] int , 0 , len ( arr )- 1 ) # for j := 0 ; j < len ( arr ); j ++ { # if j == i { # continue # } # res = append ( res , arr [ j ]) # } # # return res
switch v . Kind () { # case reflect . Invalid : # return " STR " # case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , # reflect . Int 3 2 , reflect . Int 6 4 : # return strconv . FormatInt ( v . Int (), 1 0 ) # case reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , # reflect . Uint 3 2 , reflect . Uint 6 4 , reflect . Uintptr : # return strconv . FormatUint ( v . Uint (), 1 0 ) # case reflect . Bool : # return strconv . FormatBool ( v . Bool ()) # case reflect . String : # return strconv . Quote ( v . String ()) # case reflect . Chan , reflect . Func , reflect . Ptr , reflect . Slice , reflect . Map : # return v . Type (). String () + " STR " + # strconv . FormatUint ( uint 6 4 ( v . Pointer ()), 1 6 ) # default : # return v . Type (). String () + " STR " # }
var x int # var ret bool = true # # x = - 1 # fmt . Printf (" STR ", x , isPalindrome ( x )) # if isPalindrome ( x ) == ret { # t . Fatalf (" STR ", ret ) # } # # x = 1 2 1 # fmt . Printf (" STR ", x , isPalindrome ( x )) # if isPalindrome ( x ) != ret { # t . Fatalf (" STR ", ret ) # } # # x = 1 2 3 # fmt . Printf (" STR ", x , isPalindrome ( x )) # if isPalindrome ( x ) == ret { # t . Fatalf (" STR ", ret ) # } # # x = 1 2 2 1 # fmt . Printf (" STR ", x , isPalindrome ( x )) # if isPalindrome ( x ) != ret { # t . Fatalf (" STR ", ret ) # }
h := new ( linkedHeap ) # h . linkedHeapList = linkedHeapList {} # h . linkedHeapList . Init () # h . heap . binHeapArrayIf = & h . linkedHeapList # return h
qs := [] question 3 7 8 { # # { # para 3 7 8 {[][] int {{ 1 , 5 , 9 }, { 1 0 , 1 1 , 1 3 }, { 1 2 , 1 3 , 1 5 }}, 8 }, # ans 3 7 8 { 1 3 }, # }, # # { # para 3 7 8 {[][] int {{ 1 , 5 , 7 }, { 1 1 , 1 2 , 1 3 }, { 1 2 , 1 3 , 1 5 }}, 3 }, # ans 3 7 8 { 9 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 7 8 , q . para 3 7 8 # fmt . Printf (" STR ", p , kthSmallest 3 7 8 ( p . matrix , p . k )) # } # fmt . Printf (" STR ")
h . Lock () # defer h . Unlock () # if h . Len () == 0 { # return # } # # el = h . data [ 0 ] # last := h . data [ h . Len ()- 1 ] # if h . Len () == 1 { # h . data = nil # return # } # # h . data = append ([] Item { last }, h . data [ 1 : h . Len ()- 1 ]...) # h . siftDown () # # return
m := make ( map [ int ] int ) # maxend := 0 # for i := 0 ; i < len ( wall ); i ++ { # sum := 0 # for j := 0 ; j + 1 < len ( wall [ i ]); j ++ { # sum += wall [ i ][ j ] # if v , ok := m [ sum ]; ok { # m [ sum ] = v + 1 # } else { # m [ sum ] = 1 # } # maxend = max ( maxend , m [ sum ]) # } # } # return len ( wall ) - maxend
for i , temp , n := 0 , 0 , len ( matrix )- 1 ; i <= n / 2 ; i ++ { # for j := i ; j < n - i ; j ++ { # temp = matrix [ j ][ n - i ] # matrix [ j ][ n - i ] = matrix [ i ][ j ] # matrix [ i ][ j ] = matrix [ n - j ][ i ] # matrix [ n - j ][ i ] = matrix [ n - i ][ n - j ] # matrix [ n - i ][ n - j ] = temp # } # }
return Client { # url_ : url_ , # hc : & http . Client { # Transport : & http . Transport { # Proxy : opts . Proxy , # TLSClientConfig : & tls . Config { # InsecureSkipVerify : true , # ServerName : opts . ServerName , # }, # DisableKeepAlives : ! opts . AllowKeepAlive , # }, # }, # }
ans , rx , ry , left , up := 0 , - 1 , - 1 , [ 8 ] int {}, [ 8 ] int {} # for i , row := range board { # for j , v := range row { # if rx == - 1 { # if v == ' p ' { # left [ i ], up [ j ] = 1 , 1 # } else if v == ' B ' { # left [ i ], up [ j ] = 0 , 0 # } else if v == ' R ' { # ans , rx , ry = left [ i ]+ up [ j ], i , j # } # } else if i == rx { # if v == ' p ' { # ans ++ # } # if v != '.' { # break # } # } else if j == ry { # if v == ' p ' { # ans ++ # } # if v != '.' { # return ans # } # } # } # } # return ans
fmt . Println ( wordBreak (" STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR "}))
tail := 0 # for i := 0 ; i < len ( nums ); i ++ { # if nums [ i ] != val { # nums [ tail ] = nums [ i ] # tail ++ # } # } # return tail
t . Parallel () # # var sloth Sloth # # var industrious Industrious # # if msg := AskPolymorph ( sloth ); msg != slothMsg { # t . Errorf (" STR ", msg , slothMsg ) # } # # if msg := AskPolymorph ( industrious ); msg != industriousMsg { # t . Errorf (" STR ", msg , industriousMsg ) # }
fmt . Println (" STR ") # fmt . Print (" STR ") # fmt . Print (" STR ") # fmt . Print (" STR ") # fmt . Printf (" STR ", 4 )
cases := [] struct { # name string # inputs * TreeNode # sum int # expect bool # }{ # {" STR ", # & TreeNode { Val : 5 , # Left : & TreeNode { Val : 4 , Left : nil , Right : nil }, # Right : & TreeNode { Val : 8 , Left : nil , Right : nil }, # }, # 9 , # true , # }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := hasPathSum ( c . inputs , c . sum ) # fmt . Println ( got ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
min := func ( a , b int ) int { # return int ( math . Min ( float 6 4 ( a ), float 6 4 ( b ))) # } # # max := func ( a , b int ) int { # return int ( math . Max ( float 6 4 ( a ), float 6 4 ( b ))) # } # # dp := make ([] int , len ( days )+ 1 ) # for i := range days { # dp [ i + 1 ] = dp [ i ] + costs [ 0 ] # for j := max ( 0 , i - 6 ); j <= i ; j ++ { # if days [ i ]- days [ j ] < 7 { # dp [ i + 1 ] = min ( dp [ i + 1 ], dp [ j ]+ costs [ 1 ]) # break # } # } # # for j := max ( 0 , i - 2 9 ); j <= i ; j ++ { # if days [ i ]- days [ j ] < 3 0 { # dp [ i + 1 ] = min ( dp [ i + 1 ], dp [ j ]+ costs [ 2 ]) # break # } # } # } # # return dp [ len ( days )]
args := make ([] string , len ( n . Args )) # for i , arg := range n . Args { # args [ i ] = fmt . Sprintf (" STR ", arg ) # } # # return fmt . Sprintf (" STR ", n . Func , strings . Join ( args , " STR "))
if n == 0 { # return 1 # } # if n < 0 { # return 0 # } # # if n < tablesize && table [ n ] != 0 { # return table [ n ] # } # # sum := 0 # # for k := 1 ; k <= n && ( f ( n , k ) >= 0 || g ( n , k ) >= 0 ); k ++ { # var summand int # if k % 2 == 0 { # summand = - 1 # } else { # summand = 1 # } # # summand *= P ( f ( n , k )) + P ( g ( n , k )) # # sum += summand # } # # if n < tablesize { # table [ n ] = ( sum + 1 0 * mod ) % mod # } # # return ( sum + mod ) % mod
data := & Node { data : i } # if list . head == nil { # list . head = data # list . tail = data # return # } # if list . tail != nil { # list . tail . next = data # data . prev = list . tail # } # list . tail = data
cases := [] struct { # name string # actions [] string # inputs [] int # expect [] int # }{ # {" STR ", [] string { push , push , push , getMin , pop , top , getMin }, [] int {- 2 , 0 , - 3 , 0 , 0 , 0 , 0 }, [] int {- 3 , 0 , - 2 }}, # {" STR ", [] string { push , push , getMin , top , pop , push , getMin , top }, [] int { 1 , 2 , 0 , 0 , 0 , - 2 , 0 , 0 }, [] int { 1 , 2 , - 2 , - 2 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . actions , c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . actions , c . inputs ) # } # }) # }
sResultBytes := [] byte {} # tResultBytes := [] byte {} # for i := 0 ; i < len ( S ); i ++ { # if S [ i ] != '#' { # sResultBytes = append ( sResultBytes , S [ i ]) # continue # } # if len ( sResultBytes ) > 0 { # sResultBytes = sResultBytes [: len ( sResultBytes )- 1 ] # } # } # for i := 0 ; i < len ( T ); i ++ { # if T [ i ] != '#' { # tResultBytes = append ( tResultBytes , T [ i ]) # continue # } # if len ( tResultBytes ) > 0 { # tResultBytes = tResultBytes [: len ( tResultBytes )- 1 ] # } # } # # return string ( sResultBytes ) == string ( tResultBytes )
tbl := [] brfmt { # {" STR ", [] Bytes {{ 0 , 0 , - 1 , false }}, ""}, # {" STR ", [] Bytes {{ 0 , 1 2 0 0 , 0 , true }}, ""}, # {" STR ", [] Bytes {{- 1 , - 1 , 0 , true }}, ""}, # {" STR ", [] Bytes {{ 1 2 0 0 , 0 , 0 , true }}, ""}, # } # for _ , f := range tbl { # f := f # t . Run ( f . Name , func ( t * testing . T ) { # t . Parallel () # _ , err := FormatResponse ( f . In [ 0 ]) # if err == nil { # t . Error (" STR ") # } # }) # }
max := arr [ 0 ] # for i := 0 ; i < len ( arr ); i ++ { # if arr [ i ] > max { # max = arr [ i ] # } # } # countArr := make ([] int , max ) # for _ , v := range arr { # countArr [ v - 1 ]++ # } # var newArr [] int # for i := 0 ; i < len ( countArr ); i ++ { # countIndex := countArr [ i ] # for countIndex > 0 { # newArr = append ( newArr , i + 1 ) # countIndex -- # } # } # return newArr
q . lock . Lock () # defer q . lock . Unlock () # # return q . queue [ 0 ]
var ret [] string # for i := 0 ; i < len ( nums ); i ++ { # j := i + 1 # for j < len ( nums ) { # if nums [ j ]- nums [ i ] != j - i { # break # } # j ++ # } # if j --; j == i { # ret = append ( ret , fmt . Sprintf (" STR ", nums [ i ])) # } else { # ret = append ( ret , fmt . Sprintf (" STR ", nums [ i ], nums [ j ])) # } # i = j # } # return ret
lruCache := LRUCache { # capacity : capacity , # cache : make ( map [ int ]* LRUCacheListNode ), # head : & LRUCacheListNode {}, # tail : & LRUCacheListNode {}, # } # # lruCache . head . next = lruCache . tail # lruCache . tail . prev = lruCache . head # # return lruCache
return strings . ToLower ( str )
if x == 0 { # return 0 # } # left , right , res := 1 , x , 0 # for left <= right { # mid := left + (( right - left ) >> 1 ) # if mid < x / mid { # left = mid + 1 # res = mid # } else if mid == x / mid { # return mid # } else { # right = mid - 1 # } # } # return res
m := make ( map [ int ] int ) # for i := 0 ; i < len ( nums ); i ++ { # c , ok := m [ nums [ i ]] # if ok { # r := [] int { c , i } # return r # } else { # m [ target - nums [ i ]] = i # } # } # r := [] int { 0 , 0 } # return r
str := " STR " # max := 0 # for i := 0 ; i < 9 8 7 ; i ++ { # prod := 1 # for j := i ; j <= i + 1 2 ; j ++ { # l , _ := strconv . Atoi ( string ( str [ j ])) # prod = prod * l # } # if prod > max { # max = prod # } # } # fmt . Println ( max )
maxarea , l , r := 0 , 0 , len ( height )- 1 # for l < r { # maxarea = max ( maxarea , min ( height [ l ], height [ r ])*( r - l )) # if height [ l ] < height [ r ] { # l ++ # } else { # r -- # } # } # return maxarea
this . stack 1 . PushBack ( value )
if len ( p . stack ) == 0 { # p . rtotal = 1 # } # t := & token { kind : " STR ", size : - p . rtotal } # p . tokens = append ( p . tokens , t ) # p . stack = append ( p . stack , t ) # p . string (" STR ")
low , high := int 6 4 ( 0 ), int 6 4 ( 1 * 1 e 1 4 ) # for low < high { # mid := low + ( high - low )>> 1 # if calNthMagicalCount ( mid , int 6 4 ( A ), int 6 4 ( B )) < int 6 4 ( N ) { # low = mid + 1 # } else { # high = mid # } # } # return int ( low ) % 1 0 0 0 0 0 0 0 0 7
qs := [] question 8 1 9 { # # { # para 8 1 9 {" STR ", [] string {" STR "}}, # ans 8 1 9 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 1 9 , q . para 8 1 9 # fmt . Printf (" STR ", p , mostCommonWord ( p . one , p . b )) # } # fmt . Printf (" STR ")
tw := TextWriter {} # l := Logger {" STR "} # l . Log ( tw )
list := list . New () # return & Stack { list }
cnt := make ( map [ int ] int ) # for _ , v := range deck { # cnt [ v ]++ # } # # var size int # for _ , n := range cnt { # size = gcd ( n , size ) # } # return size >= 2
go regularFunction ( 5 )
return ExamRoom { # l : [] int {}, # n : N , # }
if tree == nil { # return # } # InvertBinaryTree ( tree . Left ) # InvertBinaryTree ( tree . Right ) # tree . Left , tree . Right = tree . Right , tree . Left
t . Parallel () # # for _ , tc := range testcases { # if res , err := FewestCoinsBrute ( tc . denom , tc . target ); res != tc . expectedCoins || err != tc . expectedErr { # t . Errorf (" STR ", tc . expectedCoins , tc . expectedErr , res , err ) # } # }
path := make ([] int , len ( graph )) # res := make ([][] int , 0 , len ( graph )) # # dfs ( 0 , len ( graph )- 1 , 1 , path , graph , & res ) # # return res
log . Println (" STR ") # # first := start (" STR ", 3 , 6 ) # # second := start (" STR ", 2 , 2 ) # # time . Sleep ( 2 * time . Second ) # # shutdown ( first , second ) # # log . Println (" STR ") # return
n 1 , n 2 := len ( a 1 ), len ( a 2 ) # # dp := make ([][] int , n 1 + 1 ) # for i := range dp { # dp [ i ] = make ([] int , n 2 + 1 ) # } # # res := 0 # for i := 1 ; i <= n 1 ; i ++ { # for j := 1 ; j <= n 2 ; j ++ { # if a 1 [ i - 1 ] == a 2 [ j - 1 ] { # dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + 1 # res = max ( res , dp [ i ][ j ]) # } # } # } # # return res
for _ , v := range arr { # if item == v { # return true # } # } # return false
var output [] byte # # bufconv := (* reflect . SliceHeader )( unsafe . Pointer (& output )) # bufconv . Data = uintptr ( buffer ) # bufconv . Len = length # bufconv . Cap = length # # return output
TemplateTestGCD ( t , Iterative )
ans := 0 # sort . Ints ( nums ) # for i , value := range nums { # if 0 == i % 2 { # ans += value # } # } # return ans
dp := make ([][] int , len ( word 1 )+ 1 ) # for i := 0 ; i < len ( word 1 )+ 1 ; i ++ { # dp [ i ] = make ([] int , len ( word 2 )+ 1 ) # } # for i := 0 ; i < len ( word 1 )+ 1 ; i ++ { # dp [ i ][ 0 ] = i # } # for i := 0 ; i < len ( word 2 )+ 1 ; i ++ { # dp [ 0 ][ i ] = i # } # for i := 1 ; i < len ( word 1 )+ 1 ; i ++ { # for j := 1 ; j < len ( word 2 )+ 1 ; j ++ { # if word 1 [ i - 1 ] == word 2 [ j - 1 ] { # dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] # } else { # dp [ i ][ j ] = min ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ], dp [ i - 1 ][ j - 1 ]) + 1 # } # } # } # return dp [ len ( word 1 )][ len ( word 2 )]
if len ( arr ) < 1 { # return arr # } # var negatives , nonNegatives [] int # # for _ , item := range arr { # if item < 0 { # negatives = append ( negatives , - item ) # } else { # nonNegatives = append ( nonNegatives , item ) # } # } # negatives = unsignedRadixSort ( negatives ) # # for i , j := 0 , len ( negatives )- 1 ; i <= j ; i , j = i + 1 , j - 1 { # negatives [ i ], negatives [ j ] = - negatives [ j ], - negatives [ i ] # } # return append ( negatives , unsignedRadixSort ( nonNegatives )...)
var tests = [] struct { # array [] int # min int # }{ # {[] int { 1 }, 1 }, # {[] int { 1 , 1 }, 1 }, # {[] int { 1 , 3 , 5 }, 1 }, # {[] int { 2 , 2 , 2 , 0 , 2 }, 0 }, # {[] int { 1 , 2 , 3 , 4 , 5 }, 1 }, # {[] int { 2 , 3 , 4 , 5 , 1 }, 1 }, # {[] int { 3 , 4 , 5 , 1 , 2 }, 1 }, # {[] int { 4 , 5 , 1 , 2 , 3 }, 1 }, # {[] int { 5 , 1 , 2 , 3 , 4 }, 1 }, # {[] int { 4 , 5 , 6 , 7 , 0 , 1 , 2 }, 0 }, # } # # for _ , tt := range tests { # min := findMin ( tt . array ) # if min != tt . min { # t . Errorf (" STR ", tt . array , min , tt . min ) # } # }
for i := range nums { # for nums [ i ] > 0 && nums [ i ] <= len ( nums ) && nums [ i ] != nums [ nums [ i ]- 1 ] { # nums [ nums [ i ]- 1 ], nums [ i ] = nums [ i ], nums [ nums [ i ]- 1 ] # } # } # for i := range nums { # if nums [ i ] != i + 1 { # return i + 1 # } # } # return len ( nums ) + 1
hm . capacity <<= 1 # # tempTable := hm . table # # hm . table = make ([]* node , hm . capacity ) # # for i := 0 ; i < len ( tempTable ); i ++ { # node := tempTable [ i ] # if node == nil { # continue # } # # hm . table [ hm . hash ( node . key )] = node # }
dp , ans := [] int {}, 0 # for i := 0 ; i < len ( nums ); i ++ { # dp = append ( dp , 1 ) # for j := 0 ; j < i ; j ++ { # if nums [ i ] > nums [ j ] { # dp [ i ] = max ( dp [ i ], dp [ j ]+ 1 ) # } # } # ans = max ( dp [ i ], ans ) # } # return ans
min , max := A [ 0 ], A [ 0 ] # for i := range A { # if A [ i ] < min { # min = A [ i ] # } else if max < A [ i ] { # max = A [ i ] # } # } # # if min + K >= max - K { # return 0 # } # # return max - min - K * 2
pfs := [] int {} # for n % 2 == 0 { # pfs = append ( pfs , 2 ) # n = n / 2 # } # # for i := 3 ; i * i <= n ; i = i + 2 { # for n % i == 0 { # pfs = append ( pfs , i ) # n = n / i # } # } # # if n > 2 { # pfs = append ( pfs , n ) # } # return pfs
currLen , maxLen := 0 , 0 # preStr := " STR " # for _ , c := range [] rune ( s ) { # if strings . Contains ( preStr , string ( c )) { # i := strings . LastIndex ( preStr , string ( c )) # if len ( preStr )- 1 == i { # preStr = string ( c ) # currLen = 1 # } else { # preStr = string ( preStr [ i + 1 :]) + string ( c ) # currLen = len ( preStr ) # } # continue # } # preStr += string ( c ) # currLen ++ # if currLen > maxLen { # maxLen = currLen # } # } # return maxLen
rowMask , colMask , areaMask := [ 9 ][ 9 ] bool {}, [ 9 ][ 9 ] bool {}, [ 9 ][ 9 ] bool {} # for r := range board { # for c := range board [ r ] { # if board [ r ][ c ] == '.' { # continue # } # digit := board [ r ][ c ] - ' 0 ' - 1 # area := 3 *( r / 3 ) + c / 3 # if rowMask [ r ][ digit ] || colMask [ c ][ digit ] || areaMask [ area ][ digit ] { # return false # } # rowMask [ r ][ digit ] = true # colMask [ c ][ digit ] = true # areaMask [ area ][ digit ] = true # } # } # return true
t . Parallel () # # counter := make ([] int , 8 ) # for i := 0 ; i < 1 0 0 0 0 0 0 ; i ++ { # counter [ Rand 7 ()]++ # } # # uniform := 1 0 0 0 0 0 0 / 7 # tolerance := 1 5 0 0 # # for i := 1 ; i <= 7 ; i ++ { # if counter [ i ] < uniform - tolerance || counter [ i ] > uniform + tolerance { # t . Errorf (" STR ", uniform , counter [ i ]) # } # }
if self . size == self . maxSize { # panic (" STR ") # } # if self . top == nil { # self . top = frame # } else { # frame . next = self . top # self . top = frame # } # self . size ++
n . CondExpr = n . CondExpr . Accept ( v ) # n . TrueExpr = n . TrueExpr . Accept ( v ) # n . FalseExpr = n . FalseExpr . Accept ( v ) # # return v ( n )
if A == B { # return 0 # } # n := len ( A ) # seen := map [ string ] struct {}{} # seen [ A ] = struct {}{} # queue := [] string { A } # res := 0 # for { # res ++ # count := len ( queue ) # for k := 0 ; k < count ; k ++ { # s := queue [ k ] # i := 0 # for s [ i ] == B [ i ] { # i ++ # } # for j := i + 1 ; j < n ; j ++ { # if s [ j ] == B [ j ] || s [ i ] != B [ j ] { # continue # } # tmp := swap ( s , i , j ) # if tmp == B { # return res # } # if _ , ok := seen [ tmp ]; ! ok { # seen [ tmp ] = struct {}{} # queue = append ( queue , tmp ) # } # } # } # queue = queue [ count :] # }
hasSeen := make ( map [ string ] bool , 1 0 0 ) # for _ , email := range emails { # hasSeen [ clean ( email )] = true # } # return len ( hasSeen )
for i , j := 0 , len ( s )- 1 ; i < j ; i , j = i + 1 , j - 1 { # s [ i ], s [ j ] = s [ j ], s [ i ] # } #
qs := [] question 9 8 0 { # # { # para 9 8 0 {[][] int { # { 1 , 0 , 0 , 0 }, # { 0 , 0 , 0 , 0 }, # { 0 , 0 , 2 , - 1 }, # }}, # ans 9 8 0 { 2 }, # }, # # { # para 9 8 0 {[][] int { # { 1 , 0 , 0 , 0 }, # { 0 , 0 , 0 , 0 }, # { 0 , 0 , 0 , 2 }, # }}, # ans 9 8 0 { 4 }, # }, # # { # para 9 8 0 {[][] int { # { 1 , 0 }, # { 0 , 2 }, # }}, # ans 9 8 0 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 8 0 , q . para 9 8 0 # fmt . Printf (" STR ", p , uniquePathsIII ( p . grid )) # } # fmt . Printf (" STR ")
m := len ( grid ) # if m == 0 { # return 0 # } # n := len ( grid [ 0 ]) # if n == 0 { # return 0 # } # res , visited := 0 , make ([][] bool , m ) # for i := 0 ; i < m ; i ++ { # visited [ i ] = make ([] bool , n ) # } # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # if grid [ i ][ j ] == ' 1 ' && ! visited [ i ][ j ] { # searchIslands ( grid , & visited , i , j ) # res ++ # } # } # } # return res
cases := [] struct { # name string # inputs [] string # expect [] string # }{ # {" STR ", [] string {" STR ", " STR ", " STR "}, [] string {" STR ", " STR ", " STR "}}, # {" STR ", [] string {" STR ", " STR ", " STR "}, [] string {" STR ", " STR "}}, # {" STR ", [] string {}, [] string {}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
var prev * ListNode # for head != nil { # next := head . Next # head . Next = prev # prev = head # head = next # } # return prev
if targetIndex < 0 || targetIndex >= len ( nums ) { # panic (" STR ") # } # # val := nums [ targetIndex ] # left , right := targetIndex - 1 , targetIndex + 1 # # for left >= 0 || right < len ( nums ) { # if left >= 0 && nums [ left ] > val { # return left # } else if right < len ( nums ) && nums [ right ] > val { # return right # } # left -- # right ++ # } # # return - 1
t . Parallel () # lru := NewLRU ( 3 ) # for i := 0 ; i < 6 ; i ++ { # lru . Set ( i , i + 1 ) # } # for i := 0 ; i < 3 ; i ++ { # if v := lru . Get ( i ); v != nil { # t . Errorf (" STR ") # } # } # for i := 3 ; i < 6 ; i ++ { # if v := lru . Get ( i ); v != i + 1 { # t . Errorf (" STR ") # } # } # for i := 3 ; i < 6 ; i ++ { # lru . Set ( i , 1 0 * i ) # } # for i := 3 ; i < 6 ; i ++ { # if v := lru . Get ( i ); v != i * 1 0 { # t . Errorf (" STR ") # } # }
d . Employee . PrintDetails () # fmt . Println (" STR ") # for _ , v := range d . Skills { # fmt . Println ( v ) # }
var numCases int # fmt . Scanf (" STR ", & numCases ) # # var i = 1 # for i <= numCases { # var N int # fmt . Scanf (" STR ",& N ) # doComputation ( N ) # i = i + 1 # }
qs := [] question 8 8 4 { # # { # para 8 8 4 {" STR ", " STR "}, # ans 8 8 4 {[] string {" STR ", " STR "}}, # }, # # { # para 8 8 4 {" STR ", " STR "}, # ans 8 8 4 {[] string {" STR "}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 8 4 , q . para 8 8 4 # fmt . Printf (" STR ", p , uncommonFromSentences ( p . A , p . B )) # } # fmt . Printf (" STR ")
at [ fromState ][ overChar ] = toState
t := s . value . Type () # # var f [] reflect . StructField # # for i := 0 ; i < t . NumField (); i ++ { # field := t . Field ( i ) # if field . PkgPath != "" { # continue # } # # if tag := field . Tag . Get ( s . TagName ); tag == " STR " { # continue # } # # f = append ( f , field ) # } # # return f
p , t , lcd := 1 , [ 2 ] int {}, 1 # for c := 2 ; c <= 2 0 ; c ++ { # t [ 0 ], t [ 1 ], lcd = p , c , 1 # L : for { # if t [ 0 ] > t [ 1 ] { # t [ 0 ] = t [ 0 ] % t [ 1 ] # } else { t [ 1 ] = t [ 1 ] % t [ 0 ] } # # if t [ 0 ] == 1 || t [ 1 ] == 1 { break L } # if t [ 0 ] * t [ 1 ] == 0 { # if t [ 0 ] == 0 { # lcd = t [ 1 ] # } else { lcd = t [ 0 ] } # break L # } # } # p *= c / lcd # } # fmt . Println ( p )
maxLength := 0 # var maxQuad Quadratic # # for a := - 9 9 9 ; a < 1 0 0 0 ; a ++ { # # for b := - 1 0 0 0 ; b <= 1 0 0 0 ; b ++ { # # for n := 0 ; true ; n ++ { # # quad := Quadratic { n , a , b } # value := quad . getValue () # # if ! isPrime ( value ) { # break # } # # if n > maxLength { # maxLength = n # maxQuad = quad # } # # } # # } # # } # # fmt . Println ( maxQuad . a * maxQuad . b ) #
qs := [] question 1 2 8 3 { # # { # para 1 2 8 3 {[] int { 1 , 2 , 5 , 9 }, 6 }, # ans 1 2 8 3 { 5 }, # }, # # { # para 1 2 8 3 {[] int { 2 , 3 , 5 , 7 , 1 1 }, 1 1 }, # ans 1 2 8 3 { 3 }, # }, # # { # para 1 2 8 3 {[] int { 1 9 }, 5 }, # ans 1 2 8 3 { 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 8 3 , q . para 1 2 8 3 # fmt . Printf (" STR ", p , smallestDivisor ( p . nums , p . threshold )) # } # fmt . Printf (" STR ")
result := make ([] int , len ( arr )) # total := 1 # for _ , v := range arr { # total *= v # } # for i , v := range arr { # result [ i ] = total / v # } # return result
ans , m := len ( text ), make ( map [ byte ] int , 5 ) # for i := 0 ; i < ans ; i ++ { # switch text [ i ] { # case ' b ', ' a ', ' l ', ' o ', ' n ': # m [ text [ i ]]++ # } # } # for _ , c := range [...] byte {' b ', ' a ', ' l ', ' o ', ' n '} { # if c == ' l ' || c == ' o ' { # m [ c ] /= 2 # } # if ans > m [ c ] { # ans = m [ c ] # } # } # return ans
if root == nil { # return [] int {} # } # # var stack []* TreeNode # var nodes [] int # # stack = append ( stack , root ) # # for len ( stack ) != 0 { # lastNode := stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # nodes = append ( nodes , lastNode . Val ) # # if lastNode . Right != nil { # stack = append ( stack , lastNode . Right ) # } # if lastNode . Left != nil { # stack = append ( stack , lastNode . Left ) # } # } # # return nodes
qs := [] question 1 0 1 7 { # # { # para 1 0 1 7 { 2 }, # ans 1 0 1 7 {" STR "}, # }, # # { # para 1 0 1 7 { 3 }, # ans 1 0 1 7 {" STR "}, # }, # # { # para 1 0 1 7 { 4 }, # ans 1 0 1 7 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 1 7 , q . para 1 0 1 7 # fmt . Printf (" STR ", p , baseNeg 2 ( p . one )) # } # fmt . Printf (" STR ")
return fmt . Sprintf (" STR ", v . Type , v . Value )
if len ( pre ) == 0 { # return nil # } # if len ( pre ) == 1 { # return & TreeNode { Val : pre [ 0 ]} # } # # n := len ( post ) # i := findIndex ( post , pre [ 1 ]) # return & TreeNode { # Val : pre [ 0 ], # Left : constructFromPrePost ( pre [ 1 : i + 2 ], post [: i + 1 ]), # Right : constructFromPrePost ( pre [ i + 2 :], post [ i + 1 : n - 1 ]), # }
visited := make ([][] bool , len ( grid )) # for i := 0 ; i < len ( visited ); i ++ { # visited [ i ] = make ([] bool , len ( grid [ 0 ])) # } # res , empty , startx , starty , endx , endy , path := 0 , 0 , 0 , 0 , 0 , 0 , [] int {} # for i , v := range grid { # for j , vv := range v { # switch vv { # case 0 : # empty ++ # case 1 : # startx , starty = i , j # case 2 : # endx , endy = i , j # } # } # } # findUniquePathIII ( grid , visited , path , empty + 1 , startx , starty , endx , endy , & res ) # return res
obj := Constructor () # obj . Add ( 1 ) # obj . Add ( 2 ) # got := obj . Contains ( 1 ) # got = ! obj . Contains ( 3 ) && got # obj . Add ( 2 ) # got = obj . Contains ( 2 ) && got # obj . Remove ( 2 ) # got = ! obj . Contains ( 2 ) && got # if ! got { # t . Fatalf (" STR ", got , true ) # }
if root == nil { # return [][] int {} # } # res := make ([][] int , 0 ) # stack := []* TreeNode { root } # for len ( stack ) > 0 { # temp := make ([]* TreeNode , 0 ) # tempVals := make ([] int , 0 ) # for len ( stack ) > 0 { # node := stack [ 0 ] # tempVals = append ( tempVals , node . Val ) # if node . Left != nil { # temp = append ( temp , node . Left ) # } # if node . Right != nil { # temp = append ( temp , node . Right ) # } # stack = stack [ 1 :] # } # stack = append ( stack , temp ...) # res = append ( res , tempVals ) # } # for i , j := 0 , len ( res ) - 1 ; i < j ; i , j = i + 1 , j - 1 { # res [ i ], res [ j ] = res [ j ], res [ i ] # } # return res
reg := regexp . MustCompile (`\ S +`) # words := reg . FindAllString ( s , - 1 ) # for i , j := 0 , len ( words )- 1 ; i < j ; i , j = i + 1 , j - 1 { # words [ i ], words [ j ] = words [ j ], words [ i ] # } # return strings . Join ( words , " STR ")
head := new ( Node ) # return & LinkedList { head }
var f , lf , mf int 6 4 # if n % 2 == 0 { # lf = 2 # n /= 2 # for n % 2 == 0 { # n /= 2 # } # } else { # lf = 1 # } # f = 3 # mf = int 6 4 ( math . Sqrt ( float 6 4 ( n ))) # for n > 1 && f <= mf { # if n % f == 0 { # n /= f # lf = f # for n % f == 0 { # n /= f # } # mf = int 6 4 ( math . Sqrt ( float 6 4 ( n ))) # } # f += 2 # } # if n == 1 { # return int ( lf ) # } # return int ( n )
n := len ( s ) # # match := map [ byte ] byte { # ')': '(', # ']': '[', # '}': '{', # } # # stack := [] byte {} # # for i := 0 ; i < n ; i ++ { # switch s [ i ] { # case '(', '[', '{': # stack = append ( stack , s [ i ]) # case ')', ']', '}': # if len ( stack ) == 0 { # return false # } # m := stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # if m != match [ s [ i ]] { # return false # } # } # } # return len ( stack ) == 0
http . HandleFunc (" STR ", handler ) # log . Printf (" About to listen on 1 0 4 4 3 . Go to https : ) # # go http . ListenAndServe (" STR ", nil ) # err := http . ListenAndServeTLS (" STR ", " STR ", " STR ", nil ) # if err != nil { # log . Fatal ( err ) # } #
sum , j := 0 , 0 # for i := 1 ; i < 1 0 0 0 0 ; i ++ { # j = sumOfProperDivisors ( i ) # if i == sumOfProperDivisors ( j ) && i != j { # sum += i # } # } # println ( sum )
h := make ( IntMinHeap , 0 , len ( nums )) # heap . Init (& h ) # # for i := 0 ; i < len ( nums ); i ++ { # h . Push ( nums [ i ]) # heap . Init (& h ) # } # for len ( h ) > 0 { # fmt . Printf (" STR ", h . Pop ()) # } # return 0
nums := [] int { 3 , 1 , 4 , 1 , 5 } # fmt . Println ( findPairs ( nums , 2 ))
if this . nextVal == 0 { # this . fields = make ( map [ string ] uint 6 4 , 6 4 ) # this . values = make ( map [ uint 6 4 ] string , 6 4 ) # this . nextVal = 1 # } # name = strings . ToLower ( name ) # if name == " STR " || name == " STR " { # return fmt . Errorf (" STR ", name ) # } # _ , ok := this . fields [ name ] # if ok { # return fmt . Errorf (" STR ", name ) # } # if this . nextVal == math . MaxUint 6 4 { # return fmt . Errorf (" STR ") # } # this . fields [ name ] = this . nextVal # this . values [ this . nextVal ] = name # if this . nextVal == uint 6 4 ( 0 x 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ) { # this . nextVal = math . MaxUint 6 4 # } else { # this . nextVal <<= 1 # } # return nil
tests := [...] testType { # { # in : 5 , # want : [][] int { # { 1 }, # { 1 , 1 }, # { 1 , 2 , 1 }, # { 1 , 3 , 3 , 1 }, # { 1 , 4 , 6 , 4 , 1 }, # }, # }, # } # for _ , tt := range tests { # got := generate ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
n := len ( nums ) # temp := make ([] int , n ) # copy ( temp , nums ) # sort . Ints ( temp ) # # mid := n / 2 # # for i := 0 ; i < n ; i ++ { # if i < mid { # nums [ 2 * i + 1 ] = temp [ n - 1 - i ] # } else { # nums [ 2 *( i - mid )] = temp [ n - 1 - i ] # } # }
x := [] int {} # if root != nil { # x = append ( x , inorderTraversal ( root . Left )...) # x = append ( x , root . Val ) # x = append ( x , inorderTraversal ( root . Right )...) # } # return x
return strings . ToLower ( s )
var s string # var ret bool # s = " STR " # ret = true # fmt . Printf (" STR ", s , isValid ( s )) # if isValid ( s ) != ret { # t . Fatalf (" STR ", ret ) # } # # s = " STR " # ret = false # fmt . Printf (" STR ", s , isValid ( s )) # if isValid ( s ) != ret { # t . Fatalf (" STR ", ret ) # } # # s = " STR " # ret = true # fmt . Printf (" STR ", s , isValid ( s )) # if isValid ( s ) != ret { # t . Fatalf (" STR ", ret ) # } # # s = " STR " # ret = true # fmt . Printf (" STR ", s , isValid ( s )) # if isValid ( s ) != ret { # t . Fatalf (" STR ", ret ) # }
starttime := time . Now () # target := 2 0 0 0 0 0 0 # depth := 1 0 0 # best := 9 9 9 9 9 # miss := 9 9 9 9 9 # bestprod := 0 # # for i := 1 ; i < depth ; i ++ { # for j := i ; j < depth ; j ++ { # # total := (( i * j ) + ( i * i * j ) + ( i * j * j ) + ( i * i * j * j )) / 4 # # if total > target { # miss = total - target # } else { # miss = target - total # } # # if miss < best { # bestprod = i * j # best = miss # } # # } # } # # fmt . Println ( bestprod ) # # fmt . Println (" STR ", time . Since ( starttime )) #
var nums [] int # var target int # var ret [] int # # target = 6 # nums = [] int { 5 , 7 , 7 , 8 , 8 , 1 0 } # ret = [] int {- 1 , - 1 } # for i , v := range searchRange ( nums , target ) { # if ret [ i ] != v { # t . Fatalf (" STR ", ret ) # } # } # # target = 8 # nums = [] int { 5 , 7 , 7 , 8 , 8 , 1 0 } # ret = [] int { 3 , 4 } # for i , v := range searchRange ( nums , target ) { # if ret [ i ] != v { # t . Fatalf (" STR ", ret ) # } # } #
return rec 1 [ 0 ] < rec 2 [ 2 ] && rec 2 [ 0 ] < rec 1 [ 2 ] && rec 1 [ 1 ] < rec 2 [ 3 ] && rec 2 [ 1 ] < rec 1 [ 3 ]
if len ( list 1 ) > len ( list 2 ) { # list 1 , list 2 = list 2 , list 1 # } # # m := make ( map [ string ] int , len ( list 2 )) # for i , s := range list 2 { # m [ s ] = i # } # # min := math . MaxInt 3 2 # res := [] string {} # for i , s := range list 1 { # if j , ok := m [ s ]; ok { # if min == i + j { # res = append ( res , s ) # } else if min > i + j { # min = i + j # res = [] string { s } # } # } # } # return res
if len ( prices ) < 2 { # return 0 # } # buy := prices [ 0 ] # var maxProfit int # for i := 1 ; i < len ( prices ); i ++ { # if prices [ i ] > buy + fee { # thisTradeProfit := prices [ i ] - buy - fee # totalProfit := thisTradeProfit + MaxProfitWithFee ( prices [ i + 1 :], fee ) # if totalProfit > maxProfit { # maxProfit = totalProfit # } # } # } # return maxProfit
bytes , err := dataLocationsJsonBytes () # if err != nil { # return nil , err # } # # info := bindataFileInfo { name : " STR ", size : 5 3 1 , mode : os . FileMode ( 4 2 0 ), modTime : time . Unix ( 1 4 5 6 5 9 1 4 4 7 , 0 )} # a := & asset { bytes : bytes , info : info } # return a , nil
if len ( matrix ) == 0 || len ( matrix [ 0 ]) == 0 { # return nil # } # # m , n := len ( matrix ), len ( matrix [ 0 ]) # # next := nextFunc ( m , n ) # # res := make ([] int , m * n ) # for i := range res { # x , y := next () # res [ i ] = matrix [ x ][ y ] # } # # return res
for i , v := range strings . Split ( sentence , " STR ") { # if strings . HasPrefix ( v , searchWord ) { # return i + 1 # } # } # return - 1
sort . Ints ( nums ) # # var solution [][] int # for i := 0 ; i < len ( nums )- 2 ; i ++ { # if i > 0 && nums [ i ] == nums [ i - 1 ] { # continue # } # # lo , hi := i + 1 , len ( nums )- 1 # for lo < hi { # sum := nums [ i ] + nums [ lo ] + nums [ hi ] # switch { # case sum > 0 : # hi -- # case sum < 0 : # lo ++ # default : # solution = append ( solution , [] int { nums [ i ], nums [ lo ], nums [ hi ]}) # lo ++ # hi -- # for lo < hi && nums [ lo ] == nums [ lo - 1 ] { # lo ++ # } # for lo < hi && nums [ hi ] == nums [ hi + 1 ] { # hi -- # } # } # } # } # return solution
if len ( wordDict ) == 0 { # return false # } # # dict := make ( map [ string ] bool , len ( wordDict )) # length := make ( map [ int ] bool , len ( wordDict )) # # for _ , w := range wordDict { # length [ len ( w )] = true # dict [ w ] = true # } # # sizes := make ([] int , 0 , len ( length )) # for k := range length { # sizes = append ( sizes , k ) # } # # sort . Ints ( sizes ) # # dp := make ([] bool , len ( s )+ 1 ) # dp [ 0 ] = true # n := len ( s ) # for i := 0 ; i <= n ; i ++ { # if ! dp [ i ] { # continue # } # # for _ , size := range sizes { # if i + size <= n { # dp [ i + size ] = dp [ i + size ] || dict [ s [ i : i + size ]] # } # } # } # # return dp [ n ]
t . Parallel () # for _ , tc := range testcases { # if ways := TilingBoardWaysFaster ( tc . n ); ways != tc . tilingWays { # t . Errorf (" STR ", tc . tilingWays , ways ) # } # }
var tests = [] struct { # nums [] int # sets [][] int # }{ # {[] int { 1 , 2 , 2 }, [][] int { nil , { 1 }, { 2 }, { 1 , 2 }, { 2 , 2 }, { 1 , 2 , 2 }}}, # } # # for _ , tt := range tests { # sets := subsetsWithDup ( tt . nums ) # if reflect . DeepEqual ( sets , tt . sets ) == false { # t . Errorf (" STR ", tt . nums , sets , tt . sets ) # } # }
nums := [] int { 2 , 0 , 2 , 1 , 1 , 0 } # expected := [] int { 0 , 0 , 1 , 1 , 2 , 2 } # # sortColorsCountSort ( nums ) # # if ! reflect . DeepEqual ( nums , expected ) { # t . Errorf (" STR ", expected , nums ) # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 0 , 9 , 2 , 5 , 3 , 7 , 1 0 1 , 1 8 }, 4 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := lengthOfLIS 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
graph := make ( map [ int ] map [ int ] int ) # for _ , edge := range edges { # if _ , exists := graph [ edge . Start ]; ! exists { # graph [ edge . Start ] = make ( map [ int ] int ) # } # graph [ edge . Start ][ edge . End ] = edge . Time # } # totalTime := 0 # visited := make ( map [ int ] struct {}) # visited [ 0 ] = struct {}{} # pq := make ( priorityQueue , n + 1 ) # heap . Push (& pq , nodeVisit { 0 , 0 }) # for len ( visited ) != n + 1 { # next := heap . Pop (& pq ).( nodeVisit ) # visited [ next . id ] = struct {}{} # totalTime = next . time # for node , time := range graph [ next . id ] { # if _ , seen := visited [ node ]; seen { # continue # } # heap . Push (& pq , nodeVisit { node , next . time + time }) # } # } # return totalTime
file , err := os . OpenFile ( filename , os . O_RDWR | os . O_CREATE | os . O_TRUNC , perm ) # if err != nil { # return err # } # defer file . Close () # # enc := json . NewEncoder ( file ) # return enc . Encode ( v )
fmt . Println ( climbStairs 1 ( 3 )) # fmt . Println ( climbStairs 2 ( 4 )) # fmt . Println ( climbStairs 3 ( 5 ))
if v . Type == TypeUnknown { # return true # } # # switch v . Type { # case TypeList : # for _ , el := range v . Value .([] Variable ) { # if IsUnknown ( el ) { # return true # } # } # case TypeMap : # for _ , el := range v . Value .( map [ string ] Variable ) { # if IsUnknown ( el ) { # return true # } # } # default : # } # # return false
qs := [] question 2 1 6 { # # { # para 2 1 6 { 3 , 7 }, # ans 2 1 6 {[][] int {{ 1 , 2 , 4 }}}, # }, # { # para 2 1 6 { 3 , 9 }, # ans 2 1 6 {[][] int {{ 1 , 2 , 6 }, { 1 , 3 , 5 }, { 2 , 3 , 4 }}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 1 6 , q . para 2 1 6 # fmt . Printf (" STR ", p , combinationSum 3 ( p . n , p . k )) # } # fmt . Printf (" STR ")
i , j := 0 , 0 # for j < len ( nums ) { # nums [ i ] = nums [ j ] # i ++ # # k := j # for j < len ( nums ) && nums [ k ] == nums [ j ] { # j ++ # } # } # # return i
if i == 1 { # return 1 # } # if i == 2 { # return 2 # } # return fibonacci ( i - 1 ) + fibonacci ( i - 2 )
tests := [...] testType { # { # in : " STR ", # want : 4 , # }, # { # in : " STR ", # want : 3 , # }, # { # in : " STR ", # want : 1 , # }, # } # for _ , tt := range tests { # got := balancedStringSplit ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
fastNode := head # slowNode := head # for n > 0 { # fastNode = fastNode . Next # n -- # } # # if fastNode != nil { # for fastNode . Next != nil { # fastNode = fastNode . Next # slowNode = slowNode . Next # } # slowNode . Next = slowNode . Next . Next # # } else { # head = head . Next # } # return head
p . flushPendingBytes () # p . queue <- queueItem { term : true } # <- p . done # close ( p . queue ) # return p . final , p . err
dict 1 := make ( map [ rune ] int , 0 ) # for _ , v := range s { # dict 1 [ v ]++ # } # # dict 2 := make ( map [ rune ] int , 0 ) # for _ , v := range t { # dict 2 [ v ]++ # } # # for k 2 , v 2 := range dict 2 { # if v 1 := dict 1 [ k 2 ]; v 1 != v 2 { # return byte ( k 2 ) # } # } # return byte ( 0 )
srcData := [] byte (" STR ") # key := [] byte (" STR ") # Decrypt ( srcData , key )
 # s := initManacherStr ( in ) # c , max := 0 , 0 # # # P := make ([] int , len ( s )) # # for i := 1 ; i < len ( s )- 1 ; i ++ { # i_mirror := 2 * c - i # if max > i { # P [ i ] = Min ( P [ i_mirror ], max - i ) # } else { # P [ i ] = 0 # } # # for ( i + P [ i ]+ 1 ) < len ( s ) && ( i - P [ i ]- 1 ) >= 0 && # s [ i + P [ i ]+ 1 ] == s [ i - P [ i ]- 1 ] { # # P [ i ]++ # } # # if i + P [ i ] > max { # c = i # max = i + P [ i ] # } # # } # return extractLongest ( in , P )
result := [] byte {} # for n > 0 { # result = append ( result , ' A '+ byte (( n - 1 )% 2 6 )) # n = ( n - 1 ) / 2 6 # } # for i , j := 0 , len ( result )- 1 ; i < j ; i , j = i + 1 , j - 1 { # result [ i ], result [ j ] = result [ j ], result [ i ] # } # return string ( result )
left , right , size := 0 , 1 , len ( a ) # for ; right < size ; right ++ { # if a [ left ] == a [ right ] { # continue # } # left ++ # a [ left ], a [ right ] = a [ right ], a [ left ] # } # return left + 1
value , ok := m [ key ] # println (" STR ", key , value , ok )
var grid [ 2 0 ][ 2 0 ] int # f , _ := os . Open (" STR ") # r := csv . NewReader ( bufio . NewReader ( f )) # i := 0 # for { # record , err := r . Read () # if err == io . EOF { # break # } # for j , b := range ( record ){ # temp , _ := strconv . Atoi ( string ( b )) # grid [ i ][ j ]= temp # } # i ++ # } # max_hor := max_horizontal ( grid ) # max_ver := max_vertical ( grid ) # max_dia := max_digonal_forward ( grid ) # fmt . Println ( max_hor ) # fmt . Println ( max_ver ) # fmt . Println ( max_dia ) # fmt . Println ( max_digonal_backward ( grid ))
procs := runtime . GOMAXPROCS ( 0 ) # counter := length # partSize := length / procs # if procs <= 1 || partSize <= procs { # fn ( 0 , length ) # } else { # var wg sync . WaitGroup # for counter > 0 { # start := counter - partSize # end := counter # if start < 0 { # start = 0 # } # counter -= partSize # wg . Add ( 1 ) # go func () { # defer wg . Done () # fn ( start , end ) # }() # } # # wg . Wait () # }
n := node .(* bstElement ) # for curNode := t . Min ( n ).(* bstElement ); curNode != nil ; { # stop := callback ( t , curNode ) # if stop { # return true # } # curNode = t . Successor ( curNode , n ).(* bstElement ) # } # return false
if len ( nums ) == 0 { # return nil # } # # middle := len ( nums ) / 2 # return & TreeNode { # Val : nums [ middle ], # Left : sortedArrayToBST ( nums [: middle ]), # Right : sortedArrayToBST ( nums [ middle + 1 :]), # }
left , right , secHeight , area := 0 , len ( height )- 1 , 0 , 0 # for left < right { # if height [ left ] < height [ right ] { # secHeight = max ( secHeight , height [ left ]) # area += secHeight - height [ left ] # left ++ # } else { # secHeight = max ( secHeight , height [ right ]) # area += secHeight - height [ right ] # right -- # } # } # return area
return hm . putValue ( hm . hash ( key ), key , value )
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int {- 3 , 2 , - 3 , 4 , 2 }, 5 }, # {" STR ", [] int { 1 , 2 }, 1 }, # {" STR ", [] int { 1 , - 2 , - 3 }, 5 }, # {" STR ", [] int { 2 , 3 , 5 , - 5 , - 1 }, 1 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if x < 0 || y < 0 || x >= len ( grid ) || y >= len ( grid [ 0 ]) || v [ x ][ y ] == 1 || grid [ x ][ y ] == 0 { # return 0 # } # moves := [][] int {[] int { 1 , 0 }, [] int {- 1 , 0 }, [] int { 0 , 1 }, [] int { 0 , - 1 }} # v [ x ][ y ] = 1 # ret := 1 # for i := 0 ; i < 4 ; i ++ { # ret += travel ( grid , v , x + moves [ i ][ 0 ], y + moves [ i ][ 1 ]) # } # return ret
var tests = [] struct { # preorder [] int # inorder [] int # tree * TreeNode # }{ # {[] int { 3 , 9 , 2 0 , 1 5 , 7 }, [] int { 9 , 3 , 1 5 , 2 0 , 7 }, newTree ( 3 , 9 , 2 0 , nil , nil , 1 5 , 7 )}, # } # # for _ , tt := range tests { # tree := buildTree ( tt . preorder , tt . inorder ) # if reflect . DeepEqual ( tree , tt . tree ) == false { # t . Errorf (" STR ", tt . preorder , tt . inorder , tree , tt . tree ) # } # }
var numMap = map [ int ] int {} # for i := 0 ; i < len ( nums ); i ++ { # if _ , ok := numMap [ nums [ i ]]; ok { # if i - numMap [ nums [ i ]] <= k { # return true # } # } # numMap [ nums [ i ]] = i # } # return false
return x == y
n := 5 0 0 0 # pentagonals := generatePentagonal ( n ) # # for distance := 1 ; distance < n ; distance ++ { # for i := 1 ; i + distance <= n ; i ++ { # curDif := pentagonals [ i + distance ] - pentagonals [ i ] # curSum := pentagonals [ i + distance ] + pentagonals [ i ] # # if IsPentagonalNum ( int 6 4 ( curDif )) && IsPentagonalNum ( int 6 4 ( curSum )) { # return curDif # } # } # } # # return 0
hashValue 1 , hashValue 2 := h . HashFunc ( key , sha 1 . New ()), h . HashFunc ( key , sha 2 5 6 . New ()) # ib := big . NewInt ( int 6 4 ( i )) # mb := big . NewInt ( int 6 4 ( h . Cap )) # hashValue 2 . Mul ( hashValue 2 , ib ). Add ( hashValue 2 , hashValue 1 ). Mod ( hashValue 2 , mb ) # return uint 3 2 ( hashValue 2 . Uint 6 4 ())
maxSoFar := - int (^ uint ( 0 )>> 1 ) - 1 # for i := range nums { # if maxSoFar < nums [ i ] { # maxSoFar = nums [ i ] # } # if nums [ i ] < maxSoFar { # end = i # } # } # minSoFar := int (^ uint ( 0 ) >> 1 ) # for i := range nums { # j := len ( nums ) - 1 - i # if minSoFar > nums [ j ] { # minSoFar = nums [ j ] # } # if nums [ j ] > minSoFar { # start = j # } # } # return
bs := [] byte ( strconv . Itoa ( N )) # n := len ( bs ) # mark := n # for i := n - 1 ; i > 0 ; i -- { # if bs [ i ] < bs [ i - 1 ] { # mark = i # bs [ i - 1 ] = bs [ i - 1 ] - 1 # } # } # for i := mark ; i < n ; i ++ { # bs [ i ] = ' 9 ' # } # res , _ := strconv . Atoi ( string ( bs )) # return res
for i := h . Last (); h . Valid ( i ); i = h . Prev ( i ) { # h . MaxHeaplify ( i ) # }
sort . Ints ( A ) # for i := len ( A ) - 3 ; i >= 0 ; i -- { # if A [ i ]+ A [ i + 1 ] > A [ i + 2 ] { # return A [ i ] + A [ i + 1 ] + A [ i + 2 ] # } # } # # return 0
if root . Left == nil && root . Right == nil { # return target == root . Value # } # # if root . Left != nil { # if ans := RootToLeafTarget ( root . Left , target - root . Value ); ans { # return ans # } # } # # if root . Right != nil { # if ans := RootToLeafTarget ( root . Right , target - root . Value ); ans { # return ans # } # } # # return false
size := len ( nums ) # res := [][] int {} # list := make ([] int , 0 , size ) # helper ( nums , 0 , & res , list ) # return res
qs := [] question 4 4 7 { # # { # para 4 4 7 {[][] int {{ 0 , 0 }, { 1 , 0 }, { 2 , 0 }}}, # ans 4 4 7 { 2 }, # }, # # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 4 7 , q . para 4 4 7 # fmt . Printf (" STR ", p , numberOfBoomerangs ( p . one )) # } # fmt . Printf (" STR ")
switch { # case one == nil && two == nil : # return nil # case one == nil : # return & BinaryTree { two . Val , # MergeBinaryTrees ( nil , two . Left ), # MergeBinaryTrees ( nil , two . Right ), # } # case two == nil : # return & BinaryTree { one . Val , # MergeBinaryTrees ( one . Left , nil ), # MergeBinaryTrees ( one . Right , nil ), # } # default : # return & BinaryTree { one . Val + two . Val , # MergeBinaryTrees ( one . Left , two . Left ), # MergeBinaryTrees ( one . Right , two . Right ), # } # }
f 1 , f 2 , l := 0 , 0 , len ( cost )- 1 # for i := l ; i >= 0 ; i -- { # f 0 := f 1 # if f 2 < f 1 { # f 0 = f 2 # } # f 0 += cost [ i ] # f 1 , f 2 = f 0 , f 1 # } # if f 1 <= f 2 { # return f 1 # } # return f 2
var ( # dummy = & ListNode {} # p = dummy # s = p # ) # dummy . Next = head # # for s != nil && n > 0 { # s = s . Next # n -- # } # for s != nil && m > 1 { # p = p . Next # m -- # } # reverse (& p , & s ) # return dummy . Next
l := len ( bed ) # for i := 0 ; i < l ; i ++ { # if bed [ i ] == 0 && # (( i + 1 < l && bed [ i + 1 ] == 0 ) || i + 1 >= l ) && # (( i - 1 >= 0 && bed [ i - 1 ] == 0 ) || i - 1 < 0 ) { # bed [ i ] = 1 # n -- # if n <= 0 { # return true # } # } # } # # return n <= 0
fti , ftj := map [ rune ] int {}, map [ rune ] int {} # si , sj := strconv . Itoa ( i ), strconv . Itoa ( j ) # if len ( si ) == len ( sj ) { # for _ , v := range si { # fti [ v ] += 1 # } # for _ , v := range sj { # ftj [ v ] += 1 # } # for k , v := range fti { # if ftj [ k ] != v { # return false # } # } # return true # } # return false
var i , j int # # table := buildTable ( substr ) # # for i < len ( input ) { # if substr [ j ] == input [ i ] { # i ++ # j ++ # } # # if j == len ( substr ) { # return i - j # } # # if i < len ( input ) && substr [ j ] != input [ i ] { # if j != 0 { # j = table [ j - 1 ] # } else { # i ++ # } # } # } # # return - 1
t . Parallel () # for _ , tc := range testcases { # if result := ValidMastermindGuesses ( tc . guesses ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
qs := [] question 3 6 3 { # # { # para 3 6 3 {[][] int {{ 1 , 0 , 1 }, { 0 , - 2 , 3 }}, 2 }, # ans 3 6 3 { 2 }, # }, # # { # para 3 6 3 {[][] int {{ 2 , 2 , - 1 }}, 0 }, # ans 3 6 3 {- 1 }, # }, # # { # para 3 6 3 {[][] int {{ 5 , - 4 , - 3 , 4 }, {- 3 , - 4 , 4 , 5 }, { 5 , 1 , 5 , - 4 }}, 8 }, # ans 3 6 3 { 8 }, # }, # # { # para 3 6 3 {[][] int {{ 5 , - 4 , - 3 , 4 }, {- 3 , - 4 , 4 , 5 }, { 5 , 1 , 5 , - 4 }}, 3 }, # ans 3 6 3 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 6 3 , q . para 3 6 3 # fmt . Printf (" STR ", p , maxSumSubmatrix ( p . one , p . k )) # } # fmt . Printf (" STR ")
ans := make ([] int , len ( triangle )+ 1 ) # # for i := len ( triangle ) - 1 ; i >= 0 ; i -- { # for j := 0 ; j < len ( triangle [ i ]); j ++ { # ans [ j ] = myMin ( ans [ j ], ans [ j + 1 ]) + triangle [ i ][ j ] # } # } # # return ans [ 0 ]
var ( # lenS = len ( s ) # lenP = len ( p ) # res = [] int {} # freqP = make ([] int , 2 6 ) # freqS = make ([] int , 2 6 ) # left int # right = - 1 # ) # # if lenS < lenP { # return res # } # # for i := 0 ; i < lenP ; i ++ { # freqP [ p [ i ]-' a ']++ # } # # for right + 1 < lenS { # right ++ # freqS [ s [ right ]-' a ']++ # if right - left + 1 > lenP { # freqS [ s [ left ]-' a ']-- # left ++ # } # if right - left + 1 == lenP && isSame ( freqP , freqS ) { # res = append ( res , left ) # } # } # return res
var vals [] int # # var stack []* TreeNode # for p := root ; p != nil || len ( stack ) > 0 ; p = p . Right { # if p == nil { # n := len ( stack ) - 1 # p = stack [ n ] # stack = stack [: n ] # } # vals = append ([] int { p . Val }, vals ...) # if p . Left != nil { # stack = append ( stack , p . Left ) # } # } # # return vals
l , r , maxLen , sLen := 0 , 0 , 0 , len ( s ) # for i := 0 ; i < sLen ; i ++ { # if s [ i ] == '(' { # l ++ # } else { # r ++ # } # if l == r { # if 2 * r > maxLen { # maxLen = 2 * r # } # } else if r > l { # l , r = 0 , 0 # # } # } # l , r = 0 , 0 # for i := sLen - 1 ; i >= 0 ; i -- { # if s [ i ] == '(' { # l ++ # } else { # r ++ # } # if l == r { # if 2 * r > maxLen { # maxLen = 2 * l # } # } else if l > r { # l , r = 0 , 0 # } # } # return maxLen
m := len ( mat ) # if m == 0 { # return 0 # } # # n := len ( mat [ 0 ]) # if n == 0 { # return 0 # } # # dp := make ([][] int , m ) # for i := 0 ; i < m ; i ++ { # dp [ i ] = make ([] int , n ) # } # # for j := 0 ; j < n ; j ++ { # dp [ 0 ][ j ] = int ( mat [ 0 ][ j ] - ' 0 ') # for i := 1 ; i < m ; i ++ { # if mat [ i ][ j ] == ' 1 ' { # dp [ i ][ j ] = dp [ i - 1 ][ j ] + 1 # } # } # } # max := 0 # for i := 0 ; i < m ; i ++ { # tmp := largestRectangleArea ( dp [ i ]) # if max < tmp { # max = tmp # } # } # # return max
if len ( input ) == 0 { # return input # } # return append ( reverseInts ( input [ 1 :]), input [ 0 ])
freq := make ( map [ rune ] int ) # runes := [] rune ( s ) # # for _ , r := range runes { # freq [ r ]++ # } # # sort . Slice ( runes , func ( i , j int ) bool { # if f 1 , f 2 := freq [ runes [ i ]], freq [ runes [ j ]]; f 1 > f 2 { # return true # } else if f 1 == f 2 { # return runes [ i ] > runes [ j ] # } # # return false # }) # # return string ( runes )
for i := 1 ; i < 2 0 0 0 ; i ++ { # for j := 1 ; j < i ; j ++ { # p := i * j # if pandigital ( i , j , p ) { # products [ p ] = present # } # } # } # # sum := 0 # for p := range products { # sum += p # } # # fmt . Println ( sum )
ans := " STR " # for i := n ; i < len ( s ); i ++ { # ans += string ( s [ i ]) # } # for i := 0 ; i < n ; i ++ { # ans += string ( s [ i ]) # } # return ans
cases := [] struct { # name string # input 1 string # input 2 [] string # expect bool # }{ # {" STR ", " STR ", [] string {" STR ", " STR "}, true }, # {" STR ", " STR ", [] string {" STR ", " STR "}, true }, # {" STR ", " STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR "}, false }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := wordBreak ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 , c . input 2 ) # } # }) # }
s := & Stack {} # s . stack = make ([] interface {}, 0 ) # s . len = 0 # # return s
sMap := make ( map [ string ] bool ) # var res [] string # for i := 0 ; i < len ( s )- 9 ; i ++ { # if _ , ok := sMap [ s [ i : i + 1 0 ]]; ok { # if sMap [ s [ i : i + 1 0 ]] == true { # res = append ( res , s [ i : i + 1 0 ]) # } # sMap [ s [ i : i + 1 0 ]] = false # } else { # sMap [ s [ i : i + 1 0 ]] = true # } # } # return res
flag := 1 # switch { # case x < - 9 : # flag = - 1 # x *= - 1 # case x < 1 0 : # return x # } # var r int # for x > 0 { # r = r * 1 0 + x % 1 0 # x /= 1 0 # } # if r > math . MaxInt 3 2 || r < math . MinInt 3 2 { # return 0 # } # return flag * r
if n == 0 { # return " STR " # } # # res := make ([] byte , n ) # # nums := make ([] byte , n ) # for i := 0 ; i < n ; i ++ { # nums [ i ] = byte ( i ) + ' 1 ' # } # # f := 1 # for i := 1 ; i < n ; i ++ { # f *= i # } # # k -- # # for i := 0 ; i < n ; i ++ { # index := k / f # res [ i ] = nums [ index ] # if i == n - 1 { # break # } # nums = append ( nums [: index ], nums [ index + 1 :]...) # k %= f # f /= n - i - 1 # } # return string ( res )
data := [] string {" STR ", " STR ", " STR ", " STR ", " STR "} # sort . Slice ( data , func ( i , j int ) bool { # return data [ i ] > data [ j ] # }) # println (" STR ") # for _ , d := range data { # println ( d ) # }
b 1 , b 2 , s 1 , s 2 := math . MinInt 3 2 , math . MinInt 3 2 , 0 , 0 # for _ , p := range prices { # b 1 = max ( b 1 , - p ) # s 1 = max ( s 1 , b 1 + p ) # b 2 = max ( b 2 , s 1 - p ) # s 2 = max ( s 2 , b 2 + p ) # } # return s 2
var stack [] int # result := make ([] int , len ( arr )) # for i := len ( arr ) - 1 ; i >= 0 ; i -- { # for len ( stack ) > 0 && arr [ i ] >= arr [ stack [ len ( stack )- 1 ]] { # stack = stack [: len ( stack )- 1 ] # } # if len ( stack ) == 0 { # result [ i ] = 0 # } else { # result [ i ] = stack [ len ( stack )- 1 ] - i # } # stack = append ( stack , i ) # } # return result
return [...] string {" STR ", " STR ", " STR ", " STR ", " STR "}[ l ]
helper 9 1 2 ( nums , 0 , len ( nums )- 1 ) # return nums
random := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # letters := [] rune (" STR ") # text := make ([] rune , random . Intn ( 1 5 - 1 0 )+ 1 0 ) # for i := range text { # text [ i ] = letters [ rand . Intn ( len ( letters ))] # } # end := random . Intn ( len ( text )- 5 ) + 5 # start := random . Intn ( end ) # result := RabinKarp ( string ( text ), string ( text [ start : end ])) # if result == - 1 { # t . Fail () # }
sp := strings . Split ( s , " STR ") # ret := " STR " # for i := 0 ; i < len ( sp ); i ++ { # t := make ([] byte , len ( sp [ i ])) # for left , right := 0 , len ( sp [ i ])- 1 ; left <= right ; left , right = left + 1 , right - 1 { # t [ left ], t [ right ] = sp [ i ][ right ], sp [ i ][ left ] # } # ret += string ( t ) # if i != len ( sp )- 1 { # ret += " STR " # } # } # return ret #
concat = to # for i := range from { # if ! Contains ( concat , from [ i ]) { # concat = IntArrayCapUp ( concat ) # concat [ len ( concat )- 1 ] = from [ i ] # } # } # return concat
bs := [] byte ( strconv . Itoa ( num )) # bucket := [ 1 0 ] int {} # for i , b := range bs { # bucket [ b -' 0 '] = i # } # for i , b := range bs { # for k := 9 ; k > int ( b -' 0 '); k -- { # j := bucket [ k ] # if j > i { # bs [ i ] = bs [ j ] # bs [ j ] = b # num , _ = strconv . Atoi ( string ( bs )) # return num # } # } # } # return num
dp := make ([][] int , n + 1 ) # for i := 0 ; i < n + 1 ; i ++ { # dp [ i ] = make ([] int , n + 1 ) # } # # for j := 2 ; j < n + 1 ; j ++ { # for i := j - 1 ; i > 0 ; i -- { # dp [ i ][ j ] = i + dp [ i + 1 ][ j ] # for k := i + 1 ; k < j ; k ++ { # dp [ i ][ j ] = min ( dp [ i ][ j ], k + max ( dp [ i ][ k - 1 ], dp [ k + 1 ][ j ])) # } # } # } # return dp [ 1 ][ n ]
var result [] string # chars := make ([] byte , 0 , n * 2 ) # gp (& result , chars , n , n ) # return result
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 2 , 2 , 6 , 6 , 6 , 6 , 7 , 1 0 }, 6 }, # {" STR ", [] int { 4 , 4 }, 4 }, # {" STR ", [] int { 1 , 1 , 1 , 2 }, 1 }, # {" STR ", [] int { 7 }, 7 }, # {" STR ", [] int { 1 , 2 , 2 , 2 , 3 , 4 , 5 , 6 }, 2 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
return atMostK ( A , K ) - atMostK ( A , K - 1 )
seq := [] int { 4 , 8 , # offlineminimumExtract , # 3 , # offlineminimumExtract , # 9 , 2 , 6 , # offlineminimumExtract , # offlineminimumExtract , # offlineminimumExtract , # 1 , 7 , # offlineminimumExtract , # 5 } # exp := [] int { 4 , 3 , 2 , 6 , 8 , 1 } # extractSeq := offLineMinimum ( seq ) # if ! reflect . DeepEqual ( extractSeq , exp ) { # t . Log ( fmt . Sprintf (" STR ", exp , extractSeq )) # t . Fail () # }
dup := 0 # for i := 0 ; i < len ( nums ); i ++ { # n := abs ( nums [ i ]) # # if nums [ n - 1 ] < 0 { # dup = n # } else { # nums [ n - 1 ] = - nums [ n - 1 ] # } # } # # mis := 0 # for i , v := range nums { # if v > 0 { # mis = i + 1 # break # } # } # # return [] int { dup , mis }
res := [] int { 0 , 1 , 2 , 3 , 8 , 1 0 , 3 6 , 4 1 , 1 3 2 , 2 5 0 , 7 0 0 , 7 5 0 , 4 0 1 0 , 4 2 3 7 , 1 0 6 8 0 , 2 4 6 7 9 , 8 7 3 2 8 , 9 0 4 7 8 , 4 3 5 8 1 2 } # return res [ N ]
stack := & MyStack {} # for ix := 0 ; ix < 5 ; ix ++ { # stack . Push ( ix ) # } # pv := stack . Pop () # # if pv != 4 { # t . Fatalf (" STR ", 0 , pv ) # } # stack . Push ( 6 ) # stack . Pop () # pv = stack . Pop () # if pv != 2 { # t . Fatalf (" STR ", 2 , pv ) # } # pv = stack . Top () # if pv != 1 { # t . Fatalf (" STR ", 1 , pv ) # }
if len ( nums ) < 2 { # return len ( nums ) # } # start , preVal := 1 , nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] != preVal { # start , preVal , nums [ start ] = start + 1 , nums [ i ], nums [ i ] # } # } # return start
t . Parallel () # # for tcid , tc := range testcases { # if result := MergeBinaryTrees ( tc . one , tc . two ); ! equal ( result , tc . merged ) { # t . Errorf (" STR ", tcid ) # } # }
fmt . Println ( findPoisonedDuration ([] int { 1 , 4 }, 2 )) # fmt . Println ( findPoisonedDuration ([] int { 1 , 2 }, 2 ))
a := big . NewInt ( 2 ) # b := big . NewInt ( 2 ) # # for i := 9 9 9 ; i > 0 ; i -- { # a = a . Mul ( a , b ) # } # # strNum := a . String () # # sum := 0 # for _ , i := range [] byte ( strNum ) { # sum += int ( i - ' 0 ') # } # # return sum
fmt . Printf (" STR ", e . Dob . String (), e . JobTitle , e . Location )
b . StopTimer () # h := NewFibHeap () # b . StartTimer () # for i := 0 ; i < b . N ; i ++ { # b . StopTimer () # n := rand . Intn ( 1 0 0 0 0 ) # b . StartTimer () # h . Insert ( n , n ) # }
return l . Length
m := map [ string ] int {" STR ": 1 , " STR ": 5 , " STR ": 1 0 , " STR ": 5 0 , " STR ": 1 0 0 , " STR ": 5 0 0 , " STR ": 1 0 0 0 } # ans := 0 # for i , _ := range s { # ans += m [ string ( s [ i ])] # if i > 0 && m [ string ( s [ i ])] > m [ string ( s [ i - 1 ])] { # ans -= 2 * m [ string ( s [ i - 1 ])] # } # } # return ans #
f := func ( s string ) string { # var s 2 string # for i := len ( s ) - 1 ; i >= 0 ; i -- { # s 2 += string ( s [ i ]) # } # return s 2 # } # # var ( # i int # s 2 string # ) # for i < len ( s ) { # if i + k > len ( s ) { # s 2 += f ( s [ i :]) # break # } # s 2 += f ( s [ i : i + k ]) # i += k # # if i + k > len ( s ) { # s 2 += s [ i :] # break # } # s 2 += s [ i : i + k ] # i += k # } # return s 2
iE := i .(** ltHeapElement ) # jE := j .(** ltHeapElement ) # (* iE ), (* jE ) = (* jE ), (* iE )
arr := [] int { 1 , 3 , 2 , 2 , 4 , 5 } # sortedArr := make ([] int , 0 , 0 ) # for _ , v := range arr { # h . Append ( v ) # } # for h . Len () > 0 { # sortedArr = append ( sortedArr , h . Pop ().( int )) # } # sort . Sort ( sort . Reverse ( sort . IntSlice ( arr ))) # if ! reflect . DeepEqual ( sortedArr , arr ) { # t . Log ( fmt . Sprintf (" STR ", arr ) + fmt . Sprintf (" STR ", sortedArr )) # t . Fail () # }
lo , hi := 0 , num # for lo <= hi { # mid := lo + ( hi - lo )/ 2 # # m 2 := mid * mid # switch { # case m 2 < num : # lo = mid + 1 # case m 2 > num : # hi = mid - 1 # default : # return true # } # } # return false
sort . Slice ( A , func ( i , j int ) bool { # return A [ i ]% 2 < A [ j ]% 2 # }) # return A
max := 0 # temp := 0 # for i := 1 ; i < len ( prices ); i ++ { # temp += prices [ i ] - prices [ i - 1 ] # if temp < 0 { # temp = 0 # } # if max < temp { # max = temp # } # } # # return max
return (* funcValueWithSignature )( unsafe . Pointer ( val . id )). funcPtr
for i := 0 ; i < b . N ; i ++ { # getCoeff ( 1 3 1 3 1 3 1 3 1 , 1 2 1 2 1 2 1 2 1 ) # }
roman := [][] string { # {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR ", " STR "}, # } # # var result string # var flag int # for num > 0 { # t := num % 1 0 # result = roman [ flag ][ t ] + result # flag ++ # num /= 1 0 # } # return result
var res [] int # var max * TreeNode # for root != nil { # res = append ( res , root . Val ) # if root . Left == nil { # root = root . Right # } else { # max = root . Left # for max . Right != nil { # max = max . Right # } # # max . Right = root . Right # root , root . Left = root . Left , nil # } # } # return res
low , high := int 6 4 ( 0 ), int 6 4 ( 2 * 1 e 9 ) # for low < high { # mid := low + ( high - low )>> 1 # if calNthCount ( mid , int 6 4 ( a ), int 6 4 ( b ), int 6 4 ( c )) < int 6 4 ( n ) { # low = mid + 1 # } else { # high = mid # } # } # return int ( low )
t . Parallel () # # for tcid , tc := range testcases { # if result := PruneZeroSubtrees ( tc . head ); ! treeEqual ( result , tc . expected ) { # t . Errorf (" STR ", tcid ) # } # }
runes := [] rune ( s ) # runeMap := make ( map [ rune ] int ) # longest := 0 # preLength := 0 # for i , rn := range runes { # var length int # if val , ok := runeMap [ rn ]; ! ok || val < i - preLength { # length = preLength + 1 # } else { # length = i - val # } # if length > longest { # longest = length # } # preLength = length # runeMap [ rn ] = i # } # return longest
cl . hc . CloseIdleConnections () # return nil
n := len ( timePoints ) # sort . Strings ( timePoints ) # # minDiff := 2 4 * 6 0 - diff ( timePoints [ 0 ], timePoints [ n - 1 ]) # # for i := 1 ; i < n ; i ++ { # minDiff = min ( minDiff , diff ( timePoints [ i - 1 ], timePoints [ i ])) # } # # return minDiff
major , count := nums [ 0 ], 0 # # for _ , v := range nums { # if count == 0 { # count ++ # major = v # } else if major == v { # count ++ # } else { # count -- # } # } # # return major
t . Parallel () # b := NewLRUCache ( 3 ) # # if v , ok := b . Get (" STR "); v != nil || ok != false { # t . Error (" STR ") # } # # b . Set (" STR ", nil , time . Time {}) # # if v , ok := b . Get (" STR "); v != nil || ok != true { # t . Error (" STR ") # } # # if v , ok := b . Get (" STR "); v != nil || ok != false { # t . Error (" STR ") # } # # b . Set (" STR ", " STR ", time . Time {}) # # if v , ok := b . Get (" STR "); v != " STR " || ok != true { # t . Error (" STR ") # }
res := math . MaxInt 3 2 # var prev * int # # var inorder func (* TreeNode ) # inorder = func ( node * TreeNode ) { # if node == nil { # return # } # # inorder ( node . Left ) # if prev != nil { # res = min ( res , node . Val -* prev ) # } # prev = & node . Val # inorder ( node . Right ) # } # inorder ( root ) # return res
return & Queue { nums : [] int {}}
ch := make ( chan int ) # go func () { # for _ , val := range b . bag { # ch <- val # } # close ( ch ) # }() # return ch
ans := make ([][] int , numRows ) # for i := 0 ; i < numRows ; i ++ { # row := make ([] int , i + 1 ) # row [ 0 ], row [ i ] = 1 , 1 # for j := 1 ; j < i ; j ++ { # row [ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ] # } # ans [ i ] = row # } # return ans
type arg struct { # nums 1 [] int # m int # nums 2 [] int # n int # } # testCases := [] arg { # { nums 1 : [] int { 1 , 2 , 3 , 7 , 0 , 0 , 0 }, m : 4 , nums 2 : [] int { 2 , 5 , 6 }, n : 3 }, # { nums 1 : [] int { 2 , 5 , 6 , 0 , 0 , 0 }, m : 3 , nums 2 : [] int { 7 , 8 , 9 }, n : 3 }, # } # # expected := [][] int {{ 1 , 2 , 2 , 3 , 5 , 6 , 7 }, { 2 , 5 , 6 , 7 , 8 , 9 }} # # for index , data := range testCases { # if merge ( data . nums 1 , data . m , data . nums 2 , data . n ); ! reflect . DeepEqual ( expected [ index ], data . nums 1 ) { # t . Errorf (" STR ", expected [ index ], data . nums 1 ) # } # }
t . Parallel () # # for _ , tc := range testcases { # if result := LookAndSay ( tc . n ); result != tc . result { # t . Errorf (" STR ", tc . result , result ) # } # }
if head == nil { # return head # } # head = & ListNode { Val : - 1 , Next : head } # curr := head # for curr != nil { # psum := 0 # next := curr . Next # for next != nil { # psum += next . Val # if psum == 0 { # curr . Next = next . Next # } # next = next . Next # } # curr = curr . Next # } # return head . Next
hash := make ( map [ uint 8 ] int ) # cut := 0 # # for i := 0 ; i < len ( s ); i ++ { # fmt . Println ( s [ i ]) # if _ , ok := hash [ s [ i ]]; ! ok { # cut ++ # } # hash [ s [ i ]]++ # } # # res := " STR " # for i , j , c := 0 , 0 , 0 ; i < len ( s ); i ++ { # if hash [ s [ i ]] == 1 { # c ++ # } # hash [ s [ i ]]-- # for c == cut && hash [ s [ i ]] < 0 { # hash [ s [ j ]]++ # j ++ # } # if c == cut { # if res == " STR " || len ( res ) > i - j + 1 { # res = s [ j : i - j + 1 ] # } # } # # } # return res
slow , fast := n , n # for { # slow = digitSquareSum ( slow ) # fast = digitSquareSum ( fast ) # fast = digitSquareSum ( fast ) # # if 1 == fast { # return true # } # if slow == fast { # break # } # } # return false
qs := [] question 8 9 2 { # # { # para 8 9 2 {[][] int {{ 2 }}}, # ans 8 9 2 { 1 0 }, # }, # # { # para 8 9 2 {[][] int {{ 1 , 2 }, { 3 , 4 }}}, # ans 8 9 2 { 3 4 }, # }, # # { # para 8 9 2 {[][] int {{ 1 , 0 }, { 0 , 2 }}}, # ans 8 9 2 { 1 6 }, # }, # # { # para 8 9 2 {[][] int {{ 1 , 1 , 1 }, { 1 , 0 , 1 }, { 1 , 1 , 1 }}}, # ans 8 9 2 { 3 2 }, # }, # # { # para 8 9 2 {[][] int {{ 2 , 2 , 2 }, { 2 , 1 , 2 }, { 2 , 2 , 2 }}}, # ans 8 9 2 { 4 6 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 9 2 , q . para 8 9 2 # fmt . Printf (" STR ", p , surfaceArea ( p . one )) # } # fmt . Printf (" STR ")
qs := [] question 2 0 4 { # # { # para 2 0 4 { 1 0 }, # ans 2 0 4 { 4 }, # }, # # { # para 2 0 4 { 1 0 0 }, # ans 2 0 4 { 2 5 }, # }, # # { # para 2 0 4 { 1 0 0 0 }, # ans 2 0 4 { 1 6 8 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 0 4 , q . para 2 0 4 # fmt . Printf (" STR ", p , countPrimes ( p . one )) # } # fmt . Printf (" STR ")
return [] byte ( fmt . Sprintf (`" STR "`, d . String ())), nil
if n == 0 { # return []* TreeNode {} # } # return generateTreesI ( 1 , n )
return & Reader { # r : r , # }
parts := strings . Split ( path , " STR ") # var result [] string # for _ , part := range parts { # switch part { # case " STR ": # result = result [: len ( result )- 1 ] # case " STR ": # default : # result = append ( result , part ) # } # } # return strings . Join ( result , " STR ")
m := nums [ 0 ] # for _ , v := range nums { # if v < m { # m = v # } # } # return m
n := len ( candies ) # # r := make ( map [ int ] bool , n ) # for _ , c := range candies { # r [ c ] = true # } # # return min ( len ( r ), n / 2 )
isNotPrime := make ([] bool , n ) # for i := 2 ; i * i < n ; i ++ { # if isNotPrime [ i ] { # continue # } # for j := i * i ; j < n ; j = j + i { # isNotPrime [ j ] = true # } # } # count := 0 # for i := 2 ; i < n ; i ++ { # if ! isNotPrime [ i ] { # count ++ # } # } # return count
return c != nil && c . Table != " STR "
length := len ( nums ) # if length == 0 { # return false # } # k := 1 # for k < len ( nums ) && nums [ k - 1 ] <= nums [ k ] { # k ++ # } # # i , j := 0 , length - 1 # for i <= j { # m := ( i + j ) / 2 # med := ( m + k ) % length # # switch { # case nums [ med ] < target : # i = m + 1 # case target < nums [ med ]: # j = m - 1 # default : # return true # } # } # # return false
defer wg . Done () # # for count := 0 ; count < 2 ; count ++ { # value := counter # # runtime . Gosched () # # value ++ # # counter = value # }
return & lruCache { # node : make ([] lruNode , capacity ), # head : nil , # tail : nil , # capacity : capacity , # used : 0 , # }
m := item [ 0 ] # for _ , v := range item { # if v > m { # m = v # } # } # return m
output := make ([] string , 0 ) # for k , v := range METHOD_ACCESS_FLAGS { # if flags & k != 0 { # output = append ( output , v ) # } # } # return strings . Join ( output , " STR ")
borad := [][] byte { # [] byte {" STR ", " STR ", " STR ", " STR "}, # [] byte {" STR ", " STR ", " STR ", " STR "}, # [] byte {" STR ", " STR ", " STR ", " STR "}, # } # t . Log (" STR ", exist ( borad , " STR ")) # t . Log (" STR ", exist ( borad , " STR ")) # t . Log (" STR ", exist ( borad , " STR "))
res := 0 # var postorder func (* TreeNode ) int # postorder = func ( node * TreeNode ) int { # if node == nil { # return 0 # } # l , r := postorder ( node . Left ), postorder ( node . Right ) # res += abs ( l , r ) # return l + node . Val + r # } # postorder ( root ) # return res
var ranges [] Range # uniqStrs := make ( map [ string ] string ) # scanner := bufio . NewScanner ( f ) # lineNum := 1 # for scanner . Scan () { # r , ok , lineErr := ParseBlocklistP 2 PLine ( scanner . Bytes ()) # if lineErr != nil { # err = fmt . Errorf (" STR ", lineNum , lineErr ) # return # } # lineNum ++ # if ! ok { # continue # } # if s , ok := uniqStrs [ r . Description ]; ok { # r . Description = s # } else { # uniqStrs [ r . Description ] = r . Description # } # ranges = append ( ranges , r ) # } # err = scanner . Err () # if err != nil { # return # } # ret = New ( ranges ) # return
var m , n int # if len ( matrix ) == 0 || len ( matrix [ 0 ]) == 0 { # m , n = 0 , 0 # } else { # m , n = len ( matrix ), len ( matrix [ 0 ]) # } # # dp := make ([][] int , m + 1 ) # for i := range dp { # dp [ i ] = make ([] int , n + 1 ) # } # # for i := 1 ; i <= m ; i ++ { # for j := 1 ; j <= n ; j ++ { # dp [ i ][ j ] = matrix [ i - 1 ][ j - 1 ] + dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ] - dp [ i - 1 ][ j - 1 ] # } # } # # return NumMatrix { dp : dp }
t . Parallel () # for tcid , tc := range testcases { # if result := SwapEveryTwo ( tc . input ); ! equal ( result , tc . expected ) { # t . Errorf (" STR ", tcid ) # } # }
var tests = [] struct { # before [] interface {} # after * TreeNode # }{ # {[] interface {}{ 5 , 2 , 1 3 }, newTree ( 1 8 , 2 0 , 1 3 )}, # {[] interface {}{ 4 , 2 , 6 , 1 , 3 , 5 , 7 }, newTree ( 2 2 , 2 7 , 1 3 , 2 8 , 2 5 , 1 8 , 7 )}, # } # # for _ , tt := range tests { # after := convertBST ( newTree ( tt . before ...)) # if reflect . DeepEqual ( after , tt . after ) == false { # t . Errorf (" STR ", newTree ( tt . before ...), after , tt . after ) # } # }
s . stack = append ( s . stack , x ) # if len ( s . minStack ) == 0 || x < s . minStack [ len ( s . minStack )- 1 ] { # s . minStack = append ( s . minStack , x ) # } else { # s . minStack = append ( s . minStack , s . minStack [ len ( s . minStack )- 1 ]) # }
go close ( ch )
if len ( nums ) == 1 { # return nums [ 0 ] # } # n := len ( nums ) # # if n % 2 == 1 { # count := 1 # # for i := 0 ; i < n - 1 ; i ++ { # if nums [ n - 1 ] == nums [ i ] { # count ++ # } # } # if count > n / 2 { # return nums [ n - 1 ] # } # } # numsTmp := [] int {} # # for i := 0 ; i < n / 2 ; i ++ { # if nums [ 2 * i ] == nums [ 2 * i + 1 ] { # numsTmp = append ( numsTmp , nums [ 2 * i ]) # } # } # # return majorityElement 1 ( numsTmp )
res := 0 # for i := L ; i <= R ; i ++ { # switch bits . OnesCount 3 2 ( uint 3 2 ( i )) { # case 2 , 3 , 5 , 7 , 1 1 , 1 3 , 1 7 , 1 9 : # res ++ # } # } # return res
input := bufio . NewScanner ( c ) # for input . Scan () { # echo ( c , input . Text (), 1 * time . Second ) # } # c . Close ()
var k , max int # for _ , n := range nums { # if k += n ; n == 0 { # if k > max { # max = k # } # k = 0 # } # } # if k > max { # max = k # } # return max
qs := [] question 5 2 4 { # # { # para 5 2 4 {" STR ", [] string {" STR ", " STR ", " STR ", " STR "}}, # ans 5 2 4 {" STR "}, # }, # # { # para 5 2 4 {" STR ", [] string {" STR ", " STR ", " STR "}}, # ans 5 2 4 {" STR "}, # }, # # { # para 5 2 4 {" STR ", [] string {" STR ", " STR ", " STR "}}, # ans 5 2 4 {" STR "}, # }, # # { # para 5 2 4 {" STR ", [] string {" STR ", " STR ", " STR ", " STR "}}, # ans 5 2 4 {" STR "}, # }, # # { # para 5 2 4 {" STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 5 2 4 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 2 4 , q . para 5 2 4 # fmt . Printf (" STR ", p , findLongestWord ( p . s , p . one )) # } # fmt . Printf (" STR ")
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 3 , 6 , 1 , 0 }, 1 }, # {" STR ", [] int { 1 , 2 , 3 , 4 }, - 1 }, # {" STR ", [] int { 6 }, 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
x , y := 2 0 , 1 0 # # result := Add ( x , y ) # fmt . Println (" STR ", result ) # # result = Subtract ( x , y ) # fmt . Println (" STR ", result )
tests := [...] testType { # { # in : [][] int { # { 1 , 2 , 3 , 4 }, # { 5 , 1 , 2 , 3 }, # { 9 , 5 , 1 , 2 }, # }, # want : true , # }, # { # in : [][] int { # { 1 , 2 }, # { 2 , 2 }, # }, # want : false , # }, # } # for _ , tt := range tests { # got := isToeplitzMatrix ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
sequenceLength := 0 # # for i := n ; i > 1 ; i -- { # if sequenceLength >= i { # break # } # # foundRemainders := make ([] int , i ) # value , position := 1 , 0 # # for foundRemainders [ value ] == 0 && value != 0 { # foundRemainders [ value ] = position # value *= 1 0 # value %= i # position ++ # } # # if position - foundRemainders [ value ] > sequenceLength { # sequenceLength = position - foundRemainders [ value ] # } # } # return sequenceLength + 1
bytes := make ([] string , 0 , 4 ) # return dfs ( nil , bytes , s )
if size < 0 { # return reflect . MakeMapWithSize ( t , 4 ) # } # return reflect . MakeMapWithSize ( t , size )
n := len ( stones ) # if n == 0 || stones [ 1 ] != 1 { # return false # } # # if n == 1 || n == 2 { # return true # } # # last := stones [ n - 1 ] # # hs := make ( map [ int ] bool , n ) # # for i := 0 ; i < n ; i ++ { # if i > 3 && stones [ i ] > stones [ i - 1 ]* 2 { # return false # } # hs [ stones [ i ]] = true # } # # var dfs func ( map [ int ] bool , int , int ) bool # dfs = func ( hs map [ int ] bool , pos , jump int ) bool { # if pos + jump - 1 == last || pos + jump == last || pos + jump + 1 == last { # return true # } # for i := 1 ; - 1 <= i ; i -- { # if jump + i > 0 && hs [ pos + jump + i ] { # if dfs ( hs , pos + jump + i , jump + i ) { # return true # } # } # } # # return false # } # # return dfs ( hs , 1 , 1 )
max := int 6 4 ( math . Ceil ( math . Sqrt ( float 6 4 ( n )))) # var i int 6 4 # if n == 1 { # return false # } # if n == 2 { # return true # } # for i = 2 ; i <= max ; i ++ { # if n % i == 0 { # return false # } # } # return true
if h . min { # return a . Less ( b ) # } else { # return b . Less ( a ) # }
res , left , counter , freq := 0 , 0 , 0 , make ([] int , 2 6 ) # for right := 0 ; right < len ( s ); right ++ { # freq [ s [ right ]-' A ']++ # counter = max ( counter , freq [ s [ right ]-' A ']) # for right - left + 1 - counter > k { # freq [ s [ left ]-' A ']-- # left ++ # } # res = max ( res , right - left + 1 ) # } # return res
if x == 2 { return true } # var i , z int 6 4 = 2 , int 6 4 ( math . Sqrt ( float 6 4 ( x ))) # for ; i <= z ; i ++ { # if x % i == 0 { return false } # } # return true
w := [][] int {{ 1 , 1 , 5 , 5 }} # sol := Constructor 4 9 7 ( w ) # fmt . Printf (" STR ", sol . Pick ()) # fmt . Printf (" STR ", sol . Pick ()) # fmt . Printf (" STR ", sol . Pick ()) # fmt . Printf (" STR ", sol . Pick ()) # fmt . Printf (" STR ", sol . Pick ()) # fmt . Printf (" STR ", sol . Pick ())
if nil == root { # return & TreeNode { Val : val } # } # # if val > root . Val { # root . Right = insertIntoBST ( root . Right , val ) # } else { # root . Left = insertIntoBST ( root . Left , val ) # } # return root
if 0 == n { # return " STR " # } # # ans := " STR " # for n --; n > 0 ; n -- { # current := " STR " # for i := 0 ; i < len ( ans ); i ++ { # count := 1 # for i + 1 < len ( ans ) && ans [ i ] == ans [ i + 1 ] { # count ++ # i ++ # } # current += strconv . Itoa ( count ) + string ( ans [ i ]) # } # ans = current # } # return ans
if subtree . left != nil { # tree . PostorderTraversal ( subtree . left , callback ) # } # if subtree . right != nil { # tree . PostorderTraversal ( subtree . right , callback ) # } # callback ( subtree . data )
defer func () { # err := recover () # # if err == nil { # t . Errorf (" STR ") # return # } # # if _ , ok := err .( repanicType ); ! ok { # panic ( err ) # } # }() # # defer Recover () # # panic ( repanicType ( 1 ))
if len ( matrix ) == 0 { # return " STR " # } # spiral := make ([] string , 0 , len ( matrix )* len ( matrix [ 0 ])) # var r , c int # var left , top , right , bottom int = 0 , 0 , len ( matrix [ 0 ]), len ( matrix ) # for left < right && top < bottom { # for c < right { # spiral = append ( spiral , strconv . Itoa ( matrix [ r ][ c ])) # c ++ # } # c -- # r ++ # top ++ # for r < bottom { # spiral = append ( spiral , strconv . Itoa ( matrix [ r ][ c ])) # r ++ # } # r -- # c -- # right -- # for c >= left { # spiral = append ( spiral , strconv . Itoa ( matrix [ r ][ c ])) # c -- # } # c ++ # r -- # bottom -- # for r >= top { # spiral = append ( spiral , strconv . Itoa ( matrix [ r ][ c ])) # r -- # } # r ++ # c ++ # left ++ # } # return strings . Join ( spiral , " STR ")
n := len ( grid ) # r , c := make ([] int , n ), make ([] int , n ) # for i := 0 ; i < n ; i ++ { # for j := 0 ; j < n ; j ++ { # r [ i ] = max ( r [ i ], grid [ i ][ j ]) # c [ j ] = max ( c [ j ], grid [ i ][ j ]) # } # } # res := 0 # for i := 0 ; i < n ; i ++ { # for j := 0 ; j < n ; j ++ { # res += min ( r [ i ], c [ j ]) - grid [ i ][ j ] # } # } # return res
min 1 , min 2 := math . MaxInt 3 2 , math . MaxInt 3 2 # max 1 , max 2 , max 3 := math . MinInt 3 2 , math . MinInt 3 2 , math . MinInt 3 2 # for _ , n := range nums { # if n < min 1 { # min 1 , min 2 = n , min 1 # } else if n < min 2 { # min 2 = n # } # if n > max 3 { # max 1 , max 2 , max 3 = max 2 , max 3 , n # } else if n > max 2 { # max 1 , max 2 = max 2 , n # } else if n > max 1 { # max 1 = n # } # } # ans 1 , ans 2 := min 1 * min 2 * max 3 , max 1 * max 2 * max 3 # if ans 1 > ans 2 { # return ans 1 # } # return ans 2
return make ([] byte , length / 8 + 1 )
return q . list . Size
vv := reflect . ValueOf ( 0 xf 0 0 ) # if unsafe . Sizeof ( vv ) == ( ptrSize * 4 ) { # offsetScalar = ptrSize * 2 # offsetFlag = ptrSize * 3 # } # # upf := unsafe . Pointer ( uintptr ( unsafe . Pointer (& vv )) + offsetFlag ) # upfv := *(* uintptr )( upf ) # flagKindMask := uintptr (( 1 << flagKindWidth - 1 ) << flagKindShift ) # if ( upfv & flagKindMask )>> flagKindShift != uintptr ( reflect . Int ) { # flagKindShift = 0 # flagRO = 1 << 5 # flagIndir = 1 << 6 # # if upfv & flagIndir == 0 { # flagRO = 3 << 5 # flagIndir = 1 << 7 # } # }
io . WriteString ( res , " STR ")
var tests = [] struct { # before [] int # m , n int # after * ListNode # }{ # {[] int { 1 , 2 , 3 , 4 , 5 }, 2 , 4 , newList ( 1 , 4 , 3 , 2 , 5 )}, # } # # for _ , tt := range tests { # after := reverseBetween ( newList ( tt . before ...), tt . m , tt . n ) # if reflect . DeepEqual ( after , tt . after ) == false { # t . Errorf (" STR ", newList ( tt . before ...), tt . m , tt . n , after , tt . after ) # } # }
sort . Ints ( g ) # sort . Ints ( s ) # # i := 0 # for j := 0 ; i < len ( g ) && j < len ( s ); j ++ { # if g [ i ] <= s [ j ] { # i ++ # } # } # return i
funcs := make ([] func () int , 9 ) # for i := 0 ; i < 9 ; i ++ { # funcs [ i ] = func () int { # return i # } # } # result := make ([] int , 9 ) # for i , f := range funcs { # result [ i ] = f () # } # return result
var memo = [] int { 1 , 1 } # for i := 2 ; i <= n ; i ++ { # memo = append ( memo , memo [ i - 1 ]+ memo [ i - 2 ]) # } # return memo [ n ]
qs := [] question 4 6 1 { # # { # para 4 6 1 { 1 , 4 }, # ans 4 6 1 { 2 }, # }, # # { # para 4 6 1 { 1 , 1 }, # ans 4 6 1 { 0 }, # }, # # { # para 4 6 1 { 1 , 3 }, # ans 4 6 1 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 6 1 , q . para 4 6 1 # fmt . Printf (" STR ", p , hammingDistance ( p . x , p . y )) # } # fmt . Printf (" STR ")
if len ( intervals ) == 0 { # return nil # } # sort . Slice ( intervals , func ( i , j int ) bool { # switch { # case intervals [ i ]. Start < intervals [ j ]. Start : # return true # case intervals [ i ]. Start == intervals [ j ]. Start : # return intervals [ i ]. End <= intervals [ j ]. End # default : # return false # } # }) # merged := make ([] Interval , 0 , len ( intervals )) # current := intervals [ 0 ] # for i := 1 ; i < len ( intervals ); i ++ { # if intervals [ i ]. Start < current . End { # if intervals [ i ]. End > current . End { # current . End = intervals [ i ]. End # } # } else { # merged = append ( merged , current ) # current = intervals [ i ] # } # } # merged = append ( merged , current ) # return merged
h . hashMapBase . Init ( cap ) # if cap == 0 { # h . backets = nil # } else { # h . backets = make ([]* list . List , h . Cap , h . Cap ) # }
panic (" STR ")
rand 1 0 := 1 0 # for rand 1 0 >= 1 0 { # rand 1 0 = ( rand 7 () - 1 ) + rand 7 () # } # return rand 1 0 % 1 0 + 1
for _ , tc := range testcases { # if result := InorderMorrisTraversal ( tc . root ); ! reflect . DeepEqual ( tc . inorder , result ) { # t . Errorf (" STR ", tc . inorder , result ) # } # }
n := len ( nums ) # if n == 0 { # return 0 # } # left , right , res , sum := 0 , - 1 , n + 1 , 0 # for left < n { # if ( right + 1 ) < n && sum < s { # right ++ # sum += nums [ right ] # } else { # sum -= nums [ left ] # left ++ # } # if sum >= s { # res = min ( res , right - left + 1 ) # } # } # if res == n + 1 { # return 0 # } # return res
var tests = [] struct { # tree * TreeNode # sum int # }{ # { newTree ( 1 , 2 , 3 ), 2 5 }, # { newTree ( 1 , 2 , 2 , 3 ), 1 3 5 }, # { newTree ( 4 , 9 , 0 , 5 , 1 ), 1 0 2 6 }, # } # # for _ , tt := range tests { # sum := sumNumbers ( tt . tree ) # if sum != tt . sum { # t . Errorf (" STR ", tt . tree , sum , tt . sum ) # } # }
n := sum ([] float 6 4 { 9 8 , 9 3 , 7 7 , 8 2 , 8 3 }) # fmt . Println ( n )
return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { # start := time . Now () # log . Printf (" STR ", r . Method , r . URL . Path ) # ctx := context . WithValue ( r . Context (), " STR ", " STR ") # next . ServeHTTP ( w , r . WithContext ( ctx )) # log . Printf (" STR ", r . URL . Path , time . Since ( start )) # })
wordsMap := make ( map [ string ] int , len ( words )* 5 ) # for k := 0 ; k < len ( words ); k ++ { # for i := 0 ; i <= 1 0 && i <= len ( words [ k ]); i ++ { # for j := len ( words [ k ]); 0 <= j && len ( words [ k ])- 1 0 <= j ; j -- { # ps := words [ k ][: i ] + " STR " + words [ k ][ j :] # wordsMap [ ps ] = k # } # } # } # return WordFilter { words : wordsMap }
sum := 0 # # for curr , prev := 2 , 1 ; curr < 4 0 0 0 0 0 0 ; curr , prev = ( curr + prev ), curr { # if curr % 2 == 0 { # sum += curr # } # } # # fmt . Println ( sum )
var res uint 3 2 # for i := 0 ; i < 3 2 ; i ++ { # res = res << 1 | num & 1 # num >>= 1 # } # return res
for i := 0 ; i < 5 0 ; i ++ { # number = number + reverse ( number ) # if isP ( number ) { # return false # } # } # return true
size := len ( A ) # if size <= 2 { # return 0 # } # # res , up , down := 0 , 0 , 0 # for i := 1 ; i < size ; i ++ { # if ( down > 0 && A [ i - 1 ] < A [ i ]) || # A [ i - 1 ] == A [ i ] { # up , down = 0 , 0 # } # if A [ i - 1 ] < A [ i ] { # up ++ # } # if A [ i - 1 ] > A [ i ] { # down ++ # } # if up > 0 && down > 0 && up + down + 1 > res { # res = up + down + 1 # } # } # # return res
cases := [] struct { # name string # inputs [] int # expect [] int # }{ # {" STR ", [] int { 1 , 2 , 3 }, [] int { 1 , 2 }}, # {" STR ", [] int { 1 , 2 , 4 , 8 }, [] int { 1 , 2 , 4 , 8 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if _ , ok := suf . parents [ x ]; ok { # return # } # suf . parents [ x ] = x # suf . vals [ x ] = 1 . 0
terms := make ([] int , 0 ) # root := int ( math . Sqrt ( float 6 4 ( n ))) # if int ( root * root ) == n { # return terms # } # a := root # numerator := 0 # denominator := 1 # # for a != ( 2 * root ) { # numerator = denominator * a - numerator # denominator = ( n - numerator * numerator ) / denominator # a = ( root + numerator ) / denominator # terms = append ( terms , a ) # } # return terms
m := Mark { # english : 9 0 , # maths : 8 0 , # science : 7 0 , # social : 6 5 , # } # # s := & Student { # id : " STR ", # name : " STR ", # Mark : m , # } # # m 1 := m # m 1 . english = 8 5 # # s . setMark ( m 1 ) # s . getStudentMark () #
st . elements [ value ] = true
return MyCalendarTwo {}
n 1 , n 2 := len ( word 1 ), len ( word 2 ) # # dp := make ([][] int , n 1 + 1 ) # for i := range dp { # dp [ i ] = make ([] int , n 2 + 1 ) # } # # for i := 1 ; i <= n 1 ; i ++ { # for j := 1 ; j <= n 2 ; j ++ { # dp [ i ][ j ] = max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]) # if word 1 [ i - 1 ] == word 2 [ j - 1 ] { # dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + 1 # } # } # } # # return n 1 + n 2 - dp [ n 1 ][ n 2 ]* 2
if len ( nums ) == 0 { # return 0 # } # c , res := [] int {}, 0 # findcombinationSum 4 ( nums , target , 0 , c , & res ) # return res
list := [] int {- 1 , 2 , 1 , - 4 } # target := 1 0 # sort . Ints ( list ) # var data [] int # res := list [ 0 ] + list [ 1 ] + list [ 2 ] # data = [] int { list [ 0 ], list [ 1 ], list [ 2 ]} # length := len ( list ) # for i := 0 ; i < length - 2 ; i ++ { # left := i + 1 # right := length - 1 # for left < right { # s := list [ i ] + list [ left ] + list [ right ] # if math . Abs ( float 6 4 ( s - target )) < math . Abs ( float 6 4 ( res - target )) { # res = s # data = [] int { list [ i ], list [ left ], list [ right ]} # } else if s == target { # res = s # break # } else if s < target { # left = left + 1 # } else { # right = right - 1 # } # } # } # # fmt . Println ( res ) # fmt . Println ( data )
lgu , datas , _ := randData () # vEBT := newRsVEBTreeUint 3 2 ( lgu ) # insertData ( vEBT , datas ) # for i := range datas { # member := vEBT . Member ( i ) # e := member . Front () # for j := range datas [ i ] { # if e . Value != datas [ i ][ j ] { # t . Log ( fmt . Sprintf (" STR ", i , datas [ i ][ j ], e . Value )) # t . Fail () # } # e = e . Next () # } # }
maxDen , max , cycle := 1 , 0 , 1 # for i := 2 ; i < 1 0 0 0 ; i ++ { # cycle = calcCycle ( i ) # if cycle > max { # max = cycle # maxDen = i # } # } # fmt . Println (" STR ", maxDen , " STR ", max )
if n < 1 { # return 0 # } # if n < 4 { # return 1 # } # magic := make ([] int , n ) # magic [ 0 ] = 1 # magic [ 1 ] = 2 # magic [ 2 ] = 2 # ret , next := 1 , 1 # countIndex := 2 # count := magic [ countIndex ] # i := 3 # for i < n { # for count > 0 && i < n { # if next == 1 { # ret ++ # } # magic [ i ] = next # count -- # i ++ # } # if next == 1 { # next = 2 # } else { # next = 1 # } # countIndex ++ # count = magic [ countIndex ] # } # return ret
leetcode := new ( LeetCode ) # Problemsbuffer := getProblemsBuffer () # # if err := json . Unmarshal ( Problemsbuffer , leetcode ); err != nil { # log . Panicf (" STR ", err . Error ()) # } # # for i := 0 ; i < len ( leetcode . StatStatusPairs ); i ++ { # leetcode . StatStatusPairs [ i ]. PathName = string ( formatId ( leetcode . StatStatusPairs [ i ]. Stat . FrontendQuestionID )) + " STR " + # formatName ( leetcode . StatStatusPairs [ i ]. Stat . QuestionTitle ) # } # # return leetcode . StatStatusPairs
h := intHeap ( hand ) # heap . Init (& h ) # for h . Len () > 0 { # start := heap . Pop (& h ).( int ) # for i := 1 ; i < W ; i ++ { # if ! h . remove ( start + i ) { # return false # } # } # } # return true
tests := [...] testType { # { # in : " STR ", # want : 5 , # }, # { # in : " STR ", # want : 5 , # }, # { # in : " STR ", # want : 3 , # }, # { # in : " STR ", # want : 5 , # }, # } # for _ , tt := range tests { # got := maxScore ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if ! tree . color ( n ) { # if ! tree . IsNil ( n . Left ) && ! tree . color ( n . Left ) { # t . Log ( fmt . Sprintf (" STR ", n . Left , n )) # t . FailNow () # } # if ! tree . IsNil ( n . Right ) && ! tree . color ( n . Right ) { # t . Log ( fmt . Sprintf (" STR ", n . Right , n )) # t . FailNow () # } # }
return a [ n ]
var s StopWatch # s . Start () # time . Sleep ( time . Duration ( 1 * time . Second )) # s . Stop () # d := s . GetElapsed () # fmt . Printf (" STR ", Lrint ( d . Seconds ())) # s . Reset () # d = s . GetElapsed () # fmt . Printf (" STR ", Lrint ( d . Seconds ()))
n := len ( a ) # # var F , sum int # for i := 0 ; i < n ; i ++ { # F += i * a [ i ] # sum += a [ i ] # } # # maxF := F # for i := n - 1 ; 1 <= i ; i -- { # F += sum - n * a [ i ] # maxF = max ( F , maxF ) # } # # return maxF
if ! a . Rect . Eq ( b . Rect ) { # return false # } # # for i := 0 ; i < len ( a . Pix ); i ++ { # if a . Pix [ i ] != b . Pix [ i ] { # return false # } # } # return true
ws , res := make ([] int , len ( words )), make ([] int , len ( queries )) # for i , w := range words { # ws [ i ] = countFunc ( w ) # } # sort . Ints ( ws ) # for i , q := range queries { # fq := countFunc ( q ) # res [ i ] = len ( words ) - sort . Search ( len ( words ), func ( i int ) bool { return fq < ws [ i ] }) # } # return res
fmt . Println ( getNthPrimeNumber ( 1 0 0 0 1 ))
lo , hi := 0 , n # for lo < hi { # mid := hi - ( hi - lo )/ 2 # switch { # case mid *( mid + 1 ) < n + n : # lo = mid # case mid *( mid + 1 ) > n + n : # hi = mid - 1 # default : # return mid # } # } # return hi
triangle := make ([][] int , numRows ) # for r := 0 ; r < numRows ; r ++ { # triangle [ r ] = make ([] int , r + 1 ) # triangle [ r ][ 0 ] = 1 # for c := 1 ; c < r ; c ++ { # triangle [ r ][ c ] = triangle [ r - 1 ][ c - 1 ] + triangle [ r - 1 ][ c ] # } # triangle [ r ][ r ] = 1 # } # return triangle
testCases := [][] int { # { 1 , 0 , 0 }, # { 1 , 1 , 1 , 0 }, # { 0 }, # } # expected := [] bool { true , false , true } # # for index , bits := range testCases { # if res := isOneBitCharacter ( bits ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
var buckets [ 2 0 0 0 1 ] int 8 # for _ , num := range nums { # buckets [ num + 1 0 0 0 0 ]++ # } # # res := 0 # flag := true # for num , count := range buckets { # for count > 0 { # if flag { # res += num - 1 0 0 0 0 # } # flag = ! flag # count -- # } # } # # return res
side := 2 0 + 1 # grid := make ([][] int , side ) # for i := range grid { # grid [ i ] = make ([] int , side ) # grid [ i ][ 0 ] = 1 # grid [ 0 ][ i ] = 1 # } # for i := 1 ; i < side ; i ++ { # for x := 1 ; x < side ; x ++ { # grid [ x ][ i ] = grid [ x - 1 ][ i ] + grid [ x ][ i - 1 ] # } # } # println ( grid [ side - 1 ][ side - 1 ])
tests := [...] testType { # { # in : [] int { 2 , 7 , 4 , 1 , 8 , 1 }, # want : 1 , # }, # { # in : [] int { 2 , 7 , 4 , 1 , 8 , 1 , 5 }, # want : 0 , # }, # { # in : [] int { 3 1 6 , 1 5 7 , 7 3 , 1 0 6 , 7 7 1 , 8 2 8 }, # want : 3 7 , # }, # } # for _ , tt := range tests { # got := lastStoneWeight ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if level == len ( pyramid )- 1 { # return pyramid [ level ][ column ] # } # if mem [ level ][ column ] != 0 { # return mem [ level ][ column ] # } # down := MaximumPathSumHelper ( pyramid , column , level + 1 , mem ) # right := MaximumPathSumHelper ( pyramid , column + 1 , level + 1 , mem ) # var max int # if down > right { # max = down # } else { # max = right # } # sum := pyramid [ level ][ column ] + max # mem [ level ][ column ] = sum # return sum
nums 1 := [] int { 1 , 2 , 2 , 1 } # nums 2 := [] int { 2 , 2 } # # expectedData := [] int { 2 , 2 } # # if res := intersect ( nums 1 , nums 2 ); ! reflect . DeepEqual ( res , expectedData ) { # t . Errorf (" STR ", expectedData , res ) # }
n := len ( words ) # if n < 2 { # return nil # } # res := [][] int {} # # m := make ( map [ string ] int , n ) # for i := 0 ; i < n ; i ++ { # m [ words [ i ]] = i # } # # for i , word := range words { # for j := 0 ; j <= len ( word ); j ++ { # l , r := word [: j ], word [ j :] # # if isPalindrome ( l ) { # if k , ok := m [ reverse ( r )]; ok && i != k { # res = append ( res , [] int { k , i }) # } # } # # if len ( r ) != 0 && isPalindrome ( r ) { # if k , ok := m [ reverse ( l )]; ok && i != k { # res = append ( res , [] int { i , k }) # } # } # } # } # return res
return rgb 2 lin [ rgb ]
res := [] int {} # if root == nil { # return res # } # helper (& res , root ) # return res
return isMirror ( root , root )
if k == 0 || k == len ( nums ) { # return # } # if k > len ( nums ) { # k %= len ( nums ) # } # reverse ( nums [ 0 : len ( nums )- k ]) # reverse ( nums [ len ( nums )- k :]) # reverse ( nums )
if root == nil { # return nil # } # var res [][] int # var queue []* tree # rev := false # var level [] int # queue = append ( queue , root ) # queue = append ( queue , nil ) # for len ( queue ) > 0 { # root = queue [ 0 ] # queue = queue [ 1 :] # if root == nil { # if len ( queue ) > 0 { # queue = append ( queue , nil ) # } # res = append ( res , level ) # level = nil # rev = true # } else { # if rev { # level = append ([] int { root . data }, level ...) # } else { # level = append ( level , root . data ) # } # if root . left != nil { # queue = append ( queue , root . left ) # } # if root . right != nil { # queue = append ( queue , root . right ) # } # } # } # return res
http . Handle (" STR ", # http . StripPrefix (" STR ", # http . FileServer ( http . Dir (" STR ")))) # # http . HandleFunc (" STR ", func ( res http . ResponseWriter , req * http . Request ) { # catName := strings . Split ( req . URL . Path , " STR ")[ 2 ] # io . WriteString ( res , `<! DOCTYPE html > # < html > # < head > # < link href =" STR " type =" STR " rel =" STR "> # </ head > # < body > # Cat Name : < strong >`+ catName +`</ strong >< br > # < img src =" STR "> # </ body > # </ html >`) # }) # # http . ListenAndServe (" STR ", nil )
err := h . FromHexString ( s ) # if err != nil { # panic ( err ) # } # return
if c . writeTimeout != 0 { # c . conn . SetWriteDeadline ( time . Now (). Add ( c . writeTimeout )) # } # if err = c . writeTouchCommand ( key , timeout ); err == nil { # err = c . bw . Flush () # } # if err != nil { # return c . fatal ( err ) # } # if c . readTimeout != 0 { # c . conn . SetReadDeadline ( time . Now (). Add ( c . readTimeout )) # } # err = c . readTouchReply () # return
copied := make ([] int , len ( citations )) # copy ( copied , citations ) # # sort . Sort ( sort . Reverse ( sort . IntSlice ( copied ))) # # for index , citation := range copied { # if citation < index + 1 { # return index # } # } # # return len ( copied )
n := len ( g ) # sort . Ints ( g ) # sort . Ints ( s ) # # res := 0 # for _ , x := range s { # if res >= n { # break # } # if x >= g [ res ] { # res ++ # } # } # return res
m := make ( map [ int ] int ) # m [ 0 ] = - 1 # sum := 0 # for i := 0 ; i < len ( nums ); i ++ { # sum += nums [ i ] # if k != 0 { # sum %= k # } # prev , ok := m [ sum ] # if ok { # if i - prev > 1 { # return true # } # } else { # m [ sum ] = i # } # } # return false
red := color . RGBA { 2 5 5 , 0 , 0 , 2 5 5 } # blue := color . RGBA { 0 , 0 , 2 5 5 , 2 5 5 } # var p = ColoredPoint { Point { 1 , 1 }, red } # var q = ColoredPoint { Point { 5 , 4 }, blue } # fmt . Println ( p . Distance ( q . Point )) # p . ScaleBy ( 2 ) # q . ScaleBy ( 2 ) # fmt . Println ( p . Distance ( q . Point ))
t . Parallel () # # for _ , tc := range testcases { # if result := NumberOfValidPlayListsRec ( tc . N , tc . M , tc . B ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
for item , price := range db { # fmt . Fprintf ( w , " STR ", item , price ) # }
return this . isInt
cases := [] struct { # name string # input 1 string # input 2 [] string # expect [] string # }{ # {" STR ", " STR ", # [] string {" STR ", " STR ", " STR ", " STR ", " STR "}, [] string {" STR ", " STR "}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := wordBreak ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 , c . input 2 ) # } # }) # }
var i , sum uint 6 4 # for _ , n := range numbers { # i , _ = strconv . ParseUint ( n [: 1 6 ], 1 0 , 6 4 ) # sum += i # } # fmt . Println ( sum )
res := [][] int {} # if root == nil { # return res # } # queue := []* TreeNode { root } # for len ( queue ) > 0 { # l := len ( queue ) # list := [] int {} # for i := 0 ; i < l ; i ++ { # node := queue [ i ] # list = append ( list , node . Val ) # if node . Left != nil { # queue = append ( queue , node . Left ) # } # if node . Right != nil { # queue = append ( queue , node . Right ) # } # } # res = append ( res , list ) # queue = queue [ l :] # } # return res
if root == nil { # return nil # } # res := [][] int {} # que := Queue {} # que . Push ( root ) # # for que . Len () != 0 { # level_size := que . Len () # current_level := [] int {} # # for i := 0 ; i < level_size ; i ++ { # node := que . Pop ().(* TreeNode ) # current_level = append ( current_level , node . Val ) # # if node . Left != nil { # que . Push ( node . Left ) # fmt . Println ( node . Left ) # # } # if node . Right != nil { # que . Push ( node . Right ) # fmt . Println ( node . Right ) # } # } # res = append ( res , current_level ) # } # # return res
t . Parallel () # data := [] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } # Reverse ( sort . IntSlice ( data ), 3 , 8 ) # expected := [] int { 1 , 2 , 3 , 8 , 7 , 6 , 5 , 4 , 9 } # if ! reflect . DeepEqual ( data , expected ) { # t . Errorf (" STR ", expected , data ) # }
return & trieNode { # links : make ([]* trieNode , 2 6 ), # }
res := 0 # for n != 1 { # if n % 2 == 0 { # n /= 2 # } else if n == 3 || ( n / 2 )% 2 == 0 { # n -- # } else { # n ++ # } # res ++ # } # return res
var tests = [] struct { # tree * TreeNode # depth int # }{ # { newTree ( 3 , 9 , 2 0 , nil , nil , 1 5 , 7 ), 3 }, # { newTree ( 1 , 2 , 2 , 3 ), 3 }, # { newTree ( 1 , 2 , 2 , 3 , 3 , nil , nil , 4 , 4 ), 4 }, # { newTree ( 1 , 2 , 2 , 3 , nil , 3 , 3 , 4 ), 4 }, # { newTree ( 1 , 2 , 2 , nil , nil , nil , 3 , 4 , 4 ), 4 }, # } # # for _ , tt := range tests { # depth := maxDepth ( tt . tree ) # if depth != tt . depth { # t . Errorf (" STR ", tt . tree , depth , tt . depth ) # } # }
is := make ( map [ int ] int ) # for i , n := range nums { # is [ n ] = i # } # for i , n := range nums { # if j , ok := is [ target - n ]; ok && i != j { # return [] int { i , j } # } # } # return nil
if len ( S ) == 0 { # return 0 # } # stack := make ([] rune , 0 ) # for _ , v := range S { # if v == '(' { # stack = append ( stack , v ) # } else if ( v == ')') && len ( stack ) > 0 && stack [ len ( stack )- 1 ] == '(' { # stack = stack [: len ( stack )- 1 ] # } else { # stack = append ( stack , v ) # } # } # return len ( stack )
var i , j = m - 1 , n - 1 # # for k := m + n - 1 ; k >= 0 ; k -- { # if j < 0 || ( i >= 0 && nums 1 [ i ] > nums 2 [ j ]) { # nums 1 [ k ] = nums 1 [ i ] # i -- # } else { # nums 1 [ k ] = nums 2 [ j ] # j -- # } # }
if end < start || ( end - start ) < count { # return nil # } # nums := make ([] int , 0 ) # for len ( nums ) < count { # num := getRand (). Intn (( end - start )) + start # exist := false # for _ , v := range nums { # if v == num { # exist = true # break # } # } # if ! exist { # nums = append ( nums , num ) # } # } # return nums
if n == 0 { # return false # } # res := 0 # num := n # record := map [ int ] int {} # for { # for num != 0 { # res += ( num % 1 0 ) * ( num % 1 0 ) # num = num / 1 0 # } # if _ , ok := record [ res ]; ! ok { # if res == 1 { # return true # } # record [ res ] = res # num = res # res = 0 # continue # } else { # return false # } # }
total := 0 # for i := 1 ; i < max ; i ++ { # if i % 3 == 0 || i % 5 == 0 { # total += i # } # } # return total
for i := start ; i < index ; i ++ { # if nums [ i ] == nums [ index ] { # return true # } # } # return false
f , ok := s . LookupFunc ( n . Func ) # if ! ok { # return TypeInvalid , fmt . Errorf (" STR ", n . Func ) # } # # return f . ReturnType , nil
fmt . Println ( uniquePaths ( 7 , 3 ))
if n == 0 { # return " STR " # } # data := make ([] int , n ) # data [ 0 ] = 1 # iToS := [] byte (" STR ") # for i := 1 ; i < n ; i ++ { # data [ i ] = data [ i - 1 ] * i # } # ret := " STR " # k -- # for i := n - 1 ; i >= 0 ; i -- { # ret += string ( iToS [ k / data [ i ]]) # iToS = append ( iToS [: k / data [ i ]], iToS [ k / data [ i ]+ 1 :]...) # k = k % data [ i ] # } # return ret
if nil == root { # return 0 # } # sum := root . Val + treeSum ( root . Left , frequents ) + treeSum ( root . Right , frequents ) # if v , ok := frequents [ sum ]; ok { # frequents [ sum ] = v + 1 # } else { # frequents [ sum ] = 1 # } # return sum
qs := [] question 9 4 2 { # # { # para 9 4 2 {" STR "}, # ans 9 4 2 {[] int { 0 , 4 , 1 , 3 , 2 }}, # }, # # { # para 9 4 2 {" STR "}, # ans 9 4 2 {[] int { 0 , 1 , 2 , 3 }}, # }, # # { # para 9 4 2 {" STR "}, # ans 9 4 2 {[] int { 3 , 2 , 0 , 1 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 4 2 , q . para 9 4 2 # fmt . Printf (" STR ", p , diStringMatch ( p . S )) # } # fmt . Printf (" STR ")
out := 8 4 0 # if x := p 3 9 (); x != out { # t . Errorf (" STR ", x , out ) # }
cases := [] struct { # name string # inputs string # expect int # }{ # {" STR ", " STR ", 3 }, # {" STR ", " STR ", 4 }, # {" STR ", " STR ", 9 }, # {" STR ", " STR ", 5 8 }, # {" STR ", " STR ", 1 9 9 4 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := romanToInt ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
for i := 0 ; i < len ( a )- 1 ; i ++ { # if a [ i ] == i { # continue # } # # if a [ i ] == i + 1 && a [ i + 1 ] == i { # i ++ # } else { # return false # } # } # # return true
stockSpanner := StockSpanner { make ([] Node , 0 )} # return stockSpanner
ans , ec := 0 , 0 # for i , v := range seats { # if v == 0 { # ec ++ # } else if ec > 0 { # if i == ec { # ans = ec # } else if ( ec + 1 )/ 2 > ans { # ans = ( ec + 1 ) / 2 # } # ec = 0 # } # } # if ec > ans { # ans = ec # } # return ans
for i , num := range funcVals { # if got := Collatz ( num ); ! reflect . DeepEqual ( got , collatz [ i ]) { # t . Errorf (" STR ", num , got , collatz [ i ]) # } # }
for itemCount := len ( arr ) - 1 ; ; itemCount -- { # swap := false # for i := 1 ; i <= itemCount ; i ++ { # if arr [ i - 1 ] > arr [ i ] { # arr [ i - 1 ], arr [ i ] = arr [ i ], arr [ i - 1 ] # swap = true # } # } # if swap == false { # break # } # }
return getFields ( f . value , f . defaultTag )
newHead := new ( ListNode ) # newHead . Next = head # current := newHead # # for i := 0 ; i < m - 1 ; i ++ { # current = current . Next # } # prev := current # current = current . Next # # for i := 0 ; i < n - m ; i ++ { # node := & ListNode { current . Next . Val , prev . Next } # prev . Next = node # current . Next = current . Next . Next # } # return newHead . Next
if len ( nums ) == 0 { # return nil # } # return & TreeNode { # Val : nums [ len ( nums )/ 2 ], # Left : sortedArrayToBST ( nums [: len ( nums )/ 2 ]), # Right : sortedArrayToBST ( nums [ len ( nums )/ 2 + 1 :]), # }
var s Shape # s = & Circle { 0 , 0 , 5 } # fmt . Println ( s . perimeter ()) # s = & Rectangle { 0 , 0 , 1 0 , 1 0 } # fmt . Println ( s . perimeter ())
max := int 6 4 ( 1 0 0 0 0 0 0 ) # sum := int 6 4 ( 0 ) # # for i := int 6 4 ( 0 ); i < max ; i ++ { # if strconv . FormatInt ( i , 1 0 ) == reverse ( strconv . FormatInt ( i , 1 0 )) && strconv . FormatInt ( i , 2 ) == reverse ( strconv . FormatInt ( i , 2 )) { # sum += i # } # } # fmt . Println ( sum )
if idx >= n { # ret ++ # return # } else { # for i := 0 ; i < n ; i ++ { # if col [ i ] == true || right [ i + idx ] == true || left [ n - i - 1 + idx ] == true { # continue # } # col [ i ] = true # right [ i + idx ] = true # left [ n - i - 1 + idx ] = true # help ( col , left , right , idx + 1 , n ) # col [ i ] = false # right [ i + idx ] = false # left [ n - i - 1 + idx ] = false # } # }
res := 0 # n := len ( A ) # dp := make ([] map [ int ] int , n ) # for i := 0 ; i < n ; i ++ { # dp [ i ] = make ( map [ int ] int ) # for j := 0 ; j < i ; j ++ { # diff := A [ i ] - A [ j ] # if diff <= math . MinInt 3 2 || diff > math . MaxInt 3 2 { # continue # } # dp [ i ][ diff ] += dp [ j ][ diff ] + 1 # res += dp [ j ][ diff ] # } # } # return res
if len ( s ) < 2 { # return s # } # # begin , maxLen := 0 , 1 # # for i := 0 ; i < len ( s ); { # if len ( s )- i <= maxLen / 2 { # break # } # # b , e := i , i # for e < len ( s )- 1 && s [ e + 1 ] == s [ e ] { # e ++ # } # # i = e + 1 # # for e < len ( s )- 1 && b > 0 && s [ e + 1 ] == s [ b - 1 ] { # e ++ # b -- # } # # newLen := e + 1 - b # if newLen > maxLen { # begin = b # maxLen = newLen # } # } # # return s [ begin : begin + maxLen ]
return float 6 4 ( l )
count , res := 0 , 0 # for _ , r := range s { # if r == ' R ' { # count ++ # } else { # count -- # } # if count == 0 { # res ++ # } # } # return res
intersect := func ( a , b [] int ) [] int { # if a [ 0 ] > b [ 0 ] { # a , b = b , a # } # # if b [ 0 ] <= a [ 1 ] { # return [] int { b [ 0 ], int ( math . Min ( float 6 4 ( a [ 1 ]), float 6 4 ( b [ 1 ])))} # } # # return nil # } # # i , j := 0 , 0 # result := make ([][] int , 0 ) # for i < len ( A ) && j < len ( B ) { # in := intersect ( A [ i ], B [ j ]) # if in != nil { # result = append ( result , in ) # } # # if A [ i ][ 1 ] <= B [ j ][ 1 ] { # i ++ # } else { # j ++ # } # } # # return result
isNegative := false # if n < 0 { # isNegative = true # n = - n # } # # result := helper 5 0 ( x , n ) # if isNegative { # result = 1 / result # } # # return result
t . Parallel () # cases := [] struct { # name string # size int # characters string # key string # wantErr string # }{ # { # name : " STR ", size : 5 , characters : " STR ", key : " STR ", wantErr : "", # }, # { # name : " STR ", size : 5 , characters : " STR ", key : " STR ", wantErr : "", # }, # { # name : " STR ", size : 5 , characters : " STR ", key : " STR ", wantErr : " STR ", # }, # { # name : " STR ", size : 5 , characters : " STR ", key : " STR ", wantErr : " STR ", # }, # } # # for _ , tc := range cases { # t . Run ( tc . name , func ( t * testing . T ) { # _ , err := NewPolybius ( tc . key , tc . size , tc . characters ) # if err != nil && err . Error () != tc . wantErr { # t . Errorf (" STR ", err ) # } # }) # }
return (* byte )( unsafe . Pointer ( uintptr ( unsafe . Pointer ( ptr )) + 1 0 ))
var tests = [] struct { # nums [] int # once [] int # }{ # {[] int { 1 , 2 , 1 , 3 , 2 , 5 }, [] int { 3 , 5 }}, # {[] int { 3 , 2 , 3 , 7 , 2 , 1 }, [] int { 1 , 7 }}, # {[] int { 2 , 1 , 2 , 3 , 4 , 1 }, [] int { 3 , 4 }}, # {[] int { 1 , 2 }, [] int { 1 , 2 }}, # } # # for _ , tt := range tests { # once := singleNumber ( tt . nums ) # if len ( once ) != 2 { # t . Fatalf (" STR ", tt . nums , once ) # } # if ( once [ 0 ] != tt . once [ 0 ] || once [ 1 ] != tt . once [ 1 ]) && ( once [ 0 ] != tt . once [ 1 ] || once [ 1 ] != tt . once [ 0 ]) { # t . Errorf (" STR ", tt . nums , once , tt . once ) # } # }
M := [][] int { # { 0 , 1 , 2 , 3 }, # { 2 , 3 , 1 , 1 }, # } # # fmt . Println ( imageSmoother ( M ))
emailSet := map [ string ] bool {} # for _ , email := range emails { # parts := strings . Split ( email , " STR ") # localName := strings . Replace ( strings . Split ( parts [ 0 ], " STR ")[ 0 ], " STR ", "", - 1 ) # emailSet [ localName +" STR "+ parts [ 1 ]] = true # } # return len ( emailSet )
dummy := new ( ListNode ) # head , dummy . Next = dummy , head # for i := 0 ; i < m - 1 ; i ++ { # head = head . Next # } # newHead , _ := reverseList ( head . Next , n - m + 1 ) # head . Next = newHead # return dummy . Next
mask 1 , mask 2 := a & b , a & b # b = ^ a & b # # for ( mask 1 != 0 || mask 2 != 0 ) && b != 0 { # mask 1 <<= 1 # mask 2 >>= 1 # # m 1 , m 2 := mask 1 & b , mask 2 & b # # b = ^ mask 1 & b # b = ^ mask 2 & b # # mask 1 , mask 2 = m 1 , m 2 # # } # # if b == 0 { # return true # } # return false
jobs := make ([] job , len ( difficulty )) # for i := range difficulty { # jobs [ i ] = job { # d : difficulty [ i ], # p : profit [ i ], # } # } # sort . Slice ( jobs , func ( i int , j int ) bool { # return jobs [ i ]. d < jobs [ j ]. d # }) # # sort . Ints ( worker ) # # res := 0 # i := 0 # maxp := 0 # for _ , ability := range worker { # for i < len ( jobs ) && ability >= jobs [ i ]. d { # maxp = max ( maxp , jobs [ i ]. p ) # i ++ # } # res += maxp # } # # return res
node 1 5 := TreeNode { Val : 1 5 , Left : nil , Right : nil } # node 7 := TreeNode { Val : 7 , Left : nil , Right : nil } # node 9 := TreeNode { Val : 9 , Left : nil , Right : nil } # node 2 0 := TreeNode { Val : 2 0 , Left : & node 1 5 , Right : & node 7 } # node 3 := TreeNode { Val : 3 , Left : & node 9 , Right : & node 2 0 } # # result := levelOrderBottom (& node 3 ) # fmt . Println ( result )
comb := make ([] int , k ) # res := make ([][] int , 0 , c ( n , k )) # # var dfs func ( int , int ) # dfs = func ( index , start int ) { # if index == k { # tmp := make ([] int , k ) # copy ( tmp , comb ) # res = append ( res , tmp ) # return # } # # for i := start ; i <= n + 1 - k + index ; i ++ { # comb [ index ] = i # dfs ( index + 1 , i + 1 ) # } # } # dfs ( 0 , 1 ) # return res
path = append ( path , root . Val ) # if root . Left == nil && root . Right == nil && root . Val == sum { # clone := make ([] int , len ( path )) # copy ( clone , path ) # result = append ( result , clone ) # } # # if root . Left != nil { # result = helper 1 1 3 ( root . Left , sum - root . Val , path , result ) # } # # if root . Right != nil { # result = helper 1 1 3 ( root . Right , sum - root . Val , path , result ) # } # # path = path [: len ( path )- 1 ] # return result
data := [] int { 1 , 3 , 5 , 6 } # target := 2 # fmt . Println ( searchInsert ( data , target ))
if _ , ok := parents [ node ]; ok { # node . stackSizeType = Recursive # node . missingFrameInfo = node # return # } # parents [ node ] = struct {}{} # defer func () { # delete ( parents , node ) # }() # switch node . FrameSizeType { # case Bounded : # childMaxStackSize := uint 6 4 ( 0 ) # for _ , child := range node . Children { # if child . stackSizeType == Undefined { # child . determineStackSize ( parents ) # } # switch child . stackSizeType { # case Bounded : # if child . stackSize > childMaxStackSize { # childMaxStackSize = child . stackSize # } # case Unknown , Recursive , IndirectCall : # node . stackSizeType = child . stackSizeType # node . missingFrameInfo = child . missingFrameInfo # return # default : # panic (" STR ") # } # } # node . stackSize = node . FrameSize + childMaxStackSize # node . stackSizeType = Bounded # case Undefined : # node . stackSizeType = Unknown # node . missingFrameInfo = node # default : # panic (" STR ") # }
if ! a . Rect . Eq ( b . Rect ) { # return false # } # # for y := 0 ; y < a . Bounds (). Dy (); y ++ { # for x := 0 ; x < a . Bounds (). Dx (); x ++ { # pos := y * a . Stride + x * 4 # if a . Pix [ pos + 0 ] != b . Pix [ pos + 0 ] { # return false # } # if a . Pix [ pos + 1 ] != b . Pix [ pos + 1 ] { # return false # } # if a . Pix [ pos + 2 ] != b . Pix [ pos + 2 ] { # return false # } # if a . Pix [ pos + 3 ] != b . Pix [ pos + 3 ] { # return false # } # } # } # return true
newE := new ( linkedHeapListElement ) # newE . Value = i # newE . next = & h . root # last := h . Last ().(* linkedHeapListElement ) # lastParent := last . parent # last . next = newE # newE . prev = last # h . root . prev = newE # if lastParent . right == nil { # lastParent . right = newE # newE . parent = lastParent # } else { # lastParent . next . left = newE # newE . parent = lastParent . next # } # h . len ++
if N <= 1 { # return N # } # return fib ( N - 1 ) + fib ( N - 2 )
dp := [ 3 1 ][ 1 0 0 1 ] int {} # dp [ 0 ][ 0 ] = 1 # # for d := 1 ; d <= dices ; d ++ { # maxT := min ( target , d * faces ) # for t := d ; t <= maxT ; t ++ { # maxF := min ( faces , t ) # for f := 1 ; f <= maxF ; f ++ { # dp [ d ][ t ] += dp [ d - 1 ][ t - f ] # } # dp [ d ][ t ] %= mod # } # } # # return dp [ dices ][ target ]
if tx < ty { # sx , sy = sy , sx # tx , ty = ty , tx # } # # var helper func ( int , int ) bool # helper = func ( x , y int ) bool { # if sx == x && sy == y { # return true # } # # if sx > x || sy > y || # x == y { # return false # } # # if sy == y { # return sx % sy == x % y # } # # return helper ( y , x % y ) # } # # return helper ( tx , ty )
fmt . Printf (" STR ", s . english ) # fmt . Printf (" STR ", s . maths ) # fmt . Printf (" STR ", s . science ) # fmt . Printf (" STR ", s . social )
if nil == head || nil == head . Next { # return head # } # # p := head # q := reverseList ( head . Next ) # p . Next = nil # r := q # for nil != r . Next { # r = r . Next # } # r . Next = p # return q
var i , j int # B := make ([][] int , ( n + 1 )) # for i := range B { # B [ i ] = make ([] int , k + 1 ) # } # # for i = 0 ; i <= n ; i ++ { # for j = 0 ; j <= Min ( i , k ); j ++ { # if j == 0 || j == i { # B [ i ][ j ] = 1 # } else { # B [ i ][ j ] = B [ i - 1 ][ j - 1 ] + B [ i - 1 ][ j ] # } # } # } # return B [ n ][ k ]
if x < 2 { # return x # } # return fib ( x - 1 ) + fib ( x - 2 )
m := len ( matrix ) # if m == 0 { # return nil # } # n := len ( matrix [ 0 ]) # # i , j , d := 0 , 0 , 0 # res := make ([] int , m * n ) # dirs := [ 2 ][ 2 ] int {{- 1 , 1 }, { 1 , - 1 }} # for k := 0 ; k < m * n ; k ++ { # res [ k ] = matrix [ i ][ j ] # # i += dirs [ d ][ 0 ] # j += dirs [ d ][ 1 ] # if i >= m { # i = m - 1 # j += 2 # d = 1 - d # } # if j >= n { # j = n - 1 # i += 2 # d = 1 - d # } # if i < 0 { # i = 0 # d = 1 - d # } # if j < 0 { # j = 0 # d = 1 - d # } # } # return res
fmt . Println ( countBits ( 5 ))
if head == nil || head . Next == nil { # return head # } # fast , slow := head , head # for fast . Next != nil && fast . Next . Next != nil { # fast = fast . Next . Next # slow = slow . Next # } # fast = slow . Next # slow . Next = nil # # l 1 := sortList ( head ) # l 2 := sortList ( fast ) # # h := & ListNode {} # rear := h # # for l 1 != nil && l 2 != nil { # if l 1 . Val < l 2 . Val { # rear . Next = l 1 # l 1 = l 1 . Next # } else { # rear . Next = l 2 # l 2 = l 2 . Next # } # rear = rear . Next # rear . Next = nil # } # if l 1 != nil { # rear . Next = l 1 # } else if l 2 != nil { # rear . Next = l 2 # } # return h . Next
response := make ( chan result ) # memo . requests <- request { key , response } # res := <- response # return res . value , res . err
return strings . Replace ( start , " STR ", " STR ", - 1 ) == strings . Replace ( end , " STR ", " STR ", - 1 ) && # isOK ( idxs ( start , ' L '), idxs ( end , ' L '), isMoreOrEqual ) && # isOK ( idxs ( start , ' R '), idxs ( end , ' R '), isLessOrEqual )
mod := 1 0 0 0 0 0 0 0 0 7 # n := len ( S ) # dp 0 , dp 1 := make ([] int , n + 1 ), make ([] int , n + 1 ) # for i := 0 ; i < n + 1 ; i ++ { # dp 0 [ i ] = 1 # } # for i := 0 ; i < n ; i ++ { # cur := 0 # if S [ i ] == ' I ' { # j := 0 # for ; j < n - i ; j ++ { # cur = ( cur + dp 0 [ j ]) % mod # dp 1 [ j ] = cur # } # } else { # j := n - i - 1 # for ; j >= 0 ; j -- { # cur = ( cur + dp 0 [ j + 1 ]) % mod # dp 1 [ j ] = cur # } # } # dp 0 , dp 1 = dp 1 , dp 0 # } # return dp 0 [ 0 ]
child . p = e # e . c . PushRight ( child )
xx := ^ 0 # for xx & num > 0 { # xx <<= 1 # } # return ^ xx ^ num
p := parser {} # if ! yaml_parser_initialize (& p . parser ) { # panic (" STR ") # } # if len ( b ) == 0 { # b = [] byte {'\ n '} # } # yaml_parser_set_input_string (& p . parser , b ) # return & p
maxNum , sum := 0 , 0 # for _ , num := range weights { # sum += num # if num > maxNum { # maxNum = num # } # } # if D == 1 { # return sum # } # low , high := maxNum , sum # for low < high { # mid := low + ( high - low )>> 1 # if calSum ( mid , D , weights ) { # high = mid # } else { # low = mid + 1 # } # } # return low
return & Fraction { n , d }
k %= len ( nums ) # reverse ( nums ) # reverse ( nums [: k ]) # reverse ( nums [ k :])
if root == nil { # return true # } # if root . Left != nil && root . Val != root . Left . Val { # return false # } # if root . Right != nil && root . Val != root . Right . Val { # return false # } # return isUnivalTree ( root . Left ) && isUnivalTree ( root . Right )
testCases := [] string { # " STR ", # " STR ", # " STR ", # " STR ", # } # # expected := [] bool { true , false , false , true } # # for index , data := range testCases { # if res := isPalindrome ( data ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
tok := & token { kind : " STR ", str : str , size : len ( str )} # if len ( p . stack ) == 0 { # p . print ( tok ) # } else { # p . tokens = append ( p . tokens , tok ) # p . rtotal += len ( str ) # }
counter := map [ int ] int {} # others := [] int {} # dest := make ([] int , 0 , len ( arr 2 )) # for _ , v := range arr 2 { # counter [ v ] = 0 # } # for _ , v := range arr 1 { # if _ , ok := counter [ v ]; ok { # counter [ v ]++ # } else { # others = append ( others , v ) # } # } # # for _ , v := range arr 2 { # for i := 0 ; i < counter [ v ]; i ++ { # dest = append ( dest , v ) # } # } # sort . Ints ( others ) # dest = append ( dest , others ...) # return dest
var largest int # for start , ends := range g { # if start > largest { # largest = start # } # # for _ , node := range ends { # if node > largest { # largest = node # } # } # } # # result := make ([][] int , largest + 1 ) # for i := range result { # result [ i ] = make ([] int , largest + 1 ) # } # # visited := make ( map [ int ] struct {}, largest + 1 ) # result = transitiveClosure (- 1 , g , result , visited ) # # return result
select { # case sema <- struct {}{}: # case <- done : # return nil # } # defer func () { <- sema }() # # # f , err := os . Open ( dir ) # if err != nil { # fmt . Fprintf ( os . Stderr , " STR ", err ) # return nil # } # defer f . Close () # # entries , err := f . Readdir ( 0 ) # if err != nil { # fmt . Fprintf ( os . Stderr , " STR ", err ) # } # return entries
res := 0 # short , count := parse ( S ) # for i := range words { # res += check ( words [ i ], short , count ) # } # return res
n := len ( boxes ) # # dp := make ([][][] int , n ) # for i := 0 ; i < n ; i ++ { # dp [ i ] = make ([][] int , n ) # for j := 0 ; j < n ; j ++ { # dp [ i ][ j ] = make ([] int , n ) # } # } # # return remove ( boxes , dp , 0 , n - 1 , 0 )
reach := 0 # for i , num := range nums { # if reach >= len ( nums )- 1 { # return true # } # if 0 == num && reach <= i { # return false # } # if i + num > reach { # reach = i + num # } # } # return false
i := - 1 # lo , hi := 0 , len ( nums )- 1 # for lo <= hi { # mid := lo + ( hi - lo )/ 2 # if nums [ mid ] < target { # if target >= nums [ 0 ] && nums [ 0 ] > nums [ mid ] { # hi = mid - 1 # } else { # lo = mid + 1 # } # } else if nums [ mid ] > target { # if target < nums [ 0 ] && nums [ 0 ] <= nums [ mid ] { # lo = mid + 1 # } else { # hi = mid - 1 # } # } else { # i = mid # break # } # } # return i
bytes , err := dataCustomersJsonBytes () # if err != nil { # return nil , err # } # # info := bindataFileInfo { name : " STR ", size : 6 8 , mode : os . FileMode ( 4 2 0 ), modTime : time . Unix ( 1 4 4 5 7 2 4 0 3 0 , 0 )} # a := & asset { bytes : bytes , info : info } # return a , nil
switch { # case b . Start < 0 && b . End == - 1 : # return strconv . FormatInt ( b . Start , 1 0 ), nil # case b . Start >= 0 && b . End == - 1 : # return strconv . FormatInt ( b . Start , 1 0 ) + " STR ", nil # case b . Start >= 0 && b . End >= 0 : # if b . End < b . Start { # break # } # s , e := strconv . FormatInt ( b . Start , 1 0 ), strconv . FormatInt ( b . End , 1 0 ) # return s + " STR " + e , nil # default : # } # return " STR " invalid request range ")
nums := make ([] int , n ) # for i := 0 ; i < len ( nums ); i ++ { # nums [ i ] = i # } # # return helper 5 2 ( nums , 0 , 0 )
if n == 0 { # return " STR " # } # bytes := [] byte {} # var remainder int # for n > 0 { # remainder = ( n - 1 ) % 2 6 # bytes = append ( bytes , ' A '+ byte ( remainder )) # n = ( n - 1 ) / 2 6 # } # for i , j := 0 , len ( bytes )- 1 ; i < j ; i , j = i + 1 , j - 1 { # bytes [ i ], bytes [ j ] = bytes [ j ], bytes [ i ] # } # return string ( bytes )
cases := [] struct { # name string # inputs int # expect bool # }{ # {" STR ", 1 9 , true }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := isHappy ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if matrix == nil || len ( matrix ) == 0 || len ( matrix [ 0 ]) == 0 { # return nil # } # row , col , dir , i , x , y , d := len ( matrix ), len ( matrix [ 0 ]), [ 2 ][ 2 ] int { # {- 1 , 1 }, # { 1 , - 1 }, # }, 0 , 0 , 0 , 0 # total := row * col # res := make ([] int , total ) # for i < total { # for x >= 0 && x < row && y >= 0 && y < col { # res [ i ] = matrix [ x ][ y ] # i ++ # x += dir [ d ][ 0 ] # y += dir [ d ][ 1 ] # } # d = ( d + 1 ) % 2 # if x == row { # x -- # y += 2 # } # if y == col { # y -- # x += 2 # } # if x < 0 { # x = 0 # } # if y < 0 { # y = 0 # } # } # return res
if len ( ans ) == k { # tmp := make ([] int , k ) # copy ( tmp , ans ) # ret = append ( ret , tmp ) # return # } # i := 1 # if len ( ans ) > 0 { # i = ans [ len ( ans )- 1 ] + 1 # } # for ; i <= n ; i ++ { # if used [ i ] == true { # continue # } # used [ i ] = true # ans = append ( ans , i ) # help ( ans , n , k , used ) # ans = ans [: len ( ans )- 1 ] # used [ i ] = false # }
var secret string # var guess string # secret = " STR " # guess = " STR " # getHint ( secret , guess ) # # secret = " STR " # guess = " STR " # getHint ( secret , guess )
qs := [] question 4 0 { # # { # para 4 0 {[] int { 1 0 , 1 , 2 , 7 , 6 , 1 , 5 }, 8 }, # ans 4 0 {[][] int {{ 1 , 7 }, { 1 , 2 , 5 }, { 2 , 6 }, { 1 , 1 , 6 }}}, # }, # # { # para 4 0 {[] int { 2 , 5 , 2 , 1 , 2 }, 5 }, # ans 4 0 {[][] int {{ 1 , 2 , 2 }, { 5 }}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 0 , q . para 4 0 # fmt . Printf (" STR ", p , combinationSum 2 ( p . n , p . k )) # } # fmt . Printf (" STR ")
m := make ( map [ rune ] bool ) # for _ , v := range J { # m [ v ] = true # } # cnt := 0 # for _ , v := range S { # if m [ v ] == true { # cnt ++ # } # } # return cnt
if root == nil { # return [] string {} # } # s := & solution { path : []* TreeNode { root }} # s . helper () # return s . ret
l , r := 0 , 5 *( K + 1 ) # for l <= r { # m := ( l + r ) / 2 # zeros := 0 # x := m # for x > 0 { # x /= 5 # zeros += x # } # if zeros == K { # return 5 # } else if zeros < K { # l = m + 1 # } else { # r = m - 1 # } # } # return 0
t . Parallel () # # for _ , tc := range testcases { # if res := StableMarriage ( tc . males , tc . females ); ! reflect . DeepEqual ( res , tc . matches ) { # t . Errorf (" STR ", tc . matches , res ) # } # }
queue := []* TreeNode { root } # # for len ( queue ) != 0 { # root = queue [ 0 ] # queue = queue [ 1 :] # # if root . Right != nil { # queue = append ( queue , root . Right ) # } # if root . Left != nil { # queue = append ( queue , root . Left ) # } # } # return root . Val
defer wg . Done () # for val := range count { # fmt . Printf (" STR ", val , label ) # if val == 1 0 { # fmt . Printf (" STR ", label ) # close ( count ) # return # } # val ++ # count <- val # }
if len (* r ) < depth { # * r = append (* r , root . Val ) # } # if nil != root . Right { # postOrderTraversal ( root . Right , depth + 1 , r ) # } # if nil != root . Left { # postOrderTraversal ( root . Left , depth + 1 , r ) # }
if len ( nums ) == 0 { # return 0 # } # if len ( nums ) == 1 { # return nums [ 0 ] # } # if len ( nums ) == 2 { # return max ( nums [ 0 ], nums [ 1 ]) # } # x := helper ( nums , 0 , len ( nums )- 2 ) # y := helper ( nums , 1 , len ( nums )- 1 ) # return max ( x , y )
if root == nil { # return nil # } # # var node = & Node { Val : root . Val } # for _ , c := range root . Children { # node . Children = append ( node . Children , cloneTree ( c )) # } # return node
StoreUint 1 6 (& r . Reg , LoadUint 1 6 (& r . Reg )&^ value )
return h . data [ n ]
if tree == nil { # return nil # } # left := invertTree ( tree . left ) # right := invertTree ( tree . right ) # tree . left = right # tree . right = left # return tree
result := 0 # for i := 0 ; i < len ( nums ); i ++ { # result ^= nums [ i ] # } # return result
temp := highHeap ( nums ) # h := & temp # heap . Init ( h ) # # if k == 1 { # return (* h )[ 0 ] # } # # for i := 1 ; i < k ; i ++ { # heap . Remove ( h , 0 ) # } # # return (* h )[ 0 ]
str := strconv . Itoa ( n ) # length := len ( str ) # # for i := 0 ; i < length / 2 ; i ++ { # if str [ i ] != str [ length - 1 - i ] { # return false # } # } # # return true
benchmark ( bb , 2 0 4 8 , 1 )
total := 0 # for _ , num := range nums { # total += num # } # # sum := 0 # for i , num := range nums { # sum += num # if sum == total - sum + num { # return i # } # } # # return - 1
n := len ( prices ) # if n == 0 { # return 0 # } # res := 0 # hold := 0 - prices [ 0 ] - fee # for i := 1 ; i < n ; i ++ { # tmp := res # res = max ( res , hold + prices [ i ]) # hold = max ( hold , tmp - prices [ i ]- fee ) # } # return res
hasRoot := make ( map [ string ] bool , len ( dict )) # hasLen := make ([] bool , 1 0 1 ) # for i := range dict { # hasRoot [ dict [ i ]] = true # hasLen [ len ( dict [ i ])] = true # } # # ls := make ([] int , 0 , 1 0 1 ) # for i , ok := range hasLen { # if ok { # ls = append ( ls , i ) # } # } # sort . Ints ( ls ) # # words := strings . Split ( sentence , " STR ") # for i , w := range words { # for _ , l := range ls { # if l < len ( w ) && hasRoot [ w [: l ]] { # words [ i ] = w [: l ] # break # } # } # } # # return strings . Join ( words , " STR ")
cases := [] struct { # name string # inputs [][] int # expect [][] int # }{ # {" STR ", [][] int {{ 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 }}, [][] int {{ 1 , 4 , 7 }, { 2 , 5 , 8 }, { 3 , 6 , 9 }}}, # {" STR ", [][] int {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}, [][] int {{ 1 , 4 }, { 2 , 5 }, { 3 , 6 }}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if BinPow ( 2 , 1 0 , 1 2 1 3 2 3 ) != 1 0 2 4 { # t . Error (" STR ") # } # # if BinPow ( 1 , 1 0 , 1 2 1 3 2 3 ) != 1 { # t . Error (" STR ") # } # # if BinPow ( 0 , 1 2 3 1 2 3 , 2 ) != 0 { # t . Error (" STR ") # }
var sb strings . Builder # i , count , size := 0 , 0 , len ( S ) # for j := 0 ; j < size ; j ++ { # if S [ j ] == '(' { # count ++ # continue # } # count -- # if count == 0 { # sb . WriteString ( S [ i + 1 : j ]) # i = j + 1 # } # } # return sb . String ()
wg . Add ( 2 ) # # go doWork (" STR ") # go doWork (" STR ") # # time . Sleep ( 1 * time . Second ) # # fmt . Println (" STR ") # atomic . StoreInt 6 4 (& shutdown , 1 ) # # wg . Wait ()
cases := [] struct { # name string # inputs string # expect int # }{ # {" STR ", " STR ", 3 }, # {" STR ", " STR ", 1 }, # {" STR ", " STR ", 3 }, # } # b . ResetTimer () # for i := 0 ; i < b . N ; i ++ { # lengthOfLongestSubstring ( cases [ 0 ]. inputs ) # lengthOfLongestSubstring ( cases [ 1 ]. inputs ) # lengthOfLongestSubstring ( cases [ 2 ]. inputs ) # }
tbl := [] brfmt { # {" STR ", [] Bytes {{ 0 , 1 , 1 , true }}, " STR "}, # {" STR ", [] Bytes {{ 0 , 1 , - 1 , true }}, " STR "}, # {" STR ", [] Bytes {{- 1 , - 1 , 1 , false }}, " STR "}, # } # for _ , f := range tbl { # f := f # t . Run ( f . Name , func ( t * testing . T ) { # t . Parallel () # got , err := FormatResponse ( f . In [ 0 ]) # if err != nil { # t . Error ( err ) # } # if want , got := f . Out , got ; want != got { # t . Errorf (" STR ", want , got ) # } # }) # }
a , b := big . NewInt ( 1 ), big . NewInt ( 1 ) # n := 3 # # for { # a , b = new ( big . Int ). Add ( a , b ), a # # if len ( a . String ()) >= 1 0 0 0 { # fmt . Println ( n , a ) # break # } # # n ++ # }
var sign int 3 2 = 1 # tmp := x # if x < 0 { # sign = - 1 # tmp = - 1 * x # } # list := [] int 3 2 {} # for tmp > 9 { # list = append ( list , int 3 2 ( tmp % 1 0 )) # tmp = tmp / 1 0 # } # list = append ( list , int 3 2 ( tmp )) # var ret int 3 2 # for i := 0 ; i < len ( list ); i ++ { # if sign == 1 { # if ret > ( MAX - list [ i ])/ 1 0 { # return 0 # } # } else { # if - ret < ( MIN + list [ i ])/ 1 0 { # return 0 # } # } # ret = 1 0 * ret + list [ i ] # } # return int ( ret * sign )
cases := [] struct { # name string # input 1 * ListNode # input 2 * ListNode # expect * ListNode # }{ # {" STR ", MakeListNode ([] int { 7 , 2 , 4 , 3 }), MakeListNode ([] int { 5 , 6 , 4 }), MakeListNode ([] int { 7 , 8 , 0 , 7 })}, # {" STR ", MakeListNode ([] int {}), MakeListNode ([] int { 1 , 2 , 3 }), MakeListNode ([] int { 1 , 2 , 3 })}, # {" STR ", MakeListNode ([] int { 0 , 0 , 8 }), MakeListNode ([] int { 9 , 9 , 2 }), MakeListNode ([] int { 1 , 0 , 0 , 0 })}, # {" STR ", MakeListNode ([] int {}), MakeListNode ([] int {}), MakeListNode ([] int {})}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i + 1 ), func ( t * testing . T ) { # got := Solution ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 , c . input 2 ) # } # }) # }
fmt . Printf (" STR ", x + 0 / x ) # defer fmt . Printf (" STR ", x ) # f ( x - 1 )
t . Parallel () # var d Dice # if cost := FirstGame (& d ); cost > 5 0 0 { # t . Errorf (" STR ", cost ) # }
if num > 8 { # return [] string {} # } # res := [] string {} # for i := 0 ; i <= num ; i ++ { # for j := 0 ; j < len ( hourMap [ i ]); j ++ { # for k := 0 ; k < len ( minuteMap [ num - i ]); k ++ { # res = append ( res , hourMap [ i ][ j ]+" STR "+ minuteMap [ num - i ][ k ]) # } # } # } # return res
i := len ( A ) - 1 # res := [] int {} # # for i >= 0 || K > 0 { # if i >= 0 { # K += A [ i ] # } # res = append ( res , K % 1 0 ) # K /= 1 0 # i -- # } # for l , r := 0 , len ( res )- 1 ; l < r ; l , r = l + 1 , r - 1 { # res [ l ], res [ r ] = res [ r ], res [ l ] # } # return res
t , _ , _ := triPenHex ( 2 8 5 , 1 6 5 , 1 4 3 ) # fmt . Println ( Triangle ( t ))
result := make ([][] int , 0 , 1 << uint 6 4 ( len ( set ))) # for i := uint 6 4 ( 0 ); i < ( 1 << uint 6 4 ( len ( set ))); i ++ { # entry := make ([] int , 0 , bits . OnesCount 6 4 ( i )) # for pos := 0 ; pos < len ( set ); pos ++ { # if i &( 1 << uint 6 4 ( pos )) != 0 { # entry = append ( entry , set [ pos ]) # } # } # result = append ( result , entry ) # } # return result
var res [] int # var stack = []* TreeNode { root } # for 0 < len ( stack ) { # top := len ( stack ) - 1 # root = stack [ top ] # stack = stack [: top ] # if root != nil { # res = append ( res , root . Val ) # stack = append ( stack , root . Right , root . Left ) # } # } # # return res
arr := randomSlice ( 0 , 2 0 , 1 0 ) # resultArr := make ([] int , 0 , 0 ) # gbt := newGBT () # for _ , v := range arr { # gbt . Insert ( uint 3 2 ( v )) # } # sort . Ints ( arr ) # gbt . InOrderWalk ( gbt . Root (), func ( GBT binaryTreeIf , node interface {}) bool { # n := node .(* gbtElement ) # resultArr = append ( resultArr , int ( n . Key )) # return false # }) # if ! reflect . DeepEqual ( resultArr , arr ) { # t . Log ( fmt . Sprintf (" STR ", arr ) + fmt . Sprintf (" STR ", resultArr )) # t . Fail () # }
var c Calculator # fmt . Println ( c . Do ( Add ( 5 ))) # fmt . Println ( c . Do ( Mul ( 2 ))) # fmt . Println ( c . Do ( Sub ( 4 ))) # fmt . Println ( c . Do ( math . Sqrt )) # fmt . Println ( c . Do ( math . Cos ))
start , end , min , max := 0 , - 1 , math . MaxInt 3 2 , math . MinInt 3 2 # for i , j := 0 , len ( nums )- 1 ; i < len ( nums ); i , j = i + 1 , j - 1 { # if nums [ i ] >= max { # max = nums [ i ] # } else { # end = i # } # if nums [ j ] <= min { # min = nums [ j ] # } else { # start = j # } # } # return end - start + 1
n := NewNode ( val ) # n . Next = ll . Head # # if ll . Head != nil { # ll . Head . Prev = n # } # # ll . Head = n #
this . mutex . Lock () # defer this . mutex . Unlock () # e := this . list . Front () # if e == nil { # return nil # } # return e . Value
_i := i .(* ltHeapArray ) # h . root = h . merge ( h . root , _i . root ).(* ltHeapElement ) # h . len += _i . len # return h
qs := [] question 3 7 7 { # # { # para 3 7 7 {[] int { 1 , 2 , 3 }, 4 }, # ans 3 7 7 { 7 }, # }, # # { # para 3 7 7 {[] int { 1 , 2 , 3 }, 3 2 }, # ans 3 7 7 { 7 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 7 7 , q . para 3 7 7 # fmt . Printf (" STR ", p , combinationSum 4 ( p . n , p . k )) # } # fmt . Printf (" STR ")
size := len ( rects ) # # total := 0 # counts := make ([] int , size ) # tmp := make ([][] int , size ) # # for i , r := range rects { # x 1 , y 1 , x 2 , y 2 := r [ 0 ], r [ 1 ], r [ 2 ], r [ 3 ] # w , h := x 2 - x 1 + 1 , y 2 - y 1 + 1 # total += w * h # counts [ i ] = total # tmp [ i ] = [] int { x 1 , y 1 , w , h } # } # # return Solution { # counts : counts , # rects : tmp , # total : total , # }
prev , now := make ([] bool , len ( p )+ 1 ), make ([] bool , len ( p )+ 1 ) # for i := 0 ; i <= len ( s ); i ++ { # now , prev = prev , now # now [ 0 ] = i == 0 # for j := 1 ; j <= len ( p ); j ++ { # if p [ j - 1 ] == '*' { # now [ j ] = prev [ j ] || prev [ j - 1 ] || now [ j - 1 ] # } else { # now [ j ] = prev [ j - 1 ] && ( s [ i - 1 ] == p [ j - 1 ] || p [ j - 1 ] == '?') # } # } # } # return now [ len ( p )]
return New ( s ). Name ()
n := len ( A ) # for _ , r := range A { # i , j := 0 , n - 1 # for i < j { # r [ i ], r [ j ] = r [ j ]^ 1 , r [ i ]^ 1 # i ++ # j -- # } # if i == j { # r [ i ] ^= 1 # } # } # return A
res := 0 # count := [ 1 0 0 ] int {} # for _ , domino := range dominoes { # d := mapping ( domino ) # res += count [ d ] # count [ d ]++ # } # return res
b := createFilledBucket ( time . Now (). Add ( time . Duration ( 4 ))) # # cpu := runtime . GOMAXPROCS ( 0 ) # ch := make ( chan bool ) # worker := func () { # for i := 0 ; i < bb . N / cpu ; i ++ { # b . Get ( randomString ( 2 )) # } # ch <- true # } # for i := 0 ; i < cpu ; i ++ { # go worker () # } # for i := 0 ; i < cpu ; i ++ { # _ = <- ch # }
for i := 0 ; i < len ( a ) && i < len ( b ); i ++ { # switch { # case a [ i ] > b [ i ]: # return 1 # case a [ i ] < b [ i ]: # return - 1 # } # } # switch { # case len ( a ) > len ( b ): # return 1 # case len ( a ) < len ( b ): # return - 1 # } # return 0
t . Parallel () # for _ , tc := range testcases { # result := append ( make ([] rune , 0 , len ( tc . input )), tc . input ...) # SegregateValues ( result ) # if ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
term := a + b # if term > until { # return 0 # } # terms = append ( terms , term ) # if term > 3 { # b = a # } # return findTerms ( term , b , until )
t . Parallel () # for _ , tc := range testcases { # if result := LongestIncreasingSubsequence ( tc . seq ); ! reflect . DeepEqual ( result , tc . lis ) { # t . Errorf (" STR ", tc . lis , result ) # } # }
var count int # # for i , b 1 := range bishops { # for _ , b 2 := range bishops [ i + 1 :] { # if r , c := b 2 . Row - b 1 . Row , b 2 . Col - b 1 . Col ; r == c || r == - c { # count ++ # } # } # } # # return count
const max = 4 0 0 0 0 0 0 # tempI , i , j := 0 , 1 , 2 # # sum := 2 # for j <= max { # if ( i + j )% 2 == 0 { # sum += i + j # } # tempI = i # i = j # j += tempI # } # # fmt . Println ( sum )
comps := strings . Split ( path , " STR ") # # res := [] string {} # for _ , s := range comps { # switch s { # case " STR ", " STR ": # case " STR ": # if len ( res ) > 0 { # res = res [: len ( res )- 1 ] # } # default : # res = append ( res , s ) # } # } # return " STR " + strings . Join ( res , " STR ")
if len ( nums ) == 0 { # return - 1 # } else if len ( nums ) == 1 { # return 0 # } # low , high := 0 , len ( nums )- 1 # for low < high { # mid := ( low + high ) / 2 # switch { # case ( mid == 0 || nums [ mid - 1 ] <= nums [ mid ]) && # ( mid == len ( nums )- 1 || nums [ mid + 1 ] <= nums [ mid ]): # return mid # case mid > 0 && nums [ mid - 1 ] > nums [ mid ]: # high = mid - 1 # default : # low = mid + 1 # } # } # return low
el , q . queue = q . queue [ 0 ], q . queue [ 1 :] # q . len -- # return
log . Println (" STR ") # # defer func () { # if err := recover (); err != nil { # fcName = " STR " # para = " STR " # ansType = " STR " # nfc = " STR " # } # }() # # funcIndex := strings . Index ( fc , " STR ") # a := funcIndex + strings . Index ( fc [ funcIndex :], " STR ") # b := funcIndex + strings . Index ( fc [ funcIndex :], " STR ") # c := funcIndex + strings . Index ( fc [ funcIndex :], " STR ") # d := funcIndex + strings . Index ( fc [ funcIndex :], " STR ") # # fcName = fc [ a + 1 : b ] # para = fc [ b + 1 : c ] # ansType = strings . TrimSpace ( fc [ c + 1 : d ]) # nfc = fmt . Sprintf (" STR ", fcName , para , ansType ) # # return
if ubt . left == nil { # ubt . left = & ubtTree {} # } # return ubt . left
t . Parallel () # for _ , tc := range testcases { # if result := Calculate ( tc . tree ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
return numRoutesThruMaze ( maze , 0 , 0 )
root := & trieNode {} # for _ , word := range words { # node := root # for _ , ch := range word { # index := int ( ch - ' a ') # if node . children [ index ] == nil { # node . children [ index ] = & trieNode {} # } # # node = node . children [ index ] # } # # node . isWord = true # } # # visited := make ([][] bool , len ( board )) # for i := 0 ; i < len ( board ); i ++ { # visited [ i ] = make ([] bool , len ( board [ 0 ])) # } # # set := make ( map [ string ] bool ) # for i := 0 ; i < len ( board ); i ++ { # for j := 0 ; j < len ( board [ 0 ]); j ++ { # helper 2 1 2 ( board , i , j , visited , root , " STR ", set ) # } # } # # result := make ([] string , 0 ) # for s := range set { # result = append ( result , s ) # } # # return result
gate := 1 + 1 <<( top - 1 ) # if ( a | b )& gate != gate { # return false # } # # for a != 0 || b != 0 { # if ( a | b )& 1 == 0 { # return false # } # # # for a & b & 1 == 1 { # a >>= 1 # b >>= 1 # } # # if ( a ^ b )& 1 == 1 { # a >>= 1 # b >>= 1 # for ( a | b )& 1 == 0 && ( a > 0 || b > 0 ) { # a >>= 1 # b >>= 1 # } # if ( a ^ b )& 1 == 1 { # a >>= 1 # b >>= 1 # } else { # return false # } # # } # # } # # return true
for i := 0 ; i < len ( s ); i ++ { # if s [ i ] == c { # return i # } # } # return - 1
if n <= 0 { # return false # } # # return 0 == ( n & ( n - 1 ))
inserter := CBTInserter { # queue : make ([]* TreeNode , 0 ), # } # # q := make ([]* TreeNode , 0 ) # if root != nil { # q = append ( q , root ) # inserter . Insert ( root . Val ) # } # # for len ( q ) > 0 { # node := q [ 0 ] # q = q [ 1 :] # # if node . Left != nil { # q = append ( q , node . Left ) # inserter . Insert ( node . Left . Val ) # } # # if node . Right != nil { # q = append ( q , node . Right ) # inserter . Insert ( node . Right . Val ) # } # } # # return inserter
return & scanner . Error { # Pos : t . fset . Position ( t . curPos ), # Msg : fmt . Sprintf (" STR ", t . curToken , expected ), # }
if target < nums [ 0 ] { # return 0 # } # l := len ( nums ) # if target > nums [ l - 1 ] { # return l # } # left , right := 0 , l - 1 # for left <= right { # m := ( left + right ) / 2 # if nums [ m ] > target { # right = m - 1 # if right >= 0 { # if nums [ right ] < target { # return right + 1 # } # } else { # return 0 # } # } else if nums [ m ] < target { # left = m + 1 # if left < l { # if nums [ left ] > target { # return left # } # } else { # return l # } # } else { # return m # } # } # return 0
if len ( s ) != len ( t ) { # return false # } # ss , tt := make ( map [ byte ] int ), make ( map [ byte ] int ) # for i , j := 0 , 0 ; i < len ( s ); i , j = i + 1 , j + 1 { # b 1 , b 2 := s [ i ], t [ j ] # if ss [ b 1 ] != tt [ b 2 ] { # return false # } # ss [ b 1 ], tt [ b 2 ] = i + 1 , j + 1 # } # return true
ch <- n # ch <- n + 1 # wg . Done ()
node 1 6 := binaryTreeNode { value : 1 6 , left : nil , right : nil } # node 1 2 := binaryTreeNode { value : 1 2 , left : nil , right : nil } # node 8 := binaryTreeNode { value : 8 , left : nil , right : nil } # node 4 := binaryTreeNode { value : 4 , left : nil , right : nil } # node 1 4 := binaryTreeNode { value : 1 4 , left : & node 1 2 , right : & node 1 6 } # node 6 := binaryTreeNode { value : 6 , left : & node 4 , right : & node 8 } # node 1 0 := binaryTreeNode { value : 1 0 , left : & node 6 , right : & node 1 4 } # # ptr := conver (& node 1 0 ) # fmt . Println ( ptr . value ) #
m := make ( map [ int 3 2 ] int , 2 5 6 ) # # var i int 3 2 # for i = 0 ; i < 2 5 6 ; i ++ { # m [ i ] = 0 # } # # for _ , v := range s { # m [ v ]++ # } # for _ , v := range t { # m [ v ]-- # if m [ v ] < 0 { # return byte ( v ) # } # } # return 0
p := search () # max := p [ 0 ] # for _ , e := range p { # if e > max { # max = e # } # } # fmt . Println ( max )
t . Parallel () # for _ , tc := range testcases { # if result := IsIntegerPalindrome ( tc . num ); result != tc . expected { # t . Errorf (" STR ", tc . num , tc . expected , result ) # } # }
tests := [...] testType { # { # in : [] int { 4 , 2 , 3 }, # k : 1 , # want : 5 , # }, # { # in : [] int { 3 , - 1 , 0 , 2 }, # k : 3 , # want : 6 , # }, # { # in : [] int { 2 , - 3 , - 1 , 5 , - 4 }, # k : 2 , # want : 1 3 , # }, # } # for _ , tt := range tests { # got := largestSumAfterKNegations ( tt . in , tt . k ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
var result string # result += fmt . Sprintf (" STR ", img . Bounds ()) # result += fmt . Sprintf (" STR ", img . Stride ) # for y := 0 ; y < img . Bounds (). Dy (); y ++ { # result += " STR " # for x := 0 ; x < img . Bounds (). Dx (); x ++ { # pos := y * img . Stride + x * 4 # result += fmt . Sprintf (" STR ", img . Pix [ pos + 0 ]) # result += fmt . Sprintf (" STR ", img . Pix [ pos + 1 ]) # result += fmt . Sprintf (" STR ", img . Pix [ pos + 2 ]) # result += fmt . Sprintf (" STR ", img . Pix [ pos + 3 ]) # } # } # result += " STR " # return result
if e . lgu > 1 { # e . cluster [ key ] = new ( rsVEBTreeElement ). init ( e . clusterLgu , e . mixin ) # return e . cluster [ key ] # } # return nil
connected , ok := g . edges [ from ] # # if ! ok { # return false # } # # weight := connected [ to ] # return weight > 0
count := 0 # for _ , i := range nums { # if i != 0 { # nums [ count ] = i # count ++ # } # } # for i := count ; i < len ( nums ); i ++ { # temp := i # nums [ temp ] = 0 # } # return nums
for i := 1 ; i < 1 0 0 0 0 ; i ++ { # p := ( i * (( 3 * i ) - 1 )) / 2 # pentas = append ( pentas , p ) # pentamap [ p ] = true # } #
t . Parallel () # for _ , tc := range testcases { # if count := CountCompleteBinaryTree ( tc . tree ); count != tc . count { # t . Errorf (" STR ", tc . count , count ) # } # }
fmt . Println ( findComplement ( 5 ))
moves := 0 # dp := [ 1 0 1 ] int {} # for dp [ K ] < N { # for i := K ; i > 0 ; i -- { # dp [ i ] += dp [ i - 1 ] + 1 # } # moves ++ # } # return moves
occ := make ( map [ rune ] int , len ( letters )) # for _ , r := range letters { # occ [ r ]++ # } # result := str # var start int # for end , r := range str { # if _ , found := occ [ r ]; found { # occ [ r ]-- # if allFound ( occ ) { # for { # if count , found := occ [ rune ( str [ start ])]; found && count + 1 > 0 { # break # } else if found { # occ [ rune ( str [ start ])]++ # } # start ++ # } # result = candidate ( str [ start : end + 1 ], result ) # } # } # } # return answer ( result , ! allFound ( occ ))
path := [ 1 0 0 ][ 1 0 0 ] int {} # # for i := 0 ; i < m ; i ++ { # path [ i ][ 0 ] = 1 # } # # for j := 0 ; j < n ; j ++ { # path [ 0 ][ j ] = 1 # } # # for i := 1 ; i < m ; i ++ { # for j := 1 ; j < n ; j ++ { # path [ i ][ j ] = path [ i - 1 ][ j ] + path [ i ][ j - 1 ] # } # } # # return path [ m - 1 ][ n - 1 ]
switch op { # case " STR ": # c . acc = c . acc + input # case " STR ": # c . acc = c . acc - input # case " STR ": # c . acc = c . acc * input # } # return c . acc
var ( # start = 0 # res = 0 # lastOccurredRecord = make ( map [ rune ] int ) # ) # # for i , ch := range [] rune ( s ) { # if lastIndex , ok := lastOccurredRecord [ ch ]; ok && lastIndex >= start { # start = lastIndex + 1 # } # if i - start + 1 > res { # res = i - start + 1 # } # lastOccurredRecord [ ch ] = i # } # return res
c := count ( n ) # return factorial ( c ) * factorial ( n - c ) % mod
var tests = [] struct { # x , sqrtx int # }{ # { 4 , 2 }, # { 8 , 2 }, # { 9 , 3 }, # { 1 , 1 }, # } # # for _ , tt := range tests { # sqrtx := mySqrt ( tt . x ) # if sqrtx != tt . sqrtx { # t . Errorf (" STR ", tt . x , sqrtx , tt . sqrtx ) # } # }
if l 1 == nil { # return l 2 # } # if l 2 == nil { # return l 1 # } # # if l 1 . Val < l 2 . Val { # l 1 . Next = mergeTwoLists ( l 1 . Next , l 2 ) # return l 1 # } else { # l 2 . Next = mergeTwoLists ( l 1 , l 2 . Next ) # return l 2 # }
var count int # visited := make ([] bool , len ( M )) # for i := range M { # if visited [ i ] { # continue # } # search ( M , i , & visited ) # count ++ # } # return count
file , err := os . OpenFile (" STR ", # os . O_CREATE | os . O_WRONLY | os . O_APPEND , 0 6 6 6 ) # if err != nil { # log . Fatalln (" STR ", err ) # } # # Trace = log . New ( ioutil . Discard , # " STR ", # log . Ldate | log . Ltime | log . Lshortfile ) # # Info = log . New ( os . Stdout , # " STR ", # log . Ldate | log . Ltime | log . Lshortfile ) # # Warning = log . New ( os . Stdout , # " STR ", # log . Ldate | log . Ltime | log . Lshortfile ) # # Error = log . New ( io . MultiWriter ( file , os . Stderr ), # " STR ", # log . Ldate | log . Ltime | log . Lshortfile )
type arg struct { # a string # b string # } # # testCases := [] arg { # { # a : " STR ", # b : " STR ", # }, # { # b : " STR ", # a : " STR ", # }, # } # # expected := [] string { # " STR ", " STR ", # } # # for index , data := range testCases { # if res := addBinary ( data . a , data . b ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
answer := float 6 4 ( 1 ) # for i := 0 ; i < index ; i ++ { # answer *= ( x - points [ i ][ 0 ]) / ( points [ index ][ 0 ] - points [ i ][ 0 ]) # } # for i := index + 1 ; i < len ( points ); i ++ { # answer *= ( x - points [ i ][ 0 ]) / ( points [ index ][ 0 ] - points [ i ][ 0 ]) # } # return answer
if len ( s ) != 9 { # return false # } # set := map [ rune ] int {} # for _ , r := range s { # if r == ' 0 ' || set [ r ] > 0 { # return false # } # set [ r ] = 1 # } # return true
c := NewCircularBuffer ( 5 ) # # c . NBPush ( 0 ) # c . NBPush ( 1 ) # c . NBPush ( 2 ) # c . NBPush ( 3 ) # x := drain ( c ) # if cmp ( x , [] int { 0 , 1 , 2 , 3 }) != 0 { # t . Error (" STR ", x ) # } # # c . NBPush ( 0 ) # c . NBPush ( 1 ) # c . NBPush ( 2 ) # c . NBPush ( 3 ) # c . NBPush ( 4 ) # x = drain ( c ) # if cmp ( x , [] int { 1 , 2 , 3 , 4 }) != 0 { # t . Error (" STR ", x ) # }
c := rune ( b ) # switch { # case " STR " <= c && c <= " STR ": # return c - " STR ", true # case " STR " <= c && c <= " STR ": # return c - " STR " + 1 0 , true # case " STR " <= c && c <= " STR ": # return c - " STR " + 1 0 , true # } # return
i := & Index { # Target : & VariableAccess { Name : " STR "}, # Key : & LiteralNode { # Typex : TypeString , # Value : " STR ", # }, # } # # scope := & BasicScope { # VarMap : map [ string ] Variable { # " STR ": Variable { # Type : TypeMap , # Value : map [ string ] Variable { # " STR ": Variable { # Type : TypeString , # Value : " STR ", # }, # " STR ": Variable { # Type : TypeString , # Value : " STR ", # }, # }, # }, # }, # } # # actual , err := i . Type ( scope ) # if err != nil { # t . Fatalf (" STR ", err ) # } # if actual != TypeString { # t . Fatalf (" STR ", actual ) # }
if N <= 1 1 { # return special [ N ] # } # # # lm := genLM ( N ) # # for { # p := genPalindrome ( lm ) # if p >= N && isPrime ( p ) { # # return p # } # lm ++ # }
b . lock . Lock () # defer b . lock . Unlock () # # return b . lruList . Len () + b . freeList . Len ()
if k <= 0 { # return false # } # # m := make ( map [ int ] int , len ( nums )) # # for i , n := range nums { # if m [ n ] != 0 && i -( m [ n ]- 1 ) <= k { # return true # } # m [ n ] = i + 1 # } # # return false
for e := list . Front (); e != nil ; e = e . Next () { # if e . Value .( hashElement ). Key == key { # return e , true # } # } # return nil , false
dp := make ([] bool , len ( s )+ 1 ) # dp [ 0 ] = true # for i := range s { # for _ , word := range wordDict { # if i + 1 >= len ( word ) && s [ i + 1 - len ( word ): i + 1 ] == word { # dp [ i + 1 ] = dp [ i + 1 ] || dp [ i + 1 - len ( word )] # if dp [ i + 1 ] { # break # } # } # } # } # # return dp [ len ( s )]
if steps < 0 { # return 0 # } else if steps == 0 { # return 1 # } # # sum := 0 # for _ , stride := range strides { # sum += UniqueClimbs ( steps - stride , strides ) # } # # return sum
a := big . NewInt ( 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 ) # # if k_multiply ( a , a ). Cmp ( mul ( a , a )) != 0 { # fmt . Println ( k_multiply ( a , a ), mul ( a , a )) # t . Fatal (" STR ") # }
res := [] int { 0 , 0 } # if len ( S ) == 0 { # return res # } # res [ 0 ] = 1 # # for i := 0 ; i < len ( S ); i ++ { # if res [ 1 ]+ widths [ S [ i ]-' a '] > 1 0 0 { # res [ 0 ]++ # res [ 1 ] = widths [ S [ i ]-' a '] # } else { # res [ 1 ] += widths [ S [ i ]-' a '] # } # } # # return res
strId := strconv . Itoa ( id ) # # if len ( strId ) == 1 { # strId = " STR " + strId # } # if len ( strId ) == 2 { # strId = " STR " + strId # } # if len ( strId ) == 3 { # strId = " STR " + strId # } # # return strId
t . Parallel () # # for tcid , tc := range testcases { # if res := RemoveKthFromEnd ( tc . head , tc . kth ); ! equal ( res , tc . expected ) { # t . Errorf (" STR ", tcid ) # } # }
t . Parallel () # for _ , tc := range testcases { # if result := MaxProfitWithFee ( tc . prices , tc . fee ); ! reflect . DeepEqual ( tc . maxProfit , result ) { # t . Errorf (" STR ", tc . maxProfit , result ) # } # }
if x < 0 || x % 1 0 == 0 && x != 0 { # return false # } # var reverse int # for x > reverse { # reverse = reverse * 1 0 + x % 1 0 # x /= 1 0 # } # return x == reverse || x == reverse / 1 0
dp := make ([] int , len ( nums )+ 1 ) # dp [ 0 ] = 1 # for i := 1 ; i <= target ; i ++ { # for _ , v := range nums { # if v <= i { # dp [ i ] += dp [ i - v ] # } # } # } # return dp [ target ]
result := MakeMatrix ( make ([] float 6 4 , A . cols * A . rows ), A . cols , A . rows ) # # for i := 0 ; i < A . rows ; i ++ { # for j := 0 ; j < A . cols ; j ++ { # result . SetElm ( i , j , A . GetElm ( i , j )+ B . GetElm ( i , j )) # } # } # # return result
counter := 0 # for i := 0 ; i < len ( grid ); i ++ { # for j := 0 ; j < len ( grid [ 0 ]); j ++ { # if grid [ i ][ j ] == 1 { # if i - 1 < 0 || grid [ i - 1 ][ j ] == 0 { # counter ++ # } # if i + 1 >= len ( grid ) || grid [ i + 1 ][ j ] == 0 { # counter ++ # } # if j - 1 < 0 || grid [ i ][ j - 1 ] == 0 { # counter ++ # } # if j + 1 >= len ( grid [ 0 ]) || grid [ i ][ j + 1 ] == 0 { # counter ++ # } # } # } # } # return counter
var tests = [] struct { # num int # roman string # }{ # { 3 , " STR "}, # { 4 , " STR "}, # { 9 , " STR "}, # { 5 8 , " STR "}, # { 1 9 9 4 , " STR "}, # } # # for _ , tt := range tests { # roman := intToRoman ( tt . num ) # if roman != tt . roman { # t . Errorf (" STR ", tt . num , roman , tt . roman ) # } # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 3 , 2 , 3 }, 3 }, # {" STR ", [] int { 4 , 4 , 4 , 3 , 3 }, 4 }, # {" STR ", [] int { 2 , 2 , 1 , 1 , 1 , 2 , 2 }, 2 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := majorityElement 1 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
var tests = [] struct { # prices [] int # profit int # }{ # {[] int { 7 , 1 , 5 , 3 , 6 , 4 }, 5 }, # {[] int { 7 , 6 , 4 , 3 , 1 }, 0 }, # { nil , 0 }, # } # # for _ , tt := range tests { # profit := maxProfit ( tt . prices ) # if profit != tt . profit { # t . Errorf (" STR ", tt . prices , profit , tt . profit ) # } # }
lex := & lexer { scan : scanner . Scanner { Mode : scanner . GoTokens }} # lex . scan . Init ( bytes . NewReader ( data )) # lex . next () # defer func () { # if x := recover (); x != nil { # err = fmt . Errorf (" STR ", lex . scan . Position , x ) # } # }() # read ( lex , reflect . ValueOf ( out ). Elem ()) # return nil
res := 0 # for j := 0 ; j < 6 4 ; j ++ { # sum := 0 # for i := 0 ; i < len ( nums ); i ++ { # if ( nums [ i ] >> uint ( j ) & 1 ) > 0 { # sum ++ # } # } # if sum % 3 > 0 { # res |= 1 << uint ( j ) # } # } # return res
benchmark ( bb , 1 6 3 8 4 , 0 . 5 )
t . Run (" STR ", func ( t * testing . T ) { # got := lengthOfLastWord (" STR ") # want := 5 # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # }) # # t . Run (" STR ", func ( t * testing . T ) { # got := lengthOfLastWord (" STR ") # want := 5 # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # }) #
node . SideValue = color
t . Parallel () # if result := ValidUnlockKeypadNumber (); result != 3 8 9 1 1 2 { # t . Errorf (" STR ", result ) # }
l . header = & nodeItem { # value : " STR ", # next : nil , # } # headerNode := l . header # for i := 0 ; i < n ; i ++ { # if i % 2 == 0 { # continue # } # item := & nodeItem { # value : i , # next : nil , # } # headerNode . next = item # headerNode = headerNode . next # } # return & l
if k > len ( nums ) { # return 0 # } # return minimizePartitionMaximumSum ( nums , k )
fmt . Println ( findPeakElement ([] int { 3 , 4 , 3 , 2 , 1 })) # fmt . Println ( findPeakElement ([] int { 1 , 2 , 1 , 3 , 5 , 6 , 4 }))
sort . Ints ( nums ) # res , delta := 0 , math . MaxInt 6 4 # # for i := range nums { # if i > 0 && nums [ i ] == nums [ i - 1 ] { # continue # } # # l , r := i + 1 , len ( nums )- 1 # # for l < r { # s := nums [ i ] + nums [ l ] + nums [ r ] # switch { # case s < target : # l ++ # if delta > target - s { # delta = target - s # res = s # } # case s > target : # r -- # if delta > s - target { # delta = s - target # res = s # } # default : # return s # } # } # } # # return res
random := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # array 1 := make ([] int , random . Intn ( 1 0 0 - 1 0 )+ 1 0 ) # for i := range array 1 { # array 1 [ i ] = random . Intn ( 1 0 0 ) # } # array 2 := make ( sort . IntSlice , len ( array 1 )) # copy ( array 2 , array 1 ) # CocktailSort ( array 1 ) # array 2 . Sort () # for i := range array 1 { # if array 1 [ i ] != array 2 [ i ] { # t . Fail () # } # }
nums := [] int {- 2 , 1 , - 3 , 4 , - 1 , 2 , 1 , - 5 , 4 } # expected := 6 # # if res := maxSubArray ( nums ); res != expected { # t . Errorf (" STR ", expected , res ) # }
if b == 0 { # return 0 , errors . New (" STR ") # } # # result := 0 # for x := Abs ( a ); x >= Abs ( b ); x = SubstractAddOnly ( x , Abs ( b )) { # result ++ # } # if ( b < 0 && a > 0 ) || ( b > 0 && a < 0 ) { # result = Min ( result ) # } # # return result , nil
if root == nil { # return [] string {} # } # # var res [] string # # if root . Left == nil && root . Right == nil { # return append ( res , strconv . Itoa ( root . Val )) # } # # if root . Left != nil { # for _ , i := range binaryTreePaths ( root . Left ) { # res = append ( res , strconv . Itoa ( root . Val )+" STR "+ i ) # } # } # if root . Right != nil { # for _ , i := range binaryTreePaths ( root . Right ) { # res = append ( res , strconv . Itoa ( root . Val )+" STR "+ i ) # } # } # return res
x := make ([] int , 3 , 5 ) # x [ 0 ] = 1 0 # x [ 1 ] = 2 0 # x [ 2 ] = 3 0 # println ( x , " STR ") # # y := make ([] int , 3 ) # y [ 0 ] = 1 0 # y [ 1 ] = 2 0 # y [ 2 ] = 3 0 # println ( y , " STR ") # # z := [] int { 1 0 , 2 0 , 3 0 } # println ( z , " STR ") # # z 1 := [] int { 0 : 1 0 , 2 : 3 0 } # println ( z 1 , " STR ") # # slice := [] int { 1 0 , 2 0 , 3 0 } # slice = append ( slice , 4 0 , 5 0 ) # slice = append ( slice , [] int { 6 0 , 7 0 , 8 0 }...) # println ( slice , " STR ") # # sliced := slice [ 1 : 3 ] # println ( sliced , " STR ") #
n := len ( s ) # if n == 0 { # return 0 # } # stack := make ([] int , 0 , n ) # num := 0 # var sign byte = '+' # # for i := 0 ; i < n ; i ++ { # c := s [ i ] # if c >= ' 0 ' && c <= ' 9 ' { # num = num * 1 0 + int ( c -' 0 ') # } # if (!( c >= ' 0 ' && c <= ' 9 ') && c != ' ') || i == n - 1 { # switch sign { # case '+': # stack = append ( stack , num ) # case '-': # stack = append ( stack , - 1 * num ) # case '*': # stack [ len ( stack )- 1 ] *= num # case '/': # stack [ len ( stack )- 1 ] /= num # } # sign = c # num = 0 # } # } # res := 0 # for _ , v := range stack { # res += v # } # return res
const iterations = 3 7 # const contrast = 7 # for i := uint 8 ( 0 ); i < iterations ; i ++ { # z -= ( z - 1 /( z * z * z )) / 4 # if cmplx . Abs ( z * z * z * z - 1 ) < 1 e - 6 { # return color . Gray { 2 5 5 - contrast * i } # } # } # return color . Black
i , position , oldPosition := 0 , 0 , 0 # product := 1 # wantedDigits , wantedDigitIndex := [ 7 ] int { 1 , 1 0 , 1 0 0 , 1 0 0 0 , 1 0 0 0 0 , 1 0 0 0 0 0 , 1 0 0 0 0 0 0 }, 0 # for wantedDigitIndex < len ( wantedDigits ) { # i ++ # position += len ( Digits ( i )) # if position >= wantedDigits [ wantedDigitIndex ] && oldPosition < wantedDigits [ wantedDigitIndex ] { # product *= Digits ( i )[ position - wantedDigits [ wantedDigitIndex ]] # wantedDigitIndex ++ # } # oldPosition ++ # } # fmt . Println ( product )
if nil == ops { # return 0 # } # # sum := 0 # stack := make ([] int , 0 ) # for _ , op := range ops { # switch op { # case " STR ": # sum -= stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # case " STR ": # val := stack [ len ( stack )- 1 ] * 2 # sum += val # stack = append ( stack , val ) # case " STR ": # val := stack [ len ( stack )- 1 ] + stack [ len ( stack )- 2 ] # sum += val # stack = append ( stack , val ) # default : # val , _ := strconv . Atoi ( op ) # stack = append ( stack , val ) # sum += val # } # } # return sum
fmt . Println ( mySqrt ( 9 ))
size := len ( s ) # if size == 0 { # return [] string {" STR "} # } # # lastByte := s [ size - 1 ] # postfixs := make ([] string , 1 , 2 ) # postfixs [ 0 ] = string ( lastByte ) # if b , ok := check ( lastByte ); ok { # postfixs = append ( postfixs , string ( b )) # } # # prefixs := letterCasePermutation ( s [: size - 1 ]) # # res := make ([] string , 0 , len ( prefixs )* len ( postfixs )) # # for _ , pre := range prefixs { # for _ , post := range postfixs { # res = append ( res , pre + post ) # } # } # # return res
min := func ( m , n int ) int { # if m < n { # return m # } # # return n # } # # m := make ([] int , len ( S )) # for i := range m { # m [ i ] = - 1 # } # # for i , v := range indexes { # m [ v ] = i # } # # result := make ([] byte , 0 ) # i := 0 # for i < len ( S ) { # j := m [ i ] # if j < 0 { # result = append ( result , S [ i ]) # i ++ # } else { # start , end := indexes [ j ], min ( len ( S ), indexes [ j ]+ len ( sources [ j ])) # sub := S [ start : end ] # if sub == sources [ j ] { # result = append ( result , targets [ j ]...) # } else { # result = append ( result , sub ...) # } # # i = end # } # } # # return string ( result )
tmp := make ([] int , end - start + 1 ) # i := start # j := mid + 1 # k := 0 # for ; i <= mid && j <= end ; k ++ { # if arr [ i ] <= arr [ j ] { # tmp [ k ] = arr [ i ] # i ++ # } else { # tmp [ k ] = arr [ j ] # j ++ # } # } # for ; i <= mid ; i ++ { # tmp [ k ] = arr [ i ] # k ++ # } # for ; j <= end ; j ++ { # tmp [ k ] = arr [ j ] # k ++ # } # copy ( arr [ start : end + 1 ], tmp )
if len ( s ) != len ( t ) { # return false # } # sMap 1 := make ([] uint 8 , 2 5 6 ) # sMap 2 := make ([] uint 8 , 2 5 6 ) # # for i := 0 ; i < len ( s ); i ++ { # sMap 1 [ s [ i ]] += 1 # sMap 2 [ t [ i ]] += 1 # } # if ! reflect . DeepEqual ( sMap 1 , sMap 2 ) { # return false # } # return true
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 2 , 1 , 5 , 6 , 2 , 3 }, 1 0 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := largestRectangleArea ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
count := [ 1 2 1 ] int {} # for i := range ages { # count [ ages [ i ]]++ # } # # sums := [ 1 2 1 ] int {} # sum := 0 # res := 0 # for a := range count { # sum += count [ a ] # sums [ a ] = sum # # if a <= 1 4 || count [ a ] == 0 { # continue # } # # b := a / 2 + 7 # # res += count [ a ] * ( sums [ a ] - sums [ b ] - 1 ) # } # # return res
qs := [] question 8 3 4 { # # { # para 8 3 4 { 4 , [][] int {{ 1 , 2 }, { 3 , 2 }, { 3 , 0 }}}, # ans 8 3 4 {[] int { 6 , 6 , 4 , 4 }}, # }, # # { # para 8 3 4 { 6 , [][] int {{ 0 , 1 }, { 0 , 2 }, { 2 , 3 }, { 2 , 4 }, { 2 , 5 }}}, # ans 8 3 4 {[] int { 8 , 1 2 , 6 , 1 0 , 1 0 , 1 0 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 3 4 , q . para 8 3 4 # fmt . Printf (" STR ", p , sumOfDistancesInTree ( p . N , p . edges )) # } # fmt . Printf (" STR ")
uint 6 4 Val := uint 6 4 ( self . PopLong ()) # return math . Float 6 4 frombits ( uint 6 4 Val )
switch { # case len ( p ) == 0 : # return len ( s ) == 0 # case len ( s ) == 0 : # if len ( p ) > 1 && p [ 1 ] == '*' { # return isMatchV 1 ( s , p [ 2 :]) # } # return false # case len ( p ) > 1 && p [ 1 ] == '*': # if isMatchV 1 ( s , p [ 2 :]) { # return true # } else if s [ 0 ] == p [ 0 ] || p [ 0 ] == '.' { # return isMatchV 1 ( s [ 1 :], p ) # } # return false # default : # return ( s [ 0 ] == p [ 0 ] || p [ 0 ] == '.') && isMatchV 1 ( s [ 1 :], p [ 1 :]) # }
arr := randomSlice ( 0 , 2 0 , 1 0 ) # nodeCnt := 0 # rbt := newRBT () # for i , v := range arr { # rbt . Insert ( uint 3 2 ( v )) # stop := rbt . PreOrderWalk ( rbt . Root (), checkGBT ( t , & nodeCnt , * debug )) # if stop { # return # } # if nodeCnt != i + 1 { # t . Log (" STR ", i + 1 , " STR ", nodeCnt ) # t . Fail () # } # nodeCnt = 0 # stop = checkRBT ( t , rbt ) # if stop { # return # } # }
return helper ( expression , nil )
fmt . Println ( strconv . Itoa ( 1 )) # fmt . Println ( strings . Compare (" STR ", " STR ")) # fmt . Println ( math . Abs ( 1 . 0 ))
for a := 1 ; a <= val ; a ++ { # for b := a + 1 ; b <= val ; b ++ { # sqrt := math . Sqrt ( float 6 4 ( a * a + b * b )) # if isNaturalSquare ( sqrt ) { # if a + b + int ( sqrt ) == val { # fmt . Println (" STR ", a , " STR ", b , " STR ", int ( sqrt )) # fmt . Println ( a * b * int ( sqrt )) # } # } # } # }
for qi := range p . queue { # if qi . term { # close ( p . done ) # } else if qi . pr != nil { # res := <- qi . pr # if res . err != nil { # p . err = res . err # } # p . final = append ( p . final , res . bytes ...) # } else { # p . final = append ( p . final , qi . bs ...) # } # }
ball := make ([] int , 2 6 ) # for i := 0 ; i < len ( hand ); i ++ { # ball [ hand [ i ]-' A ']++ # } # # var dfs func ( string ) int # dfs = func ( s string ) int { # s = removeConsecutive ( s ) # if s == " STR " { # return 0 # } # count , need := maxCount , 0 # for i , j := 0 , 0 ; j < len ( s ); j ++ { # if s [ i ] == s [ j ] { # continue # } # need = i + 3 - j # if ball [ s [ i ]-' A '] >= need { # ball [ s [ i ]-' A '] -= need # count = min ( count , need + dfs ( s [: i ]+ s [ j :])) # ball [ s [ i ]-' A '] += need # } # i = j # } # return count # } # res := dfs ( board + " STR ") # if res == maxCount { # return - 1 # } # return res
dp := make ([] int , amount + 1 ) # dp [ 0 ] = 0 # # for i := 1 ; i <= amount ; i ++ { # dp [ i ] = amount + 1 # for _ , c := range coins { # if c <= i && dp [ i ] > dp [ i - c ]+ 1 { # dp [ i ] = dp [ i - c ] + 1 # } # } # } # # if dp [ amount ] > amount { # return - 1 # } # # return dp [ amount ]
swapCount := 1 # for swapCount > 0 { # swapCount = 0 # for itemIndex := 0 ; itemIndex < len ( array )- 1 ; itemIndex ++ { # if array [ itemIndex ] > array [ itemIndex + 1 ] { # array [ itemIndex ], array [ itemIndex + 1 ] = array [ itemIndex + 1 ], array [ itemIndex ] # swapCount += 1 # } # } # for itemIndex := len ( array ) - 1 ; itemIndex > 0 ; itemIndex -- { # if array [ itemIndex ] < array [ itemIndex - 1 ] { # array [ itemIndex ], array [ itemIndex - 1 ] = array [ itemIndex - 1 ], array [ itemIndex ] # swapCount += 1 # } # } # }
G := make ([] int , n + 1 ) # G [ 0 ], G [ 1 ] = 1 , 1 # for i := 2 ; i <= n ; i ++ { # for j := 1 ; j <= i ; j ++ { # G [ i ] += G [ j - 1 ] * G [ i - j ] # } # } # return G [ n ]
if nil == t 1 { # return t 2 # } # if nil == t 2 { # return t 1 # } # # return & TreeNode { Val : t 1 . Val + t 2 . Val , Left : mergeTrees ( t 1 . Left , t 2 . Left ), Right : mergeTrees ( t 1 . Right , t 2 . Right )}
var s uint # for o := 0 ; o < len ( tp . list_of_pools ); o ++ { # p := & tp . list_of_pools [ o ] # p . mu . Lock () # s += uint ( len ( p . list )) # p . mu . Unlock () # } # return s
ansSet := make ( map [ string ] struct {}) # allPossibleSubsequences ( str , ansSet ) # # return ansSet
e , o := 0 , 0 # for _ , val := range chips { # if val % 2 == 0 { # e ++ # } else { # o ++ # } # } # if e < o { # return e # } # return o
sz := len ( arr ) # step := int ( math . Sqrt ( float 6 4 ( sz ))) # prev := 0 # # for arr [ int ( math . Min ( float 6 4 ( step ), float 6 4 ( sz ))) - 1 ] < key { # prev = step # step += int ( math . Sqrt ( float 6 4 ( sz ))) # if prev >= sz { # return - 1 # } # } # # for arr [ prev ] < key { # prev ++ # if prev == int ( math . Min ( float 6 4 ( step ), float 6 4 ( sz ))) { # return - 1 # } # } # # if arr [ prev ] == key { # return prev # } # return - 1
y := x + a - 1 # return y - y % a
if mod == 1 { # return 0 # } # var r int 6 4 = 1 # b = b % mod # for e > 0 { # if e & 1 == 1 { # r = ( r * b ) % mod # } # e = e >> 1 # b = ( b * b ) % mod # } # return r
r := make ([][] int , 0 ) # if root == nil { # return r # } # level := 0 # queue := []* Node { root } # for len ( queue ) > 0 { # r = append ( r , [] int {}) # nextQueue := make ([]* Node , 0 ) # for _ , node := range queue { # r [ level ] = append ( r [ level ], node . Val ) # if len ( node . Children ) > 0 { # nextQueue = append ( nextQueue , node . Children ...) # } # } # level ++ # queue = nextQueue # } # # return r
var tests = [] struct { # p , q * TreeNode # isSame bool # }{ # { newTree ( 1 , 2 , 3 ), newTree ( 1 , 2 , 3 ), true }, # { newTree ( 1 , 2 ), newTree ( 1 , nil , 2 ), false }, # { newTree ( 1 , 2 , 1 ), newTree ( 1 , 1 , 2 ), false }, # { newTree ( 1 0 , 5 , 1 5 ), newTree ( 1 0 , 5 , nil , nil , 1 5 ), false }, # } # # for _ , tt := range tests { # isSame := isSameTree ( tt . p , tt . q ) # if isSame != tt . isSame { # t . Errorf (" STR ", tt . p , tt . q , isSame , tt . isSame ) # } # }
buf := bytes . NewBuffer ( nil ) # enc := gob . NewEncoder ( buf ) # enc . Encode ( key ) # hashBytes := hash . Sum ( buf . Bytes ()) # return new ( big . Int ). SetBytes ( hashBytes )
var ret [][] int # sort . Ints ( nums ) # for i := 0 ; i < len ( nums )- 2 ; i ++ { # if i > 0 && nums [ i - 1 ] == nums [ i ] { # continue # } # j , k := i + 1 , len ( nums )- 1 # for j < k { # if j > i + 1 && nums [ j ] == nums [ j - 1 ] { # j ++ # continue # } # if nums [ i ]+ nums [ j ]+ nums [ k ] == 0 { # ret = append ( ret , [] int { nums [ i ], nums [ j ], nums [ k ]}) # j ++ # k -- # } else if nums [ i ]+ nums [ j ]+ nums [ k ] < 0 { # j ++ # } else { # k -- # } # } # } # return ret
var tests = [] struct { # list [] int # swaped * ListNode # }{ # {[] int { 1 }, newList ( 1 )}, # {[] int { 1 , 2 , 3 , 4 }, newList ( 2 , 1 , 4 , 3 )}, # {[] int { 1 , 2 , 3 , 4 , 5 }, newList ( 2 , 1 , 4 , 3 , 5 )}, # } # # for _ , tt := range tests { # swaped := swapPairs ( newList ( tt . list ...)) # if reflect . DeepEqual ( swaped , tt . swaped ) == false { # t . Errorf (" STR ", newList ( tt . list ...), swaped , tt . swaped ) # } # }
var res [] int # var stack []* TreeNode # for 0 < len ( stack ) || root != nil { # for root != nil { # stack = append ( stack , root ) # root = root . Left # } # top := len ( stack ) - 1 # if len ( res ) < k { # res = append ( res , stack [ top ]. Val ) # } else if math . Abs ( float 6 4 ( stack [ top ]. Val )- target ) < math . Abs ( float 6 4 ( res [ 0 ])- target ) { # res = append ( res [ 1 :], stack [ top ]. Val ) # } # root = stack [ top ]. Right # stack = stack [: top ] # # } # return res
sum := 0 # for i := 2 ; i < val ; i ++ { # if chop ( i ) == i { # sum += i # } # } # fmt . Println ( sum )
x := 4 0 # for x >= 4 0 { # x = 7 *( rand 7 ()- 1 ) + ( rand 7 () - 1 ) # } # return x % 1 0 + 1
n := len ( triangle ) # if n == 0 { # return 0 # } # # for i := 1 ; i < n ; i ++ { # for j := 0 ; j <= i ; j ++ { # switch { # case j == 0 : # triangle [ i ][ 0 ] += triangle [ i - 1 ][ 0 ] # case j == i : # triangle [ i ][ i ] += triangle [ i - 1 ][ i - 1 ] # case triangle [ i - 1 ][ j - 1 ] < triangle [ i - 1 ][ j ]: # triangle [ i ][ j ] += triangle [ i - 1 ][ j - 1 ] # default : # triangle [ i ][ j ] += triangle [ i - 1 ][ j ] # } # } # } # # min := triangle [ n - 1 ][ 0 ] # for j := 1 ; j < n ; j ++ { # if min > triangle [ n - 1 ][ j ] { # min = triangle [ n - 1 ][ j ] # } # } # # return min
rets := [] int {} # if root == nil { # return rets # } # stack := []* TreeNode { root } # head := root # for len ( stack ) != 0 { # node := stack [ len ( stack )- 1 ] # if node . Left == head || node . Right == head || node . Left == nil && node . Right == nil { # rets = append ( rets , node . Val ) # stack = stack [: len ( stack )- 1 ] # head = node # } else { # if node . Right != nil { # stack = append ( stack , node . Right ) # } # if node . Left != nil { # stack = append ( stack , node . Left ) # } # } # } # return rets
for _ , tc := range testCases { # t . Run ( tc . name , func ( t * testing . T ) { # actual := IterativePower ( tc . base , tc . power ) # if actual != tc . expected { # t . Errorf (" STR ", tc . base , tc . power , tc . expected , actual ) # } # }) # }
p := m + n - 1 # m -- # n -- # for m >= 0 && n >= 0 { # if nums 1 [ m ] > nums 2 [ n ] { # nums 1 [ p ] = nums 1 [ m ] # p -- # m -- # } else { # nums 1 [ p ] = nums 2 [ n ] # p -- # n -- # } # } # # for n >= 0 { # nums 1 [ p ] = nums 2 [ n ] # p -- # n -- # }
x := make ([] int , 2 , 5 ) # x [ 0 ] = 1 0 # x [ 1 ] = 2 0 # fmt . Println (" STR ", x ) # fmt . Printf (" STR ", len ( x ), cap ( x )) # x = append ( x , 3 0 , 4 0 , 5 0 ) # fmt . Println (" STR ", x ) # fmt . Printf (" STR ", len ( x ), cap ( x )) # # x = append ( x , 6 0 , 7 0 , 8 0 ) # fmt . Println (" STR ", x ) # fmt . Printf (" STR ", len ( x ), cap ( x )) #
t . Parallel () # # for _ , tc := range testcases { # if result := NumberOfDecodings ( tc . input ); result != tc . expected { # t . Errorf (" STR ", tc . input , tc . expected , result ) # } # }
return ldc . cost [ i - 1 ][ j ] + d . cost
Problem 2 5 0 ( 2 5 0 2 5 0 , 2 5 0 )
qs := [] question 8 5 3 { # # { # para 8 5 3 { 1 2 , [] int { 1 0 , 8 , 0 , 5 , 3 }, [] int { 2 , 4 , 1 , 1 , 3 }}, # ans 8 5 3 { 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 5 3 , q . para 8 5 3 # fmt . Printf (" STR ", p , carFleet ( p . target , p . position , p . speed )) # } # fmt . Printf (" STR ")
hashValue := h . HashFunc ( key , sha 1 . New ()) # mb := big . NewInt ( int 6 4 ( h . Cap )) # hashValue . Mod ( hashValue , mb ) # return uint 3 2 ( hashValue . Uint 6 4 ())
ls , lt := len ( s ), len ( t ) # dp := make ([][] int , lt + 1 ) # for k := range dp { # dp [ k ] = make ([] int , ls + 1 ) # } # for k := range dp [ 0 ] { # dp [ 0 ][ k ] = 1 # } # for i := 1 ; i <= lt ; i ++ { # for j := 1 ; j <= ls ; j ++ { # if t [ i - 1 ] == s [ j - 1 ] { # dp [ i ][ j ] = dp [ i ][ j - 1 ] + dp [ i - 1 ][ j - 1 ] # } else { # dp [ i ][ j ] = dp [ i ][ j - 1 ] # } # } # } # return dp [ lt ][ ls ]
if len ( nums ) == 0 { # return 0 # } # last , finder := 0 , 0 # for last < len ( nums )- 1 { # startFinder := - 1 # for nums [ finder ] == nums [ last ] { # if startFinder == - 1 || startFinder > finder { # startFinder = finder # } # if finder == len ( nums )- 1 { # break # } # finder ++ # } # if finder - startFinder >= 2 && nums [ finder - 1 ] == nums [ last ] && nums [ finder ] != nums [ last ] { # nums [ last + 1 ] = nums [ finder - 1 ] # nums [ last + 2 ] = nums [ finder ] # last += 2 # } else { # nums [ last + 1 ] = nums [ finder ] # last ++ # } # if finder == len ( nums )- 1 { # if nums [ finder ] != nums [ last - 1 ] { # nums [ last ] = nums [ finder ] # } # return last + 1 # } # } # return last + 1
if len ( s ) == 0 { # return 0 # } # var bitSet [ 2 5 6 ] bool # result , left , right := 0 , 0 , 0 # for left < len ( s ) { # if bitSet [ s [ right ]] { # bitSet [ s [ left ]] = false # left ++ # } else { # bitSet [ s [ right ]] = true # right ++ # } # if result < right - left { # result = right - left # } # if left + result >= len ( s ) || right >= len ( s ) { # break # } # } # return result
total := 2 # currNum := 3 # currDivisor := 0 # foundPrimes := make ([] int , 0 ) # foundPrimes = append ( foundPrimes , 2 ) # for currNum < 2 0 0 0 0 0 0 { # ceil := int ( math . Ceil ( math . Sqrt ( float 6 4 ( currNum )))) # for ; currDivisor < len ( foundPrimes ); currDivisor ++ { # div := foundPrimes [ currDivisor ] # if ( currNum % div ) == 0 { # break # } # if currDivisor + 1 >= len ( foundPrimes ) || div > ceil { # foundPrimes = append ( foundPrimes , currNum ) # total += currNum # break # } # } # currNum += 2 # currDivisor = 0 # } # println (" STR ", total )
for _ , tc := range testcases { # buff := new ( bytes . Buffer ) # out = buff # in = strings . NewReader ( tc . input ) # main () # if result := buff . String (); result != tc . output { # t . Errorf (" STR ", tc . output , result ) # } # }
if n <= 0 { # return 0 # } else if n <= 3 { # return 1 # } # l := make ([] int , n + 1 ) # l [ 0 ], l [ 1 ], l [ 2 ] = 1 , 2 , 2 # res := 1 # i , j , num := 2 , 3 , 1 # for j < n { # for k := 0 ; k < l [ i ]; k ++ { # l [ j ] = num # if num == 1 && j < n { # res ++ # } # j ++ # } # num ^= 3 # i ++ # } # return res
if m . exist ( key ) { # return m . m [ key ].([] interface {})[ 1 ] # } # return nil
n := len ( deck ) # if n < 2 { # return false # } # hash := make ( map [ int ] int ) # for _ , val := range deck { # hash [ val ]++ # } # ans := hash [ deck [ 0 ]] # for _ , val := range hash { # ans = gcd ( ans , val ) # } # return ans >= 2
if root == nil { # return nil # } # if root . Left == nil && root . Right == nil { # if root . Val != sum { # return nil # } # return [][] int {{ root . Val }} # } # # var paths [][] int # sum -= root . Val # for _ , path := range pathSum ( root . Left , sum ) { # path = append ([] int { root . Val }, path ...) # paths = append ( paths , path ) # } # for _ , path := range pathSum ( root . Right , sum ) { # path = append ([] int { root . Val }, path ...) # paths = append ( paths , path ) # } # return paths
t . Parallel () # for _ , tc := range testcases { # copied := make ([] int 3 2 , len ( tc . input )) # copy ( copied , tc . input ) # RadixSortInt 3 2 ( copied ) # if ! reflect . DeepEqual ( copied , tc . sorted ) { # t . Errorf (" STR ", tc . sorted , copied ) # } # }
indices 1 , indices 2 := make ([] int , 0 ), make ([] int , 0 ) # for i , word := range words { # if word == word 1 { # indices 1 = append ( indices 1 , i ) # } else if word == word 2 { # indices 2 = append ( indices 2 , i ) # } # } # # dist := len ( words ) # i , j := 0 , 0 # for i < len ( indices 1 )- 1 || j < len ( indices 2 )- 1 { # dist = int ( math . Min ( float 6 4 ( dist ), math . Abs ( float 6 4 ( indices 1 [ i ]- indices 2 [ j ])))) # if j == len ( indices 2 )- 1 || ( i < len ( indices 1 )- 1 && indices 1 [ i ] < indices 2 [ j ]) { # i ++ # } else { # j ++ # } # } # # dist = int ( math . Min ( float 6 4 ( dist ), math . Abs ( float 6 4 ( indices 1 [ i ]- indices 2 [ j ])))) # return dist
n := node .(* gbtElement ) # if t . IsNil ( n . Left ) { # return t . NilNode # } # newNode := n . Left # if n . Parent . Right == n { # n . Parent . Right = newNode # } # if n . Parent . Left == n { # n . Parent . Left = newNode # } # n . Parent , newNode . Parent = newNode , n . Parent # newNode . Right , n . Left = n , newNode . Right # if ! t . IsNil ( n . Left ) { # n . Left . Parent = n # } # return newNode
for beginState , transitions := range at { # for c , endState := range transitions { # if endState == state { # return c , beginState # } # } # } # return 0 , 0
n := len ( senate ) # # qr := make ([] int , 0 , n ) # qd := make ([] int , 0 , n ) # for i , b := range senate { # if b == ' R ' { # qr = append ( qr , i ) # } else { # qd = append ( qd , i ) # } # } # # for len ( qr ) > 0 && len ( qd ) > 0 { # ri := qr [ 0 ] # qr = qr [ 1 :] # di := qd [ 0 ] # qd = qd [ 1 :] # if ri < di { # qr = append ( qr , ri + n ) # } else { # qd = append ( qd , di + n ) # } # } # # if len ( qr ) > 0 { # return " STR " # } # return " STR "
benchmarkHashMapInsert ( b , newChainedHashMap ())
cases := [] struct { from , to , expected string }{ # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # } # # for _ , c := range cases { # str , err := Convert ( c . from , c . to ) # if err != nil { # t . Log (" STR ", err ) # t . Fail () # } # if str != c . expected { # t . Log (" STR "+ c . expected +" STR ", str ) # t . Fail () # } # } #
_ , err := net . ParseMAC ( field . String ()) # return err == nil
if l . state == nil { # return token { itemEOF , ""} # } # l . state = l . state ( l ) # return l . item
m := [][] int { # # { 2 , 3 , 4 }, # { 5 , 6 , 7 }, # { 8 , 9 , 1 0 }, # { 1 1 , 1 2 , 1 3 }, # { 1 4 , 1 5 , 1 6 }, # } # fmt . Println ( imageSmoother ( m ))
dummy := & ListNode { # Next : head , # } # # node := dummy # for node != nil && node . Next != nil { # n 1 := node . Next # var n 2 , n 3 * ListNode # if n 1 != nil { # n 2 = n 1 . Next # } # # if n 2 != nil { # n 3 = n 2 . Next # node . Next = n 2 # n 2 . Next = n 1 # n 1 . Next = n 3 # } # # node = n 1 # } # # return dummy . Next
ans := 0 # for _ , v := range nums { # ans ^= v # } # return ans
pairs := [...][ 2 ] uint 6 4 {{ 2 , 6 }, { 2 0 , 1 3 7 8 4 6 5 2 8 8 2 0 }} # for _ , pair := range pairs { # in , out := pair [ 0 ], pair [ 1 ] # if x := p 1 5 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # } # }
testFramework ( t , ShellSort )
return rawType ( k << 1 )
cases := [] struct { # name string # inputs [] int # expect [] bool # }{ # {" STR ", [] int { 0 }, [] bool { true }}, # {" STR ", [] int { 1 }, [] bool { false }}, # {" STR ", [] int { 0 , 1 , 1 }, [] bool { true , false , false }}, # {" STR ", [] int { 1 , 1 , 1 }, [] bool { false , false , false }}, # {" STR ", [] int { 1 , 1 , 1 , 0 , 1 }, [] bool { false , false , false , false , false }}, # {" STR ", [] int { 0 , 1 , 1 , 1 , 1 , 1 }, [] bool { true , false , false , false , true , false }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
res := [] string {} # for i := 1 ; i <= n ; i ++ { # s := "" # if i % 3 == 0 { # s += " STR " # } # if i % 5 == 0 { # s += " STR " # } # if s == "" { # s += strconv . Itoa ( i ) # } # res = append ( res , s ) # } # return res
in , out := 1 0 0 0 0 0 0 , 8 3 7 7 9 9 # if x := p 1 4 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # }
var tests = [] struct { # candidates [] int # target int # combinations [][] int # }{ # {[] int { 1 0 , 1 , 2 , 7 , 6 , 1 , 5 }, 8 , [][] int {{ 1 , 2 , 5 }, { 1 , 7 }, { 1 , 1 , 6 }, { 2 , 6 }}}, # {[] int { 2 , 5 , 2 , 1 , 2 }, 5 , [][] int {{ 1 , 2 , 2 }, { 5 }}}, # } # # for _ , tt := range tests { # combinations := combinationSum 2 ( tt . candidates , tt . target ) # if reflect . DeepEqual ( combinations , tt . combinations ) == false { # t . Errorf (" STR ", tt . candidates , tt . target , combinations , tt . combinations ) # } # }
bx := big . NewInt ( x ) # by := big . NewInt ( y ) # return bx . Exp ( bx , by , nil )
fmt . Fprintln ( w , os . Args [ 0 ], Package , Version )
initialValue := " STR " # # numOfEntries := 1 3 # answer := 0 # start := 0 # end := start + ( numOfEntries - 1 ) # # for ; end < len ( initialValue ); start , end = start + 1 , end + 1 { # total := 1 # for counter := 0 ; counter < numOfEntries ; counter ++ { # num , _ := strconv . Atoi ( initialValue [ start + counter : start + counter + 1 ]) # total = num * total # } # if total > answer { # answer = total # } # } # # fmt . Println ( answer )
t . Parallel () # for _ , tc := range testcases { # if t 1 , t 2 , err := AssignTeams ( tc . enemies ); ! reflect . DeepEqual ( t 1 , tc . teamOne ) || # ! reflect . DeepEqual ( t 2 , tc . teamTwo ) || err != tc . err { # t . Errorf (" STR ", tc . teamOne , tc . teamTwo , tc . err , t 1 , t 2 , err ) # } # }
if len ( nums ) < 1 { # return nil # } # # mid := len ( nums ) / 2 # return & TreeNode { # Val : nums [ mid ], # Left : sortedArrayToBST ( nums [: mid ]), # Right : sortedArrayToBST ( nums [ mid + 1 :]), # }
if num < 1 0 { # return num # } # sum := 0 # for num != 0 { # sum += num % 1 0 # num = num / 1 0 # } # return addDigits ( sum )
if n == 0 { # return 1 # } # if n == 1 || n == 2 { # return n # } # # if n == 3 { # return 5 # } # # res := 0 # for i := 1 ; i <= n / 2 ; i ++ { # res += numTrees ( i - 1 ) * numTrees ( n - i ) # } # res *= 2 # if n % 2 == 1 { # temp := numTrees ( n / 2 ) # res += temp * temp # } # # return res
board := [][] byte { # {' A ', ' B ', ' C ', ' E '}, # {' S ', ' F ', ' C ', ' S '}, # {' A ', ' D ', ' E ', ' E '}, # } # testCases := [] string { # " STR ", # " STR ", # " STR ", # } # expected := [] bool { true , true , false } # for index , word := range testCases { # if res := exist ( board , word ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
char := [] rune ( s ) # for i , j := 0 , len ( s )- 1 ; i < j ; i , j = i + 1 , j - 1 { # char [ i ], char [ j ] = char [ j ], char [ i ] # } # return string ( char )
fmt . Println (" STR ") # fmt . Println ( l . p 0 ) # fmt . Println ( l . p 1 ) # fmt . Println (" STR ")
len_a := len ( a . String ()) # len_b := len ( b . String ()) # # if len_a > len_b { # return len_a / 2 # } else { # return len_b / 2 # }
return h . len
hash := make ( map [ int ] int ) # maxHash := make ( map [ int ][] int ) # return FreqStack { freq : hash , group : maxHash }
total := Sum ( 1 , 2 , 3 , 4 ) # fmt . Println (" STR ", total ) # # total = Sum ( 5 , 7 , 8 ) # fmt . Println (" STR ", total ) # # total = Sum () # fmt . Println (" STR ", total ) # # nums := [] int { 1 , 2 , 3 , 4 , 5 } # total = Sum ( nums ...) # fmt . Println (" STR ", total )
const ( # start = 1 # end = 1 0 0 0 # ) # # sum := 0 # for i := start ; i <= end ; i ++ { # sum += countTo 1 0 0 0 ( i ) # } # fmt . Println ( sum )
xx := x 2 - x 1 # yy := y 2 - y 1 # if xx == 0 { # return fmt . Sprintf (" STR ", x 1 ) # } # if yy == 0 { # return fmt . Sprintf (" STR ", y 1 ) # } # flag := xx * yy < 0 # if xx < 0 { # xx = - xx # } # if yy < 0 { # yy = - yy # } # k := gcd ( xx , yy ) # yy /= k # xx /= k # s := fmt . Sprintf (" STR ", yy , xx ) # if flag { # return " STR " + s # } # return s
if _ , ok := this . cache [ key ]; ! ok { # node := initDLinkedNode ( key , value ) # this . cache [ key ] = node # this . addToHead ( node ) # this . size ++ # if this . size > this . capacity { # removed := this . removeTail () # delete ( this . cache , removed . key ) # this . size -- # } # } else { # node := this . cache [ key ] # node . value = value # this . moveToHead ( node ) # }
opens := 0 # count := 0 # for _ , r := range parens { # if r == '(' { # opens ++ # } else if r == ')' { # if opens == 0 { # count ++ # } else { # opens -- # } # } # } # return count + opens
buf := make ([] byte , 8 ) # n , err := io . CopyBuffer ( h , r , buf ) # if err != nil { # return err # } # if n != fSize { # return errReadSizeMismatch # } # # return nil
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 2 , 3 , 0 , 2 }, 3 }, # {" STR ", [] int { 1 }, 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := maxProfit ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
return & Node { Value : value }
int 3 2 Val := int 3 2 ( math . Float 3 2 bits ( value )) # self . slots [ self . top ]. Num = int 3 2 Val # self . top ++
data := [] int { 1 , 2 , 4 , 7 , 1 1 , 1 5 } # sum := 1 5 # # fmt . Println ( findNumbers ( data , sum )) # # findContinuousSequence ( 1 5 )
for x == nil || y == nil { # if x == nil && y != nil { # fmt . Println ( x , y ) # return false # } # if x != nil && y == nil { # fmt . Println ( x , y ) # return false # } # # if x . Val != y . Val { # fmt . Println ( x , y ) # return false # } # x = x . Next # y = y . Next # } # return true
n := 1 0 0 0 # sum := big . NewInt ( 0 ) # for i := 1 ; i <= n ; i ++ { # x := big . NewInt ( int 6 4 ( i )) # x = x . Exp ( x , x , nil ) # # sum = x . Add ( x , sum ) # } # # strNum := sum . String () # # return strNum [ len ( strNum )- 1 0 :]
n := len ( s ) # stack , top := make ([] int , n ), - 1 # pair := make ([] int , n ) # # for i := 0 ; i < n ; i ++ { # switch s [ i ] { # case '(': # top ++ # stack [ top ] = i # case ')': # j := stack [ top ] # top -- # pair [ i ], pair [ j ] = j , i # } # } # var sb strings . Builder # # for i , d := 0 , 1 ; i < n ; i += d { # if s [ i ] == '(' || s [ i ] == ')' { # i = pair [ i ] # d = - d # } else { # sb . WriteByte ( s [ i ]) # } # } # # return sb . String ()
cases := [] struct { # name string # input 1 string # input 2 [] string # expect bool # }{ # {" STR ", " STR ", [] string {" STR ", " STR "}, true }, # {" STR ", " STR ", [] string {" STR ", " STR "}, true }, # {" STR ", " STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR "}, false }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := wordBreak 3 ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 , c . input 2 ) # } # }) # }
isInc , isDec := true , true # for i := 1 ; i < len ( A ); i ++ { # if A [ i ] > A [ i - 1 ] { # isDec = false # } else if A [ i ] < A [ i - 1 ] { # isInc = false # } # # if !( isInc || isDec ) { # return false # } # } # # return true
t := new ( gbt ) # t . Init () # return t
iE := i .(* linkedHeapListElement ) # return iE . prev
keys := make ([] string , 0 ) # callback := func ( key string , value Value ) { # keys = append ( keys , key ) # } # lru := New ( int 6 4 ( 1 0 ), callback ) # lru . Add (" STR ", String (" STR ")) # lru . Add (" STR ", String (" STR ")) # lru . Add (" STR ", String (" STR ")) # lru . Add (" STR ", String (" STR ")) # # expect := [] string {" STR ", " STR "} # # if ! reflect . DeepEqual ( expect , keys ) { # t . Fatalf (" STR ", expect ) # }
var tests = [] struct { # t 1 , t 2 * TreeNode # similar bool # }{ # { newTree ( 1 ), newTree ( 2 ), false }, # { newTree ( 1 ), newTree ( 1 , 2 ), false }, # { newTree ( 1 , 2 , 3 ), newTree ( 1 , 2 , 4 ), false }, # { newTree ( 1 , 2 , 3 ), newTree ( 1 , 2 , 3 , 2 , 3 ), false }, # { newTree ( 3 , 5 , 1 , 6 , 2 , 9 , 8 , nil , nil , 7 , 4 ), newTree ( 3 , 5 , 1 , 6 , 7 , 4 , 2 , nil , nil , nil , nil , nil , nil , 9 , 8 ), true }, # } # # for _ , tt := range tests { # similar := leafSimilar ( tt . t 1 , tt . t 2 ) # if similar != tt . similar { # t . Errorf (" STR ", tt . t 1 , tt . t 2 , similar , tt . similar ) # } # }
dp := [][] int {} # for i := 0 ; i < m ; i ++ { # tmp := make ([] int , n ) # dp = append ( dp , tmp ) # } # for i := 0 ; i < m ; i ++ { # dp [ i ][ 0 ] = 1 # } # for i := 0 ; i < n ; i ++ { # dp [ 0 ][ i ] = 1 # } # for i := 1 ; i < m ; i ++ { # for j := 1 ; j < n ; j ++ { # dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ] # } # } # return dp [ m - 1 ][ n - 1 ]
return q . Root ( p ) == q . Root ( r )
ms := runtime . MemStats {} # # for { # escapesToHeap () # runtime . ReadMemStats (& ms ) # println (" STR ", ms . HeapInuse , " STR ", ms . HeapIdle , " STR ", ms . GCSys ) # runtime . GC () # runtime . ReadMemStats (& ms ) # println (" STR ", ms . HeapInuse , " STR ", ms . HeapIdle , " STR ", ms . GCSys ) # time . Sleep ( 5 * time . Second ) # } #
mu . Lock () # balance = balance + amount # mu . Unlock ()
n := len ( nums ) # left , right := 0 , - 1 # min , max := nums [ n - 1 ], nums [ 0 ] # # for i := 1 ; i < n ; i ++ { # if max <= nums [ i ] { # max = nums [ i ] # } else { # right = i # } # # j := n - i - 1 # if min >= nums [ j ] { # min = nums [ j ] # } else { # left = j # } # } # # return right - left + 1
iE := i .(* ltHeapElement ) # return iE . Value
r 1 , i 1 := complex ( a ) # r 2 , i 2 := complex ( b ) # return fmt . Sprintf (" STR ", r 1 * r 2 - i 1 * i 2 , r 1 * i 2 + r 2 * i 1 )
if v 1 > v 2 { return v 1 ; } # return v 2 ;
sort . Ints ( candidates ) # # res := [][] int {} # solution := [] int {} # cs 2 ( candidates , solution , target , & res ) # # return res
m := map [ int ] struct {}{} # for i , f := range fronts { # if f == backs [ i ] { # m [ f ] = struct {}{} # } # } # res := 2 0 0 1 # for i , f := range fronts { # if _ , ok := m [ f ]; ! ok && res > f { # res = f # } # if _ , ok := m [ backs [ i ]]; ! ok && res > backs [ i ] { # res = backs [ i ] # } # } # if res == 2 0 0 1 { # return 0 # } # return res
if root == nil { # return 0 # } # if root . Left == nil && root . Right == nil { # return 1 # } # left := maxDepth ( root . Left ) # right := maxDepth ( root . Right ) # if left > right { # return left + 1 # } # return right + 1
n := len ( grid ) # # maxRow := make ([] int , n ) # maxCol := make ([] int , n ) # # for i := 0 ; i < n ; i ++ { # for j := 0 ; j < n ; j ++ { # maxRow [ i ] = max ( maxRow [ i ], grid [ i ][ j ]) # maxCol [ j ] = max ( maxCol [ j ], grid [ i ][ j ]) # } # } # # res := 0 # for i := 0 ; i < n ; i ++ { # for j := 0 ; j < n ; j ++ { # g := grid [ i ][ j ] # res += max ( g , min ( maxRow [ i ], maxCol [ j ])) - g # } # } # # return res
cases := [] struct { # name string # inputs [] int # expect bool # }{ # {" STR ", [] int { 4 , 2 , 3 }, true }, # {" STR ", [] int { 4 , 2 , 1 }, false }, # {" STR ", [] int { 1 , 2 , 5 , 4 }, true }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
for i , v := range nums { # if target <= v { # return i # } # } # return len ( nums )
n := len ( pairs ) # sort . Slice ( pairs , func ( i , j int ) bool { # if pairs [ i ][ 1 ] == pairs [ j ][ 1 ] { # return pairs [ i ][ 0 ] > pairs [ j ][ 0 ] # } # return pairs [ i ][ 1 ] < pairs [ j ][ 1 ] # }) # # res := 1 # b := pairs [ 0 ][ 1 ] # for i := 1 ; i < n ; i ++ { # c := pairs [ i ][ 0 ] # if b < c { # res ++ # b = pairs [ i ][ 1 ] # } # } # return res
if emitter . buffer_pos + 5 >= len ( emitter . buffer ) { # return yaml_emitter_flush ( emitter ) # } # return true
res := make ([] int , 0 , k ) # rec := make ( map [ int ] int , len ( nums )) # for _ , n := range nums { # rec [ n ]++ # } # counts := make ([] int , 0 , len ( rec )) # for _ , c := range rec { # counts = append ( counts , c ) # } # sort . Ints ( counts ) # min := counts [ len ( counts )- k ] # # for n , c := range rec { # if c >= min { # res = append ( res , n ) # } # } # # return res
var length int # index := make ( map [ byte ] int ) # for i , j := 0 , 0 ; j < len ( s ); j ++ { # if index [ s [ j ]] > i { # i = index [ s [ j ]] # } # if j - i + 1 > length { # length = j - i + 1 # } # index [ s [ j ]] = j + 1 # } # return length
if n <= 1 { # return 1 # } # # dp := make ([] int , n + 1 ) # dp [ 0 ], dp [ 1 ] = 1 , 1 # # for i := 2 ; i <= n ; i ++ { # num := 0 # for j := 0 ; j <= i - 1 ; j ++ { # num += dp [ j ] * dp [ i - 1 - j ] # } # # dp [ i ] = num # } # # return dp [ n ]
return ListQueue [ 0 ]
ext := filepath . Ext ( infile ) # outfile := strings . TrimSuffix ( infile , ext ) + " STR " + ext # return outfile , ImageFile 2 ( outfile , infile )
var scale float 6 4 = 1 # var sum float 6 4 # px := x # # for i := 0 ; i < p . n ; i ++ { # val := p . noise 1 ( px ) # sum += val / scale # scale *= p . alpha # px *= p . beta # } # return sum
t . Parallel () # for _ , tc := range testcases { # if result := NumberOfDecodings ( tc . input ); result != tc . expected { # t . Errorf (" STR ", tc . input , tc . expected , result ) # } # }
result := 0 # if len ( prices ) == 0 { # return result # } # # min := prices [ 0 ] # for i := 1 ; i < len ( prices ); i ++ { # if prev := prices [ i - 1 ]; prices [ i ] <= prev { # result += prev - min # min = prices [ i ] # } else if i == len ( prices )- 1 { # result += prices [ i ] - min # } # } # # return result
l := len ( s ) # ans , head := make ([] byte , l ), l - 1 # for i := l - 1 ; i >= 0 ; i -- { # if s [ i ] == '#' { # ans [ head ] = ' a ' + ( s [ i - 1 ] - ' 1 ') + ( s [ i - 2 ]-' 0 ')* 1 0 # i -= 2 # } else { # ans [ head ] = ' a ' + ( s [ i ] - ' 1 ') # } # head -- # } # return string ( ans [ head + 1 :])
n := 0 # for i := 0 ; i < len ( s ); i ++ { # if s [ i ] == c { # n ++ # } # } # return n
size := len ( A ) # u := newUnion ( size ) # # rec := make ( map [ int ] int , size * 2 ) # # for i := 0 ; i < size ; i ++ { # a := A [ i ] # for f := 2 ; f * f <= a ; f ++ { # if a % f != 0 { # continue # } # if j , ok := rec [ f ]; ok { # u . union ( i , j ) # } else { # rec [ f ] = i # } # d := a / f # if j , ok := rec [ d ]; ok { # u . union ( i , j ) # } else { # rec [ d ] = i # } # } # if j , ok := rec [ a ]; ok { # u . union ( i , j ) # } else { # rec [ a ] = i # } # } # # return u . max
if len ( points ) < 3 { # return len ( points ) # } # var max int # for i := range points { # verticalNum := 0 # equalNum := 0 # m := map [ float 6 4 ] int {} # for j := range points { # if i == j { # continue # } # if points [ i ]. X == points [ j ]. X && points [ i ]. Y == points [ j ]. Y { # equalNum ++ # } else if points [ i ]. X == points [ j ]. X { # verticalNum ++ # } else { # ratio := float 6 4 ( points [ i ]. Y - points [ j ]. Y ) / float 6 4 ( points [ i ]. X - points [ j ]. X ) # m [ ratio ]++ # } # } # if verticalNum + equalNum > max { # max = verticalNum + equalNum # } # for k := range m { # if m [ k ]+ equalNum > max { # max = m [ k ] + equalNum # } # } # } # return max + 1
if e := stack . list . Back (); e != nil { # stack . list . Remove ( e ) # return e . Value # } # # return nil
t . Parallel () # for tcid , tc := range testcases { # if result := PartitionSinglyLL ( tc . head , tc . k ); ! equal ( result , tc . expected ) { # log . Println (" STR ") # printLL ( tc . expected ) # log . Println (" STR ") # printLL ( result ) # t . Errorf (" STR ", tcid ) # } # }
total := 0 # counts := make ([] int , len ( w )) # for i := range w { # total += w [ i ] # counts [ i ] = total # } # # return Solution { # counts : counts , # total : total , # }
defer printStack () # f ( 3 )
t . Parallel () # # for _ , tc := range testcases { # if maxProfit := MaxProfit ( tc . prices , tc . k ); maxProfit != tc . maxProfit { # t . Errorf (" STR ", tc . maxProfit , maxProfit ) # } # }
var str string = "" # dumpTreeToStringHelper ( tree , & str ) # return str
for i := 1 ; i <= len ( s )/ 2 ; i ++ { # if isLeadingZero ( s [: i ]) { # break # } # for j := i + 1 ; max ( i , j - i ) <= len ( s )- j ; j ++ { # if isLeadingZero ( s [ i : j ]) { # break # } # a , _ := strconv . Atoi ( s [: i ]) # b , _ := strconv . Atoi ( s [ i : j ]) # res := make ([] int , 0 , len ( s )) # res = append ( res , a , b ) # if find ( a , b , s [ j :], & res ) { # return res # } # } # } # return nil
t . Parallel () # for _ , tc := range testcases { # if result := PopcntD ( tc . num ); ! reflect . DeepEqual ( result , tc . setBits ) { # t . Errorf (" STR ", tc . setBits , result ) # } # }
if n <= 2 { # return 1 # } # return fib ( n - 1 ) + fib ( n - 2 )
fmt . Printf (" STR ", e . FirstName , e . LastName )
this . mutex . Lock () # defer this . mutex . Unlock () # # for i , q := range this . queues { # q . Clear () # this . waiting [ i ] = 0 # } # this . top = 0 # this . total = 0
m := len ( books ) # dp := make ([] int , m + 1 ) # # for i := 1 ; i <= m ; i ++ { # dp [ i ] = 1 0 0 0 0 0 0 # k := 1 # w , h := books [ i - k ][ 0 ], books [ i - k ][ 1 ] # for w <= width { # dp [ i ] = min ( dp [ i ], dp [ i - k ]+ h ) # k ++ # if i - k < 0 { # break # } # w += books [ i - k ][ 0 ] # h = max ( h , books [ i - k ][ 1 ]) # } # } # # return dp [ m ]
size := len ( a ) # res := 0 # # # for k := 2 ; k < size && k < size - res + 2 ; k ++ { # l , r := 0 , k - 1 # # for l < r { # s := a [ l ] + a [ r ] # # if s < a [ k ] { # l ++ # continue # } else if a [ k ] < s { # r -- # continue # } # # count := 3 # i , j := r , k # for { # next := a [ i ] + a [ j ] # i , j = j , j + sort . SearchInts ( a [ j :], next ) # if j == size || a [ j ] != next { # break # } # count ++ # } # # res = max ( res , count ) # l ++ # r -- # } # # } # # return res
ans = 0 # left = make ( map [ int ] int ) # dfs ( root , 0 , 0 ) # return ans
res := 0 # for i := 2 ; i <= N ; i ++ { # if valid ( i ) { # res ++ # } # } # return res
p . Location = newLocation #
m := map [ string ] int {} # for i := 0 ; i <= len ( s )- 1 0 ; i ++ { # sub := s [ i : i + 1 0 ] # m [ sub ]++ # } # res := [] string {} # for sub , count := range m { # if count > 1 { # res = append ( res , sub ) # } # } # return res
var one , two , result int # for i , val := range nums { # switch { # case i == 0 : # result = val # case i == 1 : # result = max ( result , val ) # default : # result = max ( one , val + two ) # } # two = one # one = result # } # return result
count := make ( map [ int ] int ) # for _ , num := range nums { # if _ , ok := count [ num ]; ! ok { # count [ num ] = 1 # } else { # count [ num ]++ # } # } # # nums_ := make ( Nums , 0 ) # # for num , cnt := range count { # nums_ = append ( nums_ , Num { Val : num , Count : cnt }) # } # heap . Init (& nums_ ) # var res [] int # for i := 0 ; i < k ; i ++ { # num := heap . Pop (& nums_ ).( Num ) # res = append ( res , num . Val ) # } # return res
resultMap := map [ string ] int 6 4 {} # for i := 0 ; i < len ( cpdomains ); i ++ { # numDomain := strings . Split ( cpdomains [ i ], " STR ") # num , _ := strconv . ParseInt ( numDomain [ 0 ], 1 0 , 6 4 ) # resultMap [ numDomain [ 1 ]] += num # # for j := len ( cpdomains [ i ]) - 1 ; j >= 0 ; j -- { # if cpdomains [ i ][ j ] == '.' { # subdomain := cpdomains [ i ][ j + 1 :] # resultMap [ subdomain ] += num # } # } # } # # res := [] string {} # for k , v := range resultMap { # str := fmt . Sprint ( v ) + " STR " + k # res = append ( res , str ) # } # return res
var tests = [] struct { # num int # perfect bool # }{ # {- 1 , false }, # { 0 , false }, # { 1 , false }, # { 3 , false }, # { 6 , true }, # { 2 8 , true }, # { 4 9 6 , true }, # { 8 1 2 8 , true }, # { 3 3 5 5 0 3 3 6 , true }, # } # # for _ , tt := range tests { # perfect := checkPerfectNumber ( tt . num ) # if perfect != tt . perfect { # t . Errorf (" STR ", tt . num , perfect , tt . perfect ) # } # }
var ( # lenA = len ( a ) # lenB = len ( b ) # carry int # res = " STR " # ) # for lenA > 0 && lenB > 0 { # tmp := int ( a [ lenA - 1 ]-' 0 ') + int ( b [ lenB - 1 ]-' 0 ') + carry # res = strconv . Itoa ( tmp % 2 ) + res # carry = tmp / 2 # lenA -- # lenB -- # } # # if lenA == 0 { # for lenB > 0 { # tmp := int ( b [ lenB - 1 ]-' 0 ') + carry # res = strconv . Itoa ( tmp % 2 ) + res # carry = tmp / 2 # lenB -- # } # } # # if lenB == 0 { # for lenA > 0 { # tmp := int ( a [ lenA - 1 ]-' 0 ') + carry # res = strconv . Itoa ( tmp % 2 ) + res # carry = tmp / 2 # lenA -- # } # } # # if carry == 1 { # res = strconv . Itoa ( carry ) + res # } # return res
var code int # # exitFunc = func ( c int ) { # code = c # } # # func () { # defer Recover () # Return ( 8 2 3 5 ) # }() # # if code != 8 2 3 5 { # t . Errorf (" STR ", code , 8 2 3 5 ) # }
g 1 := [] int { 1 , 2 , 3 } # s 1 := [] int { 1 , 1 } # # fmt . Println ( findContentChildren ( g 1 , s 1 )) # # g 2 := [] int { 1 , 2 } # s 2 := [] int { 1 , 2 , 3 } # fmt . Println ( findContentChildren ( g 2 , s 2 ))
slash := strings . LastIndex ( s , " STR ") # s = s [ slash + 1 :] # if dot := strings . LastIndex ( s , " STR "); dot >= 0 { # s = s [: dot ] # } # return s
type A struct { # Name string # } # a := A { Name : " STR "} # # type B struct { # A ` structs :" STR "` # C int # } # b := & B { C : 1 2 3 } # b . A = a # # m := Map ( b ) # # _ , ok := m [" STR "].( map [ string ] interface {}) # if ok { # t . Error (" STR ") # } # # expectedMap := map [ string ] interface {}{" STR ": " STR ", " STR ": 1 2 3 } # if ! reflect . DeepEqual ( m , expectedMap ) { # t . Errorf (" STR ", expectedMap , m ) # } #
memo . mu . Lock () # e := memo . cache [ key ] # if e == nil { # e = & entry { ready : make ( chan struct {})} # memo . cache [ key ] = e # memo . mu . Unlock () # # e . res . value , e . res . err = memo . f ( key ) # # close ( e . ready ) # } else { # memo . mu . Unlock () # # <- e . ready # } # return e . res . value , e . res . err
var tests = [] struct { # n int # cnt int # }{ # { 4 , 2 }, # } # # for _ , tt := range tests { # cnt := totalNQueens ( tt . n ) # if reflect . DeepEqual ( cnt , tt . cnt ) == false { # t . Errorf (" STR ", tt . n , cnt , tt . cnt ) # } # }
if len ( values ) == 0 { # return 0 # } # for _ , coin := range values { # total += coin # } # return
head := createSinglyLinkedList ([] int { 1 , 2 , 6 , 3 , 4 , 5 , 6 }) # val := 6 # expected := createSinglyLinkedList ([] int { 1 , 2 , 3 , 4 , 5 }) # # if res := removeElements ( head , val ); ! reflect . DeepEqual ( res , expected ) { # t . Errorf (" STR ", expected , res ) # }
dictMap := make ( map [ string ] byte ) # # for i := 0 ; i < len ( words ); i ++ { # if _ , ok := dictMap [ words [ i ]]; ! ok { # dictMap [ words [ i ]] = byte ( 1 ) # } # } # # var wq wordQueue # dist := 2 # # addNextWords ( beginWord , dictMap , & wq ) # for ! wq . empty () { # wqLen := wq . size () # for i := 0 ; i < wqLen ; i ++ { # word := wq . popNext () # if word == endWord { # return dist # } # # addNextWords ( word , dictMap , & wq ) # } # dist ++ # } # # return 0
return a + t *( b - a )
return new ( scheduler ). init ( tasks , timeout )
ans = math . MinInt 3 2 # if root == nil { # return 0 # } # if root . Left == nil && root . Right == nil { # return root . Val # } # maxPath ( root ) # return ans
el := l . Front () # l . Remove ( el ) # return el . Value
missing := len ( nums ) # for i , num := range nums { # missing ^= i ^ num # } # return missing
var tests = [] struct { # before [] int # k int # after * ListNode # }{ # {[] int { 1 , 2 , 3 , 4 , 5 }, 2 , newList ( 4 , 5 , 1 , 2 , 3 )}, # {[] int { 0 , 1 , 2 }, 4 , newList ( 2 , 0 , 1 )}, # {[] int { 0 , 1 , 2 }, 0 , newList ( 0 , 1 , 2 )}, # {[] int {}, 0 , newList ()}, # } # # for _ , tt := range tests { # after := rotateRight ( newList ( tt . before ...), tt . k ) # if reflect . DeepEqual ( after , tt . after ) == false { # t . Errorf (" STR ", newList ( tt . before ...), tt . k , after , tt . after ) # } # }
sum := 0 # for _ , v := range nums { # sum += v # } # if sum % 2 == 1 { # return false # } # dp := make ([] bool , sum + 1 ) # for k := range dp { # dp [ k ] = false # } # dp [ 0 ] = true # for _ , v := range nums { # for i := sum ; i >= 0 ; i -- { # if dp [ i ] { # dp [ i + v ] = true # } # } # if dp [ sum / 2 ] { # return true # } # } # return false
for cur := t . Root ().(* gbtElement ); ! t . IsNil ( cur ); { # if cur . Key == key { # return cur # } else if key < cur . Key { # cur = cur . Left # } else { # cur = cur . Right # } # } # return t . NilNode
if len ( haystack ) < len ( needle ) { # return - 1 # } # index , i , j := 0 , 0 , 0 # for i < len ( haystack ) && j < len ( needle ) { # if haystack [ i ] == needle [ j ] { # i ++ # j ++ # } else { # index ++ # i = index # j = 0 # } # } # # if j == len ( needle ) { # return index # } # return - 1
m := len ( from ) # n := len ( to ) # # dp := make ([][] int , m + 1 ) # for i := range dp { # dp [ i ] = make ([] int , n + 1 ) # } # # for i := 1 ; i <= m ; i ++ { # dp [ i ][ 0 ] = i # } # # for j := 1 ; j <= n ; j ++ { # dp [ 0 ][ j ] = j # } # # for i := 1 ; i <= m ; i ++ { # for j := 1 ; j <= n ; j ++ { # dp [ i ][ j ] = 1 + min ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]) # # replace := 1 # if from [ i - 1 ] == to [ j - 1 ] { # replace = 0 # } # # dp [ i ][ j ] = min ( dp [ i ][ j ], dp [ i - 1 ][ j - 1 ]+ replace ) # } # } # # return dp [ m ][ n ]
var shift uint 8 # # var b byte # var rawResult uint 6 4 # for { # b , err = r . ReadByte () # if err != nil { # return 0 , err # } # rawResult |= uint 6 4 ( b & 0 x 7 f ) << shift # shift += 7 # if b & 0 x 8 0 == 0 { # break # } # } # # if shift < 6 4 && b & 0 x 4 0 != 0 { # rawResult |= ^ uint 6 4 ( 0 ) << shift # } # result = int 6 4 ( rawResult ) # # return
t . Parallel () # for _ , tc := range testcases { # if skyline := CreateSkyline ( tc . buildings ); ! reflect . DeepEqual ( skyline , tc . skyline ) { # t . Errorf (" STR ", tc . skyline , skyline ) # } # }
if ! lq . Empty () { # val := lq . queue . Back (). Value # return val , nil # } # # return " STR "
daemon . SysProcAttr = & syscall . SysProcAttr { # Setpgid : true , # Pgid : 0 , # }
t . Parallel () # for _ , tc := range testcases { # if result := AllValidStepWords ( tc . dict , tc . input ); ! reflect . DeepEqual ( result , tc . validStepWords ) { # t . Errorf (" STR ", tc . validStepWords , result ) # } # }
count , _ := countUnivalSubtrees ( root ) # return count
dp := make ([] int , target + 1 ) # dp [ 0 ] = 1 # for i := 1 ; i <= target ; i ++ { # for _ , num := range nums { # if i - num >= 0 { # dp [ i ] += dp [ i - num ] # } # } # } # return dp [ target ]
ans , carry , l := make ([] int , 0 ), 0 , len ( A )- 1 # for carry > 0 || K > 0 || l >= 0 { # x := K % 1 0 + carry # if l >= 0 { # x , l = x + A [ l ], l - 1 # } # carry , K = x / 1 0 , K / 1 0 # ans = append ([] int { x % 1 0 }, ans ...) # } # return ans
err := notFoundErrorHappens () # if errors . Is ( err , ErrNotFound ) { # fmt . Println ( err ) # } # err = errors . Unwrap ( err ) # fmt . Println ( err ) # # err = NotFoundError { # Name : " STR ", # Err : err , # } # err = fileNotFoundError () # var e NotFoundError # if errors . As ( err , & e ) { # fmt . Println ( e ) # }
p := printer { width : margin } # if err := pretty (& p , reflect . ValueOf ( v )); err != nil { # return nil , err # } # return p . Bytes (), nil
random := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # array := make ([] int , random . Intn ( 1 0 0 - 1 0 )+ 1 0 ) # for i := range array { # array [ i ] = random . Intn ( 1 0 0 ) # } # SortArray ( array ) # for _ , value := range array { # result := LinearSearch ( array , value ) # if result == - 1 { # t . Fail () # } # }
if len ( curr ) == len ( nums ) { # temp := make ([] int , len ( curr )) # copy ( temp , curr ) # ans = append ( ans , temp ) # return # } # # for idx , num := range nums { # if ! visit [ idx ] { # curr = append ( curr , num ) # visit [ idx ] = true # # dfs ( nums , curr ) # # visit [ idx ] = false # curr = curr [: len ( curr )- 1 ] # } # }
qs := [] question 8 9 { # # { # para 8 9 { 2 }, # ans 8 9 {[] int { 0 , 1 , 3 , 2 }}, # }, # # { # para 8 9 { 0 }, # ans 8 9 {[] int { 0 }}, # }, # # { # para 8 9 { 3 }, # ans 8 9 {[] int { 0 , 1 , 3 , 2 , 6 , 7 , 5 , 4 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 9 , q . para 8 9 # fmt . Printf (" STR ", p , grayCode ( p . one )) # } # fmt . Printf (" STR ")
m , res := map [ string ] int {}, [] string {} # for _ , s := range [] string { A , B } { # for _ , word := range strings . Split ( s , " STR ") { # m [ word ]++ # } # } # for key := range m { # if m [ key ] == 1 { # res = append ( res , key ) # } # } # return res
tests := [...] testType { # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := toHexspeak ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
data := & Node { data : i } # if list . rear != nil { # data . next = list . rear # } # list . rear = data
size := len ( A ) # indexs := make ([] int , 0 , size ) # isUsed := make ([] bool , size ) # suffixes := getSuffixes ( A ) # res := make ([] int , size ) # minLen := 2 4 1 # for i := 0 ; i < size ; i ++ { # isUsed [ i ] = true # greedy ( len ( A [ i ]), & minLen , append ( indexs , i ), res , A , isUsed , suffixes ) # isUsed [ i ] = false # } # return connect ( A , res , suffixes )
romanMap := [][] string { # [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # [] string {" STR ", " STR ", " STR ", " STR "}, # } # digits , tmp := 0 , num # var ret string # for tmp > 0 { # remain := tmp % 1 0 # ret = romanMap [ digits ][ remain ] + ret # tmp = tmp / 1 0 # digits ++ # } # return ret
now , current , ans := 0 , " STR ", " STR " # for _ , char := range S { # if string ( char ) == " STR " { # now ++ # } else if string ( char ) == " STR " { # now -- # } # current += string ( char ) # if now == 0 { # ans += current [ 1 : len ( current )- 1 ] # current = " STR " # } # } # return ans
var numMap = map [ int ] int {} # for i := 0 ; i < len ( numbers ); i ++ { # numMap [ numbers [ i ]] = i # } # # for i := 0 ; i < len ( numbers ); i ++ { # if numMap [ target - numbers [ i ]] > 0 && numMap [ target - numbers [ i ]] != i { # return [] int { i + 1 , numMap [ target - numbers [ i ]] + 1 } # } # } # return [] int {}
start := time . Date ( 1 9 0 1 , time . January , 1 , 0 , 0 , 0 , 0 , time . UTC ) # end := time . Date ( 2 0 0 1 , time . January , 1 , 0 , 0 , 0 , 0 , time . UTC ) # day , _ := time . ParseDuration (" STR ") # sundays := 0 # # for today := start ; today . Before ( end ); today = today . Add ( day ) { # if today . Day () == 1 && today . Weekday () == time . Sunday { # sundays ++ # } # } # # fmt . Println ( sundays )
c := NewCircularBuffer ( 1 0 ) # # evicted := 0 # c . Evict = func ( v interface {}) { # if v .( int ) != evicted { # t . Error ( v ) # } # evicted += 1 # } # # for i := 0 ; i < 1 8 ; i ++ { # v := c . NBPush ( i ) # if v != nil { # t . Error ( v ) # } # } # # for i := 9 ; i < 1 8 ; i ++ { # v := c . Get ().( int ) # if i != v { # t . Error ( v ) # } # } # # if evicted != 9 { # t . Error ( evicted ) # } # # if c . verifyIsEmpty () != true { # t . Error (" STR ") # }
left , right := 0 , len ( nums )- 1 # # for left <= right { # mid := left + ( right - left )/ 2 # if nums [ mid ] == target { # right = mid - 1 # } else if nums [ mid ] < target { # left = mid + 1 # # } else if nums [ mid ] > target { # right = mid - 1 # } # } # if nums [ left ] != target || left > len ( nums ) { # return - 1 # } # return left
if head == nil { # return nil # } # lower , bigger := & ListNode {}, & ListNode {} # ptr 1 , ptr 2 := lower , bigger # for head != nil { # if head . Val < x { # ptr 1 . Next = head # ptr 1 = ptr 1 . Next # } else { # ptr 2 . Next = head # ptr 2 = ptr 2 . Next # } # head = head . Next # } # ptr 2 . Next = nil # ptr 1 . Next = bigger . Next # return lower . Next
size := len ( A ) # # swap := make ([] int , size + 1 ) # flag := 1 # # res := 0 # for i := 0 ; i < size ; i ++ { # flag ^= swap [ i ] # if A [ i ] == flag { # continue # } # if i + K > size { # return - 1 # } # res ++ # flag ^= 1 # swap [ i + K ] = 1 # } # # return res
delay := d + time . Duration ( rand . NormFloat 6 4 ()* float 6 4 ( stddev )) # time . Sleep ( delay )
dp := make ([] int , amount + 1 ) # dp [ 0 ] = 1 # # for _ , coin := range coins { # for i := coin ; i <= amount ; i ++ { # dp [ i ] += dp [ i - coin ] # } # } # # return dp [ amount ]
http . HandleFunc (" STR ", handler ) # log . Fatal ( http . ListenAndServe (" STR ", nil ))
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 7 , 1 , 5 , 3 , 6 , 4 }, 5 }, # {" STR ", [] int { 1 , 2 , 3 , 4 , 5 }, 4 }, # {" STR ", [] int { 7 , 6 , 4 , 3 , 1 }, 0 }, # } # # for i , c := range cases { # t . Run ( c . name + strconv . Itoa ( i ), func ( t * testing . T ) { # got := maxProfit 1 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if len ( nums ) < 2 { # return nums # } # # sort . Ints ( nums ) # # var results [] int # # last := nums [ 0 ] # count := 1 # # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] != last && count == 1 { # results = append ( results , nums [ i - 1 ]) # last = nums [ i ] # count = 0 # } else if nums [ i ] != last { # last = nums [ i ] # count = 0 # } # count ++ # } # # return results
if len ( ransomNote ) == 0 && len ( magazine ) == 0 { # return true # } # if len ( magazine ) == 0 { # return false # } # if len ( ransomNote ) == 0 { # return true # } # # dict 1 := make ( map [ rune ] int , 0 ) # for _ , v := range ransomNote { # dict 1 [ v ]++ # } # # dict 2 := make ( map [ rune ] int , 0 ) # for _ , v := range magazine { # dict 2 [ v ]++ # } # # for k 1 , v 1 := range dict 1 { # if v 2 , ok := dict 2 [ k 1 ]; ! ok || v 2 < v 1 { # return false # } # } # return true
return strings . ReplaceAll ( address , " STR ", " STR ")
var maxK , maxV = - 1 , 0 # for k , v := range nums { # if maxV <= v { # maxK = k # maxV = v # } # } # # if maxK == - 1 { # return nil # } # # return & TreeNode { # Val : maxV , # Left : constructMaximumBinaryTree ( nums [: maxK ]), # Right : constructMaximumBinaryTree ( nums [ maxK + 1 :]), # }
t . Parallel () # for _ , tc := range testcases { # var s Stack # for _ , v := range tc . input { # s . Push ( v ) # } # InterleaveStack ( s ) # for i := range tc . expected { # v := tc . expected [ len ( tc . expected )- 1 - i ] # if result := s . Pop (); result != v { # t . Errorf (" STR ", v , result ) # } # } # }
return ( points [ 0 ][ 0 ]- points [ 1 ][ 0 ])*( points [ 0 ][ 1 ]- points [ 2 ][ 1 ]) != ( points [ 0 ][ 0 ]- points [ 2 ][ 0 ])*( points [ 0 ][ 1 ]- points [ 1 ][ 1 ])
node := head # for node != nil { # next := node . Next # for next != nil && next . Val == node . Val { # next = next . Next # } # # node . Next = next # node = next # } # # return head
x , y := " STR ", " STR " # fmt . Println (" STR ", x , y ) # # x , y = Swap ( x , y ) # fmt . Println (" STR ", x , y )
var i , j , k , ki , ij int # result := 1 . 0 # for i = 1 ; i < 1 0 ; i ++ { # for j = 1 ; j < i ; j ++ { # for k = 1 ; k < j ; k ++ { # ki = 1 0 * k + i # ij = 1 0 * i + j # if ki * j == ij * k { # result *= float 6 4 ( ij ) / float 6 4 ( ki ) # } # } # } # } # println ( int ( result ))
n := len ( nums ) # # dp := make ([][] int , n ) # for i := range dp { # dp [ i ] = make ([] int , n ) # dp [ i ][ i ] = nums [ i ] # } # # for Len := 2 ; Len <= n ; Len ++ { # for i := 0 ; i <= n - Len ; i ++ { # j := i + Len - 1 # # dp [ i ][ j ] = max ( nums [ i ]- dp [ i + 1 ][ j ], nums [ j ]- dp [ i ][ j - 1 ]) # } # } # # return dp [ 0 ][ n - 1 ] >= 0
return maxWeightPathTriangleHelper ( tri , 0 , 0 )
n := len ( prices ) # if 0 == n || 1 == n { # return 0 # } # # var ( # res int # minPrice = prices [ 0 ] # ) # # for _ , price := range prices { # if price - minPrice > res { # res = price - minPrice # } # if price < minPrice { # minPrice = price # } # } # return res
cases := [] struct { # name string # inputs [] int # expect [][] int # }{ # {" STR ", [] int { 1 , 1 , 2 }, [][] int { # { 1 , 1 , 2 }, # { 1 , 2 , 1 }, # { 1 , 1 , 2 }, # { 1 , 2 , 1 }, # { 2 , 1 , 1 }, # { 2 , 1 , 1 }, # }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := permute ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
slow , fast := head , head # for fast != nil && fast . Next != nil { # slow = slow . Next # fast = fast . Next . Next # } # return slow
left , right := 0 , len ( s )- 1 # # for left < right { # for left < right && ignore ( s [ left ]) { # left ++ # } # for left < right && ignore ( s [ right ]) { # right -- # } # # if lowerCase ( s [ left ]) != lowerCase ( s [ right ]) { # return false # } # left ++ # right -- # } # return true
if root == nil { # return 0 ; # } # left := helper ( root . Left , res ); # right := helper ( root . Right , res ); # * res = max (* res , root . Val , left + root . Val , root . Val + right , left + root . Val + right ); # return max ( left + root . Val , root . Val + right , root . Val );
input := bufio . NewScanner ( os . Stdin ) # for input . Scan () { # fmt . Println ( basename ( input . Text ())) # }
m := len ( matrix ) # if m == 0 { # return 0 # } # # n := len ( matrix [ 0 ]) # if n == 0 { # return 0 # } # # dp := make ([][] int , m ) # for i := 0 ; i < m ; i ++ { # dp [ i ] = make ([] int , n ) # } # # for j := 0 ; j < n ; j ++ { # dp [ 0 ][ j ] = int ( matrix [ 0 ][ j ] - " STR ") # # for i := 1 ; i < m ; i ++ { # if matrix [ i ][ j ] == " STR " { # dp [ i ][ j ] = dp [ i - 1 ][ j ] + 1 # } # } # } # # max := 0 # for i := 0 ; i < m ; i ++ { # area := largestRectangleArea ( dp [ i ]) # if area > max { # max = area # } # } # # return max
return compute ( S ) == compute ( T )
var x , y , xx , yy , xy float 6 4 # # for i := 0 ; i < maxIter ; i ++ { # xx , yy , xy = x * x , y * y , x * y # if xx + yy > 4 { # return xx + yy , i # } # x = xx - yy + px # y = 2 * xy + py # } # # return xx + yy , maxIter
const max = 1 0 0 # var sumSquares , sum int # # for i := 0 ; i <= max ; i ++ { # sumSquares += i * i # sum += i # } # # fmt . Println ( sumSquares - sum * sum )
pairs := [...][ 2 ] int {{ 1 0 0 0 0 , 3 1 6 2 6 }} # for _ , pair := range pairs { # in , out := pair [ 0 ], pair [ 1 ] # if x := p 2 1 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # } # }
return fi . name
var index , indexOfMax int # length := len ( nums ) # # if length == 0 { # return - 1 # } # # for indexOfMax + 1 < length && nums [ indexOfMax ] < nums [ indexOfMax + 1 ] { # indexOfMax ++ # } # # low , high , median := 0 , length - 1 , 0 # for low <= high { # median = ( low + high ) / 2 # # index = median + indexOfMax + 1 # if index >= length { # index -= length # } # # switch { # case nums [ index ] > target : # high = median - 1 # case nums [ index ] < target : # low = median + 1 # default : # return index # } # } # # return - 1
if head == nil { # return nil # } # original := head # for original != nil { # clone := & RandomSinglyLL { Value : original . Value , Random : nil , Next : original . Next } # original . Next = clone # original = original . Next . Next # } # original = head # for original != nil { # if original . Random != nil { # original . Next . Random = original . Random . Next # } # original = original . Next . Next # } # result := head . Next # origPtr , copyPtr := head , head . Next # for origPtr != nil { # origPtr . Next = origPtr . Next . Next # if copyPtr . Next == nil { # break # } # origPtr = origPtr . Next # copyPtr . Next = copyPtr . Next . Next # copyPtr = copyPtr . Next # } # return result
hash := make ( map [ int ] int ) # max := - 1 # for i := 1 ; i <= n ; i ++ { # var d int # if i < 1 0 { # d = i # } else { # t := i # for t > 0 { # d += t % 1 0 # t /= 1 0 # } # } # hash [ d ]++ # if hash [ d ] > max { # max = hash [ d ] # } # } # ans := 0 # for _ , val := range hash { # if val == max { # ans ++ # } # } # return ans
return LFUCache { # m : make ( map [ int ]* entry , capacity ), # pq : make ( PQ , 0 , capacity ), # cap : capacity , # }
slow , fast := n , squares ( n ) # for slow != fast { # slow = squares ( slow ) # fast = squares ( squares ( fast )) # } # if slow == 1 { # return true # } # return false
t . Run (" STR ", func ( t * testing . T ) { # data := [] string { # " STR ", # " STR ", # " STR ", # } # got := longestCommonPrefix ( data ) # want := " STR " # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # }) # # t . Run (" STR ", func ( t * testing . T ) { # data := [] string { # " STR ", # " STR ", # " STR ", # } # got := longestCommonPrefix ( data ) # want := " STR " # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # })
events := make ([] lectureEvent , 0 , 2 * len ( lectures )) # for i := range lectures { # events = append ( events , lectureEvent { lectures [ i ]. start , true }) # events = append ( events , lectureEvent { lectures [ i ]. end , false }) # } # # sort . Slice ( events , func ( i , j int ) bool { # return events [ i ]. time < events [ j ]. time # }) # # var max , active int # # for i := range events { # if events [ i ]. starting { # active ++ # } else { # active -- # } # # if max < active { # max = active # } # } # # return max
count := [ 1 0 0 0 ] int {} # for _ , v := range answers { # count [ v ]++ # } # # res := 0 # # # for ans , c := range count { # if c == 0 { # continue # } # ans ++ # res += c / ans * ans # if c % ans > 0 { # res += ans # } # } # # return res
t . Parallel () # # for _ , tc := range testcases { # if result := CountAttackingBishopPairs ( tc . bishops ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
var inversions int # for i := range array { # for j := i + 1 ; j < len ( array ); j ++ { # if array [ i ] > array [ j ] { # inversions ++ # } # } # } # return inversions
if nil == head { # return nil # } # # head . Next = removeElements ( head . Next , val ) # # if head . Val == val { # return head . Next # } else { # return head # }
if m == n { # return head # } # dummy := new ( ListNode ) # head , dummy . Next = dummy , head # # for i := 0 ; i < m - 1 ; i ++ { # head = head . Next # } # var curr , prev * ListNode = head . Next , nil # for i := 0 ; i < n - m + 1 ; i ++ { # next := curr . Next # curr . Next = prev # prev = curr # curr = next # } # head . Next . Next = curr # head . Next = prev # # return dummy . Next
arr := randomSlice ( 0 , 2 0 , 1 0 ) # bst := newBstRecrusive () # for _ , v := range arr { # bst . Insert ( uint 3 2 ( v )) # } # min := int ( bst . Min ( bst . root ).(* bstElement ). Key ) # sort . Ints ( arr ) # if min != arr [ 0 ] { # t . Log ( fmt . Sprintf (" STR ", arr [ 0 ], min )) # t . Fail () # }
res := make ([] int , 0 , len ( asteroids )) # stack := make ([] int , 0 , len ( asteroids )) # # for _ , a := range asteroids { # if a > 0 { # stack = append ( stack , a ) # continue # } # # for len ( stack ) > 0 && stack [ len ( stack )- 1 ] <= - a { # last := stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # if last == - a { # a = 0 # break # } # } # # if len ( stack ) == 0 && a != 0 { # res = append ( res , a ) # continue # } # } # # res = append ( res , stack ...) # # return res
log . Println (" STR ") # img := image . NewRGBA ( image . Rect ( 0 , 0 , imgWidth , imgHeight )) # # log . Println (" STR ") # start := time . Now () # render ( img ) # end := time . Now () # # log . Println (" STR ", end . Sub ( start )) # # log . Println (" STR ") # f , err := os . Create (" STR ") # if err != nil { # panic ( err ) # } # err = png . Encode ( f , img ) # if err != nil { # panic ( err ) # } # log . Println (" STR ")
max := 0 # currentCnt := 0 # for i := 0 ; i < len ( nums ); i ++ { # if nums [ i ] == 1 { # currentCnt ++ # if currentCnt > max { # max = currentCnt # } # } else { # currentCnt = 0 # } # } # return max
return unsafe . Pointer ( x )
for i := 0 ; i < len ( a ) && i < len ( b ); i ++ { # switch { # case a [ 0 ] < b [ 0 ]: # return - 1 # case a [ 0 ] > b [ 0 ]: # return 1 # } # } # # switch { # case len ( a ) > len ( b ): # return 1 # case len ( a ) < len ( b ): # return - 1 # default : # return 0 # }
n := len ( cost ) # dp := make ([] int , n + 1 ) # # for i := 2 ; i <= n ; i ++ { # dp [ i ] = min ( dp [ i - 1 ]+ cost [ i - 1 ], dp [ i - 2 ]+ cost [ i - 2 ]) # } # # return dp [ n ]
tmp := 0 # arrLen := len ( arr ) # gap := arrLen # for gap > 1 { # gap = gap * 1 0 / 1 3 # # for i := 0 ; i + gap < arrLen ; i ++ { # if arr [ i ] > arr [ i + gap ] { # tmp = arr [ i ] # arr [ i ] = arr [ i + gap ] # arr [ i + gap ] = tmp # } # } # }
n := len ( s ) # dp := make ([][] int , n ) # for k := range dp { # dp [ k ] = make ([] int , n ) # } # for l := 1 ; l <= n ; l ++ { # for i := 0 ; i <= n - l ; i ++ { # j := i + l - 1 # if i == j { # dp [ i ][ j ] = 1 # continue # } # if s [ i ] == s [ j ] { # dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] + 2 # } else { # dp [ i ][ j ] = mymax ( dp [ i + 1 ][ j ], dp [ i ][ j - 1 ]) # } # } # } # return dp [ 0 ][ n - 1 ]
tests := [...] testType { # { # in : 4 , # want : false , # }, # { # in : 3 , # want : true , # }, # } # for _ , tt := range tests { # got := canWinNim ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
ans := make ([] string , 0 ) # if len ( S ) < 1 { # return [] string {" STR "} # } # return core ( ans , [] byte ( S ), 0 )
t . Parallel () # for _ , tc := range testcases { # if result := ClockwiseSpiral ( tc . matrix ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
qs := [] question 2 0 1 { # # { # para 2 0 1 { 5 , 7 }, # ans 2 0 1 { 4 }, # }, # # { # para 2 0 1 { 0 , 1 }, # ans 2 0 1 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 0 1 , q . para 2 0 1 # fmt . Printf (" STR ", p , rangeBitwiseAnd ( p . m , p . n )) # } # fmt . Printf (" STR ")
nums := [][] int {{ 0 , 0 }, { 0 , 1 }, { 1 , 0 }, { 0 , 2 }, { 2 , 0 }} # # fmt . Println ( largestTriangleArea ( nums ))
t . Parallel () # for _ , tc := range testcases { # if result := CountIntersectionsBrute ( tc . p , tc . q ); result != tc . intersections { # t . Errorf (" STR ", tc . intersections , result ) # } # }
ans = 0 # longestPath ( root ) # return ans
var x int # return func () int { # x ++ # return x * x # }
qs := [] question 4 9 6 { # # { # para 4 9 6 {[] int { 4 , 1 , 2 }, [] int { 1 , 3 , 4 , 2 }}, # ans 4 9 6 {[] int {- 1 , 3 , - 1 }}, # }, # # { # para 4 9 6 {[] int { 2 , 4 }, [] int { 1 , 2 , 3 , 4 }}, # ans 4 9 6 {[] int { 3 , - 1 }}, # }, # # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 9 6 , q . para 4 9 6 # fmt . Printf (" STR ", p , nextGreaterElement ( p . one , p . another )) # } # fmt . Printf (" STR ")
for j := 0 ; j < 4 ; j ++ { # defer deferred (" STR ", j ) # }
for _ , v := range factors { # if x % v == 0 { # return false # } # } # return true
if root . Left == nil && root . Right == nil { # return root # } # var left , right * BinaryTree # if root . Left != nil { # left = ConvertBinaryTreeToFull ( root . Left ) # } # if root . Right != nil { # right = ConvertBinaryTreeToFull ( root . Right ) # } # if left != nil && right != nil { # root . Left = left # root . Right = right # return root # } else if left != nil { # return left # } # return right
n := len ( A ) # i , j := 0 , n - 1 # for i + 1 < n && A [ i ] < A [ i + 1 ] { # i ++ # } # for j > 0 && A [ j - 1 ] > A [ j ] { # j -- # } # return i == j && i > 0 && j < n - 1
data := make ([] bool , n + 1 ) # # for i := 2 ; i < int ( math . Sqrt ( float 6 4 ( n )))+ 1 ; i ++ { # if ! data [ i ] { # for j := i * i ; j <= n ; j += i { # data [ j ] = true # } # } # } # # var results [] int # # for i := 2 ; i <= n ; i ++ { # if ! data [ i ] { # results = append ( results , i ) # } # } # # return results
const mod = 1 e 9 + 7 # dp := [ 5 0 ][ 5 0 ] int {} # # for k := 0 ; k < N ; k ++ { # pre := make ([] int , n ) # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # paths := 0 # # if i == 0 { # paths ++ # } else { # paths += pre [ j ] # } # # if j == 0 { # paths ++ # } else { # paths += pre [ j - 1 ] # } # # if i == m - 1 { # paths ++ # } else { # paths += dp [ i + 1 ][ j ] # } # # if j == n - 1 { # paths ++ # } else { # paths += dp [ i ][ j + 1 ] # } # # paths %= mod # pre [ j ] = dp [ i ][ j ] # dp [ i ][ j ] = paths # } # } # } # return dp [ i ][ j ]
check := make ([] bool , n ) # for i := 2 ; i * i < n ; i ++ { # if check [ i ] { # continue # } # for j := i ; i * j < n ; j ++ { # if ! check [ i * j ] { # check [ i * j ] = true # } # } # } # cnt := 0 # for i := 2 ; i < n ; i ++ { # if ! check [ i ] { # cnt ++ # } # } # return cnt
lparen := t . curPos # t . Next () # x , err := parseConstExpr ( t , precedenceLowest ) # if err != nil { # return nil , err # } # t . Next () # if t . curToken != token . RPAREN { # return nil , unexpectedToken ( t , token . RPAREN ) # } # expr := & ast . ParenExpr { # Lparen : lparen , # X : x , # Rparen : t . curPos , # } # return expr , nil
h , h 2 := newLinkedHeap (), newLinkedHeap () # testHeapUnion ( t , h , h 2 )
benchmark ( bb , 3 2 7 6 8 , 0 . 5 )
t . Parallel () # for tcid , tc := range testcases { # if result := InorderSuccessor ( tc . givenNode ); result != tc . inorderSuccessor { # t . Errorf (" STR ", tcid ) # } # }
qs := [] question 2 5 8 { # # { # para 2 5 8 { 3 8 }, # ans 2 5 8 { 2 }, # }, # # { # para 2 5 8 { 8 8 }, # ans 2 5 8 { 7 }, # }, # # { # para 2 5 8 { 9 6 }, # ans 2 5 8 { 6 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 5 8 , q . para 2 5 8 # fmt . Printf (" STR ", p , addDigits ( p . one )) # } # fmt . Printf (" STR ")
ns := makeNums ( intss ) # sort . Sort ( ns ) # # s := newStatus ( ns , len ( intss )) # s . check () # # return s . res
fmt . Println ( Lrint ( 5 . 0 1 )) # fmt . Println ( Lrint ( 4 . 9 9 )) # fmt . Println ( Lrint ( 4 . 5 0 )) # fmt . Println ( Lrint ( 5 . 5 0 )) # fmt . Println ( Lrint ( 5 . 4 9 9 9 9 9 9 9 9 9 9 9 9 9 9 )) # fmt . Println ( Lrint ( 5 . 4 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 )) # fmt . Println ( Lrint (- 1 . 4 ))
L := len ( a ) # # if a [ 0 ] < a [ L - 1 ] { # return a [ 0 ] # } # # i , j := 0 , L - 1 # for i < j { # if a [ i ] > a [ i + 1 ] { # return a [ i + 1 ] # } # # if a [ j - 1 ] > a [ j ] { # return a [ j ] # } # # i ++ # j -- # } # # return a [ i ]
return b . index == 0
if _ , ok := cache [ input ]; ok { # return cache [ input ] # } # # ans := [] int {} # # for i := 0 ; i < len ( input ); i ++ { # ch := input [ i ] # # if ch == " STR " || ch == " STR " || ch == " STR " { # left := input [: i ] # right := input [ i + 1 :] # # l := ways ( left , cache ) # r := ways ( right , cache ) # # for _ , a := range l { # for _ , b := range r { # ans = append ( ans , calculate ( a , b , rune ( ch ))) # } # } # } # } # # if len ( ans ) == 0 { # number , _ := strconv . Atoi ( input ) # ans = append ( ans , number ) # } # # cache [ input ] = ans # # return ans
board := buildBoard ( 5 ) # score , path := chessGame ( board , 0 , 3 ) # if score != 3 { # t . Log ( fmt . Sprintf (" STR ", score )) # printBoard ( board ) # t . Fail () # } # if ! reflect . DeepEqual ( path , [][] int {{ 0 , 0 }, { 1 , 0 }, { 2 , 1 }, { 3 , 2 }, { 4 , 3 }}) { # t . Log (" STR ") # printBoard ( board ) # t . Log ( path ) # t . Fail () # } #
tmp := strings . Split ( A , " STR ") # tmp = append ( tmp , strings . Split ( B , " STR ")...) # # tmp = append ( tmp , " STR ", " STR ") # sort . Strings ( tmp ) # # size := len ( tmp ) # # res := make ([] string , 0 , size ) # # for i := 1 ; i + 1 < size ; i ++ { # if tmp [ i - 1 ] != tmp [ i ] && tmp [ i ] != tmp [ i + 1 ] { # res = append ( res , tmp [ i ]) # } # } # # return res
return find ( node ) > - 1
file , err := os . Open ( filename ) # if err != nil { # return err # } # defer file . Close () # fileinfo , err := file . Stat () # hdr := & tar . Header { # ModTime : fileinfo . ModTime (), # Name : filename , # Size : fileinfo . Size (), # Mode : int 6 4 ( fileinfo . Mode (). Perm ()), # } # if err := tw . WriteHeader ( hdr ); err != nil { # return err # } # copied , err := io . Copy ( tw , file ) # if err != nil { # return err # } # if copied < fileinfo . Size () { # return fmt . Errorf (" STR ", filename , err ) # } # return nil
problems := GetProblemsInstance () # # res := [] string {} # time . Sleep ( time . Second ) # # for i , _ := range problems { # res = append ( res , problems [ i ]. PathName ) # } # return res
testRangeString () # testStringToRunes () # testRunesToString ([] rune { 9 7 , 9 8 , 9 9 , 2 5 2 , 1 6 2 , 8 3 6 4 , 6 6 3 7 6 , 1 7 6 , 1 2 0 }) # var _ = len ([] byte ( myString (" STR ")))
var t * Tree # var count int # for _ , v := range inputArr { # # t = insertLeft ( t , v , count ) # } # # count = 0 # for _ , v := range inputArr { # # if v == t . Value { # continue # } # # t = insertRight ( t , v , count ) # } # return t
out := 4 0 8 2 4 # if x := p 8 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # }
var tests = [] struct { # nums [] int # duplicate bool # }{ # {[] int { 1 , 2 , 3 , 1 }, true }, # {[] int { 1 , 2 , 3 , 4 }, false }, # {[] int { 1 , 1 , 1 , 3 , 3 , 4 , 3 , 2 , 4 , 2 }, true }, # } # # for _ , tt := range tests { # duplicate := containsDuplicate ( tt . nums ) # if duplicate != tt . duplicate { # t . Errorf (" STR ", tt . nums , duplicate , tt . duplicate ) # } # }
return i - 1 , j - 1
res := [][] int {} # if numRows == 0 { # return res # } # # res = append ( res , [] int { 1 }) # if numRows == 1 { # return res # } # # for i := 1 ; i < numRows ; i ++ { # res = append ( res , helper ( res [ i - 1 ])) # } # # return res
if ( r . Code < 3 0 0 || r . Code > 3 0 8 ) && r . Code != 2 0 1 { # panic ( fmt . Sprintf (" STR ", r . Code )) # } # http . Redirect ( w , r . Request , r . Location , r . Code ) # return nil
charCounts := make ( map [ rune ] int ) # for _ , c := range s { # charCounts [ c ] += 1 # } # # var counts [] int # countChars := make ( map [ int ][] rune ) # for c , count := range charCounts { # if chars , ok := countChars [ count ]; ok { # countChars [ count ] = append ( chars , c ) # } else { # countChars [ count ] = [] rune { c } # counts = append ( counts , count ) # } # } # # sort . Slice ( counts , func ( i , j int ) bool { # return counts [ i ] > counts [ j ] # }) # # var chars [] rune # for _ , count := range counts { # for _ , c := range countChars [ count ] { # i := count # for i > 0 { # chars = append ( chars , c ) # i -- # } # } # } # return string ( chars )
qs := [] question 9 1 8 { # # { # para 9 1 8 {[] int { 1 , - 2 , 3 , - 2 }}, # ans 9 1 8 { 3 }, # }, # # { # para 9 1 8 {[] int { 5 , - 3 , 5 }}, # ans 9 1 8 { 1 0 }, # }, # # { # para 9 1 8 {[] int { 3 , - 1 , 2 , - 1 }}, # ans 9 1 8 { 4 }, # }, # # { # para 9 1 8 {[] int { 3 , - 2 , 2 , - 3 }}, # ans 9 1 8 { 3 }, # }, # # { # para 9 1 8 {[] int {- 2 , - 3 , - 1 }}, # ans 9 1 8 {- 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 1 8 , q . para 9 1 8 # fmt . Printf (" STR ", p , maxSubarraySumCircular ( p . one )) # } # fmt . Printf (" STR ")
if n < 4 { # return n # } # # res := n # # for i := 1 ; i <= n ; i ++ { # tmp := i * i # if tmp > n { # break # } else { # res = min ( res , 1 + SmallestNumberOfPerfectSquaresSum ( n - tmp )) # } # } # # return res
c := make ( map [ string ] interface {}) # c [" STR "] = " STR " # c [" STR "] = " STR " # c [" STR "] = map [ string ] interface {}{ # " STR ": " STR ", # " STR ": " STR ", # } # # data , err := json . MarshalIndent ( c , " STR " ") # if err != nil { # log . Println (" STR ", err ) # return # } # # fmt . Println ( string ( data ))
var err error # # this . mutex . Lock () # defer this . mutex . Unlock () # # c := int 6 4 ( len ( p )) # if c == 0 { # return 0 , nil # } # # rotate := false # if this . maxSize > 0 && this . byteCount > this . maxSize - c { # rotate = true # } # now := time . Now () # if this . maxDuration > 0 && now . Sub ( this . startTime ) > this . maxDuration { # rotate = true # } # # if rotate { # err = this . rotate ( false ) # if err != nil { # return 0 , err # } # } # # n , err := this . currentFile . Write ( p ) # this . byteCount += int 6 4 ( n ) # return n , err
points := []* point { newPoint ( 0 , 6 ), newPoint ( 1 , 0 ), newPoint ( 2 , 3 ), # newPoint ( 5 , 4 ), newPoint ( 6 , 1 ), newPoint ( 7 , 5 ), newPoint ( 8 , 2 )} # expPath := []* line { newLine ( points [ 0 ], points [ 1 ]), newLine ( points [ 0 ], points [ 2 ]), newLine ( points [ 2 ], points [ 3 ]), # newLine ( points [ 1 ], points [ 4 ]), newLine ( points [ 3 ], points [ 5 ]), newLine ( points [ 4 ], points [ 6 ]), newLine ( points [ 5 ], points [ 6 ])} # for i := range expPath [ 1 :] { # expPath [ i + 1 ]. prevLine = expPath [ i ] # } # result , path := bitonicTSP ( points ) # if math . Abs ( result - 2 5 . 5 8 4 0 2 5 ) >= 0 . 0 0 0 1 { # t . Log ( fmt . Sprintf (" STR ", result )) # t . Fail () # } # if ! reflect . DeepEqual ( path , expPath ) { # t . Log (" STR ") # for _ , v := range path { # v . print () # } # t . Fail () # }
if depth == 0 && n == 0 { # return [] string { prefix } # } # var output [] string # if depth < n { # output = append ( output , dp ( prefix +" STR ", depth + 1 , n - 1 )...) # } # if depth > 0 { # output = append ( output , dp ( prefix +" STR ", depth - 1 , n - 1 )...) # } # return output
t . Parallel () # r := NewRandom () # for _ , tc := range testcases { # results := make ( map [ int ] int ) # const iterations = 1 0 0 0 # for i := 0 ; i < iterations ; i ++ { # results [ r . RandMissingNumbers ( tc . n , tc . l )]++ # } # for _ , v := range results { # delta := ( float 6 4 ( v ) / float 6 4 ( iterations )) - tc . distribution # if delta < 0 { # delta = - delta # } # if delta > 0 . 1 { # t . Errorf (" STR ", tc . distribution ) # } # } # }
if len ( S ) < 3 { # return false # } # stack := [] byte {} # for i := 0 ; i < len ( S ); i ++ { # if S [ i ] == ' a ' { # stack = append ( stack , S [ i ]) # } else if S [ i ] == ' b ' { # if len ( stack ) > 0 && stack [ len ( stack )- 1 ] == ' a ' { # stack = append ( stack , S [ i ]) # } else { # return false # } # } else { # if len ( stack ) > 1 && stack [ len ( stack )- 1 ] == ' b ' && stack [ len ( stack )- 2 ] == ' a ' { # stack = stack [: len ( stack )- 2 ] # } else { # return false # } # } # } # return len ( stack ) == 0
tests := [...] testType { # { # in : [] int { 0 , 1 , 0 , 3 , 1 2 }, # want : [] int { 1 , 3 , 1 2 , 0 , 0 }, # }, # { # in : [] int { 0 , 1 , 0 , 2 , 3 , 3 , 0 , 7 , 8 }, # want : [] int { 1 , 2 , 3 , 3 , 7 , 8 , 0 , 0 , 0 }, # }, # { # in : [] int { 1 , 2 , 3 , 4 , 5 }, # want : [] int { 1 , 2 , 3 , 4 , 5 }, # }, # } # # for _ , tt := range tests { # got := make ([] int , len ( tt . in )) # copy ( got , tt . in ) # moveZeroes ( got ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if len ( s ) < 1 { # return s # } # t := strings . Trim ( s , " STR ") # t = strings . ToLower ( t ) # res := [] rune ( t ) # res [ 0 ] = unicode . ToUpper ( res [ 0 ]) # return string ( res )
log . Println (" STR ") # s . searchers [" STR "] = google {}
t . Parallel () # for tcid , tc := range testcases { # if result := IsSoloBlackKingInCheck ( tc . board ); result != tc . inCheck { # t . Errorf (" STR ", tcid , tc . inCheck , result ) # } # }
if len ( nums ) <= 1 { # return true # } # found := false # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] < nums [ i - 1 ] { # if found { # return false # } else { # if i - 2 >= 0 && nums [ i ] < nums [ i - 2 ] { # nums [ i ] = nums [ i - 1 ] # } # found = true # } # } # } # return true
t . Parallel () # for _ , tc := range testcases { # if result := AllPathsToLeaves ( tc . head ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
qs := [] question 4 5 3 { # # { # para 4 5 3 {[] int { 4 , 3 , 2 , 7 , 8 , 2 , 3 , 1 }}, # ans 4 5 3 { 2 2 }, # }, # # { # para 4 5 3 {[] int { 1 , 2 , 3 }}, # ans 4 5 3 { 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 5 3 , q . para 4 5 3 # fmt . Printf (" STR ", p , minMoves ( p . one )) # } # fmt . Printf (" STR ")
random := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # array 1 := make ([] int , random . Intn ( 1 0 0 - 1 0 )+ 1 0 ) # for i := range array 1 { # array 1 [ i ] = random . Intn ( 1 0 0 ) # } # array 2 := make ( sort . IntSlice , len ( array 1 )) # copy ( array 2 , array 1 ) # CombSort ( array 1 ) # array 2 . Sort () # for i := range array 1 { # if array 1 [ i ] != array 2 [ i ] { # t . Fail () # } # }
if length == 0 { # return 0 # } # # q := - 1 # for i := 1 ; i <= length ; i ++ { # q = Max ( q , price [ i ]+ CutRodRec ( price , length - i )) # } # return q
m := make ( map [ int ] bool ) # for _ , v := range nums 1 { # m [ v ] = true # } # # ret := [] int {} # for _ , v := range nums 2 { # if val , ok := m [ v ]; val && ok { # ret = append ( ret , v ) # m [ v ] = false # } # } # return ret
sort . Ints ( nums ) # flagMap := make ( map [ string ] bool ) # var res [][] int # i := 0 # for i < len ( nums ) { # if i - 1 >= 0 && nums [ i ] == nums [ i - 1 ] { # i ++ # continue # } # p , q := 1 , len ( nums )- 1 # for p + i < q { # if nums [ i ]+ nums [ p + i ]+ nums [ q ] == 0 { # flag := strconv . Itoa ( nums [ i ]) + strconv . Itoa ( nums [ p + i ]) + strconv . Itoa ( nums [ q ]) # if _ , ok := flagMap [ flag ]; ! ok { # res = append ( res , [] int { nums [ i ], nums [ p + i ], nums [ q ]}) # } # flagMap [ flag ] = true # p ++ # q -- # } else if nums [ i ]+ nums [ p + i ]+ nums [ q ] > 0 { # q -- # } else if nums [ i ]+ nums [ p + i ]+ nums [ q ] < 9 { # p ++ # } # } # i ++ # } # return res
arr := [] int { 0 , 1 , 3 } # n := len ( arr ) # s := n * ( n + 1 ) / 2 # res := 0 # for _ , v := range arr { # res = res + v # } # fmt . Println ( s - res )
ptr := bitbandAddress ( uintptr ( unsafe . Pointer (& r . Reg )), bit ) # return (* BitRegister )( unsafe . Pointer ( ptr ))
return & hitCounter {}
l 1 := make ([] int , 0 ) # l 2 := make ([] int , 0 ) # # dfs ( root 1 , & l 1 ) # dfs ( root 2 , & l 2 ) # # return reflect . DeepEqual ( l 1 , l 2 )
for x := 0 ; x < 1 0 0 ; x ++ { # out <- x # } # close ( out )
h := intHeap ( nums [: k ]) # heap . Init (& h ) # # for i := k ; i < len ( nums ); i ++ { # if nums [ i ] > h . min () { # heap . Pop (& h ) # heap . Push (& h , nums [ i ]) # } # } # return h . min ()
var ret int # var s string # # s = " STR " # ret = 0 # if ret != lengthOfLastWord ( s ) { # t . Fatalf (" STR ", ret ) # } # # s = " STR " # ret = 5 # if ret != lengthOfLastWord ( s ) { # t . Fatalf (" STR ", ret ) # }
if len ( points ) == 0 { # return 0 # } # sort . Sort ( ByLen ( points )) # # res := 0 # end := - 1 << 3 1 - 1 # for _ , interval := range points { # if interval [ 0 ] > end { # res += 1 # end = interval [ 1 ] # } # } # return res
max 1 , max 2 , max 3 := math . MinInt 6 4 , math . MinInt 6 4 , math . MinInt 6 4 # for _ , num := range nums { # if num == max 1 || num == max 2 { # continue # } # # if num > max 1 { # max 1 , max 2 , max 3 = num , max 1 , max 2 # } else if num > max 2 { # max 2 , max 3 = num , max 2 # } else if num > max 3 { # max 3 = num # } # } # if max 3 == math . MinInt 6 4 { # return max 1 # } # return max 3
for i := x ; i < x + a ; i ++ { # for j := y ; j < y + b ; j ++ { # if hill [ i ][ j ] { # fmt . Printf (" STR ") # } else { # fmt . Printf (" STR ") # } # # } # fmt . Printf (" STR ") # # }
leftMostR := r 1 # rightMostR := r 2 # if r 2 . topLeftX < r 1 . topLeftX { # leftMostR = r 2 # rightMostR = r 1 # } # deltaX := 0 # if leftMostRR := leftMostR . topLeftX + leftMostR . width ; leftMostRR > rightMostR . topLeftX { # deltaX = leftMostRR - rightMostR . topLeftX # } # if deltaX == 0 { # return 0 # } # topMostR := r 1 # bottomMostR := r 2 # if r 2 . topLeftY < r 1 . topLeftY { # topMostR = r 2 # bottomMostR = r 1 # } # deltaY := 0 # if topMostRR := topMostR . topLeftY + topMostR . height ; topMostRR > bottomMostR . topLeftY { # deltaY = topMostRR - bottomMostR . topLeftY # } # if deltaY == 0 { # return 0 # } # return deltaX * deltaY
cases := [] struct { # name string # inputs [] string # expect bool # }{ # {" STR ", [] string {" STR ", " STR "}, false }, # {" STR ", [] string {" STR ", " STR "}, true }, # {" STR ", [] string {" STR ", " STR "}, true }, # {" STR ", [] string {" STR ", " STR "}, true }, # {" STR ", [] string {" STR ", " STR "}, false }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := isMatch ( c . inputs [ 0 ], c . inputs [ 1 ]) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
pnode = head # for head != nil { # if n < 0 { # pnode = pnode . Next # } # n -- # head = head . Next # } # headIsNthFromEnd = n == 0 # return
line := strings . Repeat (" STR ", 5 ) + strings . Repeat (" STR ", len ( board [ 0 ])) # # for i := range board { # if i == 0 { # fmt . Println ( line ) # } # content := " STR " + fmt . Sprintf (" STR ", len ( board )- 1 - i ) + " STR " # for _ , v := range board [ len ( board )- 1 - i ] { # content += " STR " + fmt . Sprintf (" STR ", v ) + " STR " # } # fmt . Println ( content ) # fmt . Println ( line ) # if i == len ( board )- 1 { # xIdxs := strings . Repeat (" STR ", 5 ) # for j := range board [ 0 ] { # xIdxs += " STR " + fmt . Sprintf (" STR ", j ) + " STR " # } # fmt . Println ( xIdxs ) # } # }
res := " STR " # # isExist := func ( L int ) bool { # seen := make ( map [ string ] bool , len ( S )- L + 2 ) # for i := 0 ; i + L <= len ( S ); i ++ { # sub := S [ i : i + L ] # if seen [ sub ] { # res = sub # return true # } # seen [ sub ] = true # } # return false # } # # lo , hi := 0 , len ( S ) # for lo < hi { # mi := ( lo + hi + 1 ) / 2 # if isExist ( mi ) { # lo = mi # } else { # hi = mi - 1 # } # } # # return res
fmt . Println ( productExceptSelf ([] int { 1 , 2 , 3 , 4 })) # fmt . Println ( productExceptSelf ([] int { 2 , 4 , 5 , 7 }))
var carryOne bool # result := & RevLLNum {} # current := result # for first != nil || second != nil { # current . Next = & RevLLNum {} # current = current . Next # var sum int # switch { # case first == nil : # sum = second . Digit # second = second . Next # case second == nil : # sum = first . Digit # first = first . Next # default : # sum = first . Digit + second . Digit # first = first . Next # second = second . Next # } # if carryOne { # sum ++ # } # carryOne = sum > 9 # current . Digit = sum % 1 0 # } # if carryOne { # current . Next = & RevLLNum { 1 , nil } # } # return result . Next
var ans int # prime := make ([] bool , n ) # for i := 2 ; i < n ; i ++ { # if prime [ i ] == false { # ans ++ # for j := 2 ; j * i < n ; j ++ { # prime [ j * i ] = true # } # } # # } # return ans
for _ , v := range om . order { # fmt . Println ( om . store [ v ]) # }
qs := [] question 9 2 1 { # { # para 9 2 1 {" STR "}, # ans 9 2 1 { 1 }, # }, # # { # para 9 2 1 {" STR "}, # ans 9 2 1 { 3 }, # }, # # { # para 9 2 1 {" STR "}, # ans 9 2 1 { 0 }, # }, # # { # para 9 2 1 {" STR "}, # ans 9 2 1 { 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 2 1 , q . para 9 2 1 # fmt . Printf (" STR ", p , minAddToMakeValid ( p . one )) # } # fmt . Printf (" STR ")
return len ( b . avail )
listTest := [] string {" STR ", " STR ", " STR "} # got := numUniqueEmails ( listTest ) # want := 2 # if got != want { # t . Errorf (" STR ", want , got ) # }
res = 0 # l , r = L , R # dfs ( root ) # return res
qs := [] question 1 1 1 1 { # # { # para 1 1 1 1 {" STR "}, # ans 1 1 1 1 {[] int { 0 , 1 , 1 , 1 , 1 , 0 }}, # }, # # { # para 1 1 1 1 {" STR "}, # ans 1 1 1 1 {[] int { 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 1 1 1 , q . para 1 1 1 1 # fmt . Printf (" STR ", p , maxDepthAfterSplit ( p . one )) # } # fmt . Printf (" STR ")
t . Parallel () # c := NewConverter () # c . AddConversion ( 1 2 . 0 , " STR ", " STR ") # c . AddConversion ( 5 2 8 0 . 0 , " STR ", " STR ") # c . AddConversion ( 1 . 6 0 9 , " STR ", " STR ") # c . AddConversion ( 1 0 0 0 , " STR ", " STR ") # c . AddConversion ( 1 0 0 , " STR ", " STR ") # c . AddConversion ( 3 . 0 , " STR ", " STR ") # c . AddConversion ( 2 2 . 0 , " STR ", " STR ") # for _ , tc := range testcases { # if result , err := c . Convert ( tc . val , tc . from , tc . to ); err != tc . err || abs ( result - tc . expected ) > tc . tolerance { # t . Errorf (" STR ", tc . expected , tc . err , result , err ) # } # }
i := len ( S ) # j := len ( T ) # # for i >= 0 || j >= 0 { # i = nextIndex (& S , i ) # j = nextIndex (& T , j ) # # if i >= 0 && j >= 0 && S [ i ] != T [ j ] { # return false # } # # } # # return i == j
switch { # case n < 1 : # panic ( panicMessage ) # case n == 1 : # return 1 # case n == 2 : # return 2 # default : # return TilingBoardWays ( n - 1 ) + TilingBoardWays ( n - 2 ) # }
fmt . Printf (" STR ", name , x ) # display ( name , reflect . ValueOf ( x ))
fmt . Printf (" STR ", spiralOrder ([][] int {[] int { 1 , 2 , 3 }, [] int { 4 , 5 , 6 }, [] int { 7 , 8 , 9 }}))
qs := [] question 8 0 2 { # # { # para 8 0 2 {[][] int {{ 1 , 2 }, { 2 , 3 }, { 5 }, { 0 }, { 5 }, {}, {}}}, # ans 8 0 2 {[] int { 2 , 4 , 5 , 6 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 0 2 , q . para 8 0 2 # fmt . Printf (" STR ", p , eventualSafeNodes ( p . graph )) # } # fmt . Printf (" STR ")
res := [] int { 1 , 1 0 , 9 1 , 7 3 9 , 5 2 7 5 , 3 2 4 9 1 , 1 6 8 5 7 1 , 7 1 2 8 9 1 , 2 3 4 5 8 5 1 , 5 6 1 1 7 7 1 , 8 8 7 7 6 9 1 } # if n >= 1 0 { # return res [ 1 0 ] # } # return res [ n ]
ss := strings . Fields ( s ) # reverse 1 5 1 (& ss , 0 , len ( ss )- 1 ) # return strings . Join ( ss , " STR ")
_ , ok := itf .( interface { # String () string # }) # return ok
largest := 1 0 0 0 # # for i := 1 0 0 ; i < 1 0 0 0 ; i ++ { # # for j := 1 0 0 ; j < 1 0 0 0 ; j ++ { # # x := i * j # # isPal := isPalindrome ( x ) # # if x > largest && isPal { # largest = x # } # # } # # } # # fmt . Println ( largest ) #
qs := [] question 3 3 8 { # # { # para 3 3 8 { 2 }, # ans 3 3 8 {[] int { 0 , 1 , 1 }}, # }, # # { # para 3 3 8 { 5 }, # ans 3 3 8 {[] int { 0 , 1 , 1 , 2 , 1 , 2 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 3 8 , q . para 3 3 8 # fmt . Printf (" STR ", p , countBits ( p . one )) # } # fmt . Printf (" STR ")
zero := reflect . Zero ( f . value . Type ()). Interface () # return f . Set ( zero )
if ! IsPalindrome (" STR ") { # t . Error (` IsPalindrome (" STR ") = false `) # }
if len ( this . data ) > 0 { # l := len ( this . data ) # this . data = this . data [: l - 1 ] # this . min = this . min [: l - 1 ] # }
if val < 0 { # return - val # } else { # return val # }
new = make ([] bool , cap ( old )+ 1 ) # copy ( new , old ) # return new
min := 0 # max := 1 0 # fmt . Println ( ClipInt (- 1 , min , max )) # fmt . Println ( ClipInt ( 5 , min , max )) # fmt . Println ( ClipInt ( 1 5 , min , max ))
m = map [* Node ]* NodeCopy {} # return dfs ( root )
wg . Add ( 1 ) # go func () { # defer wg . Done () # # for i := 0 ; i < 2 5 0 0 0 ; i ++ { # sum = sum + 1 # } # # fmt . Println (" STR "+ label +" STR ", sum ) # }()
for m > 0 || n > 0 { # if n == 0 { # break # } # if m == 0 { # nums 1 [ n - 1 ] = nums 2 [ n - 1 ] # n -- # continue # } # if nums 1 [ m - 1 ] > nums 2 [ n - 1 ] { # nums 1 [ m + n - 1 ] = nums 1 [ m - 1 ] # m -- # } else { # nums 1 [ m + n - 1 ] = nums 2 [ n - 1 ] # n -- # } # }
maxArea := 0 . 0 # n := len ( points ) # for i := 0 ; i < n ; i ++ { # for j := i + 1 ; j < n ; j ++ { # for k := j + 1 ; k < n ; k ++ { # maxArea = max ( maxArea , area ( points [ i ], points [ j ], points [ k ])) # } # } # } # return maxArea
dp , ans := make ([] int , len ( nums )), 0 # for _ , v := range nums { # i := 0 # j := ans # for i < j { # m := ( i + j ) >> 1 # if dp [ m ] < v { # i = m + 1 # } else { # j = m # } # } # dp [ i ] = v # if ans == j { # ans ++ # } # } # # return ans
log . Print (" STR ") # defer log . Print (" STR ") # log . Print ( r . Context (). Value (" STR ")) # ctx := r . Context () # select { # case <- time . After ( 5 * time . Second ): # fmt . Fprintln ( w , " STR ") # case <- ctx . Done (): # err := ctx . Err () # http . Error ( w , err . Error (), http . StatusInternalServerError ) # }
l . Length = 0 # l . Head = nil # l . Tail = nil
return fmt . Sprint ( p . Fname , " STR ", p . Lname )
if targetSum < 0 { # return # } # if targetSum == 0 { # cpy := make ([] int , len ( aWaitNum )) # copy ( cpy , aWaitNum ) # * res = append (* res , cpy ) # return # } # for i := selectIndex ; i < len ( arr ); i ++ { # num := arr [ i ] # aWaitNum = append ( aWaitNum , num ) # getSumTargetArr ( arr , i , targetSum - num , aWaitNum , res ) # aWaitNum = aWaitNum [: len ( aWaitNum )- 1 ] # }
t . NilNode = new ( gbtElement ) # t . NilNode . Left = t . NilNode # t . NilNode . Right = t . NilNode # t . NilNode . Parent = t . NilNode # t . Object = t
var i int # for i = len ( digits ) - 1 ; i > 0 ; i -- { # if digits [ i ] > digits [ i - 1 ] { # break # } # } # if i == 0 { # sort . Ints ( digits ) # return # } # x := digits [ i - 1 ] # min := i # for j := i + 1 ; j < len ( digits ); j ++ { # if digits [ j ] > x && digits [ j ] < digits [ min ] { # min = j # } # } # digits [ i - 1 ], digits [ min ] = digits [ min ], digits [ i - 1 ] # sort . Ints ( digits [ i :])
sum := 0 # for m != 0 { # sum += ( m % 1 0 ) * ( m % 1 0 ) # m /= 1 0 # } # return sum
answer := 0 # max := 0 # var solutions int # for p := 5 ; p <= 1 0 0 0 ; p ++ { # solutions = 0 # for c := p ; c > p / 3 ; c -- { # for b := 1 ; b < c ; b ++ { # a := p - c - b # if isPythagoras ( a , b , c ) { # solutions ++ # } # } # } # if solutions > max { # max , answer = solutions , p # } # } # println ( answer )
column := info . columns [" STR "] # id , err := strconv . Atoi ( record [ column ]) # if err != nil { # return nil , err # } # name := record [ info . columns [" STR "]] # abbreviation := record [ info . columns [" STR "]] # censusRegionName := record [ info . columns [" STR "]] # return & state { # id : id , # name : name , # abbreviation : abbreviation , # censusRegionName : censusRegionName , # }, nil
newTree , del := pruneTreeAux ( root ) # if del { # return nil # } # return newTree
err := http . ListenAndServe (" STR ", nil ) # if err != nil { # log . Fatalln ( err ) # }
return float 6 4 ( RandUint 6 4 () / 2 ) / ( 1 << 6 3 )
var res [][] int # helper (& res , [] int {}, 1 , n , k ) # return res
x := smallestMultiple ( 1 , 2 0 ) # # fmt . Println ( x ) #
if head == nil { # return nil # } # helper := & ListNode { Next : head } # pre , current := helper , helper . Next # for current != nil { # for current . Next != nil && current . Next . Val == current . Val { # current = current . Next # } # if pre . Next == current { # pre = pre . Next # } else { # pre . Next = current . Next # } # current = current . Next # } # return helper . Next
qs := [] question 8 2 6 { # # { # para 8 2 6 {[] int { 2 , 4 , 6 , 8 , 1 0 }, [] int { 1 0 , 2 0 , 3 0 , 4 0 , 5 0 }, [] int { 4 , 5 , 6 , 7 }}, # ans 8 2 6 { 1 0 0 }, # }, # # { # para 8 2 6 {[] int { 8 5 , 4 7 , 5 7 }, [] int { 2 4 , 6 6 , 9 9 }, [] int { 4 0 , 2 5 , 2 5 }}, # ans 8 2 6 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 2 6 , q . para 8 2 6 # fmt . Printf (" STR ", p , maxProfitAssignment ( p . one , p . two , p . three )) # } # fmt . Printf (" STR ")
return mySqrt ( n )
c , res := [] int {}, [][] int {} # sort . Ints ( nums ) # for k := 0 ; k <= len ( nums ); k ++ { # generateSubsetsWithDup ( nums , k , 0 , c , & res ) # } # return res
letterCount := - 3 * 9 # letterCount += len (" STR ") # for i := 1 ; i < 1 0 0 0 ; i ++ { # fmt . Println ( number ( i )) # letterCount += len ( number ( i ). String ()) # } # # fmt . Println ( letterCount )
v := 0 # i := 0 # negtive := false # # for ; i < len ( str ); i ++ { # if ' ' != str [ i ] { # break # } # } # if i > len ( str )- 1 { # return v # } # # if '+' == str [ i ] { # i ++ # } else if '-' == str [ i ] { # negtive = true # i ++ # } else if str [ i ] < ' 0 ' || str [ i ] > ' 9 ' { # return v # } # # for ; i < len ( str ); i ++ { # if str [ i ] < ' 0 ' || str [ i ] > ' 9 ' { # break # } # v = 1 0 * v + int ( str [ i ]-' 0 ') # if negtive { # if - v <= MinInt { # return MinInt # } # continue # } # if v < 0 || v > MaxInt { # return MaxInt # } # } # # if negtive { # v = - v # } # return v
fmt . Println ( triangleNumber ([] int { 2 , 2 , 3 , 4 }))
getTime := func ( piles [] int , speed int ) int { # result := 0 # for _ , p := range piles { # result += ( p + speed - 1 ) / speed # } # # return result # } # # min , max := 1 , 0 # for _ , p := range piles { # max = int ( math . Max ( float 6 4 ( max ), float 6 4 ( p ))) # } # # for min <= max { # mid := ( min + max ) / 2 # time := getTime ( piles , mid ) # if time > H { # min = mid + 1 # } else { # if mid == 1 || getTime ( piles , mid - 1 ) > H { # return mid # } # # max = mid - 1 # } # } # # return 0
t . Parallel () # for _ , tc := range testcases { # input := append ([] Interval {}, tc . X ...) # if result := StabIntervalPoints ( input ); ! reflect . DeepEqual ( result , tc . P ) { # t . Errorf (" STR ", tc . P , result ) # } # }
* c += ByteCounter ( len ( p )) # return len ( p ), nil
m . mem = make ( map [ interface {}][] byte ) # return m
rows := make ([] bool , len ( m )) # cols := make ([] bool , len ( m [ 0 ])) # # for i := range m { # for j := range m [ i ] { # if m [ i ][ j ] == 0 { # rows [ i ] = true # cols [ j ] = true # } # } # } # # for i := range rows { # if rows [ i ] { # for j := range m [ i ] { # m [ i ][ j ] = 0 # } # } # } # # for i := range cols { # if cols [ i ] { # for j := range m { # m [ j ][ i ] = 0 # } # } # }
t . Parallel () # # for _ , tc := range testcases { # if res := CanFirstPlayerForceWinNimGame ( tc . heaps ); res != tc . forcedWin { # t . Errorf (" STR ", tc . forcedWin , res ) # } # }
t . Parallel () # # for _ , tc := range testcases { # if sum , level := MinimumSumLevel ( tc . tree ); sum != tc . minSum && level != tc . minLevel { # t . Errorf (" STR ", tc . minSum , tc . minLevel , sum , level ) # } # }
node , _ := kth ( root , k ) # return node . Val
var writtenAsSums [] int # abuns := Abuns { getAbundantNums ( 2 8 1 2 3 )} # # writtenAsAbundantsMap := writtenAsAbundants ( 2 8 1 2 3 , & abuns ) # # for i := 0 ; i < 2 8 1 2 3 ; i ++ { # # if ! writtenAsAbundantsMap [ i ] { # writtenAsSums = append ( writtenAsSums , i ) # } # # } # # fmt . Println ( getSum ( writtenAsSums )) #
if len ( intervals ) == 0 { # return nil # } # sort . Slice ( intervals , func ( i , j int ) bool { return intervals [ i ]. Start < intervals [ j ]. Start }) # # var i int # for _ , interval := range intervals { # if intervals [ i ]. End < interval . Start { # i ++ # intervals [ i ] = interval # } else if interval . End > intervals [ i ]. End { # intervals [ i ]. End = interval . End # } # } # return intervals [: i + 1 ]
if len ( items ) < 2 { # return items # # } # # var middle = len ( items ) / 2 # var a = Mergesort ( items [: middle ]) # var b = Mergesort ( items [ middle :]) # return merge ( a , b ) #
var leaves 1 , leaves 2 [] int # # var f func ([] int , * TreeNode ) [] int # f = func ( leaves [] int , root * TreeNode ) [] int { # if root == nil { # return leaves # } # if root . Left == nil && root . Right == nil { # return append ( leaves , root . Val ) # } # # leaves = f ( leaves , root . Left ) # leaves = f ( leaves , root . Right ) # return leaves # } # leaves 1 = f ( leaves 1 , root 1 ) # leaves 2 = f ( leaves 2 , root 2 ) # # if len ( leaves 1 ) != len ( leaves 2 ) { # return false # } # for i := range leaves 1 { # if leaves 1 [ i ] != leaves 2 [ i ] { # return false # } # } # return true
n := len ( nums ) # res := make ([] int , n ) # res [ n - 1 ] = 1 # for i := n - 2 ; i >= 0 ; i -- { # res [ i ] = res [ i + 1 ] * nums [ i + 1 ] # } # tmp := 1 # for i , num := range nums { # res [ i ] *= tmp # tmp *= num # } # return res
if i == j { # return 1 # } # if i > j { # return 0 # } # if word [ i ] == word [ j ] { # return 2 + LpsRec ( word , i + 1 , j - 1 ) # } # return Max ( LpsRec ( word , i , j - 1 ), LpsRec ( word , i + 1 , j ))
runeCount := make ( map [ rune ] int ) # for _ , r := range s { # runeCount [ r ]++ # } # var odds int # for _ , v := range runeCount { # if v % 2 == 1 { # odds ++ # } # } # return odds < 2
count := 0 # for i := 1 ; i <= N ; i ++ { # if isValid ( i ) { # count ++ # } # } # return count
total := 0 # n := 1 0 0 0 # for i := 0 ; i < n ; i ++ { # if i % 3 == 0 || i % 5 == 0 { # total += i # } # } # fmt . Println ( total )
n , sum := len ( A ), 0 # for _ , v := range A { # sum += v # } # kad := kadane ( A ) # for i := 0 ; i < n ; i ++ { # A [ i ] = - A [ i ] # } # negativeMax := kadane ( A ) # if sum + negativeMax <= 0 { # return kad # } # return max ( kad , sum + negativeMax )
return SummaryRanges {}
if 0 == b { # return a # } # sum := a ^ b # carry := ( a & b ) << 1 # return getSum ( sum , carry )
ans := make ([] int , 0 ) # flag : # for i := left ; i <= right ; i ++ { # for x := i ; x > 0 ; x /= 1 0 { # if d := x % 1 0 ; d == 0 || i % d != 0 { # continue flag # } # } # ans = append ( ans , i ) # } # return ans
currentNode := trie . root # for _ , r := range item { # if _ , ok := currentNode . children [ r ]; ok { # currentNode = currentNode . children [ r ] # } else { # node := & Node { children : map [ int 3 2 ]* Node {}, parent : currentNode } # currentNode . children [ r ] = node # currentNode = node # } # } # currentNode . last = true
qsc := make ( chan os . Signal , 1 ) # signal . Notify ( qsc , syscall . SIGQUIT ) # <- qsc # signal . Stop ( qsc ) # fmt . Fprintf ( w , " STR ") # buf := make ([] byte , 6 5 5 3 6 ) # buf = buf [: runtime . Stack ( buf , true )] # fmt . Fprintln ( w , string ( buf )) # os . Exit ( 1 )
tests := [...] testType { # { # in : [] string {" STR ", " STR ", " STR ", " STR "}, # want : [] string {" STR ", " STR "}, # }, # { # in : [] string {" STR ", " STR ", " STR "}, # want : [] string {" STR ", " STR "}, # }, # { # in : [] string {" STR ", " STR ", " STR "}, # want : nil , # }, # } # for _ , tt := range tests { # got := stringMatching ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
col , dia 1 , dia 2 , row , res := make ([] bool , n ), make ([] bool , 2 * n - 1 ), make ([] bool , 2 * n - 1 ), [] int {}, [][] string {} # putQueen ( n , 0 , & col , & dia 1 , & dia 2 , & row , & res ) # return res
heads = strings . Replace ( heads , `\ n `, " STR ", - 1 ) # h := http . Header {} # # sets := strings . Split ( heads , " STR ") # for i := range sets { # split := strings . SplitN ( sets [ i ], " STR ", 2 ) # if len ( split ) == 2 { # h . Set ( split [ 0 ], split [ 1 ]) # } # } # # return h , nil
return helper 3 9 ( candidates , target , 0 , make ([] int , 0 ), make ([][] int , 0 ))
res := 0 # for i := range arr 1 { # for j := range arr 2 { # if abs ( arr 1 [ i ]- arr 2 [ j ]) <= d { # break # } # if j == len ( arr 2 )- 1 { # res ++ # } # } # } # return res
fields := getFields ( s . value , s . TagName ) # # names := make ([] string , len ( fields )) # # for i , field := range fields { # names [ i ] = field . Name () # } # # return names
res := [] int {} # for _ , v := range nums { # if v < 0 { # v = - v # } # if nums [ v - 1 ] > 0 { # nums [ v - 1 ] = - nums [ v - 1 ] # } # } # for i , v := range nums { # if v > 0 { # res = append ( res , i + 1 ) # } # } # return res
circularQueue := MyCircularQueue {} # circularQueue . queue = make ([] int , k ) # circularQueue . frontIndex = 0 # circularQueue . rearIndex = - 1 # circularQueue . length = 0 # return circularQueue
if nums [ len ( nums )- 1 ] > nums [ 0 ] { # return nums [ 0 ] # } # l , r := 0 , len ( nums )- 1 # for l < r { # mid := l + ( r - l )>> 1 # if nums [ mid ] >= nums [ 0 ] { # l = mid + 1 # } else { # r = mid # } # } # # return nums [ l ]
qs := [] question 5 6 1 { # # { # para 5 6 1 {[] int {}}, # ans 5 6 1 { 0 }, # }, # # { # para 5 6 1 {[] int { 1 , 4 , 3 , 2 }}, # ans 5 6 1 { 4 }, # }, # # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 6 1 , q . para 5 6 1 # fmt . Printf (" STR ", p , arrayPairSum ( p . nums )) # } # fmt . Printf (" STR ")
t . Parallel () # var stack ThreeStacks # for i := 0 ; i < 1 0 0 ; i ++ { # stack . Push ( i , i % 3 ) # } # for i := 9 9 ; i >= 0 ; i -- { # if v , err := stack . Pop ( i % 3 ); err != nil || v != i { # t . Errorf (" STR ", i , v , err ) # } # }
result := make ([] byte , 7 ) # result [ 0 ] = color [ 0 ] # for i := 0 ; i < 3 ; i ++ { # b := helper 8 0 0 ( color [ i * 2 + 1 ], color [ i * 2 + 2 ]) # result [ i * 2 + 1 ], result [ i * 2 + 2 ] = b , b # } # # return string ( result )
qs := [] question 4 2 1 { # # { # para 4 2 1 {[] int { 3 , 1 0 , 5 , 2 5 , 2 , 8 }}, # ans 4 2 1 { 2 8 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 2 1 , q . para 4 2 1 # fmt . Printf (" STR ", p , findMaximumXOR ( p . one )) # } # fmt . Printf (" STR ")
perimeter := 0 # # for r := range grid { # for c := range grid [ r ] { # if grid [ r ][ c ] == 0 { # continue # } # if nr , nc := r , c - 1 ; nc < 0 || grid [ nr ][ nc ] == 0 { # perimeter ++ # } # # if nr , nc := r , c + 1 ; nc >= len ( grid [ nr ]) || grid [ nr ][ nc ] == 0 { # perimeter ++ # } # # if nr , nc := r - 1 , c ; nr < 0 || grid [ nr ][ nc ] == 0 { # perimeter ++ # } # # if nr , nc := r + 1 , c ; nr >= len ( grid ) || grid [ nr ][ nc ] == 0 { # perimeter ++ # } # } # } # # return perimeter
return DialOption { func ( do * dialOptions ) { # dialer := net . Dialer { Timeout : d } # do . dial = dialer . Dial # }}
qs := [] question 7 2 0 { # # { # para 7 2 0 {[] string {" STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 7 2 0 {" STR "}, # }, # # { # para 7 2 0 {[] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 7 2 0 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 2 0 , q . para 7 2 0 # fmt . Printf (" STR ", p , longestWord ( p . w )) # } # fmt . Printf (" STR ")
n := len ( A ) # sums := make ([] int , n + 1 ) # for i , a := range A { # if a == K { # return 1 # } # sums [ i + 1 ] = sums [ i ] + a # } # deque := make ([] int , n + 2 ) # res := n + 1 # for i , l , r := 0 , 0 , - 1 ; i < n + 1 ; i ++ { # for r - l >= 0 && sums [ i ]- sums [ deque [ l ]] >= K { # res = min ( res , i - deque [ l ]) # l ++ # } # for r - l >= 0 && sums [ i ] <= sums [ deque [ r ]] { # r -- # } # r ++ # deque [ r ] = i # } # if res == n + 1 { # return - 1 # } # return res
if a == b { # return a # } # if a == 0 || b == 0 { # return a + b # } # # shift := 0 # for shift = 0 ; (( a | b ) & 1 ) == 0 ; shift ++ { # a >>= 1 # b >>= 1 # } # # for ( a & 1 ) == 0 { # a >>= 1 # } # # for b != 0 { # for b & 1 == 0 { # b >>= 1 # } # if a > b { # b , a = a , b # } # b -= a # } # # return a << uint 3 2 ( shift )
m := make ( map [ string ][] string ) # for _ , v := range strs { # bytes := [] byte ( v ) # sort . SliceStable ( bytes , func ( i , j int ) bool { # return bytes [ i ] < bytes [ j ] # }) # s := string ( bytes ) # m [ s ] = append ( m [ s ], v ) # } # var ss [][] string # for e := range m { # ss = append ( ss , m [ e ]) # } # return ss
uuid := make ([] byte , 1 6 ) # # n , err := io . ReadFull ( rand . Reader , uuid ) # if n != len ( uuid ) || err != nil { # return "", err # } # # uuid [ 8 ] = uuid [ 8 ]&^ 0 xc 0 | 0 x 8 0 # uuid [ 6 ] = uuid [ 6 ]&^ 0 xf 0 | 0 x 4 0 # # return fmt . Sprintf (" STR ", uuid [ 0 : 4 ], uuid [ 4 : 6 ], uuid [ 6 : 8 ], uuid [ 8 : 1 0 ], uuid [ 1 0 :]), nil
num 1 := [] int { 1 , 2 , 2 , 1 } # num 2 := [] int { 2 , 2 } # # fmt . Println ( intersect ( num 1 , num 2 ))
for _ , test := range romanToIntegerTests { # convertedValue := RomanToInteger ( test . input ) # if convertedValue != test . expected { # t . Errorf ( # " STR ", # test . name , test . expected , convertedValue , # ) # } # }
return & Stack { sync . Mutex {}, []* TreeNode {}}
var positions [] int # for i := 0 ; i <= len ( text )- len ( pattern ); i ++ { # var match bool = true # for j := 0 ; j < len ( pattern ); j ++ { # if text [ i + j ] != pattern [ j ] { # match = false # break # } # # } # if match { # positions = append ( positions , i ) # } # } # return positions
return len ( h . data )
buf := [] byte {' 1 '} # # for n > 1 { # buf = say ( buf ) # n -- # } # # return string ( buf )
l . pos -= l . width
qs := [] question 9 2 0 { # # { # para 9 2 0 { 3 , 3 , 1 }, # ans 9 2 0 { 6 }, # }, # # { # para 9 2 0 { 2 , 3 , 0 }, # ans 9 2 0 { 6 }, # }, # # { # para 9 2 0 { 2 , 3 , 1 }, # ans 9 2 0 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 2 0 , q . para 9 2 0 # fmt . Printf (" STR ", p , numMusicPlaylists ( p . N , p . L , p . K )) # } # fmt . Printf (" STR ")
chArray := make ([] byte , 0 ) # carry := byte ( 0 ) # for i , j := len ( num 1 )- 1 , len ( num 2 )- 1 ; i >= 0 || j >= 0 ; i , j = i - 1 , j - 1 { # sum := carry # if i >= 0 { # sum += num 1 [ i ] - ' 0 ' # } # # if j >= 0 { # sum += num 2 [ j ] - ' 0 ' # } # # if sum >= 1 0 { # sum -= 1 0 # carry = 1 # } else { # carry = 0 # } # # chArray = append ( chArray , sum +' 0 ') # } # # if carry == 1 { # chArray = append ( chArray , ' 1 ') # } # # for i := 0 ; i < len ( chArray )/ 2 ; i ++ { # chArray [ i ], chArray [ len ( chArray )- 1 - i ] = chArray [ len ( chArray )- 1 - i ], chArray [ i ] # } # # return string ( chArray )
return helper ( root , sum , [] int {})
fmt . Println ( recursive ( 0 , 3 , 1 0 0 0 ))
testCases := [] string { # " STR ", # " STR ", # " STR ", # " STR ", # } # expected := [] string { # " STR ", # " STR ", # " STR ", # " STR ", # } # # for index , data := range testCases { # if res := reverseString ( data ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
switch name { # case " STR ": # if dir := os . Getenv (" STR "); dir != "" { # return dir # } # return runtime . GOOS # case " STR ": # if dir := os . Getenv (" STR "); dir != "" { # return dir # } # return runtime . GOARCH # case " STR ": # return getGoroot () # case " STR ": # if dir := os . Getenv (" STR "); dir != "" { # return dir # } # # home := getHomeDir () # return filepath . Join ( home , " STR ") # case " STR ": # dir , err := os . UserCacheDir () # if err != nil { # panic (" STR " + err . Error ()) # } # return filepath . Join ( dir , " STR ") # case " STR ": # val := os . Getenv (" STR ") # if val == " STR " || val == " STR " { # return val # } # return " STR " # case " STR ": # return sourceDir () # default : # return "" # }
chars := make ([] uint 8 , 0 ) # # for i := 0 ; i < len ( s ); i ++ { # if s [ i ] >= 6 5 && s [ i ] <= 9 0 { # chars = append ( chars , s [ i ]) # } # if s [ i ] >= 9 7 && s [ i ] <= 1 2 2 { # chars = append ( chars , s [ i ]- 3 2 ) # } # if s [ i ] >= 4 8 && s [ i ] <= 5 7 { # chars = append ( chars , s [ i ]) # } # } # # var ( # l int # r = len ( chars ) - 1 # ) # # for r >= l { # if chars [ r ] != chars [ l ] { # return false # } # r -- # l ++ # } # return true
copyStr := str # # begin , end := 0 , len ( copyStr )- 1 # for begin < end { # copyStr [ begin ], copyStr [ end ] = copyStr [ end ], copyStr [ begin ] # begin ++ # end -- # }
tests := [...] testType { # { # in : 3 , # want : 0 , # }, # { # in : 5 , # want : 1 , # }, # { # in : 7 , # want : 1 , # }, # { # in : 8 , # want : 1 , # }, # { # in : 1 0 , # want : 2 , # }, # { # in : 1 2 , # want : 2 , # }, # { # in : 2 5 , # want : 6 , # }, # } # for _ , tt := range tests { # got := trailingZeroes ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
res := make ([] int , 0 , 1 ) # inorderTraversalHelp ( root , & res ) # return res
num , _ := strconv . ParseUint ( n , 1 0 , 6 4 ) # mMax := int ( math . Log 2 ( float 6 4 ( num ))) # # for m := mMax ; m >= 1 ; m -- { # k := uint 6 4 ( math . Pow ( float 6 4 ( num ), 1 . 0 / float 6 4 ( m ))) # if isFound ( num , k , m ) { # return strconv . FormatUint ( k , 1 0 ) # } # } # # return strconv . FormatUint ( num - 1 , 1 0 )
t . Parallel () # # for _ , tc := range testcases { # if y := FindY ( tc . x ); ! reflect . DeepEqual ( y , tc . y ) { # t . Errorf (" STR ", tc . y , y ) # } # }
record := make ( map [ int ] int , len ( nums )) # for i , v := range nums { # if j , ok := record [ v ]; ok { # if i - j <= k { # return true # } # } # record [ v ] = i # } # return false
n := len ( S ) # if n == 0 || n == 2 { # return S # } # # ss := [] string {} # count , i := 0 , 0 # for j := 0 ; j < n ; j ++ { # if S [ j ] == ' 0 ' { # count -- # } else { # count ++ # } # # if count == 0 { # ss = append ( ss , " STR "+ makeLargestSpecial ( S [ i + 1 : j ])+" STR ") # i = j + 1 # } # } # sort . Sort ( sort . Reverse ( sort . StringSlice ( ss ))) # return strings . Join ( ss , " STR ")
result := [][] int {} # if candidates == nil || len ( candidates ) == 0 { # return result # } # sort . Ints ( candidates ) # set := [] int {} # explore ( candidates , target , 0 , & result , set ) # # return result
if x > 0 { # return x # } # return - x
if head == nil || head . Next == nil { # return head # } # # if head . Val == head . Next . Val { # val := head . Val # head = head . Next . Next # # for head != nil && head . Val == val { # head = head . Next # } # # return deleteDuplicates ( head ) # } # # head . Next = deleteDuplicates ( head . Next ) # # return head
var tests = [] struct { # list [] int # k int # parts []* ListNode # }{ # {[] int { 1 , 2 , 3 }, 5 , []* ListNode { newList ( 1 ), newList ( 2 ), newList ( 3 ), nil , nil }}, # {[] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 0 }, 3 , []* ListNode { newList ( 1 , 2 , 3 , 4 ), newList ( 5 , 6 , 7 ), newList ( 8 , 9 , 1 0 )}}, # } # # for _ , tt := range tests { # parts := splitListToParts ( newList ( tt . list ...), tt . k ) # if reflect . DeepEqual ( parts , tt . parts ) == false { # t . Errorf (" STR ", newList ( tt . list ...), tt . k , parts , tt . parts ) # } # }
p := [] byte {} # for len ( p ) >= 1 { # p = p [ 1 :] # }
if root == nil || p == root || q == root { # return root # } # left := Lowest ( root . left , p , q ) # right := Lowest ( root . right , p , q ) # if left == nil { # return right # } # if right == nil { # return left # } # return root
b := NewMultiLRUCache ( 4 , 2 5 0 ) # for i := 0 ; i < 1 0 0 0 ; i ++ { # b . Set ( randomString ( 2 ), " STR ", expire ) # } # return b
wg . Add ( 1 ) # go func () { # defer wg . Done () # # for i := 0 ; i < 2 5 0 0 0 ; i ++ { # mu . Lock () # sum = sum + 1 # mu . Unlock () # } # # fmt . Println (" STR "+ label +" STR ", sum ) # }()
qs := [] question 1 1 2 8 { # # { # para 1 1 2 8 {[][] int {{ 1 , 2 }, { 2 , 1 }, { 3 , 4 }, { 5 , 6 }}}, # ans 1 1 2 8 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 1 2 8 , q . para 1 1 2 8 # fmt . Printf (" STR ", p , numEquivDominoPairs ( p . dominoes )) # } # fmt . Printf (" STR ")
tests := [...] testType { # { # in : 3 8 , # want : 2 , # }, # } # for _ , tt := range tests { # got := addDigits ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
string_num := strconv . Itoa ( i ) # for i , v := 0 , len ( string_num )- 1 ; i < v ; i , v = i + 1 , v - 1 { # if string_num [ v ] != string_num [ i ] { # return false # } # } # return true
return MyLinkedList { list . New ()}
cases := [] struct { # name string # A [] int # queries [][] int # expect [] int # }{ # {" STR ", [] int { 1 , 2 , 3 , 4 }, [][] int {{ 1 , 0 }, {- 3 , 1 }, {- 4 , 0 }, { 2 , 3 }}, [] int { 8 , 6 , 2 , 4 }}, # {" STR ", [] int { 6 , 7 , 8 , 9 }, [][] int {{ 1 , 0 }, { 5 , 0 }}, [] int { 8 , 2 0 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . A , c . queries ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . A , c . queries ) # } # }) # }
dup , mis := 0 , 0 # for i , num := range nums { # if num != i + 1 { # nums [ i ] = 0 # for { # pop := nums [ num - 1 ] # if pop == num { # dup = num # break # } # nums [ num - 1 ] = num # if pop == 0 { # break # } # num = pop # } # } # } # # for i , num := range nums { # if num == 0 { # mis = i + 1 # break # } # } # return [] int { dup , mis }
var length int # # var f func (* TreeNode ) int # f = func ( root * TreeNode ) int { # if root == nil { # return 0 # } # # a , b := f ( root . Left ), f ( root . Right ) # # var l , r int # if root . Left != nil && root . Left . Val == root . Val { # l = a + 1 # } # if root . Right != nil && root . Right . Val == root . Val { # r = b + 1 # } # # if l + r > length { # length = l + r # } # # if r > l { # l = r # } # return l # } # # f ( root ) # return length
t . Parallel () # # for _ , tc := range testcases { # if res := IslandPerimeter ( tc . grid ); res != tc . perimeter { # t . Errorf (" STR ", tc . perimeter , res ) # } # }
_ , ok := at [ state ] # if ! ok || state == - 1 || at [ state ] == nil { # return false # } # return true
t . Parallel () # for _ , tc := range testcases { # if result := ValidSentences ( tc . text ); ! reflect . DeepEqual ( result , tc . sentences ) { # t . Errorf (" STR ", tc . sentences , result ) # } # }
if str 1 + str 2 != str 2 + str 1 { # return " STR " # } # return str 1 [: gcd ( len ( str 1 ), len ( str 2 ))]
p . active -- # if p . cond != nil { # p . cond . Signal () # }
sort . Ints ( candidates ) # res := [][] int {} # dfs ( candidates , nil , target , 0 , & res ) # return res
t . Parallel () # for _ , tc := range testcases { # if result := IsValidBST ( tc . root ); result != tc . isValid { # t . Errorf (" STR ", tc . isValid , result ) # } # }
b . SetNow ( key , value , expire , time . Time {})
return LoadUint 8 (& r . Reg )
if num == 0 { # return " STR " # } # var ( # s string # negative bool # ) # if num < 0 { # num = - num # negative = true # } # for num > 0 { # n := num % 7 # s = string (' 0 '+ n ) + s # num /= 7 # } # if negative { # s = " STR " + s # } # return s
if len ( dungeon ) == 0 || len ( dungeon [ 0 ]) == 0 { # return 0 # } # # rows , cols := len ( dungeon ), len ( dungeon [ 0 ]) # dp := make ([] int , cols ) # left := 1 # for i := cols - 1 ; i >= 0 ; i -- { # dp [ i ] = int ( math . Max ( 1 . 0 , float 6 4 ( left - dungeon [ rows - 1 ][ i ]))) # left = dp [ i ] # } # # for i := rows - 2 ; i >= 0 ; i -- { # left := 0 x 7 fffffff # for j := cols - 1 ; j >= 0 ; j -- { # valRight := int ( math . Max ( 1 . 0 , float 6 4 ( left - dungeon [ i ][ j ]))) # valDown := int ( math . Max ( 1 . 0 , float 6 4 ( dp [ j ]- dungeon [ i ][ j ]))) # dp [ j ] = int ( math . Min ( float 6 4 ( valRight ), float 6 4 ( valDown ))) # left = dp [ j ] # } # } # # return dp [ 0 ]
sort . Ints ( arr 2 ) # c := 0 # for _ , v 1 := range arr 1 { # l , r := 0 , len ( arr 2 )- 1 # for l <= r { # mid := ( l + r ) / 2 # if abs ( v 1 - arr 2 [ mid ]) <= d { # c ++ # break # } # if arr 2 [ mid ] > v 1 { # r = mid - 1 # } else { # l = mid + 1 # } # } # } # return len ( arr 1 ) - c
roman := map [ byte ] int { # ' I ': 1 , # ' V ': 5 , # ' X ': 1 0 , # ' L ': 5 0 , # ' C ': 1 0 0 , # ' D ': 5 0 0 , # ' M ': 1 0 0 0 , # } # # if len ( s ) <= 0 { # return 0 # } # sum , ok := roman [ s [ len ( s )- 1 ]] # if ! ok { # return 0 # } # # for i := len ( s ) - 2 ; i >= 0 ; i -- { # if roman [ s [ i ]] < roman [ s [ i + 1 ]] { # sum -= roman [ s [ i ]] # } else { # sum += roman [ s [ i ]] # } # } # return sum
fractions := split ( expression ) # res := newFraction ( fractions [ 0 ]) # for i := 1 ; i < len ( fractions ); i ++ { # res = add ( res , newFraction ( fractions [ i ])) # } # return res . String ()
var res [] int # var stack = []* TreeNode { root } # for 0 < len ( stack ) { # top := len ( stack ) - 1 # root = stack [ top ] # stack = stack [: top ] # if root != nil { # res = append ( res , root . Val ) # stack = append ( stack , root . Left , root . Right ) # } # } # # l , r := 0 , len ( res )- 1 # for l < r { # res [ l ], res [ r ] = res [ r ], res [ l ] # l ++ # r -- # } # return res
resultArr := make ([] int , 0 , 0 ) # expArr := make ([] int , 0 , 0 ) # tree . PreOrderWalk ( tree . Root (), func ( tree binaryTreeIf , node interface {}) bool { # n := node .(* gbtElement ) # resultArr = append ( resultArr , int ( n . Key )) # return false # }) # # expBst := newBstRecrusive () # for _ , v := range data { # expBst . Insert ( uint 3 2 ( v )) # } # expBst . PreOrderWalk ( expBst . Root (), func ( tree binaryTreeIf , node interface {}) bool { # n := node .(* bstElement ) # expArr = append ( expArr , int ( n . Key )) # return false # }) # if ! reflect . DeepEqual ( resultArr , expArr ) { # t . Log ( fmt . Sprintf (" STR ", expArr ) + fmt . Sprintf (" STR ", resultArr )) # t . Fail () # }
i , count , limit , mul := 1 , 0 , 1 0 , 1 # var tmp int # for limit < 1 0 0 0 0 0 1 { # str := strconv . Itoa ( i ) # count += len ( str ) # if count >= limit { # tmp , _ = strconv . Atoi ( str [ len ( str )-( count - limit )- 1 : len ( str )-( count - limit )]) # mul *= tmp # limit *= 1 0 # } # i ++ # } # println ( mul )
if ! sl . Empty () { # element := sl . stack . Front () # return element . Value , nil # } # return " STR "
t . Parallel () # for _ , tt := range distanceTest { # tt := tt # t . Run ( tt . name , func ( t * testing . T ) { # t . Parallel () # res := Distance ( tt . v 1 , tt . v 2 ) # roundRes := ( math . Floor ( res * 1 0 0 ) / 1 0 0 ) # if roundRes != tt . res { # t . Errorf (" STR ", # tt . v 1 , tt . v 2 , roundRes , tt . res ) # } # }) # }
var ans [] string # for _ , word := range words { # for _ , val := range words { # if val != word && strings . Contains ( val , word ) { # ans = append ( ans , word ) # break # } # } # } # return ans
if len ( nums ) == 0 { # return false # } # if len ( nums ) == 1 { # if nums [ 0 ] == target { # return true # } # return false # } # return search 1 ( nums , target , 0 , len ( nums )- 1 ) != - 1
if n == 0 { # return [] string {} # } # var ret [] string # tmps := generateParenthesisI ( n - 1 , n , 1 ) # for index := range tmps { # ret = append ( ret , " STR "+ tmps [ index ]) # } # return ret
i := big . NewInt ( 1 ) # j := big . NewInt ( 1 ) # temp := big . NewInt ( 0 ) # for c := 3 ; ; c ++ { # temp . Add ( i , j ) # i . Set ( j ) # j . Set ( temp ) # if len ( j . Text ( 1 0 )) >= 1 0 0 0 { # fmt . Println (" STR ", c ) # break # } # }
var ( # l = 0 # r = - 1 # res = len ( nums ) + 1 # sum = 0 # ) # # for l < len ( nums ) { # if sum < s && r + 1 < len ( nums ) { # r ++ # sum += nums [ r ] # } else { # sum -= nums [ l ] # l ++ # } # if sum >= s && res > r - l + 1 { # res = r - l + 1 # } # } # if res == len ( nums )+ 1 { # return 0 # } # return res
p , q := m - 1 , n - 1 # tail := m + n - 1 # for p >= 0 || q >= 0 { # if p == - 1 { # nums 1 [ tail ] = nums 2 [ q ] # q -- # } else if q == - 1 { # nums 1 [ tail ] = nums 1 [ p ] # p -- # } else if nums 1 [ p ] > nums 2 [ q ] { # nums 1 [ tail ] = nums 1 [ p ] # p -- # } else { # nums 1 [ tail ] = nums 2 [ q ] # q -- # } # tail -- # }
n := len ( A ) # if n == 1 { # if A [ 0 ] == 0 { # return [] bool { true } # } else { # return [] bool { false } # } # } # ans , v := make ([] bool , n ), 0 # for i := 0 ; i < n ; i ++ { # v = ( 2 * v + A [ i ]) % 5 # if v == 0 { # ans [ i ] = true # } else { # ans [ i ] = false # } # } # return ans
cur := [] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 } # tmp := make ([] int , 0 , 1 0 ) # for i := 2 ; i <= N ; i ++ { # for _ , x := range cur { # y := x % 1 0 # if x > 0 && y + K < 1 0 { # tmp = append ( tmp , x * 1 0 + y + K ) # } # if x > 0 && K > 0 && y - K >= 0 { # tmp = append ( tmp , x * 1 0 + y - K ) # } # } # cur , tmp = tmp , cur # tmp = tmp [: 0 ] # } # return cur
var ret [] string # star := false # v := " STR " # for _ , s := range source { # # for i := 0 ; i < len ( s ); { # if star { # if i + 1 == len ( s ) { # i ++ # } else { # t := string ( s [ i : i + 2 ]) # if t == " STR " { # star , i = false , i + 2 # } else { # i ++ # } # } # } else { # if i + 1 == len ( s ) { # v += string ( s [ i ]) # i ++ # } else { # t := string ( s [ i : i + 2 ]) # if t == " STR " { # star , i = true , i + 2 # } else if t == " STR " { # break # } else { # v += string ( s [ i ]) # i ++ # } # } # } # } # if v != " STR " && star == false { # ret = append ( ret , v ) # v = " STR " # } # }
ldc := newLdc (" STR ", " STR ", & newDelete ( 2 ). lDOperation , & newInsert ( 3 ). lDOperation , & newKill ( 1 ). lDOperation ) # ldc . addOp (& newTwiddle ( 2 ). lDOperation ) # ldc . addOp (& newCopy ( 1 ). lDOperation ) # ldc . addOp (& newReplace ( 4 ). lDOperation ) # dist , opSeq := ldc . levenshteinDistance () # if dist != 2 4 { # t . Log ( fmt . Sprintf (" STR ", dist )) # t . Fail () # } # if ! reflect . DeepEqual ( opSeq , [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}) { # t . Log (" STR ") # t . Log ( opSeq ) # t . Fail () # }
numbers := [] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 } # # rotate ( numbers , 3 ) # # fmt . Println ( numbers ) # # numbers 2 := [] int {- 1 } # rotate ( numbers 2 , 2 ) # fmt . Println ( numbers 2 ) #
n := len ( numbers ) # if n < 2 { # return nil # } # i , j := 0 , n - 1 # for i < j { # sum := numbers [ i ] + numbers [ j ] # if sum == target { # return [] int { i + 1 , j + 1 } # } else if sum < target { # i ++ # } else { # j -- # } # } # return nil
var ret bool # p := & TreeNode { # Val : 2 , # Left : & TreeNode { # Val : 3 , # Left : & TreeNode { # Val : 4 , # Left : nil , # Right : nil , # }, # Right : & TreeNode { # Val : 5 , # Left : nil , # Right : nil , # }, # }, # Right : & TreeNode { # Val : 3 , # Left : nil , # Right : & TreeNode { # Val : 4 , # Left : nil , # Right : nil , # }, # }, # } # # ret = false # if ret != isSymmetric ( p ) { # t . Fatalf (" STR ", ret ) # } # # p 1 := & TreeNode {} # ret = true # if ret != isSymmetric ( p 1 ) { # t . Fatalf (" STR ", ret ) # } #
num := 0 # for i := 0 ; i < len ( board ); i ++ { # for j := 0 ; j < len ( board [ i ]); j ++ { # if board [ i ][ j ] == ' R ' { # num += caputure ( board , i - 1 , j , - 1 , 0 ) # num += caputure ( board , i + 1 , j , 1 , 0 ) # num += caputure ( board , i , j - 1 , 0 , - 1 ) # num += caputure ( board , i , j + 1 , 0 , 1 ) # } # } # } # return num
_ , err := os . Stat ( filepath . Join ( root , " STR ")) # if err != nil { # return false # } # _ , err = os . Stat ( filepath . Join ( root , " STR ")) # return err == nil
if p == nil && q == nil { # return true # } # if ( p == nil && q != nil ) || ( p != nil && q == nil ) { # return false # } # if p . Val != q . Val { # return false # } # return isSameTree ( p . Left , q . Left ) && isSameTree ( p . Right , q . Right )
if list . head == nil { # return 0 , false # } # return list . head . data , true
sum , min := 0 , ( 1 << 3 1 - 1 ) # for _ , num := range nums { # if min > num { # min = num # } # sum += num # } # return sum - len ( nums )* min
k %= len ( nums ) # reverse ( nums , 0 , len ( nums )- 1 ) # reverse ( nums , 0 , k - 1 ) # reverse ( nums , k , len ( nums )- 1 ) # return
return copy ( dst , src )
return strings . Index ( s , " STR ") >= 0
var maxEndingHere , maxSoFar int # for i := range arr { # maxEndingHere = max ( arr [ i ], maxEndingHere + arr [ i ]) # maxSoFar = max ( maxSoFar , maxEndingHere ) # } # return maxSoFar
if hh < 0 || hh >= 2 4 || mm < 0 || mm >= 6 0 { # panic (" STR ") # } # if hh >= 1 2 { # hh -= 1 2 # } # hourAngle := 3 6 0 . 0 * float 6 4 ( hh ) / 1 2 . 0 # minuteAngle := 3 6 0 . 0 * float 6 4 ( mm ) / 6 0 . 0 # diffAngle := math . Abs ( hourAngle - minuteAngle ) # if diffAngle > 1 8 0 { # diffAngle -= 3 6 0 # } # return int ( math . Round ( math . Abs ( diffAngle )))
arr = make ([][] uint 6 4 , 2 1 ) # for i := range arr { # arr [ i ] = make ([] uint 6 4 , 2 1 ) # for j := range arr [ i ] { # arr [ i ][ j ] = uint 6 4 ( 0 ) # } # } # arr [ 2 0 ][ 2 0 ] = uint 6 4 ( 1 ) # println ( noOfRoutes ( 0 , 0 ))
total := 0 # previousFib := 0 # nextFib := 1 # for nextFib < max { # if nextFib % 2 == 0 { # total += nextFib # } # previousFib , nextFib = nextFib , previousFib + nextFib # } # return total
min := func ( m , n int ) int { # if m < n { # return m # } # # return n # } # # result := make ([] byte , len ( s )) # for i := 0 ; i < len ( s ); i += 2 * k { # j := i # for l := min ( len ( s )- 1 , i + k - 1 ); l >= i ; l -- { # result [ j ] = s [ l ] # j ++ # } # # for l := i + k ; l < min ( i + 2 * k , len ( s )); l ++ { # result [ j ] = s [ l ] # j ++ # } # } # # return string ( result )
n := len ( nums ) # if n == 0 { # return - 1 # } # l , r := 0 , n - 1 # for l <= r { # m := ( l + r ) / 2 # if nums [ m ] == target { # return m # } else if nums [ m ] < target { # l = m + 1 # } else { # r = m - 1 # } # } # return - 1
if m . exist ( key ) { # i := m . m [ key ].([] interface {}) # m . keyL . Remove ( i [ 0 ].(* list . Element )) # delete ( m . m , key ) # }
listener , err := net . Listen (" STR ", " STR ") # if err != nil { # log . Fatal ( err ) # } # for { # conn , err := listener . Accept () # if err != nil { # log . Print ( err ) # continue # } # go handleConn ( conn ) # }
return list . top == nil
sum , number , skip := 1 , 1 , 0 # for i := 0 ; i < 2 0 0 0 ; i ++ { # if i % 4 == 0 { # skip += 2 # } # for j := 0 ; j < skip ; j ++ { # number ++ # } # sum += number # } # println ( sum )
size := len ( nums ) # # res := make ([] int , size ) # for i := range res { # res [ i ] = - 1 # } # # stack := make ([] int , 0 , size ) # # for i := 0 ; i < size * 2 ; i ++ { # for len ( stack ) > 0 && nums [ stack [ len ( stack )- 1 ]] < nums [ i % size ] { # res [ stack [ len ( stack )- 1 ]] = nums [ i % size ] # stack = stack [: len ( stack )- 1 ] # } # stack = append ( stack , i % size ) # } # # return res
qs := [] question 1 2 0 { # { # para 1 2 0 {[][] int {{ 2 }, { 3 , 4 }, { 6 , 5 , 7 }, { 4 , 1 , 8 , 3 }}}, # ans 1 2 0 { 1 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 0 , q . para 1 2 0 # fmt . Printf (" STR ", p , minimumTotal ( p . one )) # } # fmt . Printf (" STR ")
if 0 == x { # return x # } # # isPositive := true # if x < 0 { # isPositive = false # x *= - 1 # } # # res := 0 # # for x > 0 { # res = res * 1 0 + x % 1 0 # x /= 1 0 # } # # if ! isPositive { # res *= - 1 # } # # if res < - 1 << 3 1 || res > ( 1 << 3 1 )- 1 { # return 0 # } # return res
cases := [] struct { # name string # input 1 [] int # input 2 int # expect [][] int # }{ # {" STR ", # [] int { 1 , 0 , - 1 , 0 , - 2 , 2 }, # 0 , # [][] int { # {- 1 , 0 , 0 , 1 }, # {- 2 , - 1 , 1 , 2 }, # {- 2 , 0 , 0 , 2 }, # }}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := fourSum 1 ( c . input 1 , c . input 2 ) # fmt . Println ( got ) # }) # }
if l 1 == nil { # return l 2 # } else if l 2 == nil { # return l 1 # } # var head * ListNode # if l 1 . Val < l 2 . Val { # head = l 1 # head . Next = mergeTwoLists ( l 1 . Next , l 2 ) # } else { # head = l 2 # head . Next = mergeTwoLists ( l 2 . Next , l 1 ) # } # return head
m := 0 # t := & trie {} # for _ , w := range words { # m = max ( m , len ( w )) # t . insert ( w ) # } # return StreamChecker { # trie : t , # stream : make ([] int 8 , 0 , 1 0 2 4 ), # }
if root == nil { # return 0 # } # return max ( maxDepth ( root . Left ), maxDepth ( root . Right )) + 1
tests := [...] testType { # { # in : " STR ", # wordDict : [] string {" STR ", " STR "}, # want : true , # }, # { # in : " STR ", # wordDict : [] string {" STR ", " STR "}, # want : true , # }, # { # in : " STR ", # wordDict : [] string {" STR ", " STR ", " STR ", " STR ", " STR "}, # want : false , # }, # } # for _ , tt := range tests { # got := wordBreak ( tt . in , tt . wordDict ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
result := make ([] int , row + 1 ) # for entry := range result { # result [ entry ] = combinations ( row , entry ) # } # return result
total := 0 # for _ , val := range vals { # total += val # } # return total
fmt . Println (" STR ", d . Line ) # return nil
st := set { # elements : make ( map [ interface {}] bool ), # } # for _ , item := range items { # st . Add ( item ) # } # return & st
return writer { # w : w , # writes : make ( map [ string ] struct {}), # }
t . Parallel () # # for _ , tc := range testcases { # copied := append ([] int {}, tc . input ...) # # if result := LongestConsecutiveSequenceBrute ( copied ); result != tc . lcs { # t . Errorf (" STR ", tc . lcs , result ) # } # }
cases := [] struct { # name string # inputs string # expect string # }{ # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := reverseWords ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
pointer := head # count := 1 # if head == nil || head . Next == nil { # return head # } # for pointer != nil { # if pointer . Next == nil { # pointer . Next = head # break # } # pointer = pointer . Next # count ++ # } # rem := count - k % count # for rem > 0 { # pointer = pointer . Next # rem -- # } # ans := pointer . Next # pointer . Next = nil # return ans
res := 0 # m := 1 # for m <= n { # res += ( n / m + 8 ) / 1 0 * m # if n / m % 1 0 == 1 { # res += n % m + 1 # } # m *= 1 0 # } # return res
StoreUint 1 6 (& r . Reg , LoadUint 1 6 (& r . Reg )| value )
if s == '/' { # return true # } # return false
return len (* h ) - 1
filepath . Walk ( dir , func ( path string , info os . FileInfo , err error ) error { # if info . IsDir () { # return nil # } # # fileNameChannel <- path # # return nil # }) # close ( fileNameChannel )
letters := make ( map [ rune ] struct {}, 1 0 ) # for _ , part := range [] string { first , second , result } { # for _ , r := range part { # letters [ r ] = struct {}{} # } # } # if len ( letters ) > 1 0 { # return nil # } # runes := make ([] rune , 0 , len ( letters )) # for r := range letters { # runes = append ( runes , r ) # } # sort . Slice ( runes , func ( i , j int ) bool { # return runes [ i ] < runes [ j ] # }) # availDigits := make ([] bool , 1 0 ) # for i := 0 ; i < 1 0 ; i ++ { # availDigits [ i ] = true # } # return backtrackingSearch ( runes , make ( map [ rune ] int ), availDigits , first , second , result )
fmt . Println ( strStr (" STR ", " STR "))
runes := [] rune ( str ) # # return lpsBrute ( runes )
a := math . Sqrt ( 5 ) / 5 # b := math . Pow (( 1 + math . Sqrt ( 5 ))/ 2 , float 6 4 ( n )) # c := math . Pow (( 1 - math . Sqrt ( 5 ))/ 2 , float 6 4 ( n )) # return int ( a *( b - c )) % 1 0 0 0 0 0 0 0 0 7
safeComps := make ([] string , 0 , len ( fileInfoComponents )) # for _ , comp := range fileInfoComponents { # safeComps = append ( safeComps , filepath . Clean ( comp )) # } # safeFilePath := filepath . Join ( safeComps ...) # fc := firstComponent ( safeFilePath ) # switch fc { # case " STR ": # return " STR " # default : # return safeFilePath , nil # }
var matcher defaultMatcher # Register (" STR ", matcher )
result = new ( big . Int ) # switch n . Cmp (& big . Int {}) { # case - 1 , 0 : # result . SetInt 6 4 ( 1 ) # default : # result . Set ( n ) # var one big . Int # one . SetInt 6 4 ( 1 ) # result . Mul ( result , factorial ( n . Sub ( n , & one ))) # } # return
defer wg . Done () # var input float 6 4 # for v := range in { # input = float 6 4 ( v ) # Phi := ( 1 + math . Sqrt ( 5 )) / 2 # phi := ( 1 - math . Sqrt ( 5 )) / 2 # result := ( math . Pow ( Phi , input ) - math . Pow ( phi , input )) / math . Sqrt ( 5 ) # out <- fibvalue { # input : v , # value : int ( result ), # } # } # close ( out )
c := Codec {} # s := c . serialize (& Node { # Val : 1 , # Children : []* Node { # { # Val : 1 , # Children : nil , # }, # { # Val : 2 , # Children : []* Node { # { # Val : 3 , # Children : nil , # }, # { # Val : 4 , # Children : []* Node { # { # Val : 5 , # Children : []* Node { # { # Val : 6 , # Children : nil , # }, # { # Val : 7 , # Children : nil , # }, # }, # }, # }, # }, # }, # }, # }, # }) # println ( s ) # a := c . deserialize ( s ) # fmt . Printf (" STR ", c . serialize ( a ))
qs := [] question 4 9 1 { # # { # para 4 9 1 {[] int { 4 , 3 , 2 , 1 }}, # ans 4 9 1 {[][] int {}}, # }, # # { # para 4 9 1 {[] int { 4 , 6 , 7 , 7 }}, # ans 4 9 1 {[][] int {{ 4 , 6 }, { 4 , 7 }, { 4 , 6 , 7 }, { 4 , 6 , 7 , 7 }, { 6 , 7 }, { 6 , 7 , 7 }, { 7 , 7 }, { 4 , 7 , 7 }}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 9 1 , q . para 4 9 1 # fmt . Printf (" STR ", p , findSubsequences ( p . one )) # } # fmt . Printf (" STR ")
return MyCalendarThree { # events : [][ 2 ] int {}, # }
dto := PersonDTO { ID : p . ID , Name : p . Name , DateOfBirth : p . DateOfBirth } # return dto
return float 3 2 (^ uint 3 2 ( 0 ))
symmetricDifferenceSet := New () # dropSet := New () # for _ , item := range st . GetItems () { # if st 2 . In ( item ) { # dropSet . Add ( item ) # } else { # symmetricDifferenceSet . Add ( item ) # } # } # for _ , item := range st 2 . GetItems () { # if ! dropSet . In ( item ) { # symmetricDifferenceSet . Add ( item ) # } # } # return symmetricDifferenceSet
for b != 0 { # temp := b # b = a % b # a = temp # } # return a
low , high := 0 , len ( arr )- 1 # for low <= high { # mid := low + ( high - low )/ 2 # if arr [ mid ] < target { # low = mid + 1 # continue # } # # if arr [ mid ] > target { # high = mid - 1 # continue # } # return mid # } # return - 1
sort . Ints ( nums ) # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] == nums [ i - 1 ] { # return nums [ i ] # } # } # return 0
const max = 9 9 9 # const min = 9 9 # mul := max * max # # for i := mul ; i > 0 ; i -- { # if i == reverse ( i ) { # for j := max ; j > min ; j -- { # if i % j == 0 && i / j < max { # fmt . Println ( i ) # os . Exit ( 0 ) # } # } # } # }
n := len ( s ) # res := [][] string {} # var dfs func ( int , [] string ) # dfs = func ( index int , l [] string ) { # if index == n { # tmp := make ([] string , len ( l )) # copy ( tmp , l ) # res = append ( res , tmp ) # return # } # # for i := index ; i < n ; i ++ { # if check ( s [ index : i + 1 ]) { # dfs ( i + 1 , append ( l , s [ index : i + 1 ])) # } # } # } # dfs ( 0 , make ([] string , 0 , n )) # return res
if r := l . next (); r != " STR " { # return l . error (" STR ") # } # l . ignore () # for { # switch r := l . next (); { # case unicode . IsNumber ( r ): # case r == " STR ": # l . backup () # if l . pos == l . start { # return l . error (" STR ") # } # l . emit ( itemEnd ) # return byteLen # case r == eof : # return l . error (" STR ") # default : # return l . error (" STR ") # } # }
var currentChar byte # var currentCharCnt int # var totalAbsentCnt int # for i := 0 ; i < len ( s ); i ++ { # if s [ i ] == currentChar { # currentCharCnt ++ # } else { # currentChar = s [ i ] # currentCharCnt = 1 # } # # if currentChar == ' L ' && currentCharCnt > 2 { # return false # } # # if currentChar == ' A ' { # totalAbsentCnt ++ # if totalAbsentCnt > 1 { # return false # } # } # } # return true
m , n := len ( A ), len ( B ) # res := 0 # for k := 0 ; k < n ; k ++ { # tmp := 0 # for i , j := 0 , k ; i < m && j < n ; i , j = i + 1 , j + 1 { # if A [ i ] == B [ j ] { # tmp ++ # res = max ( res , tmp ) # } else { # tmp = 0 # } # } # } # for k := 1 ; k < m ; k ++ { # tmp := 0 # for i , j := k , 0 ; i < m && j < m ; i , j = i + 1 , j + 1 { # if A [ i ] == B [ j ] { # tmp ++ # res = max ( res , tmp ) # } else { # tmp = 0 # } # } # } # return res
m := make ([] int , 2 6 ) # for _ , b := range magazine { # m [ b -' a ']++ # } # # for _ , b := range ransomNote { # m [ b -' a ']-- # if m [ b -' a '] < 0 { # return false # } # } # return true
var i uint 3 2 # if v { # i = 1 # } # StoreUint 3 2 (& r . Reg , i )
if len ( nums ) == 0 || k == 0 { # return [] int {} # } else if k == 1 { # return nums # } # queue , ans := list . New (), make ([] int , len ( nums )- k + 1 ) # # for left , right := 1 - k , 0 ; right < len ( nums ); left , right = left + 1 , right + 1 { # if left > 0 && queue . Front (). Value .( int ) == nums [ left - 1 ] { # queue . Remove ( queue . Front ()) # } # for queue . Len () != 0 && queue . Back (). Value .( int ) < nums [ right ] { # queue . Remove ( queue . Back ()) # } # queue . PushBack ( nums [ right ]) # if left >= 0 { # ans [ left ] = queue . Front (). Value .( int ) # } # } # return ans
count := 0 # for num != 0 { # count ++ # num &= num - 1 # } # return count
dummy := & ListNode {} # node := dummy # for l 1 != nil && l 2 != nil { # if l 1 . Val < l 2 . Val { # node . Next = l 1 # node , l 1 = node . Next , l 1 . Next # } else { # node . Next = l 2 # node , l 2 = node . Next , l 2 . Next # } # } # # if l 1 == nil { # node . Next = l 2 # } else { # node . Next = l 1 # } # # return dummy . Next
if stack . depth > 0 { # item := stack . sp . item # stack . sp = stack . sp . next # stack . depth -- # return item # } # # return nil
if n / 5 == 0 { # return 0 # } # return n / 5 + trailingZeroes ( n / 5 )
qs := [] question 6 5 8 { # # { # para 6 5 8 {[] int { 1 , 2 , 3 , 4 , 5 }, 4 , 3 }, # ans 6 5 8 {[] int { 1 , 2 , 3 , 4 }}, # }, # # { # para 6 5 8 {[] int { 1 , 2 , 3 , 4 , 5 }, 4 , - 1 }, # ans 6 5 8 {[] int { 1 , 2 , 3 , 4 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 5 8 , q . para 6 5 8 # fmt . Printf (" STR ", p , findClosestElements ( p . arr , p . k , p . x )) # } # fmt . Printf (" STR ")
if A . cols != B . cols && A . rows != B . rows { # return errors . New (" STR ") # } # for i := 0 ; i < A . rows ; i ++ { # for j := 0 ; j < A . cols ; j ++ { # A . SetElm ( i , j , A . GetElm ( i , j )+ B . GetElm ( i , j )) # } # } # # return nil
r := 0 # # j , k := 1 , 0 # for r < 4 e 6 { # f := j + k # if f % 2 == 0 { # r += f # } # # k = j # j = f # } # # fmt . Println (" STR ", r )
max 1 , max 2 , max 3 := math . MinInt 6 4 , math . MinInt 6 4 , math . MinInt 6 4 # n := len ( nums ) # if n == 0 { # return 0 # } # if n == 1 { # return nums [ 0 ] # } # for i := 0 ; i < n ; i ++ { # if nums [ i ] >= max 1 { # if nums [ i ] != max 1 { # max 3 , max 2 , max 1 = max 2 , max 1 , nums [ i ] # } # } else if nums [ i ] >= max 2 { # if nums [ i ] != max 2 { # max 3 , max 2 = max 2 , nums [ i ] # } # } else if nums [ i ] > max 3 { # max 3 = nums [ i ] # } # } # if max 3 != math . MinInt 6 4 { # return max 3 # } else { # return max 1 # }
l , r := 0 , len ( nums )- 1 # for i := l ; i <= r ; i ++ { # for i < r && nums [ i ] > 1 { # nums [ i ], nums [ r ] = nums [ r ], nums [ i ] # r -- # } # for i > l && nums [ i ] < 1 { # nums [ l ], nums [ i ] = nums [ i ], nums [ l ] # l ++ # } # }
if list . rear == nil { # return 0 , false # } # if list . rear . next == nil { # i := list . rear . data # list . rear = nil # return i , true # } # current := list . rear # for { # if current . next . next == nil { # i := current . next . data # current . next = nil # return i , true # } # current = current . next # }
* x = * x * * x
n := len ( prices ) # dp := make ([][] int , 0 ) # for i := 0 ; i <= n ; i ++ { # dp = append ( dp , make ([] int , 2 )) # } # dp [ 0 ][ 0 ], dp [ 0 ][ 1 ] = 0 , math . MinInt 3 2 # profit_max := 0 # for i := 0 ; i < n ; i ++ { # dp [ i + 1 ][ 0 ] = max ( dp [ i ][ 1 ]+ prices [ i ], dp [ i ][ 0 ]) # dp [ i + 1 ][ 1 ] = max ( dp [ i ][ 0 ]- prices [ i ], dp [ i ][ 1 ]) # # profit_max = max ( profit_max , dp [ i + 1 ][ 0 ]) # profit_max = max ( profit_max , dp [ i + 1 ][ 1 ]) # } # return profit_max
res := uint ( 0 ) # # for m >= 1 && n >= 1 { # if m == n { # return m << res # } # m >>= 1 # n >>= 1 # res ++ # } # return 0
N := len ( word ) # dp := make ([][] int , N ) # # for i := 0 ; i < N ; i ++ { # dp [ i ] = make ([] int , N ) # dp [ i ][ i ] = 1 # } # # for l := 2 ; l <= N ; l ++ { # for i := 0 ; i < N - l + 1 ; i ++ { # j := i + l - 1 # if word [ i ] == word [ j ] { # if l == 2 { # dp [ i ][ j ] = 2 # } else { # dp [ i ][ j ] = 2 + dp [ i + 1 ][ j - 1 ] # } # } else { # dp [ i ][ j ] = Max ( dp [ i + 1 ][ j ], dp [ i ][ j - 1 ]) # } # } # } # # return dp [ 1 ][ N - 1 ]
qs := [] question 9 4 6 { # { # para 9 4 6 {[] int { 1 , 2 , 3 , 4 , 5 }, [] int { 5 , 4 , 3 , 2 , 1 }}, # ans 9 4 6 { true }, # }, # # { # para 9 4 6 {[] int { 1 , 2 , 3 , 4 , 5 }, [] int { 4 , 3 , 5 , 1 , 2 }}, # ans 9 4 6 { false }, # }, # # { # para 9 4 6 {[] int { 1 , 0 }, [] int { 1 , 0 }}, # ans 9 4 6 { true }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 4 6 , q . para 9 4 6 # fmt . Printf (" STR ", p , validateStackSequences ( p . one , p . two )) # } # fmt . Printf (" STR ")
t . Parallel () # root := & Node { val : 2 0 , # left : nil , # right : & Node { val : 8 , left : nil , # right : & Node { val : 1 0 , left : nil , # right : & Node { val : 5 }}}, # } # expected := " STR " # var result string # if result = Serialize ( root ); result != expected { # t . Errorf (" STR ", expected , result ) # } # if root 2 := Deserialize ( result ); ! TreeEquality ( root , root 2 ) { # t . Error (" STR ") # }
if num <= 0 { # return false # } # # if num <= 6 { # return true # } # # if num % 2 == 0 { # return isUgly ( num / 2 ) # } # # if num % 3 == 0 { # return isUgly ( num / 3 ) # } # # if num % 5 == 0 { # return isUgly ( num / 5 ) # } # # return false
segs := strings . Split ( s , " STR ") # for i := len ( segs ) - 1 ; i >= 0 ; i -- { # seg := segs [ i ] # if len ( seg ) > 0 { # return len ( seg ) # } # } # # return 0
if e . end > curr . start && curr . end > e . start { # return false # } # if curr . start < e . start { # if e . left == nil { # e . left = curr # } else { # return e . left . Insert ( curr ) # } # } else { # if e . right == nil { # e . right = curr # } else { # return e . right . Insert ( curr ) # } # } # return true
n := len ( nums ) # if n <= 2 { # return n # } # # res := 2 # for i := 2 ; i < n ; i ++ { # if nums [ i ] != nums [ res - 2 ] { # nums [ res ] = nums [ i ] # res ++ # } # } # return res
fmt . Println ( MaxInt ( 5 , 6 )) # fmt . Println ( MaxInt (- 1 , - 1 0 0 )) # fmt . Println ( MaxInt ( 1 0 , 1 0 ))
if root == nil { # return 0 # } # dfs ( root , 1 ) # level := 0 # for l := range m { # if m [ l ] > m [ level ] { # level = 1 # } # } # return level
tests := [...] testType { # { # in : " STR ", # want : nil , # }, # { # in : " STR ", # want : [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # }, # } # for _ , tt := range tests { # got := letterCombinations ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
t . Parallel () # for _ , tc := range testcases { # if r , e := FirstRecurringRune ( tc . s ); r != tc . expected || e != tc . expectedErr { # t . Errorf (" STR ", tc . expected , tc . expectedErr , r , e ) # } # }
if len ( s . data ) > 0 { # val := s . data [ 0 ] # s . data = s . data [ 1 :] # return val # } # return " STR "
pair := len ( nums ) / 2 # start , end := 0 , pair - 1 # for start <= end { # mid := ( start + end ) / 2 # if nums [ mid * 2 ] != nums [ mid * 2 + 1 ] { # if mid == 0 || nums [ 2 *( mid - 1 )] == nums [ 2 *( mid - 1 )+ 1 ] { # return nums [ 2 * mid ] # } # # end = mid - 1 # } else { # start = mid + 1 # } # } # # return nums [ len ( nums )- 1 ]
return towerOfHanoi ( disks , 1 , 3 , 2 )
start , end := 0 , len ( hops )- 1 # for start < end { # if hops [ start ] == 0 { # break # } # start += hops [ start ] # } # return start == end
fmt . Println ( nthPermutation ( 9 9 9 9 9 9 ))
qs := [] question 2 1 2 { # # { # para 2 1 2 {[][] byte { # {' A ', ' B ', ' C ', ' E '}, # {' S ', ' F ', ' C ', ' S '}, # {' A ', ' D ', ' E ', ' E '}, # }, [] string {" STR ", " STR ", " STR "}}, # ans 2 1 2 {[] string {" STR ", " STR "}}, # }, # # { # para 2 1 2 {[][] byte { # {' o ', ' a ', ' a ', ' n '}, # {' e ', ' t ', ' a ', ' e '}, # {' i ', ' h ', ' k ', ' r '}, # {' i ', ' f ', ' l ', ' v '}, # }, [] string {" STR ", " STR ", " STR ", " STR "}}, # ans 2 1 2 {[] string {" STR ", " STR "}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 1 2 , q . para 2 1 2 # fmt . Printf (" STR ", p , findWords ( p . b , p . word )) # } # fmt . Printf (" STR ")
println (" STR ")
cases := [] struct { # name string # input 1 float 6 4 # input 2 int # expect float 6 4 # }{ # {" STR ", 2 . 0 0 0 0 0 , 1 0 , 1 0 2 4 . 0 0 0 0 0 }, # {" STR ", 2 . 1 0 0 0 0 , 3 , 9 . 2 6 1 0 0 }, # {" STR ", 2 . 0 0 0 0 0 , - 2 , 0 . 2 5 0 0 0 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := fmt . Sprintf (" STR ", myPow 2 ( c . input 1 , c . input 2 )) # if ! reflect . DeepEqual ( got , fmt . Sprintf (" STR ", c . expect )) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 , c . input 2 ) # } # }) # }
colors := make ([] int , len ( graph )) # # var color func ( int ) bool # color = func ( i int ) bool { # for _ , j := range graph [ i ] { # if colors [ j ] == 0 { # colors [ j ] = - colors [ i ] # if ! color ( j ) { # return false # } # } else if colors [ i ] == colors [ j ] { # return false # } # } # return true # } # for i := range graph { # if colors [ i ] == 0 { # colors [ i ] = 1 # if ! color ( i ) { # return false # } # } # } # return true
type Collar struct { # Engraving string # } # # type Dog struct { # Name string # Collar * Collar # } # # type Person struct { # Name string # Dog * Dog # } # # person := & Person { # Name : " STR ", # } # # personWithDog := & Person { # Name : " STR ", # Dog : & Dog { # Name : " STR ", # }, # } # # personWithDogWithCollar := & Person { # Name : " STR ", # Dog : & Dog { # Name : " STR ", # Collar : & Collar { # Engraving : " STR ", # }, # }, # } # # defer func () { # err := recover () # if err != nil { # fmt . Printf (" STR ", err ) # t . Error (" STR ") # } # }() # # _ = Map ( person ) # _ = Map ( personWithDog ) # _ = Map ( personWithDogWithCollar )
s . stack = append ( s . stack , n )
t := new ( DisjointSet ) # t . Value = value # t . p = t # t . rank = 0 # return t
var showArr [] string # for i := 0 ; i < num ; i ++ { # showArr = append ( showArr , show ) # } # return strings . Join ( showArr , " STR ")
t . Parallel () # for _ , tc := range testcases { # if cousins := FindCousins ( tc . root , tc . node ); ! reflect . DeepEqual ( cousins , tc . cousins ) { # t . Errorf (" STR ", tc . cousins , cousins ) # } # }
slow , fast := head , head . Next # for slow != nil && fast != nil && fast . Next != nil { # slow = slow . Next # fast = fast . Next . Next # } # return slow
var ( # stacks [] rune # mapping = map [ rune ] rune {')': '(', ']': '[', '}': '{'} # ) # for _ , char := range s { # if char == ')' || char == '}' || char == ']' { # var topElement rune # if len ( stacks ) > 0 { # topElement = stacks [ len ( stacks )- 1 ] # stacks = stacks [: len ( stacks )- 1 ] # } else { # topElement = '#' # } # if mapping [ char ] != topElement { # return false # } # } else { # stacks = append ( stacks , char ) # } # }
if len ( nums ) < 2 { # return 0 # } # res := make ( map [ int ] int , len ( nums )) # for _ , num := range nums { # if _ , exist := res [ num ]; exist { # res [ num ]++ # continue # } # res [ num ] = 1 # } # longest := 0 # for k , c := range res { # if n , exist := res [ k + 1 ]; exist { # if c + n > longest { # longest = c + n # } # } # } # return longest
if len ( nums ) < 1 { # return 0 # } # # count , flag := 1 , nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # if count < 1 { # flag = nums [ i ] # count = 1 # continue # } # if nums [ i ] == flag { # count ++ # } else { # count -- # } # } # return flag
return dfs ( nil , 0 , 1 , num )
rightAnswer := findRight ( grid ) # downAnswer := findDown ( grid ) # diagRight := findDiagRight ( grid ) # diagDown := findDiagLeft ( grid ) # var answer int # # if ( rightAnswer > downAnswer && rightAnswer > diagRight && rightAnswer > diagDown ){ # answer = rightAnswer # } else if ( downAnswer > rightAnswer && downAnswer > diagRight && downAnswer > diagDown ){ # answer = downAnswer # } else if ( diagRight > rightAnswer && diagRight > downAnswer && diagRight > diagDown ){ # answer = diagRight # } else { # answer = diagDown # } # # fmt . Println ( answer )
i := sort . Search ( n , func ( i int ) bool { # if i + 1 >= n { # return true # } # return bytes . Compare ( ip , first ( i + 1 )) < 0 # }) # if i == n { # return # } # r = full ( i ) # ok = bytes . Compare ( r . First , ip ) <= 0 && bytes . Compare ( ip , r . Last ) <= 0 # return
cmd := & CmdLine {} # # flag . Usage = cmd . PrintHelpMessage # flag . BoolVar (& cmd . help , " STR ", false , " STR ") # flag . BoolVar (& cmd . help , " STR ", false , " STR ") # flag . BoolVar (& cmd . version , " STR ", false , " STR ") # flag . StringVar (& cmd . jre , " STR ", " STR ") # flag . StringVar (& cmd . classpath , " STR ", " STR ") # flag . StringVar (& cmd . classpath , " STR ", " STR ") # # flag . Parse () # # args := flag . Args () # if len ( args ) > 0 { # cmd . class = args [ 0 ] # cmd . args = args [ 1 :] # } # # return cmd
ans , m := make ([] int , len ( queries )), make ([] int , len ( words )) # for i , w := range words { # m [ i ] = f ( w ) # } # sort . Ints ( m ) # for i , q := range queries { # t := f ( q ) # for j := len ( m ) - 1 ; j >= 0 ; j -- { # if t >= m [ j ] { # break # } # ans [ i ]++ # } # } # return ans
size := len ( nums ) # count := make ( map [ int ] int , size ) # next := make ( map [ int ] int , size ) # for i := range nums { # count [ nums [ i ]]++ # } # # for _ , n := range nums { # if count [ n ] == 0 { # continue # } # count [ n ]-- # # if next [ n ] > 0 { # next [ n ]-- # next [ n + 1 ]++ # } else if count [ n + 1 ] > 0 && count [ n + 2 ] > 0 { # count [ n + 1 ]-- # count [ n + 2 ]-- # next [ n + 3 ]++ # } else { # return false # } # # } # # return true
upper := 9 9 9 # biggestPalindrome := upper * upper # L : # for ; biggestPalindrome > 1 ; biggestPalindrome -- { # if numIsPalindrome ( biggestPalindrome ) { # m := makePrimeSlice ( 1 , biggestPalindrome ) # if checkSlice ( upper , m ) { # fmt . Println (" STR ", biggestPalindrome , m ) # break L # } else { # fmt . Println (" STR ", biggestPalindrome , m ) # } # # } # }
var buffer bytes . Buffer # buffer . WriteString (" STR ") # for i := 1 ; i <= maxn ; i ++ { # buffer . WriteString ( strconv . Itoa ( i )) # } # return buffer . String ()
var tests = [] struct { # nums [] int # k int # duplicate bool # }{ # {[] int { 9 9 , 9 9 }, 2 , true }, # {[] int { 1 , 2 , 3 , 1 }, 3 , true }, # {[] int { 1 , 0 , 1 , 1 }, 1 , true }, # {[] int { 1 , 2 , 3 , 1 , 2 , 3 }, 2 , false }, # } # # for _ , tt := range tests { # duplicate := containsNearbyDuplicate ( tt . nums , tt . k ) # if duplicate != tt . duplicate { # t . Errorf (" STR ", tt . nums , tt . k , duplicate , tt . duplicate ) # } # }
seen := make ( map [ int ] int ) # for { # if _ , ok := seen [ n ]; ok { # return true # } # seen [ n ] = - 1 # n = squareSum ( n ) # if n == 1 { # return true # } # }
send := func ( i big . Int ) { # ch <- len ( i . String ()) # } # # fibseq := [ 3 ] big . Int {} # fibseq [ 0 ]. Set ( big . NewInt ( 1 )) # fibseq [ 1 ]. Set ( big . NewInt ( 1 )) # fibseq [ 2 ]. Set ( big . NewInt ( 2 )) # send ( fibseq [ 0 ]) # send ( fibseq [ 1 ]) # send ( fibseq [ 2 ]) # for { # fibseq [ 0 ]. Set (& fibseq [ 1 ]) # fibseq [ 1 ]. Set (& fibseq [ 2 ]) # fibseq [ 2 ]. Add (& fibseq [ 0 ], & fibseq [ 1 ]) # send ( fibseq [ 2 ]) # } #
h := t . Head # n := & Node { Value : i } # # for h != nil { # switch h . Compare ( n ) { # case - 1 : # h = h . Right # case 1 : # h = h . Left # case 0 : # return h # default : # panic (" STR ") # } # } # panic (" STR ")
str := [] byte ( s ) # l := len ( str ) # if l == 0 { # return " STR " # } # dp := make ([][] bool , l ) # for k := range dp { # dp [ k ] = make ([] bool , l ) # } # ret := [] byte {} # max := 0 # for i := l - 1 ; i >= 0 ; i -- { # for j := i ; j < l ; j ++ { # if str [ i ] == str [ j ] && ( j - i <= 2 || dp [ i + 1 ][ j - 1 ]) { # dp [ i ][ j ] = true # if max < j - i + 1 { # max = j - i + 1 # ret = str [ i : j + 1 ] # } # } # } # } # return string ( ret )
return e . Msg + " STR " + e . File + " STR " + e . Err . Error ()
res := 0 # for i := 0 ; i < len ( points ); i ++ { # record := make ( map [ int ] int , len ( points )) # for j := 0 ; j < len ( points ); j ++ { # if j != i { # record [ dis ( points [ i ], points [ j ])]++ # } # } # for _ , r := range record { # res += r * ( r - 1 ) # } # } # return res
a := [] float 6 4 { 1 , 1 , 1 , 1 } # A := MakeMatrix ( a , 2 , 2 ) # B := MakeMatrix ([] float 6 4 { 2 , 2 , 2 , 2 }, 2 , 2 ) # # A . add ( A ) # if ! FloatArrayEquals ( A . Elements , B . Elements ) { # t . Error () # }
var tests = [] struct { # array [] int # tree * TreeNode # }{ # {[] int {- 1 0 , - 3 , 0 , 5 , 9 }, newTree ( 0 , - 3 , 9 , - 1 0 , nil , 5 )}, # } # # for _ , tt := range tests { # tree := sortedArrayToBST ( tt . array ) # if reflect . DeepEqual ( tree , tt . tree ) == false { # t . Errorf (" STR ", tt . array , tree , tt . tree ) # } # }
ans , idx := make ([] int , n ), [ 3 ] int {} # ans [ 0 ] = 1 # for i := 1 ; i < n ; i ++ { # for j , n := range [...] int { 2 , 3 , 5 } { # if ans [ idx [ j ]]* n <= ans [ i - 1 ] { # idx [ j ]++ # } # if num := ans [ idx [ j ]] * n ; j == 0 { # ans [ i ] = num # } else if ans [ i ] > num { # ans [ i ] = num # } # } # } # return ans [ n - 1 ]
jobs , dp := [] job {}, make ([] int , len ( startTime )) # for i := 0 ; i < len ( startTime ); i ++ { # jobs = append ( jobs , job { startTime : startTime [ i ], endTime : endTime [ i ], profit : profit [ i ]}) # } # sort . Sort ( sortJobs ( jobs )) # dp [ 0 ] = jobs [ 0 ]. profit # for i := 1 ; i < len ( jobs ); i ++ { # low , high := 0 , i - 1 # for low < high { # mid := low + ( high - low )>> 1 # if jobs [ mid + 1 ]. endTime <= jobs [ i ]. startTime { # low = mid + 1 # } else { # high = mid # } # } # if jobs [ low ]. endTime <= jobs [ i ]. startTime { # dp [ i ] = max ( dp [ i - 1 ], dp [ low ]+ jobs [ i ]. profit ) # } else { # dp [ i ] = max ( dp [ i - 1 ], jobs [ i ]. profit ) # } # } # return dp [ len ( startTime )- 1 ]
solutions := make ( map [ int ] int ) # # for p := 1 0 0 0 ; p >= 5 ; p -- { # for a := 1 ; a < 9 9 8 ; a ++ { # for b := 1 ; b <= p - a ; b ++ { # a 2 := math . Pow ( float 6 4 ( a ), 2 ) # b 2 := math . Pow ( float 6 4 ( b ), 2 ) # c := p - ( a + b ) # c 2 := math . Pow ( float 6 4 ( c ), 2 ) # # if ( a 2 + b 2 ) == c 2 { # solutions [ p ] = solutions [ p ] + 1 # } # } # } # } # # maxVal := 0 # maxP := 0 # for k , v := range solutions { # if v > maxVal { # maxVal = v # maxP = k # } # } # # fmt . Println ( solutions ) # # return maxP
if self . version { # self . PrintVersionMessage () # } else if self . help || self . class == "" { # self . PrintHelpMessage () # } else { # fmt . Printf (" STR ", self . classpath , self . class , self . args ) # }
u := newUnion ( 2 6 ) # # for _ , e := range equations { # if e [ 1 ] == '=' { # u . unite ( e [ 0 ]-' a ', e [ 3 ]-' a ') # } # } # # for _ , e := range equations { # if e [ 1 ] == '!' && u . find ( e [ 0 ]-' a ') == u . find ( e [ 3 ]-' a ') { # return false # } # } # # return true
var tests = [] struct { # nums [] int # majority int # }{ # {[] int { 3 , 2 , 3 }, 3 }, # {[] int { 2 , 2 , 1 , 1 , 1 , 2 , 2 }, 2 }, # } # # for _ , tt := range tests { # majority := majorityElement ( tt . nums ) # if majority != tt . majority { # t . Errorf (" STR ", tt . nums , majority , tt . majority ) # } # }
newHead := head # for head . Next != nil { # next := head . Next # head . Next = next . Next # next . Next = newHead # newHead = next # } # return newHead
cache := make ( map [ string ][] int ) # var dfs func ( string ) [] int # dfs = func ( s string ) [] int { # if t , ok := cache [ s ]; ok { # return t # } # tmp := [] int {} # for i := 0 ; i < len ( s ); i ++ { # if s [ i ] == '+' || s [ i ] == '-' || s [ i ] == '*' { # for _ , l := range dfs ( s [: i ]) { # for _ , r := range dfs ( s [ i + 1 :]) { # tmp = append ( tmp , operate ( l , r , s [ i ])) # } # } # } # } # # if len ( tmp ) == 0 { # num , _ := strconv . Atoi ( s ) # tmp = append ( tmp , num ) # } # # cache [ s ] = tmp # return tmp # } # return dfs ( input )
qs := [] question 2 0 0 { # # { # para 2 0 0 {[][] byte { # {' 1 ', ' 1 ', ' 1 ', ' 1 ', ' 0 '}, # {' 1 ', ' 1 ', ' 0 ', ' 1 ', ' 0 '}, # {' 1 ', ' 1 ', ' 0 ', ' 0 ', ' 0 '}, # {' 0 ', ' 0 ', ' 0 ', ' 0 ', ' 0 '}, # }}, # ans 2 0 0 { 1 }, # }, # # { # para 2 0 0 {[][] byte { # {' 1 ', ' 1 ', ' 0 ', ' 0 ', ' 0 '}, # {' 1 ', ' 1 ', ' 0 ', ' 0 ', ' 0 '}, # {' 0 ', ' 0 ', ' 1 ', ' 0 ', ' 0 '}, # {' 0 ', ' 0 ', ' 0 ', ' 1 ', ' 1 '}, # }}, # ans 2 0 0 { 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 0 0 , q . para 2 0 0 # fmt . Printf (" STR ", p , numIslands ( p . one )) # } # fmt . Printf (" STR ")
s . mtx . Lock () # defer s . mtx . Unlock () # p , ok := s . m [ profileID ] # if ! ok { # return ErrNotFound # } # for _ , address := range p . Addresses { # if address . ID == a . ID { # return ErrAlreadyExists # } # } # p . Addresses = append ( p . Addresses , a ) # s . m [ profileID ] = p # return nil
println (" STR ", t . name )
if a < 0 { # return - a # } else { # return a # }
println (" STR ", s . a , s . b , s . c , s . d ) # test 4 b ( s 4 b ( s )) # test 4 bp ((* s 4 b )(& s ))
tests := [...] testType { # { # word 1 : [] string {" STR ", " STR "}, # word 2 : [] string {" STR ", " STR "}, # want : true , # }, # { # word 1 : [] string {" STR ", " STR "}, # word 2 : [] string {" STR ", " STR "}, # want : false , # }, # { # word 1 : [] string {" STR ", " STR ", " STR "}, # word 2 : [] string {" STR "}, # want : true , # }, # } # for _ , tt := range tests { # got := arrayStringsAreEqual ( tt . word 1 , tt . word 2 ) # if got != tt . want { # t . Fatalf (" STR ", tt . word 1 , tt . word 2 , got , tt . want ) # } # }
left := countLeaf ( root . Left ) # if left == k - 1 { # return root . Val # } else if left > k - 1 { # return kthSmallest ( root . Left , k ) # } else { # return kthSmallest ( root . Right , k - left - 1 ) # }
var tests = [] struct { # tree * TreeNode # vals [] int # }{ # { newTree ( 1 , nil , 2 , 3 ), [] int { 3 , 2 , 1 }}, # { newTree ( 7 , 3 , 6 , 1 , 2 , 4 , 5 ), [] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 }}, # } # # for _ , tt := range tests { # vals := postorderTraversal ( tt . tree ) # if reflect . DeepEqual ( vals , tt . vals ) == false { # t . Errorf (" STR ", tt . tree , vals , tt . vals ) # } # }
n := len ( bits ) # if 1 == n { # return true # } # # cur := 0 # flag := false # # for cur < n { # if 0 == bits [ cur ] { # cur ++ # } else { # cur += 2 # } # if cur == n - 1 { # flag = true # } # } # return flag
res := make ([] int , 1 , rowIndex + 1 ) # res [ 0 ] = 1 # if rowIndex == 0 { # return res # } # # for i := 0 ; i < rowIndex ; i ++ { # res = append ( res , 1 ) # for j := len ( res ) - 2 ; j > 0 ; j -- { # res [ j ] += res [ j - 1 ] # } # } # return res
x ^= y # # res := 0 # for x > 0 { # res += x & 1 # x >>= 1 # } # # return res
if root == nil { # return 0 # } # return 1 + countNodes ( root . Left ) + countNodes ( root . Right )
blocks := " STR " + strings . Join ( allowed , " STR ") # # var dfs func ( string , int , int ) bool # dfs = func ( bottom string , cur , length int ) bool { # if cur + 2 > length { # bottom = bottom [ length :] # length = len ( bottom ) # if length == 1 { # return true # } # return dfs ( bottom , 0 , length ) # } # # b := " STR " + bottom [ cur : cur + 2 ] # beg := 0 # for beg < len ( blocks ) { # index := strings . Index ( blocks [ beg :], b ) + beg # if index < beg { # break # } # beg = index + 4 # color := blocks [ index + 3 : index + 4 ] # if dfs ( bottom + color , cur + 1 , length ) { # return true # } # } # # return false # } # # return dfs ( bottom , 0 , len ( bottom ))
if size == len ( board ) { # return 1 # } # # var count int # # for i := 0 ; i < size ; i ++ { # board = append ( board , i ) # if isValid ( board ) { # count += NQueens ( size , board ) # } # # board = board [: len ( board )- 1 ] # } # # return count
e := NewEwma ( time . Duration ( 1 * time . Minute )) # # ts := time . Now () # e . Update ( 0 , ts ) # # e . Update ( 0 , ts . Add (- 1 * time . Second )) # if e . Current != 0 { # t . Error (" STR ") # } # # e . UpdateNow ( 0 ) # if e . Current != 0 { # t . Error (" STR ") # }
tests := [...] testType { # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := reverseWords ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
var tests = [] struct { # grid [][] byte # num int # }{ # { # [][] byte { # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # }, 1 , # }, # { # [][] byte { # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # }, 3 , # }, # } # # for _ , tt := range tests { # num := numIslands ( tt . grid ) # if num != tt . num { # t . Errorf (" STR ", tt . grid , num , tt . num ) # } # }
if t . p > 0 { # t . p -- # } # if t . p == 0 { # t . finishTime = *( t . clk ) # }
benchmarkFramework ( b , SelectionSort )
count := 0 # for 0 < num { # if num % 2 == 1 { # count ++ # } # num /= 2 # } # return count
size := len ( S ) # a := s 2 is ( S ) # shift := 0 # for i := size - 1 ; 0 <= i ; i -- { # shift += shifts [ i ] # shift %= 2 6 # a [ i ] = ( a [ i ] + shift ) % 2 6 # } # return is 2 s ( a )
res = 0 # last = nil # dfs ( root ) # return res
var nodes [] int # for head != nil { # nodes = append ( nodes , head . Val ) # head = head . Next # } # ans := make ([] int , len ( nodes )) # if len ( nodes ) == 0 { # return ans # } # var stack [] int # for i := 0 ; i < len ( nodes ); i ++ { # for len ( stack ) > 0 && nodes [ stack [ len ( stack )- 1 ]] < nodes [ i ] { # ans [ stack [ len ( stack )- 1 ]] = nodes [ i ] # stack = stack [: len ( stack )- 1 ] # } # stack = append ( stack , i ) # } # return ans
var s int # for _ , c := range m . cache { # s += c . Clear () # } # return s
trie := Constructor () # trie . Insert (" STR ") # trie . Search (" STR ") # trie . Search (" STR ") # trie . StartsWith (" STR ") # trie . Insert (" STR ") # trie . Search (" STR ")
this . mutex . Lock () # defer this . mutex . Unlock () # this . list . Init ()
if numRows < 2 || len ( s ) <= numRows { # return s # } # rows := make ([][] byte , numRows ) # for i := range rows { # rows [ i ] = [] byte {} # } # var direct , row int # bottom := numRows - 1 # for _ , v := range s { # rows [ row ] = append ( rows [ row ], byte ( v )) # if row == 0 { # direct = 1 # } else if row == bottom { # direct = - 1 # } # row += direct # } # result := make ([] byte , 0 , len ( s )) # for _ , v := range rows { # result = append ( result , v ...) # } # return string ( result )
t . Parallel () # for _ , tc := range testcases { # if result := GcdSlice ( tc . nums ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result , tc . nums ) # } # }
x := [] int { 1 0 , 2 0 , 3 0 } # fmt . Printf (" STR ", len ( x ), cap ( x )) # y := make ([] int , 5 , 1 0 ) # copy ( y , x ) # fmt . Printf (" STR ", len ( y ), cap ( y )) # fmt . Println (" STR ", y ) # y [ 3 ] = 4 0 # y [ 4 ] = 5 0 # fmt . Println (" STR ", y )
var num int # r := map [ byte ] int { # ' I ': 1 , ' V ': 5 , ' X ': 1 0 , ' L ': 5 0 , ' C ': 1 0 0 , ' D ': 5 0 0 , ' M ': 1 0 0 0 , # } # for k := range s { # if k + 1 == len ( s ) || r [ s [ k ]] >= r [ s [ k + 1 ]] { # num += r [ s [ k ]] # } else { # num -= r [ s [ k ]] # } # } # return num
if len ( preorder ) < 2 { # return true # } # # var root = - 1 << 6 3 # var stack = [] int {} # # for _ , v := range preorder { # top := len ( stack ) - 1 # for 0 <= top && stack [ top ] < v { # root = stack [ top ] # stack = stack [: top ] # top -- # } # # if v < root { # return false # } # # stack = append ( stack , v ) # } # # return true
tests := map [ int ] string { # 1 : " STR ", # 3 : " STR ", # 5 : " STR ", # 7 : " STR ", # 9 : " STR ", # } # # for in , want := range tests { # got := countAndSay ( in ) # if got != want { # t . Fatalf (" STR ", in , got , want ) # } # }
memo . mu . Lock () # res , ok := memo . cache [ key ] # if ! ok { # res . value , res . err = memo . f ( key ) # memo . cache [ key ] = res # } # memo . mu . Unlock () # return res . value , res . err
switch sc := src .( type ) { # case xtime . Time : # * jt = Time ( sc . Unix ()) # case string : # var i int 6 4 # i , err = strconv . ParseInt ( sc , 1 0 , 6 4 ) # * jt = Time ( i ) # } # return
var row , col , box [ 9 ][ 9 ] bool # for r := 0 ; r < 9 ; r ++ { # for c := 0 ; c < 9 ; c ++ { # if board [ r ][ c ] == '.' { # continue # } # cell := board [ r ][ c ] - ' 1 ' # row [ r ][ cell ] = true # col [ c ][ cell ] = true # box [ r / 3 * 3 + c / 3 ][ cell ] = true # } # } # dfs ( board , row [:], col [:], box [:], 0 )
fmt . Println ( trap ([] int { 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 }))
t . Parallel () # for _ , tc := range testcases { # data := append ([] int {}, tc . input ...) # if result := LongestConsecutiveSequenceBrute ( data ); result != tc . length { # t . Errorf (" STR ", tc . length , result ) # } # }
N := len ( rooms ) # # next := make ([] int , 1 , N ) # next [ 0 ] = 0 # # isEntered := make ([] bool , N ) # isEntered [ 0 ] = true # count := 1 # # for len ( next ) > 0 { # r := next [ 0 ] # next = next [ 1 :] # # for _ , x := range rooms [ r ] { # if isEntered [ x ] { # continue # } # next = append ( next , x ) # isEntered [ x ] = true # count ++ # } # # if count == N { # return true # } # # } # # return count == N
var letters [] rune # for _ , r := range s { # if unicode . IsLetter ( r ) { # letters = append ( letters , unicode . ToLower ( r )) # } # } # for i := range letters { # if letters [ i ] != letters [ len ( letters )- 1 - i ] { # return false # } # } # return true
if root == nil || root . Val == p . Val || root . Val == q . Val { # return root # } # left := lowestCommonAncestor ( root . Left , p , q ) # right := lowestCommonAncestor ( root . Right , p , q ) # # if left == nil && right == nil { # return nil # } else if left == nil && right != nil { # return right # } else if left != nil && right == nil { # return left # } else { # return root # }
count := 0 # for i := 1 ; i < len ( nums ) && count < 2 ; i ++ { # if nums [ i - 1 ] > nums [ i ] { # count ++ # if i - 2 < 0 || nums [ i - 2 ] <= nums [ i ] { # nums [ i - 1 ] = nums [ i ] # } else { # nums [ i ] = nums [ i - 1 ] # } # } # } # return count < 2
if root != nil && root . left == nil && root . right == nil { # return root , 1 # } # if root . left == nil { # n , count := Deepest ( root . right ) # return n , count + 1 # } else if root . right == nil { # n , count := Deepest ( root . left ) # return n , count + 1 # } # ln , lcount := Deepest ( root . left ) # rn , rcount := Deepest ( root . right ) # if lcount > rcount { # return ln , lcount + 1 # } # return rn , rcount + 1
searchResults , err := matcher . Search ( feed , searchTerm ) # if err != nil { # log . Println ( err ) # return # } # # for _ , result := range searchResults { # results <- result # }
sort . Ints ( nums ) # closest := ( nums [ 0 ] + nums [ 1 ] + nums [ 2 ]) - target # for i := 0 ; i < len ( nums )- 2 ; i ++ { # j , k := i + 1 , len ( nums )- 1 # for j < k { # sum := nums [ i ] + nums [ j ] + nums [ k ] # if sum == target { # return target # } # # if math . Abs ( float 6 4 ( sum - target )) < math . Abs ( float 6 4 ( closest - target )) { # closest = sum # } # # if sum > target { # k -- # } else { # j ++ # } # } # } # # return closest
benchmark ( bb , 1 6 3 8 4 , 0 . 9 )
for i := 0 ; i < 1 0 ; i ++ { # for j := i ; j < 1 0 0 0 0 ; j ++ { # if check ( i , j ) { # fmt . Println ( i , j , i * j ) # } # } # } # for i := 0 ; i < 1 0 0 ; i ++ { # for j := i ; j < 1 0 0 0 ; j ++ { # if check ( i , j ) { # fmt . Println ( i , j , i * j ) # } # } # }
max , count := len ( nums ), 0 # s := make ([] bool , max ) # for _ , v := range nums { # s [ v - 1 ] = true # } # for i := 1 ; i <= max ; i ++ { # if ! s [ i - 1 ] { # nums [ count ] = i # count ++ # } # } # return nums [: count ]
cases := [] struct { # name string # candies [] int # extraCandies int # expect [] bool # }{ # {" STR ", [] int { 2 , 3 , 5 , 1 , 3 }, 3 , [] bool { true , true , true , false , true }}, # {" STR ", [] int { 1 0 , 1 0 0 }, 5 0 , [] bool { false , true }}, # {" STR ", [] int { 1 , 1 }, 1 , [] bool { true , true }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . candies , c . extraCandies ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . candies , c . extraCandies ) # } # }) # }
tests := map [ string ] int { # " STR ": 0 , # " STR ": 2 , # " STR ": 0 , # " STR ": - 1 , # } # # for in , want := range tests { # got := firstUniqChar ( in ) # if got != want { # t . Fatalf (" STR ", in , got , want ) # } # }
return dfs ( nil , nil , n )
return MyStack {[] int {}, [] int {}}
n := len ( weights ) # m := maxWeight # dp := make ([][] int , n + 1 ) # for i := range dp { # dp [ i ] = make ([] int , m + 1 ) # } # for i := 0 ; i < len ( weights ); i ++ { # for j := 0 ; j <= maxWeight ; j ++ { # if weights [ i ] > j { # dp [ i + 1 ][ j ] = dp [ i ][ j ] # } else { # dp [ i + 1 ][ j ] = Max ( dp [ i ][ j - weights [ i ]]+ values [ i ], dp [ i ][ j ]) # } # } # } # return dp [ n ][ m ]
tests := [...] testType { # { # in : [] int { 3 , 2 , 5 }, # want : true , # }, # { # in : [] int { 3 , 2 , 1 }, # want : false , # }, # { # in : [] int { 3 , 4 , 2 , 3 }, # want : false , # }, # { # in : [] int { 1 , 2 , 3 , 7 , 5 , 6 }, # want : true , # }, # { # in : [] int { 1 , 2 , 3 , 7 , 1 , 9 }, # want : true , # }, # } # for _ , tt := range tests { # got := checkPossibility ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
type Person struct { # Name string # Number int # } # # type Access struct { # Person Person # HasPermission bool # LastAccessed time . Time # } # # s := & Access { # Person : Person { Name : " STR ", Number : 1 2 3 4 5 6 7 }, # LastAccessed : time . Now (), # HasPermission : true , # } # # fields := Fields ( s ) # # for _ , field := range fields { # if field . Name () == " STR " { # fmt . Printf (" STR ", field . Field (" STR "). Value ()) # } # } #
if len ( s ) <= 1 { # return true # } # # left , right := 0 , len ( s )- 1 # for left < right { # for left < right && ! isCharacter ( s [ left ]) { # left ++ # } # for left < right && ! isCharacter ( s [ right ]) { # right -- # } # # if lowerCharacter ( s [ left ]) != lowerCharacter ( s [ right ]) { # return false # } # left ++ # right -- # } # return true
fmt . Println ( pivotIndex ([] int { 1 , 7 , 3 , 6 , 5 , 6 })) # fmt . Println ( pivotIndex ([] int { 1 , 2 , 3 })) # fmt . Println ( pivotIndex ([] int {- 1 , - 1 , - 1 , - 1 , - 1 , 0 })) # fmt . Println ( pivotIndex ([] int {- 1 , - 1 , - 1 , - 1 , 0 , - 1 }))
return & ClassReader { data }
if root == nil { # return true # } # return symmetric ( root . Left , root . Right )
var tests = [] struct { # s , t string # letter byte # }{ # {" STR ", " STR ", ' e '}, # {" STR ", " STR ", ' e '}, # } # # for _ , tt := range tests { # letter := findTheDifference ( tt . s , tt . t ) # if letter != tt . letter { # t . Errorf (" STR ", tt . s , tt . t , letter , tt . letter ) # } # }
if len ( matrix ) == 0 || len ( matrix [ 0 ]) == 0 { # return NumMatrix {} # } # numMatrix := NumMatrix { dp : make ([][] int , len ( matrix )+ 1 )} # for i := 0 ; i < len ( numMatrix . dp ); i ++ { # numMatrix . dp [ i ] = make ([] int , len ( matrix [ 0 ])+ 1 ) # } # # for i := 1 ; i <= len ( matrix ); i ++ { # for j := 1 ; j <= len ( matrix [ 0 ]); j ++ { # numMatrix . dp [ i ][ j ] = numMatrix . dp [ i - 1 ][ j ] + numMatrix . dp [ i ][ j - 1 ] - numMatrix . dp [ i - 1 ][ j - 1 ] + matrix [ i - 1 ][ j - 1 ] # } # } # return numMatrix
x := math . Sqrt ( 1 + 8 * float 6 4 ( n )) - 1 # return int ( x ) / 2
list := [...] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "} # m := make ( map [ string ] bool ) # for _ , word := range words { # k := " STR " # for i := 0 ; i < len ( word ); i ++ { # k += list [ word [ i ]-' a '] # } # m [ k ] = true # } # return len ( m )
if len ( arr ) > 1 { # primeIdx := rand . Intn ( len ( arr )) # arr [ primeIdx ], arr [ len ( arr )- 1 ] = arr [ len ( arr )- 1 ], arr [ primeIdx ] # primeIdx = partition ( arr ) # randomQuickSort ( arr [: primeIdx ]) # randomQuickSort ( arr [ primeIdx + 1 :]) # }
lo , hi := 0 , len ( nums )- 1 # for lo < hi { # mid := lo + ( hi - lo )/ 2 # if nums [ mid ] > nums [ hi ] { # lo = mid + 1 # } else { # hi = mid # } # } # return nums [ lo ]
t := 5 0 # for t > 3 9 { # t = 7 *( rand 7 ()- 1 ) + ( rand 7 () - 1 ) # } # return t % 1 0 + 1
ans , l , r := 0 , 0 , len ( height )- 1 # for l < r { # w , h := r - l , height [ l ] # if h < height [ r ] { # l ++ # } else { # h , r = height [ r ], r - 1 # } # if area := w * h ; area > ans { # ans = area # } # } # return ans
var res [] int # var stack []* TreeNode # # for root != nil || len ( stack ) > 0 { # for root != nil { # stack = append ( stack , root ) # root = root . Left # } # # pre := len ( stack ) - 1 # res = append ( res , stack [ pre ]. Val ) # root = stack [ pre ]. Right # stack = stack [: pre ] # } # return res
list := NewCyclic () # fillList ( list , 3 ) # wantSize := 0 # list . Destroy () # # got := list . Head # # if got != nil { # t . Errorf (" STR ", got ) # } # # if wantSize != list . Size { # t . Errorf (" STR ", got , wantSize ) # }
return f . field . Anonymous
for i , v := range ints { # if v == k { # return [] int { v } # } else if k > v { # if subset := SubsetSumBrute ( ints [ i + 1 :], k - v ); len ( subset ) != 0 { # return append ([] int { v }, subset ...) # } # } # } # return nil
t . Error (" STR ")
for i := 2 ; ; i ++ { # ch <- i # }
t . Parallel () # for _ , tc := range testcases { # if coins := MaxCoinsPath ( tc . grid ); coins != tc . maxCoins { # t . Errorf (" STR ", tc . maxCoins , coins ) # } # }
length := int ( math . Max ( float 6 4 ( len ( a )), float 6 4 ( len ( b )))) + 1 # result := make ([] byte , length ) # i , j , k := len ( a )- 1 , len ( b )- 1 , length - 1 # carry := 0 # for i >= 0 || j >= 0 { # sum := carry # if i >= 0 { # sum += int ( a [ i ] - ' 0 ') # i -- # } # # if j >= 0 { # sum += int ( b [ j ] - ' 0 ') # j -- # } # # if sum > 1 { # sum = sum - 2 # carry = 1 # } else { # carry = 0 # } # # result [ k ] = byte ( sum + ' 0 ') # k -- # } # # if carry > 0 { # result [ 0 ] = ' 1 ' # } # # if result [ 0 ] != ' 1 ' { # result = result [ 1 : len ( result )] # } # # return string ( result )
qs := [] question 4 1 6 { # # { # para 4 1 6 {[] int { 1 , 5 , 1 1 , 5 }}, # ans 4 1 6 { true }, # }, # # { # para 4 1 6 {[] int { 1 , 2 , 3 , 5 }}, # ans 4 1 6 { false }, # }, # # { # para 4 1 6 {[] int { 1 , 2 , 5 }}, # ans 4 1 6 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 1 6 , q . para 4 1 6 # fmt . Printf (" STR ", p , canPartition ( p . one )) # } # fmt . Printf (" STR ")
var sum , res int # for _ , c := range s { # if c == ' R ' { # sum += 1 # } else { # sum -= 1 # } # if sum == 0 { # res += 1 # } # } # return res
iE := i .(* linkedHeapListElement ) # return iE . right
m := map [ int ] struct {}{} # for _ , a := range A { # if _ , ok := m [ a ]; ok { # return a # } # m [ a ] = struct {}{} # } # return - 1
if root == nil { # return 0 # } # level = compute ( root ) # # if level == 0 { # return 1 # } # # counter = int ( math . Pow ( 2 , float 6 4 ( level ))) # left , right := 0 , counter - 1 # for left <= right { # mid := ( left + right ) / 2 # if exist ( mid , root ) { # left = mid + 1 # } else { # right = mid - 1 # } # } # # return counter + left - 1
p := Pool { # work : make ( chan Worker ), # } # # p . wg . Add ( maxGoroutines ) # for i := 0 ; i < maxGoroutines ; i ++ { # go func () { # for w := range p . work { # w . Task () # } # p . wg . Done () # }() # } # # return & p
resp , err := http . Get ( path ) # if err != nil { # fmt . Println ( err ) # return errors . New ( path + " STR " + err . Error ()) # } # # if resp . StatusCode != 2 0 0 { # fmt . Println ( resp . StatusCode ) # return errors . New ( string ( resp . StatusCode )) # } # # return nil
_ , err := os . Stat ( path ) # if err == nil { # return true # } # if os . IsNotExist ( err ) { # return false # } # return true
node := q . list . Get ( 0 ) # if node == nil { # return nil # } # return node . Data
if head == nil || head . Next == nil { # return head # } # # prev , slow , fast := head , head , head # for fast != nil && fast . Next != nil { # prev = slow # slow = slow . Next # fast = fast . Next . Next # } # prev . Next = nil # return merge ( sortList ( head ), sortList ( slow ))
l := len ( nums ) # sums := make ([] int , l + 1 ) # for i := 1 ; i <= l ; i ++ { # sums [ i ] = sums [ i - 1 ] + nums [ i - 1 ] # } # ans := 0 # for i := 0 ; i < l ; i ++ { # for j := i ; i < l ; j ++ { # if ( sums [ j + 1 ] - sums [ i ]) == k { # ans ++ # } # } # } # return ans
if len ( s ) == 0 { # return 0 # } # # dp := make ([][] int , len ( s )) # for i := range dp { # dp [ i ] = make ([] int , len ( s )) # dp [ i ][ i ] = 1 # } # # for le := 2 ; le <= len ( s ); le ++ { # for i := 0 ; i <= len ( s )- le ; i ++ { # j := i + le - 1 # dp [ i ][ j ] = le # for k := i + 1 ; k <= j ; k ++ { # turns := dp [ i ][ k - 1 ] + dp [ k ][ j ] # if s [ k - 1 ] == s [ j ] { # turns -- # } # # if dp [ i ][ j ] > turns { # dp [ i ][ j ] = turns # } # } # } # } # # return dp [ 0 ][ len ( s )- 1 ]
lr := & io . LimitedReader { R : r , N : 7 } # b := make ([] byte , 7 ) # n , err := lr . Read ( b ) # if err != nil { # return " STR " # } # return string ( b [: n ])
if a == 0 || b == 0 { # return 0 # } # if a < b { # return Multiply ( b , a ) # } # # if b == 1 { # return a # } # if b == 2 { # return a + a # } # temp := Multiply ( a , ( b - 1 )/ 2 ) # temp += temp + a # return temp #
m , n := len ( grid ), len ( grid [ 0 ]) # if k == m * n { # return grid # } # if k % n == 0 { # for k > 0 { # last := grid [ m - 1 ] # for i := m - 1 ; i > 0 ; i -- { # grid [ i ] = grid [ i - 1 ] # } # grid [ 0 ] = last # k -= n # } # return grid # } # tmp := make ([] int , 0 ) # for _ , val := range grid { # tmp = append ( tmp , val ...) # } # for k > 0 { # last := tmp [ m * n - 1 ] # for i := m * n - 1 ; i > 0 ; i -- { # tmp [ i ] = tmp [ i - 1 ] # } # tmp [ 0 ] = last # k -- # } # l := 0 # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # grid [ i ][ j ] = tmp [ l ] # l ++ # } # } # return grid
qs := [] question 3 { # # { # para 3 {" STR "}, # ans 3 { 3 }, # }, # # { # para 3 {" STR "}, # ans 3 { 1 }, # }, # # { # para 3 {" STR "}, # ans 3 { 3 }, # }, # # { # para 3 {" STR "}, # ans 3 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 , q . para 3 # fmt . Printf (" STR ", p , lengthOfLongestSubstring_ ( p . s )) # } # fmt . Printf (" STR ")
TestCases := [] struct { # name string # inputs [] int # expect [] int # }{ # { # " STR ", # [] int { 4 , 2 , 1 , 3 }, # [] int { 1 , 2 , 3 , 4 }, # }, # { # " STR ", # [] int {- 1 , 5 , 3 , 4 , 0 }, # [] int {- 1 , 0 , 3 , 4 , 5 }, # }, # } # # for _ , c := range TestCases { # t . Run ( c . name , func ( t * testing . T ) { # ret := Solution ( UnmarshalListBySlice ( c . inputs )) # if ! isEqual ( ret , UnmarshalListBySlice ( c . expect )) { # PrintList ( ret ) # PrintList ( UnmarshalListBySlice ( c . expect )) # t . Fatalf (" STR ", c . expect , ret , c . inputs ) # } # }) # }
if len ( points ) == 1 { # return 1 # } # _max := 0 # for idx := 1 ; idx < len ( points ); idx ++ { # tmpSlopes := make ( map [ string ] int ) # tmpMax := 0 # double := 0 # for inner := 0 ; inner < idx ; inner ++ { # x 1 , y 1 , x 2 , y 2 := points [ inner ][ 0 ], points [ inner ][ 1 ], points [ idx ][ 0 ], points [ idx ][ 1 ] # if x 1 == x 2 && y 1 == y 2 { # double ++ # continue # } # k := slope ( x 1 , y 1 , x 2 , y 2 ) # if _ , ok := tmpSlopes [ k ]; ! ok { # tmpSlopes [ k ] = 1 # } # tmpSlopes [ k ]++ # if tmpSlopes [ k ] > _max { # _max = tmpSlopes [ k ] # } # } # # if tmpMax == 0 { # tmpMax = 1 # } # tmpMax += double # if tmpMax > _max { # _max = tmpMax # } # } # return _max
counts := make ( map [ byte ] int ) # for _ , ch := range [] byte ( t ) { # if _ , exists := counts [ ch ]; exists { # counts [ ch ]++ # } else { # counts [ ch ] = 1 # } # } # # i , j , total := 0 , 0 , len ( t ) # var result string # for j < len ( s ) { # if count , exists := counts [ s [ j ]]; exists { # counts [ s [ j ]]-- # if count > 0 { # total -- # } # } # # for i <= j && total == 0 { # if result == " STR " || len ( result ) > j - i + 1 { # result = string ( s [ i : j + 1 ]) # } # # if count , exists := counts [ s [ i ]]; exists { # counts [ s [ i ]]++ # if count >= 0 { # total ++ # } # } # # i ++ # } # # j ++ # } # # return result
cases := [] struct { # name string # inputs [] int # expect [] int # }{ # {" STR ", [] int {- 4 , - 1 , 0 , 3 , 1 0 }, [] int { 0 , 1 , 9 , 1 6 , 1 0 0 }}, # {" STR ", [] int {- 7 , - 3 , 2 , 3 , 1 1 }, [] int { 4 , 9 , 9 , 4 9 , 1 2 1 }}, # {" STR ", [] int {}, [] int {}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if K == 0 || N >= K + W { # return 1 . # } # dp := make ([] float 6 4 , N + 1 ) # dp [ 0 ] = 1 . # s , m := 1 ., 1 / float 6 4 ( W ) # res := 0 . # for i := 1 ; i <= N ; i ++ { # dp [ i ] = s * m # if i < K { # s += dp [ i ] # } else { # res += dp [ i ] # } # if i >= W { # s -= dp [ i - W ] # } # } # return res
for _ , tier := range al { # ret = append ( ret , append ([] string ( nil ), tier ...)) # } # return
return f . value . Kind ()
type testCase struct { # param int # wantToReturn int # } # list := NewCyclic () # fillList ( list , 3 ) # # testCases := [] testCase { # { 1 , 2 }, # { 3 , 2 }, # { 6 , 2 }, # { 7 , 3 }, # {- 2 , 1 }, # { 5 , 3 }, # { 8 , 2 }, # {- 8 , 3 }, # } # for idx , tCase := range testCases { # list . Rotate ( tCase . param ) # got := list . Head . Val # if got != tCase . wantToReturn { # t . Errorf (" STR ", got , tCase . wantToReturn , idx ) # } # }
if idx >= n { # tmp := [] string {} # for i := 0 ; i < n ; i ++ { # str := " STR " # for j := 0 ; j < b [ i ]; j ++ { # str += " STR " # } # str += " STR " # for j := b [ i ] + 1 ; j < n ; j ++ { # str += " STR " # } # tmp = append ( tmp , str ) # } # ret = append ( ret , tmp ) # } else { # for i := 0 ; i < n ; i ++ { # if col [ i ] == true || right [ i + idx ] == true || left [ n - i - 1 + idx ] == true { # continue # } # col [ i ] = true # right [ i + idx ] = true # left [ n - i - 1 + idx ] = true # b [ idx ] = i # help ( b , col , left , right , idx + 1 , n ) # col [ i ] = false # right [ i + idx ] = false # left [ n - i - 1 + idx ] = false # } # }
maxCount , currentCount := 0 , 0 # for _ , v := range nums { # if v == 1 { # currentCount ++ # } else { # currentCount = 0 # } # if currentCount > maxCount { # maxCount = currentCount # } # } # return maxCount
if n <= 1 { # return 1 # } # if m [ n ] != 0 { # return m [ n ] # } else { # m [ n ] = jumpFloorRecursion ( n - 1 , m ) + jumpFloorRecursion ( n - 2 , m ) # } # return m [ n ]
input := bufio . NewScanner ( c ) # for input . Scan () { # go echo ( c , input . Text (), 1 * time . Second ) # } # c . Close ()
ans := make ([] int , 0 ) # if head == nil { # return ans # } # ans = reversePrint ( head . Next ) # ans = append ( ans , head . Val ) # return ans
var leftHeight , rightHeight int # if root . Left != nil { # leftHeight = root . Left . Height # } # if root . Right != nil { # rightHeight = root . Right . Height # } # return leftHeight - rightHeight
l := len ( s ) # for i := 0 ; i < l / 2 ; i ++ { # if s [ i ] != s [ l - i - 1 ] { # return false # } # } # # return true
if len ( s 1 ) != len ( s 2 ) { # return false # } # for i , val := range s 1 { # if s 2 [ i ] != val { # return false # } # } # return true
var err error # # err = seek ( r , qSize , io . SeekCurrent , qSize ) # if err != nil { # return err # } # # err = seek ( r , qSize , io . SeekCurrent , hSize ) # if err != nil { # return err # } # # return read ( r , hSize , h )
if job . state != jobStateQueued { # return false # } # # for _ , dep := range job . dependencies { # if dep . state != jobStateFinished { # return false # } # } # # return true
mod := 1 0 0 0 0 0 0 0 0 7 # dp := make ([][] int , N + 1 ) # for i := 0 ; i < N + 1 ; i ++ { # dp [ i ] = make ([] int , L + 1 ) # } # dp [ 1 ][ 1 ] = 1 # for i := 1 ; i < N + 1 ; i ++ { # for j := 1 ; j < L + 1 ; j ++ { # if i == 1 && j == 1 { # continue # } # v := ( dp [ i - 1 ][ j - 1 ] * i ) % mod # if i - K > 0 { # v = ( v + ( dp [ i ][ j - 1 ]*( i - K ))% mod ) % mod # } # dp [ i ][ j ] = v # } # } # return dp [ N ][ L ]
l := len ( digits ) # carry := 1 # # for 0 < l { # l -- # digits [ l ] += carry # if 9 < digits [ l ] { # carry = digits [ l ] / 1 0 # digits [ l ] %= 1 0 # } else { # carry = 0 # } # } # if 0 < carry { # digits = append ( digits , 0 ) # copy ( digits [ 1 :], digits ) # digits [ 0 ] = carry # } # # return digits
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 0 , 3 }, 3 }, # {" STR ", [] int { 7 , - 3 }, - 2 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := divide ( c . inputs [ 0 ], c . inputs [ 1 ]) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
var res [] string # dfs (" STR ", n , n , & res ) # return res
g := NewDirected () # # for i := 0 ; i < 1 0 ; i ++ { # g . AddVertex ( VertexId ( i )) # } # # if len ( g . edges ) != 1 0 { # fmt . Println ( g ) # t . Error () # } # # for i := 0 ; i < 1 0 ; i ++ { # g . AddEdge ( VertexId ( i ), VertexId ( i % 2 ), 1 ) # } # # r := g . Reverse () # if ! r . IsEdge ( 1 , 7 ) || r . IsEdge ( 8 , 0 ) { # fmt . Println ( r . edges ) # t . Error () # } # # successors := r . GetSuccessors ( 1 ). VerticesIter () # for successor := range successors { # if successor != 3 && # successor != 5 && # successor != 7 && # successor != 9 { # t . Error () # } # } # # predecessors := g . GetPredecessors ( 1 ). VerticesIter () # for predecessor := range predecessors { # if predecessor != 3 && # predecessor != 5 && # predecessor != 7 && # predecessor != 9 { # t . Error () # } # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 2 , 3 }, 1 }, # {" STR ", [] int { 2 , 2 , 2 , 3 , 3 }, 2 }, # {" STR ", [] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 0 }, 5 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
return int (( math . Sqrt ( float 6 4 ( 8 * n + 1 )) - 1 ) / 2 )
ans := 0 # for i := range nums { # c := 1 # for nums [ i ] != i { # nums [ i ], nums [ nums [ i ]] = nums [ nums [ i ]], nums [ i ] # c ++ # } # if ans < c { # ans = c # } # } # return ans
if cmd == "" { # return nil # } # if c . writeTimeout != 0 { # c . conn . SetWriteDeadline ( time . Now (). Add ( c . writeTimeout )) # } # if err = c . writeStoreCommand ( cmd , key , value , flags , timeout , cas ); err == nil { # err = c . bw . Flush () # } # if err != nil { # return c . fatal ( err ) # } # if c . readTimeout != 0 { # c . conn . SetReadDeadline ( time . Now (). Add ( c . readTimeout )) # } # err = c . readStoreReply () # return
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", # [][] int { # { 1 , 3 , 1 }, # { 1 , 5 , 1 }, # { 4 , 2 , 1 }, # }, # 7 , # }, # {" STR ", # [][] int { # { 1 , 2 , 5 }, # { 3 , 2 , 1 }, # }, # 6 , # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := minPathSum ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
pairs := [...][ 2 ] int {{ 5 , 1 5 }, { 1 0 0 , 9 1 8 3 }} # for _ , pair := range pairs { # in , out := pair [ 0 ], int ( pair [ 1 ]) # if x := p 2 9 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # } # }
var r int # for e := range s { # if s [ e ] != ' ' { # if e > 0 && s [ e - 1 ] == ' ' { # r = 0 # } # r ++ # } # } # return r
sLen := len ( s ) # patternLen := len ( pattern ) # if sLen == 0 || patternLen == 0 || patternLen > sLen { # return - 1 # } # findRange := sLen - patternLen # for i := 0 ; i <= findRange ; i ++ { # if ( s [ i : i + patternLen ]) == pattern { # return i # } # } # return - 1
for _ , p := range perm 6 ([] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }) { # valid := true # # for _ , g := range guesses { # var count int # # for i := 0 ; i < len ( p ); i ++ { # if p [ i ] == g . Code [ i ] { # count ++ # } # } # # if count != g . Score { # valid = false # break # } # } # # if valid { # return true # } # } # # return false
res := make ([] int , 0 , k ) # n := len ( a ) # if n == 0 { # return [] int {} # } # for i := 0 ; i <= n - k ; i ++ { # max := a [ i ] # for j := 1 ; j < k ; j ++ { # if max < a [ i + j ] { # max = a [ i + j ] # } # } # res = append ( res , max ) # } # # return res
var addr string # if len ( os . Args ) != 2 { # fmt . Println (" STR ") # os . Exit ( 0 ) # } # addr = os . Args [ 1 ] # listener , err := net . Listen (" STR ", addr ) # if err != nil { # log . Fatal (" STR ", err ) # } # fmt . Println (" STR ") # for { # conn , err := listener . Accept () # if err != nil { # log . Println (" STR ", err ) # } # go handleConnection ( conn ) # } #
n := len ( nums ) - 1 # lo , hi := 0 , n - 1 # # for lo < hi { # mid := lo + ( hi - lo )/ 2 # if mid % 2 == 1 { # mid -- # } # # if nums [ mid ] != nums [ mid + 1 ] { # hi = mid # } else { # lo = mid + 2 # } # # } # # return nums [ lo ]
res := make ([] float 6 4 , len ( nums )- k + 1 ) # w := newWindow ( nums , k ) # # for i := 0 ; i + k < len ( nums ); i ++ { # res [ i ] = w . median () # w . update ( i , i + k , nums ) # } # # res [ len ( nums )- k ] = w . median () # # return res
size := len ( A ) # count := size # # parent := make ([] int , size ) # for i := 0 ; i < size ; i ++ { # parent [ i ] = i # } # var find func ( int ) int # find = func ( x int ) int { # if x != parent [ x ] { # parent [ x ] = find ( parent [ x ]) # } # return parent [ x ] # } # union := func ( x , y int ) { # x , y = find ( x ), find ( y ) # if x != y { # parent [ y ] = x # count -- # } # } # # for i := 0 ; i < size ; i ++ { # for j := i + 1 ; j < size ; j ++ { # if isSimilar ( A [ i ], A [ j ]) { # union ( i , j ) # } # } # } # # return count
x 0 , y 0 := p [ 0 ][ 0 ], p [ 0 ][ 1 ] # x 1 , y 1 := p [ 1 ][ 0 ], p [ 1 ][ 1 ] # x 2 , y 2 := p [ 2 ][ 0 ], p [ 2 ][ 1 ] # return ( x 0 - x 2 )*( y 1 - y 2 ) != ( y 0 - y 2 )*( x 1 - x 2 )
return MyHashMap { # table : make ([] int , 1 0 0 0 0 0 1 ), # }
if root == nil { # return 0 # } # # if root . Left == nil { # return minDepth ( root . Right ) + 1 # } # if root . Right == nil { # return minDepth ( root . Left ) + 1 # } # # ld := minDepth ( root . Left ) # rd := minDepth ( root . Right ) # # d := ld # if rd < ld { # d = rd # } # return d + 1
return MyHashSet { make ( map [ int ] bool , 0 )}
sum := 0 # for i := 0 ; i < ( p - 1 )* PowInt ( 9 , p ); i ++ { # if equalPows ( i , p ) { # sum += i # } # } # return sum
s := [] byte ( strconv . Itoa ( n )) # for i := len ( s ) - 2 ; 0 <= i ; i -- { # if s [ i ] <= s [ i + 1 ] { # continue # } # # s [ i ]-- # for j := i + 1 ; j < len ( s ); j ++ { # s [ j ] = ' 9 ' # } # } # # res , _ := strconv . Atoi ( string ( s )) # return res
sort . Ints ( candidates ) # # res := [][] int {} # solution := [] int {} # cs ( candidates , solution , target , & res ) # # return res
return io . ReadFull ( Reader , b )
l := len ( S ) # ret := make ([] int , l + 1 ) # indexI , indexD := 0 , len ( S ) # for i := 0 ; i <= l ; i ++ { # if i == l { # ret [ i ] = indexI # break # } # if S [ i ] == ' D ' { # ret [ i ] = indexD # indexD -- # } # if S [ i ] == ' I ' { # ret [ i ] = indexI # indexI ++ # } # } # return ret
for b != 0 { # a , b = a ^ b , ( a & b )<< 1 # } # return a
if y == 0 { # return x # } # return gcd ( y , x % y )
numbers := [] int { 3 , 3 2 , 3 2 1 } # fmt . Println ( printMinNumber ( numbers ))
t . Parallel () # for _ , tc := range testcases { # trie := NewTrie ( tc . input ) # result := trie . Match ( tc . query ) # sort . Strings ( result ) # if ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result , tc . query ) # } # }
fmt . Println ( allPathsSourceTarget ([][] int {[] int { 1 , 2 }, [] int { 3 }, [] int { 3 }, [] int {}}))
if a < b { # return a # } # return b
seen := make ( map [ int ] struct {}, len ( nums )) # # for _ , n := range nums { # seen [ n ] = struct {}{} # } # # ans := make ([] int , 0 , 1 _ 0 0 0 _ 0 0 0 - len ( seen )+ 1 ) # # for n := 1 ; n <= 1 _ 0 0 0 _ 0 0 0 ; n ++ { # if _ , ok := seen [ n ]; ! ok { # ans = append ( ans , n ) # } # } # # return ans
if divisor == 0 { # panic (" STR ") # } # # var dividendNeg , divisorNeg bool # # if dividend < 0 { # dividendNeg = true # dividend = - dividend # } # # if divisor < 0 { # divisorNeg = true # divisor = - divisor # } # # var quotient int # # for dividend >= 0 { # dividend -= divisor # quotient ++ # } # # remainder := dividend + divisor # quotient -- # # if dividendNeg { # quotient = - quotient # remainder = - remainder # } # # if divisorNeg { # quotient = - quotient # remainder = - remainder # } # # return quotient , remainder
s := [] rune ( S ) # i , j := 0 , len ( s )- 1 # for i < j { # if ! unicode . IsLetter ( rune ( S [ i ])) { # i ++ # } else if ! unicode . IsLetter ( rune ( S [ j ])) { # j -- # } else { # s [ i ], s [ j ] = s [ j ], s [ i ] # i ++ # j -- # } # } # return string ( s )
if random == nil { # random = rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # } # return random
if len ( board ) == 0 || len ( board [ 0 ]) == 0 { # return false # } # # visited := make ([][] bool , len ( board )) # for i := 0 ; i < len ( board ); i ++ { # visited [ i ] = make ([] bool , len ( board [ 0 ])) # } # # var found bool # for i := 0 ; i < len ( board ) && ! found ; i ++ { # for j := 0 ; j < len ( board [ 0 ]) && ! found ; j ++ { # found = helper 7 9 ( board , word , visited , i , j , 0 ) # } # } # # return found
qs := [] question 3 8 5 { # # { # para 3 8 5 {" STR "}, # ans 3 8 5 {[] int {}}, # }, # # { # para 3 8 5 {" STR "}, # ans 3 8 5 {[] int {}}, # }, # # { # para 3 8 5 {" STR "}, # ans 3 8 5 {[] int {- 1 }}, # }, # # { # para 3 8 5 {" STR "}, # ans 3 8 5 {[] int { 1 2 3 , 4 5 6 , 7 8 9 }}, # }, # # { # para 3 8 5 {" STR "}, # ans 3 8 5 {[] int { 3 2 4 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 8 5 , q . para 3 8 5 # fmt . Printf (" STR ", p ) # fmt . Printf (" STR ") # deserialize ( p . n ). Print () # } # fmt . Printf (" STR ")
startIndex := lowIndex # endIndex := highIndex # var mid int # size := len ( array ) # if size == 0 || highIndex > size || lowIndex < 0 { # return - 1 # } # for startIndex <= endIndex { # mid = ( endIndex + startIndex ) / 2 # if array [ mid ] > target { # endIndex = mid - 1 # } else if array [ mid ] < target { # startIndex = mid + 1 # } else { # return mid # } # } # return - 1
keys := makeKeys ( n - 1 , k ) # r := make ( map [ string ][] string , len ( keys )) # for i := range keys { # r [ keys [ i ]] = makeNums ( k ) # } # # res := strings . Repeat (" STR ", n - 1 ) # # count := int ( math . Pow ( float 6 4 ( k ), float 6 4 ( n ))) # # for k := 0 ; k < count ; k ++ { # key := res [ len ( res )-( n - 1 ):] # next := r [ key ][ 0 ] # r [ key ] = r [ key ][ 1 :] # res += next # } # # return res
_ , ret := helper ( root ) # return ret
if m == 0 { # return 1 # } # if n == 1 { # return 2 # } # if n == 2 { # if m == 1 { # return 3 # } # return 4 # } # if m == 1 { # return 4 # } # if m == 2 { # return 7 # } # return 8
t . Parallel () # r := NewRandom ([] interface {}{" STR ", " STR ", " STR "}, [] float 6 4 { 0 . 1 , 0 . 8 , 0 . 1 }) # counts := make ( map [ interface {}] int ) # for i := 0 ; i < 1 0 0 0 0 ; i ++ { # counts [ r . Get ()]++ # } # if ac := counts [" STR "]; ac < 2 0 0 || ac > 1 8 0 0 { # t . Errorf (" STR ") # } # if bc := counts [" STR "]; bc < 7 0 0 0 || bc > 9 0 0 0 { # t . Errorf (" STR ") # } # if cc := counts [" STR "]; cc < 2 0 0 || cc > 1 8 0 0 { # t . Errorf (" STR ") # }
return MinStack { make ([] int , 0 ), make ([] int , 0 ), 0 }
 # n := len ( matrix ) # for i := 0 ; i < n ; i ++ { # for j := i + 1 ; j < n ; j ++ { # matrix [ i ][ j ], matrix [ j ][ i ] = matrix [ j ][ i ], matrix [ i ][ j ] # } # } # # for i := 0 ; i < n ; i ++ { # for j := 0 ; j < n / 2 ; j ++ { # matrix [ i ][ j ], matrix [ i ][ n - 1 - j ] = matrix [ i ][ n - 1 - j ], matrix [ i ][ j ] # } # }  
mux := http . NewServeMux () # mux . Handle (" STR ", & indexHandler {}) # # thWelcome := & textHandler {" STR "} # mux . Handle (" STR ", thWelcome ) # # mux . Handle (" STR ", thMessage ) # # log . Println (" STR ") # http . ListenAndServe (" STR ", mux )
if len ( nums ) == 0 { # return [] int {} # } # max := nums [ 0 ] # var left_res , right_res , res [] int # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] < max { # left_res = append ( left_res , nums [ i ]) # } else { # right_res = append ( right_res , nums [ i ]) # } # } # left_res = Sort ( left_res ) # right_res = Sort ( right_res ) # res = append ( res , left_res ...) # res = append ( res , max ) # res = append ( res , right_res ...) # return res
arr := [] int { 1 0 , 5 , 2 , 6 } # numSubarrayProductLessThanK ( arr , 1 0 0 )
tests := [...] testType { # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := validIPAddress ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
res := make ([] int , 0 , right - left + 1 ) # for i := left ; i <= right ; i ++ { # if isSelfDividing ( i ) { # res = append ( res , i ) # } # } # return res
var 1 , var 2 , new , total := 1 , 2 , 0 , 0 # n := 4 0 0 0 0 0 0 # for var 1 <= n { # if var 1 % 2 == 0 { # total += var 1 # } # new = var 1 + var 2 # var 1 = var 2 # var 2 = new # } # fmt . Println ( total )
fmt . Println ( plusOne ([] int { 4 , 3 , 2 , 1 })) # fmt . Println ( plusOne ([] int { 9 }))
qs := [] question 6 3 6 { # # { # para 6 3 6 { 2 , [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 6 3 6 {[] int { 8 , 1 }}, # }, # # { # para 6 3 6 { 2 , [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 6 3 6 {[] int { 7 , 1 }}, # }, # # { # para 6 3 6 { 2 , [] string {" STR ", " STR ", " STR ", " STR "}}, # ans 6 3 6 {[] int { 3 , 4 }}, # }, # } # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 3 6 , q . para 6 3 6 # fmt . Printf (" STR ", p , exclusiveTime ( p . n , p . one )) # } # fmt . Printf (" STR ")
root := & Trie { make ( map [ rune ] int ), make ( map [ rune ]* Trie )} # for _ , word := range words { # curr := root # for _ , r := range word { # curr . freq [ r ]++ # if curr . ptr [ r ] == nil { # curr . ptr [ r ] = & Trie { make ( map [ rune ] int ), make ( map [ rune ]* Trie )} # } # curr = curr . ptr [ r ] # } # } # results := make ([] string , 0 , len ( words )) # for _ , word := range words { # var sb strings . Builder # curr := root # for _ , r := range word { # sb . WriteRune ( r ) # if curr . freq [ r ] == 1 { # results = append ( results , sb . String ()) # break # } # curr = curr . ptr [ r ] # } # } # return results
size := len ( A ) # # dp := make ([] int , size ) # copy ( dp , A [ 0 ]) # # for i := 1 ; i < size ; i ++ { # tmps := [ 1 0 0 ] int {} # for j := 0 ; j < size ; j ++ { # a , tmp := A [ i ][ j ], maxSum # l , r := max ( j - 1 , 0 ), min ( j + 1 , size - 1 ) # for k := l ; k <= r ; k ++ { # tmp = min ( tmp , a + dp [ k ]) # } # tmps [ j ] = tmp # } # dp = tmps [: size ] # } # # res := maxSum # for i := 0 ; i < size ; i ++ { # res = min ( res , dp [ i ]) # } # # return res
qs := [] question 7 1 9 { # # { # para 7 1 9 {[] int { 1 , 3 , 1 }, 1 }, # ans 7 1 9 { 0 }, # }, # # { # para 7 1 9 {[] int { 1 , 1 , 1 }, 2 }, # ans 7 1 9 { 0 }, # }, # # { # para 7 1 9 {[] int { 1 , 6 , 1 }, 3 }, # ans 7 1 9 { 5 }, # }, # # { # para 7 1 9 {[] int { 6 2 , 1 0 0 , 4 }, 2 }, # ans 7 1 9 { 5 8 }, # }, # # { # para 7 1 9 {[] int { 9 , 1 0 , 7 , 1 0 , 6 , 1 , 5 , 4 , 9 , 8 }, 1 8 }, # ans 7 1 9 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 1 9 , q . para 7 1 9 # fmt . Printf (" STR ", p , smallestDistancePair ( p . num , p . k )) # } # fmt . Printf (" STR ")
ret := 1 . 0 # sign := true # if n < 0 { # n = - n # sign = false # } # for n != 0 { # if n % 2 == 1 { # ret *= x # } # n >>= 1 # x *= x # } # # if ! sign { # return 1 / ret # } # return ret
if len ( its ) <= 1 { # return its # } # # quickSort ( its ) # # res := make ([] Interval , 0 , len ( its )) # temp := its [ 0 ] # # for i := 1 ; i < len ( its ); i ++ { # if its [ i ]. Start <= temp . End { # temp . End = max ( temp . End , its [ i ]. End ) # continue # } # res = append ( res , temp ) # temp = its [ i ] # } # # res = append ( res , temp ) # # return res
t . Parallel () # for _ , tc := range testcases { # if result := EvalSimpleMathExpression ( tc . expr ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
if len ( s ) < k { # return 0 # } # # count := make ( map [ byte ] int , len ( s )) # maxCount := 0 # for i := range s { # count [ s [ i ]]++ # maxCount = max ( maxCount , count [ s [ i ]]) # } # if maxCount < k { # return 0 # } # # var b byte # var c int # # useless := make ([] string , 0 , len ( count )) # for b , c = range count { # if c < k { # useless = append ( useless , string ( b )) # } # } # # if len ( useless ) == 0 { # return len ( s ) # } # # var u string # for _ , u = range useless { # s = strings . Replace ( s , u , " STR ", - 1 ) # } # # ss := strings . Split ( s , " STR ") # # maxLen := 0 # for _ , s = range ss { # maxLen = max ( maxLen , longestSubstring ( s , k )) # } # # return maxLen
total , m := 0 , make ( map [ int ] int ) # for _ , v := range ans { # if m [ v ] == 0 { # m [ v ] += v # total += v + 1 # } else { # m [ v ]-- # } # } # return total
ss := make ([] string , len ( nums )) # for i , num := range nums { # ss [ i ] = strconv . Itoa ( num ) # } # sort . Slice ( ss , func ( i , j int ) bool { return ss [ j ]+ ss [ i ] < ss [ i ]+ ss [ j ] }) # # if ss [ 0 ] == " STR " { # return " STR " # } # # var b strings . Builder # for _ , s := range ss { # b . WriteString ( s ) # } # return b . String ()
if val < 0 { # return - val # } # return val
n . keyValue [ i ], n . keyValue [ j ] = n . keyValue [ j ], n . keyValue [ i ]
fmt . Printf (" STR ", # a . name , # a . email )
for _ , job := range jobs { # if job . readyToRun () { # return job # } # } # return nil
t . Parallel () # for _ , tc := range testcases { # if result := LongestAppleRun ( tc . apples ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
return RangeModule {& SegmentTreeNode { 0 , 1 e 9 , false , 0 , nil , nil }}
var ( # max = math . MinInt 3 2 # sum int # start , end , f int # ) # for i , j := range nums { # sum += j # if sum > max { # if f != 0 { # start = f + 1 # f = 0 # } # max = sum # end = i # } # if sum < 0 { # f = i # sum = 0 # } # } # fmt . Printf (" STR ", start , end ) # return max
if a == 0 { # return b , 0 , 1 # } # gcd , xPrime , yPrime := Extended ( b % a , a ) # return gcd , yPrime - ( b / a )* xPrime , xPrime
op := k . lDOperation . init (" STR ", cost ) # op . lDCompute = k # return k
dp := make ([] int , target + 1 ) # dp [ 0 ] = 1 # for i := 1 ; i <= target ; i ++ { # for _ , num := range nums { # if i >= num { # dp [ i ] += dp [ i - num ] # } # } # } # # return dp [ target ]
const sum = 1 0 0 0 # a := 0 # var b , c int # var floatC float 6 4 # for a +( a + 1 )+( a + 2 ) < sum { # b = a + 1 # for a + b +( b + 1 ) < sum { # floatC = math . Sqrt ( float 6 4 ( a * a + b * b )) # if floatC == float 6 4 ( int ( floatC )) { # c = int ( floatC ) # if a + b + c == 1 0 0 0 { # fmt . Println ( a * b * c ) # os . Exit ( 0 ) # } # } # b ++ # } # a ++ # }
defer TimeTaken ( time . Now (), " STR ") # # sum := 1 0 0 0 # # calculate : # for a := 1 ; a <= sum / 3 ; a ++ { # for b := a + 1 ; b <= sum / 2 ; b ++ { # c := sum - b - a # # if a * a + b * b == c * c { # fmt . Println ( a * b * c ) # break calculate # } # } # } #
var res int # l := len ( points ) # for i := 1 ; i < l ; i ++ { # x := abs ( points [ i ][ 0 ] - points [ i - 1 ][ 0 ]) # y := abs ( points [ i ][ 1 ] - points [ i - 1 ][ 1 ]) # res += max ( x , y ) # } # return res
sum := 0 # for i := 0 ; i <= n ; i ++ { # if i % 3 == 0 || i % 5 == 0 { # sum += i # } # } # return sum
t . Parallel () # for _ , tc := range testcases { # if result := IsPowerFourBrute ( tc . n ); result != tc . isPowerFour { # t . Errorf (" STR ", tc . n , tc . isPowerFour , result ) # } # }
fmt . Println ( findRadius ([] int { 1 , 2 , 3 }, [] int { 2 })) # fmt . Println ( findRadius ([] int { 1 , 2 , 3 , 4 , 9 9 }, [] int { 1 , 4 }))
assertType ( 3 , uintptr ( reflect . Int )<< 1 ) # assertType ( uint 8 ( 3 ), uintptr ( reflect . Uint 8 )<< 1 ) # assertType ( byte ( 3 ), uintptr ( reflect . Uint 8 )<< 1 ) # assertType ( int 6 4 ( 3 ), uintptr ( reflect . Int 6 4 )<< 1 ) # assertType ("", uintptr ( reflect . String )<< 1 ) # assertType ( 3 . 5 , uintptr ( reflect . Float 6 4 )<< 1 ) # assertType ( unsafe . Pointer ( nil ), uintptr ( reflect . UnsafePointer )<< 1 ) # # const intNum = uintptr ( reflect . Int ) << 1 # assertType ( namedInt 1 ( 0 ), ( 3 << 6 )| intNum ) # assertType ( namedInt 2 ( 0 ), ( 2 << 6 )| intNum ) # assertType ( namedInt 3 ( 0 ), ( 1 << 6 )| intNum ) # # assertType ( make ( chan int ), ( intNum << 5 )| prefixChan ) # assertType ( new ( int ), ( intNum << 5 )| prefixPtr ) # assertType ([] int {}, ( intNum << 5 )| prefixSlice )
var tests = [] struct { # nums 1 [] int # m int # nums 2 [] int # n int # nums [] int # }{ # { # [] int { 1 , 2 , 3 , 0 , 0 , 0 }, 3 , # [] int { 2 , 5 , 6 }, 3 , # [] int { 1 , 2 , 2 , 3 , 5 , 6 }, # }, # } # # for _ , tt := range tests { # nums 1 := make ([] int , len ( tt . nums 1 )) # copy ( nums 1 , tt . nums 1 ) # # merge ( tt . nums 1 , tt . m , tt . nums 2 , tt . n ) # if reflect . DeepEqual ( tt . nums 1 , tt . nums ) == false { # t . Errorf (" STR ", nums 1 , tt . m , tt . nums 2 , tt . n , tt . nums 1 , tt . nums ) # } # }
max 1 , max 2 := 0 , 0 # for _ , num := range nums { # if num >= max 1 { # max 2 = max 1 # max 1 = num # } else if num <= max 1 && num >= max 2 { # max 2 = num # } # } # return ( max 1 - 1 ) * ( max 2 - 1 )
if s . top == len ( s . data ) { # return false # } # s . data [ s . top ] = i # s . top += 1 # return true
var n int # z := x ^ y # for z != 0 { # z = z & ( z - 1 ) # n ++ # } # return n
cases := [] struct { # name string # inputs int # expect int # }{ # {" STR ", 1 2 3 , 3 2 1 }, # {" STR ", - 1 2 3 , - 3 2 1 }, # {" STR ", 1 2 0 , 2 1 }, # {" STR ", 1 5 3 4 2 3 6 4 6 9 , 0 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := reverse ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
var tests = [] struct { # s , t * TreeNode # sub bool # }{ # { newTree ( 3 , 4 , 5 , 1 , 2 ), newTree ( 4 , 1 , 2 ), true }, # { newTree ( 3 , 4 , 5 , 1 , 2 , nil , nil , nil , nil , 0 ), newTree ( 4 , 1 , 2 ), false }, # } # # for _ , tt := range tests { # sub := isSubtree ( tt . s , tt . t ) # if sub != tt . sub { # t . Errorf (" STR ", tt . s , tt . t , sub , tt . sub ) # } # }
return h [:]
if len ( segs ) != len ( res ) { # return false # } # c := Constructor () # # for idx := 0 ; idx < len ( segs ); idx ++ { # if res [ idx ] != c . Book ( segs [ idx ]. start , segs [ idx ]. end ) { # return false # } # } # return true
sum , ans := 0 , make ([] int , 0 ) # for _ , v := range A { # if v % 2 == 0 { # sum += v # } # } # for _ , q := range queries { # v , i := q [ 0 ], q [ 1 ] # if A [ i ]% 2 == 0 { # sum -= A [ i ] # } # A [ i ] += v # if A [ i ]% 2 == 0 { # sum += A [ i ] # } # ans = append ( ans , sum ) # } # return ans
return s 1 == s 2
const sign = 1 << 6 3 # return float 6 4 frombits ( float 6 4 bits ( x ) &^ sign )
t := [] byte ( s ) # for l := 0 ; ; l += 2 * k { # r := l + k - 1 # if r >= len ( t ) { # r = len ( t ) - 1 # } # for i := l ; i < r ; i , r = i + 1 , r - 1 { # t [ i ], t [ r ] = t [ r ], t [ i ] # } # if ( l + 2 * k ) >= len ( t ) { # break # } # } # return string ( t )
t . Parallel () # for _ , tc := range testcases { # if result := BruteForcePartitionSet ( tc . multiset ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
t . Parallel () # for _ , tc := range testcases { # if result := StartIndicesAnagrams ( tc . W , tc . S ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
emp := Employee { # FirstName : " STR ", # LastName : " STR ", # JobTitle : " STR ", # } # data , err := json . Marshal ( emp ) # if err != nil { # fmt . Println ( err . Error ()) # return # } # jsonStr := string ( data ) # fmt . Println (" STR ") # fmt . Println ( jsonStr ) # # b := [] byte (`{" STR ": 1 0 1 ," STR ":" STR "," STR ":" STR "," STR ":" STR "}`) # var emp 1 Employee # err = json . Unmarshal ( b , & emp 1 ) # if err != nil { # fmt . Println ( err . Error ()) # return # } # fmt . Println (" STR ") # fmt . Printf (" STR ", emp 1 . ID , emp 1 . FirstName , emp 1 . LastName , emp 1 . JobTitle )
sumEven , sumOdd := 0 , 0 # for _ , v := range A { # if v % 2 == 0 { # sumEven += v # } else { # sumOdd += v # } # } # # result := make ([] int , len ( queries )) # for i , q := range queries { # idx , val := q [ 1 ], q [ 0 ] # if val % 2 == 0 { # if A [ idx ]% 2 == 0 { # sumEven += val # } else { # sumOdd += val # } # } else { # if A [ idx ]% 2 == 0 { # sumOdd += ( A [ idx ] + val ) # sumEven -= A [ idx ] # } else { # sumOdd -= A [ idx ] # sumEven += ( A [ idx ] + val ) # } # } # # result [ i ] = sumEven # A [ idx ] += val # } # # return result
cases := [] struct { # name string # nums [] int # k int # expect int # }{ # {" STR ", [] int { 3 , 1 , 4 , 1 , 5 }, 2 , 2 }, # {" STR ", [] int { 1 , 2 , 3 , 4 , 5 }, 1 , 4 }, # {" STR ", [] int { 1 , 3 , 1 , 5 , 4 }, 0 , 1 }, # {" STR ", [] int { 1 , 3 , 1 , 5 , 4 }, - 1 , 0 }, # {" STR ", [] int { 1 }, 0 , 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . nums , c . k ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . nums , c . k ) # } # }) # }
t . Parallel () # for _ , tc := range testcases { # if result := Sqrt ( tc . n ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
t . Parallel () # # for _ , tc := range testcases { # if result , _ := Reconstruct ( tc . preorder , tc . inorder ); ! treesEqual ( result , tc . expected ) { # t . Errorf (" STR ") # } # }
sum := 0 # for _ , num := range nums { # sum += num # } # # if ( sum + S )% 2 == 1 || S > sum { # return 0 # } # # sum = ( sum + S ) / 2 # dp := make ([] int , sum + 1 ) # dp [ 0 ] = 1 # # for i := 0 ; i < len ( nums ); i ++ { # for j := sum ; j >= 0 ; j -- { # if j >= nums [ i ] { # dp [ j ] += dp [ j - nums [ i ]] # } # } # } # # return dp [ sum ]
cases := [] struct { # name string # inputs int # expect [] int # }{ # {" STR ", 0 , [] int { 1 }}, # {" STR ", 3 , [] int { 1 , 3 , 3 , 1 }}, # {" STR ", 5 , [] int { 1 , 5 , 1 0 , 1 0 , 5 , 1 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
const ( # key = 1 0 # input = " STR " # ) # # encryptedText := Encrypt ( input , key ) # fmt . Printf (" STR ", key , input , encryptedText ) # # decryptedText := Decrypt ( encryptedText , key ) # fmt . Printf (" STR ", key , encryptedText , decryptedText ) #
var res [] int # if root == nil { # return res # } # var stack = []* Node { root } # for 0 < len ( stack ) { # res = append ( res , root . Val ) # for i := len ( root . Children ) - 1 ; 0 <= i ; i -- { # stack = append ( stack , root . Children [ i ]) # } # root = stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # } # return res
n := node .(* bstElement ) # if n != nil { # stop := callback ( t , n ) # if stop { # return true # } # stop = t . PreOrderWalk ( n . left , callback ) # if stop { # return true # } # stop = t . PreOrderWalk ( n . right , callback ) # return stop # } # return false
var ret int # var num int # # num = 3 8 # ret = 2 # if ret != addDigits ( num ) { # t . Fatalf (" STR ", ret ) # }
return largeNumber % smallNumber == 0
defer Recover ()
if num <= 2 { # return num # } # return stepOne ( num - 1 ) + stepOne ( num - 2 )
if memory , has := memo [ n ]; has { # return memory # } # # ret := 0 # for i := 1 ; i < n ; i ++ { # if n % i == 0 { # ret += i # } # } # # memo [ n ] = ret # # return ret
if n == 2 { # return 1 # } # # if n == 3 { # return 2 # } # # res := 1 # for n > 4 { # res *= 3 # n -= 3 # } # # return res * n
if list . head == nil { # return false # } # current := list . head # for current != nil { # if current . data == i { # return true # } # current = current . next # } # return false
switch b { # case BadgeTypeProfile : # return " STR " # case BadgeTypeUserNotFound : # return " STR " # case BadgeTypeRanking : # return " STR " # case BadgeTypeSolved : # return " STR " # case BadgeTypeSolvedRate : # return " STR " # case BadgeTypeAccepted : # return " STR " # case BadgeTypeAcceptedRate : # return " STR " # case BadgeTypeChartRanking : # return " STR " # case BadgeTypeChartSolved : # return " STR " # } # # return " STR "
if p . ID != "" && id != p . ID { # return ErrInconsistentIDs # } # # s . mtx . Lock () # defer s . mtx . Unlock () # # existing , ok := s . m [ id ] # if ! ok { # return ErrNotFound # } # # # if p . Name != "" { # existing . Name = p . Name # } # if len ( p . Addresses ) > 0 { # existing . Addresses = p . Addresses # } # s . m [ id ] = existing # return nil
testData := [] string { # " STR ", # " STR ", # " STR ", # } # expectedData := [] int { 3 , 1 , 3 } # # for index , data := range testData { # if res := lengthOfLongestSubstring ( data ); res != expectedData [ index ] { # t . Errorf (" STR ", expectedData [ index ], res ) # } # }
flag . Parse () # # roots := flag . Args () # if len ( roots ) == 0 { # roots = [] string {" STR "} # } # # fileSizes := make ( chan int 6 4 ) # var n sync . WaitGroup # for _ , root := range roots { # n . Add ( 1 ) # go walkDir ( root , & n , fileSizes ) # } # go func () { # n . Wait () # close ( fileSizes ) # }() # # var tick <- chan time . Time # if * vFlag { # tick = time . Tick ( 5 0 0 * time . Millisecond ) # } # var nfiles , nbytes int 6 4 # loop : # for { # select { # case size , ok := <- fileSizes : # if ! ok { # break loop # } # nfiles ++ # nbytes += size # case <- tick : # printDiskUsage ( nfiles , nbytes ) # } # } # # printDiskUsage ( nfiles , nbytes )
return Trie { root : & node { next : make ( map [ byte ]* node )}}
size := 1 << uint ( n ) # # seq := make ([] int , size ) # for bit := 1 ; bit < size ; bit <<= 1 { # for i := 0 ; i < bit ; i ++ { # seq [ bit + i ] = seq [ bit - 1 - i ] | bit # } # } # return seq
res := make ([] int , 0 , n ) # # i , j := 1 , n # # for i <= j { # if k % 2 == 1 { # res = append ( res , i ) # i ++ # } else { # res = append ( res , j ) # j -- # } # if k > 1 { # k -- # } # } # # return res
matrix := [][] int { # # { 0 , 1 , 2 , 0 }, # { 3 , 4 , 5 , 2 }, # { 1 , 3 , 1 , 5 }, # } # setZeroes ( matrix ) # # fmt . Println ( matrix )
str := [] byte ( s ) # l := len ( s ) # for i := 0 ; i < l / 2 ; i ++ { # if str [ i ] != str [ l - i - 1 ] { # j := l - i - 1 # return isPalindrome ( str , i + 1 , j ) || isPalindrome ( str , i , j - 1 ) # } # } # return true
m . mem = make ( map [ interface {}]* list . Element ) # m . pq = list . New () # for i := 0 ; i < size ; i ++ { # cacheItem := new ( cacheItem ) # cacheItem . dirty = false # m . pq . PushBack ( cacheItem ) # } # m . downStreamModel = downStreamModel # m . memory = self # return m
var recurse func ( left int , right int ) # var partition func ( left int , right int , pivot int ) int # # partition = func ( left int , right int , pivot int ) int { # v := arr [ pivot ] # right -- # arr [ pivot ], arr [ right ] = arr [ right ], arr [ pivot ] # # for i := left ; i < right ; i ++ { # if arr [ i ] <= v { # arr [ i ], arr [ left ] = arr [ left ], arr [ i ] # left ++ # } # } # # arr [ left ], arr [ right ] = arr [ right ], arr [ left ] # return left # } # # recurse = func ( left int , right int ) { # if left < right { # pivot := ( right + left ) / 2 # pivot = partition ( left , right , pivot ) # recurse ( left , pivot ) # recurse ( pivot + 1 , right ) # } # } # # recurse ( 0 , len ( arr )) # return arr
count := [ 2 6 ] int {} # for i := 0 ; i < len ( T ); i ++ { # count [ T [ i ]-' a ']++ # } # bs := [] byte {} # for i := 0 ; i < len ( S ); i ++ { # for count [ S [ i ]-' a '] > 0 { # bs = append ( bs , S [ i ]) # count [ S [ i ]-' a ']-- # } # } # for i , c := range count { # for c > 0 { # bs = append ( bs , byte ( i )+' a ') # c -- # } # } # return string ( bs )
n := len ( strs ) # res := - 1 # for i , str := range strs { # if len ( str ) < res { # continue # } # j := 0 # for j < n { # if i != j && isSubseq ( str , strs [ j ]) { # break # } # j ++ # } # if j == n { # res = max ( res , len ( str )) # } # } # return res
fileBuf , err := ioutil . ReadFile (" STR ") # if err != nil { # panic ( err ) # } # fileStr := string ( fileBuf ) # lines := strings . SplitN ( fileStr , " STR ", - 1 ) # var line [] string # arr := make ([][] int , 1 5 ) # for i := range arr { # line = strings . SplitN ( lines [ i ], " STR ", - 1 ) # arr [ i ] = make ([] int , len ( line )) # for j := range line { # arr [ i ][ j ], _ = strconv . Atoi ( line [ j ]) # } # } # for j := 1 4 ; j >= 0 ; j -- { # for i := 0 ; i < j ; i ++ { # if arr [ j ][ i ] > arr [ j ][ i + 1 ] { # arr [ j - 1 ][ i ] += arr [ j ][ i ] # } else { # arr [ j - 1 ][ i ] += arr [ j ][ i + 1 ] # } # } # } # return arr [ 0 ][ 0 ]
if n < 0 { # return [] string {} # } # solution := make ([] string , n ) # for i := 1 ; i <= n ; i ++ { # if i % 3 == 0 && i % 5 == 0 { # solution [ i - 1 ] = " STR " # } else if i % 3 == 0 { # solution [ i - 1 ] = " STR " # } else if i % 5 == 0 { # solution [ i - 1 ] = " STR " # } else { # solution [ i - 1 ] = strconv . Itoa ( i ) # } # } # return solution
t . Parallel () # for _ , tc := range testcases { # if result := FindTwoSumKInBST ( tc . head , tc . k ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
for i := 0 ; i < len ( nodes ); i ++ { # if nodes [ i ] == target { # return i # } # } # return - 1
t . Parallel () # for _ , tc := range testcases { # if result := WellBalanced ( tc . input ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result , tc . input ) # } # }
uint 6 4 Val := uint 6 4 ( self . GetLong ( index )) # return math . Float 6 4 frombits ( uint 6 4 Val )
var T = struct { # A string # B int # C bool # }{ # A : " STR ", # B : 2 , # C : true , # } # # a := make ( map [ string ] interface {}, 0 ) # FillMap ( T , a ) # # if len ( a ) != 3 { # t . Errorf (" STR ", len ( a )) # } # # inMap := func ( val interface {}) bool { # for _ , v := range a { # if reflect . DeepEqual ( v , val ) { # return true # } # } # # return false # } # # for _ , val := range [] interface {}{" STR ", 2 , true } { # if ! inMap ( val ) { # t . Errorf (" STR ", val ) # } # }
fake := & ListNode { Next : head } # p := fake # for p != nil && p . Next != nil { # if p . Next . Val == val { # p . Next = p . Next . Next # } else { # p = p . Next # } # } # return fake . Next
if n . p == nil { # return nil , - 1 # } # # i := n . p . searchKeyIdx ( n . keyValue [ 0 ]. key ) # # if n . p . LessByKey ( n . keyValue [ 0 ]. key , n . p . keyValue [ i ]. key ) { # if i <= 0 { # return nil , - 1 # } # return n . p . c [ i - 1 ], i - 1 # } # return n . p . c [ i ], i
n := len ( s ) # # dp := make ([][] int , n ) # for i := range dp { # dp [ i ] = make ([] int , n ) # dp [ i ][ i ] = 1 # } # # for Len := 2 ; Len <= n ; Len ++ { # for i := 0 ; i + Len - 1 < n ; i ++ { # j := i + Len - 1 # if s [ i ] == s [ j ] { # dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] + 2 # } else { # dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j - 1 ]) # } # } # } # # return dp [ 0 ][ n - 1 ]
return len ( p )
ListQueue = append ( ListQueue , n )
s , t := [] byte ( stamp ), [] byte ( target ) # sSize , tSize := len ( stamp ), len ( target ) # # res := make ([] int , 0 , 1 0 0 0 ) # # isStamped := func ( i int ) bool { # canStamp := false # for j := 0 ; j < sSize ; j ++ { # if t [ i + j ] == '?' { # continue # } # if t [ i + j ] != s [ j ] { # return false # } # canStamp = true # } # if canStamp { # for k := i ; k < i + sSize ; k ++ { # t [ k ] = '?' # } # res = append ( res , i ) # } # return canStamp # } # # maxIndex := tSize - sSize + 1 # # for { # isChanged := false # for i := 0 ; i < maxIndex ; i ++ { # isChanged = isChanged || isStamped ( i ) # } # if ! isChanged { # break # } # } # # reverse ( res ) # # if string ( t ) == strings . Repeat (" STR ", tSize ) { # return res # } # return nil
if len ( digits ) == 0 { # return nil # } # var res [] string # var str string # dfs ( digits , & res , str , 0 ) # return res
if num == 0 { # return false # } # for ; num % 2 == 0 ; num /= 2 { # } # for ; num % 3 == 0 ; num /= 3 { # } # for ; num % 5 == 0 ; num /= 5 { # } # if num == 1 { # return true # } # return false
ten := [] int { 1 0 0 , 7 5 , 5 0 , 2 5 , 1 1 , 4 5 , 7 8 , 9 9 , 1 0 1 , 1 2 } # tenK := 2 0 1 # t . Run (" STR ", func ( t * testing . T ) { # t . Parallel () # if result := TwoSumBrute ( ten , tenK ); ! result { # t . Error (" STR ") # } # if result := TwoSumBrute ( ten , 2 0 2 ); result { # t . Error (" STR ") # } # }) # t . Run (" STR ", func ( t * testing . T ) { # t . Parallel () # if result := TwoSumBetter ( ten , tenK ); ! result { # t . Error (" STR ") # } # if result := TwoSumBetter ( ten , 2 0 2 ); result { # t . Error (" STR ") # } # }) # t . Run (" STR ", func ( t * testing . T ) { # t . Parallel () # if result := TwoSumBest ( ten , tenK ); ! result { # t . Error (" STR ") # } # if result := TwoSumBest ( ten , 2 0 2 ); result { # t . Error (" STR ") # } # })
return dfs ( root , math . MinInt 6 4 , math . MaxInt 6 4 )
return strings . SplitN ( filePath , string ( filepath . Separator ), 2 )[ 0 ]
t . Parallel () # for _ , tc := range testcases { # head := createList ( tc . list ) # newhead := RemoveFromEnd ( head , tc . kth ) # result := backToSlice ( newhead ) # if ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
tail , res := make ([] int , len ( nums )), 0 # # for _ , n := range nums { # i := sort . SearchInts ( tail [: res ], n ) # tail [ i ] = n # if i == res { # res ++ # } # } # return res
cache = make ( map [ uint 6 4 ] int ) # max := 1 # var start uint 6 4 = 1 # # for i := uint 6 4 ( 2 ); i < 1 0 0 0 0 0 0 ; i += 1 { # length := collatzLength ( i ) # if length > max { # max = length # start = i # } # } # # fmt . Printf (" STR ", start , max )
dp := make ([] int , n + 1 ) # # for i := range dp { # dp [ i ] = - 1 # } # # nck := make ([][] int , n + 1 ) # # for i := range nck { # nck [ i ] = make ([] int , n + 1 ) # for j := range nck [ i ] { # nck [ i ][ j ] = - 1 # } # } # # currLog 2 := - 1 # currPower 2 := 1 # log 2 := make ([] int , n + 1 ) # # for i := 1 ; i <= n ; i ++ { # if currPower 2 == i { # currLog 2 ++ # # currPower 2 *= 2 # } # # log 2 [ i ] = currLog 2 # } # # return numberOfHeaps ( n , dp , log 2 , nck )
x := size / 2 # y := x # # dir := right # step := 1 # n := 1 # # for x < size { # var xDelta , yDelta int # # switch dir { # case right : # xDelta , yDelta = 1 , 0 # case down : # xDelta , yDelta = 0 , 1 # case left : # xDelta , yDelta = - 1 , 0 # case up : # xDelta , yDelta = 0 , - 1 # } # # for i := 0 ; i < step ; i ++ { # grid [ y ][ x ] = n # # x += xDelta # y += yDelta # n ++ # } # # dir = ( dir + 1 ) % 4 # # if dir % 2 == 0 { # step ++ # } # } # # sum := 0 # for i , row := range grid { # sum += row [ i ] # if i != size / 2 { # sum += row [ size - i - 1 ] # } # } # # fmt . Println ( sum )
fmt . Println ( swimInWater ([][] int {[] int { 0 , 2 }, [] int { 1 , 3 }})) # fmt . Println ( swimInWater ([][] int {[] int { 1 0 , 1 2 , 4 , 6 }, [] int { 9 , 1 1 , 3 , 5 }, [] int { 1 , 7 , 1 3 , 8 }, [] int { 2 , 0 , 1 5 , 1 4 }}))
flag := 0 # if isFlag { # flag = log . Ldate | log . Ltime | log . Lshortfile # } # # Trace = log . New ( traceHandle , " STR ", flag ) # Info = log . New ( infoHandle , " STR ", flag ) # Warning = log . New ( warningHandle , " STR ", flag ) # Error = log . New ( errorHandle , " STR ", flag ) #
op := is . lDOperation . init (" STR ", cost ) # op . lDCompute = is # return is
var res NumArray # res . Sum = make ([] int , len ( nums )+ 1 ) # for k , v := range nums { # res . Sum [ k + 1 ] = res . Sum [ k ] + v # } # return res
rw . ReadLock ( reader ) # # count := atomic . AddInt 3 2 (& rw . currentReads , 1 ) # # log . Printf (" STR ", rw . name , reader , count ) # time . Sleep ( time . Duration ( rand . Intn ( 1 0 0 0 )) * time . Millisecond ) # # count = atomic . AddInt 3 2 (& rw . currentReads , - 1 ) # log . Printf (" STR ", rw . name , reader , count ) # # rw . ReadUnlock ( reader )
xorResult := x ^ y # cnt := 0 # for xorResult > 0 { # if xorResult % 2 == 1 { # cnt ++ # } # xorResult /= 2 # } # return cnt
return RLEIterator { nums : A }
fileBuf , err := ioutil . ReadFile (" STR ") # if err != nil { # panic ( err ) # } # fileStr := string ( fileBuf ) # lines := strings . SplitN ( fileStr , " STR ", 1 0 0 ) # result := " STR " # carryout , digit := 0 , 0 # for i := 4 9 ; i >= 0 ; i -- { # sum := carryout # for j := range lines { # num , _ := strconv . Atoi ( string ( lines [ j ][ i ])) # sum += num # } # digit = sum % 1 0 # carryout = sum / 1 0 # result = strconv . Itoa ( digit ) + result # } # result = strconv . Itoa ( carryout ) + result # return result [ 0 : 1 0 ]
return new ( ltHeapArray )
if head == nil { # return head # } # # odd := head # even := head . Next # evenHead := even # # for even != nil && even . Next != nil { # odd . Next = odd . Next . Next # even . Next = even . Next . Next # odd = odd . Next # even = even . Next # } # odd . Next = evenHead # return head
var max , i int # # max = 1 # # for max <= n { # if i < len ( nums ) && nums [ i ] <= max { # max += nums [ i ] # i ++ # } else { # max <<= 1 # count ++ # } # } # # return
src , _ , err := image . Decode ( r ) # if err != nil { # return err # } # dst := Image ( src ) # return jpeg . Encode ( w , dst , nil )
target := make ( map [ string ] int ) # window := make ( map [ string ] int ) # for _ , v := range t { # target [ string ( v )]++ # } # left , right , validate := 0 , 0 , 0 # for right < len ( s )- 1 { # char := string ( s [ right ]) # right ++ # if v , ok := target [ char ]; ok && ( v >= 1 ) { # window [ char ]++ # if window [ char ] == target [ char ] { # validate ++ # } # } # for right - left >= len ( t ) { # if validate == len ( t ) { # return true # } # removeChar := string ( s [ left ]) # left ++ # if v , ok := target [ removeChar ]; ok && v >= 1 { # if window [ removeChar ] == target [ removeChar ] { # validate -- # } # window [ removeChar ]-- # } # } # } # return false
if strings . ContainsRune ( s , '@') { # return maskEmailAddress ( strings . ToLower ( s )) # } # return maskPhoneNumber ( s )
if n == 0 { # return 0 # } # # var nPrev uint = 0 # var nCur uint = 1 # var i uint = 0 # # for i = 1 ; i < n ; i ++ { # tmp := nCur # # nCur += nPrev # nPrev = tmp # } # # return nCur
if recurse ( 1 4 , 7 ) != 7 || # recurse ( 4 , 2 ) != 2 || # recurse ( 3 1 , 2 ) != 1 || # recurse ( 3 3 , 1 1 ) != 1 1 { # t . Error () # }
cases := [] struct { # name string # inputs int # expect [][] int # }{ # {" STR ", 5 , [][] int {{ 1 }, { 1 , 1 }, { 1 , 2 , 1 }, { 1 , 3 , 3 , 1 }, { 1 , 4 , 6 , 4 , 1 }}}, # {" STR ", 2 , [][] int {{ 1 }, { 1 , 1 }}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
ans , flag := 0 , 0 # for _ , b := range s { # if b == ' L ' { # flag -- # } else { # flag ++ # } # if flag == 0 { # ans ++ # } # } # return ans
size := [] int { 1 , 1 , 2 , 6 , 2 4 , 1 2 0 , 7 2 0 , 5 0 4 0 , 4 0 3 2 0 , 3 6 2 8 8 0 , 3 6 2 8 8 0 0 } # # list := make ([] int , n ) # for i := 1 ; i <= n ; i ++ { # list [ i - 1 ] = i # } # str := " STR " # k -- # for i := 0 ; i < n ; i ++ { # total := size [ n - i ] # idx := int ( k / int ( total /( n - i ))) # idx %= n - i # t := list [ idx ] # list = append ( list [: idx ], list [ idx + 1 :]...) # str += string (' 0 ' + t ) # # } # return str
if ! sort . IntsAreSorted ( listeners ) { # sort . Ints ( listeners ) # } # if ! sort . IntsAreSorted ( towers ) { # sort . Ints ( towers ) # } # var minRange int # towerIndex := 0 # for _ , listener := range listeners { # dist := abs ( listener - towers [ towerIndex ]) # for i := towerIndex ; i < len ( towers ); i ++ { # if d := abs ( listener - towers [ i ]); d > dist { # break # } else { # towerIndex = i # dist = d # } # } # if dist > minRange { # minRange = dist # } # } # return minRange
sort . Ints ( candidates ) # res := [][] int {} # var dfs func ( remain int , combo [] int , index int ) # dfs = func ( remain int , combo [] int , index int ) { # if remain == 0 { # t := make ([] int , len ( combo )) # copy ( t , combo ) # res = append ( res , t ) # return # } # # for i := index ; i < len ( candidates ); i ++ { # if candidates [ i ] > remain { # break # } # dfs ( remain - candidates [ i ], append ( combo , candidates [ i ]), i ) # } # } # dfs ( target , [] int {}, 0 ) # return res
j 1 := " STR " # s 1 := " STR " # fmt . Println ( numJewelsInStones ( j 1 , s 1 )) # # j 2 := " STR " # s 2 := " STR " # fmt . Println ( numJewelsInStones ( j 2 , s 2 ))
t 0 := time . Now () # result := 0 # for x := 1 2 3 4 5 6 ; x < 4 5 6 7 8 9 ; x ++ { # if checkValue ( x ) { # result = x # break # } # } # t 1 := time . Now () # # answer = fmt . Sprintf (" STR ", result ) # runTime = t 1 . Sub ( t 0 ) # # return
return filepath . Clean ( path )
min := arr [ 0 ] # for _ , v := range arr { # if v < min { # min = v # } # } # return min
return n . bTreeNodeSort . LessByKey ( n . keyValue [ i ]. key , n . keyValue [ j ]. key )
if e . min == nil { # return nil # } else if key == e . min . key { # return e . min . value # } else if key == e . max . key { # return e . max . value # } else if e . lgu == 1 { # return nil # } else { # if cluster , ok := e . cluster [ e . mixin . High ( e . lgu , key )]; ok { # return cluster . Member ( e . mixin . Low ( e . lgu , key )) # } # return nil # } #
testCases := [] struct { # name string # left int # right int # max int # }{ # { # name : " STR ", # left : 1 0 , # right : 9 , # max : 1 0 , # }, # { # name : " STR ", # left : 1 , # right : 1 0 , # max : 1 0 , # }, # } # # for _ , test := range testCases { # t . Run ( test . name , func ( t * testing . T ) { # returnedMax := Int ( test . left , test . right ) # if returnedMax != test . max { # t . Errorf (" STR ", # test . name , test . left , test . right , test . max , returnedMax ) # } # }) # }
if len ( postorder ) == 0 { # return nil # } # r := len ( postorder ) - 1 # root := & TreeNode { # Val : postorder [ r ], # Left : nil , # Right : nil , # } # if len ( postorder ) == 1 { # return root # } # idx := 0 # for idx = 0 ; postorder [ r ]!= inorder [ idx ]; idx ++{ # } # root . Left = buildTree ( inorder [: idx ], postorder [ 0 : idx ]) # root . Right = buildTree ( inorder [ idx + 1 :], postorder [ idx : r ]) # return root #
processes := [] string {" STR ", " STR ", " STR ", " STR "} # for _ , p := range processes { # Sum ( p ) # } # wg . Wait () # fmt . Println (" STR ", sum )
return rand . Intn ( 7 ) + 1
if len ( nums ) < 3 { # return false # } # num 3 , stack := math . MinInt 6 4 , [] int {} # for i := len ( nums ) - 1 ; i >= 0 ; i -- { # if nums [ i ] < num 3 { # return true # } # for len ( stack ) != 0 && nums [ i ] > stack [ len ( stack )- 1 ] { # num 3 = stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # } # stack = append ( stack , nums [ i ]) # fmt . Printf (" STR ", stack ) # } # return false
var player = checkRow ( board ) # if player == " STR " { # return " STR " # } else if player == " STR " { # return " STR " # } # player = checkColumn ( board ) # if player == " STR " { # return " STR " # } else if player == " STR " { # return " STR " # } # player = checkDiagonals ( board ) # if player == " STR " { # return " STR " # } else if player == " STR " { # return " STR " # } # count := 0 # for _ , v := range board { # for _ , val := range v { # if val == " STR " || val == " STR " { # count ++ # } # } # } # if count == 9 { # return " STR " # } else { # return " STR " # }
p := root # stack := []* TreeNode {} # sortedValues := [] int {} # for p != nil || len ( stack ) != 0 { # for p != nil { # stack = append ( stack , p ) # p = p . Left # } # if len ( stack ) != 0 { # p = stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # if len ( sortedValues ) != 0 && p . Val <= sortedValues [ len ( sortedValues )- 1 ] { # return false # } # sortedValues = append ( sortedValues , p . Val ) # p = p . Right # } # } # return true
sort . Ints ( candidates ) # # var combinations [][] int # # var f func ([] int , int , int ) # f = func ( combination [] int , index int , target int ) { # if target == 0 { # n := make ([] int , len ( combination )) # copy ( n , combination ) # combinations = append ( combinations , n ) # return # } # # for i , j := index , index + 1 ; i < len ( candidates ); i , j = j , j + 1 { # for j < len ( candidates ) && candidates [ i ] == candidates [ j ] { # j ++ # } # # c := combination # var sum int # for k := i ; k < j ; k ++ { # sum += candidates [ k ] # if sum > target { # break # } # c = append ( c , candidates [ k ]) # f ( c , j , target - sum ) # } # } # } # # f ( nil , 0 , target ) # return combinations
result := & quickUnion {} # result . IDs = make ([] int , n ) # for x := range result . IDs { # result . IDs [ x ] = x # } # return result
return LRUCache { # cap : capacity , # l : new ( list . List ), # m : make ( map [ int ]* list . Element , capacity ), # }
sort . Slice ( clips , func ( i int , j int ) bool { # return clips [ i ][ 0 ] < clips [ j ][ 0 ] # }) # # res := 0 # # for i , start , end := 0 , 0 , 0 ; start < T ; start = end { # for i < len ( clips ) && clips [ i ][ 0 ] <= start { # end = max ( end , clips [ i ][ 1 ]) # i ++ # } # if start == end { # return - 1 # } # res ++ # } # # return res
if nil == data || 0 > len ( data ) { # return 0 # } # # copy := make ([] int , len ( data )) # for id , value := range data { # copy [ id ] = value # } # # count := inversePairsCore ( data , copy , 0 , len ( data )- 1 ) # return count
start , end := 0 , len ( nums )- 1 # # for start < end { # for start < end && ( nums [ start ]% 2 == 1 ) { # start ++ # } # for start < end && ( nums [ end ]% 2 == 0 ) { # end -- # } # nums [ start ], nums [ end ] = nums [ end ], nums [ start ] # } # return nums
if left >= right { # if nums [ left ] == target { # return left # } else { # return - 1 # } # } # if nums [ left ] < nums [ right ] { # if nums [ left ] > target || nums [ right ] < target { # return - 1 # } # mid := int (( left + right ) / 2 ) # ret := help ( nums , left , mid , target ) # if ret != - 1 { # return ret # } # return help ( nums , mid + 1 , right , target ) # } else { # mid := int (( left + right ) / 2 ) # ret := help ( nums , left , mid , target ) # if ret != - 1 { # return ret # } # return help ( nums , mid + 1 , right , target ) # } # return - 1
return ! strings . Contains ( s , " STR ") && strings . Count ( s , " STR ") <= 1
if dest , err := os . Readlink ( filepath . Join ( path , " STR ")); nil == err { # return filepath . Dir ( filepath . Clean ( dest )) # } # return path
qs := [] question 7 4 { # # { # para 7 4 {[][] int {{ 1 , 3 , 5 , 7 }, { 1 0 , 1 1 , 1 6 , 2 0 }, { 2 3 , 3 0 , 3 4 , 5 0 }}, 3 }, # ans 7 4 { true }, # }, # # { # para 7 4 {[][] int {{ 1 , 3 , 5 , 7 }, { 1 0 , 1 1 , 1 6 , 2 0 }, { 2 3 , 3 0 , 3 4 , 5 0 }}, 1 3 }, # ans 7 4 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 4 , q . para 7 4 # fmt . Printf (" STR ", p , searchMatrix ( p . matrix , p . target )) # } # fmt . Printf (" STR ")
foo (& Bar {})
t . Parallel () # for _ , tc := range testcases { # if result , err := ShortestTransformation ( tc . start , tc . end , tc . dict ); err != tc . expectedErr || ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , tc . expectedErr , result , err ) # } # }
m := make ( map [ int ] int ) # for _ , num := range nums 1 { # m [ num ]++ # } # # nums := make ([] int , 0 ) # for _ , num := range nums 2 { # if m [ num ] != 0 { # m [ num ]-- # nums = append ( nums , num ) # } # } # return nums
floatValue := 4 . 9 9 # fmt . Printf (" STR ", floatValue )
nums := [] int { 1 , 1 , 1 , 2 , 2 , 3 } # k := 2 # expected := [] int { 1 , 2 } # if res := topKFrequent ( nums , k ); ! reflect . DeepEqual ( res , expected ) { # t . Errorf (" STR ", expected , res ) # }
dp := make ([] int , target + 1 ) # dp [ 0 ] = 1 # # for i := 1 ; i <= target ; i ++ { # for j := range nums { # if nums [ j ] <= i { # dp [ i ] += dp [ i - nums [ j ]] # } # } # } # # return dp [ target ]
return messageParser . Find ( data ) != nil
ans , l := 0 , len ( s ) # dp := make ([] int , l ) # for i , c := range s { # if i == 0 || c == '(' { # continue # } # if s [ i - 1 ] == '(' { # dp [ i ] = 2 # if i > 1 { # dp [ i ] += dp [ i - 2 ] # } # } else if i > dp [ i - 1 ] && s [ i - 1 - dp [ i - 1 ]] == '(' { # dp [ i ] = dp [ i - 1 ] + 2 # if i - 1 > dp [ i - 1 ] { # dp [ i ] += dp [ i - 2 - dp [ i - 1 ]] # } # } # if dp [ i ] > ans { # ans = dp [ i ] # } # } # return ans
return uint ( crc 3 2 . ChecksumIEEE ([] byte ( key ))) % m . buckets
fmt . Println ( subarraySum ([] int { 1 , 1 , 1 }, 2 )) # fmt . Println ( subarraySum ([] int { 1 }, 0 ))
self . table [ index ]. Ref = ref
res := 0 # m := map [ byte ] int { # ' I ': 1 , # ' V ': 5 , # ' X ': 1 0 , # ' L ': 5 0 , # ' C ': 1 0 0 , # ' D ': 5 0 0 , # ' M ': 1 0 0 0 , # } # # last := 0 # for i := len ( s ) - 1 ; i >= 0 ; i -- { # temp := m [ s [ i ]] # # sign := 1 # if temp < last { # sign = - 1 # } # # res += sign * temp # # last = temp # } # # return res
i := 1 # for { # if i % 1 1 == 0 && i % 1 2 == 0 && i % 1 3 == 0 && i % 1 4 == 0 && i % 1 5 == 0 && i % 1 6 == 0 && i % 1 7 == 0 && i % 1 8 == 0 && i % 1 9 == 0 && i % 2 0 == 0 { # fmt . Println ( i ) # return # } # i ++ # }
b := [] byte ( s ) # for i , j := 0 , 0 ; i < len ( b ); i = j + 1 { # for i < len ( b ) && b [ i ] == ' ' { # i ++ # } # j = i + 1 # for j < len ( b ) && b [ j ] != ' ' { # j ++ # } # # for k := j - 1 ; i < k ; i , k = i + 1 , k - 1 { # b [ i ], b [ k ] = b [ k ], b [ i ] # } # } # return string ( b )
hdrs := [] lout { # {" STR ", " STR ", [] token { # { itemError , ` wanted a " STR " ( got " STR ")`}}}, # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemError , ` wanted int - like until " STR " ( got " STR ")`}}}, # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemStart , " STR "}, # { itemError , ` wanted int - like until " STR " or eof ( got " STR ")`}}}, # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemError , ` wanted int - like until " STR " or eof ( got " STR ")`}}}, # } # for _ , h := range hdrs { # t . Run ( h . Name , lexCmp ( lexRequest , h )) # }
qs := [] question 1 1 8 4 { # # { # para 1 1 8 4 {[] int { 1 , 2 , 3 , 4 }, 0 , 1 }, # ans 1 1 8 4 { 1 }, # }, # # { # para 1 1 8 4 {[] int { 1 , 2 , 3 , 4 }, 0 , 2 }, # ans 1 1 8 4 { 3 }, # }, # # { # para 1 1 8 4 {[] int { 1 , 2 , 3 , 4 }, 0 , 3 }, # ans 1 1 8 4 { 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 1 8 4 , q . para 1 1 8 4 # fmt . Printf (" STR ", p , distanceBetweenBusStops ( p . distance , p . start , p . destination )) # } # fmt . Printf (" STR ")
for strings . Contains ( S , " STR ") { # S = strings . Replace ( S , " STR ", " STR ", - 1 ) # } # return len ( S )
d , i := len ( S ), 0 # result := make ([] int , 0 ) # for _ , c := range S { # if c == ' D ' { # result = append ( result , d ) # d -- # } else { # result = append ( result , i ) # i ++ # } # } # # result = append ( result , d ) # return result
largest := 0 # directions := [] Cursor {{- 1 , 0 }, { 0 , 1 }, { 1 , 0 }, { 0 , - 1 }, { 1 , 1 }, {- 1 , 1 }} # for _ , direction := range directions { # result := directionHandler ( cursor , matrix , direction ) # if result > largest { # largest = result # } # } # return largest
s := make ( Set ) # s . Add ( items ...) # return s
return big . NewInt ( 0 ). Exp ( big . NewInt ( base ), big . NewInt ( exp ), nil )
var nPermutations [] int # for i := 9 ; i > 0 ; i -- { # nPermutations = permutations ([] int {}, i ) # for j := len ( nPermutations ) - 1 ; j > 0 ; j -- { # if big . NewInt ( int 6 4 ( nPermutations [ j ])). ProbablyPrime ( 2 0 ) { # fmt . Println ( nPermutations [ j ]) # i , j = 0 , 0 # } # } # }
sort . Ints ( A ) # for i := len ( A ) - 3 ; i >= 0 ; i -- { # if A [ i ]+ A [ i + 1 ] > A [ i + 2 ] { # return A [ i ] + A [ i + 1 ] + A [ i + 2 ] # } # } # return 0
low , high := 0 , len ( nums )- 1 # for low < high { # if nums [ low ] < nums [ high ] { # return nums [ low ] # } # mid := low + ( high - low )>> 1 # if nums [ mid ] > nums [ low ] { # low = mid + 1 # } else if nums [ mid ] == nums [ low ] { # low ++ # } else { # high = mid # } # } # return nums [ low ]
var T = struct { # A string # B int # C bool # }{ # A : " STR ", # B : 2 , # C : true , # } # # a := Map ( T ) # # if typ := reflect . TypeOf ( a ). Kind (); typ != reflect . Map { # t . Errorf (" STR ", typ ) # } # # if len ( a ) != 3 { # t . Errorf (" STR ", len ( a )) # } # # inMap := func ( val interface {}) bool { # for _ , v := range a { # if reflect . DeepEqual ( v , val ) { # return true # } # } # # return false # } # # for _ , val := range [] interface {}{" STR ", 2 , true } { # if ! inMap ( val ) { # t . Errorf (" STR ", val ) # } # } #
sum , maxSum := - 1 << 3 1 , - 1 << 3 1 # for _ , n := range nums { # sum = max ( sum + n , n ) # maxSum = max ( maxSum , sum ) # } # return maxSum
m := make ( map [ int ] int ) # max := 0 # for _ , v := range wall { # r := 0 # v = v [: len ( v )- 1 ] # for _ , vv := range v { # m [ r + vv ]++ # if m [ r + vv ] > max { # max = m [ r + vv ] # } # r += vv # } # } # return len ( wall ) - max
var res , maxHigh , maxIdx , preHigh int # # for i , v := range input { # if v > maxHigh { # maxHigh = v # maxIdx = i # } # } # # for i := 0 ; i < maxIdx ; i ++ { # if input [ i ] > preHigh { # preHigh = input [ i ] # } # res += preHigh - input [ i ] # } # # preHigh = 0 # for i := len ( input ) - 1 ; i > maxIdx ; i -- { # if input [ i ] > preHigh { # preHigh = input [ i ] # } # res += preHigh - input [ i ] # } # return res
tests := [...] testType { # { # in : [] int { 3 , 1 , 2 , 4 }, # want : [] int { 2 , 4 , 3 , 1 }, # }, # } # for _ , tt := range tests { # got := sortArrayByParity ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
hdrs := [] lout { # {" STR ", " STR ", [] token { # { itemError , ` wanted a space ( got " STR ")`}}}, # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemError , ` wanted an int - like ( got " STR ")`}}}, # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemError , ` wanted an int - like ( got " STR ")`}}}, # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemStart , " STR "}, # { itemError , ` wanted an int - like ( got " STR ")`}}}, # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemStart , " STR "}, # { itemError , ` wanted an int - like ( got " STR ")`}}}, # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemStart , " STR "}, # { itemEnd , " STR "}, # { itemError , ` wanted int - like until end of string ( got " STR ")`}}}, # } # for _ , h := range hdrs { # t . Run ( h . Name , lexCmp ( lexResponse , h )) # }
if len ( lists ) == 0 { # return nil # } # if len ( lists ) == 1 { # return lists [ 0 ] # } # n := len ( lists ) / 2 # return merge ( mergeKLists 4 ( lists [: n ]), mergeKLists 4 ( lists [ n :]))
var b [] byte # for n > 0 { # n -- # b = append ( b , ' A '+ byte ( n % 2 6 )) # n /= 2 6 # } # for i , j := 0 , len ( b )- 1 ; i < j ; i , j = i + 1 , j - 1 { # b [ i ], b [ j ] = b [ j ], b [ i ] # } # return string ( b )
println (" STR ", t . name , " STR ", arg )
copied := append ([] int {}, denom ...) # sort . Sort ( sort . Reverse ( sort . IntSlice ( copied ))) # # return fewestCoinsBrute ( copied , target , MaxInt )
fnMinusTwo , fnMinusOne , fn := big . NewInt ( 1 ), big . NewInt ( 1 ), big . NewInt ( 2 ) # index := big . NewInt ( 3 ) # var limit big . Int # limit . Exp ( big . NewInt ( 1 0 ), big . NewInt ( 9 9 9 ), nil ) # for fn . Cmp (& limit ) < 0 { # fnMinusTwo = fnMinusOne # fnMinusOne = fn # fn = big . NewInt ( 0 ) # fn . Add ( fnMinusOne , fnMinusTwo ) # index . Add ( index , big . NewInt ( 1 )) # } # fmt . Println ( index )
head := & SinglyLL {} # current := head # # for _ , value := range data { # current . Next = & SinglyLL { Value : value , Next : nil } # current = current . Next # } # # return head . Next
b := filledMultiLRU ( time . Now (). Add ( time . Duration ( 4 ))) # # cpu := runtime . GOMAXPROCS ( 0 ) # ch := make ( chan bool ) # worker := func () { # for i := 0 ; i < bb . N / cpu ; i ++ { # expire := time . Now (). Add ( time . Duration ( 4 * time . Second )) # b . Set ( randomString ( 2 ), " STR ", expire ) # } # ch <- true # } # for i := 0 ; i < cpu ; i ++ { # go worker () # } # for i := 0 ; i < cpu ; i ++ { # _ = <- ch # }
t . Parallel () # for _ , tc := range testcases { # if result := BitwiseAndInclusiveRange ( tc . m , tc . n ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
size := len ( s ) # if size == 0 { # return 0 # } # # index := [ 2 6 ][] int {} # for i := range index { # index [ i ] = make ([] int , 0 , size ) # } # # for i , b := range s { # index [ b -' A '] = append ( index [ b -' A '], i ) # } # # res := 0 # for i := range index { # if len ( index [ i ]) == 0 { # continue # } # index [ i ] = append ( index [ i ], size ) # a , b , c := 0 , - 1 , index [ i ][ 0 ] # for j := 1 ; j < len ( index [ i ]); j ++ { # a , b , c = b , c , index [ i ][ j ] # res += (( b - a ) * ( c - b )) % module # res %= module # } # } # # return res
tests := [...] testType { # { # in : [] string {" STR ", " STR ", " STR "}, # want : 1 , # }, # { # in : [] string {" STR ", " STR "}, # want : 0 , # }, # { # in : [] string {" STR ", " STR ", " STR "}, # want : 3 , # }, # } # for _ , tt := range tests { # got := minDeletionSize ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if n == 1 { # * result = append (* result , string ( array )) # } else { # for i := 0 ; i < n ; i ++ { # generatePermutations ( array , n - 1 , result ) # if n % 2 == 0 { # array [ 0 ], array [ n - 1 ] = array [ n - 1 ], array [ 0 ] # } else { # array [ i ], array [ n - 1 ] = array [ n - 1 ], array [ i ] # } # } # }
defer rw . reportShutdown . Done () # # for { # select { # case <- rw . shutdown : # log . Printf (" STR ", rw . name ) # return # # default : # rw . performRead ( reader ) # } # }
if n < 1 { # return false # } # for n > 1 { # if n & 1 != 0 { # return false # } # n >>= 1 # } # return true
return k . Height
var T = struct { # A string # B int # C bool # }{ # A : " STR ", # B : 2 , # C : true , # } # # defer func () { # err := recover () # if err != nil { # t . Error (" STR ") # } # }() # # FillMap ( T , nil )
return root == nil || dfs ( root . Left , root . Right )
str 1 := " STR " # fmt . Println ( detectCapitalUse ( str 1 )) # # str 2 := " STR " # fmt . Println ( detectCapitalUse ( str 2 )) # # str 3 := " STR " # fmt . Println ( detectCapitalUse ( str 3 )) # # fmt . Println ( detectCapitalUse 2 ( str 1 )) # fmt . Println ( detectCapitalUse 2 ( str 2 )) # fmt . Println ( detectCapitalUse 2 ( str 3 ))
var i , j int # for i = 1 ; i < len ( arr ); i ++ { # for j = 0 ; j < i ; j ++ { # if arr [ j ] > arr [ i ] { # arr [ i ], arr [ j ] = arr [ j ], arr [ i ] # } # } # }
r := 0 # # for i := 1 ; i <= n ; i ++ { # r += ( i * i ) # } # # return r
return f != f
if power == 0 { # return 1 # } else if power % 2 == 0 { # return RecursivePower 1 ( n , power / 2 ) * RecursivePower 1 ( n , power / 2 ) # } else { # return n * RecursivePower 1 ( n , power / 2 ) * RecursivePower 1 ( n , power / 2 ) # }
fmt . Println ( MinInt ( 5 , 6 )) # fmt . Println ( MinInt ( 1 0 0 , - 1 )) # fmt . Println ( MinInt ( 1 0 , 1 0 ))
cases := [] struct { # name string # inputs [] string # expect bool # }{ # {" STR ", [] string { # " STR ", " STR ", " STR ", # }, true }, # {" STR ", [] string { # " STR ", " STR ", " STR ", # }, false }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := isInterleave 2 ( c . inputs [ 0 ], c . inputs [ 1 ], c . inputs [ 2 ]) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
n := len ( digits ) # for i := n - 1 ; i >= 0 ; i -- { # if digits [ i ] == 9 { # digits [ i ] = 0 # } else { # digits [ i ] += 1 # return digits # } # } # ans := make ([] int , n + 1 ) # ans [ 0 ] = 1 # return ans
P := new ( pair ) # P . point 1 = A # P . point 2 = B # P . distance = calcDistance ( A , B ) # # return P
if len ( x ) == * index { # return nil # } # fmt . Println ( x , x [* index ]) # if x [* index ] == - 1 { # * index = * index + 1 # return nil # } # (* index ) = * index + 1 # node := & TreeNode { Val : x [* index ]} # node . Left = GenTreeHelp ( x , index ) # return node
switch val := val .( type ) { # case Doubler : # println (" STR ", val . Double ()) # case int : # println (" STR ", val ) # case byte : # println (" STR ", val ) # case string : # println (" STR ", val ) # case Thing : # println (" STR ", val . String ()) # case * Thing : # println (" STR ", val . String ()) # case Foo : # println (" STR ", val ) # default : # println (" STR ") # }
dp := [ maxDiff ] int {} # for d := 1 ; d < maxDiff ; d ++ { # dp [ d ] = - 1 0 0 0 0 # } # for _ , r := range rods { # cur := dp # for d := 0 ; d + r < maxDiff ; d ++ { # dp [ d + r ] = max ( dp [ d + r ], cur [ d ]) # adr := abs ( d - r ) # dp [ adr ] = max ( dp [ adr ], cur [ d ]+ min ( d , r )) # } # } # return dp [ 0 ]
var res [] int # var min * TreeNode # for root != nil { # res = append ( res , root . Val ) # if root . Right == nil { # root = root . Left # } else { # min = root . Right # for min . Left != nil && min . Left != root { # min = min . Left # } # # min . Left = root . Left # root , root . Right = root . Right , nil # } # } # # l , r := 0 , len ( res )- 1 # for l < r { # res [ l ], res [ r ] = res [ r ], res [ l ] # l ++ # r -- # } # return res
if len ( nums ) == 0 { # return 0 , 0 # } # min , max = nums [ 0 ], nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] < min { # min = nums [ i ] # } # if nums [ i ] > max { # max = nums [ i ] # } # } # return min , max
return & BinaryTree {& BinaryTree {& BinaryTree { nil , nil }, # & BinaryTree {& BinaryTree { nil , nil }, nil }}, # & BinaryTree { nil , & BinaryTree { nil , nil }}}
t . Parallel () # # for _ , tc := range testcases { # if result := StrobogrammaticNumber ( tc . digits ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
n := len ( nums ) # # index := make ( map [ int ] int , n ) # index [ 0 ] = - 1 # # sum := 0 # # for i := 0 ; i < n ; i ++ { # sum += nums [ i ] # if k != 0 { # sum %= k # } # # idx , ok := index [ sum ] # if ok { # if i - idx > 1 { # return true # } # } else { # index [ sum ] = i # } # # } # # return false
if key == " STR " { # return # } # t . value += val - del # if len ( key ) == 1 { # t . end = true # return # } # ch , ok := t . children [ key [ 1 ]] # if ! ok { # ch = & Trie { char : key [ 1 ], children : map [ byte ]* Trie {}} # t . children [ key [ 1 ]] = ch # } # (* ch ). Insert ( key [ 1 :], val , del )
if r . element . Size != nil { # size , err := strconv . ParseInt (* r . element . Size , 0 , 3 2 ) # if err != nil { # panic ( err ) # } # return int ( size ) / 8 # } # return 4
this . mutex . Lock () # defer this . mutex . Unlock () # if ! this . closed { # this . pool <- 0 # }
tests := [...] testType { # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := freqAlphabets ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
for true { # if root . Val > p . Val && root . Val > q . Val { # root = root . Left # } else if root . Val < p . Val && root . Val < q . Val { # root = root . Right # } else { # return root # } # } # return root
fmt . Println (" STR ") # fmt . Println (" STR ") # fmt . Println (" STR ") # fmt . Println (" STR ") # fmt . Println (" STR ")
return fmt . Errorf ( # " STR ", ErrNotFound , # )
keys := make ([] interface {}, 0 , len ( st . elements )) # for k := range st . elements { # keys = append ( keys , k ) # } # return keys
sort . Slice ( nums , func ( i , j int ) bool { # return nums [ i ] < nums [ j ] # }) # # dp := make ([] int , len ( nums )) # dp [ len ( dp )- 1 ] = 1 # largestI , largestVal := 0 , 0 # # for i := len ( dp ) - 2 ; i >= 0 ; i -- { # m := 0 # # for j := i + 1 ; j < len ( dp ); j ++ { # if nums [ j ]% nums [ i ] == 0 { # m = max ( m , dp [ j ]) # } # } # # if dp [ i ] = 1 + m ; dp [ i ] > largestVal { # largestI = i # largestVal = dp [ i ] # } # } # # result := make ([] int , 0 , largestVal ) # # for i := largestI ; i < len ( nums ); i ++ { # if nums [ i ]% nums [ largestI ] == 0 { # result = append ( result , nums [ i ]) # } # } # # return result
if cmd == "" { # return 0 , nil # } # if c . writeTimeout != 0 { # c . conn . SetWriteDeadline ( time . Now (). Add ( c . writeTimeout )) # } # if err = c . writeIncrDecrCommand ( cmd , key , delta ); err == nil { # err = c . bw . Flush () # } # if err != nil { # return 0 , c . fatal ( err ) # } # if c . readTimeout != 0 { # c . conn . SetReadDeadline ( time . Now (). Add ( c . readTimeout )) # } # val , err = c . readIncrDecrReply () # return
n := len ( A ) # delta := make ([] int , n ) # for i , a := range A { # delta [( i - a + 1 + n )% n ]-- # } # res := 0 # for i := 1 ; i < n ; i ++ { # delta [ i ] += delta [ i - 1 ] + 1 # if delta [ res ] < delta [ i ] { # res = i # } # } # return res
handleBackspace := func ( s string ) string { # stack := make ([] rune , 0 ) # for _ , ch := range s { # if ch == '#' && len ( stack ) > 0 { # stack = stack [: len ( stack )- 1 ] # } else if ch != '#' { # stack = append ( stack , ch ) # } # } # # return string ( stack ) # } # # return handleBackspace ( S ) == handleBackspace ( T )
if tree == nil { # return 0 # } # leftDeep := getMaxDepth ( tree . left ) # rightDeep := getMaxDepth ( tree . right ) # if leftDeep > rightDeep { # return leftDeep + 1 # } # return rightDeep + 1
n 1 := make ([] int , N , N ) # n 2 := make ([] int , N , N ) # var a , b [] int # n 1 [ 0 ], n 2 [ 0 ] = 1 , 1 # for i := 3 ; ; i ++ { # if i % 2 == 0 { # a = n 1 # b = n 2 # } else { # a = n 2 # b = n 1 # } # for n := 0 ; n < N ; n ++ { # if n > 0 && a [ n - 1 ] > 9 { # a [ n ] += int ( a [ n - 1 ] / 1 0 ) # a [ n - 1 ] %= 1 0 # } # a [ n ] += b [ n ] # } # if a [ N - 1 ] != 0 { # println ( i ) # break # } # }
if ! strings . ContainsRune (" STR ", u . op ) { # return fmt . Errorf (" STR ", u . op ) # } # return u . x . Check ( vars )
s := newStruct () # # if ! s . Field (" STR "). IsEmbedded () { # t . Errorf (" STR ") # } # # if s . Field (" STR "). IsEmbedded () { # t . Errorf (" STR ") # }
low , high := 0 , len ( A )- 1 # for low <= high { # mid := low + ( high - low )>> 1 # if A [ mid ] > A [ mid + 1 ] && A [ mid ] > A [ mid - 1 ] { # return mid # } # if A [ mid ] > A [ mid + 1 ] && A [ mid ] < A [ mid - 1 ] { # high = mid - 1 # } # if A [ mid ] < A [ mid + 1 ] && A [ mid ] > A [ mid - 1 ] { # low = mid + 1 # } # } # return 0
starttime := time . Now () # # count := 0 # for x := 0 ; x < 1 << 3 0 ; x ++ { # # if x &( x << 1 ) == 0 { # count ++ # } # # } # # fmt . Println ( count ) # # fmt . Println (" STR ", time . Since ( starttime ))
aBytes , bBytes := [] byte ( a ), [] byte ( b ) # var carry , sum byte = ' 0 ', ' 0 ' # short , long := aBytes , bBytes # if len ( aBytes ) > len ( bBytes ) { # short , long = bBytes , aBytes # } # newShort := make ([] byte , len ( long )- len ( short )) # for i := range newShort { # newShort [ i ] = ' 0 ' # } # newShort = append ( newShort , short ...) # ret := make ([] byte , len ( long )+ 1 ) # for i := len ( long ) - 1 ; i >= 0 ; i -- { # sum , carry = add ( newShort [ i ], long [ i ], carry ) # ret [ i + 1 ] = sum # } # if carry == ' 1 ' { # ret [ 0 ] = carry # } else { # ret = ret [ 1 :] # } # return string ( ret )
if head == nil || head . Next == nil { # return head # } # newHead := reverseList ( head . Next ) # head . Next . Next = head # head . Next = nil # return newHead
t . Parallel () # for _ , tc := range testcases { # if maxProfit := MaxProfit ( tc . prices , tc . k ); maxProfit != tc . maxProfit { # t . Errorf (" STR ", tc . maxProfit , maxProfit ) # } # }
length := len ( nums ) # if length != 0 { # i := length - k % length # copy ( nums , append ( nums [ i : length ], nums [ 0 : i ]...)) # }
str , ac , bc := " STR ", 0 , 0 # for A > 0 || B > 0 { # if A > B && ac < 2 || bc == 2 { # str += " STR " # A , ac , bc = A - 1 , ac + 1 , 0 # } else { # str += " STR " # B , ac , bc = B - 1 , 0 , bc + 1 # } # } # return str
qs := [] question 1 0 4 7 { # # { # para 1 0 4 7 {" STR "}, # ans 1 0 4 7 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 4 7 , q . para 1 0 4 7 # fmt . Printf (" STR ", p , removeDuplicates 1 0 4 7 ( p . s )) # } # fmt . Printf (" STR ")
nums 1 := [][] int { # [] int { 1 , 3 }, # [] int { 1 , 2 , 3 }, # [] int { 4 }, # } # nums 2 := [][] int { # [] int { 2 }, # [] int { 4 , 5 , 6 }, # [] int { 1 , 2 , 3 , 7 , 8 , 9 , 1 0 , 1 1 }, # } # results := [] float 6 4 { # 2 , # 3 . 5 , # 7 , # } # caseNums := 3 # for i := 0 ; i < caseNums ; i ++ { # if ret := findMedianSortedArrays ( nums 1 [ i ], nums 2 [ i ]); ret != results [ i ] { # t . Fatalf (" STR ", i , results [ i ], ret ) # } # }
for i := 0 ; i < len ( board ); i ++ { # for j := 0 ; j < len ( board [ i ]); j ++ { # if i != 0 && j != 0 && i != len ( board ) - 1 && j != len ( board [ i ]) - 1 { # continue # } # if board [ i ][ j ] == ' O ' { # mark ( board , i , j ) # } # } # } # for i := 0 ; i < len ( board ); i ++ { # for j := 0 ; j < len ( board [ i ]); j ++ { # if board [ i ][ j ] == ' O ' { # board [ i ][ j ] = ' X ' # } else if board [ i ][ j ] == ' M ' { # board [ i ][ j ] = ' O ' # } # } # } # #
if l 1 == nil && l 2 == nil { # return nil # } # if l 1 == nil { # return l 2 # } # # if l 2 == nil { # return l 1 # } # # if l 1 . Val < l 2 . Val { # l 1 . Next = mergeTwoLists ( l 1 . Next , l 2 ) # return l 1 # } # l 2 . Next = mergeTwoLists ( l 1 , l 2 . Next ) # return l 2
if x < 0 || y < 0 || x >= N || y >= N { # return false # } # return true
typeAndValue () # formatToString ()
min , max := A [ 0 ], A [ 0 ] # for _ , v := range A { # if v < min { # min = v # } else if v > max { # max = v # } # } # ans := max - min - 2 * K # if ans < 0 { # return 0 # } # return ans
var rows [ 2 ][] int # rows [ 0 ] = make ([] int , rowIndex + 1 ) # rows [ 1 ] = make ([] int , rowIndex + 1 ) # for r := 0 ; r <= rowIndex ; r ++ { # i := r & 1 # rows [ i ][ 0 ] = 1 # for c := 1 ; c < r ; c ++ { # rows [ i ][ c ] = rows [ i ^ 1 ][ c - 1 ] + rows [ i ^ 1 ][ c ] # } # rows [ i ][ r ] = 1 # } # return rows [ rowIndex & 1 ]
stack := make ([] int , len ( ops )) # top := 0 # # for i := 0 ; i < len ( ops ); i ++ { # op := ops [ i ] # switch op { # case " STR ": # last 1 := stack [ top - 1 ] # last 2 := stack [ top - 2 ] # stack [ top ] = last 1 + last 2 # top ++ # case " STR ": # last 1 := stack [ top - 1 ] # stack [ top ] = last 1 * 2 # top ++ # case " STR ": # top -- # default : # stack [ top ], _ = strconv . Atoi ( op ) # top ++ # } # } # # points := 0 # for i := 0 ; i < top ; i ++ { # points += stack [ i ] # } # return points
candidate 1 , candidate 2 , count 1 , count 2 := 0 , 1 , 0 , 0 # for _ , num := range nums { # if num == candidate 1 { # count 1 ++ # } else if num == candidate 2 { # count 2 ++ # } else if count 1 == 0 { # candidate 1 , count 1 = num , 1 # } else if count 2 == 0 { # candidate 2 , count 2 = num , 1 # } else { # count 1 -- # count 2 -- # } # } # # count 1 , count 2 = 0 , 0 # for _ , num := range nums { # if num == candidate 1 { # count 1 ++ # } else if num == candidate 2 { # count 2 ++ # } # } # res := [] int {} # if count 1 > len ( nums )/ 3 { # res = append ( res , candidate 1 ) # } # if count 2 > len ( nums )/ 3 { # res = append ( res , candidate 2 ) # } # return res
var ret int # var nums [] int # ret = 1 # nums = [] int { 2 , 2 , 1 } # if ret != singleNumber ( nums ) { # t . Fatalf (" STR ", ret ) # } # # ret = 4 # nums = [] int { 4 , 1 , 2 , 1 , 2 } # if ret != singleNumber ( nums ) { # t . Fatalf (" STR ", ret ) # }
t . Parallel () # g := New () # first := g . GetInstance () # second := g . GetInstance () # if first == second { # t . Errorf (" STR ") # } # for i := 0 ; i < 1 0 0 ; i ++ { # if first != g . GetInstance () { # t . Errorf (" STR ") # } # if second != g . GetInstance () { # t . Errorf (" STR ") # } # }
testCases := [][] int { # { 7 , 1 , 5 , 3 , 6 , 4 }, # { 5 , 3 , 2 , 2 , 5 , 7 , 9 , 4 }, # {}, # { 3 }, # { 5 , 3 , 2 , 2 , 5 , 7 , 9 , 4 , 5 , 3 , 2 , 2 , 5 , 7 , 9 , 4 }, # { 2 , 4 , 1 , 1 1 , 7 }, # } # # expected := [] int { 5 , 7 , 0 , 0 , 7 , 1 0 } # # for index , data := range testCases { # if res := maxProfit ( data ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
x := [] int { 1 0 , 2 0 , 3 0 , 4 0 , 5 0 } # y := x [ 1 : 3 ] # fmt . Println (" STR ", y ) # fmt . Println ( len ( y )) # fmt . Println ( cap ( y )) # # z := x [: 3 ] # fmt . Println (" STR ", z ) # fmt . Println ( len ( z )) # fmt . Println ( cap ( z )) # x 1 := x [:] # fmt . Println (" STR ", x 1 ) # fmt . Println ( len ( x 1 )) # fmt . Println ( cap ( x 1 )) # # x 1 [ 4 ] = 7 5 # fmt . Println (" STR ", x ) # fmt . Println (" STR ", x 1 ) #
if stack . depth > 0 { # return stack . sp . item # } # # return nil
if num == 0 { # return " STR " # } # # res , sign := " STR ", " STR " # if num < 0 { # sign = " STR " # num *= - 1 # } # for num > 0 { # res = strconv . Itoa ( num % 7 ) + res # num /= 7 # } # return sign + res
var mystack MyStack # return mystack
cnt := [ 2 6 ] int {} # for i := range cnt { # cnt [ i ] = math . MaxUint 1 6 # } # cntInWord := [ 2 6 ] int {} # for _ , word := range A { # for _ , char := range [] byte ( word ) { # cntInWord [ char -' a ']++ # } # for i := 0 ; i < 2 6 ; i ++ { # if cntInWord [ i ] < cnt [ i ] { # cnt [ i ] = cntInWord [ i ] # } # } # for i := range cntInWord { # cntInWord [ i ] = 0 # } # } # result := make ([] string , 0 ) # for i := 0 ; i < 2 6 ; i ++ { # for j := 0 ; j < cnt [ i ]; j ++ { # result = append ( result , string ( rune ( i +' a '))) # } # } # return result
 # res := 1 # k -- # for k > 0 { # count := 0 # begin , end := res , res + 1 # for begin <= n { # count += min ( n + 1 , end ) - begin # begin *= 1 0 # end *= 1 0 # } # # if count <= k { # k -= count # res ++ # } else { # k -- # res *= 1 0 # } # # } # # return res
head := new (* ListNode ) # current := head # for e := range array { # if * current == nil { # * current = new ( ListNode ) # } # (** current ). Val = array [ e ] # current = &((* current ). Next ) # } # return * head
for i := 1 ; ; i ++ { # test ( i , arrayify ( i )) # }
f ( arg )
ans := 0 # for i := 0 ; i < len ( A [ 0 ]); i ++ { # for j , str := range A [ 1 :] { # if str [ i ] < A [ j ][ i ] { # ans ++ # break # } # } # } # return ans
file , _ := os . Open (" STR ") # fileScanner := bufio . NewScanner ( file ) # total := big . NewInt ( 0 ) # for fileScanner . Scan () { # line := fileScanner . Text () # current := big . NewInt ( 0 ) # current . SetString ( line , 1 0 ) # total . Add ( total , current ) # } # return total
type A struct { # Name string # } # a := A { Name : " STR "} # # type B struct { # A # C int # } # b := & B { C : 1 2 3 } # b . A = a # # s := Fields ( b ) # # inSlice := func ( val interface {}) bool { # for _ , v := range s { # if reflect . DeepEqual ( v . Name (), val ) { # return true # } # } # return false # } # # for _ , val := range [] interface {}{" STR ", " STR "} { # if ! inSlice ( val ) { # t . Errorf (" STR ", val ) # } # }
sort . Ints ( stones ) # return [] int { low ( stones ), high ( stones )}
m := map [ string ] int {} # for k := 0 ; k < len ( words ); k ++ { # for i := 0 ; i <= 1 0 && i <= len ( words [ k ]); i ++ { # for j := len ( words [ k ]); 0 <= j && len ( words [ k ])- 1 0 <= j ; j -- { # m [ words [ k ][: i ]+" STR "+ words [ k ][ j :]] = k # } # } # } # return WordFilter { m : m }
self . pc = value
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", # [][] int { # { 4 , 3 , 8 , 4 }, # { 9 , 5 , 1 , 9 }, # { 2 , 7 , 6 , 2 }, # }, # 1 }, # {" STR ", # [][] int { # { 1 , 3 , 8 , 2 }, # { 7 , 5 , 1 , 9 }, # { 2 , 9 , 6 , 3 }, # }, # 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
values , err := url . ParseQuery ( req . URL . String ()[ 1 :]) # if err != nil { # fmt . Fprintf ( w , err . Error ()) # } # * numThreads , _ = strconv . Atoi ( values . Get (" STR ")) # * method = values . Get (" STR ") # * numConnections , _ = strconv . Atoi ( values . Get (" STR ")) # * totalCalls , _ = strconv . Atoi ( values . Get (" STR ")) # * disableKeepAlives , _ = strconv . ParseBool ( values . Get (" STR ")) # toCall , _ := url . QueryUnescape ( values . Get (" STR ")) # fmt . Fprintf ( w , string ( SingleNode ( toCall )))
q := NewQueue () # q . Add ( 1 ) # q . Add ( 2 ) # q . Add ( 3 ) # fmt . Printf (" STR ", q . Len ()) # v := q . Remove ().( int ) # fmt . Printf (" STR ", v ) # fmt . Printf (" STR ", q . Len ()) # q . Clear () # fmt . Printf (" STR ", q . Len ()) # c := time . After ( 1 0 0 * time . Millisecond ) # d := make ( chan int ) # go func () { # v := q . RemoveWait () # fmt . Printf (" STR ", v ) # d <- 0 # }() # <- c # q . Close () # <- d
if s == " STR " || len ( d ) == 0 { # return " STR " # } # var res string # for _ , v := range d { # if len ( v ) > len ( s ) { # continue # } # i := 0 # j := 0 # for i < len ( v ) && j < len ( s ) { # if v [ i ] == s [ j ] { # if len ( v [ i :]) > len ( s [ j :]) { # break # } # i ++ # } # j ++ # } # if i == len ( v ) { # if len ( v ) == len ( res ) { # if v < res { # res = v # } # } else if len ( v ) > len ( res ) { # res = v # } # } # } # # return res
queue . array = append ( queue . array , val )
arr := randomSlice ( 0 , 2 0 , 1 0 ) # nodeCnt := 0 # bst := newBstRecrusive () # for _ , v := range arr { # bst . Insert ( uint 3 2 ( v )) # } # bst . InOrderWalk ( bst . root , checkBst ( t , & nodeCnt , * debug )) # if nodeCnt != len ( arr ) { # t . Log ( fmt . Sprintf (" STR ", len ( arr ), nodeCnt )) # t . Fail () # }
tests := [...] testType { # { # in : [] int { 4 , 2 , 5 , 7 }, # want : [] int { 4 , 5 , 2 , 7 }, # }, # { # in : [] int { 2 , 3 , 1 , 1 , 4 , 0 , 0 , 4 , 3 , 3 }, # want : [] int { 2 , 3 , 0 , 1 , 4 , 1 , 0 , 3 , 4 , 3 }, # }, # } # for _ , tt := range tests { # got := sortArrayByParityII ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
qs := [] question 9 { # # { # para 9 { 1 2 1 }, # ans 9 { true }, # }, # # { # para 9 {- 1 2 1 }, # ans 9 { false }, # }, # # { # para 9 { 1 0 }, # ans 9 { false }, # }, # # { # para 9 { 3 2 1 }, # ans 9 { false }, # }, # # { # para 9 {- 1 2 3 }, # ans 9 { false }, # }, # # { # para 9 { 1 2 0 }, # ans 9 { false }, # }, # # { # para 9 { 1 5 3 4 2 3 6 4 6 9 }, # ans 9 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 , q . para 9 # fmt . Printf (" STR ", p . one , isPalindrome ( p . one )) # } # fmt . Printf (" STR ")
qs := [] question 1 0 7 9 { # # { # para 1 0 7 9 {" STR "}, # ans 1 0 7 9 { 8 }, # }, # # { # para 1 0 7 9 {" STR "}, # ans 1 0 7 9 { 1 8 8 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 7 9 , q . para 1 0 7 9 # fmt . Printf (" STR ", p , numTilePossibilities ( p . one )) # } # fmt . Printf (" STR ")
if nil == nums || len ( nums ) < 1 { # return 0 # } # # newLength := 1 # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] != nums [ newLength - 1 ] { # nums [ newLength ] = nums [ i ] # newLength ++ # } # } # return newLength
bytes := [] byte ( s ) # i , j := 0 , len ( bytes )- 1 # L : # for i < j { # for { # if i >= j { # break L # } # if ! isAlpha ( bytes [ i ]) { # i ++ # } else { # break # } # } # for { # if i >= j { # break L # } # if ! isAlpha ( bytes [ j ]) { # j -- # } else { # break # } # } # if toLower ( bytes [ i ]) != toLower ( bytes [ j ]) { # return false # } # i ++ # j -- # } # return true
moveZeroes ([] int { 0 , 1 , 0 , 3 , 1 2 }) # moveZeroes ([] int { 0 , 0 , 1 }) # bestMoveZeroes ([] int { 1 , 2 , 3 , 0 , 0 , 4 })
type Foo struct { # A string # B bool # } # f := & Foo {} # # n := Name ( f ) # if n != " STR " { # t . Errorf (" STR ", n ) # } # # unnamed := struct { Name string }{ Name : " STR "} # m := Name ( unnamed ) # if m != "" { # t . Errorf (" STR ", n ) # } # # defer func () { # err := recover () # if err == nil { # t . Error (" STR ") # } # }() # # Name ([] string {})
t := [] byte ( T ) # sort . Slice ( t , func ( i , j int ) bool { # idxI , idxJ := strings . IndexByte ( S , t [ i ]), strings . IndexByte ( S , t [ j ]) # return idxI < idxJ # }) # # return string ( t )
var tests = [] struct { # nums [] int # missing int # }{ # {[] int { 3 , 0 , 1 }, 2 }, # {[] int { 9 , 6 , 4 , 2 , 3 , 5 , 7 , 0 , 1 }, 8 }, # } # # for _ , tt := range tests { # missing := missingNumber ( tt . nums ) # if missing != tt . missing { # t . Errorf (" STR ", tt . nums , missing , tt . missing ) # } # }
cur := head # for cur != nil && cur . Next != nil { # if cur . Next . Val == cur . Val { # cur . Next = cur . Next . Next # } else { # cur = cur . Next # } # } # return head
m := make ( map [ int ][] int ) # for i := 0 ; i < len ( nums ); i ++ { # m [ nums [ i ]] = append ( m [ nums [ i ]], i ) # } # degree , ret := 0 , len ( nums ) # for _ , v := range m { # if len ( v ) > degree { # degree = len ( v ) # ret = v [ len ( v )- 1 ] - v [ 0 ] + 1 # } else if len ( v ) == degree { # if ret > v [ len ( v )- 1 ]- v [ 0 ]+ 1 { # ret = v [ len ( v )- 1 ] - v [ 0 ] + 1 # } # } # } # return ret #
if root == nil { # return nil # } # # if root . Left == nil && root . Right == nil { # return [] int { root . Val } # } # # res := inorderTraversal ( root . Left ) # res = append ( res , root . Val ) # res = append ( res , inorderTraversal ( root . Right )...) # # return res
if n <= 3 { # return n > 1 # } # if n % 2 == 0 || n % 3 == 0 { # return false # } # # for i := 5 ; i * i <= n ; i += 6 { # if n % i == 0 || n % ( i + 2 )== 0 { # return false # } # } # return true
m := make ( map [ string ] map [ string ] float 6 4 ) # for i , e := range equations { # a , b := e [ 0 ], e [ 1 ] # v := values [ i ] # if _ , ok := m [ a ]; ! ok { # m [ a ] = make ( map [ string ] float 6 4 ) # } # m [ a ][ b ] = 1 . 0 / v # if _ , ok := m [ b ]; ! ok { # m [ b ] = make ( map [ string ] float 6 4 ) # } # m [ b ][ a ] = v # } # # res := make ([] float 6 4 , len ( queries )) # for i , q := range queries { # res [ i ] = bfs ( m , q [ 0 ], q [ 1 ]) # } # # return res
if nil == data || len ( data ) < 2 { # return 0 , 0 # } # # var result int # for i := 0 ; i < len ( data ); i ++ { # result ^= data [ i ] # } # indexOf 1 := findFirstBitIs 1 ( result ) # var num 1 , num 2 int # for j := 0 ; j < len ( data ); j ++ { # if isBit 1 ( data [ j ], indexOf 1 ) { # num 1 ^= data [ j ] # } else { # num 2 ^= data [ j ] # } # } # return num 1 , num 2
counter := 3 # answer := 2 # for ; counter < 2 0 0 0 0 0 0 ; counter += 2 { # if isPrime ( counter ){ # answer += counter # } # } # fmt . Printf (" STR ", answer )
var res int # size := len ( nums ) # # checkFunc := func ( n int ) func ( int ) { # init := 1 # if n < 0 { # init = - 1 # } # res = 2 # # return func ( x int ) { # var new int # # switch { # case x < 0 : # new = - 1 # case x > 0 : # new = 1 # default : # return # } # # if init * new < 0 { # res ++ # init = new # } # } # } # # var check func ( int ) # var i = 1 # for i < size && nums [ i ]- nums [ i - 1 ] == 0 { # i ++ # } # # if i == size { # return 1 # } # # check = checkFunc ( nums [ i ] - nums [ i - 1 ]) # # for i < size { # check ( nums [ i ] - nums [ i - 1 ]) # i ++ # } # # return res
n := len ( s ) # # i := 0 # for i < n && ( s [ i ] < ' 0 ' || ' 9 ' < s [ i ]) { # i ++ # } # if i == n { # return s # } # # j := i + 1 # for s [ j ] != '[' { # j ++ # } # # k := j # count := 1 # for count > 0 { # k ++ # # if s [ k ] == '[' { # count ++ # } else if s [ k ] == ']' { # count -- # } # } # # # num , _ := strconv . Atoi ( s [ i : j ]) # # return s [: i ] + times ( num , decodeString ( s [ j + 1 : k ])) + decodeString ( s [ k + 1 :])
m := map [ string ] int {} # for _ , s := range strings . Fields ( A ) { # m [ s ]++ # } # for _ , s := range strings . Fields ( B ) { # m [ s ]++ # } # res := [] string {} # for s , c := range m { # if c == 1 { # res = append ( res , s ) # } # } # return res
mutex := sync . Mutex {} # wg := sync . WaitGroup {} # maxLength := 0 # maxLengthStarter := float 6 4 ( 0 ) # # for i := float 6 4 ( 0 ); i < 1 0 0 0 0 0 0 ; i ++ { # # wg . Add ( 1 ) # go chainAndCount ( i , & mutex , & wg , & maxLength , & maxLengthStarter ) # # } # # wg . Wait () # # fmt . Println ( maxLengthStarter ) #
tests := [...] testType { # { # in : [] int { 5 , 4 , 0 , 3 , 1 , 6 , 2 }, # want : 4 , # }, # { # in : [] int { 0 , 3 , 1 , 5 , 4 , 6 , 2 }, # want : 5 , # }, # { # in : [] int { 6 , 2 , 5 , 4 , 0 , 3 , 1 }, # want : 7 , # }, # { # in : [] int { 3 , 1 , 5 , 4 , 0 , 6 , 2 }, # want : 3 , # }, # } # for _ , tt := range tests { # got := arrayNesting ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
fmt . Println ( intToRoman ( 1 9 9 4 )) # fmt . Println ( intToRoman ( 2 0 ))
for _ , match := range matches { # scores [ match . Winner ], scores [ match . Loser ] = # playGame ( scores [ match . Winner ], scores [ match . Loser ], kFactor ) # } # # return scores
obj := Constructor () # obj . Push_back ( 1 ) # obj . Push_back ( 2 ) # param_ 1 := obj . Max_value () # param_ 2 := obj . Pop_front () # param_ 3 := obj . Max_value () # fmt . Println ( param_ 1 , param_ 2 , param_ 3 )
var majority , cnt int # for _ , num := range nums { # if cnt == 0 { # majority = num # } # if num == majority { # cnt ++ # } else { # cnt -- # } # } # return majority
t . Parallel () # # for tcid , tc := range testcases { # if res := RootToLeafTarget ( tc . root , tc . target ); res != tc . expected { # t . Errorf (" STR ", tcid , tc . expected , res ) # } # }
ans := 0 # for i := 1 ; i <= n ; i *= 1 0 { # a := n / i # b := n % i # if 0 == a % 1 0 { # ans += i * a / 1 0 # } else if 1 == a % 1 0 { # ans += i * a / 1 0 + b + 1 # } else { # ans += ( a / 1 0 + 1 ) * i # } # } # return ans
println ( isNumber (" STR "))
if srs . eof { # return 0 , io . EOF # } # # if srs . pos > srs . rpos { # n , err := io . CopyN ( ioutil . Discard , srs . r , srs . pos - srs . rpos ) # srs . rpos += n # if err != nil { # switch err { # case io . EOF , io . ErrUnexpectedEOF : # srs . eof = true # return 0 , io . EOF # default : # return 0 , err # } # } # } # # if srs . rpos != srs . pos { # return 0 , errSeekPos # } # # n , err := srs . r . Read ( p ) # srs . rpos += int 6 4 ( n ) # srs . pos = srs . rpos # switch err { # case io . EOF , io . ErrUnexpectedEOF : # srs . eof = true # } # # return n , err
qs := [] question 4 8 0 { # # { # para 4 8 0 {[] int { 1 , 3 , - 1 , - 3 , 5 , 3 , 6 , 7 }, 3 }, # ans 4 8 0 {[] int { 1 , - 1 , - 1 , 3 , 5 , 6 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 8 0 , q . para 4 8 0 # fmt . Printf (" STR ", p , medianSlidingWindow 1 ( p . one , p . k )) # } # fmt . Printf (" STR ")
n := len ( digits ) # for i := n - 1 ; i >= 0 ; i -- { # if digits [ i ] < 9 { # digits [ i ] += 1 # return digits # } else { # digits [ i ] = 0 # } # } # ret := make ([] int , n + 1 ) # ret [ 0 ] = 1 # return ret
distChannel := make ( chan string , len ( config . Nodes )* 2 ) # wg := & sync . WaitGroup {} # for _ , node := range config . Nodes { # go runChild ( distChannel , wg , node ) # wg . Add ( 1 ) # } # wg . Wait () # CalcDistStats ( distChannel )
n := len ( arr ) # for i := 0 ; i < n - n / 4 ; i ++ { # if arr [ i ] == arr [ i + n / 4 ] { # return arr [ i ] # } # } # return - 1
if root == nil { # return true , 0 # } # lbh , lh := check ( root . Left ) # rbh , rh := check ( root . Right ) # ishb := lbh && rbh && abs ( lh - rh ) <= 1 # return ishb , max ( lh , rh ) + 1
res := [][] int {} # sort . Ints ( nums ) # # for i := 0 ; i < len ( nums )- 3 ; i ++ { # if i > 0 && nums [ i ] == nums [ i - 1 ] { # continue # } # # for j := i + 1 ; j < len ( nums )- 2 ; j ++ { # if j > i + 1 && nums [ j ] == nums [ j - 1 ] { # continue # } # # l , r := j + 1 , len ( nums )- 1 # for l < r { # s := nums [ i ] + nums [ j ] + nums [ l ] + nums [ r ] # switch { # case s < target : # l ++ # case s > target : # r -- # default : # res = append ( res , [] int { nums [ i ], nums [ j ], nums [ l ], nums [ r ]}) # l , r = next ( nums , l , r ) # } # } # } # # } # return res
tests := map [ string ] bool { # " STR ": true , # " STR ": true , # " STR ": true , # " STR ": true , # " STR ": false , # " STR ": false , # " STR ": false , # " STR ": false , # } # # for in , want := range tests { # got := isValid ( in ) # if got != want { # t . Fatalf (" STR ", in , got , want ) # } # }
return int ( i )
if n == 1 { # return 1 # } # records := [] int { 1 } # i , j , k := 0 , 0 , 0 # for len ( records ) < n { # next := min ( 2 * records [ i ], min ( 3 * records [ j ], 5 * records [ k ])) # if next == 2 * records [ i ] { # i ++ # } # if next == 3 * records [ j ] { # j ++ # } # if next == 5 * records [ k ] { # k ++ # } # records = append ( records , next ) # } # return records [ len ( records )- 1 ]
in , out := " STR ", 7 0 6 0 0 6 7 4 # if x := p 1 1 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # }
var target int # var ret [] int # var nums [] int # # ret = [] int { 5 , 6 , 7 , 1 , 2 , 3 , 4 } # nums = [] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 } # target = 3 # rotate ( nums , target ) # for i , v := range nums { # if v != ret [ i ] { # t . Fatalf (" STR ", ret ) # } # }
ret := make ([][] int , r ) # for k := range ret { # ret [ k ] = make ([] int , c ) # } # if len ( nums ) == 0 || r * c != len ( nums )* len ( nums [ 0 ]) { # return nums # } # rows , cols := 0 , 0 # for i := 0 ; i < len ( nums ); i ++ { # for j := 0 ; j < len ( nums [ 0 ]); j ++ { # ret [ rows ][ cols ] = nums [ i ][ j ] # cols ++ # if cols == c { # rows ++ # cols = 0 # } # } # } # return ret
var tests = [] struct { # nums 1 , nums 2 [] int # intersection [] int # }{ # { # [] int { 1 , 2 , 2 , 1 }, [] int { 2 , 2 }, # [] int { 2 , 2 }, # }, # { # [] int { 4 , 9 , 5 }, [] int { 9 , 4 , 9 , 8 , 4 }, # [] int { 4 , 9 }, # }, # } # # for _ , tt := range tests { # nums := intersect ( tt . nums 1 , tt . nums 2 ) # sort . Ints ( nums ) # if reflect . DeepEqual ( nums , tt . intersection ) == false { # t . Errorf (" STR ", tt . nums 1 , tt . nums 2 , nums , tt . intersection ) # } # }
index , maxIndex , numsLen := 0 , 0 , len ( nums ) # if numsLen == 0 { # return - 1 # } # # for maxIndex + 1 < numsLen && nums [ maxIndex ] < nums [ maxIndex + 1 ] { # maxIndex ++ # } # # for l , r := 0 , numsLen ; l < r ; { # m := ( l + r ) / 2 # index = m + maxIndex + 1 # if index >= numsLen { # index -= numsLen # } # # if nums [ index ] > target { # r = m # } else if nums [ index ] < target { # l = m + 1 # } else { # return index # } # } # return - 1
qs := [] question 2 6 8 { # # { # para 2 6 8 {[] int { 3 , 0 , 1 }}, # ans 2 6 8 { 2 }, # }, # # { # para 2 6 8 {[] int { 9 , 6 , 4 , 2 , 3 , 5 , 7 , 0 , 1 }}, # ans 2 6 8 { 8 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 6 8 , q . para 2 6 8 # fmt . Printf (" STR ", p , missingNumber ( p . s )) # } # fmt . Printf (" STR ")
resp , err := http . Get ( url ) # if err != nil { # return "", 0 , err # } # defer resp . Body . Close () # # local := path . Base ( resp . Request . URL . Path ) # if local == " STR " { # local = " STR " # } # f , err := os . Create ( local ) # if err != nil { # return "", 0 , err # } # n , err = io . Copy ( f , resp . Body ) # if closeErr := f . Close (); err == nil { # err = closeErr # } # return local , n , err
if num == 0 { # return 1 # } # return num * factorial ( num - 1 )
this . total -- # if this . total == 0 { # this . top = 0 # } else { # for this . top > 0 && this . queues [ this . top ]. Len () == 0 { # this . top -- # } # }
team := struct { # teams [] string # manager string # }{ # [] string {" STR ", " STR ", " STR "}, # " STR ", # } # fmt . Printf (" STR ", team ) #
link := & linkTable { # Head : & linkNodeItem { # val : 1 , # next : & linkNodeItem { # val : 2 , # next : & linkNodeItem { # val : 3 , # next : & linkNodeItem { # val : 4 , # next : & linkNodeItem { # val : 5 , # next : & linkNodeItem { # val : 6 , # next : & linkNodeItem { # val : 7 , # next : nil , # }, # }, # }, # }, # }, # }, # }, # } # return link
fmt . Println ( isNStraightHand ([] int { 1 , 2 , 3 , 6 , 2 , 3 , 4 , 7 , 8 }, 3 ))
t . Parallel () # arr := [] int { 0 , 0 , 0 , 0 , 9 , 8 , 7 , 6 , 0 , 0 } # sa := NewSparseArray ( arr ) # for i , val := range arr { # if result , err := sa . Get ( i ); result != val || err != nil { # t . Errorf (" STR ", val , nil , result , err ) # } # } # if err := sa . Set ( 0 , 1 0 ); err != nil { # t . Error (" STR ", err ) # } # if result , err := sa . Get ( 0 ); result != 1 0 || err != nil { # t . Error (" STR ") # } # if err := sa . Set ( 0 , 0 ); err != nil { # t . Error (" STR ", err ) # } # for i , val := range arr { # if result , err := sa . Get ( i ); result != val || err != nil { # t . Errorf (" STR ", val , nil , result , err ) # } # }
fmt . Println ( toHex ( 1 4 )) # fmt . Println ( toHex (- 1 ))
n := node .(* bstElement ) # if n == nil { # return nil # } # if n . left != nil { # return t . Max ( n . left ) # } # cur := n # for cur . parent != nil && cur . parent . right != cur { # cur = cur . parent # } # return cur . parent #
return syscall . Getpid ()
m 1 = m # n 1 = n # k 1 = k # visited = make ([][] bool , m ) # for i := 0 ; i < len ( visited ); i ++ { # visited [ i ] = make ([] bool , n ) # } # # return dfs ( 0 , 0 , 0 , 0 )
nums := make ([] int , 0 , 1 0 ) # # lastTail := n % 1 0 # isMax := true # for n > 0 { # tail := n % 1 0 # if tail < lastTail { # isMax = false # } # lastTail = tail # nums = append ( nums , tail ) # n /= 1 0 # } # # if isMax { # return - 1 # } # # reverse ( nums ) # # beg := exchange ( nums ) # # sort . Ints ( nums [ beg :]) # # res := combine ( nums ) # # if res > 1 << 3 1 - 1 { # return - 1 # } # return res
tests := [...] testType { # { # in : 1 0 , # want : 1 2 , # }, # { # in : 9 , # want : 1 0 , # }, # { # in : 6 0 , # want : 3 8 4 , # }, # { # in : 9 0 , # want : 1 1 5 2 , # }, # { # in : 1 , # want : 1 , # }, # } # for _ , tt := range tests { # got := nthUglyNumber ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
for i := 0 ; i < b . N ; i ++ { # RecursivePower 1 ( 1 0 , 5 ) # }
ldc := newLdc (" STR ", " STR ", & newDelete ( 2 ). lDOperation , & newInsert ( 2 ). lDOperation , & newKill ( math . MaxInt 3 2 ). lDOperation ) # ldc . addOp (& newCopy (- 1 ). lDOperation ) # ldc . addOp (& newReplace ( 1 ). lDOperation ) # dist , opSeq := ldc . levenshteinDistance () # if dist != 3 { # t . Log ( fmt . Sprintf (" STR ", dist )) # t . Fail () # } # if ! reflect . DeepEqual ( opSeq , [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}) { # t . Log (" STR ") # t . Log ( opSeq ) # t . Fail () # }
sort . Ints ( A ) # ans , min := 0 , A [ len ( A )- 1 ] # for _ , v := range A { # if K > 0 && v <= 0 { # K , v = K - 1 , - v # } # if v < min { # min = v # } # ans += v # } # if K & 1 == 1 { # ans -= min * 2 # } # return ans
happened := map [ int ] bool {} # for n != 1 { # n = squares ( n ) # if happened [ n ] { # return false # } # happened [ n ] = true # } # return true
n := len ( list ) # i , j := 0 , n - 1 # maxMulArea := 0 # for i < j { # maxMulArea = int ( math . Max ( float 6 4 ( maxMulArea ), float 6 4 ( j - i )* math . Min ( float 6 4 ( list [ i ]), float 6 4 ( list [ j ])))) # if list [ i ] <= list [ j ] { # i = i + 1 # } else { # j = j - 1 # } # } # return maxMulArea
r 1 , r 2 := rand . Int ()% 4 + 1 , rand . Int ()% 4 + 1 # return r 1 + r 2 , r 1 == r 2
qs := [] question 2 0 { # # { # para 2 0 {" STR "}, # ans 2 0 { true }, # }, # { # para 2 0 {" STR "}, # ans 2 0 { false }, # }, # { # para 2 0 {" STR "}, # ans 2 0 { true }, # }, # { # para 2 0 {" STR "}, # ans 2 0 { true }, # }, # { # para 2 0 {" STR "}, # ans 2 0 { false }, # }, # { # para 2 0 {" STR "}, # ans 2 0 { false }, # }, # { # para 2 0 {" STR "}, # ans 2 0 { true }, # }, # { # para 2 0 {" STR "}, # ans 2 0 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 0 , q . para 2 0 # fmt . Printf (" STR ", p , isValid ( p . one )) # }
if b [ 0 ] == " STR " { # sd := string ( b [ 1 : len ( b )- 1 ]) # d . Duration , err = time . ParseDuration ( sd ) # return # } # # var id int 6 4 # id , err = json . Number ( string ( b )). Int 6 4 () # d . Duration = time . Duration ( id ) # # return
ds . Lock () # defer ds . Unlock () # ds . set ( key , value )
n := len ( citations ) # # cnt := make ([] int , n + 1 ) # for _ , citation := range citations { # if citation > n { # citation = n # } # cnt [ citation ]++ # } # # var h int # for i := n ; i > 0 ; i -- { # if i <= cnt [ i ] { # h = i # break # } # cnt [ i - 1 ] += cnt [ i ] # } # return h
return reflect . TypeOf ( i )
if head == nil || head . Next == nil { # return head # } # p := reverseList 2 ( head . Next ) # head . Next . Next = head # head . Next = p # return p
cur := root # for cur . left != nil { # cur = cur . left # } # return cur
res := 0 # var dfs func (* TreeNode ) int # dfs = func ( node * TreeNode ) int { # if node == nil { # return 0 # } # l := dfs ( node . Left ) # r := dfs ( node . Right ) # lp , rp := 0 , 0 # if node . Left != nil && node . Val == node . Left . Val { # lp = l + 1 # } # # if node . Right != nil && node . Val == node . Right . Val { # rp = r + 1 # } # res = max ( res , lp + rp ) # if lp > rp { # return lp # } # return rp # } # dfs ( root ) # return res
qs := [] question 7 0 { # # { # para 7 0 { 2 }, # ans 7 0 { 2 }, # }, # # { # para 7 0 { 3 }, # ans 7 0 { 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 0 , q . para 7 0 # fmt . Printf (" STR ", p , climbStairs ( p . n )) # } # fmt . Printf (" STR ")
if needle == " STR " { # return 0 # } # p := 0 # q := 0 # for q < len ( needle ) && p < len ( haystack ) { # if haystack [ p : p + 1 ] == needle [ q : q + 1 ] { # q ++ # } else { # p = p - q # q = 0 # } # p ++ # } # if q != len ( needle ) { # return - 1 # } # return p - q
t . Parallel () # for _ , tc := range testcases { # if result , err := FastFibonnaci ( tc . n ); result != tc . fib || err != tc . err { # t . Errorf (" STR ", tc . n , tc . fib , tc . err , result , err ) # } # }
clients := make ( map [ client ] bool ) # for { # select { # case msg := <- messages : # for cli := range clients { # cli <- msg # } # # case cli := <- entering : # clients [ cli ] = true # # case cli := <- leaving : # delete ( clients , cli ) # close ( cli ) # } # }
var i , j int # j = len ( s ) - 1 # for i < j { # if s [ i ] != s [ j ] { # return false # } # i ++ # j -- # } # return true
binary := make ([] byte , 0 , 3 2 ) # for num > 0 { # binary = append ( binary , byte ( num % 2 )+' 0 ') # num /= 2 # } # # n := len ( binary ) # a := make ([] int , n ) # b := make ([] int , n ) # a [ 0 ] = 1 # b [ 0 ] = 1 # # for i := 1 ; i < n ; i ++ { # a [ i ] = a [ i - 1 ] + b [ i - 1 ] # b [ i ] = a [ i - 1 ] # } # # res := a [ n - 1 ] + b [ n - 1 ] # for i := n - 2 ; i >= 0 ; i -- { # if binary [ i ] == ' 1 ' && binary [ i + 1 ] == ' 1 ' { # break # } # if binary [ i ] == ' 0 ' && binary [ i + 1 ] == ' 0 ' { # res -= b [ i ] # } # } # # return res
ans := 0 # for k := i ; k <= j ; k ++ { # ans += this . Sum [ k ] # } # return ans
count := 1 << uint 3 2 ( n ) # res := make ([] int , count ) # for i := 0 ; i < count ; i ++ { # res [ i ] = i ^ i >> 1 # } # return res
rec := make ([] int , 2 6 ) # for _ , b := range s { # rec [ b -' a ']++ # } # # for i , b := range s { # if rec [ b -' a '] == 1 { # return i # } # } # # return - 1
var tempArray 1 , tempArray 2 [] int # for i := leftIndex ; i <= divideIndex ; i ++ { # tempArray 1 = append ( tempArray 1 , array [ i ]) # } # for i := divideIndex + 1 ; i <= rightIndex ; i ++ { # tempArray 2 = append ( tempArray 2 , array [ i ]) # } # arrayIndex := leftIndex # tempArray 1 Index := 0 # tempArray 2 Index := 0 # for tempArray 1 Index != len ( tempArray 1 ) && tempArray 2 Index != len ( tempArray 2 ) { # if tempArray 1 [ tempArray 1 Index ] <= tempArray 2 [ tempArray 2 Index ] { # array [ arrayIndex ] = tempArray 1 [ tempArray 1 Index ] # tempArray 1 Index += 1 # } else { # array [ arrayIndex ] = tempArray 2 [ tempArray 2 Index ] # tempArray 2 Index += 1 # } # arrayIndex += 1 # } # for tempArray 1 Index < len ( tempArray 1 ) { # array [ arrayIndex ] = tempArray 1 [ tempArray 1 Index ] # tempArray 1 Index += 1 # arrayIndex += 1 # # } # for tempArray 2 Index < len ( tempArray 2 ) { # array [ arrayIndex ] = tempArray 2 [ tempArray 2 Index ] # tempArray 2 Index += 1 # arrayIndex += 1 # }
aI := a .( int ) # bI := b .( int ) # return aI <= bI
var ret bool # var str string # var pattern string # # str = " STR " # pattern = " STR " # ret = true # if ret != wordPattern ( pattern , str ) { # t . Fatalf (" STR ", ret ) # } # # str = " STR " # pattern = " STR " # ret = false # if ret != wordPattern ( pattern , str ) { # t . Fatalf (" STR ", ret ) # }
return & numPermutation { # aData : aData , # Length : len ( aData ), # }
StoreUint 8 (& r . Reg , LoadUint 8 (& r . Reg )| value )
conn , err := net . Dial (" STR ", " STR ") # if err != nil { # log . Fatal ( err ) # } # defer conn . Close () # mustCopy ( os . Stdout , conn )
t . Parallel () # for _ , tc := range testcases { # result := PowerSet ( tc . input ) # if len ( result ) != len ( tc . expected ) { # t . Errorf (" STR ", len ( tc . expected ), len ( result )) # continue # } # for i := range result { # if ! reflect . DeepEqual ( result [ i ], tc . expected [ i ]) { # t . Errorf (" STR ", tc . expected [ i ], result [ i ]) # } # } # }
for i , num := range funcVals { # if got := IsPrime ( num ); got != prime [ i ] { # t . Errorf (" STR ", num , got , prime [ i ]) # } # }
for i , j := 0 , len ( data )- 1 ; i < j ; i , j = i + 1 , j - 1 { # data [ i ], data [ j ] = data [ j ], data [ i ] # }
var sb strings . Builder # opens := 0 # for _ , r := range parens { # switch { # case r == '(': # opens ++ # case r == ')' && opens == 0 : # sb . WriteRune ('(') # default : # opens -- # } # sb . WriteRune ( r ) # } # for i := 0 ; i < opens ; i ++ { # sb . WriteRune (')') # } # return sb . String ()
out := 1 0 7 4 # if x := p 1 8 (); x != out { # t . Errorf (" STR ", x , out ) # }
promisesPtr , err := syscall . BytePtrFromString ( promises ) # if err != nil { # return err # } # promisesUnsafe , pathsUnsafe := unsafe . Pointer ( promisesPtr ), unsafe . Pointer ( nil ) # if paths != nil { # var pathsPtr []* byte # if pathsPtr , err = syscall . SlicePtrFromStrings ( paths ); err != nil { # return err # } # pathsUnsafe = unsafe . Pointer (& pathsPtr [ 0 ]) # } # _ , _ , e := syscall . Syscall ( _SYS_PLEDGE , uintptr ( promisesUnsafe ), uintptr ( pathsUnsafe ), 0 ) # if e != 0 { # return e # } # return nil
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 2 , 2 , 1 }, 1 }, # {" STR ", [] int { 4 , 1 , 2 , 1 , 2 }, 4 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := singleNumber 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
return RecentCounter { # q : [] int {}, # }
var nodes [] string # for nil != node { # nodes = append ( nodes , strconv . Itoa ( node . Val )) # node = node . Next # } # return strings . Join ( nodes , " STR ")
if a < b { # MultiplyAddOnly ( b , a ) # } # # result := 0 # for x := 0 ; x < Abs ( b ); x ++ { # result += a # } # # if b < 0 { # result = Min ( result ) # } # return result
qs := [] question 7 3 9 { # # { # para 7 3 9 {[] int { 7 3 , 7 4 , 7 5 , 7 1 , 6 9 , 7 2 , 7 6 , 7 3 }}, # ans 7 3 9 {[] int { 1 , 1 , 4 , 2 , 1 , 1 , 0 , 0 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 3 9 , q . para 7 3 9 # fmt . Printf (" STR ", p , dailyTemperatures ( p . s )) # } # fmt . Printf (" STR ")
defer TimeTaken ( time . Now (), " STR ") # # a , b := 0 , 0 # for i := 0 ; i < 1 0 1 ; i ++ { # a += ( i * i ) # b += i # } # fmt . Println (( b * b )- a )
tests := [...] testType { # { # in : [] int { 1 , 2 , 2 , 5 , 3 , 5 }, # want : 2 , # }, # { # in : [] int { 1 , 2 , 2 }, # want : 2 , # }, # { # in : [] int { 1 , 1 , 2 }, # want : 2 , # }, # { # in : [] int { 3 , 2 , 1 }, # want : 1 , # }, # { # in : [] int { 1 , 2 }, # want : 2 , # }, # { # in : [] int { 2 , 2 , 3 , 1 }, # want : 1 , # }, # } # for _ , tt := range tests { # got := thirdMax ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
abort := make ( chan struct {}) # go func () { # os . Stdin . Read ( make ([] byte , 1 )) # abort <- struct {}{} # }() # # fmt . Println (" STR ") # tick := time . Tick ( 1 * time . Second ) # for countdown := 1 0 ; countdown > 0 ; countdown -- { # fmt . Println ( countdown ) # select { # case <- tick : # case <- abort : # fmt . Println (" STR ") # return # } # } # launch ()
if _ , ok := numMap [ s ]; ok { # return true # } # return false
var res = 1 << 6 3 - 1 # for root != nil { # if abs ( float 6 4 ( root . Val )- target ) < abs ( float 6 4 ( res )- target ) { # res = root . Val # } # if float 6 4 ( root . Val ) < target { # root = root . Right # } else if target < float 6 4 ( root . Val ) { # root = root . Left # } else { # return root . Val # } # } # return res
words := make ([] string , 0 ) # paragraph = strings . ToLower ( paragraph ) # reg := regexp . MustCompile (`[ a - z ]+`) # for _ , word := range reg . FindAllString ( paragraph , - 1 ) { # words = append ( words , word ) # } # mb := make ( map [ string ] bool ) # for _ , ban := range banned { # mb [ ban ] = true # } # ans , max , count := " STR ", 0 , make ( map [ string ] int ) # for _ , word := range words { # if ! mb [ word ] { # count [ word ]++ # if count [ word ] > max { # max = count [ word ] # ans = word # } # } # } # return ans
if val := bc . r . Intn ( 1 0 0 ); val < bc . zeroBias { # return 0 # } # return 1
arr := [] int { 4 , 5 , 8 , 2 } # kthLargest := Constructor ( 3 , arr ) # fmt . Println ( kthLargest . Add ( 3 )) # fmt . Println ( kthLargest . Add ( 5 )) # fmt . Println ( kthLargest . Add ( 1 0 )) # fmt . Println ( kthLargest . Add ( 9 )) # fmt . Println ( kthLargest . Add ( 4 ))
tests := [...] testType { # { # nums : [] int { 2 , 7 , 1 1 , 1 5 }, # target : 9 , # want : [] int { 1 , 2 }, # }, # { # nums : [] int { 2 , 7 , 1 1 , 1 5 }, # target : 1 0 , # want : nil , # }, # { # nums : [] int { 1 , 3 , 5 , 7 , 9 , 1 2 }, # target : 1 6 , # want : [] int { 4 , 5 }, # }, # { # nums : [] int { 1 , 2 , 3 , 4 }, # target : 6 , # want : [] int { 2 , 4 }, # }, # } # # for _ , tt := range tests { # got := twoSum ( tt . nums , tt . target ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . nums , got , tt . want ) # } # }
xor , i := 0 , 0 # for i = 0 ; i < len ( nums ); i ++ { # xor = xor ^ i ^ nums [ i ] # } # return xor ^ i
remains , debts , start := 0 , 0 , 0 # # for i , g := range gas { # remains += g - cost [ i ] # if remains < 0 { # start = i + 1 # debts += remains # remains = 0 # } # } # # if debts + remains < 0 { # return - 1 # } # # return start
if class == 0 { # return Range { 0 , 0 } # } # classRange . Min = int ( math . Pow ( 1 0 , float 6 4 ( class - 1 ))) # classRange . Max = int ( math . Pow ( 1 0 , float 6 4 ( class ))) - 1 # return
kthLarges := Constructor ( 3 , [] int { 4 , 5 , 8 , 2 }) # # fmt . Println ( kthLarges . Add ( 3 )) # fmt . Println ( kthLarges . Add ( 5 )) # fmt . Println ( kthLarges . Add ( 1 0 )) # fmt . Println ( kthLarges . Add ( 9 )) # fmt . Println ( kthLarges . Add ( 4 ))
xs := [ 5 1 ] int {} # ys := [ 5 1 ] int {} # res := 0 # # for i , line := range grid { # for j , k := range line { # if k == 0 { # continue # } # res ++ # xs [ i ] = max ( xs [ i ], k ) # ys [ j ] = max ( ys [ j ], k ) # } # } # # for i := range xs { # res += xs [ i ] + ys [ i ] # } # # return res
fmt . Println (" STR ")
left , right := 0 , 0 # for right < len ( nums )- 1 { # max := right # for i := left ; i <= right ; i ++ { # if max < nums [ i ]+ i { # max = nums [ i ] + i # } # } # # if max <= right { # return false # } # # left = right + 1 # right = max # } # # return true
m , n , l := 0 , - 1 , len ( nums ) # for max , min , i , j := 0 , l - 1 , 1 , l - 2 ; i < l ; i , j = i + 1 , j - 1 { # if nums [ i ] < nums [ max ] { # n = i # } else if nums [ i ] > nums [ max ] { # max = i # } # if nums [ j ] > nums [ min ] { # m = j # } else if nums [ j ] < nums [ min ] { # min = j # } # } # return n - m + 1
return 4 , map [ uint 3 2 ][] int { 1 : { 1 }, # 2 : { 2 , 3 }, # 4 : { 6 0 , 7 0 }, # 7 : { 8 , 9 }, # 1 1 : { 7 9 , 8 6 }, # 1 5 : { 3 1 , 2 }}, [] int { 1 , 2 , 4 , 7 , 1 1 , 1 5 }
e . p = nil # e . l = nil # e . r = nil # e . c = newFabHeapElementList ( e ) # e . mark = false # e . Key = key # e . Value = value # return e
ret := 0 # stack := [] int {} # sign := 1 # for i := 0 ; i < len ( s ); i ++ { # if s [ i ] >= ' 0 ' && s [ i ] <= ' 9 ' { # num := 0 # for ; i < len ( s ) && s [ i ] >= ' 0 ' && s [ i ] <= ' 9 '; i ++ { # num = 1 0 * num + int ( s [ i ]-' 0 ') # } # ret += sign * num # i -- # } else if s [ i ] == '+' { # sign = 1 # } else if s [ i ] == '-' { # sign = - 1 # } else if s [ i ] == '(' { # stack = append ( stack , ret , sign ) # ret = 0 # sign = 1 # } else if s [ i ] == ')' { # signTmp := stack [ len ( stack )- 1 ] # retTmp := stack [ len ( stack )- 2 ] # stack = stack [: len ( stack )- 2 ] # ret = signTmp * ret + retTmp # sign = 1 # } # } # return ret
stack := make ([] int , 0 ) # result := 0 # for i , h := range height { # for len ( stack ) > 0 && height [ stack [ len ( stack )- 1 ]] <= h { # lower := height [ stack [ len ( stack )- 1 ]] # stack = stack [: len ( stack )- 1 ] # if len ( stack ) > 0 { # left := stack [ len ( stack )- 1 ] # heigher := int ( math . Min ( float 6 4 ( height [ left ]), float 6 4 ( h ))) # result += ( i - left - 1 ) * ( heigher - lower ) # } # } # # stack = append ( stack , i ) # } # # return result
fmt . Println ( reverseWords (" STR "))
qs := [] question 5 9 9 { # # { # para 5 9 9 {[] string {" STR ", " STR ", " STR ", " STR "}, [] string {" STR ", " STR ", " STR ", " STR "}}, # ans 5 9 9 {[] string {" STR "}}, # }, # # { # para 5 9 9 {[] string {" STR ", " STR ", " STR ", " STR "}, [] string {" STR ", " STR ", " STR "}}, # ans 5 9 9 {[] string {" STR "}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 9 9 , q . para 5 9 9 # fmt . Printf (" STR ", p , findRestaurant ( p . one , p . two )) # } # fmt . Printf (" STR ")
t . Parallel () # # for tcid , tc := range testcases { # if result := IsValidRules ( tc . rules ); result != tc . isValid { # t . Errorf (" STR ", tcid , tc . isValid , result ) # } # }
m . mem [ id ] = data .([] byte )
dis := make ([] int , 1 0 0 0 0 0 0 ) # for i := 0 ; i < len ( nums ); i ++ { # for j := i + 1 ; j < len ( nums ); j ++ { # if nums [ i ] > nums [ j ] { # dis [ nums [ i ]- nums [ j ]]++ # } else { # dis [ nums [ j ]- nums [ i ]]++ # } # } # } # for i := 0 ; i < len ( dis ); i ++ { # if k <= dis [ i ] { # return i # } # k -= dis [ i ] # } # return 0
cases := [] struct { # name string # inputs int # expect int # }{ # {" STR ", 1 0 , 4 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := countPrimes 3 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
size := len ( A ) # # stack := make ([] int , 1 , size ) # top := 0 # for i := 1 ; i < size ; i ++ { # if A [ stack [ top ]] > A [ i ] { # stack = append ( stack , i ) # top ++ # } # } # # res := 0 # for j := size - 1 ; j >= 0 && top >= 0 ; j -- { # width := 0 # for top >= 0 && A [ stack [ top ]] <= A [ j ] { # width = j - stack [ top ] # stack = stack [: top ] # top -- # } # res = max ( res , width ) # } # # return res
for i := 0 ; i < int ( h . Cap ); i ++ { # hashValue := h . hash ( key , uint 3 2 ( i )) # if h . existKey ( hashValue ) && h . backets [ hashValue ]. Key == key { # h . backets [ hashValue ] = & openHashElement { exist : false } # h . Count -- # h . DownScale () # return # } # }
roate := make ([][] int , len ( rawArr )) # length := len ( rawArr ) - 1 # for i := 0 ; i <= length ; i ++ { # for j := 0 ; j <= length ; j ++ { # roate [ j ] = append ([] int { rawArr [ i ][ j ]}, roate [ j ]...) # } # } # return roate
iE := i .(* linkedHeapListElement ) # jE := j .(* linkedHeapListElement ) # iE . Value , jE . Value = jE . Value , iE . Value
if nil == root { # return 0 # } # return findPath ( root , sum ) + pathSum ( root . Left , sum ) + pathSum ( root . Right , sum )
graph := make ( map [ int ][] int ) # inEdges := make ([] int , numCourses ) # res := [] int {} # queue := make ([] int , 0 ) # # for i := 0 ; i < len ( prerequisites ); i ++ { # graph [ prerequisites [ i ][ 1 ]] = append ( graph [ prerequisites [ i ][ 1 ]], prerequisites [ i ][ 0 ]) # inEdges [ prerequisites [ i ][ 0 ]]++ # } # # for i := 0 ; i < numCourses ; i ++ { # if inEdges [ i ] == 0 { # queue = append ( queue , i ) # } # } # # for len ( queue ) != 0 { # course := queue [ 0 ] # res = append ( res , course ) # queue = queue [ 1 :] # # for i := 0 ; i < len ( graph [ course ]); i ++ { # inEdges [ graph [ course ][ i ]]-- # # if inEdges [ graph [ course ][ i ]] == 0 { # queue = append ( queue , graph [ course ][ i ]) # } # } # } # return len ( res ) == numCourses
bucket := make ( map [ int ] int , k + 1 ) # for i , num := range nums { # if t == 0 { # if j , ok := bucket [ num ]; ok && i - j <= k { # return true # } # bucket [ num ] = i # continue # } # # index := num / t # for j := index - 1 ; j <= index + 1 ; j ++ { # if v , ok := bucket [ j ]; ok && d ( num , v ) <= t { # return true # } # } # # bucket [ index ] = num # if len ( bucket ) > k { # delete ( bucket , nums [ i - k ]/ t ) # } # } # return false
uint 3 2 Val := math . Float 3 2 bits ( value ) # self . table [ index ]. Num = int 3 2 ( uint 3 2 Val )
if root == nil { # return 0 # } # var level int # for _ , n := range root . Children { # level = maxInt ( level , maxDepth ( n )) # } # # return level + 1
row := len ( grid ) # col := len ( grid [ 0 ]) # count := 0 # for i := 0 ; i < row ; i ++ { # for j := 0 ; j < col ; j ++ { # if grid [ i ][ j ] == 1 { # t := 4 # if j >= 1 && grid [ i ][ j - 1 ] == 1 { # t -- # } # if j < col - 1 && grid [ i ][ j + 1 ] == 1 { # t -- # } # if i >= 1 && grid [ i - 1 ][ j ] == 1 { # t -- # } # if i < row - 1 && grid [ i + 1 ][ j ] == 1 { # t -- # } # count += t # } # } # } # return count
var res []* Reply # if res , err = c . Gets ( cmd , key ); err != nil { # return # } # if len ( res ) > 0 { # return res [ 0 ], nil # } # return nil , ErrNotFound
r . Ewma . Init ( halfLife ) # return r
fmt . Println ( findLength ([] int { 0 , 1 , 1 , 1 , 1 }, [] int { 1 , 0 , 1 , 0 , 1 })) # fmt . Println ( findLength ([] int { 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 }, [] int { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 }))
d , err := time . ParseDuration ( s ) # if err != nil { # panic ( s ) # } # return d
res := make ([] string , n ) # for i := 0 ; i < n ; i ++ { # num := i + 1 # if num % 1 5 == 0 { # res [ i ] = " STR " # } else if num % 5 == 0 { # res [ i ] = " STR " # } else if num % 3 == 0 { # res [ i ] = " STR " # } else { # res [ i ] = strconv . Itoa ( num ) # } # } # return res
if x < 0 { # return false # } # rx , t := 0 , 0 # n := x # for x != 0 { # t = rx * 1 0 + x % 1 0 # rx = t # x /= 1 0 # } # return rx == n
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 2 }, 1 }, # {" STR ", [] int { 5 , 0 , 3 , 8 , 6 }, 3 }, # {" STR ", [] int { 1 , 1 , 1 , 0 , 6 , 1 2 }, 4 }, # {" STR ", [] int { 9 , 8 , 1 0 }, 2 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
t . Parallel () # # for _ , tc := range testcases { # if result := StartIndicesAnagrams ( tc . W , tc . S ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
random := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # array 1 := make ([] int , random . Intn ( 1 0 0 - 1 0 )+ 1 0 ) # for i := range array 1 { # array 1 [ i ] = random . Intn ( 1 0 0 ) # } # array 2 := make ( sort . IntSlice , len ( array 1 )) # copy ( array 2 , array 1 ) # InsertionSort ( array 1 ) # array 2 . Sort () # for i := range array 1 { # if array 1 [ i ] != array 2 [ i ] { # t . Fail () # } # }
var res = [] byte {} # for i := len ( s ) - 1 ; i >= 0 ; i -- { # if ( s [ i ] >= ' A ' && s [ i ] <= ' Z ') || # ( s [ i ] >= ' a ' && s [ i ] <= ' z ') { # res = append ( res , s [ i ]) # } else { # if len ( res ) > 0 { # break # } # } # } # # return len ( res )
tests := [...] testType { # { # a : [] int { 1 , 1 }, # b : [] int { 2 , 2 }, # want : [] int { 1 , 2 }, # }, # { # a : [] int { 1 , 2 }, # b : [] int { 2 , 3 }, # want : [] int { 1 , 2 }, # }, # { # a : [] int { 2 }, # b : [] int { 1 , 3 }, # want : [] int { 2 , 3 }, # }, # { # a : [] int { 1 , 2 , 5 }, # b : [] int { 2 , 4 }, # want : [] int { 5 , 4 }, # }, # { # a : [] int { 1 , 2 , 3 }, # b : [] int { 1 1 , 1 5 , 1 7 }, # want : nil , # }, # } # for _ , tt := range tests { # got := fairCandySwap ( tt . a , tt . b ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . a , tt . b , got , tt . want ) # } # }
if a <= 1 9 9 9 { # return 1 # } # # if answer , ok := memo [ a ]; ok { # return answer # } # # # answer := ( fib ( a - 2 0 0 0 ) + fib ( a - 1 9 9 9 )) % mod # # memo [ a ] = answer # return answer #
cases := [] struct { # name string # postorder [] int # inorder [] int # expect * TreeNode # }{ # {" STR ", [] int { 9 , 1 5 , 7 , 2 0 , 3 }, [] int { 9 , 3 , 1 5 , 2 0 , 7 }, & TreeNode { 3 , & TreeNode { Val : 9 }, & TreeNode { 2 0 , & TreeNode { Val : 1 5 }, & TreeNode { Val : 7 }}}}, # {" STR ", [] int {- 1 }, [] int {- 1 }, & TreeNode { Val : - 1 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inorder , c . postorder ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inorder , c . postorder ) # } # }) # }
if len ( noSpaces ) == 0 { # return " STR ", nil # } # for word := range words { # if len ( word ) <= len ( noSpaces ) && word == noSpaces [: len ( word )] { # rest , err := OriginalSentence ( words , noSpaces [ len ( word ):]) # if err == nil { # return strings . TrimSpace ( fmt . Sprintf (" STR ", word , rest )), nil # } # } # } # return " STR ", errNoSentencePossible
this . mutex . Lock () # defer this . mutex . Unlock () # if ! this . closed { # close ( this . pool ) # this . closed = true # }
if s == nil { # return Variable {}, false # } # # v , ok := s . VarMap [ n ] # return v , ok
var ret bool # var num int # num = 1 9 # ret = true # if ret != isHappy ( num ) { # t . Fatalf (" STR ", ret ) # } # # num = 2 # ret = false # if ret != isHappy ( num ) { # t . Fatalf (" STR ", ret ) # }
cases := [] struct { # name string # num 1 , num 2 string # expect string # }{ # {" STR ", " STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR ", " STR "}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . num 1 , c . num 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . num 1 , c . num 2 ) # } # }) # }
t . Parallel () # for _ , tc := range testcases { # if result := MostMouseSteps ( tc . mice , tc . holes ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
var tests = [] struct { # digits string # combinations [] string # }{ # {" STR ", nil }, # {" STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # } # # for _ , tt := range tests { # combinations := letterCombinations ( tt . digits ) # if reflect . DeepEqual ( combinations , tt . combinations ) == false { # t . Errorf (" STR ", tt . digits , combinations , tt . combinations ) # } # }
m := len ( grid ) # if m == 0 { # return 0 # } # n := len ( grid [ 0 ]) # if n == 0 { # return 0 # } # res , visited := 0 , make ([][] bool , m ) # for i := 0 ; i < m ; i ++ { # visited [ i ] = make ([] bool , n ) # } # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # isEdge := false # if grid [ i ][ j ] == 0 && ! visited [ i ][ j ] { # checkIslands ( grid , & visited , i , j , & isEdge ) # if ! isEdge { # res ++ # } # # } # } # } # return res
trie = make ( map [ int ] map [ uint 8 ] int ) # stateIsTerminal = make ([] bool , 1 ) # f = make ( map [ int ][] int ) # state := 1 # CreateNewState ( 0 , trie ) # for i := 0 ; i < len ( p ); i ++ { # current := 0 # j := 0 # for j < len ( p [ i ]) && GetTransition ( current , p [ i ][ j ], trie ) != - 1 { # current = GetTransition ( current , p [ i ][ j ], trie ) # j ++ # } # for j < len ( p [ i ]) { # stateIsTerminal = BoolArrayCapUp ( stateIsTerminal ) # CreateNewState ( state , trie ) # stateIsTerminal [ state ] = false # CreateTransition ( current , p [ i ][ j ], state , trie ) # current = state # j ++ # state ++ # } # if stateIsTerminal [ current ] { # newArray := IntArrayCapUp ( f [ current ]) # newArray [ len ( newArray )- 1 ] = i # f [ current ] = newArray # } else { # stateIsTerminal [ current ] = true # f [ current ] = [] int { i } # } # } # return trie , stateIsTerminal , f
obj := Constructor () # obj . Insert (" STR ", 3 ) # if res := obj . Sum (" STR "); res != 3 { # t . Errorf (" STR ", 3 , res ) # } # # obj . Insert (" STR ", 2 ) # if res := obj . Sum (" STR "); res != 5 { # t . Errorf (" STR ", 5 , res ) # } # # if res := obj . Sum (" STR "); res != 0 { # t . Errorf (" STR ", 0 , res ) # }
cases := [] struct { # name string # inputs [] int # expect [] int # }{ # {" STR ", [] int { 8 , 1 , 2 , 2 , 3 }, [] int { 4 , 0 , 1 , 1 , 3 }}, # {" STR ", [] int { 1 , 2 , 3 , 4 , 5 }, [] int { 0 , 1 , 2 , 3 , 4 }}, # {" STR ", [] int { 5 , 4 , 3 , 2 , 1 }, [] int { 4 , 3 , 2 , 1 , 0 }}, # {" STR ", [] int {}, [] int {}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if root == nil { # return 0 # } # min = 1 << 6 3 - 1 # dfs ( root , 1 ) # return min
t . Parallel () # # for _ , tc := range testcases { # if result := RotateMatrixRightClockwise 9 0 ( tc . matrix ); ! reflect . DeepEqual ( result , tc . rotated ) { # t . Errorf (" STR ", tc . rotated , result ) # } # }
cur , count := 0 , 0 # for _ , v := range nums { # if count == 0 { # cur = v # } # if v == cur { # count ++ # } else { # count -- # } # } # return cur
d := make ( map [ int ] interface {}) # for k , v := range arr { # if d [ v ] != nil { # return d [ v ].( int ), k # } # d [ target - v ] = k # } # return nil , nil
return self . thread
t . Parallel () # for _ , tc := range testcases { # if result := SmallestStepsToOne ( tc . n ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
return strings . Split ( tagStr , " STR ")
gz , err := gzip . NewReader ( bytes . NewBuffer ( data )) # if err != nil { # return nil , fmt . Errorf (" STR ", name , err ) # } # # var buf bytes . Buffer # _ , err = io . Copy (& buf , gz ) # clErr := gz . Close () # # if err != nil { # return nil , fmt . Errorf (" STR ", name , err ) # } # if clErr != nil { # return nil , err # } # # return buf . Bytes (), nil
if len ( triangle ) == 0 || len ( triangle [ 0 ]) == 0 { # return 0 # } # _dfs ( triangle , 0 , 0 , "", 0 ) # # return minSum
if root == nil || p == root || q == root { # return root # } # # l := lowestCommonAncestor ( root . Left , p , q ) # r := lowestCommonAncestor ( root . Right , p , q ) # # if l == nil { # return r # } # # if r == nil { # return l # } # # return root
if nil == root { # return [] int {} # } # # var vals [] int # leftNodes := []* TreeNode { root } # for len ( leftNodes ) > 0 { # node := leftNodes [ len ( leftNodes )- 1 ] # leftNodes = leftNodes [: len ( leftNodes )- 1 ] # for nil != node { # vals = append ([] int { node . Val }, vals ...) # if nil != node . Left { # leftNodes = append ( leftNodes , node . Left ) # } # node = node . Right # } # } # return vals
qs := [] question 3 0 0 { # # { # para 3 0 0 {[] int { 1 0 , 9 , 2 , 5 , 3 , 7 , 1 0 1 , 1 8 }}, # ans 3 0 0 { 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 0 0 , q . para 3 0 0 # fmt . Printf (" STR ", p , lengthOfLIS ( p . one )) # } # fmt . Printf (" STR ")
max , current , l := nums [ 0 ], nums [ 0 ], len ( nums ) # for i := 1 ; i < l ; i ++ { # if current > 0 { # current += nums [ i ] # } else { # current = nums [ i ] # } # if current > max { # max = current # } # } # return max
return StockSpanner { # s : [][ 2 ] int {}, # }
tests := [...] testType { # { # nums : [] int { 2 , 7 , 1 1 , 1 5 }, # target : 5 , # want : 1 , # }, # { # nums : [] int { 1 , 3 , 5 , 6 }, # target : 2 , # want : 1 , # }, # { # nums : [] int { 1 , 3 , 5 , 6 }, # target : 7 , # want : 4 , # }, # { # nums : [] int { 1 , 3 , 5 , 6 }, # target : 7 , # want : 4 , # }, # { # nums : [] int { 1 , 3 , 5 , 6 }, # target : 0 , # want : 0 , # }, # } # # for _ , tt := range tests { # got := searchInsert ( tt . nums , tt . target ) # if got != tt . want { # t . Fatalf (" STR ", tt . nums , got , tt . want ) # } # }
bytes := [] byte ( s ) # return numDecodingsI ( bytes )
var maxPrimeNumber = 0 # var lastA , lastB = 0 , 0 # for a := - 9 9 9 ; a < 1 0 0 0 ; a ++ { # for b := - 1 0 0 0 ; b <= 1 0 0 0 ; b ++ { # var n = 0 # for ; ; n ++ { # if ! IsPrime (( n * n ) + a * n + b ) { # break # } # } # if n > maxPrimeNumber { # maxPrimeNumber = n # lastA = a # lastB = b # } # } # } # # return lastA * lastB
t . Parallel () # for n , tc := range testcases { # gol := NewGameOfLife ( tc . board ) # for i := 0 ; i < tc . steps ; i ++ { # gol . Step () # } # if result := gol . String (); result != tc . expected { # t . Errorf (" STR ", n , tc . expected , result ) # } # }
b := [] byte ( str ) # const d = ' a ' - ' A ' # for i := 0 ; i < len ( b ); i ++ { # if b [ i ] >= ' A ' && b [ i ] <= ' Z ' { # b [ i ] += d # } # } # return string ( b )
var tests = [] struct { # nums [] int # diff int # }{ # {[] int { 1 0 }, 0 }, # {[] int { 1 , 3 , 1 0 0 }, 9 7 }, # {[] int { 3 , 1 , 1 0 0 }, 9 7 }, # {[] int { 3 , 3 , 2 , 1 }, 1 }, # {[] int { 3 , 6 , 9 , 1 }, 3 }, # } # # for _ , tt := range tests { # diff := maximumGap ( tt . nums ) # if diff != tt . diff { # t . Errorf (" STR ", tt . nums , diff , tt . diff ) # } # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 3 , 2 , 3 }, 3 }, # {" STR ", [] int { 2 , 2 , 1 , 1 , 1 , 2 , 2 }, 2 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := majorityElement 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
result := make ([] int , len ( A )) # sort . Ints ( A ) # # bWithIndex := make ([][] int , len ( B )) # for i , b := range B { # bWithIndex [ i ] = [] int { b , i } # } # # sort . Slice ( bWithIndex , func ( i , j int ) bool { # return bWithIndex [ i ][ 0 ] < bWithIndex [ j ][ 0 ] # }) # # i , j := 0 , len ( A )- 1 # for k := len ( B ) - 1 ; k >= 0 ; k -- { # a , b := A [ j ], bWithIndex [ k ][ 0 ] # if a > b { # result [ bWithIndex [ k ][ 1 ]] = a # j -- # } else { # result [ bWithIndex [ k ][ 1 ]] = A [ i ] # i ++ # } # } # # return result
if n == 0 { # return [] int { 0 } # } # res := [] int {} # num := make ([] int , n ) # generateGrayCode ( int ( 1 << uint ( n )), 0 , & num , & res ) # return res
s := strconv . FormatInt ( i , 1 0 ) # i , j := int 6 4 ( 0 ), int 6 4 ( len ( s )- 1 ) # for i < j { # if s [ i ] != s [ j ] { # return false # } # i ++ # j -- # } # return true
n := newFabHeapElement ( key , value ) # h . root . PushRight ( n ) # if h . less ( n , h . min ) { # h . min = n # } # h . n ++ # return n
var tests = [] struct { # n int # num int # }{ # { 3 , 5 }, # { 1 0 , 1 6 7 9 6 }, # } # # for _ , tt := range tests { # num := numTrees ( tt . n ) # if num != tt . num { # t . Errorf (" STR ", tt . n , num , tt . num ) # } # }
n . bTreeNode . init ( t , n ) # return n
sort . Ints ( nums ) # low , high := 0 , nums [ len ( nums )- 1 ]- nums [ 0 ] # for low < high { # mid := low + ( high - low )>> 1 # tmp := findDistanceCount ( nums , mid ) # if tmp >= k { # high = mid # } else { # low = mid + 1 # } # } # return low
if _ , err := os . Stat ( indir ); os . IsNotExist ( err ) { # fmt . Fprintln ( os . Stderr , " STR ", indir ) # os . Exit ( 1 ) # } # os . MkdirAll ( outdir , 0 7 7 7 ) # # infiles , err := filepath . Glob ( filepath . Join ( indir , " STR ")) # if err != nil { # fmt . Fprintln ( os . Stderr , " STR ", err ) # os . Exit ( 1 ) # } # sort . Strings ( infiles ) # for _ , infile := range infiles { # fmt . Println ( infile ) # device , err := readSVD ( infile , sourceURL ) # if err != nil { # return fmt . Errorf (" STR ", err ) # } # err = writeGo ( outdir , device , interruptSystem ) # if err != nil { # return fmt . Errorf (" STR ", err ) # } # switch interruptSystem { # case " STR ": # case " STR ": # err = writeAsm ( outdir , device ) # if err != nil { # return fmt . Errorf (" STR ", err ) # } # default : # return fmt . Errorf (" STR ", interruptSystem ) # } # } # return nil
counts := make ( map [ byte ] int ) # for _ , task := range tasks { # counts [ task ]++ # } # # max := 0 # for _ , count := range counts { # if max < count { # max = count # } # } # # maxCount := 0 # for _ , count := range counts { # if count == max { # maxCount ++ # } # } # # all , others := len ( tasks ), len ( tasks )- max # if others - maxCount + 1 >= n *( max - 1 ) { # return all # } # # return ( n + 1 )*( max - 1 ) + maxCount
sum , biggest := 0 , 0 # for _ , n := range nums { # sum += n # biggest = max ( biggest , n ) # } # if m == 1 { # return sum # } # # bigger := func ( guess int ) bool { # count , subsum := 1 , 0 # for _ , n := range nums { # subsum += n # if subsum > guess { # subsum = n # count ++ # if count > m { # return false # } # } # } # return true # } # # l , r := biggest , sum # for l <= r { # mid := ( l + r ) / 2 # if bigger ( mid ) { # r = mid - 1 # } else { # l = mid + 1 # } # } # return l
t . Parallel () # for _ , tc := range testcases { # if cyclic := HasCycle ( tc . g , tc . start ); cyclic != tc . cyclic { # t . Errorf (" STR ", tc . cyclic , cyclic ) # } # }
tr := new ( TimeoutReader ) # tr . reader = reader # tr . timeout = timeout # tr . closeOnTimeout = closeOnTimeout # tr . maxReadSize = maxReadSize # tr . done = make ( chan * readResponse , 1 ) # if timeout > 0 { # tr . timer = time . NewTimer ( timeout ) # } # return tr
var tests = [] struct { # tree * TreeNode # value int # }{ # { newTree ( 1 ), 1 }, # { newTree ( 2 , 1 , 3 ), 1 }, # { newTree ( 1 , 2 , 3 , 4 , nil , 5 , 6 , nil , nil , 7 ), 7 }, # } # # for _ , tt := range tests { # value := findBottomLeftValue ( tt . tree ) # if value != tt . value { # t . Errorf (" STR ", tt . tree , value , tt . value ) # } # }
a := big . NewInt ( 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 ) # # if k_multiply ( a , a ). Cmp ( mul ( a , a )) != 0 { # fmt . Println ( k_multiply ( a , a ), mul ( a , a )) # t . Fatal (" STR ") # }
fmt . Println ( numTrees ( 3 ))
if num < 0 { # num *= - 1 # } # # rev := 0 # tmp := num # # for tmp > 0 { # dig := tmp % 1 0 # rev = rev * 1 0 + dig # tmp /= 1 0 # } # # return rev == num
if node == nil { # return false # } # # if index > list . Size { # return false # } # # list . mutex . Lock () # defer list . mutex . Unlock () # # if index == 0 { # node . Next = list . Head # list . Head = node # list . Size += 1 # return true # } # var i uint # ptr := list . Head # for i = 1 ; i < index ; i ++ { # ptr = ptr . Next # } # next := ptr . Next # ptr . Next = node # node . Next = next # list . Size += 1 # return true
m , n := len ( s ), len ( t ) # dp := make ([] int , n + 1 ) # dp [ 0 ] = 1 # for i := 0 ; i < m ; i ++ { # for j := n - 1 ; j >= 0 ; j -- { # if s [ i ] == t [ j ] { # dp [ j + 1 ] += dp [ j ] # } # } # } # return dp [ n ]
for i := 0 ; i < len ( A ); i ++ { # reverse ( A [ i ]) # invert ( A [ i ]) # } # return A
ret := make ([] int , 0 ) # if len ( nums ) == 0 { # return ret # } # maxCount := 0 # element 2 CountMap := make ( map [ int ] int , 0 ) # for _ , num := range nums { # element 2 CountMap [ num ]++ # if element 2 CountMap [ num ] > maxCount { # maxCount = element 2 CountMap [ num ] # } # } # tmp := make ([][] int , maxCount + 1 ) # for k , v := range element 2 CountMap { # tmp [ v ] = append ( tmp [ v ], k ) # } # for i := maxCount ; i >= 0 ; i --{ # if len ( tmp [ i ]) == 0 { # continue # } # ret = append ( ret , tmp [ i ]...) # if len ( ret ) == k { # break # } # } # return ret
if offset >= len ( s ){ # return # } # if dot == 3 { # if len ( s ) - offset >= 2 && s [ offset ] == ' 0 '{ # return # } # if i , _ := strconv . Atoi ( string ( s [ offset : len ( s )])); i <= 2 5 5 { # res = append ( res , s ) # } # return # } # if s [ offset ] == ' 0 '{ # tmp := [] byte ( s ) # t := string ( tmp [ 0 : offset + 1 ]) + " STR " + string ( tmp [ offset + 1 :]) # help ( t , offset + 2 , dot + 1 ) # return # } # for i := 1 ; i <= 3 ; i ++{ # if offset + i >= len ( s ){ # return # } # if v , _ := strconv . Atoi ( string ( s [ offset : offset + i ])); v <= 2 5 5 { # tmp :=[] byte ( s ) # t := string ( tmp [: offset + i ])+" STR "+ string ( tmp [ offset + i :]) # help ( t , offset + i + 1 , dot + 1 ) # } # }
return indexByteString ( s , c ) != - 1
t . Parallel () # for _ , tc := range testcases { # if result , err := NextPermutationUint ( tc . in ); result != tc . out || err != tc . err { # t . Errorf (" STR ", tc . out , tc . err , result , err ) # } # }
max := int 6 4 ( 1 0 0 0 0 0 0 ) # greaterThanMax := 0 # # for n := 1 ; n <= 1 0 0 ; n ++ { # for r := 0 ; r <= n ; r ++ { # coef := big . NewInt ( int 6 4 ( 0 )). Binomial ( int 6 4 ( n ), int 6 4 ( r )) # if coef . Cmp ( big . NewInt ( max )) >= 0 { # greaterThanMax ++ # } # } # } # fmt . Println ( greaterThanMax )
iE := i .(* linkedHeapListElement ) # return iE != & h . root && iE != nil
in , err := os . Open ( infile ) # if err != nil { # return err # } # defer in . Close () # # out , err := os . Create ( outfile ) # if err != nil { # return err # } # # if err := ImageStream ( out , in ); err != nil { # out . Close () # return fmt . Errorf (" STR ", infile , outfile , err ) # } # return out . Close ()
if n == 0 { # return [] int { 0 } # } # if n == 1 { # return [] int { 0 , 1 } # } # tmps := grayCode ( n - 1 ) # rets := make ([] int , 2 * len ( tmps )) # ones := 1 # for n > 1 { # ones *= 2 # n -- # } # for i , tmp := range tmps { # rets [ i ] = tmp # rets [ 2 * len ( tmps )- i - 1 ] = tmp + ones # } # return rets
if root == nil { # return nil # } # var result [] int # levels := []* IntBinaryTree { root } # leftToRight := true # for len ( levels ) != 0 { # var nextLevel []* IntBinaryTree # for _ , n := range levels { # result = append ( result , n . Value ) # if n . Left != nil { # nextLevel = append ( nextLevel , n . Left ) # } # if n . Right != nil { # nextLevel = append ( nextLevel , n . Right ) # } # } # if ! leftToRight { # toReverse := result [ len ( result )- len ( levels ):] # for i := 0 ; i < len ( toReverse )/ 2 ; i ++ { # toReverse [ i ], toReverse [ len ( toReverse )- 1 - i ] = toReverse [ len ( toReverse )- 1 - i ], toReverse [ i ] # } # } # leftToRight = ! leftToRight # levels = nextLevel # } # return result
t . Parallel () # for _ , tc := range testcases { # if result := SpreadsheetColumnName ( tc . pos ); result != tc . cell { # t . Errorf (" STR ", tc . cell , result ) # } # }
if x != p [ x ] { # p [ x ] = find ( p [ x ]) # } # return p [ x ]
for _ , entry := range dirents ( dir ) { # if entry . IsDir () { # subdir := filepath . Join ( dir , entry . Name ()) # walkDir ( subdir , fileSizes ) # } else { # fileSizes <- entry . Size () # } # }
return MyLinkedList {}
for i := 0 ; i < height ; i ++ { # r += strconv . Itoa ( rand . Int () % 1 0 ) # } # return
for b != 0 { # a , b = b , a % b # } # return a
return int ( math . Ceil ( math . Log 2 ( float 6 4 ( coins ))))
arr := [] int { 5 , 2 , 6 , 8 , 3 , 1 } # # i 0 := RSelect ( arr , 6 , 0 ) # i 1 := RSelect ( arr , 6 , 1 ) # i 2 := RSelect ( arr , 6 , 2 ) # i 3 := RSelect ( arr , 6 , 3 ) # i 4 := RSelect ( arr , 6 , 4 ) # i 5 := RSelect ( arr , 6 , 5 ) # if i 0 != 1 && # i 1 != 2 && # i 2 != 3 && # i 3 != 5 && # i 4 != 6 && # i 5 != 8 { # fmt . Println (" STR ", i 0 , i 1 , i 2 , i 3 , i 4 , i 5 ) # t . Error () # }
out := 4 1 7 9 8 7 1 # if x := p 2 3 (); x != out { # t . Errorf (" STR ", x , out ) # }
count := 0 # for i := 0 ; i < len ( nums ); i ++ { # digits := len ( strconv . Itoa ( nums [ i ])) # if digits & 1 == 0 { # count ++ # } # } # return count
if dominoes == nil || len ( dominoes ) == 0 { # return 0 # } # result , buckets := 0 , [ 1 0 0 ] int {} # for _ , dominoe := range dominoes { # key , rotatedKey := dominoe [ 0 ]* 1 0 + dominoe [ 1 ], dominoe [ 1 ]* 1 0 + dominoe [ 0 ] # if dominoe [ 0 ] != dominoe [ 1 ] { # if buckets [ rotatedKey ] > 0 { # result += buckets [ rotatedKey ] # } # } # if buckets [ key ] > 0 { # result += buckets [ key ] # buckets [ key ]++ # } else { # buckets [ key ]++ # } # } # return result
print ( fibonacci ( 0 , 1 , 0 ), " STR ")
return h . root
const ( # seed = " STR " # key = 9 7 # ) # # encrypted := Encrypt ( byte ( key ), [] byte ( seed )) # fmt . Printf (" STR ", key , seed , encrypted ) # # decrypted := Decrypt ( byte ( key ), encrypted ) # fmt . Printf (" STR ", key , encrypted , string ( decrypted )) #
return len ( A ) == len ( B ) && # strings . Contains ( A + A , B ) #
s . mtx . Lock () # defer s . mtx . Unlock () # if _ , ok := s . m [ p . ID ]; ok { # return ErrAlreadyExists # } # s . m [ p . ID ] = p # return nil
tests := [...][] int { # { 0 , 1 , 2 }, # { 1 , 2 , 3 }, # } # for _ , input := range tests { # l := SliceInt 2 ListNode ( input ) # output := ListNode 2 SliceInt ( l ) # if ! reflect . DeepEqual ( output , input ) { # t . Fatalf (" STR ", input , output , input ) # } # }
blackCntQ := make ([] int , 0 , 0 ) # # stop := rbTree . PreOrderWalk ( rbTree . Root (), func ( tree binaryTreeIf , node interface {}) bool { # checkRBTRoot ( t , tree .(* rbt ), node .(* gbtElement )) # checkRBTRedNode ( t , tree .(* rbt ), node .(* gbtElement )) # checkRBTBlackPath ( t , tree .(* rbt ), node .(* gbtElement ), & blackCntQ ) # return false # }) # # if len ( blackCntQ ) == 0 { # t . Error (" STR ") # return true # } # return stop
mode = 0 # dic := make ( map [ int ] int ) # ret := [] int {} # helper ( root , dic ) # for k , v := range dic { # if v == mode { # ret = append ( ret , k ) # } # } # return ret
t . Parallel () # for _ , tc := range testcases { # if balanced := WildcardParens ( tc . input ); balanced != tc . balanced { # t . Errorf (" STR ", tc . input , tc . balanced , balanced ) # } # }
fmt . Println ( generateParenthesis ( 3 ))
if root == nil { # return nil # } # # switch { # case key < root . Val : # root . Left = deleteNode ( root . Left , key ) # case key > root . Val : # root . Right = deleteNode ( root . Right , key ) # default : # if root . Left == nil { # return root . Right # } # if root . Right == nil { # return root . Left # } # root . Val = findMinNodeKey ( root . Right ) # root . Right = deleteNode ( root . Right , root . Val ) # } # return root
s := & solution {} # s . helper ( root , 0 ) # return s . sum
const MaxInt = int (^ uint ( 0 ) >> 1 ) # const MinInt = - MaxInt - 1 # return isValidBST ( root . Left , MinInt , root . Value ) && isValidBST ( root . Right , root . Value , MaxInt )
k := len ( word ); # if v , ok := this . trie [ k ]; ok { # this . trie [ k ] = append ( v , word ); # } else { # this . trie [ k ] = [] string { word }; # }
this . startTime = time . Now (). UnixNano () # this . running = true
sf , err := os . Open ( src ) # if err != nil { # return err # } # defer sf . Close () # df , err := os . Create ( dst ) # if err != nil { # return err # } # defer df . Close () # _ , err = io . Copy ( df , sf ) # return err
if k == 8 1 { # return true # } # # r , c := k / 9 , k % 9 # if board [ r ][ c ] != " STR " { # return solve ( board , k + 1 ) # } # # # bi , bj := r / 3 * 3 , c / 3 * 3 # # isValid := func ( b byte ) bool { # for n := 0 ; n < 9 ; n ++ { # if board [ r ][ n ] == b || # board [ n ][ c ] == b || # board [ bi + n / 3 ][ bj + n % 3 ] == b { # return false # } # } # return true # } # # for b := byte (" STR "); b <= " STR "; b ++ { # if isValid ( b ) { # board [ r ][ c ] = b # if solve ( board , k + 1 ) { # return true # } # } # } # # board [ r ][ c ] = " STR " # # return false
temp := queue . array [ len ( queue . array )- 1 ] # queue . array = queue . array [: len ( queue . array )- 1 ] # return temp
sArr := strings . Split ( str , " STR ") # if len ( sArr ) != len ( pattern ) { # return false # } # pMap := make ( map [ byte ] string ) # qMap := make ( map [ string ] byte ) # # for i , v := range sArr { # if _ , ok := pMap [ pattern [ i ]]; ok && pMap [ pattern [ i ]] != v { # return false # } else { # pMap [ pattern [ i ]] = v # } # if _ , ok := qMap [ v ]; ok && qMap [ v ] != pattern [ i ] { # return false # } else { # qMap [ v ] = pattern [ i ] # } # } # return true
tests := [...] testType { # { # in : [] int { 2 , 6 , 4 , 8 , 1 0 , 9 , 1 5 }, # want : 5 , # }, # { # in : [] int { 1 , 2 , 3 , 4 }, # want : 0 , # }, # { # in : [] int { 1 , 2 , 4 , 5 , 3 }, # want : 3 , # }, # } # for _ , tt := range tests { # got := findUnsortedSubarray ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
return fmt . Sprintf (" STR ", n . Target , n . Key )
for i , v := range b { # if v == c { # return i # } # } # return - 1
var y int # for x != 0 { # pop := x % 1 0 # if y > math . MaxInt 3 2 / 1 0 || ( y == math . MaxInt 3 2 / 1 0 && pop > 7 ) { # return 0 # } # if x < math . MinInt 3 2 / 1 0 || ( y == math . MinInt 3 2 / 1 0 && pop < - 8 ) { # return 0 # } # # y = y * 1 0 + pop # x /= 1 0 # } # return y
var combinations [][] int # # var f func ([] int , int ) # f = func ( nums [] int , index int ) { # if len ( nums ) == k { # n := make ([] int , k ) # copy ( n , nums ) # combinations = append ( combinations , n ) # return # } # # for i := index ; i <= n ; i ++ { # f ( append ( nums , i ), i + 1 ) # } # } # # f ( make ([] int , 0 , k ), 1 ) # return combinations
l := len ( nums ) # if l == 1 { # return 0 # } # if nums [ 0 ] > nums [ 1 ] { # return 0 # } else if nums [ l - 1 ] > nums [ l - 2 ] { # return l - 1 # } else { # for i := 1 ; i < len ( nums )- 1 ; i ++ { # if nums [ i ] > nums [ i - 1 ] && nums [ i ] > nums [ i + 1 ] { # return i # } # } # } # return - 1
return leetcodeFlags [ l ]
count := 1 # found := false # for i := 0 ; i < len ( s ); i ++ { # if i > 0 && s [ i ] == ' ' && s [ i - 1 ] != ' ' { # count ++ # } # if s [ i ] != ' ' { # found = true # } # if i == len ( s )- 1 && s [ i ] == ' ' { # count -- # } # } # if found { # return count # } # return 0
positions := make ( map [ string ] Position ) # # for _ , rule := range rules { # parts := strings . Split ( rule , " STR ") # to , dir , from := parts [ 0 ], Direction ( parts [ 1 ]), parts [ 2 ] # toPos , toFound := positions [ to ] # fromPos , fromFound := positions [ from ] # # switch delta := directions [ dir ]; { # case toFound && fromFound : # if ! checkValid ( fromPos , toPos , dir ) { # return false # } # case toFound && ! fromFound : # positions [ from ] = Position { toPos . X - delta . X , toPos . Y - delta . Y } # case ! toFound && fromFound : # positions [ to ] = Position { fromPos . X + delta . X , fromPos . Y + delta . Y } # default : # positions [ from ] = Position { 0 , 0 } # positions [ to ] = directions [ dir ] # } # } # # return true
r := 0 # for x != 0 { # r = r * 1 0 + x % 1 0 # if r > math . MaxInt 3 2 || r < math . MinInt 3 2 { # return 0 # } # x /= 1 0 # } # return r
isBanned := make ( map [ string ] bool ) # for _ , b := range banned { # isBanned [ b ] = true # } # # ss := split ( paragraph ) # # count := make ( map [ string ] int , len ( ss )) # for _ , s := range ss { # if isBanned [ s ] { # continue # } # count [ s ]++ # } # # res := " STR " # max := 0 # # for s , c := range count { # if max < c { # max = c # res = s # } # } # # return res
if len ( obstacleGrid ) == 0 || len ( obstacleGrid [ 0 ]) == 0 { # return 0 # } # # m , n := len ( obstacleGrid ), len ( obstacleGrid [ 0 ]) # dp := make ([] int , n ) # for i := range dp { # if obstacleGrid [ 0 ][ i ] == 1 { # dp [ i ] = 0 # } else if i > 0 { # dp [ i ] = dp [ i - 1 ] # } else { # dp [ i ] = 1 # } # } # # for i := 1 ; i < m ; i ++ { # if obstacleGrid [ i ][ 0 ] == 1 { # dp [ 0 ] = 0 # } # # for j := 1 ; j < n ; j ++ { # if obstacleGrid [ i ][ j ] == 0 { # dp [ j ] += dp [ j - 1 ] # } else { # dp [ j ] = 0 # } # } # } # # return dp [ n - 1 ]
a := make ( map [ interface {}] interface {}) # for k , v := range s { # if a [ v ] == nil { # a [ v ] = t [ k ] # } else { # if a [ v ] != t [ k ] { # return false # } # } # } # b := make ( map [ interface {}] interface {}) # for k , v := range t { # if b [ v ] == nil { # b [ v ] = s [ k ] # } else { # if b [ v ] != s [ k ] { # return false # } # } # } # return true
me . i . mu . Lock () # defer me . i . mu . Unlock () # me . v . refs -- # if me . v . refs == 0 { # delete ( me . i . active , me . k ) # }
sum , n := 1 , 1 # for width := 3 ; width <= 1 0 0 1 ; width += 2 { # for corners := 0 ; corners < 4 ; corners ++ { # n += width - 1 # sum += n # } # } # # fmt . Println ( sum )
var tests = [] struct { # nums 1 , nums 2 [] int # intersection [] int # }{ # { # [] int { 1 , 2 , 2 , 1 }, [] int { 2 , 2 }, # [] int { 2 }, # }, # { # [] int { 4 , 9 , 5 }, [] int { 9 , 4 , 9 , 8 , 4 }, # [] int { 4 , 9 }, # }, # } # # for _ , tt := range tests { # nums := intersection ( tt . nums 1 , tt . nums 2 ) # sort . Ints ( nums ) # if reflect . DeepEqual ( nums , tt . intersection ) == false { # t . Errorf (" STR ", tt . nums 1 , tt . nums 2 , nums , tt . intersection ) # } # }
i . mu . Lock () # defer i . mu . Unlock () # if i . active == nil { # i . active = make ( map [ Key ]* activeValueType ) # } # v , ok := i . active [ key ] # if ! ok { # v = & activeValueType { # ch : make ( chan struct {}, i . SlotsPerKey ), # } # i . active [ key ] = v # } # v . refs ++ # return ActiveValueRef { # v : v , # k : key , # i : i , # }
for i , d := range data { # if err := p . Store ( d ); err != nil { # return i , err # } # } # # return len ( data ), nil
cases := [] struct { # name string # inputs string # expect int # }{ # {" STR ", " STR ", 2 }, # {" STR ", " STR ", 4 }, # {" STR ", " STR ", 6 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := longestValidParentheses ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
switch b . op { # case " STR ": # return b . x . Eval ( env ) + b . y . Eval ( env ) # case " STR ": # return b . x . Eval ( env ) - b . y . Eval ( env ) # case " STR ": # return b . x . Eval ( env ) * b . y . Eval ( env ) # case " STR ": # return b . x . Eval ( env ) / b . y . Eval ( env ) # } # panic ( fmt . Sprintf (" STR ", b . op ))
i , count , end := 0 , 0 , len ( nums )- 1 # # var nextI , maxNextI , maxI int # for i < end { # if i + nums [ i ] >= end { # return count + 1 # } # # nextI , maxNextI = i + 1 , i + nums [ i ] # for nextI <= maxNextI { # if nextI + nums [ nextI ] > maxI { # maxI , i = nextI + nums [ nextI ], nextI # } # # nextI ++ # } # # count ++ # } # # return count
textLength := len ( text ) # patternLength := len ( pattern ) # if patternLength > textLength { # return - 1 # } # for i := 0 ; i < textLength - patternLength + 1 ; i ++ { # if calculateHash ( pattern ) != calculateHash ( text [ i : i + patternLength ]) { # continue # } # matchesCount := 0 # for j := 0 ; j < patternLength ; j ++ { # if text [ i + j ] != pattern [ j ] { # break # } # matchesCount ++ # } # if matchesCount == patternLength { # return i # } # } # return - 1
count := 0 # for i := range S { # if strings . Contains ( J , string ( S [ i ])) { # count ++ # } # } # return count
low , high , n := 0 . 0 , 1 . 0 , len ( A ) # for { # mid , count , p , q , j := ( high + low )/ 2 . 0 , 0 , 0 , 1 , 0 # for i := 0 ; i < n ; i ++ { # for j < n && float 6 4 ( A [ i ]) > float 6 4 ( mid )* float 6 4 ( A [ j ]) { # j ++ # } # count += n - j # if j < n && q * A [ i ] > p * A [ j ] { # p = A [ i ] # q = A [ j ] # } # } # if count == K { # return [] int { p , q } # } else if count < K { # low = mid # } else { # high = mid # } # }
var tests = [] struct { # nums [] int # elements [] int # length int # }{ # {[] int {}, [] int {}, 0 }, # {[] int { 1 , 1 , 1 , 2 , 2 , 3 }, [] int { 1 , 1 , 2 , 2 , 3 }, 5 }, # {[] int { 0 , 0 , 1 , 1 , 1 , 1 , 2 , 3 , 3 }, [] int { 0 , 0 , 1 , 1 , 2 , 3 , 3 }, 7 }, # } # # for _ , tt := range tests { # nums := make ([] int , len ( tt . nums )) # copy ( nums , tt . nums ) # # length := removeDuplicates ( tt . nums ) # if length != tt . length || reflect . DeepEqual ( tt . nums [: length ], tt . elements ) == false { # t . Errorf (" STR ", nums , tt . nums [: length ], length , tt . elements , tt . length ) # } # }
if hashFunc == nil { # hashFunc = crc 3 2 . ChecksumIEEE # } # hm = & HashMap { # HashFunc : hashFunc , # Replicas : replicas , # Keys : nil , # HashMap : make ( map [ int ] string ), # } # return hm
cur := new ( TreeNode ) # # var inorder func (* TreeNode ) # inorder = func ( node * TreeNode ) { # if node == nil { # return # } # # inorder ( node . Left ) # node . Left = nil # cur . Right = node # cur = cur . Right # inorder ( node . Right ) # } # # t := cur # inorder ( root ) # return t . Right
if n % 4 > 0 { # return true # } # # return false
testData := [][] int { # {- 1 , 0 , 1 , 2 , - 6 , - 4 }, # {- 7 , 3 , - 7 , 3 , 4 , 5 , 6 , 6 , 4 }, # } # expected := [][][] int { # {{- 1 , 0 , 1 }}, # {{- 7 , 3 , 4 }}, # } # # for index , nums := range testData { # if res := threeSum ( nums ); ! reflect . DeepEqual ( res , expected [ index ]) { # t . Errorf (" STR ", expected [ index ], res ) # } # }
sort . Ints ( nums ) # ans := 0 # for i := 0 ; i < len ( nums ); i += 2 { # ans += nums [ i ] # } # return ans
return float 3 2 ( uint 3 2 ( v ))
t . Parallel () # for _ , tc := range testcases { # if result := SimulateDominoes ( tc . start ); result != tc . end { # t . Errorf (" STR ", tc . start , tc . end , result ) # } # }
size := len ( nums ) # if size == 0 { # return 0 # } # # sum := make ([] int , size + 1 ) # for i , n := range nums { # sum [ i + 1 ] = sum [ i ] + n # } # # lo = lower # up = upper # tmp = make ([] int , len ( sum )) # # return mergeSort ( sum )
Len := len ( a ) # # i := 1 # for i < Len && a [ i - 1 ] < a [ i ] { # i ++ # } # # return a [ i % Len ]
m := make ( map [ rune ] int ) # for _ , l := range licensePlate { # if l >= ' A ' && l <= ' Z ' { # m [ l -' A '+' a ']++ # } else if l >= ' a ' && l <= ' z ' { # m [ l ]++ # } # } # idx := - 1 # for i := range words { # cnt , flag := make ( map [ rune ] int ), true # for _ , w := range words [ i ] { # cnt [ w ]++ # } # for k , v := range m { # if cnt [ k ] == 0 || cnt [ k ] < v { # flag = false # break # } # } # if flag { # if idx == - 1 { # idx = i # } else if len ( words [ idx ]) > len ( words [ i ]) { # idx = i # } # } # } # return words [ idx ]
if side == left { # return node . Right # } # return node . Left
mux := http . NewServeMux () # mux . Handle (" STR ", loggingHandler ( http . HandlerFunc ( index ))) # mux . Handle (" STR ", loggingHandler ( http . HandlerFunc ( welcome ))) # mux . Handle (" STR ", loggingHandler ( http . HandlerFunc ( message ))) # log . Println (" STR ") # server := & http . Server { # Addr : " STR ", # Handler : mux , # } # server . ListenAndServe ()
old := * pq # n := len ( old ) # item := old [ n - 1 ] # item . index = - 1 # * pq = old [ 0 : n - 1 ] # return item
s . id = id
if len ( pre ) == 0 { # return nil # } # # v := pre [ 0 ] # node := & TreeNode { Val : v } # idx := 1 # for ; idx < len ( pre ); idx ++ { # if pre [ idx ] > v { # break # } # } # if idx > 1 { # node . Left = buildBstFromPreOrder ( pre [ 1 : idx ]) # } # # if idx < len ( pre ) { # node . Right = buildBstFromPreOrder ( pre [ idx :]) # } # # return node
maxArea := 0 # for i := 0 ; i < len ( grid ); i ++ { # for j := 0 ; j < len ( grid [ 0 ]); j ++ { # if 1 == grid [ i ][ j ] { # current := AreaOfIsland ( grid , i , j ) # if maxArea < current { # maxArea = current # } # } # } # } # return maxArea
sd := [] int { 1 , 6 , 3 , 2 , 1 2 3 , - 1 2 3 , - 2 9 , 3 , 0 , 1 } # sort . Slice ( sd , func ( i , j int ) bool { # return sd [ i ] > sd [ j ] # }) # println (" STR ") # for _ , d := range sd { # println ( d ) # } # # ud := [] uint { 1 , 6 , 3 , 2 , 1 2 3 , 2 9 , 3 , 0 , 1 } # sort . Slice ( ud , func ( i , j int ) bool { # return ud [ i ] > ud [ j ] # }) # println (" STR ") # for _ , d := range ud { # println ( d ) # }
ss , pre , l := [] byte ( s +" STR "), 0 , len ( s ) # for cur , c := range ss { # if c == ' ' { # for i , j := pre , cur - 1 ; i < j ; i , j = i + 1 , j - 1 { # ss [ i ], ss [ j ] = ss [ j ], ss [ i ] # } # pre = cur + 1 # } # } # return string ( ss [: l ])
data := make ([] Data , batch ) # # for { # i , err := pull (& sys . Xenia , data ) # if i > 0 { # if _ , err := store (& sys . Pillar , data [: i ]); err != nil { # return err # } # } # # if err != nil { # return err # } # }
res := [] int {} # i := 0 # var dfs func (* TreeNode ) bool # dfs = func ( node * TreeNode ) bool { # if node == nil { # return true # } # if node . Val != voyage [ i ] { # i ++ # return false # } # i ++ # if node . Left != nil && node . Left . Val != voyage [ i ] { # res = append ( res , node . Val ) # return dfs ( node . Right ) && dfs ( node . Left ) # } # return dfs ( node . Left ) && dfs ( node . Right ) # } # if dfs ( root ) { # return res # } # return [] int {- 1 }
n . Target = n . Target . Accept ( v ) # n . Key = n . Key . Accept ( v ) # return v ( n )
for { # switch l . next () { # case " STR ": # l . backup () # l . emit ( itemUnit ) # l . chomp () # return byteRangeSet # case eof : # return l . error (" STR ") # } # }
if n % 2 == 0 { # return n / 2 # } else { # return 3 * n + 1 # }
if h . mixin . LessKey ( n . Key , key ) { # panic (" STR ") # } # n . Key = key # n . Value = value # if p := n . p ; n . p != nil && h . less ( n , n . p ) { # p . c . Remove ( n ) # h . root . PushLeft ( n ) # n . mark = false # h . cascadingCut ( p ) # } # if h . less ( n , h . min ) { # h . min = n # }
pairs := [...][ 2 ] int {{ 1 0 0 , 4 4 }, { 4 0 0 0 0 0 0 , 4 6 1 3 7 3 2 }} # for _ , pair := range pairs { # in , out := pair [ 0 ], pair [ 1 ] # if x := p 2 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # } # }
head := & ListNode {} # tmp := head # for _ , v := range nums { # tmp . Next = & ListNode { Val : v , Next : nil } # tmp = tmp . Next # } # return head . Next
n := len ( A ) # res := make ([] int , 0 , n ) # for x , i := n , 0 ; x > 0 ; x -- { # for i = 0 ; A [ i ] != x ; i ++ { # } # reverse ( A , i + 1 ) # res = append ( res , i + 1 ) # reverse ( A , x ) # res = append ( res , x ) # } # return res
y := 0 # for x != 0 { # y = y * 1 0 + x % 1 0 # x = x / 1 0 # } # if y > math . MaxInt 3 2 || y < math . MinInt 3 2 { # return 0 # } # return y
testCases := []* ListNode { # createSingleLinkedList ([] int { 1 , 2 , 3 , 3 , 4 , 4 , 5 }), # createSingleLinkedList ([] int { 1 , 1 , 1 , 2 , 3 }), # } # # expected := []* ListNode { # createSingleLinkedList ([] int { 1 , 2 , 5 }), # createSingleLinkedList ([] int { 2 , 3 }), # } # # for index , head := range testCases { # if res := deleteDuplicates ( head ); ! reflect . DeepEqual ( res , expected [ index ]) { # t . Errorf (" STR ", expected [ index ], res ) # } # }
x := 1 # y := 2 # z := 3 # rotate (& x , & y , & z ) # fmt . Println ( x , y , z )
fixtures := [] divisorsFixture { # { 1 0 , 8 }, # { 2 2 0 , 2 8 4 }, # { 2 8 4 , 2 2 0 }, # } # # for _ , v := range fixtures { # result := DivisorsSum ( v . value ) # if result != v . expected { # t . Error ( # " STR ", v . value , # " STR ", v . expected , # " STR ", result , # ) # } # }
oldBackets := h . backets # h . Init ( cap ) # for _ , list := range oldBackets { # if list != nil { # for e := list . Front (); e != nil ; e = e . Next () { # h . HashInsert ( e . Value .( hashElement ). Key , e . Value .( hashElement ). Value ) # } # } # }
tests := [...] testType { # { # in : [] int { 1 , 0 , 0 , 0 , 1 , 0 , 1 }, # want : 2 , # }, # { # in : [] int { 1 , 0 , 0 , 0 }, # want : 3 , # }, # { # in : [] int { 0 , 0 , 0 , 1 }, # want : 3 , # }, # { # in : [] int { 0 , 0 , 0 , 0 , 0 , 1 , 0 }, # want : 5 , # }, # { # in : [] int { 0 , 1 , 0 , 0 , 0 , 1 , 0 }, # want : 2 , # }, # { # in : [] int { 0 , 1 , 0 , 0 , 0 , 0 , 0 }, # want : 5 , # }, # { # in : [] int { 1 , 0 , 1 }, # want : 1 , # }, # } # for _ , tt := range tests { # got := maxDistToClosest ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
return (* byte )( unsafe . Pointer ( uintptr ( unsafe . Pointer ( ptr )) + offset ))
lo , hi := 0 , len ( nums ) # for lo < hi { # mid := lo + ( hi - lo )/ 2 # switch { # case nums [ mid ] < target : # lo = mid + 1 # case nums [ mid ] > target : # hi = mid # default : # return mid # } # } # return lo
x , y := 1 , 1 # for i := 1 ; i < n ; i ++ { # x , y = y , x + y # } # return y
sum := make ([] int , 1 0 0 0 1 ) # for _ , num := range nums { # sum [ num ] += num # } # a , b := 0 , 0 # res := 0 # for _ , v := range sum { # if a > b + v { # res = a # } else { # res = b + v # } # a , b = res , a # } # return res
t . Parallel () # for _ , tc := range testcases { # if result := ShortestSubstringContains ( tc . str , tc . letters ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
sorted := make ([] int , len ( heights )) # copy ( sorted , heights ) # sort . Ints ( sorted ) # res := 0 # for i := 0 ; i < len ( heights ); i ++ { # if heights [ i ] != sorted [ i ] { # res ++ # } # } # return res
switch val := val .( type ) { # case Unmatched : # panic (" STR ") # case Doubler : # println (" STR ", val . Double ()) # case Tuple : # println (" STR ", val . Nth ( 0 ), val . Nth ( 1 ), val . Nth ( 2 ), val . Nth ( 3 )) # val . Print () # case int : # println (" STR ", val ) # case byte : # println (" STR ", val ) # case string : # println (" STR ", val ) # case Thing : # println (" STR ", val . String ()) # case * Thing : # println (" STR ", val . String ()) # case struct { i int }: # println (" STR ") # case struct { n int }: # println (" STR ") # case struct { # n int ` foo :" STR "` # }: # println (" STR ") # case Foo : # println (" STR ", val ) # default : # println (" STR ") # }
t . Parallel () # for _ , tc := range testcases { # h := NewHuffman ( tc . freq ) # for i := range tc . decoded { # if encode , err := h . Encode ( tc . decoded [ i ]); err != tc . encodedErr [ i ] || encode != tc . encoded [ i ] { # t . Errorf (" STR ", tc . decoded [ i ], tc . encoded [ i ], tc . encodedErr [ i ], encode , err ) # } # } # }
n := len ( A ) # color := 0 # for i := 1 ; i < n ; i ++ { # if A [ i - 1 ] == A [ i ] { # continue # } else if A [ i - 1 ] < A [ i ] { # if color > 0 { # return false # } # color = - 1 # } else { # if color < 0 { # return false # } # color = 1 # } # } # return true
decoded , err := hex . DecodeString ( msg ) # if err != nil { # panic (" STR ") # } # # smallest := 1 0 0 0 . 0 # ans := " STR " # # for b := byte ( 0 ); b < byte ( 2 5 5 ); b ++ { # freq := make ( map [ byte ] int ) # sb := strings . Builder {} # totalC := 0 # invalidC := 0 # # for i := 0 ; i < len ( decoded ); i ++ { # newB := decoded [ i ] ^ b # lowered := strings . ToLower ( string ( newB )) # # if lowerC := lowered [ 0 ]; lowerC >= ' a ' && lowerC <= ' z ' { # freq [ lowerC ]++ # } else if lowerC != ' ' { # invalidC ++ # } # totalC ++ # # sb . WriteByte ( newB ) # } # # if invalidC > 0 { # continue # } # # var diff float 6 4 # # for k , v := range freq { # diff += abs ( freqMap [ k ] - float 6 4 ( v )/ float 6 4 ( totalC )) # } # # if diff < smallest { # smallest = diff # ans = sb . String () # } # } # # return ans
i := 0 # p := Pool { # New : func () interface {} { # i ++ # return i # }, # } # if v := p . Get (); v != 1 { # t . Fatalf (" STR ", v ) # } # if v := p . Get (); v != 2 { # t . Fatalf (" STR ", v ) # } # p . Put ( 4 2 ) # if v := p . Get (); v != 4 2 { # t . Fatalf (" STR ", v ) # } # if v := p . Get (); v != 3 { # t . Fatalf (" STR ", v ) # }
return & HashMap { # capacity : defaultCapacity , # table : make ([]* node , defaultCapacity ), # }
var x , y IntSet # x . Add ( 1 ) # x . Add ( 1 4 4 ) # x . Add ( 9 ) # fmt . Println ( x . String ()) # # y . Add ( 9 ) # y . Add ( 4 2 ) # fmt . Println ( y . String ()) # # x . UnionWith (& y ) # fmt . Println ( x . String ()) # # fmt . Println ( x . Has ( 9 ), x . Has ( 1 2 3 )) #
qs := [] question 2 1 7 { # # { # para 2 1 7 {[] int { 1 , 2 , 3 , 1 }}, # ans 2 1 7 { true }, # }, # # { # para 2 1 7 {[] int { 1 , 2 , 3 , 4 }}, # ans 2 1 7 { false }, # }, # # { # para 2 1 7 {[] int { 1 , 1 , 1 , 3 , 3 , 4 , 3 , 2 , 4 , 2 }}, # ans 2 1 7 { true }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 1 7 , q . para 2 1 7 # fmt . Printf (" STR ", p , containsDuplicate ( p . one )) # } # fmt . Printf (" STR ")
var v * int # return v
res := 0 # gap := 0 # # for N > 0 { # if N & 1 == 1 { # res = max ( res , gap ) # gap = 1 # } else if gap > 0 { # gap ++ # } # N >>= 1 # } # # return res
return fmt . Sprintf (" STR ", n . Typex , n . Value )
n := len ( nums ) # if n == 0 { # return false # } # # k := 1 # for k < n && nums [ k - 1 ] <= nums [ k ] { # k ++ # } # # for i , j := 0 , n - 1 ; i <= j ; { # m := ( i + j ) / 2 # middle := ( m + k ) % n # # if nums [ middle ] == target { # return true # } else if nums [ middle ] < target { # i = m + 1 # } else { # j = m - 1 # } # } # return false
if len ( a ) != len ( b ) { # return false # } # if len ( a ) == 0 { # return true # } # startLetter := rune ( a [ 0 ]) # startPos := strings . IndexRune ( b , startLetter ) # for { # if startPos == - 1 { # return false # } # matches := 0 # for pos := startPos ; pos < startPos + len ( b ); pos ++ { # if a [ pos - startPos ] != b [ pos % len ( b )] { # newIndex := strings . IndexRune ( b [ startPos + 1 :], startLetter ) # if newIndex == - 1 { # startPos = - 1 # } else { # startPos += ( newIndex + 1 ) # } # break # } # matches ++ # } # if matches == len ( a ) { # return true # } # }
res := [][] int {} # for l , r := 0 , 1 ; r < len ( S ); r ++ { # if S [ l ] != S [ r ] { # l = r # continue # } # if r - l + 1 == 3 { # res = append ( res , [] int { l , r }) # } else if r - l + 1 > 3 { # res [ len ( res )- 1 ][ 1 ] = r # } # } # return res
return & prefixMapSumTrie {}
return dp ("", 0 , n * 2 )
tests := [...] testType { # { # in : [][] int { # { 1 , 1 , 1 }, # { 1 , 0 , 1 }, # { 1 , 1 , 1 }, # }, # want : [][] int { # { 0 , 0 , 0 }, # { 0 , 0 , 0 }, # { 0 , 0 , 0 }, # }, # }, # { # in : [][] int { # { 1 , 2 , 3 }, # { 4 , 5 , 6 }, # { 7 , 8 , 9 }, # }, # want : [][] int { # { 3 , 3 , 4 }, # { 4 , 5 , 5 }, # { 6 , 6 , 7 }, # }, # }, # } # for _ , tt := range tests { # got := imageSmoother ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
hdrs := [] lout { # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemStart , " STR "}, # { itemEnd , " STR "}}}, # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemStart , " STR "}, # { itemEnd , ""}}}, # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemStart , " STR "}, # { itemEnd , " STR "}, # { itemStart , " STR "}, # { itemEnd , " STR "}}}, # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemStart , " STR "}, # { itemEnd , " STR "}, # { itemStart , " STR "}, # { itemEnd , ""}}}, # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemStart , " STR "}, # { itemEnd , ""}, # { itemStart , " STR "}, # { itemEnd , " STR "}}}, # } # for _ , h := range hdrs { # t . Run ( h . Name , lexCmp ( lexRequest , h )) # }
return & MemCache { # cache : make ( map [ string ] string ), # }
t . Run (" STR ", func ( t * testing . T ) { # var want int 6 4 = 9 # var prvKey int 6 4 = 5 # var generator int 6 4 = 3 # var primeNumber int 6 4 = 1 3 # got := modularExponentiation ( generator , prvKey , primeNumber ) # if got != want { # t . Errorf (` with privateKey =% d , generator =% d and primeNumber =% d # modularExponentiation should result =% d , but resulted =% d `, prvKey , generator , primeNumber , want , got ) # } # }) # # t . Run (" STR ", func ( t * testing . T ) { # alicePrvKey , _ := rsa . GenerateKey ( rand . Reader , 3 1 ) # bobPrvKey , _ := rsa . GenerateKey ( rand . Reader , 3 1 ) # # shareKeyByAlice := GenerateShareKey ( alicePrvKey . D . Int 6 4 ()) # shareKeyByBob := GenerateShareKey ( bobPrvKey . D . Int 6 4 ()) # # # mutualKeyComputedByAlice := GenerateMutualKey ( alicePrvKey . D . Int 6 4 (), shareKeyByBob ) # mutualKeyComputedByBob := GenerateMutualKey ( bobPrvKey . D . Int 6 4 (), shareKeyByAlice ) # # if mutualKeyComputedByAlice != mutualKeyComputedByBob { # t . Errorf (" STR ") # } # })
t 0 := time . Now () # # sum := uint 6 4 ( 1 ) # # for i := uint 6 4 ( 2 ); i < 1 0 0 0 ; i ++ { # t := uint 6 4 ( 1 ) # for j := uint 6 4 ( 1 ); j <= i ; j ++ { # t *= i # t %= 1 0 0 0 0 0 0 0 0 0 0 # } # sum += t # sum %= 1 0 0 0 0 0 0 0 0 0 0 # } # # t 1 := time . Now () # # answer = fmt . Sprint ( sum ) # runTime = t 1 . Sub ( t 0 ) # # return
if len ( s ) == 0 { # return 0 # } # str := [] byte ( s ) # start , end := 0 , 0 # ret := 0 # c := make ([] int , 2 6 ) # c [ str [ 0 ]-' A ']++ # for len ( str ) > end { # maxc := 0 # for i := 0 ; i < 2 6 ; i ++ { # if c [ i ] > maxc { # maxc = c [ i ] # } # } # if maxc + k > end - start { # end ++ # if end < len ( str ) { # c [ str [ end ]-' A ']++ # } # } else { # c [ str [ start ]-' A ']-- # start ++ # } # if maxc + k > ret { # if maxc + k <= len ( str ) { # ret = maxc + k # } else { # ret = len ( str ) # } # } # } # return ret
big , small := A , B # bigCh , smallCh := byte ( 9 7 ), byte ( 9 8 ) # if A < B { # big , small = B , A # bigCh , smallCh = byte ( 9 8 ), byte ( 9 7 ) # } # # result := make ([] byte , 0 ) # for big > small && big > 1 && small > 0 { # result = append ( result , bigCh , bigCh , smallCh ) # big , small = big - 2 , small - 1 # } # # for big > 0 && small > 0 { # result = append ( result , bigCh , smallCh ) # big , small = big - 1 , small - 1 # } # # for big > 0 { # result = append ( result , bigCh ) # big -- # } # # return string ( result )
h . Swap ( h . Head (), h . Last ()) # i = h . binHeapArrayIf . Pop () # if h . Len () > 0 { # h . MaxHeaplify ( h . Head ()) # } # return
sd := [] int 1 6 { 1 , 6 , 3 , 2 , 1 9 2 3 , 1 2 3 , - 1 2 3 , - 2 9 , 3 , 0 , 1 } # sort . Slice ( sd , func ( i , j int ) bool { # return sd [ i ] > sd [ j ] # }) # println (" STR ") # for _ , d := range sd { # println ( d ) # } # # ud := [] uint 1 6 { 1 , 6 , 3 , 2 , 1 9 2 3 , 1 2 3 , 2 9 , 3 , 0 , 1 } # sort . Slice ( ud , func ( i , j int ) bool { # return ud [ i ] > ud [ j ] # }) # println (" STR ") # for _ , d := range ud { # println ( d ) # }
solve ( board , 0 )
return ( root . Left == nil || root . Left . Val == root . Val && isUnivalTree ( root . Left )) && # ( root . Right == nil || root . Right . Val == root . Val && isUnivalTree ( root . Right ))
low , high := 0 , len ( letters )- 1 # for low <= high { # mid := ( low + high ) / 2 # if letters [ mid ] > target { # high = mid - 1 # } else { # low = mid + 1 # } # } # if low >= len ( letters ) { # return letters [ 0 ] # } else { # return letters [ low ] # }
l := len ( strs ) # if l == 0 { # return " STR " # } # pre := strs [ 0 ] # for i := 1 ; i < l ; i ++ { # for strings . Index ( strs [ i ], pre ) != 0 { # pre = pre [: len ( pre )- 1 ] # } # } # return pre
fmt . Printf (" STR ", p . Dob . String (), p . Email , p . Location )
dp := make ([] int , len ( nums )) # dp [ len ( nums )- 1 ] = 1 # # for i := len ( nums ) - 2 ; i >= 0 ; i -- { # for j := 0 ; j <= nums [ i ] && j < len ( nums ); j ++ { # if dp [ i + j ] == 1 { # dp [ i ] = 1 # break # } # } # } # return dp [ 0 ] == 1
elfFile , err := elf . Open ( executable ) # if err != nil { # return nil , elf . FileHeader {}, err # } # defer elfFile . Close () # # section := elfFile . Section ( sectionName ) # if section == nil { # return nil , elf . FileHeader {}, fmt . Errorf (" STR ", sectionName ) # } # # data , err := section . Data () # # return data , elfFile . FileHeader , err
if a > b { # a , b = b , a # } # # m := lcm ( a , b ) # l , r := a * n / 2 , b * n # # for { # med := ( l + r ) / 2 # count := magicalOf ( med , a , b , m ) # switch { # case count < n : # l = med + 1 # case n < count : # r = med - 1 # default : # res := med - min ( med % a , med % b ) # return res % mod # } # }
maxDiagonal := 1 0 0 1 # position , diagonalsSum , jump := 1 , 1 , 0 # for ( jump + 2 ) <= maxDiagonal { # jump += 2 # for i := 0 ; i < 4 ; i ++ { # position += jump # diagonalsSum += position # } # } # fmt . Println ( diagonalsSum )
var tests = [] struct { # n int # cnt int # }{ # { 0 , 0 }, # { 1 0 , 4 }, # { 1 0 0 , 2 5 }, # { 1 0 0 0 , 1 6 8 }, # { 1 0 0 0 0 , 1 2 2 9 }, # } # # for _ , tt := range tests { # cnt := countPrimes ( tt . n ) # if cnt != tt . cnt { # t . Errorf (" STR ", tt . n , cnt , tt . cnt ) # } # }
var result string # # maxIndex := 0 # for i , str := range strs { # strLen := len ( str ) # if i == 0 { # maxIndex = strLen - 1 # result = str # continue # } # # if strLen - 1 < maxIndex { # maxIndex = strLen - 1 # result = result [: strLen ] # } # # for j := 0 ; j <= maxIndex && j < strLen ; j ++ { # if str [ j ] != result [ j ] { # maxIndex = j - 1 # result = str [: j ] # } # } # } # # return result
hashsep , pow := HashStrBytes ( sep ) # n := len ( sep ) # var h uint 3 2 # for i := 0 ; i < n ; i ++ { # h = h * PrimeRK + uint 3 2 ( s [ i ]) # } # if h == hashsep && Equal ( s [: n ], sep ) { # return 0 # } # for i := n ; i < len ( s ); { # h *= PrimeRK # h += uint 3 2 ( s [ i ]) # h -= pow * uint 3 2 ( s [ i - n ]) # i ++ # if h == hashsep && Equal ( s [ i - n : i ], sep ) { # return i - n # } # } # return - 1
out := make ( chan int ) # go func () { # out <- 1 # limit := int ( math . Ceil ( math . Sqrt ( float 6 4 ( n )))) # for i := 2 ; i <= limit ; i ++ { # if n % i == 0 { # out <- i # out <- n / i # } # } # close ( out ) # }() # # return out
count 1 , count 2 , candidate 1 , candidate 2 := 0 , 0 , 0 , 1 # for _ , num := range nums { # if num == candidate 1 { # count 1 ++ # } else if num == candidate 2 { # count 2 ++ # } else if count 1 <= 0 { # candidate 1 , count 1 = num , 1 # } else if count 2 <= 0 { # candidate 2 , count 2 = num , 1 # } else { # count 1 -- # count 2 -- # } # } # count 1 , count 2 = 0 , 0 # for _ , num := range nums { # if num == candidate 1 { # count 1 ++ # } else if num == candidate 2 { # count 2 ++ # } # } # length := len ( nums ) # if count 1 > length / 3 && count 2 > length / 3 { # return [] int { candidate 1 , candidate 2 } # } # if count 1 > length / 3 { # return [] int { candidate 1 } # } # if count 2 > length / 3 { # return [] int { candidate 2 } # } # return [] int {}
return " STR " + str
data := make ([] bool , n + 1 ) # for i := 2 ; i < int ( math . Sqrt ( float 6 4 ( n )))+ 1 ; i ++ { # if ! data [ i ] { # for j := i * i ; j <= n ; j += i { # data [ j ] = true # } # } # } # var results [] int # for i := 2 ; i <= n ; i ++ { # if ! data [ i ] { # results = append ( results , i ) # } # } # return results
arr := randomSlice ( 0 , 2 0 , 1 0 ) # bst := newBstRecrusive () # for _ , v := range arr { # bst . Insert ( uint 3 2 ( v )) # } # key := getRand (). Intn ( len ( arr )) # result := int ( bst . Search ( uint 3 2 ( arr [ key ])).(* bstElement ). Key ) # if result != arr [ key ] { # t . Log ( fmt . Sprintf (" STR ", arr [ key ], result )) # t . Fail () # }
switch v := reflect . ValueOf ( v ); v . Kind () { # case reflect . String : # result . Type = TypeString # default : # err = fmt . Errorf (" STR ", v . Kind ()) # } # # result . Value = v # return
min := time . Duration ( 5 * time . Second ) # max := time . Duration ( 3 0 * time . Second ) # fmt . Println ( ClipDuration ( 3 * time . Second , min , max )) # fmt . Println ( ClipDuration ( 1 0 * time . Second , min , max )) # fmt . Println ( ClipDuration ( 5 0 * time . Second , min , max ))
max := 1 0 0 0 0 # # var sum , divisorsSum int # for i := 0 ; i < max ; i ++ { # divisorsSum = getDivisorsSum ( i ) # if divisorsSum < i && getDivisorsSum ( divisorsSum ) == i { # sum += i + divisorsSum # } # } # fmt . Println ( sum )
str 1 := " STR " # str 2 := " STR " # fmt . Println ( isIsomorphic ( str 1 , str 2 ))
dp := make ([] int , amount + 1 ) # for j := 1 ; j <= amount ; j ++ { # dp [ j ] = amount + 1 # } # for i := 1 ; i <= amount ; i ++ { # for _ , v := range coins { # if i >= v { # dp [ i ] = min ( dp [ i ], dp [ i - v ]+ 1 ) # } # } # } # if dp [ amount ] > amount { # return - 1 # } # return dp [ amount ]
target := " STR " # charmap := [] rune (" STR ") # # res , err := GeneticString ( target , charmap , & Conf {}) # if err != nil { # t . Errorf (" STR ", err ) # } # # got := res . Best # # if got . Value != float 6 4 ( 1 . 0 ) { # t . Errorf (" STR ", float 6 4 ( 1 . 0 ), got . Value ) # } # # if got . Key != target { # t . Errorf (" STR ", target , got . Key ) # }
if 0 == len ( inorder ) { # return nil # } # # val := postorder [ len ( postorder )- 1 ] # root := & TreeNode { Val : val } # # i := 0 # for ; i < len ( inorder ); i ++ { # if inorder [ i ] == val { # break # } # } # # root . Left = buildTree ( inorder [: i ], postorder [: i ]) # root . Right = buildTree ( inorder [ i + 1 :], postorder [ i : len ( postorder )- 1 ]) # # return root
if x < 0 || ( x != 0 && x % 1 0 == 0 ) { # return false # } # reverse := 0 # for x > reverse { # reverse = reverse * 1 0 + ( x % 1 0 ) # x = x / 1 0 # } # return x == reverse || x == reverse / 1 0
left , right := 0 , len ( nums )- 1 # for left <= right { # mid := left + ( right - left )/ 2 # if nums [ mid ] < target { # left = mid + 1 # } else if nums [ mid ] > target { # right = mid - 1 # } else { # res := [] int { mid , mid } # for res [ 0 ]- 1 >= 0 && nums [ res [ 0 ]- 1 ] == target { # res [ 0 ]-- # } # for res [ 1 ]+ 1 < len ( nums ) && nums [ res [ 1 ]+ 1 ] == target { # res [ 1 ]++ # } # return res # } # } # # return [] int {- 1 , - 1 }
if root == nil { # return 0 # } # val := 0 # if root . Left != nil { # val += rob ( root . Left . Left ) + rob ( root . Left . Right ) # } # if root . Right != nil { # val += rob ( root . Right . Right ) + rob ( root . Right . Left ) # } # return max ( val + root . Val , rob ( root . Left )+ rob ( root . Right ))
a := [] float 6 4 { 1 , 2 , 3 , 4 , 5 , 6 } # A := MakeMatrix ( a , 3 , 2 ) # # if A . CountRows () != 3 { # t . Error () # } # if A . CountCols () != 2 { # t . Error () # }
this . mutex . Lock () # defer this . mutex . Unlock () # # for i , q := range this . queues { # q . Close () # this . waiting [ i ] = 0 # } # this . top = 0 # this . total = 0
perfects := [] int {} # for i := 1 ; i * i <= n ; i ++ { # perfects = append ( perfects , i * i ) # } # # dp := make ([] int , n + 1 ) # for i := 1 ; i < len ( dp ); i ++ { # dp [ i ] = math . MaxInt 3 2 # } # # for _ , p := range perfects { # for i := p ; i < len ( dp ); i ++ { # if dp [ i ] > dp [ i - p ]+ 1 { # dp [ i ] = dp [ i - p ] + 1 # } # } # } # # return dp [ n ]
type arg struct { # nums [] int # target int # } # # testCases := [] arg { # { # nums : [] int {- 1 , 0 , 3 , 5 , 9 , 1 2 }, # target : 9 , # }, # { # nums : [] int {- 1 , 0 , 3 , 5 , 9 , 1 2 }, # target : - 3 , # }, # } # # expected := [] int { 4 , - 1 } # # for index , data := range testCases { # if res := search ( data . nums , data . target ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
tree := []* TreeNode { root } # for i := 0 ; i < len ( tree ); i ++ { # if tree [ i ]. Left != nil { # tree = append ( tree , tree [ i ]. Left ) # } # if tree [ i ]. Right != nil { # tree = append ( tree , tree [ i ]. Right ) # } # } # return CBTInserter { # tree : tree , # }
list . top = nil
var tests = [] struct { # nums [] int # tree * TreeNode # }{ # {[] int { 3 , 2 , 1 , 6 , 0 , 5 }, newTree ( 6 , 3 , 5 , nil , 2 , 0 , nil , nil , 1 )}, # } # # for _ , tt := range tests { # tree := constructMaximumBinaryTree ( tt . nums ) # if reflect . DeepEqual ( tree , tt . tree ) == false { # t . Errorf (" STR ", tt . nums , tree , tt . tree ) # } # }
fmt . Println ( rotatedDigits ( 2 ))
window := make ( map [ string ] int ) # target := make ( map [ string ] int ) # for _ , v := range p { # target [ string ( v )]++ # } # left , right := 0 , 0 # validate := 0 # for right < len ( s ) { # char := string ( s [ right ]) # right ++ # if v , ok := target [ char ]; ok && v >= 1 { # window [ char ]++ # if window [ char ] == target [ char ] { # validate ++ # } # } # for right - left >= len ( p ) { # if right - left == validate { # res = append ( res , left ) # } # removeChar := string ( s [ left ]) # left ++ # if v , ok := target [ removeChar ]; ok && v >= 1 { # if target [ removeChar ] == window [ removeChar ] { # validate -- # } # window [ removeChar ]-- # } # } # } # return
qs := [] question 5 0 7 { # # { # para 5 0 7 { 2 8 }, # ans 5 0 7 { true }, # }, # # { # para 5 0 7 { 4 9 6 }, # ans 5 0 7 { true }, # }, # # { # para 5 0 7 { 5 0 0 }, # ans 5 0 7 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 0 7 , q . para 5 0 7 # fmt . Printf (" STR ", p , checkPerfectNumber ( p . num )) # } # fmt . Printf (" STR ")
var n 1 , n 2 , prev * TreeNode # var dfs func (* TreeNode ) # dfs = func ( node * TreeNode ) { # if node . Left != nil { # dfs ( node . Left ) # } # # if prev != nil && prev . Val > node . Val { # if n 1 == nil { # n 1 = prev # } # if n 1 != nil { # n 2 = node # } # } # prev = node # # if node . Right != nil { # dfs ( node . Right ) # } # } # dfs ( root ) # n 1 . Val , n 2 . Val = n 2 . Val , n 1 . Val
offsets := make ([] int 6 4 , len ( fields )) # var o int 6 4 # for i , f := range fields { # a := s . Alignof ( f . Type ()) # o = align ( o , a ) # offsets [ i ] = o # o += s . Sizeof ( f . Type ()) # } # return offsets
m := make ( map [ byte ] int ) # for i := len ( order ) - 1 ; i >= 0 ; i -- { # m [ order [ i ]] = i # } # if len ( words ) > 1 { # for pre , word := range words [ 1 :] { # l , wl := len ( words [ pre ]), len ( word ) # for i := 0 ; i < l ; i ++ { # if wl <= i || m [ words [ pre ][ i ]] > m [ word [ i ]] { # return false # } else if m [ words [ pre ][ i ]] < m [ word [ i ]] { # break # } # } # } # } # return true
roots := make ( map [ byte ][] string ) # for _ , root := range dict { # b := root [ 0 ] # roots [ b ] = append ( roots [ b ], root ) # } # words := strings . Split ( sentence , " STR ") # for i , word := range words { # b := [] byte ( word ) # for j := 1 ; j < len ( b ) && j <= 1 0 0 ; j ++ { # if findWord ( roots , b [ 0 : j ]) { # words [ i ] = string ( b [ 0 : j ]) # break # } # } # } # return strings . Join ( words , " STR ")
jrePath := self . jre # if jrePath != "" && exists ( jrePath ) { # return jrePath , nil # } # jh := os . Getenv (" STR ") # if jh != "" { # jh = filepath . Join ( jh , " STR ") # return jh , nil # } # return " STR "
result := big . NewInt ( 0 ) # result . MulRange ( 1 , n ) # return result
var ( # res int # n = len ( points ) # ) # # for i := 0 ; i < n ; i ++ { # record := make ( map [ int ] int ) # for j := 0 ; j < n ; j ++ { # if j != i { # dis := dis ( points [ i ], points [ j ]) # record [ dis ]++ # } # } # # for _ , j := range record { # res += j * ( j - 1 ) # } # } # return res
qs := [] question 3 4 3 { # # { # para 3 4 3 { 2 }, # ans 3 4 3 { 1 }, # }, # # { # para 3 4 3 { 1 0 }, # ans 3 4 3 { 3 6 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 4 3 , q . para 3 4 3 # fmt . Printf (" STR ", p , integerBreak ( p . one )) # } # fmt . Printf (" STR ")
if len ( matrix ) == 0 || len ( matrix [ 0 ]) == 0 { # return false # } # # n := len ( matrix ) # m := len ( matrix [ 0 ]) # if target < matrix [ 0 ][ 0 ] || target > matrix [ n - 1 ][ m - 1 ] { # return false # } # # var mid int # low , high := 0 , n - 1 # for low <= high { # mid = ( low + high ) / 2 # if matrix [ mid ][ 0 ] > target { # high = mid - 1 # } else if matrix [ mid ][ 0 ] < target { # low = mid + 1 # } else { # return true # } # } # # left , right := 0 , m - 1 # for left <= right { # mid = ( left + right ) / 2 # if matrix [ high ][ mid ] > target { # right = mid - 1 # } else if matrix [ high ][ mid ] < target { # left = mid + 1 # } else { # return true # } # } # return false
modified := false # for i := 0 ; i < len ( nums )- 1 ; i ++ { # if nums [ i ] > nums [ i + 1 ] { # if modified { # return false # } else if i >= 1 && nums [ i - 1 ] > nums [ i + 1 ] { # nums [ i + 1 ] = nums [ i ] # } # modified = true # } # } # return true
log . Println (" STR ") # fmt . Fprintf ( w , " STR ")
inserted := & TreeNode { Val : val } # if root == nil { # return inserted # } # # for p := root ; ; { # if val < p . Val { # if p . Left == nil { # p . Left = inserted # break # } # p = p . Left # } else { # if p . Right == nil { # p . Right = inserted # break # } # p = p . Right # } # } # return root
cases := [] struct { # name string # x int # expect [][] string # }{ # {" STR ", 4 , [][] string {{" STR "," STR "," STR "," STR "},{" STR "," STR "," STR "," STR "}}}, # {" STR ", 1 , [][] string {{" STR "}}}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := Solution ( c . x ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . x ) # } # }) # }
cash , hold := 0 , - prices [ 0 ] # for i := 1 ; i < len ( prices ); i ++ { # cash = max ( cash , hold + prices [ i ]- fee ) # hold = max ( hold , cash - prices [ i ]) # } # return cash
if len ( nums ) < 2 { # return # } # median := findKthLargest 3 2 4 ( nums , ( len ( nums )+ 1 )/ 2 ) # n , i , left , right := len ( nums ), 0 , 0 , len ( nums )- 1 # # for i <= right { # if nums [ indexMap ( i , n )] > median { # nums [ indexMap ( left , n )], nums [ indexMap ( i , n )] = nums [ indexMap ( i , n )], nums [ indexMap ( left , n )] # left ++ # i ++ # } else if nums [ indexMap ( i , n )] < median { # nums [ indexMap ( right , n )], nums [ indexMap ( i , n )] = nums [ indexMap ( i , n )], nums [ indexMap ( right , n )] # right -- # } else { # i ++ # } # }
fmt . Println ( partitionDisjoint ([] int { 5 , 0 , 3 , 8 , 6 }))
c := & Call { Func : " STR "} # scope := & BasicScope { # FuncMap : map [ string ] Function { # " STR ": Function { ReturnType : TypeString }, # }, # } # # _ , err := c . Type ( scope ) # if err == nil { # t . Fatal (" STR ") # }
fmt . Println ( numMagicSquaresInside ([][] int { # { 4 , 3 , 8 , 4 }, # { 9 , 5 , 1 , 9 }, # { 2 , 7 , 6 , 2 }, # })) #
index := int ( 1 . 0 / 6 . 0 * ( 1 . 0 + math . Sqrt ( 1 . 0 + 2 4 . 0 * float 6 4 ( number )))) # if ( index *( 3 * index - 1 ))/ 2 == number { # return true # } # return false
reader := bufio . NewReader ( os . Stdin ) # for { # fmt . Print (" STR ") # cmdString , err := reader . ReadString ('\ n ') # if err != nil { # fmt . Fprintln ( os . Stderr , err ) # } # err = runCommand ( cmdString ) # if err != nil { # fmt . Fprintln ( os . Stderr , err ) # } # }
var ret int # var num int # # num = 5 # ret = 4 # if ret != firstBadVersion ( num ) { # t . Fatalf (" STR ", ret ) # }
for _ , tc := range testCases { # t . Run ( tc . name , func ( t * testing . T ) { # actual := Kmp ( tc . text , tc . word ) # if ! reflect . DeepEqual ( actual , tc . expected ) { # t . Errorf (" STR ", # tc . word , tc . text , tc . expected . numberOfComparison , tc . expected . resultPosition , actual . numberOfComparison , actual . resultPosition ) # } # }) # }
type A struct { # Name string # Value string # Time time . Time ` structs :" STR "` # } # a := A { Time : time . Now ()} # # type B struct { # Desc string # A A # } # b := & B { A : a } # # m := Map ( b ) # # in , ok := m [" STR "].( map [ string ] interface {}) # if ! ok { # t . Error (" STR ") # } # # if _ , ok := in [" STR "].( map [ string ] interface {}); ok { # t . Error (" STR ") # } # # if _ , ok := in [" STR "].( time . Time ); ! ok { # t . Error (" STR ") # }
if self . size == 0 { # panic (" STR ") # } # topElem := self . top # self . top = topElem . next # topElem . next = nil # self . size -- # # return topElem
cases := [] struct { # name string # inputs int # expect string # }{ # {" STR ", 4 9 , " STR "}, # {" STR ", 0 , " STR "}, # {" STR ", 1 4 , " STR "}, # {" STR ", 1 0 0 , " STR "}, # {" STR ", - 7 , " STR "}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
fmt . Println ( leastInterval ([] byte {' A ', ' A ', ' A ', ' B ', ' B '}, 2 ))
stack := make ([] int , len ( tokens )) # top := - 1 # for i := 0 ; i < len ( tokens ); i ++ { # switch ch := tokens [ i ]; ch { # case " STR ": # stack [ top - 1 ] += stack [ top ] # top -- # case " STR ": # stack [ top - 1 ] -= stack [ top ] # top -- # case " STR ": # stack [ top - 1 ] *= stack [ top ] # top -- # case " STR ": # stack [ top - 1 ] /= stack [ top ] # top -- # default : # top ++ # stack [ top ], _ = strconv . Atoi ( ch ) # } # } # return stack [ 0 ]
if len ( matrix ) == 0 || len ( matrix [ 0 ]) == 0 { # return 0 # } # m := map [ byte ] int { # ' 0 ': 0 , # ' 1 ': 1 , # } # p := make ([][] int , len ( matrix )) # for i := range p { # p [ i ] = make ([] int , len ( matrix [ i ])) # } # max := 0 # for i := range matrix { # for j := range matrix [ i ] { # if i == 0 || j == 0 { # p [ i ][ j ] = m [ matrix [ i ][ j ]] # } else if matrix [ i ][ j ] == ' 1 ' { # p [ i ][ j ] = min ( min ( p [ i - 1 ][ j ], p [ i ][ j - 1 ]), p [ i - 1 ][ j - 1 ]) + 1 # } # if p [ i ][ j ] > max { # max = p [ i ][ j ] # } # } # } # return max * max
var route [] int # var queue [] int # startIdx := getIdx ( start , nodes ) # queue = append ( queue , startIdx ) # for len ( queue ) > 0 { # now := queue [ 0 ] # route = append ( route , nodes [ now ]) # if len ( queue ) > 1 { # queue = queue [ 1 :] # } else { # queue = queue [ 0 :] # } # for i := 0 ; i < len ( edges [ now ]); i ++ { # if edges [ now ][ i ] && notExist ( i , queue ) { # queue = append ( queue , i ) # } # edges [ now ][ i ] = false # edges [ i ][ now ] = false # } # if route [ len ( route )- 1 ] == end { # return true # } # } # return false
idxMap = make ( map [ int ] int ) # preorderIdx = 0 # for i , v := range inorder { # idxMap [ v ] = i # } # return build ( 0 , len ( inorder ) - 1 , preorder )
current 3 ++ # return current 3 * ( current 3 + 1 ) / 2
if len ( lists ) == 0 { # return nil # } # begin , end := 0 , len ( lists )- 1 # for begin < end { # mid := ( begin + end - 1 ) / 2 # for i := 0 ; i <= mid ; i ++ { # lists [ i ] = mergeTwoLists ( lists [ i ], lists [ end - i ]) # } # end = ( begin + end ) / 2 # } # return lists [ 0 ]
arr := make ([] int , 1 0 0 0 0 0 0 ) # max , maxLoc , notFound , cur , steps := 0 , 0 , true , uint 6 4 ( 0 ), 0 # for i := 1 ; i < 1 0 0 0 0 0 0 ; i ++ { # notFound = true # cur = uint 6 4 ( i ) # steps = 0 # for notFound { # if cur == 1 { # notFound = false # arr [ i ] = steps # if steps > max { # max = steps # maxLoc = i # } # } else if cur < uint 6 4 ( i ) { # notFound = false # steps = steps + arr [ cur ] # arr [ i ] = steps # if steps > max { # max = steps # maxLoc = i # } # } else { # if cur % 2 == 0 { # cur /= 2 # } else { # cur = 3 * cur + 1 # } # } # steps ++ # } # } # println ( max , maxLoc )
if v == len ( g ) { # return true # } # for c := 1 ; c <= k ; c ++ { # if isSafe ( v , g , color , c ) { # color [ v ] = c # if CanColor ( v + 1 , g , color , k ) { # return true # } # color [ v ] = 0 # } # } # return false
if contiguousTimeouts > 8 { # contiguousTimeouts = 8 # } # d = 1 5 * time . Second # for ; contiguousTimeouts > 0 ; contiguousTimeouts -- { # d *= 2 # } # return
cases := [] struct { # name string # A , B [] int # expect [] int # }{ # {" STR ", [] int { 1 , 1 }, [] int { 2 , 2 }, [] int { 1 , 2 }}, # {" STR ", [] int { 1 , 2 }, [] int { 2 , 3 }, [] int { 1 , 2 }}, # {" STR ", [] int { 2 }, [] int { 1 , 3 }, [] int { 2 , 3 }}, # {" STR ", [] int { 1 , 2 , 5 }, [] int { 2 , 4 }, [] int { 5 , 4 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . A , c . B ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . A , c . B ) # } # }) # }
for i := 0 ; i < len ( slice ); i ++ { # if slice [ i ] == target { # return false # } # } # return true
return this . idx < len ( this . Raw )
return BSTIterator { # node : root , # }
l := len ( cost ) # t := make ([] int , l ) # t [ 0 ] = cost [ 0 ] # t [ 1 ] = cost [ 1 ] # for i := 2 ; i < l ; i ++ { # t [ i ] = mymin ( t [ i - 1 ]+ cost [ i ], t [ i - 2 ]+ cost [ i ]) # } # return mymin ( t [ l - 1 ], t [ l - 2 ])
words := strings . Split ( str , " STR ") # if len ( words ) != len ( pattern ) { # return false # } # m := make ( map [ byte ] string ) # seen := make ( map [ string ] struct {}) # for i := 0 ; i < len ( pattern ); i ++ { # c , s := pattern [ i ], words [ i ] # v , ok := m [ c ] # if ok { # if v != s { # return false # } # } else { # if _ , ok := seen [ s ]; ok { # return false # } # m [ c ] = s # seen [ s ] = struct {}{} # } # } # return true
if len ( s ) == 0 { # return 0 # } # dp := make ([] int , len ( s )+ 1 ) # dp [ 0 ] = 1 # for i := 1 ; i <= len ( s ); i ++ { # if s [ i - 1 ] > ' 0 ' { # dp [ i ] += dp [ i - 1 ] # } # if i > 1 && s [ i - 2 : i ] >= " STR " && s [ i - 2 : i ] <= " STR " { # dp [ i ] += dp [ i - 2 ] # } # } # return dp [ len ( s )]
var tests = [] struct { # list * ListNode # middle int # }{ # { newList ( 1 , 2 , 3 , 4 , 5 ), 3 }, # { newList ( 1 , 2 , 3 , 4 , 5 , 6 ), 4 }, # } # # for _ , tt := range tests { # middle := middleNode ( tt . list ) # if middle . Val != tt . middle { # t . Errorf (" STR ", tt . list , middle . Val , tt . middle ) # } # }
return arr [ sort . Search ( len ( arr )- k , func ( i int ) bool { return x - arr [ i ] <= arr [ i + k ]- x }):][: k ]
arr := randomSlice ( 0 , 2 0 , 1 0 ) # resultArr := make ([] int , 0 , 0 ) # bst := newBstRecrusive () # for _ , v := range arr { # bst . Insert ( uint 3 2 ( v )) # } # sort . Ints ( arr ) # bst . InOrderWalk ( bst . root , func ( tree binaryTreeIf , node interface {}) bool { # n := node .(* bstElement ) # resultArr = append ( resultArr , int ( n . Key )) # return false # }) # if ! reflect . DeepEqual ( resultArr , arr ) { # t . Log ( fmt . Sprintf (" STR ", arr ) + fmt . Sprintf (" STR ", resultArr )) # t . Fail () # }
result := make ([] string , 0 ) # if len ( s ) < 1 0 { # return result # } # # dict := make ( map [ string ] int ) # for i := 0 ; i < len ( s )- 9 ; i ++ { # sub := string ( s [ i : i + 1 0 ]) # if _ , exists := dict [ sub ]; ! exists { # dict [ sub ] = 1 # } else { # dict [ sub ]++ # } # } # # for k , v := range dict { # if v > 1 { # result = append ( result , k ) # } # } # # return result
ss := strings . Split ( S , " STR ") # # for i := range ss { # ss [ i ] = handleWord ( ss [ i ], i ) # } # # return strings . Join ( ss , " STR ")
var item * list . Element # var ok bool # if item , ok = m . mem [ id ]; ! ok { # if item = m . pq . Back (); item . Value .(* cacheItem ). dirty { # m . downStreamModel . write ( item . Value .(* cacheItem ). key , item . Value .(* cacheItem ). value ) # item . Value .(* cacheItem ). dirty = false # } # delete ( m . mem , item . Value .(* cacheItem ). key ) # m . mem [ id ] = item # item . Value .(* cacheItem ). key = id # } # m . pq . MoveToFront ( item ) # return item
ans := make ([] string , 0 ) # data := [] string {" STR ", " STR ", " STR "} # # for _ , v := range words { # word := strings . ToLower ( v ) # if ( strings . ContainsAny ( data [ 0 ], word ) && ! strings . ContainsAny ( data [ 1 ], word ) && ! strings . ContainsAny ( data [ 2 ], word )) || # (! strings . ContainsAny ( data [ 0 ], word ) && strings . ContainsAny ( data [ 1 ], word ) && ! strings . ContainsAny ( data [ 2 ], word )) || # (! strings . ContainsAny ( data [ 0 ], word ) && ! strings . ContainsAny ( data [ 1 ], word ) && strings . ContainsAny ( data [ 2 ], word )) { # ans = append ( ans , v ) # } # } # return ans
n := len ( s ) # dp := [][] bool {} # for i := 0 ; i < n ; i ++ { # dp = append ( dp , make ([] bool , n + 1 )) # } # # for i := 0 ; i < n ; i ++ { # dp [ i ][ i ] = true # if i == n - 1 { # break # } # dp [ i ][ i + 1 ] = s [ i ] == s [ i + 1 ] # } # # for i := n - 3 ; i >= 0 ; i -- { # for j := i + 2 ; j < n ; j ++ { # dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] && s [ i ] == s [ j ] # } # } # max := 0 # maxStr := "" # for i := 0 ; i < n ; i ++ { # for j := 0 ; j < n ; j ++ { # if dp [ i ][ j ] == true && j - i + 1 > max { # max = j - i + 1 # maxStr = s [ i : j + 1 ] # } # } # } # # return maxStr
row := make ([] int , 9 ) # col := make ([] int , 9 ) # block := make ([] int , 9 ) # # for i := 0 ; i < 9 ; i ++ { # for j := 0 ; j < 9 ; j ++ { # if board [ i ][ j ] == '.' { # continue # } # index := 1 << ( board [ i ][ j ] - ' 0 ') # if row [ i ]& index != 0 || col [ j ]& index != 0 || block [ i / 3 * 3 + j / 3 ]& index != 0 { # return false # } # row [ i ] |= index # col [ j ] |= index # block [ i / 3 * 3 + j / 3 ] |= index # } # } # return true
lowered := strings . ToLower ( s ) # # filtered := " STR " # # for i := 0 ; i < len ( lowered ); i ++ { # if lowered [ i ] >= ' a ' && lowered [ i ] <= ' z ' { # filtered += string ([] byte { lowered [ i ]}) # } # if lowered [ i ] >= ' 0 ' && lowered [ i ] <= ' 9 ' { # filtered += string ([] byte { lowered [ i ]}) # } # } # # for i := 0 ; i < len ( filtered )/ 2 ; i ++ { # if filtered [ i ] != filtered [ len ( filtered )- i - 1 ] { # return false # } # } # return true
minDiff , res := math . MaxInt 3 2 , [][] int {} # sort . Ints ( arr ) # for i := 1 ; i < len ( arr ); i ++ { # if arr [ i ]- arr [ i - 1 ] < minDiff { # minDiff = arr [ i ] - arr [ i - 1 ] # } # if minDiff == 1 { # break # } # } # for i := 1 ; i < len ( arr ); i ++ { # if arr [ i ]- arr [ i - 1 ] == minDiff { # res = append ( res , [] int { arr [ i - 1 ], arr [ i ]}) # } # } # return res
if len ( nums ) == 0 { # return nil # } else if len ( nums ) == 1 { # return nums # } # sort . Ints ( nums ) # var results [] int # last := nums [ 0 ] # count := 1 # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] != last && count == 1 { # results = append ( results , nums [ i - 1 ]) # last = nums [ i ] # count = 0 # } else if nums [ i ] != last { # last = nums [ i ] # count = 0 # } # count ++ # } # return results
if value <= 3 { # return value > 1 # } # if value % 2 == 0 || value % 3 == 0 { # return false # } # for i := 5 ; i * i <= value ; i += 6 { # if value % i == 0 || value %( i + 2 ) == 0 { # return false # } # } # return true
var res [] int # sort . Ints ( nums ) # sum := 0 # for _ , n := range nums { # sum += n # } # counter := 0 # i := len ( nums ) # half := sum / 2 # # for counter <= half { # i -- # counter += nums [ i ] # res = append ( res , nums [ i ]) # } # return res
if root == nil { # return nil # } # root . Left = removeLeafNodes ( root . Left , target ) # root . Right = removeLeafNodes ( root . Right , target ) # if root . Left == nil && root . Right == nil && root . Val == target { # return nil # } # return root
bt . bTree . init ( t , bt ) # return bt
dst := len ( graph ) - 1 # path := make ([] int , len ( graph )) # res := [][] int {} # var dfs func ( int , int ) # dfs = func ( id , level int ) { # if id == dst { # tmp := make ([] int , level ) # copy ( tmp , path ) # res = append ( res , tmp ) # } # for _ , node := range graph [ id ] { # path [ level ] = node # dfs ( node , level + 1 ) # } # } # dfs ( 0 , 1 ) # return res
return new ( lDComputor ). init ( word 0 , word 1 , delete , insert , kill )
tree := & TreeNode { # Val : 1 , # Left : & TreeNode { # Val : 2 , # }, # Right : & TreeNode { # Val : 3 , # }, # } # subtreeWithAllDeepest ( tree )
total := n * n # idx := 1 # ret := [][] int {} # # for i := 0 ; i < n ; i ++{ # tmp := make ([] int , n ) # ret = append ( ret , tmp ) # } # for i := 0 ; idx <= total ; i ++{ # for j := i ; idx <= total && j < n - i ; j ++{ # ret [ i ][ j ] = idx # idx ++ # } # for j := i + 1 ; idx <= total && j < n - i ; j ++{ # ret [ j ][ n - i - 1 ] = idx # idx ++ # } # for j := n - i - 2 ; idx <= idx && j >= i ; j --{ # ret [ n - i - 1 ][ j ] = idx # idx ++ # } # for j := n - i - 2 ; idx <= idx && j >= i + 1 ; j --{ # ret [ j ][ i ] = idx # idx ++ # } # } # return ret
return area ( A , B , C , D ) + area ( E , F , G , H ) - # area ( max ( A , E ), max ( B , F ), min ( C , G ), min ( D , H ))
sx , sy , n := - 1 , - 1 , 1 # for i := 0 ; i < len ( grid ); i ++ { # for j := 0 ; j < len ( grid [ 0 ]); j ++ { # if grid [ i ][ j ] == 0 { # n ++ # } else if grid [ i ][ j ] == 1 { # sx , sy = j , i # } # # } # } # return dfs ( grid , sx , sy , n ) #
fmt . Println ( fib ( 1 0 ))
i , j := 0 , len ( nums )- 1 # for i < j { # mid := ( i + j ) / 2 # if nums [ mid ] == nums [ j ] { # j -- # } else if nums [ mid ] > nums [ j ] { # i = mid + 1 # } else { # j = mid # } # } # return nums [ i ]
i , nl , j , tl := 0 , len ( name ), 0 , len ( typed ) # for i < nl || j < tl { # if i < nl && j < tl && name [ i ] == typed [ j ] { # i ++ # j ++ # } else if i >= 1 && j < tl && typed [ j ] == name [ i - 1 ] { # j ++ # } else { # return false # } # } # return true
if k == 0 || head == nil || head . Next == nil { # return head # } # # var ( # listSize int # count int # p = head # rotateNode = head # ) # # for p != nil && count < k { # p = p . Next # listSize ++ # count ++ # } # # if p == nil { # k = k % listSize # if k == 0 { # return head # } # p = head # for count = 0 ; count < k ; count ++ { # p = p . Next # } # } # # for p . Next != nil { # rotateNode = rotateNode . Next # p = p . Next # } # # p . Next = head # head = rotateNode . Next # rotateNode . Next = nil # return head
N := len ( M ) # res := N # # friend := make ([] int , res ) # for i := 0 ; i < res ; i ++ { # friend [ i ] = i # } # # union := func ( s , d int ) { # for i := range friend { # if friend [ i ] == s { # friend [ i ] = d # } # } # } # # for i := 0 ; i < N ; i ++ { # for j := i + 1 ; j < N ; j ++ { # if M [ i ][ j ] == 1 { # if friend [ i ] != friend [ j ] { # res -- # union ( friend [ i ], friend [ j ]) # } # } # } # } # # return res
return getFields ( s . value , s . TagName )
t . Parallel () # # for _ , tc := range testcases { # if res , err := PartitionIntoThreeEqualSum ( tc . input ); ! reflect . DeepEqual ( res , tc . expected ) || # tc . expectedErr != err { # t . Errorf (" STR ", tc . expected , tc . expectedErr , res , err ) # } # }
if isSame ( s , t ) { # return true # } # if s == nil { # return false # } # return isSubtree ( s . Left , t ) || isSubtree ( s . Right , t )
tests := [...] testType { # { # in : [] int { 1 , 1 , 4 , 2 , 1 , 3 }, # want : 3 , # }, # } # for _ , tt := range tests { # got := heightChecker ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
const ( # num = int 6 4 ( 2 ) # pow = int 6 4 ( 1 0 0 0 ) # ) # # res := new ( big . Int ). Exp ( big . NewInt ( num ), big . NewInt ( pow ), nil ) # sum := 0 # for _ , digit := range res . String () { # intDigit , err := strconv . Atoi ( string ( digit )) # if err != nil { # panic ( err ) # } # sum += intDigit # } # fmt . Println ( sum )
n := len ( board ) # rectSets := make ([] int 1 6 , n * n / 9 ) # for i := 0 ; i < n ; i ++ { # rowSet , colSet := int 1 6 ( 0 ), int 1 6 ( 0 ) # for j := 0 ; j < n ; j ++ { # if num := board [ i ][ j ]; num != '.' { # numBit := int 1 6 ( 1 << ( num - ' 0 ')) # if rowSet & numBit > 0 { # return false # } # rowSet |= numBit # # if rectSets [( n / 3 )*( i / 3 )+ j / 3 ]& numBit > 0 { # return false # } # rectSets [( n / 3 )*( i / 3 )+ j / 3 ] |= numBit # } # # if num := board [ j ][ i ]; num != '.' { # numBit := int 1 6 ( 1 << ( num - ' 0 ')) # if colSet & numBit > 0 { # return false # } # colSet ^= numBit # } # } # } # return true
l := len ( digits ) # for i := l - 1 ; i >= 0 ; i -- { # if digits [ i ] < 9 { # digits [ i ]++ # return digits # } # digits [ i ] = 0 # } # if digits [ 0 ] == 0 { # digits = append ([] int { 1 }, digits ...) # } # return digits
cases := [] struct { # name string # dict [] string # inputs string # expect bool # }{ # {" STR ", [] string {" STR ", " STR "}, " STR ", false }, # {" STR ", [] string {" STR ", " STR "}, " STR ", true }, # {" STR ", [] string {" STR ", " STR "}, " STR ", false }, # {" STR ", [] string {" STR ", " STR "}, " STR ", false }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # obj := Constructor () # obj . BuildDict ( c . dict ) # got := obj . Search ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . dict , c . inputs ) # } # }) # }
list := & ListNode {} # head := list # list . Val = nodes [ 0 ] # for i := 1 ; i < len ( nodes ); i ++ { # list . Next = & ListNode {} # list = list . Next # list . Val = nodes [ i ] # } # return head
var tests = [] struct { # num int # hex string # }{ # { 2 6 , " STR "}, # { 1 6 , " STR "}, # {- 1 , " STR "}, # { 0 , " STR "}, # } # # for _ , tt := range tests { # hex := toHex ( tt . num ) # if hex != tt . hex { # t . Errorf (" STR ", tt . num , hex , tt . hex ) # } # }
if len ( costs ) == 0 { # return 0 # } # # cost 0 , cost 1 , cost 2 := costs [ 0 ][ 0 ], costs [ 0 ][ 1 ], costs [ 0 ][ 2 ] # for i := 1 ; i < len ( costs ); i ++ { # newCost 0 := costs [ i ][ 0 ] + int ( math . Min ( float 6 4 ( cost 1 ), float 6 4 ( cost 2 ))) # newCost 1 := costs [ i ][ 1 ] + int ( math . Min ( float 6 4 ( cost 0 ), float 6 4 ( cost 2 ))) # newCost 2 := costs [ i ][ 2 ] + int ( math . Min ( float 6 4 ( cost 0 ), float 6 4 ( cost 1 ))) # # cost 0 , cost 1 , cost 2 = newCost 0 , newCost 1 , newCost 2 # } # # return int ( math . Min ( float 6 4 ( cost 0 ), math . Min ( float 6 4 ( cost 1 ), float 6 4 ( cost 2 ))))
flag . Parse () # fmt . Printf (" STR ", * period ) # time . Sleep (* period ) # fmt . Println ()
m := make ( map [ int ] int , len ( nums )) # sum 1 , sum 2 := 0 , 0 # for _ , v := range nums { # if _ , ok := m [ v ]; ! ok { # m [ v ]++ # sum 1 += v # } # sum 2 += v # } # return ( 3 * sum 1 - sum 2 ) / 2
cases := [] struct { # name string # input 1 string # input 2 int # expect string # }{ # {" STR ", " STR ", 3 , " STR "}, # {" STR ", " STR ", 4 , " STR "}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := convert ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . input 1 , c . input 2 ) # } # }) # }
r , err := FormatRequest ( Bytes { Start : 0 , End : - 1 }) # if err != nil { # panic ( err ) # } # fmt . Println ( r )
var w Wheel # w = Wheel { Circle { Point { 8 , 8 }, 5 }, 2 0 } # # w = Wheel { # Circle : Circle { # Point : Point { X : 8 , Y : 8 }, # Radius : 5 , # }, # Spokes : 2 0 , # } # # fmt . Printf (" STR ", w ) # # w . X = 4 2 # # fmt . Printf (" STR ", w )
if x == 1 { # return 1 # } # l , r := 0 , x # for { # mid := ( l + r ) / 2 # if mid == l { # return mid # } # sqr := mid * mid # if sqr > x { # r = mid # } # if sqr < x { # l = mid # } # if sqr == x { # return mid # } # }
c 1 , c 7 , c 3 0 := costs [ 0 ], costs [ 1 ], costs [ 2 ] # endDay := days [ len ( days )- 1 ] # # dp := [ 3 6 6 ] int {} # # for d , i := 1 , 0 ; d <= endDay ; d ++ { # if d == days [ i ] { # dp [ d ] = min ( dp [ d - 1 ]+ c 1 , dp [ max ( 0 , d - 7 )]+ c 7 , dp [ max ( 0 , d - 3 0 )]+ c 3 0 ) # i ++ # continue # } # dp [ d ] = dp [ d - 1 ] # } # # return dp [ endDay ]
if r . element . Dim == nil { # return - 1 # } # dim , err := strconv . ParseInt (* r . element . Dim , 0 , 3 2 ) # if err != nil { # panic ( err ) # } # return int ( dim )
var value , depth int # # var f func (* TreeNode , int ) # f = func ( root * TreeNode , d int ) { # if root == nil { # return # } # if root . Left == nil && root . Right == nil && d > depth { # depth = d # value = root . Val # } # # f ( root . Left , d + 1 ) # f ( root . Right , d + 1 ) # } # f ( root , 1 ) # # return value
t . Parallel () # delta := 0 . 0 1 # for _ , tc := range testcases { # rm := NewRunningMedian () # var mismatch bool # results := make ([] int , 0 , len ( tc . input )) # for i , v := range tc . input { # result := rm . Median ( v ) # if lower , upper := result - delta , result + delta ; tc . expected [ i ] > upper || tc . expected [ i ] < lower { # mismatch = true # results = append ( results , v ) # } # } # if mismatch { # t . Errorf (" STR ", tc . expected , results ) # } # }
if triangle == nil { # return 0 # } # for row := len ( triangle ) - 2 ; row >= 0 ; row -- { # for col := 0 ; col < len ( triangle [ row ]); col ++ { # triangle [ row ][ col ] += min ( triangle [ row + 1 ][ col ], triangle [ row + 1 ][ col + 1 ]) # } # } # return triangle [ 0 ][ 0 ]
maps := make ( map [ int ] int ) # for i := 0 ; i < len ( A ); i ++ { # for j := 0 ; j < len ( B ); j ++ { # maps [ A [ i ]+ B [ j ]]++ # } # } # ret := 0 # for i := 0 ; i < len ( C ); i ++ { # for j := 0 ; j < len ( D ); j ++ { # ret += maps [- 1 *( C [ i ]+ D [ j ])] # } # } # return ret
for d := 1 1 ; d < 9 9 ; d ++ { # for n := 1 0 ; n < d ; n ++ { # decimal := float 6 4 ( n ) / float 6 4 ( d ) # # nTens , nOnes := n / 1 0 , n % 1 0 # dTens , dOnes := d / 1 0 , d % 1 0 # # if nOnes == dTens { # reduced := float 6 4 ( nTens ) / float 6 4 ( dOnes ) # if decimal == reduced { # fmt . Printf (" STR ", n , d , nTens , dOnes ) # } # } # } # }
if n <= 2 { # return n # } # n 1 , n 2 := 1 , 2 # for i := 3 ; i <= n ; i ++ { # n 2 , n 1 = n 1 + n 2 , n 2 # } # return n 2
qs := [] question 1 4 5 5 { # # { # para 1 4 5 5 {" STR ", " STR "}, # ans 1 4 5 5 { 4 }, # }, # # { # para 1 4 5 5 {" STR ", " STR "}, # ans 1 4 5 5 { 2 }, # }, # # { # para 1 4 5 5 {" STR ", " STR "}, # ans 1 4 5 5 {- 1 }, # }, # # { # para 1 4 5 5 {" STR ", " STR "}, # ans 1 4 5 5 { 4 }, # }, # # { # para 1 4 5 5 {" STR ", " STR "}, # ans 1 4 5 5 {- 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 4 5 5 , q . para 1 4 5 5 # fmt . Printf (" STR ", p ) # fmt . Printf (" STR ", isPrefixOfWord ( p . sentence , p . searchWord )) # } # fmt . Printf (" STR ")
t . Parallel () # b := NewLRUCache ( 3 ) # # b . Set (" STR ", " STR ", time . Time {}) # # c := * b # r := rec ( func () { # c . Del (" STR ") # }) # if r != 1 { # t . Error (" STR ") # } # # b . Del (" STR ") # # r = rec ( func () { # c . Set (" STR ", " STR ", time . Time {}) # }) # if r != 1 { # t . Error (" STR ") # }
n := len ( s ) # if n < 4 || n > 1 2 { # return [] string {} # } # # res := [] string {} # combination := make ([] string , 4 ) # # var dfs func ( int , int ) # dfs = func ( idx , begin int ) { # if idx == 3 { # temp := s [ begin :] # if isOK ( temp ) { # combination [ 3 ] = temp # res = append ( res , IP ( combination )) # } # return # } # # maxRemain := 3 * ( 3 - idx ) # # for end := begin + 1 ; end <= n -( 3 - idx ); end ++ { # if end + maxRemain < n { # continue # } # # if end - begin > 3 { # break # } # # temp := s [ begin : end ] # if isOK ( temp ) { # combination [ idx ] = temp # dfs ( idx + 1 , end ) # } # } # } # # dfs ( 0 , 0 ) # # return res
res := []* TreeNode {} # for i := 0 ; i < len ( input ); i ++ { # if input [ i ]. Left != nil { # res = append ( res , input [ i ]. Left ) # } # if input [ i ]. Right != nil { # res = append ( res , input [ i ]. Right ) # } # } # return res
if nums == nil { # return [] int {- 1 , - 1 } # } # l , r := 0 , len ( nums )- 1 # for nums [ l ] < nums [ r ] { # m := ( l + r ) / 2 # if nums [ m ] < target { # l = m + 1 # } else if nums [ m ] > target { # r = m - 1 # } else { # if nums [ l ] == nums [ m ] { # r -- # } else { # l ++ # } # } # } # if nums [ l ] == nums [ r ] && nums [ l ] == target { # return [] int { l , r } # } # return [] int {- 1 , - 1 }
t . Parallel () # for _ , tc := range testcases { # if result := MaximumNonAdjacentSum ( tc . input ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
cases := [] struct { # name string # inputs [][] int # expect [][] int # }{ # {" STR ", [][] int {{ 2 , 3 , 4 }, { 5 , 6 , 7 }, { 8 , 9 , 1 0 }, { 1 1 , 1 2 , 1 3 }, { 1 4 , 1 5 , 1 6 }}, [][] int {{ 4 , 4 , 5 }, { 5 , 6 , 6 }, { 8 , 9 , 9 }, { 1 1 , 1 2 , 1 2 }, { 1 3 , 1 3 , 1 4 }}}, # {" STR ", [][] int {{ 1 , 1 , 1 }, { 1 , 0 , 1 }, { 1 , 1 , 1 }}, [][] int {{ 0 , 0 , 0 }, { 0 , 0 , 0 }, { 0 , 0 , 0 }}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
n := len ( A ) # f := newForest ( n ) # for i := 0 ; i < n ; i ++ { # for j := 0 ; j < i ; j ++ { # if similar ( A [ i ], A [ j ]) { # f . union ( i , j ) # } # } # } # res := 0 # for i := 0 ; i < n ; i ++ { # if f . parent [ i ] == i { # res ++ # } # } # return res
var tests = [] struct { # num int # digit int # }{ # { 1 7 , 8 }, # { 3 8 , 2 }, # { 1 5 8 3 , 8 }, # { 6 5 5 3 6 , 7 }, # } # # for _ , tt := range tests { # digit := addDigits ( tt . num ) # if digit != tt . digit { # t . Errorf (" STR ", tt . num , digit , tt . digit ) # } # }
t . Parallel () # for tcid , tc := range testcases { # if result := IsToeplitzMatrix ( tc . mat ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result , tcid ) # } # }
h := newLinkedHeap () # testHeap ( t , h )
indexs := [ 2 6 ] int {} # for i := 0 ; i < len ( order ); i ++ { # indexs [ order [ i ]-' a '] = i # } # # compare := func ( s 1 , s 2 string ) int { # m , n , cmp := len ( s 1 ), len ( s 2 ), 0 # for i := 0 ; i < n && i < m && cmp == 0 ; i ++ { # cmp = indexs [ s 1 [ i ]-' a '] - indexs [ s 2 [ i ]-' a '] # } # if cmp == 0 { # return m - n # } # return cmp # } # # for i := 1 ; i < len ( words ); i ++ { # if compare ( words [ i - 1 ], words [ i ]) > 0 { # return false # } # } # return true
return hm . table [ hash ]
s := 0 # l := len ( numbers ) - 1 # for s < l { # r := numbers [ s ] + numbers [ l ] # if r == target { # return [] int { s + 1 , l + 1 } # } else if r < target { # s ++ # } else { # l -- # } # } # return nil
var s Solution # s . head = head # return s
size := len ( p ) # # dp := [ 5 0 1 ][ 5 0 1 ] int {} # for i := 0 ; i < size ; i ++ { # dp [ i ][ i ] = p [ i ] # } # # for d := 1 ; d < size ; d ++ { # for i := 0 ; i < size - d ; i ++ { # dp [ i ][ i + d ] = max ( p [ i ]- dp [ i + 1 ][ i + d ], p [ i + d ]- dp [ i ][ i + d - 1 ]) # } # } # # return dp [ 0 ][ size - 1 ] > 0
minM , minN := m , n # for _ , op := range ops { # minM = min ( minM , op [ 0 ]) # minN = min ( minN , op [ 1 ]) # } # return minM * minN
n , dn , cnt := 3 , 2 , 0 # primearray := PrimesBelow ( 1 0 0 0 0 0 0 ) # for cnt <= 5 0 0 { # n ++ # n 1 := n # if n 1 % 2 == 0 { # n 1 /= 2 # } # dn 1 := 1 # for i := 0 ; i < len ( primearray ); i ++ { # if primearray [ i ]* primearray [ i ] > n 1 { # dn 1 *= 2 # break # } # exponent := 1 # for n 1 % primearray [ i ] == 0 { # exponent ++ # n 1 /= primearray [ i ] # } # if exponent > 1 { # dn 1 *= exponent # } # if n 1 == 1 { # break # } # } # cnt = dn * dn 1 # dn = dn 1 # } # return n * ( n - 1 ) / 2
fmt . Println ( generate ( 0 ))
field , ok := f . FieldOk ( name ) # if ! ok { # panic (" STR ") # } # # return field
var tests = [] struct { # s string # length int # }{ # {" STR ", 3 }, # {" STR ", 1 }, # {" STR ", 3 }, # } # # for _ , tt := range tests { # length := lengthOfLongestSubstring ( tt . s ) # if length != tt . length { # t . Errorf (" STR ", tt . s , length , tt . length ) # } # }
fmt . Println ( Add ( 9 , 1 1 ))
return LRUCache { # l : list . New (), # m : make ( map [ int ]* list . Element ), # c : capacity , # }
StoreUint 1 6 (& r . Reg , value )
t . Parallel () # for _ , tc := range testcases { # if result := IsTreeSymmetric ( tc . root ); result != tc . symmetric { # t . Errorf (" STR ", tc . symmetric , result ) # } # }
lp := genCnter ( licensePlate ) # var ret string # for _ , w := range words { # if match ( lp , w ) { # if len ( w ) < len ( ret ) || ret == " STR " { # ret = w # } # } # } # return ret
return isHappyInner ( n , nil )
var oneLen , twoLen int # for e := one ; e != nil ; e = e . Next { # oneLen ++ # } # for e := two ; e != nil ; e = e . Next { # twoLen ++ # } # var longer , shorter * Node # var diff int # if oneLen > twoLen { # longer = one # shorter = two # diff = oneLen - twoLen # } else { # longer = two # shorter = one # diff = twoLen - oneLen # } # for i := 0 ; i < diff ; i ++ { # longer = longer . Next # } # for longer != nil { # if longer == shorter { # return longer # } # longer = longer . Next # shorter = shorter . Next # } # return nil
if len ( nums ) == 0 { # return 0 # } # if len ( nums ) == 1 { # return nums [ 0 ] # } # # size := int ( 1 e 4 + 1 ) # dp := make ([] int , size ) # for _ , n := range nums { # dp [ n ] += n # } # # for i := 2 ; i < size ; i ++ { # dp [ i ] = max ( dp [ i - 1 ], dp [ i ]+ dp [ i - 2 ]) # } # # return dp [ size - 1 ]
f ( 3 )
q . IDs [ q . Root ( r )] = q . Root ( p )
p . pendingBytes = append ( p . pendingBytes , b )
if s == " STR " { # return 0 # } # for i , j := 0 , len ( s )- 1 ; i < j ; i , j = i + 1 , j - 1 { # if s [ i ] != s [ j ] { # return 2 # } # } # return 1
t . Parallel () # # for _ , tc := range testcases { # if result := ClosestLargerNumberIndexBrute ( tc . nums , tc . targetIndex ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
n := x ^ y # ans := 0 # for n != 0 { # n &= n - 1 # ans ++ # } # return ans
return l . Length == 0
count , digits := 9 , 1 # num := 1 # for n - count * digits > 0 { # n -= count * digits # count *= 1 0 # digits ++ # num *= 1 0 # } # # index := n % digits # if index == 0 { # index = digits # } # num += n / digits # if index == digits { # num -- # } # # for i := index ; i < digits ; i ++ { # num /= 1 0 # } # return num % 1 0
type Base struct { # ID int # } # # type User struct { # Base # Name string # } # # u := User {} # s := New (& u ) # f := s . Field (" STR "). Field (" STR ") # err := f . Set ( 1 0 ) # if err != nil { # t . Errorf (" STR ", err ) # } # if f . Value ().( int ) != 1 0 { # t . Errorf (" STR ", f . Value ()) # }
for i := m + n - 1 ; m > 0 && n > 0 && i >= 0 ; i -- { # if nums 1 [ m - 1 ] > nums 2 [ n - 1 ] { # nums 1 [ i ] = nums 1 [ m - 1 ] # m -- # } else { # nums 1 [ i ] = nums 2 [ n - 1 ] # n -- # } # } # if m == 0 { # for ; n > 0 ; n -- { # nums 1 [ n - 1 ] = nums 2 [ n - 1 ] # } # } # return
results := make ( map [ int ] int ) # for i := 0 ; i < maxp ; i ++ { # results [ i ] = 0 # } # for p := 0 ; p < maxp ; p ++ { # for x := 0 ; x < p ; x ++ { # y := x # z := p - x - y # for y <= z { # if math . Pow ( float 6 4 ( x ), 2 )+ math . Pow ( float 6 4 ( y ), 2 ) == math . Pow ( float 6 4 ( z ), 2 ) { # results [ p ]++ # } # y ++ # z -- # } # } # } # bestp := 0 # bestCount := 0 # for i := 0 ; i < maxp ; i ++ { # if results [ i ] >= bestCount { # bestCount = results [ i ] # bestp = i # } # } # return bestp
f . Write ([] byte ( h . HexString ()))
m := len ( matrix ) # if m == 0 { # return false # } # n := len ( matrix [ 0 ]) # if n == 0 { # return false # } # if matrix [ m - 1 ][ 0 ] == target { # return true # } # for i , j := 0 , n - 1 ; i <= m - 1 && j >= 0 ;{ # if target == matrix [ i ][ j ]{ # return true # } # if matrix [ i ][ j ] < target { # i ++ # } else { # j -- # } # } # return false
n := len ( nums ) # vector := make ([] int , n ) # taken := make ([] bool , n ) # # var ans [][] int # # makePermutation ( 0 , n , nums , vector , taken , & ans ) # # return ans
cases := [] struct { # name string # inputs [] string # expect bool # }{ # {" STR ", [] string { # " STR ", " STR ", " STR ", # }, true }, # {" STR ", [] string { # " STR ", " STR ", " STR ", # }, false }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := isInterleave ( c . inputs [ 0 ], c . inputs [ 1 ], c . inputs [ 2 ]) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
value := self . slots [ self . top - 1 ] # return value
if self . size == 0 { # panic (" STR ") # } # return self . top
return len ( stackArray )
for left >= 0 && right < len ( str ) { # if str [ left ] != str [ right ] { # break # } # left -- # right ++ # } # return str [ left + 1 : right ]
h := intHeap ( nums ) # heap . Init (& h ) # # for len ( h ) > k { # heap . Pop (& h ) # } # # return KthLargest { # k : k , # heap : h , # }
if rowIndex < 0 { # return nil # } # # vi := make ([] int , rowIndex + 1 ) # vi [ 0 ] = 1 # for i := 0 ; i <= rowIndex ; i ++ { # for j := i ; j > 0 ; j -- { # vi [ j ] = vi [ j ] + vi [ j - 1 ] # } # } # return vi
number , err := strconv . ParseFloat ( os . Args [ 1 ], 6 4 ) # if err != nil { # log . Fatalln ( err ) # } # # fmt . Println (" STR ") # fmt . Println (" STR ") # fmt . Println (" STR ") # fmt . Println (" STR ") # # fmt . Printf (" STR ", number ) # fmt . Printf (" STR ", number * miTokm ) # # fmt . Println (" STR ") # fmt . Println (" STR ")
deleteNonCompletedNode := func ( node * bstElement ) { # var reConnectedNode * bstElement # if node . left == nil { # reConnectedNode = node . right # } else { # reConnectedNode = node . left # } # if reConnectedNode != nil { # reConnectedNode . parent = node . parent # } # if node . parent == nil { # t . root = reConnectedNode # } else if node . parent . right == node { # node . parent . right = reConnectedNode # } else { # node . parent . left = reConnectedNode # } # node = nil # } # node := t . Search ( key ).(* bstElement ) # if node == nil { # return node # } # if node . left == nil || node . right == nil { # deleteNonCompletedNode ( node ) # } else { # successor := t . Successor ( node , t . Root ()).(* bstElement ) # _key , _value := successor . Key , successor . Value # deleteNonCompletedNode ( successor ) # node . Key , node . Value = _key , _value # } # return node
n := len ( s ) # res := [] string {} # var dfs func ( int , int , string ) # dfs = func ( start , step int , ip string ) { # if start == n && step == 4 { # res = append ( res , ip [: len ( ip )- 1 ]) # return # } # if n - start > ( 4 - step )* 3 || n - start < 4 - step { # return # } # num := 0 # for i := start ; i < start + 3 && i < n ; i ++ { # num = num * 1 0 + int ( s [ i ]-' 0 ') # if num < 2 5 6 { # ip += s [ i : i + 1 ] # dfs ( i + 1 , step + 1 , ip +" STR ") # } # if num == 0 { # break # } # } # } # dfs ( 0 , 0 , " STR ") # return res
cases := [] struct { # name string # inputs string # expect int # }{ # {" STR ", " STR ", 2 }, # {" STR ", " STR ", 3 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := numDecodings ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
words := readWordsFile (" STR ") # count := 0 # for _ , word := range words { # if isTriangleWord ( word ) { # count ++ # } # } # fmt . Println (" STR ", count )
words := strings . Fields ( s ) # # i := 0 # j := len ( words ) - 1 # # for i < j { # words [ i ], words [ j ] = words [ j ], words [ i ] # i ++ # j -- # } # # return strings . Join ( words , " STR ")
var neg bool # if x >= 0 { # neg = true # } else { # x *= - 1 # } # var y int # for x > 0 { # y = y * 1 0 + x % 1 0 # x = x / 1 0 # if y > 2 1 4 7 4 8 3 6 4 7 { # return 0 # } # } # if neg == false { # y *= - 1 # } # return y
v := cmplx . Sqrt ( z ) # blue := uint 8 ( real ( v )* 1 2 8 ) + 1 2 7 # red := uint 8 ( imag ( v )* 1 2 8 ) + 1 2 7 # return color . YCbCr { 1 2 8 , blue , red }
return MagicDictionary { rdict : make ( map [ int ] string )}
tests := [...] testType { # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := removeDuplicates ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
arr := randomSlice ( 0 , 2 0 , 1 0 ) # nodeCnt := 0 # gbt := newGBT () # for _ , v := range arr { # gbt . Insert ( uint 3 2 ( v )) # } # delNum := getRand (). Intn ( 1 0 ) + 1 # if * debug { # fmt . Println ( delNum ) # } # for i := 0 ; i < delNum ; i ++ { # gbt . Delete ( uint 3 2 ( arr [ i ])) # } # gbt . InOrderWalk ( gbt . Root (), checkGBT ( t , & nodeCnt , * debug )) # if nodeCnt != len ( arr )- delNum { # t . Log ( fmt . Sprintf (" STR ", len ( arr )- delNum , nodeCnt )) # t . Fail () # } #
if t == u .( rawType ) { # return true # } # if u . Kind () == Interface { # panic (" STR ") # } # return false
if len ( prices ) < 1 { # return 0 # } # # maxProfit := 0 # minPrice := prices [ 0 ] # for i := 1 ; i < len ( prices ); i ++ { # if prices [ i ] < minPrice { # minPrice = prices [ i ] # continue # } # # current := prices [ i ] - minPrice # # if current > maxProfit { # maxProfit = current # } # } # return maxProfit
db := database {" STR ": 5 0 , " STR ": 5 } # mux := http . NewServeMux () # mux . HandleFunc (" STR ", db . list ) # mux . HandleFunc (" STR ", db . price ) # log . Fatal ( http . ListenAndServe (" STR ", mux ))
var chars = [] byte (" STR ") # # length , err := rand . Int ( rand . Reader , big . NewInt ( int 6 4 ( maxLength - minLength ))) # if err != nil { # panic ( err ) # } # length . Add ( length , big . NewInt ( int 6 4 ( minLength ))) # # intLength := int ( length . Int 6 4 ()) # # newPassword := make ([] byte , intLength ) # randomData := make ([] byte , intLength + intLength / 4 ) # clen := byte ( len ( chars )) # maxrb := byte ( 2 5 6 - ( 2 5 6 % len ( chars ))) # i := 0 # for { # if _ , err := io . ReadFull ( rand . Reader , randomData ); err != nil { # panic ( err ) # } # for _ , c := range randomData { # if c >= maxrb { # continue # } # newPassword [ i ] = chars [ c % clen ] # i ++ # if i == intLength { # return string ( newPassword ) # } # } # }
s 1 := " STR " # s 2 := " STR " # s 3 := " STR " # isInterleave ( s 1 , s 2 , s 3 ) # isInterleave 2 ( s 1 , s 2 , s 3 ) #
in , out := 1 0 0 0 , 3 1 8 7 5 0 0 0 # if x := p 9 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # }
c := Constructor ( 2 ) # c . Put ( 1 , 1 ) # c . Put ( 2 , 2 ) # fmt . Println ( c . Get ( 1 )) # c . Put ( 3 , 3 ) # fmt . Println ( c . Get ( 2 )) # fmt . Println ( c . Get ( 3 )) # c . Put ( 4 , 4 ) # fmt . Println ( c . Get ( 1 )) # fmt . Println ( c . Get ( 3 )) # fmt . Println ( c . Get ( 4 ))
t . Parallel () # root := & BinaryTree { value : 0 , # left : & BinaryTree { value : 1 }, # right : & BinaryTree { value : 0 , # left : & BinaryTree { value : 1 , # left : & BinaryTree { value : 1 }, # right : & BinaryTree { value : 1 }}, # right : & BinaryTree { value : 0 }}} # if count := CountUnivalSubtrees ( root ); count != 5 { # t . Errorf (" STR ", 5 , count ) # } # root = & BinaryTree { value : 0 , # left : & BinaryTree { value : 1 }, # right : & BinaryTree { value : 0 , # left : & BinaryTree { value : 0 }, # right : & BinaryTree { value : 1 , # left : & BinaryTree { value : 1 }, # right : & BinaryTree { value : 1 }}}} # if count := CountUnivalSubtrees ( root ); count != 5 { # t . Errorf (" STR ", 5 , count ) # }
return AllOne { # m : make ( map [ string ]* list . Element ), # l : list . New (), # }
defer wg . Done () # for v := range in { # fmt . Printf (" STR ", v . input , v . value ) # }
return syscall . Fdatasync ( int ( fd ))
fields := s . structFields () # # for _ , field := range fields { # val := s . value . FieldByName ( field . Name ) # # _ , tagOpts := parseTag ( field . Tag . Get ( s . TagName )) # # if IsStruct ( val . Interface ()) && ! tagOpts . Has (" STR ") { # ok := HasZero ( val . Interface ()) # if ok { # return true # } # # continue # } # # zero := reflect . Zero ( val . Type ()). Interface () # # current := val . Interface () # # if reflect . DeepEqual ( current , zero ) { # return true # } # } # # return false
digits := [] int { 3 , 1 , 4 , 1 , 5 , 9 } # expected := int 6 4 ( 3 1 4 1 5 9 ) # actual := ToInteger ( digits ) # # if expected != actual { # t . Errorf (" STR ", expected , actual ) # }
var T = struct { # A string # B int # C bool # }{ # A : " STR ", # B : 2 , # C : true , # } # # s := Fields ( T ) # # if len ( s ) != 3 { # t . Errorf (" STR ", len ( s )) # } # # inSlice := func ( val string ) bool { # for _ , v := range s { # if reflect . DeepEqual ( v . Name (), val ) { # return true # } # } # return false # } # # for _ , val := range [] string {" STR ", " STR ", " STR "} { # if ! inSlice ( val ) { # t . Errorf (" STR ", val ) # } # }
var nums [] int # var target int # var ret int # # nums = [] int { 1 , 3 } # target = 2 # ret = 1 # if ret != searchInsert ( nums , target ) { # t . Fatalf (" STR ", ret ) # } # # nums = [] int { 1 , 3 , 5 , 6 } # target = 5 # ret = 2 # if ret != searchInsert ( nums , target ) { # t . Fatalf (" STR ", ret ) # } # # nums = [] int { 1 , 3 , 5 , 6 } # target = 2 # ret = 1 # if ret != searchInsert ( nums , target ) { # t . Fatalf (" STR ", ret ) # } # # nums = [] int { 1 , 3 , 5 , 6 } # target = 7 # ret = 4 # if ret != searchInsert ( nums , target ) { # t . Fatalf (" STR ", ret ) # } # # nums = [] int { 1 , 3 , 5 , 6 } # target = 0 # ret = 0 # if ret != searchInsert ( nums , target ) { # t . Fatalf (" STR ", ret ) # }
low , high := 0 , len ( nums )- 1 # for low <= high { # mid := low + ( high - low )/ 2 # if nums [ mid ] > target { # high = mid - 1 # continue # } # if nums [ mid ] < target { # low = mid + 1 # continue # } # if nums [ mid ] == target { # return mid # } # } # return - 1
var tests = [] struct { # list * ListNode # palindrome bool # }{ # { newList ( 1 , 2 ), false }, # { newList ( 1 , 2 , 2 , 1 ), true }, # { newList ( 1 , 2 , 3 , 2 , 1 ), true }, # } # # for _ , tt := range tests { # palindrome := isPalindrome ( tt . list ) # if palindrome != tt . palindrome { # t . Errorf (" STR ", tt . list , palindrome , tt . palindrome ) # } # }
flags := os . O_WRONLY | os . O_CREATE | os . O_TRUNC # file , err := os . OpenFile ( archive , flags , 0 6 4 4 ) # if err != nil { # return err # } # defer file . Close () # tw := tar . NewWriter ( file ) # defer tw . Close () # for _ , filename := range files { # if err := addToArchive ( filename , tw ); err != nil { # return err # } # } # return nil
if len ( nums ) == 0 { # return nil # } # root := new ( TreeNode ) # root . Val = nums [ 0 ] # ch := make ( chan * TreeNode , len ( nums )) # ch <- root # nums = nums [ 1 :] # for i := 0 ; i < len ( nums ); i ++{ # tree := <- ch # if nums [ i ] == - 1 { # tree . Left = nil # } else { # tree . Left = & TreeNode { # Val : nums [ i ], # } # ch <- tree . Left # } # i ++ # if i == len ( nums )|| nums [ i ] == - 1 { # tree . Right = nil # } else { # tree . Right = & TreeNode { # Val : nums [ i ], # } # ch <- tree . Right # } # } # return root
if tree == nil { # return # } # minSum = int (^ uint ( 0 ) >> 1 ) # minLevel = minSum # current := make ([]* BinaryTree , 0 , 1 ) # current = append ( current , tree ) # level := 1 # for len ( current ) != 0 { # nextLevel := make ([]* BinaryTree , 0 , 2 * cap ( current )) # var sum int # for _ , ptr := range current { # sum += ptr . Value # if ptr . Left != nil { # nextLevel = append ( nextLevel , ptr . Left ) # } # if ptr . Right != nil { # nextLevel = append ( nextLevel , ptr . Right ) # } # } # if sum < minSum { # minSum = sum # minLevel = level # } # level ++ # current = nextLevel # } # return
if n == nil { # return " STR " # } # return n . Names [ 0 ]
res , j := make ([] int , len ( T )), 0 # for i := 0 ; i < len ( T ); i ++ { # for j = i + 1 ; j < len ( T ); j ++ { # if T [ j ] > T [ i ] { # res [ i ] = j - i # break # } # } # } # return res
n := big . NewInt ( 1 ) # # two := big . NewInt ( 2 ) # # for i := 0 ; i < 1 0 0 0 ; i ++ { # n . Mul ( n , two ) # } # # chrToInt := func ( chr rune ) int { # return int ( uint 8 ( chr ) - ' 0 ') # } # # sum := 0 # # for _ , chr := range n . String () { # sum += chrToInt ( chr ) # } # # fmt . Println ( sum )
i := 0 # # for j := 0 ; j < len ( nums ); j ++ { # if nums [ j ]& 1 == 1 { # tmp := nums [ j ] # for k := j - 1 ; k >= i ; k -- { # nums [ k + 1 ] = nums [ k ] # } # nums [ i ] = tmp # i += 1 # } # } # return nums
n := len ( S ) # if n == 0 { # return 0 # } # countOne := 0 # res := 0 # for i := 0 ; i < n ; i ++ { # if S [ i ] == ' 0 ' { # if countOne == 0 { # continue # } else { # res ++ # } # } else { # countOne ++ # } # if res > countOne { # res = countOne # } # } # return res
tests := [...] testType { # { # in : 0 , # want : 5 , # }, # { # in : 5 , # want : 0 , # }, # { # in : 1 7 , # want : 0 , # }, # { # in : 1 1 , # want : 0 , # }, # } # for _ , tt := range tests { # got := preimageSizeFZF ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
val := root . Val # queue := make ([]* TreeNode , 0 ) # queue = append ( queue , root ) # for len ( queue ) > 0 { # node := queue [ 0 ] # queue = queue [ 1 :] # if val != node . Val { # return false # } # # if node . Left != nil { # queue = append ( queue , node . Left ) # } # # if node . Right != nil { # queue = append ( queue , node . Right ) # } # } # # return true
if n == 1 { # return 1 # } # first , second := 1 , 2 # for i := 3 ; i <= n ; i ++ { # first , second = second , first + second # } # return second
n := NewNode ( val ) # n . Next = ll . Head # ll . Head = n # ll . length ++
tests := [...] testType { # { # in : [] int { 1 , 1 , 0 , 1 , 1 , 1 }, # want : 3 , # }, # { # in : [] int { 1 , 0 , 1 , 1 , 0 , 1 }, # want : 2 , # }, # } # for _ , tt := range tests { # got := findMaxConsecutiveOnes ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
ls , lp := len ( s ), len ( p ) # # dp := [][] bool {} # for i := 0 ; i < ls + 1 ; i ++ { # rt := make ([] bool , lp + 1 ) # dp = append ( dp , rt ) # } # dp [ 0 ][ 0 ] = true # # for j := 1 ; j <= lp ; j ++ { # if p [ j - 1 ] == '*' { # dp [ 0 ][ j ] = dp [ 0 ][ j - 1 ] # } # } # # for i := 1 ; i <= ls ; i ++ { # for j := 1 ; j <= lp ; j ++ { # if p [ j - 1 ] != '*' { # dp [ i ][ j ] = ( p [ j - 1 ] == s [ i - 1 ] || p [ j - 1 ] == '?') && dp [ i - 1 ][ j - 1 ] # } else { # dp [ i ][ j ] = dp [ i - 1 ][ j ] || dp [ i ][ j - 1 ] # } # } # } # return dp [ ls ][ lp ]
max := arr [ 0 ] # for _ , v := range arr { # if v > max { # max = v # } # } # return max
s := New () # # if ! s . isEmpty () || # s . len != 0 || # s . Len () != 0 { # t . Error () # } # # s . Push ( 1 ) # s . Push ( 2 ) # s . Push ( 3 ) # # if s . stack [ 0 ] != 3 || # s . stack [ 1 ] != 2 || # s . stack [ 2 ] != 1 { # fmt . Println ( s . stack ) # t . Error () # } # # if s . Len () != 3 { # t . Error () # } # # a := s . Pop () # # if a != 3 || s . Len () != 2 { # t . Error () # } # # b := s . Peek () # # if b != 2 { # t . Error () # }
if len ( prices ) == 0 { # return 0 # } # max , n 0 := 0 , prices [ 0 ] # for _ , n := range prices [ 1 :] { # if n > n 0 { # if max < n - n 0 { # max = n - n 0 # } # } else { # n 0 = n # } # } # return max
l := & ListNode { Next : head } # for prev := l ; head != nil ; { # if head . Next != nil && head . Val == head . Next . Val { # for val := head . Val ; head != nil && head . Val == val ; { # dup := head # head = head . Next # dup . Next = nil # } # prev . Next = head # } else { # prev = head # head = head . Next # } # } # return l . Next
return e . Update ( value , time . Now ())
for { # t := <- input [ 0 ] # if t == nil { # * result = append (* result , t ) # } else { # temp := * t # * result = append (* result , & temp ) # } # input [ 1 ] <- nil # }
kR , kC := findBlackKing ( board ) # # for r := range board { # for c := range board [ r ] { # switch board [ r ][ c ] { # case ' B ': # if bishop ( board , r , c , kR , kC ) { # return true # } # case ' N ': # if knight ( board , r , c , kR , kC ) { # return true # } # case ' P ': # if pawn ( board , r , c , kR , kC ) { # return true # } # case ' R ': # if rook ( board , r , c , kR , kC ) { # return true # } # case ' Q ': # if queen ( board , r , c , kR , kC ) { # return true # } # } # } # } # # return false
cases := [] struct { # name string # inputs [] int # expect bool # }{ # {" STR ", [] int { 0 }, true }, # {" STR ", [] int { 1 , 0 , 0 }, true }, # {" STR ", [] int { 1 , 1 , 1 , 0 }, false }, # {" STR ", [] int { 0 , 1 , 1 , 0 }, true }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
isJewel := make ( map [ byte ] bool , len ( J )) # for i := range J { # isJewel [ J [ i ]] = true # } # # res := 0 # for i := range S { # if isJewel [ S [ i ]] { # res ++ # } # } # # return res
str := " STR " # return permutation (" STR ", str )
m := make ( map [ int ] struct {}, len ( nums )) # for _ , n := range nums { # if _ , ok := m [ n ]; ok { # return true # } else { # m [ n ] = struct {}{} # } # } # return false
i , j := len ( A )- 1 , len ( B )- 1 # res := make ([] int , 0 , i + j ) # carry := 0 # for i >= 0 || j >= 0 || carry != 0 { # if i >= 0 { # carry += A [ i ] # i -- # } # if j >= 0 { # carry += B [ j ] # j -- # } # res = append ( res , carry & 1 ) # carry = -( carry >> 1 ) # } # # res = reverse ( res ) # # i , end := 0 , len ( res )- 1 # for i < end && res [ i ] == 0 { # i ++ # } # return res [ i :]
qs := [] question 1 3 { # # { # para 1 3 {" STR "}, # ans 1 3 { 3 }, # }, # # { # para 1 3 {" STR "}, # ans 1 3 { 4 }, # }, # # { # para 1 3 {" STR "}, # ans 1 3 { 9 }, # }, # # { # para 1 3 {" STR "}, # ans 1 3 { 5 8 }, # }, # # { # para 1 3 {" STR "}, # ans 1 3 { 1 9 9 4 }, # }, # # { # para 1 3 {" STR "}, # ans 1 3 { 2 0 1 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 3 , q . para 1 3 # fmt . Printf (" STR ", p . one , romanToInt ( p . one )) # } # fmt . Printf (" STR ")
n := h . min # if n != nil { # for i , e := n . degree (), n . c . Leftist (); i > 0 ; i = i - 1 { # nextE := e . right () # n . c . Remove ( e ) # h . root . PushLeft ( e ) # e = nextE # } # h . root . Remove ( n ) # if n == n . right () { # h . min = nil # } else { # h . min = n . right () # h . consolidate () # } # h . n -- # } # return n
fields := s . structFields () # # var t [] interface {} # # for _ , field := range fields { # val := s . value . FieldByName ( field . Name ) # # _ , tagOpts := parseTag ( field . Tag . Get ( s . TagName )) # # if tagOpts . Has (" STR ") { # zero := reflect . Zero ( val . Type ()). Interface () # current := val . Interface () # # if reflect . DeepEqual ( current , zero ) { # continue # } # } # # if tagOpts . Has (" STR ") { # s , ok := val . Interface ().( fmt . Stringer ) # if ok { # t = append ( t , s . String ()) # } # continue # } # # if IsStruct ( val . Interface ()) && ! tagOpts . Has (" STR ") { # t = append ( t , Values ( val . Interface ())...) # } else { # t = append ( t , val . Interface ()) # } # } # # return t
cases := [] struct { # name string # inputs string # expect int # }{ # {" STR ", " STR ", 7 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := longestPalindrome ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
type Server struct { # Name string ` structs :" STR "` # ID int 3 2 ` structs :" STR "` # Time time . Time ` structs :" STR "` # } # # const shortForm = " STR " # t , _ := time . Parse (" STR ", " STR ") # # s := & Server { # Name : " STR ", # ID : 7 8 9 0 1 2 , # Time : t , # } # # m := Map ( s ) # # fmt . Printf (" STR ", m [" STR "]) # fmt . Printf (" STR ", m [" STR "]) # fmt . Printf (" STR ", m [" STR "].( time . Time ))
if num < 6 { # return false # } # sum , mid := 1 , num # for i := 2 ; i < mid ; i ++ { # if num % i == 0 { # n := num / i # sum += i + n # if mid > n { # mid = n # } # } # } # return sum == num
sort . Ints ( candidates ) # return DFS ( candidates , 0 , target , [] int {}, [][] int {})
hashKey := h . hash ( key ) # if h . backets [ hashKey ] == nil { # return # } # le , exist := h . existInList ( key , h . backets [ hashKey ]) # if exist { # h . backets [ hashKey ]. Remove ( le ) # } # if h . backets [ hashKey ]. Len () == 0 { # h . backets [ hashKey ] = nil # h . Count -- # } # h . DownScale ()
checked := make ([] bool , n ) # sqrt_n := int ( math . Sqrt ( float 6 4 ( n ))) # # for i := 2 ; i <= sqrt_n ; i ++ { # if ! checked [ i ] { # for j := i * i ; j < n ; j += i { # checked [ j ] = true # } # } # } # # for i := 1 ; i < n ; i ++ { # if ! checked [ i ] { # primes = append ( primes , i ) # } # } # # return
node := this . tail . prev # this . removeNode ( node ) # return node
nums := [] int { 1 , 2 , 3 , 6 , 7 , 8 , 9 , 3 , 4 , 2 , 5 } # na := Constructor ( nums ) # if res := na . SumRange ( 4 , 9 ); res != 3 3 { # t . Errorf (" STR ", 4 3 , res ) # } # na . Update ( 6 , 1 0 ) # if res := na . SumRange ( 4 , 9 ); res != 3 4 { # t . Errorf (" STR ", 4 4 , res ) # }
return ParkingSystem { # Packing : big << 1 0 + medium << 2 0 + small << 3 0 , # }
return len ( g . edges )
var sum int # for p := root ; p != nil ; { # if p . Right == nil { # sum += p . Val # p . Val = sum # p = p . Left # continue # } # # q := p . Right # for q . Left != nil && q . Left != p { # q = q . Left # } # # if q . Left != nil { # sum += p . Val # p . Val = sum # q . Left = nil # p = p . Left # } else { # q . Left = p # p = p . Right # } # } # return root
root := & Trie { letters : make ( map [ rune ]* Trie )} # for _ , word := range words { # current := root # for _ , letter := range word { # if n , found := current . letters [ letter ]; ! found { # current . letters [ letter ] = & Trie { letters : make ( map [ rune ]* Trie )} # current = current . letters [ letter ] # } else { # current = n # } # } # current . wordCount ++ # } # return root
if ! fill ( board , ' 1 ', 0 ) { # panic (" STR ") # }
in 1 , in 2 , out := 1 0 , 1 0 0 0 0 0 0 , 2 7 8 3 9 1 5 4 6 0 # if x := p 2 4 ( in 1 , in 2 ); x != out { # t . Errorf (" STR ", in 1 , in 2 , x , out ) # }
sort . Ints ( people ) # left , right , res := 0 , len ( people )- 1 , 0 # for left <= right { # if left == right { # res ++ # return res # } # if people [ left ]+ people [ right ] <= limit { # left ++ # right -- # } else { # right -- # } # res ++ # } # return res
sum := 0 # for i := 1 ; i < 1 0 0 0 ; i ++ { # if i % 3 == 0 || i % 5 == 0 { # sum += i # } # } # fmt . Println ( sum )
http . HandleFunc (" STR ", index ) # http . HandleFunc (" STR ", welcome ) # http . HandleFunc (" STR ", message ) # log . Println (" STR ") # http . ListenAndServe (" STR ", nil )
if FastPow ( 2 , 1 0 ) != 1 0 2 4 { # t . Error (" STR ") # } # # if FastPow ( 1 , 1 0 ) != 1 { # t . Error (" STR ") # } # # if FastPow ( 0 , 1 5 ) != 0 { # t . Error (" STR ") # } # # if FastPow ( 1 0 , 2 ) != 1 0 0 { # t . Error (" STR ") # }
h := & ListNode { Next : head } # # tmp := h # for tmp . Next != nil { # if tmp . Next . Val == val { # tmp . Next = tmp . Next . Next # } else { # tmp = tmp . Next # } # } # return h . Next
var midNode * linkedHeapListElement # _i := i .(* linkedHeapList ) # if h . Len () > _i . Len () { # midNode = _i . Head ().(* linkedHeapListElement ) # h . Last ().(* linkedHeapListElement ). next = midNode # midNode . prev = h . Last ().(* linkedHeapListElement ) # h . root . prev = _i . Last ().(* linkedHeapListElement ) # _i . Last ().(* linkedHeapListElement ). next = & h . root # } else { # midNode := h . Head ().(* linkedHeapListElement ) # _i . Last ().(* linkedHeapListElement ). next = midNode # midNode . prev = _i . Last ().(* linkedHeapListElement ) # h . root . next = _i . Head ().(* linkedHeapListElement ) # _i . Head ().(* linkedHeapListElement ). prev = & h . root # } # for iNode := midNode ; h . Valid ( iNode ); iNode = h . Next ( iNode ).(* linkedHeapListElement ) { # iNode . parent = nil # iNode . left = nil # iNode . right = nil # prev := iNode . prev # prevParent := prev . parent # if prevParent . right == nil { # prevParent . right = iNode # iNode . parent = prevParent # } else { # prevParent . next . left = iNode # iNode . parent = prevParent . next # } # } # h . len += _i . Len () # return * h
return TwoSum {}
return reflect . MakeMap ( t )
if len ( prices ) == 0 { # return 0 # } # max , minElement := 0 , prices [ 0 ] # for i := 1 ; i < len ( prices ); i ++ { # if prices [ i ] < minElement { # minElement = prices [ i ] # } # tmp := prices [ i ] - minElement # if tmp > max { # max = tmp # } # } # return max
sd := [] int 8 { 1 , 6 , 3 , 2 , 1 2 3 , - 1 2 3 , - 2 9 , 3 , 0 , 1 } # sort . Slice ( sd , func ( i , j int ) bool { # return sd [ i ] > sd [ j ] # }) # println (" STR ") # for _ , d := range sd { # println ( d ) # } # # ud := [] uint 8 { 1 , 6 , 3 , 2 , 1 2 3 , 2 9 , 3 , 0 , 1 } # sort . Slice ( ud , func ( i , j int ) bool { # return ud [ i ] > ud [ j ] # }) # println (" STR ") # for _ , d := range ud { # println ( d ) # }
var perimeter int # for i , line := range grid { # for j , val := range line { # if val == 0 { # continue # } # perimeter += 4 # if i > 0 && grid [ i - 1 ][ j ] == 1 { # perimeter -- # } # if i < len ( grid )- 1 && grid [ i + 1 ][ j ] == 1 { # perimeter -- # } # if j > 0 && grid [ i ][ j - 1 ] == 1 { # perimeter -- # } # if j < len ( line )- 1 && grid [ i ][ j + 1 ] == 1 { # perimeter -- # } # } # } # return perimeter
qs := [] question 5 4 1 { # # { # para 5 4 1 {" STR ", 2 }, # ans 5 4 1 {" STR "}, # }, # # { # para 5 4 1 {" STR ", 5 }, # ans 5 4 1 {" STR "}, # }, # # { # para 5 4 1 {" STR ", 4 }, # ans 5 4 1 {" STR "}, # }, # # { # para 5 4 1 {" STR ", 1 0 0 }, # ans 5 4 1 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 4 1 , q . para 5 4 1 # fmt . Printf (" STR ", p , reverseStr ( p . s , p . k )) # } # fmt . Printf (" STR ")
n := len ( a ) # res , i , j , sum := n + 1 , 0 , 0 , 0 # # for j < n { # sum += a [ j ] # j ++ # # for sum >= s { # sum -= a [ i ] # i ++ # if res > j - i + 1 { # res = j - i + 1 # } # } # } # # return res % ( n + 1 )
op . name = name # op . cost = cost # return op
n := len ( s ) # countPalindrome := func ( l , r int ) int { # count := 0 # for l >= 0 && r < n && s [ l ] == s [ r ] { # count ++ # l -- # r ++ # } # return count # } # # res := 0 # for i := 0 ; i < n ; i ++ { # res += countPalindrome ( i , i ) + countPalindrome ( i , i + 1 ) # } # return res
result := make ([] int , 0 ) # val := 1 # for i := len ( digits ) - 1 ; i >= 0 ; i -- { # sum := val + digits [ i ] # if sum >= 1 0 { # sum -= 1 0 # val = 1 # } else { # val = 0 # } # # result = append ( result , sum ) # } # # if val > 0 { # result = append ( result , val ) # } # # for i , j := 0 , len ( result )- 1 ; i < j ; i , j = i + 1 , j - 1 { # result [ i ], result [ j ] = result [ j ], result [ i ] # } # # return result
ans , count := 0 , 0 # for _ , n := range nums { # if n == ans { # count ++ # } else { # count -- # } # if count <= 0 { # ans = n # count = 1 # } # } # return ans
t . Parallel () # # for _ , tc := range testcases { # copied := make ([] int 3 2 , len ( tc . input )) # copy ( copied , tc . input ) # RadixSortInt 3 2 ( copied ) # # if ! reflect . DeepEqual ( copied , tc . sorted ) { # t . Errorf (" STR ", tc . sorted , copied ) # } # }
var sortedPeripherals []* SVDPeripheral # var missingBasePeripherals []* SVDPeripheral # knownBasePeripherals := map [ string ] struct {}{} # for i := range input { # p := & input [ i ] # groupName := p . GroupName # if groupName == "" { # groupName = p . Name # } # knownBasePeripherals [ groupName ] = struct {}{} # if p . DerivedFrom != "" { # if _ , ok := knownBasePeripherals [ p . DerivedFrom ]; ! ok { # missingBasePeripherals = append ( missingBasePeripherals , p ) # continue # } # } # sortedPeripherals = append ( sortedPeripherals , p ) # } # # sortedPeripherals = append ( sortedPeripherals , missingBasePeripherals ...) # # return sortedPeripherals
if t . Kind () == Ptr { # panic (" STR ") # } # ptrType := t .( rawType )<< 5 | 5 # if ptrType >> 5 != t { # panic (" STR ") # } # return ptrType
lruCache := LRUCache { limit : capacity } # lruCache . HashMap = make ( map [ int ]* LruLinkNode , capacity ) # return lruCache
if len ( str ) == 0 { # return [] string {} # } # # digitMap := map [ byte ] string { # ' 2 ': " STR ", # ' 3 ': " STR ", # ' 4 ': " STR ", # ' 5 ': " STR ", # ' 6 ': " STR ", # ' 7 ': " STR ", # ' 8 ': " STR ", # ' 9 ': " STR ", # } # # queue := make ( chan [] string ) # count := len ( digitMap [ str [ 0 ]]) # for i := 0 ; i < count ; i ++ { # go numToWordsCore ( str , digitMap , 1 , queue ) # } # # result := make ([] string , 0 ) # for i := 0 ; i < count ; i ++ { # suffix := <- queue # for _ , word := range suffix { # result = append ( result , digitMap [ str [ 0 ]][ i : i + 1 ]+ word ) # } # } # # return result
if len 2 <= 0 { # return crc 1 # } # # even := make ([] uint , 3 2 ) # odd := make ([] uint , 3 2 ) # # odd [ 0 ] = uint ( poly ) # row := uint ( 1 ) # for n := 1 ; n < 3 2 ; n ++ { # odd [ n ] = row # row <<= 1 # } # # gf 2 MatrixSquare ( even , odd ) # # gf 2 MatrixSquare ( odd , even ) # # crc 1 n := uint ( crc 1 ) # for { # gf 2 MatrixSquare ( even , odd ) # if len 2 & 1 != 0 { # crc 1 n = gf 2 MatrixTimes ( even , crc 1 n ) # } # len 2 >>= 1 # # if len 2 == 0 { # break # } # # gf 2 MatrixSquare ( odd , even ) # if len 2 & 1 != 0 { # crc 1 n = gf 2 MatrixTimes ( odd , crc 1 n ) # } # len 2 >>= 1 # # if len 2 == 0 { # break # } # } # # crc 1 n ^= uint ( crc 2 ) # return uint 3 2 ( crc 1 n )
return m . cache [ m . bucketNo ( key )]. GetNotStaleNow ( key , now )
n := len ( s ) # if n == 0 { # return false # } # return strings . Contains (( s + s )[ 1 : n * 2 - 1 ], s )
if n <= 1 { # return # } # # var max int = math . MinInt 3 2 # for i := range a { # if a [ i ] > max { # max = a [ i ] # } # } # # c := make ([] int , max + 1 ) # for i := range a { # c [ a [ i ]]++ # } # for i := 1 ; i <= max ; i ++ { # c [ i ] += c [ i - 1 ] # } # # r := make ([] int , n ) # for i := n - 1 ; i >= 0 ; i -- { # index := c [ a [ i ]] - 1 # r [ index ] = a [ i ] # c [ a [ i ]]-- # } # copy ( a , r )
res , n := - 1 , len ( strs ) # for i := 0 ; i < n ; i ++ { # if len ( strs [ i ]) < res { # continue # } # j := - 1 # for j < n { # j ++ # if i != j && isSub ( strs [ i ], strs [ j ]) { # break # } # } # if j == n { # res = max ( res , len ( strs [ i ])) # } # } # return res
m := len ( matrix ) # if m == 0 { # return 0 # } # # n := len ( matrix [ 0 ]) # if n == 0 { # return 0 # } # # dp := make ([][] int , m ) # for i := 0 ; i < m ; i ++ { # dp [ i ] = make ([] int , n ) # } # # for j := 0 ; j < n ; j ++ { # dp [ 0 ][ j ] = int ( matrix [ 0 ][ j ] - ' 0 ') # # for i := 1 ; i < m ; i ++ { # if matrix [ i ][ j ] == ' 1 ' { # dp [ i ][ j ] = dp [ i - 1 ][ j ] + 1 # } # } # } # # max := 0 # for i := 0 ; i < m ; i ++ { # area := largestRectangleArea ( dp [ i ]) # if area > max { # max = area # } # } # # return max
if k < 1 || t < 0 { # return false # } # m := make ( map [ int ] int ) # t ++ # for i , num := range nums { # bucketid := num / t # if num < 0 { # bucketid -- # } # if _ , ok := m [ bucketid ]; ok { # return true # } else if v , ok := m [ bucketid - 1 ]; ok && abs ( num , v ) < t { # return true # } else if v , ok := m [ bucketid + 1 ]; ok && abs ( num , v ) < t { # return true # } # m [ bucketid ] = num # if i >= k { # delete ( m , nums [ i - k ]/ t ) # } # } # return false
return bits . Reverse 3 2 ( num )
str := n . FloatString ( maxLength )[ 2 :] # # length := len ( str ) # # outer : # for i := 1 ; i < length / 2 ; i ++ { # cycle := str [: i ] # # for j := i ; j < length / 2 ; j += i { # if str [ j : j + i ] != cycle { # continue outer # } # } # return i # } # # return - 1
defer wg . Done () # for i := 1 ; i <= 2 0 ; i ++ { # select { # case fib := <- fibs : # fmt . Printf (" STR ", fib . input , fib . value ) # case sqr := <- sqrs : # fmt . Printf (" STR ", sqr . input , sqr . value ) # } # }
gol := & GameOfLife { living : make ( map [ Coord ] struct {})} # rows := strings . Split ( board , " STR ") # gol . maxY = int 6 4 ( len ( rows )) # # for y := 0 ; y < len ( rows ); y ++ { # for x , val := range rows [ len ( rows )- 1 - y ] { # if val == '*' { # gol . living [ Coord { int 6 4 ( x ), int 6 4 ( y )}] = struct {}{} # if int 6 4 ( x ) >= gol . maxX { # gol . maxX = int 6 4 ( x ) + 1 # } # } # } # } # # gol . minX , gol . minY = - 1 , - 1 # # return gol
stack := make ([] rune , len ( s )) # top := 0 # # for _ , c := range s { # switch c { # case '(': # stack [ top ] = ')' # top += 1 # break # case '{': # stack [ top ] = '}' # top += 1 # break # case '[': # stack [ top ] = ']' # top += 1 # break # default : # if top == 0 || stack [ top - 1 ] != c { # return false # } # top -= 1 # break # } # } # # return top == 0
m , n := len ( grid ), len ( grid [ 0 ]) # # res := 0 # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # if grid [ i ][ j ] == 0 { # continue # } # res += 4 # for k := 0 ; k < 4 ; k ++ { # x := i + dx [ k ] # y := j + dy [ k ] # if 0 <= x && x < m && 0 <= y && y < n && grid [ x ][ y ] == 1 { # res -- # } # } # } # } # # return res
fs := http . Dir ( root ) # if listDirectory { # return fs # } # return & onlyfilesFS { fs }
i , j , k := 0 , 0 , len ( a )- 1 # # for j <= k { # switch a [ j ] { # case 0 : # a [ i ], a [ j ] = a [ j ], a [ i ] # i ++ # j ++ # case 1 : # j ++ # case 2 : # a [ j ], a [ k ] = a [ k ], a [ j ] # k -- # } # } #
n := len ( machines ) # sum := 0 # for _ , v := range machines { # sum += v # } # if sum % n != 0 { # return - 1 # } # avg , count := sum / n , 0 # res := 0 # for _ , v := range machines { # diff := v - avg # count += diff # res = max ( max ( res , abs ( count )), diff ) # } # return res
for i := 0 ; i < len ( nums ); i ++ { # if nums [ i ] == 0 { # nums [ i ] = - 1 # } # } # ret , sum := 0 , 0 # m := make ( map [ int ] int ) # m [ 0 ] = - 1 # for i := 0 ; i < len ( nums ); i ++ { # sum += nums [ i ] # if v , ok := m [ sum ]; ok { # ret = max ( ret , i - v ) # } else { # m [ sum ] = i # } # } # return ret
return s . stack [ len ( s . stack )- 1 ]
for x := 2 5 2 0 ; x <= 1 0 0 0 0 0 0 0 0 0 ; x += 2 0 { # for y := 3 ; y <= 2 0 ; y ++ { # if x % y != 0 { # print ( x , " STR ", y , " STR ") # break # } # # if y == 2 0 { # print ( x ) # return # } # } # }
if length := len ( str ); length < 2 { # return 1 # } # # count := 0 # # if first := str [ 0 ]; first == ' 1 ' || ( first == ' 2 ' && str [ 1 ] < ' 7 ') { # count = NumberOfDecodings ( str [ 2 :]) # } # # return count + NumberOfDecodings ( str [ 1 :])
if n < 2 { # return 1 # } # dp := make ([] int , n + 1 ) # dp [ 0 ], dp [ 1 ] = 1 , 1 # for i := 2 ; i <= n ; i ++ { # for j := 0 ; j < i ; j ++ { # dp [ i ] += dp [ j ] * dp [ i - 1 - j ] # } # } # return dp [ n ]
var sb strings . Builder # # move := func ( x 1 , y 1 , x 2 , y 2 int ) { # for y 1 > y 2 { # y 1 -- # sb . WriteByte (' L ') # } # for x 1 > x 2 { # x 1 -- # sb . WriteByte (' U ') # } # for x 1 < x 2 { # x 1 ++ # sb . WriteByte (' D ') # } # for y 1 < y 2 { # y 1 ++ # sb . WriteByte (' R ') # } # return # } # # x 1 , y 1 := 0 , 0 # for _ , r := range target { # x 2 , y 2 := coordinate ( r ) # move ( x 1 , y 1 , x 2 , y 2 ) # sb . WriteByte ('!') # x 1 , y 1 = x 2 , y 2 # } # # return sb . String ()
wordDictionary := Constructor (); # wordDictionary . AddWord (" STR "); # wordDictionary . AddWord (" STR "); # wordDictionary . AddWord (" STR "); # wordDictionary . Search (" STR "); # wordDictionary . Search (" STR "); # wordDictionary . Search (" STR "); # wordDictionary . Search (" STR ");
var max * TreeNode # var res [] int # for root != nil { # if root . Left == nil { # res = append ( res , root . Val ) # root = root . Right # } else { # max = root . Left # for max . Right != nil && max . Right != root { # max = max . Right # } # # if max . Right == nil { # res = append ( res , root . Val ) # max . Right = root . Right # root = root . Left # } else { # root = root . Right # max . Right = nil # } # } # } # return res
count := 9 # n 1 := totalNQueens ( count ) # n 2 := totalNQueens 3 ( count ) # n 3 := totalNQueens 2 ( count ) # t . Logf (" STR ", n 1 , n 2 , n 3 )
if left > right { # return nil # } # root := & TreeNode { Val : preorder [ preorderIdx ]} # preorderIdx ++ # idx := idxMap [ root . Val ] # root . Left = build ( left , idx - 1 , preorder ) # root . Right = build ( idx + 1 , right , preorder ) # return root
pq := make ( PQ , 0 , 1 0 0 0 0 ) # return FreqStack { # freq : make ( map [ int ] int , 1 0 0 0 0 ), # pq : & pq , # }
chars := [] byte ( s ) # # for idx := 0 ; idx * k < len ( chars ); idx += 2 { # start , end := idx * k , idx * k + k - 1 # if end >= len ( chars ) { # end = len ( chars )- 1 # } # # for start < end { # chars [ start ], chars [ end ] = chars [ end ], chars [ start ] # start ++ # end -- # } # } # return string ( chars )
b := & LRUCache {} # b . Init ( capacity ) # return b
minRad := 0 # sort . Ints ( heaters ) # for _ , house := range houses { # heater := findClosestHeater ( house , heaters ) # rad := heater - house # if rad < 0 { # rad = - rad # } # if rad > minRad { # minRad = rad # } # } # return minRad #
if 1 >= len ( arrayChar ) { # return # } # if start == len ( arrayChar )- 1 { # for i := 0 ; i < len ( arrayChar ); i ++ { # fmt . Printf (" STR ", arrayChar [ i ]) # } # fmt . Println () # } else { # for i := start ; i < len ( arrayChar ); i ++ { # swap ( arrayChar , start , i ) # permutation ( arrayChar , start + 1 ) # swap ( arrayChar , start , i ) # } # }
l , r := 2 * i + 1 , 2 * i + 2 # max := i # # if l < h . size () && h . slice [ l ] > h . slice [ max ] { # max = l # } # if r < h . size () && h . slice [ r ] > h . slice [ max ] { # max = r # } # if max != i { # h . slice [ i ], h . slice [ max ] = h . slice [ max ], h . slice [ i ] # h . MaxHeapify ( max ) # }
l . Tail . Next , k . Head . Prev = k . Head , l . Tail # l . Tail = k . Tail # l . Length += k . Length
head := & ListNode {} # cur := head # # for _ , j := range arr { # cur . Next = & ListNode { Val : j } # cur = cur . Next # } # return head . Next
mul := big . NewInt ( int 6 4 ( a )) # result := big . NewInt ( int 6 4 ( a )) # for i := 1 ; i < b ; i ++ { # result . Mul ( result , mul ) # } # return result
names = readNamesFile (" STR ") # sortNames ( 0 , len ( names )- 1 ) # sum := 0 # for i := range names { # sum += score ( i ) # } # fmt . Println (" STR ", sum )
n := len ( S ) # if n < 3 { # return [][] int {} # } # res := make ([][] int , 0 ) # c , l , r := 1 , - 1 , - 1 # for i := 1 ; i < n ; i ++ { # if S [ i ] == S [ i - 1 ] { # c ++ # if l == - 1 { # l = i - 1 # } # if c >= 3 { # r = i # } # } else { # if c >= 3 { # res = append ( res , [] int { l , r }) # } # c , l = 1 , - 1 # } # } # if c >= 3 { # res = append ( res , [] int { l , r }) # } # return res
if nil == root { # return root # } # # sums := 0 # convertBSTCore ( root , & sums ) # return root
temp := 0 # for i := 0 ; i < k ; i ++ { # temp += nums [ i ] # } # # max := temp # # for i := k ; i < len ( nums ); i ++ { # temp = temp - nums [ i - k ] + nums [ i ] # # if max < temp { # max = temp # } # } # # return float 6 4 ( max ) / float 6 4 ( k )
flag . Parse () # target = os . Args [ len ( os . Args )- 1 ] # if * configFile != "" { # readConfig () # } # runtime . GOMAXPROCS (* numThreads )
dp := [][] int {} # # for i := 0 ; i < m ; i ++ { # tmp := make ([] int , n ) # dp = append ( dp , tmp ) # } # # for i := 0 ; i < m ; i ++ { # dp [ i ][ 0 ] = 1 # } # # for j := 0 ; j < n ; j ++ { # dp [ 0 ][ j ] = 1 # } # # for i := 1 ; i < m ; i ++ { # for j := 1 ; j < n ; j ++ { # dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ] # } # } # # return dp [ m - 1 ][ n - 1 ]
lgu , datas , _ := basicData () # vEBT := newRsVEBTreeUint 3 2 ( lgu ) # insertData ( vEBT , datas ) # for i := range datas { # member := vEBT . Member ( i ) # e := member . Front () # for j := range datas [ i ] { # if e . Value != datas [ i ][ j ] { # t . Log ( fmt . Sprintf (" STR ", i , datas [ i ][ j ], e . Value )) # t . Fail () # } # e = e . Next () # } # }
if len ( S ) < 3 { # return [][] int {} # } # # ans := make ([][] int , 0 ) # start , count := 0 , 0 # for i := 0 ; i < len ( S ); i ++ { # if S [ i ] == S [ start ] { # count ++ # } else { # if 3 <= count { # ans = append ( ans , [] int { start , i - 1 }) # } # start = i # count = 1 # } # } # # if 3 <= count && S [ start ] == S [ len ( S )- 1 ] { # ans = append ( ans , [] int { start , len ( S ) - 1 }) # } # # return ans
head := & SinglyLL {} # current := head # for _ , value := range data { # current . Next = & SinglyLL { Value : value , Next : nil } # current = current . Next # } # return head . Next
if len ( tmp ) == num { # tmp 1 := make ([] int , len ( tmp )) # copy ( tmp 1 , tmp ) # res = append ( res , tmp 1 ) # return # } # for i := start ; i < len ( nums ); i ++{ # if i > start && nums [ i ] == nums [ i - 1 ]{ # continue # } # tmp = append ( tmp , nums [ i ]) # dfs ( nums , i + 1 , num , tmp ) # tmp = tmp [: len ( tmp )- 1 ] # }
n := len ( points ) # if n == 0 { # return 0 # } # sort . Slice ( points , func ( i , j int ) bool { # return points [ i ][ 1 ] < points [ j ][ 1 ] # }) # # res := 1 # end := points [ 0 ][ 1 ] # # for i := 1 ; i < n ; i ++ { # if points [ i ][ 0 ] <= end { # continue # } # res ++ # end = points [ i ][ 1 ] # } # return res
ans = len ( M ) # initialize ( ans ) # # for i := 0 ; i < len ( M ); i ++ { # for j := 0 ; j < i ; j ++ { # if 1 == M [ i ][ j ] { # union ( i , j ) # } # } # } # return ans
t . Parallel () # for _ , tc := range testcases { # if result := ClosestLargerNumberIndexBrute ( tc . nums , tc . targetIndex ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
procs := runtime . GOMAXPROCS (- 1 ) # var dec func () bool # if unsafe . Sizeof ( b . N ) == 8 { # n := int 6 4 ( b . N ) # dec = func () bool { # return atomic . AddInt 6 4 (& n , - 1 ) >= 0 # } # } else { # n := int 3 2 ( b . N ) # dec = func () bool { # return atomic . AddInt 3 2 (& n , - 1 ) >= 0 # } # } # var p Pool # var wg sync . WaitGroup # for i := 0 ; i < procs ; i ++ { # wg . Add ( 1 ) # go func () { # defer wg . Done () # for dec () { # p . Put ( 1 ) # p . Get () # } # }() # } # wg . Wait ()
mu . Lock () # count ++ # mu . Unlock () # fmt . Fprintf ( w , " STR ", r . URL . Path )
return len ( h . tasks )
sum 1 := 0 # nums 1 := make ( map [ int ] bool ) # for _ , n := range A { # sum 1 += n # nums 1 [ n ] = true # } # # sum 2 := 0 # nums 2 := make ( map [ int ] bool ) # for _ , n := range B { # sum 2 += n # nums 2 [ n ] = true # } # # diff := ( sum 1 - sum 2 ) / 2 # for n 1 := range nums 1 { # if _ , exists := nums 2 [ n 1 - diff ]; exists { # return [] int { n 1 , n 1 - diff } # } # } # # return make ([] int , 0 )
if i == j { # return 0 # } # q := 1 << 3 2 # for k := i ; k < j ; k ++ { # prod := MatrixChainRec ( D , i , k ) + MatrixChainRec ( D , k + 1 , j ) + D [ i - 1 ]* D [ k ]* D [ j ] # q = Min ( prod , q ) # } # return q
clumps := 0 # inClumps := false # for i := 1 ; i < len ( xs ); i ++ { # curr , prev := xs [ i ], xs [ i - 1 ] # if inClumps { # if curr != prev { # inClumps = false # } # } else { # if curr == prev { # inClumps = true # clumps ++ # } # } # } # return clumps
sum_sq := uint 6 4 ( 0 ) # sq_sum := uint 6 4 ( 0 ) # # for i := 0 ; i <= 1 0 0 ; i ++ { # sum_sq += ( uint 6 4 ( i ) * uint 6 4 ( i )) # sq_sum += uint 6 4 ( i ) # } # # sq_sum *= sq_sum # # fmt . Printf (" STR ", sq_sum , sum_sq , sq_sum - sum_sq ) #
const ( FinalNumber = 1 0 0 0 # FirstFactor = 3 # SecondFactor = 5 ) # var ( # sum = 0 # i = 0 ) # for ; i < FinalNumber ; i ++ { # if ( i % FirstFactor == 0 && i % SecondFactor == 0 ) { # sum += i # } # } # fmt . Println (" STR ", FinalNumber , " STR ", FirstFactor , " STR ", SecondFactor , " STR ", sum )
s = removeNoise ( s ) # var slen int = len ( s ) # for i := 0 ; i < slen / 2 ; i ++ { # fmt . Println (" STR ", s [ i : i + 1 ], " STR ", s [ slen - i - 1 : slen - i ]) # if s [ i : i + 1 ] != s [ slen - i - 1 : slen - i ] { # return false # } # } # return true #
remaindersMap := make ( map [ int ] int ) # # remainder := numerator % denominator # # repeatingRemainder := false # # for remainder != 0 && ! repeatingRemainder { # remaindersMap [ remainder ] = len ( repetend ) # remainder *= 1 0 # currentDigit := remainder / denominator # repetend = fmt . Sprintf (" STR ", repetend , currentDigit ) # remainder %= denominator # _ , repeatingRemainder = remaindersMap [ remainder ] # } # # if remainder == 0 { # repetend = " STR " # } else { # repetend = repetend [ remaindersMap [ remainder ]:] # } # # return
n := len ( s ) # counts := [ 2 6 ] int {} # maxLen , l , r := 0 , 0 , 0 # for ; r < n ; r ++ { # counts [ s [ r ]-' A ']++ # maxLen = max ( maxLen , counts [ s [ r ]-' A ']) # if r - l + 1 - maxLen > k { # counts [ s [ l ]-' A ']-- # l ++ # } # } # return n - l
jumps := make ( map [ int ] int , len ( ladders )+ len ( snakes )) # for _ , j := range ladders { # jumps [ j . From ] = j . To # } # for _ , j := range snakes { # jumps [ j . From ] = j . To # } # return snakesAndLaddersFewestTurns ( jumps , 0 , 0 , int (^ uint ( 0 )>> 1 ), maxDepth )
t . Parallel () # for _ , tc := range testcases { # if result , err := MajorityElementMap ( tc . nums ); err != tc . err || result != tc . majority { # t . Errorf (" STR ", tc . majority , tc . err , result , err ) # } # }
qs := [] question 1 2 0 0 { # # { # para 1 2 0 0 {[] int { 4 , 2 , 1 , 3 }}, # ans 1 2 0 0 {[][] int {{ 1 , 2 }, { 2 , 3 }, { 3 , 4 }}}, # }, # # { # para 1 2 0 0 {[] int { 1 , 3 , 6 , 1 0 , 1 5 }}, # ans 1 2 0 0 {[][] int {{ 1 , 3 }}}, # }, # # { # para 1 2 0 0 {[] int { 3 , 8 , - 1 0 , 2 3 , 1 9 , - 4 , - 1 4 , 2 7 }}, # ans 1 2 0 0 {[][] int {{- 1 4 , - 1 0 }, { 1 9 , 2 3 }, { 2 3 , 2 7 }}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 0 0 , q . para 1 2 0 0 # fmt . Printf (" STR ", p , minimumAbsDifference ( p . arr )) # } # fmt . Printf (" STR ")
t . Parallel () # randomizer = rand . New ( rand . NewSource ( 9 9 )) # expected := 5 8 # input := make ( chan interface {}) # go func () { # for i := 0 ; i < 1 0 0 ; i ++ { # input <- i # } # close ( input ) # }() # if result := UniformlyRandom ( input ); result != 5 8 { # t . Errorf (" STR ", expected , result ) # }
sum := 0 # primes := PrimesBelow ( 7 5 0 0 0 0 ) # Loop : # for _ , p := range primes { # if p < 1 1 { # continue # } # left , right := p , p # for left > 0 { # if ! IsPrime ( left , primes ) { # continue Loop # } # left /= 1 0 # } # for right > 0 { # if ! IsPrime ( right , primes ) { # continue Loop # } # switch { # case right > 1 0 0 0 0 0 : # right %= 1 0 0 0 0 0 # case right > 1 0 0 0 0 : # right %= 1 0 0 0 0 # case right > 1 0 0 0 : # right %= 1 0 0 0 # case right > 1 0 0 : # right %= 1 0 0 # case right > 1 0 : # right %= 1 0 # case right > 1 : # right %= 1 # } # } # sum += p # } # return sum
if ! IsPalindrome (" STR ") { # t . Error (` IsPalindrome (" STR ") = false `) # } # if ! IsPalindrome (" STR ") { # t . Error (` IsPalindrome (" STR ") = false `) # }
trueTimes := 0 # for _ , v := range targetStr { # for _ , vv := range needStr { # if string ( v ) == string ( vv ) { # trueTimes ++ # break # } # } # # } # if trueTimes == len ( targetStr ) { # return true # } # return false
dp := make ([] int , target + 1 ) # dp [ 0 ] = 1 # for i := 1 ; i < target + 1 ; i ++ { # for _ , num := range nums { # if num <= i { # dp [ i ] += dp [ i - num ] # } # } # } # return dp [ target ]
res := 0 # for i , p := range prices { # if i == 0 { # continue # } # if p > prices [ i - 1 ] { # res += p - prices [ i - 1 ] # } # } # return res
q . lock . Lock () # defer q . lock . Unlock () # # return q . len == 0
data := convertToSlice ( head ) # # r . Shuffle ( len ( data ), func ( i , j int ) { # data [ i ], data [ j ] = data [ j ], data [ i ] # }) # # return convertToLL ( data )
t . Parallel () # for _ , tc := range testcases { # if result , err := LargestPathValue ( tc . nodes , tc . edges ); result != tc . expected || err != tc . expectedErr { # t . Errorf (" STR ", tc . expected , tc . expectedErr , result , err ) # } # }
if len ( s ) < 2 { # return s # } # longest := s [ 0 : 1 ] # for i := 1 ; i < len ( s ); i ++ { # for rightStep := 0 ; rightStep < 2 ; rightStep ++ { # for p , q := i - 1 , i + rightStep ; p >= 0 && q < len ( s ) && s [ p ] == s [ q ]; { # if q - p + 1 > len ( longest ) { # longest = s [ p : q + 1 ] # } # p -- # q ++ # } # } # } # return longest
return reflect . Swapper ( slice )
start , end := 0 , len ( nums )- 1 # for start <= end { # mid := ( start + end ) / 2 # if target == nums [ mid ] { # r := make ([] int , 2 ) # i := mid # for i >= 0 && target == nums [ i ] { # i -- # } # i ++ # r [ 0 ] = i # for i <= len ( nums )- 1 && target == nums [ i ] { # i ++ # } # r [ 1 ] = i - 1 # return r # } # if target > nums [ mid ] { # start = mid + 1 # continue # } # end = mid - 1 # } # return [] int {- 1 , - 1 }
s . TotalWriteProcessed += s 1 . TotalWriteProcessed # s . TotalDelProcessed += s 1 . TotalDelProcessed # s . TotalGetProcessed += s 1 . TotalGetProcessed # s . TotalFlushProcessed += s 1 . TotalFlushProcessed # s . TotalCompactProcessed += s 1 . TotalCompactProcessed # s . TotalReadBytes += s 1 . TotalReadBytes # s . TotalWriteBytes += s 1 . TotalWriteBytes # s . TotalAddDelay += s 1 . TotalAddDelay # s . TotalWriteDelay += s 1 . TotalWriteDelay # s . TotalDelDelay += s 1 . TotalDelDelay # s . TotalGetDelay += s 1 . TotalGetDelay # s . TotalFlushDelay += s 1 . TotalFlushDelay # s . TotalCompactDelay += s 1 . TotalCompactDelay
rotated := indexOfMin ( nums ) # size := len ( nums ) # left , right := 0 , size - 1 # # for left <= right { # mid := ( left + right ) / 2 # # rotatedMid := ( rotated + mid ) % size # switch { # case nums [ rotatedMid ] < target : # left = mid + 1 # case target < nums [ rotatedMid ]: # right = mid - 1 # default : # return rotatedMid # } # } # # return - 1
cases := [] struct { # name string # inputs [] string # expect int # }{ # {" STR ", [] string {" STR ", " STR "}, 3 }, # {" STR ", [] string {" STR ", " STR "}, 3 }, # {" STR ", [] string {" STR ", " STR "}, 5 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := minDistance ( c . inputs [ 0 ], c . inputs [ 1 ]) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
if N == 1 { # return []* TreeNode {& TreeNode {}} # } # res := []* TreeNode {} # for i := 1 ; i < N - 1 ; i += 2 { # l , r := allPossibleFBT ( i ), allPossibleFBT ( N - i - 1 ) # for _ , ln := range l { # for _ , rn := range r { # res = append ( res , & TreeNode { # Left : ln , # Right : rn , # }) # } # } # } # return res
if unsafe . Sizeof ( Exists ) != 0 { # t . Error (" STR ") # }
var pos , neg , k , cur int # for target > 0 { # cur = target % x # target /= x # if k > 0 { # pos , neg = min ( cur * k + pos , ( cur + 1 )* k + neg ), min (( x - cur )* k + pos , ( x - cur - 1 )* k + neg ) # } else { # pos , neg = cur * 2 , ( x - cur )* 2 # } # k ++ # } # return min ( pos , k + neg ) - 1
fmt . Println ( firstMissingPositive ([] int { 3 , 4 , - 1 , 1 }))
found := - 1 # m := make ( map [ int ] int ) # for _ , v := range nums { # m [ v ]++ # if m [ v ] > 1 { # found = v # break # } # } # return found
s = strings . ToLower ( s ) # i , j := 0 , len ( s )- 1 # for i < j { # for i < j && ! isChar ( s [ i ]) { # i ++ # } # for i < j && ! isChar ( s [ j ]) { # j -- # } # if s [ i ] != s [ j ] { # return false # } # i ++ # j -- # } # # return true
res := 0 # if i >= 0 && i < len ( grid ) && j >= 0 && j < len ( grid [ 0 ]) && 1 == grid [ i ][ j ] { # grid [ i ][ j ] = 0 # up := dfs ( grid , i - 1 , j ) # down := dfs ( grid , i + 1 , j ) # left := dfs ( grid , i , j - 1 ) # right := dfs ( grid , i , j + 1 ) # res = up + down + left + right + 1 # } # return res
if n < 2 { # return n # } # a , b , c := 0 , 1 , 1 # for n > 2 { # a , b , c = b , c , a + b + c # n -- # } # return c
num := [] int { 1 , 2 , 3 } # # fmt . Println ( minMoves ( num ))
low , high := 0 , 1 0 0 0 0 0 # for low < high { # mid := low + ( high - low )>> 1 # if calculateSum ( arr , mid ) < target { # low = mid + 1 # } else { # high = mid # } # } # sum 1 , sum 2 := calculateSum ( arr , low - 1 ), calculateSum ( arr , low ) # if target - sum 1 <= sum 2 - target { # return low - 1 # } # return low
var res = [][] int {} # currentLevel := []* TreeNode { root } # for len ( currentLevel ) > 0 { # nextLevel := []* TreeNode {} # currentLevelTraverseResult := [] int {} # # for _ , n := range currentLevel { # if n != nil { # currentLevelTraverseResult = append ( currentLevelTraverseResult , n . Val ) # } # # if n != nil && n . Left != nil { # nextLevel = append ( nextLevel , n . Left ) # } # # if n != nil && n . Right != nil { # nextLevel = append ( nextLevel , n . Right ) # } # } # # if len ( currentLevelTraverseResult ) > 0 { # res = append ( res , currentLevelTraverseResult ) # } # # currentLevel = nextLevel # } # for i := 0 ; i < len ( res )/ 2 ; i ++ { # res [ i ], res [ len ( res )- i - 1 ] = res [ len ( res )- i - 1 ], res [ i ] # } # return res
print ( north , east , south , west ) # r := newRobot () # for _ , i := range instructions { # r . receive ( i ) # } # return ( r . x == 0 && r . y == 0 ) || # ( r . d != north )
return checkFlags ( name , list , validLinkerFlags , validLinkerFlagsWithNextArg )
sort . Ints ( nums ) # size := len ( nums ) # # median := nums [ size / 2 ] # if size & 1 == 0 { # median += ( nums [ size / 2 - 1 ] - median ) / 2 # } # # res := 0 # for _ , n := range nums { # res += diff ( median , n ) # } # # return res
t . Parallel () # for tcid , tc := range testcases { # if result := DeepCloneRandomSinglyLL ( tc . head ); ! equalButNotIdentical ( tc . head , result ) { # t . Errorf (" STR ", tcid ) # } # }
size := len ( prices ) # if size <= 1 { # return 0 # } # # if k >= size { # return profits ( prices ) # } # local := make ([] int , k + 1 ) # global := make ([] int , k + 1 ) # # for i := 1 ; i < size ; i ++ { # diff := prices [ i ] - prices [ i - 1 ] # for j := k ; j >= 1 ; j -- { # local [ j ] = max ( global [ j - 1 ]+ max ( diff , 0 ), local [ j ]+ diff ) # global [ j ] = max ( local [ j ], global [ j ]) # } # } # # return global [ k ]
if x == nil { # return # } # p . mu . Lock () # if p . list == nil { # if p . drainTicker == nil && p . DrainPeriod != 0 { # p . drainTicker = time . NewTicker ( p . DrainPeriod ) # go func () { # for _ = range p . drainTicker . C { # p . Drain () # } # }() # } # } # p . list = append ( p . list , x ) # p . mu . Unlock ()
t . Parallel () # for _ , tc := range testcases { # if result := BinaryTreeByLevel ( tc . tree ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
offsetString := r . element . Offset # if offsetString == nil { # offsetString = r . element . AddressOffset # } # addr , err := strconv . ParseUint (* offsetString , 0 , 3 2 ) # if err != nil { # panic ( err ) # } # return r . baseAddress + addr
m , ans , has_odd := make ( map [ rune ] int , 1 2 8 ), 0 , false # for _ , v := range s { # m [ v ]++ # } # for _ , v := range m { # ans += v # if v % 2 == 1 { # ans -- # has_odd = true # } # } # if has_odd { # ans ++ # } # # return ans
s = strings . ToLower ( s ) # l , r := 0 , len ( s )- 1 # for l < r { # for l < r && ( s [ l ] < ' a ' || s [ l ] > ' z ') && ( s [ l ] < ' 0 ' || s [ l ] > ' 9 ') { # l ++ # } # for l < r && ( s [ r ] < ' a ' || s [ r ] > ' z ') && ( s [ r ] < ' 0 ' || s [ r ] > ' 9 ') { # r -- # } # if l < r { # if s [ l ] != s [ r ] { # return false # } # l ++ # r -- # } # } # return true
n := len ( A ) # up , down := 0 , 0 # res := 0 # for i := 1 ; i < n ; i ++ { # if down != 0 && A [ i - 1 ] < A [ i ] { # up , down = 1 , 0 # } else if A [ i - 1 ] == A [ i ] { # up , down = 0 , 0 # } else if A [ i - 1 ] < A [ i ] { # up ++ # } else if A [ i - 1 ] > A [ i ] { # down ++ # } # if up > 0 && down > 0 { # res = max ( res , up + 1 + down ) # } # } # return res
for i := 0 ; i < len ( arr ); i ++ { # min := i # for j := i + 1 ; j < len ( arr ); j ++ { # if arr [ j ] < arr [ min ] { # min = j # } # } # if min != i { # arr [ i ], arr [ min ] = arr [ min ], arr [ i ] # } # } # return arr
if ! sort . IntsAreSorted ( sorted ) { # return 0 , errInputNotSorted # } # # for lo , hi := 0 , len ( sorted ); lo <= hi ; { # switch mid := ( lo + hi ) / 2 ; { # case sorted [ mid ] == mid : # if hi - lo == 0 { # return mid , nil # } # # hi = mid # case sorted [ mid ] < mid : # lo = mid + 1 # default : # hi = mid - 1 # } # } # # return 0 , errNoSuchIndex
n := len ( nums ) # pos := binarySearch ( nums , 0 , n - 1 , target ) # # var result [] int # low , high := - 1 , - 1 # if pos >= 0 { # high = pos # low = high # # l := binarySearch ( nums , 0 , low - 1 , target ) # for l >= 0 { # low = l # l = binarySearch ( nums , 0 , low - 1 , target ) # } # # h := binarySearch ( nums , high + 1 , n - 1 , target ) # for h >= 0 { # high = h # h = binarySearch ( nums , high + 1 , n - 1 , target ) # } # } # result = append ( result , low ) # result = append ( result , high ) # # return result
nodes , diff := strings . Split ( preorder , " STR "), 1 # for _ , node := range nodes { # diff -- # if diff < 0 { # return false # } # if node != " STR " { # diff += 2 # } # } # return diff == 0
maxProfit := 0 # minPrice := math . MaxInt 6 4 # for _ , v := range prices { # minPrice = mymin ( minPrice , v ) # maxProfit = mymax ( maxProfit , v - minPrice ) # } # return maxProfit
if nil == head || 0 == k { # return head # } # head , length := cycleList ( head ) # if k >= length { # k = k % length # } # for i := 0 ; i < length - k - 1 ; i ++ { # head = head . Next # } # p := head . Next # head . Next = nil # return p
limit := 1 0 0 # # times := 0 # # res := [] int {} # for head != nil { # times ++ # if times > limit { # msg := fmt . Sprintf (" STR ", limit ) # panic ( msg ) # } # # res = append ( res , head . Val ) # head = head . Next # } # # return res
if n < 1 { # return nil # } # return genTrees ( 1 , n )
if leftIndex >= rightIndex { # return # } # divideIndex := int (( leftIndex + rightIndex ) / 2 ) # MergeSort ( array , leftIndex , divideIndex ) # MergeSort ( array , divideIndex + 1 , rightIndex ) # mergeParts ( array , leftIndex , divideIndex , rightIndex )
cases := [] struct { # name string # inputs string # expect [] string # }{ # {" STR ", " STR ", [] string {" STR ", " STR "}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := findRepeatedDnaSequences ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
pivot := arr [ end ] # i := start # for j := start ; j < end ; j ++ { # if arr [ j ] < pivot { # if i != j { # arr [ i ], arr [ j ] = arr [ j ], arr [ i ] # } # i ++ # } # } # arr [ i ], arr [ end ] = arr [ end ], arr [ i ] # return i
n := len ( citations ) # counts := make ([] int , n + 1 ) # for _ , c := range citations { # if c > n { # counts [ n ]++ # } else { # counts [ c ]++ # } # } # count := 0 # for i := n ; i >= 0 ; i -- { # count += counts [ i ] # if count >= i { # return i # } # } # return 0
sort . Ints ( nums ) # # n := len ( nums ) # vector := make ([] int , n ) # taken := make ([] bool , n ) # # var ans [][] int # # makePermutation ( 0 , n , nums , vector , taken , & ans ) # # return ans
n := len ( digits ) # if n < 1 { # return [] int { 1 } # } # digits [ n - 1 ] += 1 # carry := 0 # for i := n - 1 ; i >= 0 ; i -- { # n := digits [ i ] + carry # digits [ i ], carry = n % 1 0 , n / 1 0 # } # if carry > 0 { # digits = append ([] int { carry }, digits ...) # } # return digits
qs := [] question 5 1 { # # { # para 5 1 { 4 }, # ans 5 1 {[][] string { # {" STR ", # " STR ", # " STR ", # " STR "}, # {" STR ", # " STR ", # " STR ", # " STR "}, # }}, # }, # } # # fmt . Printf (" STR ") # for _ , q := range qs { # _ , p := q . ans 5 1 , q . para 5 1 # fmt . Printf (" STR ", p , solveNQueens ( p . one )) # } # fmt . Printf (" STR ")
qs := [] question 1 2 1 { # # { # para 1 2 1 {[] int {}}, # ans 1 2 1 { 0 }, # }, # # { # para 1 2 1 {[] int { 7 , 1 , 5 , 3 , 6 , 4 }}, # ans 1 2 1 { 5 }, # }, # # { # para 1 2 1 {[] int { 7 , 6 , 4 , 3 , 1 }}, # ans 1 2 1 { 0 }, # }, # # { # para 1 2 1 {[] int { 1 , 3 , 2 , 8 , 4 , 9 }}, # ans 1 2 1 { 8 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 1 , q . para 1 2 1 # fmt . Printf (" STR ", p , maxProfit ( p . one )) # } # fmt . Printf (" STR ")
res = [] string {} # if digits == " STR " { # return res # } # # findCombinations ( digits , 0 , " STR ") # return res
cases := [] struct { # name string # inputs string # expect bool # }{ # {" STR ", " STR ", true }, # {" STR ", " STR ", false }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := checkRecord ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
ans := nums [ 0 ] + nums [ 1 ] + nums [ len ( nums )- 1 ] # sort . Ints ( nums ) # for i := 0 ; i < len ( nums )- 2 ; i ++ { # start , end := i + 1 , len ( nums )- 1 # for start < end { # sum := nums [ i ] + nums [ start ] + nums [ end ] # if sum > target { # end -- # } else { # start ++ # } # # if Abs ( sum - target ) < Abs ( ans - target ) { # ans = sum # } # # } # } # return ans
n := len ( s ) # if n == 0 { # return 0 # } # # dp := make ([] int , n + 1 ) # dp [ 0 ], dp [ 1 ] = 1 , one ( s [ 0 : 1 ]) # # for i := 2 ; i <= n ; i ++ { # w 1 , w 2 := one ( s [ i - 1 : i ]), two ( s [ i - 2 : i ]) # dp [ i ] = dp [ i - 1 ]* w 1 + dp [ i - 2 ]* w 2 # if dp [ i ] == 0 { # return 0 # } # } # # return dp [ n ]
dp := make ([] int , amount + 1 ) # # for i := 1 ; i < amount + 1 ; i ++ { # dp [ i ] = amount + 1 # for _ , c := range coins { # if c <= i && dp [ i ] > dp [ i - c ]+ 1 { # dp [ i ] = dp [ i - c ] + 1 # } # } # } # # if dp [ amount ] > amount { # return - 1 # } # return dp [ amount ]
starttime := time . Now () # # target := int 6 4 ( 4 ) # # counter := int 6 4 ( 0 ) # record := int 6 4 ( 0 ) # # for target = 4 ; counter < 1 0 0 0 ; target ++ { # # counter = 0 # # for den := target + 1 ; den <= 2 * target ; den ++ { # # if ( den * target )%( den - target ) == 0 { # counter ++ # } # # } # # if counter > record { # record = counter # fmt . Println ( target , record ) # } # # } # # fmt . Println ( target ) # # fmt . Println (" STR ", time . Since ( starttime ))
visits := make ( map [ int ] bool ) # return hasCycle ( g , start , visits )
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 2 , 2 , 1 }, 1 }, # {" STR ", [] int { 4 , 1 , 2 , 1 , 2 }, 4 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := singleNumber ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
fmt . Println (" STR ") # # for i := 0 ; i < 1 0 ; i ++ { # defer fmt . Println ( i ) # } # # fmt . Println (" STR ")
handle (" STR ", func ( res http . ResponseWriter , req * http . Request ) error { # f , err := os . Open (" STR ") # if err != nil { # return err # } # defer f . Close () # # rdr := csv . NewReader ( f ) # rows , err := rdr . ReadAll () # if err != nil { # return err # } # # records := make ([] record , 0 , len ( rows )) # for i , row := range rows { # if i == 0 { # continue # } # record := makeRecord ( row ) # records = append ( records , record ) # } # # tpl , err := template . ParseFiles (" STR ") # if err != nil { # return err # } # err = tpl . Execute ( res , records ) # if err != nil { # return err # } # # return nil # }) # # http . ListenAndServe (" STR ", nil )
islands , neighbours := 0 , 0 # m := len ( grid ) # if m == 0 { # return 0 # } # n := len ( grid [ 0 ]) # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # if grid [ i ][ j ] == 1 { # islands ++ # if i < m - 1 && grid [ i + 1 ][ j ] == 1 { # neighbours ++ # } # if j < n - 1 && grid [ i ][ j + 1 ] == 1 { # neighbours ++ # } # } # } # } # return islands * 4 - neighbours * 2
var sum [] byte # # var prev byte # for i , j := len ( a )- 1 , len ( b )- 1 ; i >= 0 || j >= 0 ; i , j = i - 1 , j - 1 { # var x , y byte # if i >= 0 { # x = a [ i ] - ' 0 ' # } # if j >= 0 { # y = b [ j ] - ' 0 ' # } # # v := x + y + prev # prev = v & 2 >> 1 # sum = append ( sum , ' 0 '+( v & 1 )) # } # if prev == 1 { # sum = append ( sum , ' 1 ') # } # # for i , j := 0 , len ( sum )- 1 ; i < j ; i , j = i + 1 , j - 1 { # sum [ i ], sum [ j ] = sum [ j ], sum [ i ] # } # return string ( sum )
r , err := FormatResponse ( Bytes { Start : 0 , End : 4 0 9 5 , Length : - 1 , Satisfied : true }) # if err != nil { # panic ( err ) # } # fmt . Println ( r )
var ii , pi , missed int # inputR := [] rune ( input ) # patternR := [] rune ( pattern ) # for isPossible ( ii , len ( inputR ), pi , len ( patternR ), missed ) { # if patternR [ pi ] == '*' { # prev := patternR [ pi - 1 ] # var next rune # if pi + 1 < len ( patternR ) { # next = patternR [ pi + 1 ] # } # for shouldKeepLooking ( ii , len ( inputR ), inputR , next ) { # if prev != '.' && inputR [ ii ] != prev { # return false # } # ii ++ # } # if remainingPattern ( ii , len ( inputR ), pi , len ( patternR )) { # return false # } # ii -- # } else if missedMatch ( patternR [ pi ], inputR [ ii ]) { # missed ++ # } # ii ++ # pi ++ # } # return finished ( ii , len ( input ), pi , len ( pattern ))
var tests = [] struct { # tree * TreeNode # sum int # path [][] int # }{ # { newTree ( 5 , 4 , 8 , 1 1 , nil , 1 3 , 4 , 7 , 2 , nil , nil , 5 , 1 ), 2 2 , [][] int {{ 5 , 4 , 1 1 , 2 }, { 5 , 8 , 4 , 5 }}}, # } # # for _ , tt := range tests { # path := pathSum ( tt . tree , tt . sum ) # if reflect . DeepEqual ( path , tt . path ) == false { # t . Errorf (" STR ", tt . tree , tt . sum , path , tt . path ) # } # }
cases := [] struct { # name string # preorder [] int # inorder [] int # expect * TreeNode # }{ # {" STR ", [] int { 3 , 9 , 2 0 , 1 5 , 7 }, [] int { 9 , 3 , 1 5 , 2 0 , 7 }, & TreeNode { 3 , & TreeNode { Val : 9 }, & TreeNode { 2 0 , & TreeNode { Val : 1 5 }, & TreeNode { Val : 7 }}}}, # {" STR ", [] int {- 1 }, [] int {- 1 }, & TreeNode { Val : - 1 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . preorder , c . inorder ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . preorder , c . inorder ) # } # }) # }
if node == nil { # return nil # } # # m := make ( map [* Node 1 3 3 ]* Node 1 3 3 ) # queue := make ([]* Node 1 3 3 , 0 ) # visited := make ( map [* Node 1 3 3 ] bool ) # # c := & Node 1 3 3 { # Val : node . Val , # } # # queue = append ( queue , node ) # visited [ node ] = true # m [ node ] = c # # for len ( queue ) > 0 { # n := queue [ 0 ] # queue = queue [ 1 :] # cloneN := m [ n ] # # for _ , neighbor := range n . Neighbors { # if ! visited [ neighbor ] { # cloneNeighbor := & Node 1 3 3 { # Val : neighbor . Val , # } # # queue = append ( queue , neighbor ) # m [ neighbor ] = cloneNeighbor # visited [ neighbor ] = true # } # # cloneN . Neighbors = append ( cloneN . Neighbors , m [ neighbor ]) # } # } # # return c
arrSize := rand . Intn ( 1 0 0 ) + 5 0 # arr := make ([] int , arrSize , arrSize ) # for i := range arr { # arr [ i ] = rand . Intn ( 1 0 0 ) # } # sortedArr := make ([] int , 0 , 0 ) # h := NewFibHeap () # for _ , v := range arr { # h . Insert ( v , v ) # } # for h . n > 0 { # min := h . ExtractMin () # sortedArr = append ( sortedArr , min . Key .( int )) # } # sort . Sort ( sort . Reverse ( sort . IntSlice ( arr ))) # if ! reflect . DeepEqual ( sortedArr , arr ) { # t . Log ( fmt . Sprintf (" STR ", arr ) + fmt . Sprintf (" STR ", sortedArr )) # t . Fail () # }
res := 0 # for _ , n := range nums { # res ^= n # } # return res
t . Parallel () # for _ , tc := range testcases { # if result := CircleWords ( tc . input ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
leftMax , nextMax , rightBegin := A [ 0 ], A [ 0 ], 1 # # for i := 1 ; i < len ( A ); i ++ { # if leftMax > A [ i ] { # leftMax = nextMax # rightBegin = i + 1 # } else { # nextMax = max ( nextMax , A [ i ]) # } # } # # return rightBegin
if me . unread { # return errors . New (" STR ") # } # me . unread = true # return nil
var tests = [] struct { # tree * TreeNode # paths [] string # }{ # { newTree ( 1 , 2 , 3 , nil , 5 ), [] string {" STR ", " STR "}}, # } # # for _ , tt := range tests { # paths := binaryTreePaths ( tt . tree ) # if reflect . DeepEqual ( paths , tt . paths ) == false { # t . Errorf (" STR ", tt . tree , paths , tt . paths ) # } # }
if len ( houses ) == 0 { # return 0 # } # # res := 0 # # sort . Ints ( houses ) # sort . Ints ( heaters ) # # iHeater := sort . SearchInts ( heaters , houses [ 0 ]) # # for iHouse := 0 ; iHouse < len ( houses ); iHouse ++ { # for iHeater < len ( heaters ) && houses [ iHouse ] > heaters [ iHeater ] { # iHeater ++ # } # # if iHeater == len ( heaters ) { # return max ( res , houses [ len ( houses )- 1 ]- heaters [ iHeater - 1 ]) # } # # left := 1 << 3 1 - 1 # if 0 <= iHeater - 1 { # left = houses [ iHouse ] - heaters [ iHeater - 1 ] # } # # right := heaters [ iHeater ] - houses [ iHouse ] # # res = max ( res , min ( left , right )) # } # # return res
return New ( s ). Names ()
in , out := 2 0 0 0 0 0 0 , 1 4 2 9 1 3 8 2 8 9 2 2 # if x := p 1 0 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # }
n := len ( nums ) # if n == 0 { # return 0 # } # if n == 1 { # return nums [ 0 ] # } # dp := make ([] int , n ) # dp [ 0 ], dp [ 1 ] = nums [ 0 ], max ( nums [ 1 ], nums [ 0 ]) # for i := 2 ; i < n ; i ++ { # dp [ i ] = max ( dp [ i - 1 ], nums [ i ]+ dp [ i - 2 ]) # } # return dp [ n - 1 ]
qs := [] question 8 4 4 { # # { # para 8 4 4 {" STR ", " STR "}, # ans 8 4 4 { true }, # }, # # { # para 8 4 4 {" STR ", " STR "}, # ans 8 4 4 { true }, # }, # # { # para 8 4 4 {" STR ", " STR "}, # ans 8 4 4 { true }, # }, # # { # para 8 4 4 {" STR ", " STR "}, # ans 8 4 4 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 4 4 , q . para 8 4 4 # fmt . Printf (" STR ", p , backspaceCompare ( p . s , p . t )) # } # fmt . Printf (" STR ")
sum := 0 # for _ , num := range multiset { # sum += num # } # if sum % 2 == 1 { # return false # } # half := sum / 2 # return subsetSum ( multiset , half )
if len ( nums ) <= 2 { # return len ( nums ) # } # # i , j , count , first := 1 , 1 , 1 , nums [ 0 ] # for j < len ( nums ) { # if nums [ j ] != first { # nums [ i ] = nums [ j ] # i ++ # count , first = 1 , nums [ j ] # } else if count < 2 { # nums [ i ] = nums [ j ] # i ++ # count ++ # } # # j ++ # } # # return i
for m := 2 ; m < 3 0 ; m ++ { # for n := 1 ; n < m ; n ++ { # for k := 0 ; ; k ++ { # a , b , c := k *(( m * m )-( n * n )), k *( 2 * m * n ), k *(( m * m )+( n * n )) # p := a + b + c # # if p <= 1 0 0 0 { # addSolution ( a , b , c , p ) # } else { # break # } # } # } # } # # maxP := 0 # maxSolutions := 0 # # for p , solutions := range perimeterSolutions { # if solutions > maxSolutions { # maxSolutions , maxP = solutions , p # } # } # # fmt . Println ( maxP )
d := newDisc () # for i := 0 ; i < 8 ; i ++ { # buf := new ( bytes . Buffer ) # binary . Write ( buf , binary . LittleEndian , uint 3 2 ( i )) # d . write ( i , buf . Bytes ()) # } # for i := 0 ; i < 8 ; i ++ { # data , _ := d . read ( i ) # buf := bytes . NewBuffer ( data .([] byte )) # var dataI uint 3 2 # binary . Read ( buf , binary . LittleEndian , & dataI ) # if uint 3 2 ( i ) != dataI { # t . Log ( i , dataI ) # t . Fail () # } # }
n := len ( A ) # count := 0 # for _ , a := range A { # if a == 1 { # count ++ # } # } # if count == 0 { # return [] int { 0 , n - 1 } # } # if count % 3 != 0 { # return [] int {- 1 , - 1 } # } # # k := count / 3 # p 1 , p 2 , p 3 , count 1 := 0 , 0 , 0 , 0 # for i , a := range A { # if a == 1 { # if count 1 == 0 { # p 1 = i # } else if count 1 == k { # p 2 = i # } else if count 1 == 2 * k { # p 3 = i # break # } # count 1 ++ # } # } # for p 3 < n && A [ p 1 ] == A [ p 2 ] && A [ p 2 ] == A [ p 3 ] { # p 1 ++ # p 2 ++ # p 3 ++ # } # if p 3 == n { # return [] int { p 1 - 1 , p 2 } # } # return [] int {- 1 , - 1 }
for _ , test := range searchTests { # actual := BinaryIterative ( test . data , test . key , 0 , len ( test . data )- 1 ) # if actual != test . expected { # t . Errorf (" STR ", test . name ) # } # }
return 0 , func ( i int ) { println (" STR ", i ) }
cases := [] struct { # value , min , max , expected float 6 4 # }{ # { # value : 0 . 0 , # min : 0 . 0 , # max : 1 . 0 , # expected : 0 . 0 , # }, # { # value : 0 . 0 , # min : 1 . 0 , # max : 1 . 5 , # expected : 1 . 0 , # }, # { # value : 2 0 0 . 0 , # min : 0 . 0 , # max : 1 . 0 , # expected : 1 . 0 , # }, # { # value : - 4 5 6 1 2 0 0 . 0 , # min : 0 . 0 , # max : 1 . 0 , # expected : 0 . 0 , # }, # } # # for _ , c := range cases { # actual := Clamp ( c . value , c . min , c . max ) # if actual != c . expected { # t . Errorf (" STR ", c . expected , actual ) # } # }
sort . Ints ( nums ) # copyNum := append ([] int {}, nums ...) # # res := [][] int {} # res = append ( res , copyNum ) # for { # canBeBigger := false # for i := len ( nums ) - 1 ; i >= 1 ; i -- { # if nums [ i ] > nums [ i - 1 ] { # canBeBigger = true # for j := i ; j < len ( nums ); j ++ { # if nums [ j ] < nums [ i ] && nums [ j ] > nums [ i - 1 ] { # nums [ j ], nums [ i ] = nums [ i ], nums [ j ] # } # } # nums [ i ], nums [ i - 1 ] = nums [ i - 1 ], nums [ i ] # sort . Ints ( nums [ i :]) # internalRes := append ([] int {}, nums ...) # res = append ( res , internalRes ) # break # } # } # if ! canBeBigger { # break # } # } # return res
if k < 2 { # return 0 # } # ret , total , l := 0 , 1 , 0 # for i := 0 ; i < len ( nums ); i ++ { # total *= nums [ i ] # for total >= k { # total /= nums [ l ] # l ++ # } # ret += i - l + 1 # } # return ret
input := " STR " # if ! IsPalindrome ( input ) { # t . Errorf (` IsPalindrome (% q ) = false `, input ) # }
if len ( sortedData ) == 0 { # return - 1 # } # # var ( # low , high = 0 , len ( sortedData ) - 1 # lowVal , highVal = sortedData [ low ], sortedData [ high ] # ) # # for lowVal != highVal && ( lowVal <= guess ) && ( guess <= highVal ) { # mid := low + int ( float 6 4 ( float 6 4 (( guess - lowVal )*( high - low ))/ float 6 4 ( highVal - lowVal ))) # # if sortedData [ mid ] == guess { # for mid > 0 && sortedData [ mid - 1 ] == guess { # mid -- # } # return mid # # } # # if sortedData [ mid ] > guess { # high , highVal = mid - 1 , sortedData [ high ] # # } else { # low , lowVal = mid + 1 , sortedData [ low ] # } # # } # # if guess == lowVal { # return low # } # return - 1
return & DLinkedNode { # key : key , # value : value , # }
if n < 1 { # return false # } # # for n > 1 { # if n % 2 == 1 { # return false # } # n /= 2 # } # # return true
t . Parallel () # for _ , tc := range testcases { # if result := MinPathSum ( tc . tree ); result != tc . minSum { # t . Errorf (" STR ", tc . minSum , result ) # } # }
type arg struct { # nums [] int # target int # } # # testCases := [] arg { # { nums : [] int { 4 , 5 , 6 , 7 , 0 , 1 , 2 }, target : 0 }, # { nums : [] int { 4 , 5 , 6 , 7 , 0 , 1 , 2 }, target : 3 }, # { nums : [] int {}, target : 2 }, # { nums : [] int { 4 }, target : 4 }, # { nums : [] int { 4 , 5 , 6 , 7 , 0 }, target : 0 }, # { nums : [] int { 9 , 7 }, target : 7 }, # { nums : [] int { 1 , 3 }, target : 3 }, # { nums : [] int { 4 , 5 , 6 , 7 , 8 , 1 , 2 }, target : 5 }, # } # # expected := [] int { 4 , - 1 , - 1 , 0 , 4 , 1 , 1 , 1 } # # for index , data := range testCases { # if res := search ( data . nums , data . target ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
var max int # for x := range grid { # for y := range grid [ x ] { # if grid [ x ][ y ] == 0 { # continue # } # i := search ( grid , x , y ) # if max < i { # max = i # } # } # } # return max
return itf . Error ()
if root 1 == nil || root 2 == nil { # return root 1 == root 2 # } # if root 1 . Val != root 2 . Val { # return false # } # return flipEquiv ( root 1 . Left , root 2 . Left ) && flipEquiv ( root 1 . Right , root 2 . Right ) || # flipEquiv ( root 1 . Left , root 2 . Right ) && flipEquiv ( root 1 . Right , root 2 . Left )
self . top -- # uint 3 2 Val := uint 3 2 ( self . slots [ self . top ]. Num ) # return math . Float 3 2 frombits ( uint 3 2 Val )
if len ( nums ) == 1 { # return nums [ 0 ] # } # res := nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # res ^= nums [ i ] # } # return res
t . Parallel () # for _ , tc := range testcases { # if result := Match ( tc . input , tc . pattern ); result != tc . expected { # t . Errorf (" STR ", tc . input , tc . pattern , tc . expected , result ) # } # }
c := pc . c # if _ , ok := c .( errorConnection ); ok { # return nil # } # pc . c = errorConnection { ErrConnClosed } # # pc . p . put ( c , false ) # return nil
n := len ( s ) # stack := [] byte {} # # count := [ 2 6 ] int {} # for i := 0 ; i < n ; i ++ { # count [ s [ i ]-' a ']++ # } # # visited := [ 2 6 ] bool {} # for i := 0 ; i < n ; i ++ { # b := s [ i ] # count [ b -' a ']-- # if visited [ b -' a '] { # continue # } # # for len ( stack ) != 0 { # p := stack [ len ( stack )- 1 ] # if p > b && count [ p -' a '] > 0 { # visited [ p -' a '] = false # stack = stack [: len ( stack )- 1 ] # } else { # break # } # } # stack = append ( stack , b ) # visited [ b -' a '] = true # } # # return string ( stack )
l := len ( nums ) # i , j := 0 , 0 # # for j < l { # if nums [ j ] != 0 { # nums [ i ] = nums [ j ] # i ++ # } # j ++ # } # # for i < l { # nums [ i ] = 0 # i ++ # }
benchmark ( bb , 8 1 9 2 , 1 )
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", [][] int { # { 1 , 2 , 2 , 1 }, # { 3 , 1 , 2 }, # { 1 , 3 , 2 }, # { 2 , 4 }, # { 3 , 1 , 2 }, # { 1 , 3 , 1 , 1 }, # }, 2 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := leastBricks ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
var res [][] int # if root == nil { # return res # } # var q []* Node # var n * Node # var idx = 0 # q = append ( q , root ) # # for len ( q ) != 0 { # res = append ( res , [] int {}) # qLen := len ( q ) # for i := 0 ; i < qLen ; i ++ { # n , q = q [ 0 ], q [ 1 :] # res [ idx ] = append ( res [ idx ], n . val ) # if n . left != nil { # q = append ( q , n . left ) # } # if n . right != nil { # q = append ( q , n . right ) # } # } # idx ++ # } # return res
_ , ok := m . m [ key ] # return ok
arr := randomSlice ( 0 , 2 0 , 1 0 ) # resultArr := make ([] int , 0 , 0 ) # expArr := make ([] int , 0 , 0 ) # bst := newBstIterative () # expBst := newBstRecrusive () # for _ , v := range arr { # bst . Insert ( uint 3 2 ( v )) # expBst . Insert ( uint 3 2 ( v )) # } # expBst . PostOrderWalk ( expBst . Root (), func ( tree binaryTreeIf , node interface {}) bool { # n := node .(* bstElement ) # expArr = append ( expArr , int ( n . Key )) # return false # }) # bst . PostOrderWalk ( bst . Root (), func ( tree binaryTreeIf , node interface {}) bool { # n := node .(* bstElement ) # if * debug { # fmt . Println ( n ) # } # resultArr = append ( resultArr , int ( n . Key )) # return false # }) # if ! reflect . DeepEqual ( resultArr , expArr ) { # t . Log ( fmt . Sprintf (" STR ", expArr ) + fmt . Sprintf (" STR ", resultArr )) # t . Fail () # }
var T = struct { # A string # B int # C bool # }{ # A : " STR ", # B : 2 , # C : true , # } # # s := Values ( T ) # # if typ := reflect . TypeOf ( s ). Kind (); typ != reflect . Slice { # t . Errorf (" STR ", typ ) # } # # inSlice := func ( val interface {}) bool { # for _ , v := range s { # if reflect . DeepEqual ( v , val ) { # return true # } # } # return false # } # # for _ , val := range [] interface {}{" STR ", 2 , true } { # if ! inSlice ( val ) { # t . Errorf (" STR ", val ) # } # }
return rec 1 [ 0 ] < rec 2 [ 2 ] && rec 2 [ 0 ] < rec 1 [ 2 ] && # rec 1 [ 1 ] < rec 2 [ 3 ] && rec 2 [ 1 ] < rec 1 [ 3 ]
switch { # case i == 0 : # return _Type_name_ 0 # case i == 2 : # return _Type_name_ 1 # case i == 4 : # return _Type_name_ 2 # case i == 8 : # return _Type_name_ 3 # case i == 1 6 : # return _Type_name_ 4 # case i == 3 2 : # return _Type_name_ 5 # case i == 6 4 : # return _Type_name_ 6 # case i == 1 2 8 : # return _Type_name_ 7 # case i == 2 5 6 : # return _Type_name_ 8 # default : # return fmt . Sprintf (" STR ", i ) # }
intersectionSet := New () # var minSet , maxSet Set # if st . Len () > st 2 . Len () { # minSet = st 2 # maxSet = st # } else { # minSet = st # maxSet = st 2 # } # for _ , item := range minSet . GetItems () { # if maxSet . In ( item ) { # intersectionSet . Add ( item ) # } # } # return intersectionSet
counts := make ( map [ string ] int ) # for _ , filename := range os . Args [ 1 :] { # data , err := ioutil . ReadFile ( filename ) # if err != nil { # fmt . Fprintf ( os . Stderr , " STR ", err ) # continue # } # for _ , line := range strings . Split ( string ( data ), " STR ") { # counts [ line ]++ # } # } # for line , n := range counts { # if n > 1 { # fmt . Printf (" STR ", n , line ) # } # }
i , j := 0 , len ( nums )- 1 # for i < j { # mid := ( i + j ) / 2 # if nums [ mid ] < nums [ mid + 1 ] { # i = mid + 1 # } else { # j = mid # } # } # return i
m := make ( map [ int ] int ) # for _ , v := range nums { # m [ v ]++ # } # for i := 0 ; i < len ( nums )- 2 ; i ++ { # for j := i + 1 ; j < len ( nums )- 1 ; j ++ { # needed := k - nums [ i ] - nums [ j ] # if m [ needed ] >= 0 { # m [ nums [ i ]]-- # m [ nums [ j ]]-- # m [ needed ]-- # if m [ nums [ i ]] >= 0 && m [ nums [ j ]] >= 0 && m [ needed ] >= 0 { # return [] int { nums [ i ], nums [ j ], needed } # } # m [ nums [ i ]]++ # m [ nums [ j ]]++ # m [ needed ]++ # } # } # } # return nil
New ( s ). FillMap ( out )
max := 2 0 0 # pences := [] int { 1 , 2 , 5 , 1 0 , 2 0 , 5 0 , 1 0 0 , 2 0 0 } # # var possibilities = make ([] int , max + 1 ) # possibilities [ 0 ] = 1 # for i := 0 ; i < len ( pences ); i ++ { # for j := pences [ i ]; j < len ( possibilities ); j ++ { # possibilities [ j ] += possibilities [ j - pences [ i ]] # } # } # # fmt . Println ( possibilities [ max ])
t . Parallel () # for _ , tc := range testcases { # if result := SmallestWindowEveryDistinctLength ( tc . input ); result != tc . windowLength { # t . Errorf (" STR ", tc . windowLength , result ) # } # }
println (" STR ", s . a , s . b )
board := make ([][] string , 3 ) # toggle := true # for i := range board { # board [ i ] = make ([] string , 3 ) # } # for _ , move := range moves { # i , j := move [ 0 ], move [ 1 ] # if toggle { # board [ i ][ j ] = " STR " # toggle = false # } else { # board [ i ][ j ] = " STR " # toggle = true # } # } # return winner ( board )
color := image [ sr ][ sc ] # if color != newColor { # dfs ( image , sr , sc , color , newColor ) # } # return image
if start > destination { # start , destination = destination , start # } # # total , part := 0 , 0 # for i , d := range distance { # total += d # if start <= i && i < destination { # part += d # } # } # # return min ( part , total - part )
pre = nil # head = nil # dfs ( root ) # if pre != nil { # pre . Right = head # head . Left = pre # } # return head
qs := [] question 6 4 8 { # # { # para 6 4 8 {[] string {" STR ", " STR ", " STR "}, " STR "}, # ans 6 4 8 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 4 8 , q . para 6 4 8 # fmt . Printf (" STR ", p , replaceWords ( p . one , p . s )) # } # fmt . Printf (" STR ")
elementSet := make ([] string , n ) # for i := range elementSet { # elementSet [ i ] = string ( rune ( i + 4 9 )) # } # out <- elementSet
return helper 2 3 ( lists , 0 , len ( lists )- 1 )
dp := make ([] int , amount + 1 ) # dp [ 0 ] = 1 # for _ , coin := range coins { # for i := coin ; i <= amount ; i ++ { # dp [ i ] += dp [ i - coin ] # } # } # return dp [ amount ]
n := len ( arr ) # maxL := make ([] int , n ) # minR := make ([] int , n ) # # maxL [ 0 ] = arr [ 0 ] # for i := 1 ; i < n ; i ++ { # maxL [ i ] = max ( maxL [ i - 1 ], arr [ i ]) # } # # minR [ n - 1 ] = arr [ n - 1 ] # for i := n - 2 ; i >= 0 ; i -- { # minR [ i ] = min ( minR [ i + 1 ], arr [ i ]) # } # # res := 1 # for i := 0 ; i < n - 1 ; i ++ { # if maxL [ i ] <= minR [ i + 1 ] { # res ++ # } # } # return res
if len ( A ) != len ( B ) { # return false # } # # if A == B { # return hasDouble ( A ) # } # # size := len ( A ) # i := 0 # countDown := 2 # ca , cb := byte ( 0 ), byte ( 0 ) # for countDown > 0 && i < size { # if A [ i ] != B [ i ] { # ca += A [ i ] # cb += B [ i ] # countDown -- # } # i ++ # } # # return ca == cb && A [ i :] == B [ i :]
s = p [ 0 ] # for i := 1 ; i < len ( p ); i ++ { # s = s + p [ i ] # } # return s
fmt . Fprintf ( w , " STR ")
p := root # ret := [] int {} # stack := []* TreeNode {} # for p != nil || len ( stack ) != 0 { # for p != nil { # stack = append ( stack , p ) # p = p . Left # } # if len ( stack ) != 0 { # tmp := stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # p = tmp . Right # ret = append ( ret , tmp . Val ) # } # } # return ret
res , count := 0 , 0 # for _ , b := range s { # if b == ' L ' { # count ++ # } else { # count -- # } # if count == 0 { # res ++ # } # } # return res
if len ( n . keyValue ) == 0 { # return nil , - 1 # } # # i := n . searchKeyIdx ( key ) # # if key == n . keyValue [ i ]. key { # return n . keyValue [ i ], i # } else if n . LessByKey ( key , n . keyValue [ i ]. key ) { # return n . c [ i ], i # } else { # return n . c [ i + 1 ], i + 1 # }
n := len ( nums ) # if n < 2 { # return n # } # res := 1 # count := 1 # for i := 1 ; i < n ; i ++ { # if nums [ i ]- nums [ i - 1 ] > 0 { # count ++ # if count > res { # res = count # } # } else { # count = 1 # } # } # return res
if bt . root == nil { # bt . root = bt . bTreeIf . newNode ( bt . t ) # bt . height ++ # } # # for n := bt . root ; n != nil ; { # n = bt . insertOrSet ( n , key , value ) # } #
qs := [] question 1 0 0 4 { # # { # para 1 0 0 4 {[] int { 1 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 0 }, 2 }, # ans 1 0 0 4 { 6 }, # }, # # { # para 1 0 0 4 {[] int { 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 }, 3 }, # ans 1 0 0 4 { 1 0 }, # }, # # { # para 1 0 0 4 {[] int { 0 , 0 , 0 , 1 }, 4 }, # ans 1 0 0 4 { 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 0 4 , q . para 1 0 0 4 # fmt . Printf (" STR ", p , longestOnes ( p . s , p . k )) # } # fmt . Printf (" STR ")
s = trim ( s ) # # return isReal ( s )
qs := [] question 1 2 6 6 { # # { # para 1 2 6 6 {[][] int {{ 1 , 1 }, { 3 , 4 }, {- 1 , 0 }}}, # ans 1 2 6 6 { 7 }, # }, # # { # para 1 2 6 6 {[][] int {{ 3 , 2 }, {- 2 , 2 }}}, # ans 1 2 6 6 { 5 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 6 6 , q . para 1 2 6 6 # fmt . Printf (" STR ", p , minTimeToVisitAllPoints ( p . points )) # } # fmt . Printf (" STR ")
n := len ( A ) # sum := 0 # for _ , num := range A { # sum += num # } # # dp := make ([][] bool , n / 2 + 1 ) # for i := range dp { # dp [ i ] = make ([] bool , sum + 1 ) # } # # dp [ 0 ][ 0 ] = true # for _ , num := range A { # for s := sum ; s >= num ; s -- { # for k := 1 ; k <= n / 2 ; k ++ { # dp [ k ][ s ] = dp [ k ][ s ] || dp [ k - 1 ][ s - num ] # # if dp [ k ][ s ] && sum * k == s * n { # return true # } # } # } # } # # return false
lastEven := - 1 # for i := range A { # if A [ i ]% 2 == 0 { # lastEven ++ # A [ lastEven ], A [ i ] = A [ i ], A [ lastEven ] # } # } # # return A
if len ( nums ) == 0 { # return nil # } # # node := & TreeNode {} # mid := len ( nums ) / 2 # node . Val = nums [ mid ] # if mid > 0 { # node . Left = Solution ( nums [: mid ]) # } # if mid < len ( nums )- 1 { # node . Right = Solution ( nums [ mid + 1 :]) # } # # return node
var ret int # var nums [] int # # ret = 2 # nums = [] int { 3 , 0 , 1 } # if ret != missingNumber ( nums ) { # t . Fatalf (" STR ", ret ) # } # # ret = 8 # nums = [] int { 9 , 6 , 4 , 2 , 3 , 5 , 7 , 0 , 1 } # if ret != missingNumber ( nums ) { # t . Fatalf (" STR ", ret ) # }
l := new ( ListNode ) # n := l # for _ , v := range vs { # n . Next = & ListNode { Val : v } # n = n . Next # } # return l . Next
buildTriangle () # fmt . Println ( getMaxTreeSum ( triangle [ 0 ]))
cannonicalName := strings . Replace ( name , " STR ", " STR ", - 1 ) # if f , ok := _bindata [ cannonicalName ]; ok { # a , err := f () # if err != nil { # return nil , fmt . Errorf (" STR ", name , err ) # } # return a . bytes , nil # } # return nil , fmt . Errorf (" STR ", name )
tests := [...] testType { # { # in : [] int { 1 , 2 , 3 , 4 }, # queries : [][] int {{ 1 , 0 }, {- 3 , 1 }, {- 4 , 0 }, { 2 , 3 }}, # want : [] int { 8 , 6 , 2 , 4 }, # }, # } # for _ , tt := range tests { # got := sumEvenAfterQueries ( tt . in , tt . queries ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
tests := map [ int ] int { # 1 2 3 : 3 2 1 , # - 1 2 3 : - 3 2 1 , # 1 2 0 : 2 1 , # math . MaxInt 3 2 : 0 , # math . MinInt 3 2 : 0 , # } # # for in , want := range tests { # got := reverse ( in ) # if got != want { # t . Fatalf (" STR ", in , got , want ) # } # }
return int ( math . Sqrt ( float 6 4 ( n )))
numMap := make ( map [ int ] int ) # l := len ( nums ) # for i := 0 ; i < l ; i ++ { # if numMap [ nums [ i ]] >= 2 { # nums = append ( nums [: i ], nums [ i + 1 :]...) # i -- # l -- # } # numMap [ nums [ i ]]++ # } # return len ( nums )
sleep := rand . Int 6 3 n ( 1 0 0 0 ) # time . Sleep ( time . Duration ( sleep ) * time . Millisecond ) # t . Status = " STR "
val , res := 0 , 0 # for i := 0 ; i < len ( s ); i ++ { # val = int ( s [ i ] - ' A ' + 1 ) # res = res * 2 6 + val # } # return res
dp := make ([][] int , m + 1 ) # for k , _ := range dp { # dp [ k ] = make ([] int , n + 1 ) # } # for _ , v := range strs { # c 0 , c 1 := 0 , 0 # for i := 0 ; i < len ( v ); i ++ { # if v [ i ] == ' 1 ' { # c 1 ++ # } else { # c 0 ++ # } # } # if c 0 > m || c 1 > n { # continue # } # for i := m ; i >= c 0 ; i -- { # for j := n ; j >= c 1 ; j -- { # dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i - c 0 ][ j - c 1 ]+ 1 ) # } # } # } # return dp [ m ][ n ]
type A struct { # Name string # Enabled bool # } # a := A { Name : " STR "} # # type B struct { # A A # C int # Value string ` structs :" STR "` # Number int # } # b := & B { A : a , C : 1 2 3 } # # s := Fields ( b ) # # if len ( s ) != 3 { # t . Errorf (" STR ", len ( s )) # } # # inSlice := func ( val interface {}) bool { # for _ , v := range s { # if reflect . DeepEqual ( v . Name (), val ) { # return true # } # } # return false # } # # for _ , val := range [] interface {}{" STR ", " STR "} { # if ! inSlice ( val ) { # t . Errorf (" STR ", val ) # } # }
if len ( A ) == 0 { # return [] int {} # } # right := len ( A ) # var ( # ans [] int # ) # for right > 0 { # idx := find ( A , right ) # if idx != right - 1 { # reverse 9 6 9 ( A , 0 , idx ) # reverse 9 6 9 ( A , 0 , right - 1 ) # ans = append ( ans , idx + 1 , right ) # } # right -- # } # # return ans
if start == len ( digits ) { # * res = append (* res , str ) # return # } # mapStr := maps [ digits [ start ]-" STR "] # for i := 0 ; i < len ( mapStr ); i ++ { # dfs ( digits , res , str + string ( mapStr [ i ]), start + 1 ) # }
fmt . Println ( numberOf 1 Between 1 AndN ( 1 2 ))
var ret int # var nums [] int # # nums = [] int { 3 , 2 , 1 } # ret = 1 # if ret != thirdMax ( nums ) { # t . Fatalf (" STR ", ret ) # } # # nums = [] int { 1 , 2 } # ret = 2 # if ret != thirdMax ( nums ) { # t . Fatalf (" STR ", ret ) # } # # nums = [] int { 2 , 1 } # ret = 2 # if ret != thirdMax ( nums ) { # t . Fatalf (" STR ", ret ) # } # # nums = [] int { 2 , 2 , 3 , 1 } # ret = 1 # if ret != thirdMax ( nums ) { # t . Fatalf (" STR ", ret ) # } # # nums = [] int { 1 } # ret = 1 # if ret != thirdMax ( nums ) { # t . Fatalf (" STR ", ret ) # } # # nums = [] int { 2 , 2 , 3 , 1 , 5 , 3 , 5 } # ret = 2 # if ret != thirdMax ( nums ) { # t . Fatalf (" STR ", ret ) # } #
tweets := make ( map [ int ][] tweet ) # feeds := make ( map [ int ][] tweet ) # fans := make ( map [ int ][] int ) # # return Twitter { tweets , feeds , fans }
sum , max , val := 2 , 0 , 0 # for i := 3 ; i < 5 0 0 0 0 0 ; i += 2 { # if isPrime ( i ) { # primes = append ( primes , i ) # sum += i # val = sum # for j := 0 ; j < len ( primes ); j ++ { # if val < 1 0 0 0 0 0 0 { # if val > max { # if isPrime ( val ) { # max = val # break # } else { # val -= primes [ j ] # } # } else { # break # } # } # } # } # } # fmt . Println (" STR ", max )
var tests = [] struct { # a , b string # sum string # }{ # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # } # # for _ , tt := range tests { # sum := addBinary ( tt . a , tt . b ) # if sum != tt . sum { # t . Errorf (" STR ", tt . a , tt . b , sum , tt . sum ) # } # }
cases := [] struct { # name string # inputs [] int # expect [] int # }{ # {" STR ", [] int { 4 , 2 , 5 , 7 }, [] int { 4 , 5 , 2 , 7 }}, # {" STR ", [] int {}, [] int {}}, # {" STR ", [] int { 1 , 2 , 3 , 4 }, [] int { 2 , 1 , 4 , 3 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
freq := make ( map [ rune ] int ) # for _ , r := range w { # freq [ r ]++ # } # var result [] int # for i := range s { # sub := make ( map [ rune ] int ) # for j := i ; j < len ( s ) && j < i + len ( w ); j ++ { # sub [ rune ( s [ j ])]++ # } # if reflect . DeepEqual ( sub , freq ) { # result = append ( result , i ) # } # } # return result
nums := [] int { 4 , 2 , 1 } # fmt . Println ( checkPossibility ( nums )) # # nums 2 := [] int { 4 , 2 , 3 } # fmt . Println ( checkPossibility ( nums 2 )) # # nums 3 := [] int { 3 , 4 , 2 , 3 } # fmt . Println ( checkPossibility ( nums 3 ))
fmt . Println ( digitAtIndex ( 1 9 ))
if char >= ' a ' && char <= ' z ' { # return true # } # return false
if root == nil { # return false # } # # if root . Left == nil && root . Right == nil { # return root . Val == sum # } # # if root . Left != nil && hasPathSum ( root . Left , sum - root . Val ) { # return true # } # # return root . Right != nil && hasPathSum ( root . Right , sum - root . Val ) #
url := " http : # statusCode := 2 0 0 # # t . Log (" STR ") # { # t . Logf (" STR ", # url , statusCode ) # { # resp , err := http . Get ( url ) # if err != nil { # t . Fatal (" STR ", # ballotX , err ) # } # t . Log (" STR ", # checkMark ) # # defer resp . Body . Close () # # if resp . StatusCode == statusCode { # t . Logf (" STR ", # statusCode , checkMark ) # } else { # t . Errorf (" STR ", # statusCode , ballotX , resp . StatusCode ) # } # } # }
circle := make ([] bool , len ( graph )) # color := make ([] int , len ( graph )) # # for n := 0 ; n < len ( graph ); n ++ { # helper 8 0 2 ( graph , n , circle , color ) # } # # result := make ([] int , 0 ) # for n , c := range circle { # if ! c { # result = append ( result , n ) # } # } # # return result
if nil == nums || len ( nums ) == 0 { # return 0 # } # # maxSum := math . MinInt 3 2 # for i := 0 ; i <= len ( nums )- k ; i ++ { # temp := 0 # for j := 0 ; j < k ; j ++ { # temp += nums [ i + j ] # } # if maxSum < temp { # maxSum = temp # } # } # return float 6 4 ( maxSum ) / float 6 4 ( k )
t . Parallel () # for _ , tc := range testcases { # if result := PossiblePhoneLetters ( tc . number , tc . mapping ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
err := da . CheckRangeFromIndex ( index ) # # if err != nil { # return nil , err # } # # return da . ElementData [ index ], nil
pre := [ 2 5 ][ 2 5 ] float 6 4 {} # pre [ r ][ c ] = 1 # # for k := 0 ; k < K ; k ++ { # next := [ 2 5 ][ 2 5 ] float 6 4 {} # # for i := 0 ; i < N ; i ++ { # for j := 0 ; j < N ; j ++ { # if pre [ i ][ j ] == 0 { # continue # } # for m := 0 ; m < 8 ; m ++ { # x := dx [ m ] + i # y := dy [ m ] + j # if 0 <= x && x < N && 0 <= y && y < N { # next [ x ][ y ] += pre [ i ][ j ] # } # } # } # } # # pre = next # } # # count := 0 . # for i := 0 ; i < N ; i ++ { # for j := 0 ; j < N ; j ++ { # count += pre [ i ][ j ] # } # } # # return float 6 4 ( count ) / math . Pow ( 8 ., float 6 4 ( K ))
for index , value := range array { # if value == number { # return index # } # } # return - 1
a , b := 0 , 1 # for i := 0 ; i < N ; i ++ { # a , b = b , a + b # } # return a
conn , err := net . Dial (" STR ", " STR ") # if err != nil { # log . Fatal ( err ) # } # defer conn . Close () # go mustCopy ( os . Stdout , conn ) # mustCopy ( conn , os . Stdin )
type arg struct { # haystack string # needle string # } # # testCases := [] arg { # { haystack : " STR ", needle : " STR "}, # { haystack : " STR ", needle : " STR "}, # { haystack : " STR "}, # } # # expected := [] int { 2 , - 1 , 0 } # for index , data := range testCases { # if res := strStr ( data . haystack , data . needle ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
index := make ( map [ int ] int ) # for i , num := range nums { # if j , ok := index [ num ]; ok && i - j <= k { # return true # } # index [ num ] = i # } # return false
return MyCalendarThree {}
var sb strings . Builder # sb . Grow ( A + B ) # # a , b := byte (' a '), byte (' b ') # if A < B { # A , B = B , A # a , b = b , a # } # # for A > 0 { # sb . WriteByte ( a ) # A -- # if A > B { # sb . WriteByte ( a ) # A -- # } # if B > 0 { # sb . WriteByte ( b ) # B -- # } # } # # return sb . String ()
prev , curr := 0 , 1 # return func () int { # ret := prev # prev , curr = curr , prev + curr # return ret # }
result := 0 # for n > 0 { # n = n / 5 # result += n # } # # return result
t . Parallel () # for _ , tc := range testcases { # if result := IsPermutationPalindrome ( tc . s ); result != tc . expected { # t . Errorf (" STR ", tc . s , result , tc . expected ) # } # }
h , v := 0 , 0 # for _ , move := range moves { # switch move { # case ' U ': # h ++ # case ' D ': # h -- # case ' L ': # v ++ # case ' R ': # v -- # } # } # return h == 0 && v == 0
return new ( twiddle ). init ( cost )
if cw == w || i == n { # if cw > maxW { # maxW = cw # return # } # } # if logWeight [ i ][ cw ] == 1 { # return # } # logWeight [ i ][ cw ] = 1 # pkgTraceBack ( i + 1 , cw ) # if cw + weight [ i ] <= w { # pkgTraceBack ( i + 1 , cw + weight [ i ]) # }
seen := make ( map [ string ] bool ) # input := bufio . NewScanner ( os . Stdin ) # for input . Scan () { # line := input . Text () # if ! seen [ line ] { # seen [ line ] = true # fmt . Println ( line ) # } # } # # if err := input . Err (); err != nil { # fmt . Fprintf ( os . Stderr , " STR ", err ) # os . Exit ( 1 ) # }
fmt . Println ( findUnsortedSubarray ([] int { 2 , 6 , 4 , 8 , 1 0 , 9 , 1 5 })) # fmt . Println ( findUnsortedSubarray ([] int { 2 , 1 }))
fmt . Println ( romanToInt (" STR ")) # fmt . Println ( romanToInt (" STR "))
matrix := [][] int { # { 5 , 1 , 9 , 1 1 }, # { 2 , 4 , 8 , 1 0 }, # { 1 3 , 3 , 6 , 7 }, # { 1 5 , 1 4 , 1 2 , 1 6 }, # } # # expected := [][] int { # { 1 5 , 1 3 , 2 , 5 }, # { 1 4 , 3 , 4 , 1 }, # { 1 2 , 6 , 8 , 9 }, # { 1 6 , 7 , 1 0 , 1 1 }, # } # # if rotate ( matrix ); ! reflect . DeepEqual ( matrix , expected ) { # t . Errorf (" STR ", expected , matrix ) # }
return bindataRead ( # _dataLocationsJson , # " STR ", # )
if n <= 0 || head == nil { # return head # } # fast := head # for i := 1 ; i <= n && fast != nil ; i ++ { # fast = fast . Next # } # # if fast == nil { # return head . Next # } # # slow := head # for fast . Next != nil { # slow = slow . Next # fast = fast . Next # } # slow . Next = slow . Next . Next # return head
sort . Slice ( moves , func ( i , j int ) bool { # return moves [ i ]. Timestamp < moves [ j ]. Timestamp # }) # # if len ( moves ) == 0 { # return 0 , 0 # } # # var start , end uint 6 4 # # var count , maxCount int # # for i , move := range moves { # if move . Type == Enter { # count += move . Count # if count > maxCount { # start = move . Timestamp # end = moves [ i + 1 ]. Timestamp # } # } else if move . Type == Exit { # count -= move . Count # } # } # # return start , end
var maxPalindrome int 6 4 = 0 # for i := 1 0 0 ; i < 1 0 0 0 ; i ++ { # palindromePart := strconv . FormatInt ( int 6 4 ( i ), 1 0 ) # palindrome , err := strconv . ParseInt ( palindromePart + reverse ( palindromePart ), 1 0 , 3 2 ) # if err != nil { # fmt . Println ( err ) # return # } # if isMultiplicationOfTheeDigits ( palindrome ) && maxPalindrome < palindrome { # maxPalindrome = palindrome # } # } # fmt . Println ( maxPalindrome )
n := len ( dominoes ) # if n == 1 { # return 0 # } # hash , pairs := make ( map [ int ] int ), 0 # for _ , val := range dominoes { # newVal := changeVal ( val ) # pairs += hash [ newVal ] # hash [ newVal ]++ # } # return pairs
if len ( nums ) == 0 { # return nil # } # root := new ( TreeNode ) # root . Val = nums [ 0 ] # ch := make ( chan * TreeNode , len ( nums )) # ch <- root # nums = nums [ 1 :] # for i := 0 ; i < len ( nums ); i ++ { # tree := <- ch # if nums [ i ] == - 1 { # tree . Left = nil # } else { # tree . Left = & TreeNode { # Val : nums [ i ], # } # ch <- tree . Left # } # i ++ # if i == len ( nums ) || nums [ i ] == - 1 { # tree . Right = nil # } else { # tree . Right = & TreeNode { # Val : nums [ i ], # } # ch <- tree . Right # } # } # return root
if method == " STR " { # client := & http . Client {} # request , err := http . NewRequest ( method , url , nil ) # request . Header . Add (" STR ", " STR ") # # response , err := client . Do ( request ) # if err != nil || response . StatusCode != 2 0 0 { # log . Printf (" STR ", url , response . StatusCode , ReadRequest ( response . Body )) # } # resp_data , err := ioutil . ReadAll ( response . Body ) # if err != nil { # log . Fatalln ( err . Error ()) # } # return resp_data # } else if method == " STR " { # return nil # } # # return nil
var vals [] string # for nil != l { # vals = append ( vals , strconv . Itoa ( l . Val )) # l = l . Next # } # return strings . Join ( vals , " STR ")
m := map [ rune ] rune { # '(': ')', # '[': ']', # '{': '}', # } # stack := make ([] rune , len ( s )) # top := 0 # for _ , c := range s { # switch c { # case '(', '[', '{': # stack [ top ] = m [ c ] # top ++ # case ')', ']', '}': # if top > 0 && stack [ top - 1 ] == c { # top -- # } else { # return false # } # } # } # # return top == 0
for i := len ( s ) - 1 ; i >= 0 ; i -- { # if s [ i ] == " STR " { # s = s [ i + 1 :] # break # } # } # for i := len ( s ) - 1 ; i >= 0 ; i -- { # if s [ i ] == " STR " { # s = s [: i ] # break # } # } # return s
qs := [] question 1 0 3 0 { # # { # para 1 0 3 0 { 1 , 2 , 0 , 0 }, # ans 1 0 3 0 {[][] int {{ 0 , 0 }, { 0 , 1 }}}, # }, # # { # para 1 0 3 0 { 2 , 2 , 0 , 1 }, # ans 1 0 3 0 {[][] int {{ 0 , 1 }, { 0 , 0 }, { 1 , 1 }, { 1 , 0 }}}, # }, # # { # para 1 0 3 0 { 2 , 3 , 1 , 2 }, # ans 1 0 3 0 {[][] int {{ 1 , 2 }, { 0 , 2 }, { 1 , 1 }, { 0 , 1 }, { 1 , 0 }, { 0 , 0 }}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 3 0 , q . para 1 0 3 0 # fmt . Printf (" STR ", p , allCellsDistOrder ( p . R , p . C , p . r 0 , p . c 0 )) # } # fmt . Printf (" STR ")
return & node { # child : [ 2 6 ]* node {}, # empty : true , # }
fmt . Printf (" STR ", nil ) # fmt . Println (" STR ") # # var number * int # var dict map [ string ] int # fmt . Printf (" STR ", number ) # fmt . Printf (" STR ", dict ) # fmt . Println (" STR ") # # var m map [ int ] string # var ptr * int # var c chan int # var sl [] int # var f func () # var i interface {} # fmt . Printf (" STR ", m ) # fmt . Printf (" STR ", ptr ) # fmt . Printf (" STR ", c ) # fmt . Printf (" STR ", sl ) # fmt . Printf (" STR ", f ) # fmt . Printf (" STR ", i ) # fmt . Println (" STR ") #
m , n := len ( A ), len ( B ) # res := make ([] int , k ) # for i := max ( 0 , k - n ); i <= m && k - i >= 0 ; i ++ { # temp := combine ( choose ( A , i ), choose ( B , k - i )) # if isBigger ( temp , res , 0 , 0 ) { # res = temp # } # } # return res
f , err := os . Open ( filename ) # if err != nil { # panic ( err ) # } # defer f . Close () # return ioutil . ReadAll ( f )
robEven , robOdd := 0 , 0 # for i := 0 ; i < len ( nums ); i ++ { # if i % 2 == 0 { # robEven = max ( robEven + nums [ i ], robOdd ) # } else { # robOdd = max ( robEven , nums [ i ]+ robOdd ) # } # } # return max ( robEven , robOdd )
if v . Kind () != Ptr { # return v # } # return v . Elem ()
fmt . Println ( customSortString (" STR ", " STR "))
return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { # start := time . Now () # log . Printf (" STR ", r . Method , r . URL . Path ) # next . ServeHTTP ( w , r ) # log . Printf (" STR ", r . URL . Path , time . Since ( start )) # })
return ( a * a + b * b ) == c * c
pub := base 6 4 . StdEncoding . EncodeToString ( b . EncrypterPublic [:]) # nonce := base 6 4 . StdEncoding . EncodeToString ( b . Nonce [:]) # box := base 6 4 . StdEncoding . EncodeToString ( b . Box ) # # str := fmt . Sprintf (" STR ", # b . SchemaVersion , pub , nonce , box ) # return [] byte ( str )
nums := combine ( nums 1 , nums 2 ) # return medianOf ( nums )
res := make ([] string , n ) # # for i := range res { # x := i + 1 # switch { # case x % 1 5 == 0 : # res [ i ] = " STR " # case x % 5 == 0 : # res [ i ] = " STR " # case x % 3 == 0 : # res [ i ] = " STR " # default : # res [ i ] = strconv . Itoa ( x ) # } # } # # return res
ans := make ([] int , 0 , 0 ) # for _ , v := range nums { # if v & 1 != 0 { # ans = append ( ans , v ) # } # } # for _ , v := range nums { # if v & 1 == 0 { # ans = append ( ans , v ) # } # } # return ans
sufficientSubsetRec (& root , 0 , limit ) # return root
for i , interval := range intervals { # if newInterval . Start <= interval . End { # if newInterval . End < interval . Start { # return append ( append ( intervals [: i : i ], newInterval ), intervals [ i :]...) # } # # if newInterval . Start < interval . Start { # intervals [ i ]. Start = newInterval . Start # } # if newInterval . End > interval . End { # intervals [ i ]. End = newInterval . End # } # # j := i + 1 # for j < len ( intervals ) && intervals [ j ]. Start <= newInterval . End { # j ++ # } # if intervals [ j - 1 ]. End > intervals [ i ]. End { # intervals [ i ]. End = intervals [ j - 1 ]. End # } # return append ( intervals [: i + 1 ], intervals [ j :]...) # } # } # return append ( intervals , newInterval )
fmt . Println ( judgeCircle (" STR ")) # fmt . Println ( judgeCircle (" STR ")) # fmt . Println ( judgeCircle 2 (" STR ")) # fmt . Println ( judgeCircle 2 (" STR "))
for ; root != nil ; root = root . Right { # right := root . Right # root . Left , root . Right = nil , root . Left # # p := root # for p . Right != nil { # p = p . Right # } # p . Right = right # }
res := uint ( 0 ) # # for m >= 1 && n >= 1 { # if m == n { # return m << res # } # # m >>= 1 # n >>= 1 # res ++ # } # # return 0
land := [][] int { # { 0 , 1 , 0 , 0 }, # { 1 , 1 , 1 , 0 }, # { 0 , 1 , 0 , 0 }, # { 1 , 1 , 0 , 0 }} # # fmt . Println ( islandPerimeter ( land )) #
return n == nil
return b . ExpireNow ( time . Now ())
b = Beer { # ProductID : productID , # Name : name , # Category : category , # Type : beerType , # Brewer : brewer , # Country : country , # Price : price , # } # return
dp := make ([][] bool , len ( s )+ 1 ) # for i := 0 ; i < len ( s )+ 1 ; i ++ { # dp [ i ] = make ([] bool , len ( p )+ 1 ) # } # dp [ len ( s )][ len ( p )] = true # # for i := len ( s ); i >= 0 ; i -- { # for j := len ( p ) - 1 ; j >= 0 ; j -- { # fm := false # if i < len ( s ) && ( s [ i ] == p [ j ] || p [ j ] == '.') { # fm = true # } # # if ( j + 1 ) < len ( p ) && p [ j + 1 ] == '*' { # dp [ i ][ j ] = dp [ i ][ j + 2 ] || ( fm && dp [ i + 1 ][ j ]) # } else { # dp [ i ][ j ] = fm && dp [ i + 1 ][ j + 1 ] # } # } # } # return dp [ 0 ][ 0 ]
return MyCalendar { # order : [][ 2 ] int {}, # }
num := nums [ 0 ] # l , r := 0 , len ( nums )- 1 # for l < r { # for l < r && nums [ r ] <= num { # r -- # } # nums [ l ] = nums [ r ] # for l < r && nums [ l ] >= num { # l ++ # } # nums [ r ] = nums [ l ] # } # nums [ l ] = num # # if l + 1 == k { # return num # } else if l + 1 > k { # return findKthLargest ( nums [: l + 1 ], k ) # } else { # return findKthLargest ( nums [ l + 1 :], k - l - 1 ) # }
obj := Constructor 9 8 1 () # obj . Set (" STR ", " STR ", 1 ) # fmt . Printf (" STR ", obj . Get (" STR ", 1 )) # fmt . Printf (" STR ", obj . Get (" STR ", 3 )) # obj . Set (" STR ", " STR ", 4 ) # fmt . Printf (" STR ", obj . Get (" STR ", 4 )) # fmt . Printf (" STR ", obj . Get (" STR ", 5 ))
dp := make ([] int , amount + 1 ) # for i := 0 ; i < amount + 1 ; i ++ { # dp [ i ] = amount + 1 # } # dp [ 0 ] = 0 # # for i := 1 ; i <= amount ; i ++ { # for j := 0 ; j < len ( coins ); j ++ { # if coins [ j ] <= i { # dp [ i ] = min ( dp [ i ], dp [ i - coins [ j ]]+ 1 ) # # } # } # } # if dp [ amount ] > amount { # return - 1 # } # return dp [ amount ]
return new ( discModel ). init ()
if exp == " STR " || exp == " STR " { # return exp == " STR " # } # n := len ( exp ) # op , exp := exp [ 0 ], exp [ 2 : n - 1 ] # switch op { # case '&': # return and ( split ( exp )) # case '|': # return or ( split ( exp )) # default : # return not ( exp ) # }
sum = 0 # helper ( root ) # return root
hDiff , aMap := diff ( A , B )/ 2 , make ( map [ int ] int , len ( A )) # for _ , a := range A { # aMap [ a ] = a # } # for _ , b := range B { # if a , ok := aMap [ hDiff + b ]; ok { # return [] int { a , b } # } # } # return nil
if len ( vs ) == 0 { # panic (" STR ") # } # m := vs [ 0 ] # for _ , n := range vs [ 1 :] { # if n > m { # m = n # } # } # return m
device , err := readATDF ( filepath ) # if err != nil { # return err # } # err = writeGo ( outdir , device ) # if err != nil { # return err # } # err = writeAsm ( outdir , device ) # if err != nil { # return err # } # return writeLD ( outdir , device )
qs := [] question 1 0 0 2 { # # { # para 1 0 0 2 {[] string {" STR ", " STR ", " STR "}}, # ans 1 0 0 2 {[] string {" STR ", " STR ", " STR "}}, # }, # # { # para 1 0 0 2 {[] string {" STR ", " STR ", " STR "}}, # ans 1 0 0 2 {[] string {" STR ", " STR "}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 0 2 , q . para 1 0 0 2 # fmt . Printf (" STR ", p , commonChars ( p . one )) # } # fmt . Printf (" STR ")
tests := [...] testType { # { # paragraph : " STR ", # banned : [] string {" STR "}, # want : " STR ", # }, # { # paragraph : " STR ", # banned : [] string {" STR "}, # want : " STR ", # }, # { # paragraph : " STR ", # banned : [] string {}, # want : " STR ", # }, # } # for _ , tt := range tests { # got := mostCommonWord ( tt . paragraph , tt . banned ) # if got != tt . want { # t . Fatalf (" STR ", tt . paragraph , tt . banned , got , tt . want ) # } # }
var result uint 3 2 # for i := 0 ; i < 3 2 ; i ++ { # bit := num & 0 x 8 0 0 0 0 0 0 0 # num = num << 1 # result = ( result >> 1 ) | bit # } # # return result
p . m . Lock () # defer p . m . Unlock () # # if p . closed { # r . Close () # return # } # # select { # case p . resources <- r : # log . Println (" STR ", " STR ") # # default : # log . Println (" STR ", " STR ") # r . Close () # }
iE := i .(* linkedHeapListElement ) # return iE . Value .( int )
ans := 0 # for _ , c := range s { # ans *= 2 6 # ans += int ( c ) - ' A ' + 1 # } # return ans
var tests = [] struct { # tree * TreeNode # length int # }{ # { newTree ( 5 , 4 , 5 , 1 , 1 , nil , 5 ), 2 }, # { newTree ( 5 , 5 , 4 , nil , 5 , 1 , 1 ), 2 }, # { newTree ( 1 , 4 , 5 , 4 , 4 , nil , 5 ), 2 }, # { newTree ( 1 , 5 , 4 , 5 , nil , 4 , 4 ), 2 }, # { newTree ( 2 6 , 2 6 , 2 6 ), 2 }, # { newTree ( 2 6 , 2 6 , 2 6 , 2 6 , 2 6 ), 3 }, # } # # for _ , tt := range tests { # length := longestUnivaluePath ( tt . tree ) # if length != tt . length { # t . Errorf (" STR ", tt . tree , length , tt . length ) # } # }
flippedTime , count := 0 , 0 # for i := 0 ; i < len ( A ); i ++ { # if i >= K && A [ i - K ] == 2 { # flippedTime -- # } # if flippedTime % 2 == A [ i ] { # if i + K > len ( A ) { # return - 1 # } # A [ i ] = 2 # flippedTime ++ # count ++ # } # } # return count
result := make ([] int , row + 1 ) # for entry := range result { # result [ entry ] = combinations ( row , entry ) # } # # return result
if len ( s ) == 1 { # return [] string { s } # } # # perms := [] string {} # head := string ( s [ 0 ]) # tail := s [ 1 :] # # for _ , perm := range permute ( tail ) { # for i := 0 ; i < len ( s ); i ++ { # newperm := perm [: i ] + head + perm [ i :] # perms = append ( perms , newperm ) # } # } # return perms
res := 0 # for i := 1 ; i < len ( prices ); i ++ { # tmp := prices [ i ] - prices [ i - 1 ] # if tmp > 0 { # res += tmp # } # } # # return res
runes := [] rune ( s ) # for i , j := 0 , len ( runes )- 1 ; i < j ; i , j = i + 1 , j - 1 { # runes [ i ], runes [ j ] = runes [ j ], runes [ i ] # } # return string ( runes )
if root == nil { # return 0 # } # # var sum int # if root . Left != nil && root . Left . Left == nil && root . Left . Right == nil { # sum += root . Left . Val # } else { # sum += sumOfLeftLeaves ( root . Left ) # } # return sum + sumOfLeftLeaves ( root . Right )
expression = insertPlus ( expression ) # es := strings . Split ( expression , " STR ") # res := getFrac ( es [ 0 ]) # for i := 1 ; i < len ( es ); i ++ { # res = add ( res , getFrac ( es [ i ])) # } # return res . String ()
leftMax = arr [ 0 ] # for i := 0 ; i < index ; i ++ { # if arr [ i ] > leftMax { # leftMax = arr [ i ] # } # } # rightMax = arr [ len ( arr )- 1 ] # for i := index ; i <= len ( arr )- 1 ; i ++ { # if arr [ i ] > rightMax { # rightMax = arr [ i ] # } # } # return
archive := " STR " # files := [] string {" STR ", " STR "} # err := archiveFiles ( files , archive ) # if err != nil { # log . Fatalf (" STR ", err ) # } # err = readArchive ( archive ) # if err != nil { # log . Fatalf (" STR ", err ) # # }
if root == nil { # return nil # } # if key < root . Val { # root . Left = deleteNode ( root . Left , key ) # } else if key > root . Val { # root . Right = deleteNode ( root . Right , key ) # } else { # if root . Left == nil { # return root . Right # } else if root . Right == nil { # return root . Left # } # node := root . Right # for node . Left != nil { # node = node . Left # } # root . Val = node . Val # root . Right = deleteNode ( root . Right , root . Val ) # } # return root
arrSize := rand . Intn ( 1 0 0 ) + 5 0 # arrSize 1 := rand . Intn ( arrSize ) # arr := make ([] int , arrSize , arrSize ) # for i := range arr { # arr [ i ] = rand . Intn ( 1 0 0 ) # } # sortedArr := make ([] int , 0 , 0 ) # for i , v := range arr { # if i < arrSize 1 { # h 1 . Append ( v ) # } else { # h 2 . Append ( v ) # } # } # h 1 = h 1 . Union ( h 2 ).( heapIf ) # for h 1 . Len () > 0 { # sortedArr = append ( sortedArr , h 1 . Pop ().( int )) # } # sort . Sort ( sort . Reverse ( sort . IntSlice ( arr ))) # if ! reflect . DeepEqual ( sortedArr , arr ) { # t . Log ( fmt . Sprintf (" STR ", arr ) + fmt . Sprintf (" STR ", sortedArr )) # t . Fail () # }
tasks := make ( chan string , taskLoad ) # # wg . Add ( numberGoroutines ) # for gr := 1 ; gr <= numberGoroutines ; gr ++ { # go worker ( tasks , gr ) # } # # for post := 1 ; post <= taskLoad ; post ++ { # tasks <- fmt . Sprintf (" STR ", post ) # } # # close ( tasks ) # # wg . Wait ()
low , high := 0 , len ( nums )- 1 # for low < high { # if nums [ low ] < nums [ high ] { # return nums [ low ] # } # mid := low + ( high - low )>> 1 # if nums [ mid ] >= nums [ low ] { # low = mid + 1 # } else { # high = mid # } # } # return nums [ low ]
fmt . Println ( reverseString (" STR "))
return Post ( url , " STR ", strings . NewReader ( data . Encode ()))
_ , balanced := isHeightBalanced ( root ) # return balanced
ss , l := strings . Split ( str , " STR "), len ( pattern ) # m , e := make ( map [ byte ] string ), make ( map [ string ] bool ) # if len ( ss ) != l { # return false # } # for i := 0 ; i < l ; i ++ { # if s , ok := m [ pattern [ i ]]; ok { # if ss [ i ] != s { # return false # } # } else if e [ ss [ i ]] { # return false # } else { # m [ pattern [ i ]], e [ ss [ i ]] = ss [ i ], true # } # } # return true
n := len ( A ) # values := make ( map [ int ] int , n ) # res := make ([] int , n ) # # for i := range B { # values [ B [ i ]] = i # } # # for i := range res { # res [ i ] = values [ A [ i ]] # } # # return res
t . Parallel () # time . Sleep ( 1 * time . Second ) # input , expected := [] int { 7 , 8 , 1 0 }, 2 5 # result := Sum ( input ...) # if result != expected { # # t . Errorf (" STR ", result , expected ) # } #
return k . Matrix [ y * k . Width + x ]
cases := [] struct { # name string # root * TreeNode # expect int # }{ # {" STR ", & TreeNode { # Val : 1 , # Left : & TreeNode { Val : 2 }, # Right : & TreeNode { Val : 3 }, # }, 6 }, # {" STR ", & TreeNode { # - 1 0 , # & TreeNode { Val : 9 }, # & TreeNode { # 2 0 , # & TreeNode { Val : 1 5 }, # & TreeNode { Val : 7 }, # }, # }, 4 2 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . root ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . root ) # } # }) # }
n := len ( a ) # sort . Ints ( a ) # # low := a [ 1 ] - a [ 0 ] # for i := 2 ; i < n ; i ++ { # low = min ( low , a [ i ]- a [ i - 1 ]) # } # # high := a [ n - 1 ] - a [ 0 ] # for low < high { # mid := low + ( high - low )/ 2 # if count ( a , mid ) < k { # low = mid + 1 # } else { # high = mid # } # } # # return low
data := make ([] int , len ( nums )) # copy ( data , nums ) # maxKadane := KadaneAlg ( data ) # maxWrap := 0 # for i , v := range data { # maxWrap += v # data [ i ] = - data [ i ] # } # maxWrap += KadaneAlg ( data ) # return max ( maxWrap , maxKadane )
return new ( replace ). init ( cost )
total := ss . avg * Price ( ss . n ) # # if prev , exists := ss . data [ d . Timestamp ]; exists { # ss . data [ d . Timestamp ] = d # ss . avg = ( total + d . Price - prev . Price ) / Price ( ss . n ) # # if d . Price < ss . min || d . Price > ss . max { # ss . min , ss . max = ss . recalculateMinMax () # } # } else { # if d . Price > ss . max { # ss . max = d . Price # } # if d . Price < ss . min { # ss . min = d . Price # } # ss . n ++ # ss . avg = ( total + d . Price ) / Price ( ss . n ) # ss . data [ d . Timestamp ] = d # }
increment := len ( arr ) / 2 # for increment > 0 { # for i := increment ; i < len ( arr ); i ++ { # j := i # temp := arr [ i ] # # for j >= increment && arr [ j - increment ] > temp { # arr [ j ] = arr [ j - increment ] # j = j - increment # } # arr [ j ] = temp # } # if increment == 2 { # increment = 1 # } else { # increment = int ( increment * 5 / 1 1 ) # } # }
data := [][] int {{ 1 , 2 , 3 , 4 }, { 5 , 1 , 2 , 3 }, { 9 , 5 , 1 , 2 }} # fmt . Println ( isToeplitzMatrix ( data ))
n 1 := len ( s 1 ) # n 2 := len ( s 2 ) # if n 1 > n 2 { # return false # } # # count := 0 # for i := 0 ; i < n 1 ; i ++ { # count += 1 << ( s 1 [ i ] - ' a ') # count -= 1 << ( s 2 [ i ] - ' a ') # } # # if count == 0 { # return true # } # # for i := n 1 ; i < n 2 ; i ++ { # count += ( 1 << ( s 2 [ i - n 1 ] - ' a ')) - ( 1 << ( s 2 [ i ] - ' a ')) # if count == 0 { # return true # } # } # # return false
if n == 2 || n == 3 { # return true # } # if n < 2 || n % 2 == 0 { # return false # } # if n < 9 { # return true # } # if n % 3 == 0 { # return false # } # r := math . Sqrt ( float 6 4 ( n )) # f := 5 # for float 6 4 ( f ) <= r { # if n % f == 0 { # return false # } # if n %( f + 2 ) == 0 { # return false # } # f += 6 # } # return true
a , b := 1 1 , 6 # bezout_a , bezout_b := getCoeff ( 1 1 , 6 ) # # if bezout_a * a + bezout_b * b != 1 { # fmt . Println ( a , b , a * 1 1 + b * 6 ) # t . Error () # } # # a , b = 1 2 , 6 # bezout_a , bezout_b = getCoeff ( 1 2 , 6 ) # # if bezout_a * a + bezout_b * b != 6 { # fmt . Println ( a , b , a * 1 1 + b * 6 ) # t . Error () # }
result := uint ( 1 ) # for i := uint ( 0 ); i < y ; i ++ { # result *= x # } # return result
return i .( int ) >> 1
return acc + n
var av atomic . Value # for _ , val := range values { # av . Store ( val ) # loadedVal := av . Load () # if loadedVal != val { # println (" STR ", val , " STR ", loadedVal ) # } # }
rets := [][] int {} # if n <= 0 || k <= 0 || n < k { # return rets # } # currentInt := make ([] int , k ) # solution := [] int {} # depth := - 1 # maxDepth := k - 1 # for { # L : # for depth < maxDepth { # for { # childDepth := depth + 1 # preInt := currentInt [ childDepth ] # if preInt == n { # currentInt [ childDepth ] = 0 # break L # } # currentInt [ childDepth ]++ # if depth == - 1 || currentInt [ childDepth ] > currentInt [ depth ] { # solution = append ( solution , currentInt [ childDepth ]) # break # } # } # depth ++ # } # if depth == maxDepth { # cp := make ([] int , len ( solution )) # copy ( cp , solution ) # rets = append ( rets , cp ) # } # if depth == - 1 { # break # } # depth -- # solution = solution [: len ( solution )- 1 ] # } # return rets
type A struct { # Name string ` structs :" STR "` # IP string ` structs :" STR "` # Query string ` structs :" STR "` # Payload interface {} ` structs :" STR "` # } # # a := A { # Name : " STR ", # IP : " STR ", # Query : "", # Payload : map [ string ] string {" STR ": " STR "}, # } # # defer func () { # err := recover () # if err != nil { # t . Error (" STR ") # } # }() # # _ = Map ( a )
low , high := 0 , len ( nums )- 1 # for low <= high { # mid := low + ( high - low )>> 1 # if nums [ mid ] == target { # return mid # } else if nums [ mid ] > target { # high = mid - 1 # } else { # low = mid + 1 # } # } # return - 1
tests := [...] testType { # { # in : 2 , # want : 1 , # }, # { # in : 3 , # want : 2 , # }, # { # in : 4 , # want : 3 , # }, # { # in : 1 , # want : 1 , # }, # } # for _ , tt := range tests { # got := fib ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
m := url . Values {" STR ": {" STR "}} # m . Add (" STR ", " STR ") # m . Add (" STR ", " STR ") # # fmt . Println ( m . Get (" STR ")) # fmt . Println ( m . Get (" STR ")) # fmt . Println ( m . Get (" STR ")) # fmt . Println ( m [" STR "]) # # m = nil # fmt . Println ( m . Get (" STR ")) # m . Add (" STR ", " STR ")
min := - 9 9 9 # max := 1 0 0 0 # # var primes , maximumPrimes , maxA , maxB int # for a := min ; a < max ; a ++ { # for b := min ; b < max ; b ++ { # primes = numberOfPrimes ( a , b ) # if primes > maximumPrimes { # maximumPrimes = primes # maxA = a # maxB = b # } # } # } # fmt . Println ( maxA * maxB )
t . Parallel () # for _ , tc := range nonNegativeTestcases { # if result := ContiguousSumBrute ( tc . input , tc . k ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # } # for _ , tc := range negativeTestcases { # if result := ContiguousSumBrute ( tc . input , tc . k ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
if tree . root == nil { # tree . root = & TreeNode { Val : v } # return # } # # q := make ([]* TreeNode , 0 ) # q = append ( q , tree . root ) # for len ( q ) > 0 { # curNode := q [ 0 ] # q = q [ 1 :] # # if curNode . Left != nil { # q = append ( q , curNode . Left ) # } else { # curNode . Left = & TreeNode { Val : v } # return # } # # if curNode . Right != nil { # q = append ( q , curNode . Right ) # } else { # curNode . Right = & TreeNode { Val : v } # return # } # }
m := make ( map [ int ] int ) # # for i , num := range nums { # if j , ok := m [ target - num ]; ok { # return [] int { j , i } # } # m [ num ] = i # } # return nil
l 1 , l 2 := len ( s 1 ), len ( s 2 ) # d := gcd ( max ( l 1 , l 2 ), min ( l 1 , l 2 )) # p := s 2 [: d ] # if s 1 == strings . Repeat ( p , l 1 / d ) && # s 2 == strings . Repeat ( p , l 2 / d ) { # return p # } # return " STR "
low , high := 0 , len ( citations )- 1 # for low <= high { # mid := low + ( high - low )>> 1 # if len ( citations )- mid > citations [ mid ] { # low = mid + 1 # } else { # high = mid - 1 # } # } # return len ( citations ) - low
sortString := func ( str string ) string { # bytes := [] byte ( str ) # sort . Slice ( bytes , func ( i , j int ) bool { # return bytes [ i ] < bytes [ j ] # }) # # return string ( bytes ) # } # # sortedToAnagrams := make ( map [ string ][] string ) # for _ , str := range strs { # sorted := sortString ( str ) # anagrams , exists := sortedToAnagrams [ sorted ] # if ! exists { # anagrams = make ([] string , 0 ) # } # # sortedToAnagrams [ sorted ] = append ( anagrams , str ) # } # # result := make ([][] string , 0 ) # for _ , anagrams := range sortedToAnagrams { # result = append ( result , anagrams ) # } # # return result
negative := ( numerator > 0 && denominator < 0 ) || ( numerator < 0 && denominator > 0 ) # if numerator < 0 { # numerator = - numerator # } # # if denominator < 0 { # denominator = - denominator # } # # result := " STR " # if numerator % denominator == 0 { # result = strconv . Itoa ( numerator / denominator ) # } else { # result = strconv . Itoa ( numerator / denominator ) + " STR " + fractionToDecimalCore ( numerator % denominator , denominator ) # } # # if negative { # return " STR " + result # } # # return result
if head == nil { # return head # } # var ( # odd = head # evenHead = head . Next # even = evenHead # ) # for even != nil && even . Next != nil { # odd . Next = even . Next # odd = odd . Next # even . Next = odd . Next # even = even . Next # } # odd . Next = evenHead # return head
count := [ 2 6 ] int {} # for _ , t := range tiles { # count [ t -' A ']++ # } # # var dfs func () int # dfs = func () int { # sum := 0 # for i := 0 ; i < 2 6 ; i ++ { # if count [ i ] == 0 { # continue # } # sum ++ # count [ i ]-- # sum += dfs () # count [ i ]++ # } # return sum # } # # return dfs ()
start , maxLen , l := 0 , 0 , len ( s ) # for i := 0 ; i < l ; i ++ { # expandAroundCenter ( s , i , i , & start , & maxLen ) # expandAroundCenter ( s , i , i + 1 , & start , & maxLen ) # } # return s [ start : start + maxLen ]
n := len ( nums ) # l , r := 0 , - 1 # # min , max := nums [ n - 1 ], nums [ 0 ] # # for i := 1 ; i < n ; i ++ { # if max <= nums [ i ] { # max = nums [ i ] # } else { # r = i # } # # j := n - i - 1 # if min >= nums [ j ] { # min = nums [ j ] # } else { # l = j # } # } # return r - l + 1
p . mu . Lock () # p . list = make ([] interface {}, 0 , cap ( p . list )/ 2 ) # p . mu . Unlock ()
return & Struct { # raw : s , # value : strctVal ( s ), # TagName : DefaultTagName , # }
var row , col , block [ 9 ][ 5 8 ] bool # for k , nums := range board { # for i , v := range nums { # if v == '.' { # continue # } # if row [ i ][ v ] { # return false # } # if col [ k ][ v ] { # return false # } # if block [ i / 3 + k / 3 * 3 ][ v ] { # return false # } # row [ i ][ v ] = true # col [ k ][ v ] = true # block [ i / 3 + k / 3 * 3 ][ v ] = true # } # } # return true
data := ListQueue [ 0 ] # ListQueue = ListQueue [ 1 :] # return data
lq . queue . PushBack ( value )
cases := [] struct { # name string # inputs int # expect int # }{ # {" STR ", 1 0 , 4 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := countPrimes ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
matrix := make ([][] bool , len ( s )) # for i := range matrix { # matrix [ i ] = make ([] bool , len ( s )) # } # for i := len ( matrix ) - 1 ; i >= 0 ; i -- { # for j := i ; j < len ( matrix [ i ]); j ++ { # if j == i || s [ i ] == s [ j ] && ( i + 1 == j || matrix [ i + 1 ][ j - 1 ]) { # matrix [ i ][ j ] = true # } # } # } # # p := len ( s ) - 1 # for ; p >= 0 ; p -- { # if matrix [ 0 ][ p ] { # break # } # } # return reverse ( s [ p + 1 :]) + s
return A . Elements [ i * A . step + j ]
max , cur := 0 , 1 # for i , v := range nums { # if i >= 1 && v > nums [ i - 1 ] { # cur ++ # } else { # cur = 1 # } # if cur > max { # max = cur # } # } # return max
return len ( t )
x := sumOfSquares ( 1 , 0 ) # y := squareOfSum ( 1 , 0 ) # # print ( y - x )
tags := [] struct { # tag string # has bool # }{ # {"", false }, # {" STR ", true }, # {" STR ", true }, # {" STR ", false }, # {" STR ", false }, # } # # for _ , tag := range tags { # name , _ := parseTag ( tag . tag ) # # if ( name != " STR ") && tag . has { # t . Errorf (" STR ", tag ) # } # }
return r . Current ( time . Now ())
fives , tens := 0 , 0 # # for _ , b := range bills { # switch b { # case 5 : # fives ++ # case 1 0 : # fives -- # tens ++ # case 2 0 : # if tens > 0 { # tens -- # fives -- # } else { # fives -= 3 # } # } # if fives < 0 || tens < 0 { # return false # } # } # # return true
p := [] uint { 2 , 3 , 5 , 7 , 1 1 , 1 3 , 1 7 , 1 9 , 2 3 , 2 9 , 3 1 } # r := uint ( 1 ) # var d uint # for i := range p { # d = p [ i ] # for d <= k { # d *= p [ i ] # } # d /= p [ i ] # r *= d # } # return r
r , b := 0 , len ( nums )- 1 # for i := 0 ; i <= b ; i ++ { # if nums [ i ] == 0 { # nums [ i ], nums [ r ] = nums [ r ], nums [ i ] # r ++ # } else if nums [ i ] == 2 { # nums [ i ], nums [ b ] = nums [ b ], nums [ i ] # b -- # i -- # } # } # return
return (* p )[ i ]. x < (* p )[ j ]. x
n := len ( arr ) # if n > 1 { # for i := 0 ; i < n ; i ++ { # if arr [ i ] == 0 { # for j := n - 1 ; j > i ; j -- { # arr [ j ] = arr [ j - 1 ] # } # i ++ # } # } # }
stack := make ([] int , 1 , len ( hist )) # stack [ 0 ] = - 1 # var result int # for i := range hist { # for stack [ len ( stack )- 1 ] != - 1 && hist [ stack [ len ( stack )- 1 ]] >= hist [ i ] { # last := stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # result = max ( result , hist [ last ]*( i - stack [ len ( stack )- 1 ]- 1 )) # } # stack = append ( stack , i ) # } # for stack [ len ( stack )- 1 ] != - 1 { # last := stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # result = max ( result , hist [ last ]*( len ( hist )- stack [ len ( stack )- 1 ]- 1 )) # } # return result
n := len ( A ) # sort . Ints ( A ) # res := A [ n - 1 ] - A [ 0 ] # p , q := A [ n - 1 ]- K , A [ 0 ]+ K # for i := 0 ; i < n - 1 ; i ++ { # res = min ( res , max ( p , A [ i ]+ K )- min ( q , A [ i + 1 ]- K )) # } # return res
n := len ( target ) # m := 1 << uint ( n ) # dp := make ([] int , m ) # for i := 1 ; i < m ; i ++ { # dp [ i ] = math . MaxInt 3 2 # } # for i := 0 ; i < m ; i ++ { # if dp [ i ] == math . MaxInt 3 2 { # continue # } # for _ , s := range stickers { # sup := i # for _ , c := range s { # for r := 0 ; r < n ; r ++ { # if target [ r ] == byte ( c ) && (( uint ( sup )>> uint ( r ))& 1 ) == 0 { # sup |= 1 << uint ( r ) # break # } # } # } # if dp [ i ]+ 1 < dp [ sup ] { # dp [ sup ] = dp [ i ] + 1 # } # } # } # if dp [ m - 1 ] != math . MaxInt 3 2 { # return dp [ m - 1 ] # } # return - 1
var one , two int # for _ , n := range nums { # two |= one & n # one ^= n # three := one & two # one &= ^ three # two &= ^ three # } # return one
t . Parallel () # for _ , tc := range testcases { # if result := SevenishNumber ( tc . n ); result != tc . expected { # t . Errorf (" STR ", tc . n , tc . expected , result ) # } # }
return l . len
var res int # for i := range s { # sMap := make ( map [ byte ] bool ) # q := 0 # for q + i < len ( s ) { # if sMap [ s [ q + i ]] { # break # } else { # sMap [ s [ q + i ]] = true # } # q ++ # } # if q > res { # res = q # } # if q >= len ( s )- i { # break # } # } # return res
if k == 0 || head == nil { # return head # } # # first := head # for i := 0 ; i < k ; i ++ { # if first . Next == nil { # return rotateRight ( head , k %( i + 1 )) # } # first = first . Next # } # # second := head # for first . Next != nil { # second , first = second . Next , first . Next # } # # newHead := second . Next # second . Next , first . Next = nil , head # # return newHead
counter := 0 # for i := L ; i <= R ; i ++ { # if isPrime ( bits . OnesCount ( uint ( i ))) { # counter ++ # } # } # return counter
b := [] byte ( s ) # i , j := - 1 , len ( b ) # for { # for i + 1 < len ( b ) && ! isVowel ( b [ i + 1 ]) { # i ++ # } # i ++ # for j - 1 > i && ! isVowel ( b [ j - 1 ]) { # j -- # } # j -- # # if i >= j { # break # } # b [ i ], b [ j ] = b [ j ], b [ i ] # } # return string ( b )
if ele , ok := c . cache [ key ]; ok { # c . ll . MoveToFront ( ele ) # kv := ele . Value .(* entry ) # kv . value = value # return # } # ele := c . ll . PushFront (& entry { key , value }) # c . cache [ key ] = ele # c . nbytes += int 6 4 ( len ( key )) + int 6 4 ( value . Len ()) # # for c . maxBytes != 0 && c . maxBytes < c . nbytes { # c . RemoveOldest () # }
n := len ( array ) # count := 0 # # for i := 0 ; i < n ; i ++ { # for j := i + 1 ; j < n ; j ++ { # if array [ j ] < array [ i ] { # count ++ # } # } # } # return count
b , err := json . Marshal ( data ) # if err != nil { # return " STR " # } # # return string ( b )
p . Drain () # p . mu . Lock () # p . list = make ([] interface {}, 0 ) # if p . drainTicker != nil { # p . drainTicker . Stop () # p . drainTicker = nil # } # p . mu . Unlock ()
if nil == nums 1 || len ( nums 1 ) == 0 { # return nums 1 # } # if nil == nums 2 || len ( nums 2 ) == 0 { # return nums 2 # } # # dict 1 := make ( map [ int ] int , 1 ) # dict 2 := make ( map [ int ] int , 1 ) # for _ , v := range nums 1 { # dict 1 [ v ]++ # } # for _ , v := range nums 2 { # dict 2 [ v ]++ # } # # ans := make ([] int , 0 ) # for k := range dict 1 { # if _ , ok := dict 2 [ k ]; ok { # ans = append ( ans , k ) # } # } # return ans
qs := [] question 1 0 4 4 { # { # para 1 0 4 4 {" STR "}, # ans 1 0 4 4 {" STR "}, # }, # # { # para 1 0 4 4 {" STR "}, # ans 1 0 4 4 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 4 4 , q . para 1 0 4 4 # fmt . Printf (" STR ", p , longestDupSubstring ( p . one )) # } # fmt . Printf (" STR ")
x := 1 . 5 # square (& x ) # fmt . Println ( x )
n := len ( points ) # if n < 3 { # return 0 # } # res := 0 # for i := 0 ; i < n ; i ++ { # m := make ( map [ int ] int , n ) # for j := 0 ; j < n ; j ++ { # if i == j { # continue # } # x := points [ j ][ 0 ] - points [ i ][ 0 ] # y := points [ j ][ 1 ] - points [ i ][ 1 ] # dist := x * x + y * y # m [ dist ]++ # } # for _ , v := range m { # res += v * ( v - 1 ) # } # } # return res
str := string ( getContributorBufer ()) # return str
var result [] string # helper (& result , digits , " STR ", 0 ) # return result
head := root # var max * TreeNode # # for root != nil { # if root . Left == nil { # root = root . Right # } else { # max = root . Left # for max . Right != nil { # max = max . Right # } # # root . Right , max . Right = root . Left , root . Right # root . Left = nil # } # } # return head
maxProduct := 0 # # for i := 9 0 0 0 ; i < 1 0 0 0 0 ; i ++ { # if product := pandigitalProduct ( i ); product > maxProduct { # maxProduct = product # fmt . Println ( maxProduct ) # } # }
if len ( s ) != len ( t ) { # return false # } # m := map [ byte ] byte {} # n := map [ byte ] byte {} # for i := range s { # if _ , ok := m [ t [ i ]]; ! ok { # m [ t [ i ]] = s [ i ] # } # if _ , ok := n [ s [ i ]]; ! ok { # n [ s [ i ]] = t [ i ] # } # if s [ i ] != m [ t [ i ]] { # return false # } # if t [ i ] != n [ s [ i ]] { # return false # } # } # return true
depth := getDepth ( root , 0 ) + 1 # width := 1 << uint ( depth ) - 1 # res := make ([][] string , depth ) # for i := range res { # res [ i ] = make ([] string , width ) # } # var recur func (* TreeNode , int , int ) # recur = func ( node * TreeNode , level , bin int ) { # if node == nil { # return # } # span := width >> uint ( level ) # res [ level ][ span * bin + bin + span / 2 ] = strconv . Itoa ( node . Val ) # recur ( node . Left , level + 1 , 2 * bin ) # recur ( node . Right , level + 1 , 2 * bin + 1 ) # } # recur ( root , 0 , 0 ) # return res
t . Parallel () # for _ , tc := range testcases { # if result := CountIslands ( tc . grid ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
if root == nil || a > b { # return 0 # } # leftSum := SumBSTRange ( root . Left , a , root . Val ) # rightSum := SumBSTRange ( root . Right , root . Val , b ) # if root . Val >= a && root . Val <= b { # return root . Val + leftSum + rightSum # } # return leftSum + rightSum
if 0 >= index { # return 0 # } # # uglyNumbers := make ([] int , index ) # uglyNumbers [ 0 ] = 1 # nextUglyIndex := 1 # # var pMultiply 2 , pMultiply 3 , pMultiply 5 int # for nextUglyIndex < index { # uglyNumbers [ nextUglyIndex ] = min 3 ( uglyNumbers [ pMultiply 2 ]* 2 , uglyNumbers [ pMultiply 3 ]* 3 , uglyNumbers [ pMultiply 5 ]* 5 ) # # for uglyNumbers [ pMultiply 2 ]* 2 <= uglyNumbers [ nextUglyIndex ] { # pMultiply 2 ++ # } # for uglyNumbers [ pMultiply 3 ]* 3 <= uglyNumbers [ nextUglyIndex ] { # pMultiply 3 ++ # } # for uglyNumbers [ pMultiply 5 ]* 5 <= uglyNumbers [ nextUglyIndex ] { # pMultiply 5 ++ # } # nextUglyIndex ++ # } # return uglyNumbers [ index - 1 ]
if len ( S ) == 2 || len ( S ) == 0 { # return S # } # # res := [] string {} # count , i := 0 , 0 # # for j , b := range S { # if b == ' 1 ' { # count ++ # } else { # count -- # } # # if count == 0 { # res = append ( res , " STR "+ makeLargestSpecial ( S [ i + 1 : j ])+" STR ") # i = j + 1 # } # } # # sort . Sort ( sort . Reverse ( sort . StringSlice ( res ))) # # return strings . Join ( res , " STR ")
ans , n := 0 , x ^ y # for n > 0 { # ans , n = ans + 1 , n &( n - 1 ) # } # return ans
for _ , test := range searchTests { # actual := Linear ( test . data , test . key ) # if actual != test . expected { # t . Errorf (" STR ", test . name ) # } # }
for i , child := 0 , 1 ; i < h . Len () && i << 1 + 1 < h . Len (); i = child { # child = i << 1 + 1 # # if child + 1 <= h . Len ()- 1 && h . Less ( h . Get ( child + 1 ), h . Get ( child )) { # child ++ # } # # if h . Less ( h . Get ( i ), h . Get ( child )) { # break # } # # h . data [ i ], h . data [ child ] = h . data [ child ], h . data [ i ] # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 8 , 6 , 2 , 5 , 4 , 8 , 3 , 7 }, 4 9 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := maxArea ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
n := len ( A ) # res := 0 # for k := 2 ; k < n && k < n - res + 2 ; k ++ { # l , r := 0 , k - 1 # for l < r { # s := A [ l ] + A [ r ] # if s == A [ k ] { # count := 3 # i , j := r , k # for { # next := A [ i ] + A [ j ] # i , j = j , j + sort . SearchInts ( A [ j :], next ) # if j == n || A [ j ] != next { # break # } # count ++ # } # if count > res { # res = count # } # l ++ # r -- # } else if s < A [ k ] { # l ++ # } else { # r -- # } # } # } # return res
h := NewMax () # # h . Insert ( Int ( 8 )) # h . Insert ( Int ( 7 )) # h . Insert ( Int ( 6 )) # h . Insert ( Int ( 3 )) # h . Insert ( Int ( 1 )) # h . Insert ( Int ( 0 )) # h . Insert ( Int ( 2 )) # h . Insert ( Int ( 4 )) # h . Insert ( Int ( 9 )) # h . Insert ( Int ( 5 )) # # sorted := make ([] Int , 0 ) # for h . Len () > 0 { # sorted = append ( sorted , h . Extract ().( Int )) # } # # for i := 0 ; i < len ( sorted )- 2 ; i ++ { # if sorted [ i ] < sorted [ i + 1 ] { # fmt . Println ( sorted ) # t . Error () # } # }
return & Pool { Dial : newFn , MaxIdle : maxIdle }
c := NewCircularBuffer ( 1 0 ) # # go func () { # for i := 0 ; i < 4 ; i ++ { # v := c . Get ().( int ) # if i != v { # t . Error ( i ) # } # } # # if c . verifyIsEmpty () != true { # t . Error (" STR ") # } # }() # # c . NBPush ( 0 ) # c . NBPush ( 1 ) # c . NBPush ( 2 ) # c . NBPush ( 3 )
result := make ([] string , 0 ) # for i := 0 ; i < len ( s )- 1 ; i ++ { # if s [ i ] == '+' && s [ i + 1 ] == '+' { # chars := [] byte ( s ) # chars [ i ], chars [ i + 1 ] = '-', '-' # result = append ( result , string ( chars )) # } # } # # return result
cases := [] struct { # name string # inputs int # expect [] int # }{ # {" STR ", 5 , [] int {- 7 , - 1 , 1 , 3 , 4 }}, # {" STR ", 4 , [] int {- 2 , - 1 , 1 , 2 }}, # {" STR ", 3 , [] int {- 1 , 0 , 1 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # res := checkResult ( got ) # if res != 0 { # t . Fatalf (" STR ", res , c . inputs ) # } # }) # }
left := 0 # right := len ( arr ) - 1 # for left <= right { # mid := left + (( right - left ) >> 1 ) # if arr [ mid ] == target { # return arr [ mid ], mid # } else if arr [ mid ] < arr [ right ] { # if arr [ mid ] < target && arr [ right ] >= target { # left = mid + 1 # } else { # right = mid - 1 # } # } else { # if arr [ left ] <= target && arr [ mid ] > target { # right = mid - 1 # } else { # left = mid + 1 # } # } # } # return target , - 1
cases := [] struct { # name string # inputs [] string # expect bool # }{ # {" STR ", [] string {" STR ", " STR "}, true }, # {" STR ", [] string {" STR ", " STR "}, false }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := isAnagram ( c . inputs [ 0 ], c . inputs [ 1 ]) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
t . Parallel () # # var p BytePool # p . Init ( 1 * time . Millisecond , 1 2 8 ) # p . Put ( make ([] byte , 1 2 7 )) # time . Sleep ( 1 0 0 * time . Millisecond ) # # if p . entries () != 0 { # t . Fatal (" STR ") # } # p . Close ()
return num &( num - 1 ) == 0 && num & 0 x 5 5 5 5 5 5 5 5 > 0
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", [][] int { # { 1 , 2 , 3 }, # { 1 , 1 }, # }, 1 }, # {" STR ", [][] int { # { 1 , 2 }, # { 1 , 2 , 3 }, # }, 2 }, # } # # for i , c := range cases { # t . Run ( c . name + strconv . Itoa ( i ), func ( t * testing . T ) { # got := findContentChildren ( c . inputs [ 0 ], c . inputs [ 1 ]) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
t . Parallel () # # for _ , tc := range testcases { # if reversed := ReverseDirectedGraph ( tc . g ); ! reflect . DeepEqual ( reversed , tc . reversed ) { # t . Errorf (" STR ", tc . reversed , reversed ) # } # }
size := len ( nums ) # switch size { # case 0 : # return 0 # case 1 : # return nums [ 0 ] # } # return max ( robbing ( nums [ 1 :]), robbing ( nums [: size - 1 ]))
n := t . gbt . Insert ( node ).(* gbtElement ) # t . setColor ( n , red ) # t . insertFix ( n ) # return n
mux := http . NewServeMux () # mux . Handle (" STR ", http . HandlerFunc ( index )) # mux . Handle (" STR ", http . HandlerFunc ( welcome )) # mux . Handle (" STR ", http . HandlerFunc ( message )) # log . Println (" STR ") # http . ListenAndServe (" STR ", mux )
ak := - 1 << 3 1 # ajStack := make ([] int , 0 , len ( a )) # # for i := len ( a ) - 1 ; 0 <= i ; i -- { # # if a [ i ] < ak { # return true # } # # for len ( ajStack ) > 0 && # ajStack [ len ( ajStack )- 1 ] < a [ i ] { # ak = ajStack [ len ( ajStack )- 1 ] # ajStack = ajStack [: len ( ajStack )- 1 ] # # } # # ajStack = append ( ajStack , a [ i ]) # } # # return false
t . Parallel () # for tcid , tc := range testcases { # if valid := IsValidCrossword ( tc . puzzle ); valid != tc . isValid { # t . Errorf (" STR ", tcid , tc . isValid , valid ) # } # }
size := len ( prices ) # if size <= 1 { # return 0 # } # # if k >= size { # return profits ( prices ) # } # # local := make ([] int , k + 1 ) # global := make ([] int , k + 1 ) # # for i := 1 ; i < size ; i ++ { # diff := prices [ i ] - prices [ i - 1 ] # for j := k ; j >= 1 ; j -- { # local [ j ] = max ( global [ j - 1 ]+ max ( diff , 0 ), local [ j ]+ diff ) # global [ j ] = max ( local [ j ], global [ j ]) # } # } # # return global [ k ]
defer TimeTaken ( time . Now (), " STR ") # # value := 0 # for i := 0 ; i < 1 0 0 0 ; i ++ { # if i % 3 == 0 || i % 5 == 0 { # value += i # } # } # fmt . Println ( value )
var result [][] int # helper ( nums , & result , [] int {}, 0 ) # return result
node := head # for node != nil { # clone := & Node 1 3 8 { # Val : node . Val , # Next : node . Next , # } # # node . Next = clone # node = clone . Next # } # # node = head # for node != nil { # clone := node . Next # random := node . Random # if random != nil { # clone . Random = random . Next # } # # node = clone . Next # } # # newNode := & Node 1 3 8 {} # dummy , node := newNode , head # for node != nil { # clone := node . Next # newNode . Next = clone # newNode = newNode . Next # # node . Next = clone . Next # node = node . Next # } # # return dummy . Next
l , _ := strconv . ParseInt ( L , 1 0 , 0 ) # r , _ := strconv . ParseInt ( R , 1 0 , 0 ) # # left := int ( math . Sqrt ( float 6 4 ( l ))) # right := int ( math . Sqrt ( float 6 4 ( r ))) # ll , lr := len ( strconv . Itoa ( left )), len ( strconv . Itoa ( right )) # # res := 0 # L : # for n := ll ; n < lr + 1 ; n ++ { # for _ , p := range genP ( n )[ 1 :] { # if p < left { # continue # } # if p > right { # break L # } # if isP ( p * p ) { # res ++ # } # } # } # return res
if head == nil || head . Next == nil { # return head # } # # newHead := head . Next # for head != nil && head . Next != nil { # first , second := head , head . Next # # next := second . Next # if next != nil && next . Next != nil { # next = next . Next # } # # head = second . Next # first . Next , second . Next = next , first # } # return newHead
qs := [] question 4 6 3 { # # { # para 4 6 3 {[][] int {{ 0 , 1 , 0 , 0 }, { 1 , 1 , 1 , 0 }, { 0 , 1 , 0 , 0 }, { 1 , 1 , 0 , 0 }}}, # ans 4 6 3 { 1 6 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 6 3 , q . para 4 6 3 # fmt . Printf (" STR ", p , islandPerimeter ( p . one )) # } # fmt . Printf (" STR ")
if head == nil { # return nil # } # # head . Left = PruneZeroSubtrees ( head . Left ) # head . Right = PruneZeroSubtrees ( head . Right ) # # if head . Value == 0 && head . Left == nil && head . Right == nil { # return nil # } # # return head
num := 3 8 # for ( num / 1 0 ) > 0 { # d := 0 # for num > 0 { # d += num % 1 0 # num /= 1 0 # } # num = d # } # fmt . Println ( num ) # # var num 2 = 3 8 # res := ( num 2 - 1 )% 9 + 1 # fmt . Println ( res )
fmt . Println ( countWaysToMake ( 2 0 0 , allCoins ))
fmt . Println ( restoreIpAddresses (" STR "))
var funcList [] func () int # for _ , i := range [] int { 1 , 2 , 3 } { # funcList = append ( funcList , func () int { # return i # }) # } # return funcList
var i , num int # sign := 1 # if str == " STR " { # return 0 # } # for i < len ( str ) && str [ i ] == 3 2 { # i ++ # } # # if i >= len ( str ) { # return 0 # } # # if str [ i ] == 4 3 { # i ++ # } else if str [ i ] == 4 5 { # sign = - 1 # i ++ # } # for ; i < len ( str ); i ++ { # if str [ i ] != 0 && ( str [ i ] < 4 8 || str [ i ] > 5 7 ) { # return num * sign # } # n , _ := strconv . Atoi ( string ( str [ i ])) # num = num * 1 0 + n # if num * sign < math . MinInt 3 2 { # return math . MinInt 3 2 # } else if num * sign > math . MaxInt 3 2 { # return math . MaxInt 3 2 # } # } # return num * sign
if ldc . seq 0 [ i ] == ldc . seq 1 [ j ] { # return ldc . cost [ i - 1 ][ j - 1 ] + c . cost # } # return math . MaxInt 3 2
str 1 := " STR " # str 2 := " STR " # # fmt . Println ( addStrings ( str 1 , str 2 ))
var res = make ([] string , 0 ) # if n == 0 { # res = append ( res , " STR ") # } else { # for i := 0 ; i < n ; i ++ { # for _ , left := range generateParenthesis ( i ) { # for _ , right := range generateParenthesis ( n - 1 - i ) { # res = append ( res , " STR "+ left +" STR "+ right ) # } # } # } # } # return res
t . Parallel () # # for _ , tc := range testcases { # if res := GroupByAnagram ( tc . words ); ! reflect . DeepEqual ( res , tc . expected ) { # t . Errorf (" STR ", tc . expected , res ) # } # }
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", # [][] int { # { 1 , 1 , 0 }, # { 1 , 1 , 1 }, # { 0 , 1 , 1 }, # }, # 1 , # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := findCircleNum ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", c . expect , got , c . inputs ) # } # }) # }
return & Heap { # data : make ([] Item , 0 ), # min : true , # }
if len ( candidates ) == 0 { # return [][] int {} # } # c , res := [] int {}, [][] int {} # sort . Ints ( candidates ) # findcombinationSum 2 ( candidates , target , 0 , c , & res ) # return res
ns := strconv . Itoa ( N ) # size := len ( D ) # res := zeroLead ( size , len ( ns )) # return res + equal ( D , ns )
if n < 1 { # return " STR " # } # # say := [] byte (" STR ") # for i := 0 ; i < n - 1 ; i ++ { # var cnt byte # var nextSay [] byte # for j := 0 ; j < len ( say ); j ++ { # cnt ++ # if j == len ( say )- 1 || say [ j ] != say [ j + 1 ] { # nextSay = append ( nextSay , 4 8 + cnt , say [ j ]) # fmt . Println ( string ( nextSay ), string ( 4 8 + cnt ), string ( say [ j ])) # cnt = 0 # } # } # say = nextSay # } # return string ( say )
if ans , ok := memo [ n ]; ok { # return ans # } # # if n % 2 == 0 { # memo [ n ] = collatz ( n / 2 ) + 1 # return collatz ( n ) # } # # memo [ n ] = collatz ( 3 * n + 1 ) + 1 # return collatz ( n ) #
n := len ( nums ) # if k == 0 || k % n == 0 { # return # } # k = k % n # reverse ( nums , 0 , n - 1 ) # reverse ( nums , 0 , k - 1 ) # reverse ( nums , k , n - 1 )
if word == " STR " { # return # } # # switch remaining , r := len ( word ), rune ( word [ 0 ]); { # case tst . letter == 0 || tst . letter == r : # tst . letter = r # if remaining != 1 && tst . middle == nil { # tst . middle = & TernarySearchTree {} # } # # tst = tst . middle # tst . Insert ( word [ 1 :]) # case tst . letter > r : # if tst . left == nil { # tst . left = & TernarySearchTree {} # } # # tst = tst . left # tst . Insert ( word ) # case tst . letter < r : # if tst . right == nil { # tst . right = & TernarySearchTree {} # } # # tst = tst . right # tst . Insert ( word ) # }
const l string = " STR " # var s string # for n > 0 { # i := n % 2 6 # n = ( n - 1 ) / 2 6 # s = string ( l [ i ]) + s # } # return s
this . mutex . Lock () # defer this . mutex . Unlock () # e := this . list . Front () # if e == nil { # return nil # } # return this . list . Remove ( e )
return nil , errors . New (" STR ")
bytes := make ([] byte , n + 2 ) # # copy ( bytes , " STR ") # # i , j := 2 , 2 # for j < n { # b := ( bytes [ j ] - ' 0 ') ^ 3 + ' 0 ' # c := bytes [ i ] - ' 0 ' # i ++ # # for c > 0 { # j ++ # bytes [ j ] = b # c -- # } # } # # return strings . Count ( string ( bytes [: n ]), " STR ")
if n == 0 { # return nil # } # return dfs ( 1 , n )
if n < 0 { # return 1 . 0 / pow ( x , - n ) # } # # return pow ( x , n )
t . Parallel () # for _ , tc := range testcases { # if diff := EditDistance ( tc . s 1 , tc . s 2 ); diff != tc . diff { # t . Errorf (" STR ", tc . diff , diff ) # } # }
defer conn . Close () # io . Copy ( conn , rot 1 3 ( conn ))
var tests = [] struct { # nums [] int # elem [] int # }{ # {[] int { 3 , 2 , 3 }, [] int { 3 }}, # {[] int { 1 , 1 , 1 , 3 , 3 , 2 , 2 , 2 }, [] int { 1 , 2 }}, # {[] int { 1 , 2 , 2 , 3 , 2 , 1 , 1 , 3 }, [] int { 1 , 2 }}, # } # # for _ , tt := range tests { # elem := majorityElement ( tt . nums ) # if reflect . DeepEqual ( elem , tt . elem ) == false { # t . Errorf (" STR ", tt . nums , elem , tt . elem ) # } # }
langSet [ titleSlug ] = " STR "
var err error # var out bytes . Buffer # var stderr bytes . Buffer # var commitDate string # var commitTime time . Time # # rng := hash + " STR " + hash # cmd := exec . Command (" STR ", " STR ", " STR ", rng ) # cmd . Stdout = & out # cmd . Stderr = & stderr # if workingDir != "" { # cmd . Dir = workingDir # } # err = cmd . Run () # if err != nil { # return commitTime , fmt . Errorf (" STR ", stderr . String ()) # } # # lines := strings . Split ( out . String (), " STR ") # for _ , s := range lines { # if strings . HasPrefix ( s , " STR ") { # commitDate = s # continue # } # } # if commitDate == "" { # return commitTime , fmt . Errorf (" STR ") # } # commitDate = strings . TrimSpace ( commitDate [ 1 2 :]) # # commitTime , err = time . Parse (" STR ", commitDate ) # if err != nil { # return commitTime , err # } # return commitTime . UTC (), nil
c . failed = true
fmt . Println ( arrayPairSum ([] int { 1 , 4 , 3 , 2 }))
if highIndex < lowIndex || len ( array ) == 0 { # return - 1 # } # mid := ( highIndex + lowIndex ) / 2 # if array [ mid ] > target { # return Binary ( array , target , lowIndex , mid - 1 ) # } else if array [ mid ] < target { # return Binary ( array , target , mid + 1 , highIndex ) # } else { # return mid # }
ret := 1 # # for i := 0 ; i < step && x > 0 && x < len ( grid ) && y > 0 && y < len ( grid ); i ++ { # val := grid [ y ][ x ] # # if val == 0 { # return 0 # } # # ret *= val # # x += xDelta # y += yDelta # } # # return ret
size := len ( stations ) # gases := make ( intHeap , 0 , size ) # miles := startFuel # stops := 0 # i := 0 # # for { # if miles >= target { # return stops # } # # for i < size && stations [ i ][ 0 ] <= miles { # heap . Push (& gases , stations [ i ][ 1 ]) # i ++ # } # # if len ( gases ) == 0 { # break # } # # maxGas := heap . Pop (& gases ).( int ) # stops ++ # miles += maxGas # # } # # return - 1
number := " STR " # # a , b , c , d , e := 7 , 3 , 1 , 6 , 7 # maxP := a * b * c * d * e # p := maxP # # for i := 5 ; i < len ( number )- 1 ; i ++ { # if a == 0 { # p = b * c * d * e # } else { # p /= a # } # # next , _ := strconv . Atoi ( number [ i : i + 1 ]) # a , b , c , d , e = b , c , d , e , next # # p *= e # # if p > maxP { # maxP = p # } # } # # fmt . Println ( maxP )
qs := [] question 9 3 0 { # # { # para 9 3 0 {[] int { 1 , 0 , 1 , 0 , 1 }, 2 }, # ans 9 3 0 { 4 }, # }, # # { # para 9 3 0 {[] int { 0 , 0 , 0 , 0 , 0 }, 0 }, # ans 9 3 0 { 1 5 }, # }, # # { # para 9 3 0 {[] int { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 }, 2 }, # ans 9 3 0 { 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 3 0 , q . para 9 3 0 # fmt . Printf (" STR ", p , numSubarraysWithSum ( p . s , p . k )) # } # fmt . Printf (" STR ")
size := len ( A ) # greater , less := 1 , 1 # # res := 1 # for i := 1 ; i < size ; i ++ { # switch { # case A [ i ] > A [ i - 1 ]: # greater , less = less + 1 , 1 # res = max ( res , greater ) # case A [ i ] < A [ i - 1 ]: # greater , less = 1 , greater + 1 # res = max ( res , less ) # default : # greater , less = 1 , 1 # } # } # # return res
var i int # for i = len ( bits ) - 2 ; i >= 0 && bits [ i ] == 1 ; i -- { # } # return ( len ( bits )- 2 - i )& 1 == 0
result := make ( Matrix , len ( m )) # for i := range result { # result [ i ] = make ([] int , len ( m )) # } # for i := range m { # for j := range m [ i ] { # result [ j ][ len ( m )- 1 - i ] = m [ i ][ j ] # } # } # return result
if len ( segments ) == 0 { # return route # } # last := route [ len ( route )- 1 ] # for i , segment := range segments { # segmentsWoCurrent := append ([] Flight {}, segments [: i ]...) # segmentsWoCurrent = append ( segmentsWoCurrent , segments [ i + 1 :]...) # route = append ( route , segment . arrive ) # if segment . depart == last { # return Itinerary ( segmentsWoCurrent , route ) # } # route = route [: len ( route )- 1 ] # } # return nil
var res int # dfs ( root , root . Val , root . Val , & res ) # return res
if k <= 1 { # return nums # } # # # queue := list . New () # result := make ([] int , 0 , len ( nums )- k + 1 ) # # for i , v := range nums { # for queue . Len () > 0 { # if x := queue . Back (); nums [ x . Value .( int )] <= v { # queue . Remove ( x ) # } else { # break # } # } # queue . PushBack ( i ) # for x , j := queue . Front (), i - k + 1 ; x . Value .( int ) < j ; x = queue . Front () { # queue . Remove ( x ) # } # if i >= k - 1 { # result = append ( result , nums [ queue . Front (). Value .( int )]) # } # } # # return result
if len ( inorder ) == 0 { # return nil # } # # res := & TreeNode { Val : postorder [ len ( postorder )- 1 ]} # if len ( inorder ) == 1 { # return res # } # # index := 0 # for i , v := range inorder { # if v == res . Val { # index = i # break # } # } # # res . Left = buildTree ( inorder [: index ], postorder [: index ]) # res . Right = buildTree ( inorder [ index + 1 :], postorder [ index : len ( postorder )- 1 ]) # return res
tests := [...] testType { # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := removeOuterParentheses ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
for i := range s { # if ! isInRow [ s [ i ]] { # return false # } # } # return true
dp := make ([] int , len ( books )+ 1 ) # dp [ 0 ] = 0 # for i := 1 ; i <= len ( books ); i ++ { # width , height := books [ i - 1 ][ 0 ], books [ i - 1 ][ 1 ] # dp [ i ] = dp [ i - 1 ] + height # for j := i - 1 ; j > 0 && width + books [ j - 1 ][ 0 ] <= shelfWidth ; j -- { # height = max ( height , books [ j - 1 ][ 1 ]) # width += books [ j - 1 ][ 0 ] # dp [ i ] = min ( dp [ i ], dp [ j - 1 ]+ height ) # } # } # return dp [ len ( books )]
c . acc = op ( c . acc ) # return c . acc
bs := [] byte ( strconv . Itoa ( num )) # # indexs := make ( map [ byte ] int , len ( bs )) # for i := range bs { # indexs [ bs [ i ]] = i # } # # for i := 0 ; i < len ( bs ); i ++ { # for bj := byte (' 9 '); bs [ i ] < bj ; bj -- { # j := indexs [ bj ] # if j > i { # bs [ i ], bs [ j ] = bs [ j ], bs [ i ] # return convert ( bs ) # } # } # } # # return convert ( bs )
n , err := rot 1 3 . Reader . Read ( p ) # for i , v := range p [: n ] { # if v <= " STR " && v >= " STR " { # p [ i ] = v + 1 3 # if p [ i ] > " STR " { # p [ i ] -= 2 6 # } # } else if v <= " STR " && v >= " STR " { # p [ i ] = v + 1 3 # if p [ i ] > " STR " { # p [ i ] -= 2 6 # } # } else { # p [ i ] = v # } # } # return n , err
ans = [][] int {} # cur := [] int {} # for i := 0 ; i <= len ( nums ); i ++ { # dfs ( nums , i , 0 , cur ) # } # return ans
failed := c . failed # return failed
new = make ([] int , cap ( old )+ 1 ) # copy ( new , old ) # return new
if root == nil { # return nil # } # # root . Left = pruneTree ( root . Left ) # root . Right = pruneTree ( root . Right ) # # if root . Val == 0 && root . Left == nil && root . Right == nil { # return nil # } # return root
sort . Ints ( nums ) # res := [][] int {} # # for i := range nums { # if i > 0 && nums [ i ] == nums [ i - 1 ] { # continue # } # # l , r := i + 1 , len ( nums )- 1 # # for l < r { # s := nums [ i ] + nums [ l ] + nums [ r ] # switch { # case s < 0 : # l ++ # case s > 0 : # r -- # default : # res = append ( res , [] int { nums [ i ], nums [ l ], nums [ r ]}) # l , r = next ( nums , l , r ) # } # } # } # # return res
nodes := 0 # curr 1 := root # for curr 1 != nil { # nodes ++ # curr 1 = curr 1 . Next # } # ans := make ([]* ListNode , k ) # quo , rem := nodes / k , nodes % k # # curr := root # for i := 0 ; curr != nil && i < k ; i ++ { # ans [ i ] = curr # size := quo # if rem > 0 { # size ++ # rem -- # } # # for j := 1 ; j < size ; j ++ { # curr = curr . Next # } # end := curr # curr = curr . Next # end . Next = nil # } # return ans
mask := 1 # tmp := num # for tmp > 0 { # mask <<= 1 # tmp >>= 1 # } # return num ^ ( mask - 1 )
res := [][] int {} # if numRows == 0 { # return res # } # # res = append ( res , [] int { 1 }) # if numRows == 1 { # return res # } # # for i := 1 ; i < numRows ; i ++ { # res = append ( res , genNext ( res [ i - 1 ])) # } # # return res
n := len ( A ) # # count := [ 1 0 0 0 1 ] int {} # for _ , a := range A { # count [ a ]++ # } # # sort . Slice ( A , func ( i int , j int ) bool { # if count [ A [ i ]] == count [ A [ j ]] { # return A [ i ] < A [ j ] # } # return count [ A [ i ]] > count [ A [ j ]] # }) # # res := make ([] int , n ) # i := 0 # for _ , a := range A { # res [ i ] = a # i += 2 # if i >= n { # i = 1 # } # } # # return res
dp := [ 5 0 0 1 ] int {} # for i := 1 ; i < 5 0 0 1 ; i ++ { # dp [ i ] = - 1 # } # cur := [ 5 0 0 1 ] int {} # clone := func () { # for i , x := range dp { # cur [ i ] = x # } # } # for _ , x := range rods { # clone () # for d := 0 ; d + x < 5 0 0 1 ; d ++ { # if cur [ d ] >= 0 { # dp [ d + x ] = max ( cur [ d ], cur [ d + x ]) # dp [ abs ( d - x )] = max ( cur [ d ]+ min ( d , x ), dp [ abs ( d - x )]) # } # } # } # return dp [ 0 ]
tests := [...] testType { # { # in : [] int { 1 }, # k : 0 , # want : 0 , # }, # { # in : [] int { 0 , 1 0 }, # k : 2 , # want : 6 , # }, # { # in : [] int { 1 , 3 , 6 }, # k : 3 , # want : 0 , # }, # { # in : [] int { 1 , 3 , 5 , 7 , 9 }, # k : 1 , # want : 6 , # }, # { # in : [] int { 1 8 , 1 6 , 1 2 , 7 , 9 , 3 , 5 }, # k : 6 , # want : 3 , # }, # } # for _ , tt := range tests { # got := smallestRangeI ( tt . in , tt . k ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
t . Parallel () # for _ , tc := range testcases { # if result := MaxXorPairLinear ( tc . nums ); result != tc . maxXor { # t . Errorf (" STR ", tc . maxXor , result ) # } # }
sort . Ints ( g ) # sort . Ints ( s ) # # var i , j , res int # for i < len ( g ) && j < len ( s ) { # if g [ i ] <= s [ j ] { # res ++ # i ++ # } # j ++ # } # # return res
if i <= 1 || i % 2 == 0 || i % 3 == 0 { # return false # } # for j := 5 ; j * j <= i ; j += 6 { # if i % j == 0 || i % ( j + 2 ) == 0 { # return false # } # } # return true
var ( # v 1 = strings . Split ( version 1 , " STR ") # v 2 = strings . Split ( version 2 , " STR ") # ) # for i := 0 ; i < len ( v 1 ) || i < len ( v 2 ); i ++ { # var v 1 N , v 2 N int # if i < len ( v 1 ) { # v 1 N , _ = strconv . Atoi ( v 1 [ i ]) # } # if i < len ( v 2 ) { # v 2 N , _ = strconv . Atoi ( v 2 [ i ]) # } # # if v 1 N > v 2 N { # return 1 # } else if v 1 N < v 2 N { # return - 1 # } # } # return 0
s := time . Now () # amicable := make ( map [ int ] int ) # # var res int = 0 # # for i := 2 2 0 ; i < 1 0 0 0 0 ; i ++ { # # if amicable [ i ] != 0 { # res += i # } else { # sum := FindSumOfProperDivisors 2 ( i ) # if sum == i || sum == 0 { # continue # } # sumA := FindSumOfProperDivisors 2 ( sum ) # # if sumA == i { # res += i # amicable [ sumA ] = sum # } # } # } # fmt . Println ( time . Now (). Sub ( s )) # return res
return stack . Len () == 0
res := 0 # n := len ( nums ) # for i := 0 ; i < 3 2 ; i ++ { # bitCount := 0 # for _ , num := range nums { # bitCount += ( num >> uint ( i )) & 1 # } # res += bitCount * ( n - bitCount ) # } # return res
temp := make ([] int , m ) # copy ( temp , nums 1 ) # # j , k := 0 , 0 # for i := 0 ; i < len ( nums 1 ); i ++ { # if k >= n { # nums 1 [ i ] = temp [ j ] # j ++ # continue # } # if j >= m { # nums 1 [ i ] = nums 2 [ k ] # k ++ # continue # } # if temp [ j ] < nums 2 [ k ] { # nums 1 [ i ] = temp [ j ] # j ++ # } else { # nums 1 [ i ] = nums 2 [ k ] # k ++ # } # }
distinct := make ( map [ rune ] int ) # for _ , r := range str { # distinct [ r ]++ # } # distinctCount := len ( distinct ) # distinct = make ( map [ rune ] int , distinctCount ) # var begin int # smallest := len ( str ) # for end , r := range str { # distinct [ r ]++ # if len ( distinct ) == distinctCount { # for toRemove := rune ( str [ begin ]); distinct [ toRemove ] > 1 ; toRemove = rune ( str [ begin ]) { # distinct [ toRemove ]-- # begin ++ # } # if length := end - begin + 1 ; length < smallest { # smallest = length # } # } # for len ( distinct ) == distinctCount { # toRemove := rune ( str [ begin ]) # distinct [ toRemove ]-- # if count := distinct [ toRemove ]; count == 0 { # delete ( distinct , toRemove ) # } # begin ++ # } # } # return smallest
r := [' z ' + 1 ] int {} # for i := range s { # r [ s [ i ]]++ # } # # ss := make ([] string , 0 , len ( s )) # for i := range r { # if r [ i ] == 0 { # continue # } # ss = append ( ss , makeString ( byte ( i ), r [ i ])) # } # # sort . Sort ( segments ( ss )) # # res := " STR " # for _ , s := range ss { # res += s # } # # return res
qs := [] question 2 9 { # # { # para 2 9 { 1 0 , 3 }, # ans 2 9 { 3 }, # }, # # { # para 2 9 { 7 , - 3 }, # ans 2 9 {- 2 }, # }, # # { # para 2 9 {- 1 , 1 }, # ans 2 9 {- 1 }, # }, # # { # para 2 9 { 1 , - 1 }, # ans 2 9 {- 1 }, # }, # # { # para 2 9 { 2 1 4 7 4 8 3 6 4 7 , 3 }, # ans 2 9 { 7 1 5 8 2 7 8 8 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 9 , q . para 2 9 # fmt . Printf (" STR ", p , divide ( p . dividend , p . divisor )) # } # fmt . Printf (" STR ")
const max = 2 0 0 0 0 0 0 # goroutines := 8 0 # cycle := int ( max / goroutines ) # sum := 0 # # ch := make ( chan int ) # for i := 0 ; i < max ; i += cycle { # if i + cycle < max { # go sumPrimes ( i , i + cycle , ch ) # } else { # go sumPrimes ( i , max , ch ) # } # # } # # for i := 0 ; i < goroutines ; i ++ { # sum += <- ch # } # # fmt . Println ( sum )
_ , ok := itf .( error ) # return ok
charFreq := [ 2 6 ] int {} # for _ , char := range chars { # charFreq [ char - 9 7 ]++ # } # res := 0 # for _ , word := range words { # if checkIfGood ( word , charFreq ) { # res += len ( word ) # } # } # return res
maxValue := 9 9 9 * 9 9 9 # minValue := 1 0 0 * 1 0 0 # answer := 0 # for ; maxValue > minValue ; maxValue -- { # if isPalindrome ( maxValue ) { # if isProduct ( maxValue ){ # answer = maxValue # fmt . Printf (" STR ", answer ) # return # } # } # } # fmt . Printf (" STR ", answer )
b , a , l , o , n := 0 , 0 , 0 , 0 , 0 # for _ , r := range text { # switch r { # case ' b ': # b ++ # case ' a ': # a ++ # case ' l ': # l ++ # case ' o ': # o ++ # case ' n ': # n ++ # } # } # res := min ( b , min ( a , n )) # res = min ( res , min ( l / 2 , o / 2 )) # return res
qs := [] question 7 5 6 { # # { # para 7 5 6 {" STR ", [] string {" STR ", " STR ", " STR ", " STR "}}, # ans 7 5 6 { true }, # }, # # { # para 7 5 6 {" STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 7 5 6 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 5 6 , q . para 7 5 6 # fmt . Printf (" STR ", p , pyramidTransition ( p . b , p . a )) # } # fmt . Printf (" STR ")
m := make ( map [ int ] int , len ( M )) # count := 0 # for i := 0 ; i < len ( M ); i ++{ # if _ , ok := m [ i ];! ok { # dfs ( M , i , m ) # count ++ # } # } # return count
for _ , v := range favorites { # fmt . Println ( v ) # }
for i := range data { # if err := p . Pull (& data [ i ]); err != nil { # return i , err # } # } # # return len ( data ), nil
var tests = [] struct { # tree * TreeNode # value int # }{ # { newTree ( 2 , 2 , 5 , nil , nil , 5 , 7 ), 5 }, # { newTree ( 2 , 2 , 2 ), - 1 }, # } # # for _ , tt := range tests { # value := findSecondMinimumValue ( tt . tree ) # if value != tt . value { # t . Errorf (" STR ", tt . tree , value , tt . value ) # } # }
combination := make ([] int , k ) # res := [][] int {} # # var dfs func ( int , int ) # dfs = func ( idx , begin int ) { # if idx == k { # temp := make ([] int , k ) # copy ( temp , combination ) # res = append ( res , temp ) # return # } # # for i := begin ; i <= n + 1 - k + idx ; i ++ { # combination [ idx ] = i # dfs ( idx + 1 , i + 1 ) # } # } # # dfs ( 0 , 1 ) # # return res
fmt . Println ( minPathSum ([][] int { # { 1 , 3 , 1 }, # { 1 , 5 , 1 }, # { 4 , 2 , 1 }, # }))
return Vector 2 D { # nums : v , # group : 0 , # index : 0 , # }
fmt . Fprintf ( w , th . responseText )
nums := [] int { 3 , 4 , 5 , 1 , 2 } # expected := 1 # if res := findMin ( nums ); res != expected { # t . Errorf (" STR ", expected , res ) # }
t . Parallel () # for _ , tc := range testcases { # testGrid := copyGrid ( tc . grid ) # ReplaceAdjacentColorPixel ( testGrid , tc . coord , tc . color ) # if ! reflect . DeepEqual ( tc . expected , testGrid ) { # t . Errorf (" STR ", tc . expected , testGrid ) # } # }
var ( # record = make ( map [ int ] int ) # res int # ) # # for _ , i := range A { # for _ , j := range B { # record [ i + j ]++ # } # } # # for _ , i := range C { # for _ , j := range D { # if s , ok := record [- i - j ]; ok && s > 0 { # res += s # } # } # } # return res
t . Parallel () # for _ , tc := range testcases { # if order := AlienLanguageOrder ( tc . alienWords ); ! reflect . DeepEqual ( order , tc . order ) { # t . Errorf (" STR ", tc . order , order ) # } # }
if len ( nums ) <= 1 { # return false # } # if k <= 0 { # return false # } # record := make ( map [ int ] bool , len ( nums )) # for i , n := range nums { # if _ , found := record [ n ]; found { # return true # } # record [ n ] = true # if len ( record ) == k + 1 { # delete ( record , nums [ i - k ]) # } # } # return false
qs := [] question 1 6 4 { # # { # para 1 6 4 {[] int { 3 , 6 , 9 , 1 }}, # ans 1 6 4 { 3 }, # }, # { # para 1 6 4 {[] int { 1 }}, # ans 1 6 4 { 0 }, # }, # # { # para 1 6 4 {[] int {}}, # ans 1 6 4 { 0 }, # }, # # { # para 1 6 4 {[] int { 2 , 1 0 }}, # ans 1 6 4 { 8 }, # }, # # { # para 1 6 4 {[] int { 2 , 4 3 5 , 2 1 4 , 6 4 3 2 1 , 6 4 3 , 7 2 3 4 , 7 , 4 3 6 5 2 3 , 7 8 5 6 , 8 }}, # ans 1 6 4 { 3 7 2 2 0 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 6 4 , q . para 1 6 4 # fmt . Printf (" STR ", p , maximumGap 1 ( p . one )) # } # fmt . Printf (" STR ")
set := make ( map [ int ] bool ) # powX := 1 # for powX < bound { # powY := 1 # for powY < bound { # if powX + powY <= bound { # set [ powX + powY ] = true # } # # if y == 1 { # break # } # # powY *= y # } # # if x == 1 { # break # } # # powX *= x # } # # result := make ([] int , 0 ) # for k := range set { # result = append ( result , k ) # } # # return result
n := len ( nums ) # if n < 1 { # return - 1 # } # sum := 0 # for _ , num := range nums { # sum += num # } # tsum := 0 # for i , num := range nums { # sum -= num # if tsum == sum { # return i # } # tsum += num # } # return - 1
text = regexp . MustCompile (`[ \ t \ n ]+`). ReplaceAllString ( text , " STR ") # text = strings . ReplaceAll ( text , " STR ", " STR ") # text = strings . TrimSpace ( text ) # return text
cases := [] struct { # name string # matrix [][] int # k int # expect [][] int # }{ # {" STR ", [][] int {{ 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 }}, 1 , [][] int {{ 1 2 , 2 1 , 1 6 }, { 2 7 , 4 5 , 3 3 }, { 2 4 , 3 9 , 2 8 }}}, # {" STR ", [][] int {{ 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 }}, 2 , [][] int {{ 4 5 , 4 5 , 4 5 }, { 4 5 , 4 5 , 4 5 }, { 4 5 , 4 5 , 4 5 }}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . matrix , c . k ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . matrix , c . k ) # } # }) # }
return x << y
dstArr := make ([] int , len ( height )) # sum := 0 # for i := 0 ; i < len ( height ); i ++ { # dstArr [ i ] = height [ i ] # sum += height [ i ] # } # return dstArr , sum
if root == nil { # return 0 # } # left := helper ( root . Left ) # if left == k - 1 { # return root . Val # } # if left > k - 1 { # return kthSmallest ( root . Left , k ) # } # return kthSmallest ( root . Right , k - 1 - left )
t . Parallel () # for _ , tc := range testcases { # if area := LargestRectangleHistogram ( tc . hist ); area != tc . area { # t . Errorf (" STR ", tc . area , area ) # } # }
short := shortest ( strs ) # # for i , r := range short { # for j := 0 ; j < len ( strs ); j ++ { # if strs [ j ][ i ] != byte ( r ) { # return strs [ j ][: i ] # } # } # } # # return short
var i , prod float 6 4 = 0 , 1 # for i = 4 0 ; i > 2 0 ; i -- { # prod *= i / ( i - 2 0 ) # fmt . Println ( i /( i - 2 0 )) # } # fmt . Println ( prod )
if root == nil { # return [][] int {} # } # # res := [][] int {} # # currentLevelNodes := []* TreeNode { root } # for len ( currentLevelNodes ) > 0 { # traverseResult := [] int {} # var nextLevelNodes = []* TreeNode {} # for i := 0 ; i < len ( currentLevelNodes ); i ++ { # traverseResult = append ( traverseResult , currentLevelNodes [ i ]. Val ) # if currentLevelNodes [ i ]. Left != nil { # nextLevelNodes = append ( nextLevelNodes , currentLevelNodes [ i ]. Left ) # } # if currentLevelNodes [ i ]. Right != nil { # nextLevelNodes = append ( nextLevelNodes , currentLevelNodes [ i ]. Right ) # # } # } # res = append ( res , traverseResult ) # currentLevelNodes = nextLevelNodes # } # for i := 0 ; i < len ( res ); i ++ { # if i % 2 == 0 { # continue # } # # for j := 0 ; j < len ( res [ i ])/ 2 ; j ++ { # res [ i ][ j ], res [ i ][ len ( res [ i ])- 1 - j ] = res [ i ][ len ( res [ i ])- 1 - j ], res [ i ][ j ] # } # } # return res
data := [] int { 7 , 1 , 5 , 3 , 6 , 4 } # # fmt . Println ( maxProfit ( data ))
return calculateDepth ( t . Root , 0 )
v := reflect . ValueOf ( s ) # # for v . Kind () == reflect . Ptr { # v = v . Elem () # } # # if v . Kind () != reflect . Struct { # panic (" STR ") # } # # return v
if a < b { return a } # return b
return MyHashSet { # data : make ([] bool , 1 0 0 0 0 0 1 ), # }
if board [ click [ 0 ]][ click [ 1 ]] == ' M ' { # board [ click [ 0 ]][ click [ 1 ]] = ' X ' # return board # } # # mineMap := make ([][] int , len ( board )) # for i := range board { # mineMap [ i ] = make ([] int , len ( board [ i ])) # } # # for i := range board { # for j := range board [ i ] { # if board [ i ][ j ] == ' M ' { # mineMap [ i ][ j ] = - 1 # for _ , d := range dir 8 { # nx , ny := i + d [ 0 ], j + d [ 1 ] # if isInBoard ( board , nx , ny ) && mineMap [ nx ][ ny ] >= 0 { # mineMap [ nx ][ ny ]++ # } # } # } # } # } # mineSweeper ( click [ 0 ], click [ 1 ], board , mineMap , dir 8 ) # return board
if testing . Short () { # t . Skip (" STR ") # } # time . Sleep ( 5 * time . Second )
var tests = [] struct { # tree * TreeNode # values [][] int # }{ # { newTree ( 3 , 9 , 2 0 , nil , nil , 1 5 , 7 ), [][] int {{ 1 5 , 7 }, { 9 , 2 0 }, { 3 }}}, # } # # for _ , tt := range tests { # values := levelOrderBottom ( tt . tree ) # if reflect . DeepEqual ( values , tt . values ) == false { # t . Errorf (" STR ", tt . tree , values , tt . values ) # } # }
devident , remainder := 1 0 , 1 # remainders := map [ int ] int { 1 : 0 } # quotient := " STR " # for { # if devident < divisor { # devident *= 1 0 # quotient += " STR " # } else { # remainder = devident % divisor # quotient += strconv . Itoa ( devident / divisor ) # if remainder == 0 { # return 0 # } # if idx , exists := remainders [ remainder ]; exists { # return len ( quotient ) - idx # } else { # remainders [ remainder ] = len ( quotient ) - 1 # devident = remainder * 1 0 # } # } # } #
for cl . Size > 1 { # cl . Rotate ( k ) # cl . Delete () # cl . Rotate (- 1 ) # } # retval := cl . Head . Val .( int ) # cl . Destroy () # return retval
if len ( this . dequeue ) > 0 { # return this . dequeue [ 0 ] # } else if len ( this . enqueue ) > 0 { # return this . enqueue [ len ( this . enqueue )- 1 ] # } # # return 0
for msg := range ch { # fmt . Fprintln ( conn , msg ) # }
qs := [] question 5 0 0 { # # { # para 5 0 0 {[] string {" STR ", " STR ", " STR ", " STR "}}, # ans 5 0 0 {[] string {" STR ", " STR "}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 0 0 , q . para 5 0 0 # fmt . Printf (" STR ", p , findWords 5 0 0 ( p . one )) # } # fmt . Printf (" STR ")
fmt . Printf (" STR ", m )
return b . GetStaleNow ( key , time . Now ())
fmt . Println ( maxProfit 1 ([] int { 1 , 2 , 3 , 4 , 5 })) # fmt . Println ( maxProfit 1 ([] int { 7 , 1 , 5 , 3 , 6 , 4 }))
return cap ( ints )
dummy := & ListNode {} # dummy . Next = head # cur := dummy # # for cur . Next != nil && cur . Next . Next != nil { # node 1 := cur . Next # node 2 := node 1 . Next # node 3 := node 2 . Next # # node 2 . Next = node 1 # node 1 . Next = node 3 # cur . Next = node 2 # cur = node 1 # } # return dummy . Next
if root == nil { # return true , 0 # } # # left , leftDepth := helper 1 1 0 ( root . Left ) # right , rightDepth := helper 1 1 0 ( root . Right ) # if ! left || ! right || leftDepth - rightDepth > 1 || leftDepth - rightDepth < - 1 { # return false , 0 # } # # if leftDepth > rightDepth { # return true , leftDepth + 1 # } # # return true , rightDepth + 1
s . arr = append ( s . arr , elem )
t . Parallel () # for tcid , tc := range testcases { # if result := IsMinimallyConnected ( tc . g ); result != tc . expected { # t . Errorf (" STR ", tcid , tc . expected , result ) # } # }
major , count := nums [ 0 ], 0 # # for _ , v 1 := range nums { # tmpCount := 0 # for _ , v 2 := range nums { # if v 2 == v 1 { # tmpCount ++ # } # } # if tmpCount > count { # count = tmpCount # major = v 1 # } # } # # return major
ans , l 1 , l 2 , carry := " STR ", len ( num 1 )- 1 , len ( num 2 )- 1 , byte (' 0 ') # for l 1 >= 0 || l 2 >= 0 || carry != ' 0 ' { # v := carry # if l 1 >= 0 { # v += num 1 [ l 1 ] - ' 0 ' # l 1 -- # } # if l 2 >= 0 { # v += num 2 [ l 2 ] - ' 0 ' # l 2 -- # } # carry = ' 0 ' + ( v -' 0 ')/ 1 0 # v = ' 0 ' + ( v -' 0 ')% 1 0 # ans = string ( v ) + ans # } # return ans
var shift uint = 0 # # if x == y { # return x # } # # if x == 0 { # return y # } # # if y == 0 { # return x # } # # for shift := 0 ; ( x | y )& 1 == 0 ; shift ++ { # x = x >> 1 # y = y >> 1 # } # # for ( x & 1 ) == 0 { # x = x >> 1 # } # # for y == 0 { # # for ( y & 1 ) == 0 { # y = y >> 1 # } # # if x > y { # t := x # x = y # y = t # } # # y = y - x # # } # # y = y << shift # # return y
s . lock . Lock () # defer s . lock . Unlock () # # el , s . stack = s . stack [ 0 ], s . stack [ 1 :] # s . len -- # return
 # lenSi , i := 0 , 0 # # for ; lenSi < K ; i ++ { # char := S [ i ] # if isDigit ( char ) { # lenSi *= int ( char - ' 0 ') # } else { # lenSi ++ # } # } # # for { # i -- # char := S [ i ] # if isDigit ( char ) { # lenSi /= int ( char - ' 0 ') # K %= lenSi # } else { # if K == 0 || # K == lenSi { # return string ( char ) # } # lenSi -- # } # } #
if n < 0 { # n = - n # } # var result int # for arithmeticSum ( result ) < n || ( arithmeticSum ( result )- n )% 2 == 1 { # result ++ # } # return result
out := 8 7 1 1 9 8 2 8 2 # if x := p 2 2 (); x != out { # t . Errorf (" STR ", x , out ) # }
qs := [] question 5 3 2 { # # { # para 5 3 2 {[] int { 3 , 1 , 4 , 1 , 5 }, 2 }, # ans 5 3 2 { 2 }, # }, # # { # para 5 3 2 {[] int { 1 , 2 , 3 , 4 , 5 }, 1 }, # ans 5 3 2 { 4 }, # }, # # { # para 5 3 2 {[] int { 1 , 3 , 1 , 5 , 4 }, 0 }, # ans 5 3 2 { 1 }, # }, # # { # para 5 3 2 {[] int {}, 3 }, # ans 5 3 2 { 0 }, # }, # # # # # # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 3 2 , q . para 5 3 2 # fmt . Printf (" STR ", p , findPairs ( p . one , p . n )) # } # fmt . Printf (" STR ")
fmt . Println ( strconv . Itoa ( 1 )) # fmt . Println ( strings . Compare (" STR "," STR "))
t . Parallel () # for _ , tc := range testcases { # r := NewOrderLogSlice ( tc . size ) # for _ , v := range tc . orders { # r . Record ( v ) # } # for i , v := range tc . getLast { # if result := r . GetLast ( v ); result != tc . expected [ i ] { # t . Errorf (" STR ", tc . expected [ i ], result ) # } # } # }
if len ( os . Args ) != 2 { # fmt . Fprintf ( os . Stderr , " STR ") # os . Exit ( 1 ) # } # url := os . Args [ 1 ] # if err := WaitForServer ( url ); err != nil { # fmt . Fprintf ( os . Stderr , " STR ", err ) # os . Exit ( 1 ) # }
boundValue := 1 # for boundValue < len ( array ) && array [ boundValue ] < number { # boundValue *= 2 # } # if boundValue > len ( array ) { # boundValue = len ( array ) - 1 # } # return BinarySearch ( array , boundValue + 1 , number )
fmt . Println ( sum ()) # fmt . Println ( sum ( 3 )) # fmt . Println ( sum ( 1 , 2 , 3 , 4 )) # # values := [] int { 1 , 2 , 3 , 4 } # fmt . Println ( sum ( values ...))
decimals := [] uint 8 {} # for i := 1 ; i < 2 0 0 0 0 0 0 ; i ++ { # for _ , val := range strconv . Itoa ( i ) { # decimals = append ( decimals , uint 8 ( val -' 0 ')) # } # } # prod := uint 8 ( 1 ) # for i := 1 ; i <= 1 0 0 0 0 0 0 ; i *= 1 0 { # prod *= decimals [ i - 1 ] # } # fmt . Println (" STR ", prod )
graph := make ( map [ int ] map [ int ] bool ) # addNode 7 4 2 ( root , graph ) # buildGraph 7 4 2 ( root , graph ) # # queue := make ([] int , 0 ) # visited := make ( map [ int ] bool ) # queue = append ( queue , k ) # visited [ k ] = true # for len ( queue ) > 0 { # n := queue [ 0 ] # queue = queue [ 1 :] # # if ( n != root . Val && len ( graph [ n ]) == 1 ) || ( n == root . Val && root . Left == nil && root . Right == nil ) { # return n # } # # for c := range graph [ n ] { # if ! visited [ c ] { # visited [ c ] = true # queue = append ( queue , c ) # } # } # } # # return - 1
if random == nil { # random = rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # } # # return random
numbers := [] int { 0 , 0 , 0 , 1 , 1 , 1 , 2 , 3 , 1 , 1 , 1 } # # fmt . Println ( moreThanHalfNum ( numbers ))
fmt . Println ( strings . Join ( os . Args [ 1 :], " STR "))
max := abs ( target [ 0 ]) + abs ( target [ 1 ]) # for _ , g := range ghosts { # d := abs ( g [ 0 ]- target [ 0 ]) + abs ( g [ 1 ]- target [ 1 ]) # if d <= max { # return false # } # } # return true
t . Parallel () # for _ , tc := range testcases { # if peak := PeakIndexNR ( tc . nums ); peak != tc . peakIndex { # t . Errorf (" STR ", tc . peakIndex , peak ) # } # }
n := & Node { Value : i } # if t . Head == nil { # t . Head = n # t . Size ++ # return # } # # h := t . Head # # for { # if n . Compare ( h ) == - 1 { # if h . Left == nil { # h . Left = n # n . Parent = h # break # } else { # h = h . Left # } # } else { # if h . Right == nil { # h . Right = n # n . Parent = h # break # } else { # h = h . Right # } # } # } # t . Size ++
var row_mask [ cnt ][ cnt ] bool # var col_mask [ cnt ][ cnt ] bool # var partArea_mask [ cnt ][ cnt ] bool # # for r := 0 ; r < len ( inputArr ); r ++ { # for c := 0 ; c < len ( inputArr [ r ]); c ++ { # # if inputArr [ r ][ c ] == 0 { # continue # } # idx := inputArr [ r ][ c ] - 1 # # if row_mask [ r ][ idx ] == true { # return true # } # row_mask [ r ][ idx ] = true # # if col_mask [ c ][ idx ] == true { # return true # } # row_mask [ c ][ idx ] = true # # area := ( r / 3 )* 3 + ( c / 3 ) # if partArea_mask [ area ][ idx ] == true { # return false # } # partArea_mask [ area ][ idx ] = true # } # } # return true
return & Rot 1 3 Reader { rdr }
starttime := time . Now () # # count := make ( map [ int 6 4 ] int ) # # for a := int 6 4 ( 1 ); a < maxA ; a ++ { # # for c := 2 * a - 1 ; c >= 0 ; c -- { # # n := 4 * a * a - c * c # # if n > top { # break # } # # if a - c > 0 { # count [ n ]++ # } # if a + c > 0 && c != 0 { # count [ n ]++ # # } # } # # } # # total := 0 # for _ , mult := range count { # # if mult == desiredMult { # # total ++ # } # } # # fmt . Println ( total ) # # fmt . Println (" STR ", time . Since ( starttime ))
return equal ( tree , tree )
for _ , op := range ops { # if m > op [ 0 ] { # m = op [ 0 ] # } # if n > op [ 1 ] { # n = op [ 1 ] # } # } # return m * n
for v := range in { # out <- v * v # } # close ( out )
if maxStack > 0 { # stack := & OperandStack {} # stack . top = 0 # stack . slots = make ([] Slot , maxStack ) # return stack # } # return nil
qs := [] question 1 1 7 0 { # # { # para 1 1 7 0 {[] string {" STR "}, [] string {" STR "}}, # ans 1 1 7 0 {[] int { 1 }}, # }, # # { # para 1 1 7 0 {[] string {" STR ", " STR "}, [] string {" STR ", " STR ", " STR ", " STR "}}, # ans 1 1 7 0 {[] int { 1 , 2 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 1 7 0 , q . para 1 1 7 0 # fmt . Printf (" STR ", p , numSmallerByFrequency ( p . queries , p . words )) # } # fmt . Printf (" STR ")
fmt . Println ( consecutiveNumbersSum ( 1 )) # fmt . Println ( consecutiveNumbersSum ( 9 )) # fmt . Println ( consecutiveNumbersSum ( 1 5 ))
nums := [] int {} # for i := 0 ; i < N ; i ++ { # nums = append ( nums , rand . Int ()) # } # nums = append ( nums , 7 , 2 ) # # b . ResetTimer () # for i := 0 ; i < b . N ; i ++ { # TwoSum 2 ( nums , 9 ) # }
if len ( S ) == 0 { # return S # } # # var stackLength , left int # # var ret string # # for i := 0 ; i < len ( S ); i ++ { # if stackLength == 0 { # left = i # } # if S [ i ] == '(' { # stackLength ++ # } else { # stackLength -- # } # if stackLength == 0 { # ret += S [ left + 1 : i ] # } # } # return ret
if root == nil { return } # Solution ( root . Left ) # if root . Left != nil { # left , right := root . Left , root . Right # root . Right = left # for left . Right != nil { # left = left . Right # } # left . Right = right # root . Left = nil # } # Solution ( root . Right )
ps := strings . Split ( pattern , " STR ") # ss := strings . Split ( str , " STR ") # # if len ( ps ) != len ( ss ) { # return false # } # # return isMatch ( ps , ss ) && isMatch ( ss , ps )
res := 0 # stack := make ([] int , 0 , len ( s )) # sign := 1 # # for i := 0 ; i < len ( s ); i ++ { # switch s [ i ] { # case ' 1 ', ' 2 ', ' 3 ', ' 4 ', ' 5 ', ' 6 ', ' 7 ', ' 8 ', ' 9 ', ' 0 ': # num := 0 # for i < len ( s ) && s [ i ] >= ' 0 ' && s [ i ] <= ' 9 ' { # num = num * 1 0 + int ( s [ i ]-' 0 ') # i ++ # } # res += sign * num # i -- # case '+': # sign = 1 # case '-': # sign = - 1 # case '(': # stack = append ( stack , res , sign ) # res = 0 # sign = 1 # case ')': # sign = stack [ len ( stack )- 1 ] # tmp := stack [ len ( stack )- 2 ] # stack = stack [: len ( stack )- 2 ] # # res = sign * res + tmp # } # } # return res
for _ , char := range word { # charFreq [ char - 9 7 ]-- # if charFreq [ char - 9 7 ] < 0 { # return false # } # } # return true
n := len ( M ) # if n == 0 { # return 0 # } # visited := make ([] bool , n ) # res := 0 # # var dfs func ( int ) # dfs = func ( i int ) { # for j := 0 ; j < n ; j ++ { # if M [ i ][ j ] == 1 && ! visited [ j ] { # visited [ j ] = true # dfs ( j ) # } # } # } # # for i := 0 ; i < n ; i ++ { # if ! visited [ i ] { # dfs ( i ) # res ++ # } # } # return res
at [ state ] = make ( map [ uint 8 ] int )
p := Point { 1 , 2 } # q := Point { 4 , 6 } # # distance := Point . Distance # fmt . Println ( distance ( p , q )) # fmt . Printf (" STR ", distance ) # # scale := (* Point ). ScaleBy # scale (& p , 2 ) # fmt . Println ( p ) # fmt . Printf (" STR ", scale )
board := [][] int { # { 0 , 1 , 0 }, # { 0 , 0 , 1 }, # { 1 , 1 , 1 }, # { 0 , 0 , 0 }, # } # gameOfLife ( board )
profit , low := 0 , prices [ 0 ] # for i := 0 ; i < len ( prices ); i ++ { # profit = max ( profit , prices [ i ]- low ) # low = min ( low , prices [ i ]) # } # return profit
type arg struct { # s int # nums [] int # } # testData := [] arg { # { # s : 7 , # nums : [] int { 2 , 3 , 1 , 2 , 4 , 3 }, # }, # { # s : 7 , # nums : [] int { 7 , 4 , 3 , 2 }, # }, # { # s : 6 6 , # nums : [] int { 7 , 4 , 3 , 2 }, # }, # } # # expectedData := [] int { 2 , 1 , 0 } # # for index , data := range testData { # if res := minSubArrayLen ( data . s , data . nums ); res != expectedData [ index ] { # t . Errorf (" STR ", expectedData [ index ], res ) # } # }
t . Parallel () # for _ , tc := range testcases { # if result := ValidIPAddresses ( tc . digits ); ! reflect . DeepEqual ( tc . ips , result ) { # t . Errorf (" STR ", tc . ips , result ) # } # }
s := newStruct () # # f := s . Field (" STR ") # if f . Kind () != reflect . String { # t . Errorf (" STR ", f . Kind (), reflect . String ) # } # # f = s . Field (" STR ") # if f . Kind () != reflect . Int { # t . Errorf (" STR ", f . Kind (), reflect . Int ) # } # # f = s . Field (" STR ") # if f . Kind () != reflect . String { # t . Errorf (" STR ", f . Kind (), reflect . String ) # }
fmt . Println ( constructRectangle ( 4 ))
n := len ( A ) # for i , j := 0 , 1 ; i < n ; i += 2 { # for j < n && A [ j ]% 2 == 1 { # j += 2 # } # if A [ i ]% 2 == 1 { # A [ i ], A [ j ] = A [ j ], A [ i ] # j += 2 # } # } # return A
parsedTmpl , err := template . New (" STR "). Parse ( tmpl ) # if err != nil { # return nil , err # } # # var result bytes . Buffer # if err := parsedTmpl . Execute (& result , data ); err != nil { # return nil , err # } # # return result . Bytes (), nil
if len ( s ) == 0 { # return 0 # } # count := 0 # idx := 0 # for idx = len ( s )- 1 ; idx >= 0 && s [ idx ] == ' '; idx --{ # # } # for i := idx ; i >= 0 && s [ i ]!=' '; i --{ # count ++; # } # return count ;
data , err := hex . DecodeString ( hexs ) # if err != nil { # panic (" STR ") # } # # return base 6 4 . StdEncoding . EncodeToString ( data )
fakeHead := & LL { 0 , head } # for start := fakeHead ; start != nil ; start = start . Next { # var sum int # var farthest * LL # var found bool # for next := start . Next ; next != nil ; next = next . Next { # sum += next . Value # if sum == 0 { # farthest = next . Next # found = true # } # } # if found { # start . Next = farthest # } # } # return fakeHead . Next
for w := mySqrt ( area ); w > 1 ; w -- { # if area % w == 0 { # return [] int { area / w , w } # } # } # return [] int { area , 1 }
graph := createGraph ( rates ) # source := 0 # minDist := make ([] float 6 4 , len ( rates )) # for i := range minDist { # minDist [ i ] = math . Inf ( 1 ) # } # minDist [ source ] = 0 # # for i := 0 ; i < len ( graph )- 1 ; i ++ { # for v := range graph { # for w := range graph [ v ] { # if minDist [ w ] > minDist [ v ]+ graph [ v ][ w ] { # minDist [ w ] = minDist [ v ] + graph [ v ][ w ] # } # } # } # } # for v := range graph { # for w := range graph [ v ] { # if minDist [ w ] > minDist [ v ]+ graph [ v ][ w ] { # return true # } # } # } # return false
m := make ( map [ int ] int , len ( nums )) # for _ , num := range nums { # m [ num ]++ # } # # res := 0 # for _ , num := range nums { # if v , ok := m [ num + 1 ]; ok { # res = max ( res , m [ num ]+ v ) # } # } # return res
bs , i , j := [] byte ( s ), 0 , len ( s )- 1 # for i < j { # bs [ i ], bs [ j ] = bs [ j ], bs [ i ] # i ++ # j -- # } # return string ( bs )
init , end := 0 , len ( sortedArray )- 1 # # for init <= end { # middle := (( end - init ) >> 1 ) + init # # if sortedArray [ middle ] == el { # return middle # } # # if sortedArray [ middle ] < el { # init = middle + 1 # } else { # end = middle - 1 # } # } # # return - 1
maxans := 0 # dp := make ([] int , len ( s )) # # for i := 1 ; i < len ( s ); i ++ { # if s [ i ] == ')' { # if s [ i - 1 ] == '(' { # if i >= 2 { # dp [ i ] = dp [ i - 2 ] + 2 # } else { # dp [ i ] = 2 # } # } else if i - dp [ i - 1 ] > 0 && s [ i - dp [ i - 1 ]- 1 ] == '(' { # if i - dp [ i - 1 ] >= 2 { # dp [ i ] = dp [ i - 1 ] + dp [ i - dp [ i - 1 ]- 2 ] + 2 # } else { # dp [ i ] = dp [ i - 1 ] + 2 # } # } # } # maxans = Max ( maxans , dp [ i ]) # } # return maxans
pivot := data [ max ] # i := min # r := srank ( pivot ) # for j := min ; j < max ; j ++ { # if srank ( data [ j ]) <= r { # data [ i ], data [ j ] = data [ j ], data [ i ] # i ++ # } # } # data [ i ], data [ max ] = data [ max ], data [ i ] # return i
n := len ( nums ) # if n == 0 { # return " STR " # } # res := strconv . Itoa ( nums [ 0 ]) # if n == 1 { # return res # } # if n == 2 { # return res + " STR " + strconv . Itoa ( nums [ 1 ]) # } # res += " STR " + strconv . Itoa ( nums [ 1 ]) # for i := 2 ; i < n ; i ++ { # res += " STR " + strconv . Itoa ( nums [ i ]) # } # return res + " STR "
v 1 s := conv ( version 1 ) # v 2 s := conv ( version 2 ) # # if len ( v 1 s ) != len ( v 2 s ) { # v 1 s , v 2 s = toSameLen ( v 1 s , v 2 s ) # } # # for i := 0 ; i < len ( v 1 s ); i ++ { # if v 1 s [ i ] < v 2 s [ i ] { # return - 1 # } else if v 1 s [ i ] > v 2 s [ i ] { # return 1 # } # } # # return 0
for i , j , k := m + n - 1 , m - 1 , n - 1 ; i >= 0 ; i -- { # chosen := 0 # if k < 0 { # chosen = nums 1 [ j ] # j -- # } else if j < 0 { # chosen = nums 2 [ k ] # k -- # } else { # if nums 1 [ j ] > nums 2 [ k ] { # chosen = nums 1 [ j ] # j -- # } else { # chosen = nums 2 [ k ] # k -- # } # } # # if i < len ( nums 1 ) { # nums 1 [ i ] = chosen # } # }
result := make ([] string , 0 ) # if len ( cpdomains ) == 0 { # return result # } # domainCountMap := make ( map [ string ] int , 0 ) # for _ , domain := range cpdomains { # countDomain := strings . Split ( domain , " STR ") # allDomains := strings . Split ( countDomain [ 1 ], " STR ") # temp := make ([] string , 0 ) # for i := len ( allDomains ) - 1 ; i >= 0 ; i -- { # temp = append ([] string { allDomains [ i ]}, temp ...) # ld := strings . Join ( temp , " STR ") # count , _ := strconv . Atoi ( countDomain [ 0 ]) # if val , ok := domainCountMap [ ld ]; ! ok { # domainCountMap [ ld ] = count # } else { # domainCountMap [ ld ] = count + val # } # } # } # for k , v := range domainCountMap { # t := strings . Join ([] string { strconv . Itoa ( v ), k }, " STR ") # result = append ( result , t ) # } # return result
if N == 1 { # return 0 # } # if K & 1 == 1 { # return kthGrammar ( N - 1 , ( K + 1 )/ 2 ) # } # return ( kthGrammar ( N - 1 , K / 2 ) + 1 ) & 1
dp := make ([] int , amount + 1 ) # dp [ 0 ] = 0 # for i := 1 ; i < len ( dp ); i ++ { # dp [ i ] = amount + 1 # } # for i := 1 ; i <= amount ; i ++ { # for j := 0 ; j < len ( coins ); j ++ { # if coins [ j ] <= i { # dp [ i ] = min ( dp [ i ], dp [ i - coins [ j ]]+ 1 ) # } # } # } # if dp [ amount ] > amount { # return - 1 # } # return dp [ amount ]
qs := [] question 8 7 8 { # # { # para 8 7 8 { 1 , 2 , 3 }, # ans 8 7 8 { 2 }, # }, # # { # para 8 7 8 { 4 , 2 , 3 }, # ans 8 7 8 { 6 }, # }, # # { # para 8 7 8 { 5 , 2 , 4 }, # ans 8 7 8 { 1 0 }, # }, # # { # para 8 7 8 { 3 , 6 , 4 }, # ans 8 7 8 { 8 }, # }, # # { # para 8 7 8 { 1 0 0 0 0 0 0 0 0 0 , 4 0 0 0 0 , 4 0 0 0 0 }, # ans 8 7 8 { 9 9 9 7 2 0 0 0 7 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 7 8 , q . para 8 7 8 # fmt . Printf (" STR ", p , nthMagicalNumber ( p . n , p . a , p . b )) # } # fmt . Printf (" STR ")
if target < 0 { # target = - target # } # # n := int ( math . Ceil (( math . Sqrt ( 8 * float 6 4 ( target )+ 1 ) - 1 ) / 2 )) # # sum := n * ( n + 1 ) / 2 # # if sum == target { # return n # } # # x := sum - target # # if x & 1 == 0 { # return n # } # # if ( n + 1 )& 1 == 1 { # return n + 1 # } # # return n + 2 #
limit := 9 * 9 * 9 * 9 * 9 * ( 5 - 1 ) # sum := 0 # for i := 2 2 ; i < limit ; i ++ { # if i == sumOfFifthPowers ( i ) { # sum += i # } # } # println ( sum )
c := make ([] int , 2 6 ) # for _ , task := range tasks { # c [ task -' A ']++ # } # # most := 0 # for _ , count := range c { # if most < count { # most = count # } # } # idles := ( most - 1 ) * ( n + 1 ) # for _ , count := range c { # idles -= min ( most - 1 , count ) # } # return len ( tasks ) + max ( 0 , idles )
b . StopTimer () # arr := make ([] int , 0 , 0 ) # nodeArr := make ([]* FibHeapElement , 0 , 0 ) # h := NewFibHeap () # for i := 0 ; i < b . N ; i ++ { # n := rand . Intn ( 1 0 0 0 0 ) # nodeArr = append ( nodeArr , h . Insert ( n , n )) # arr = append ( arr , n + rand . Intn ( 5 0 )+ 5 0 ) # } # h . consolidate () # b . StartTimer () # for i := 0 ; i < b . N ; i ++ { # h . ModifyNode ( nodeArr [ i ], arr [ i ], arr [ i ]) # }
cases := [] struct { # name string # inputs [][] int # expect [][] int # }{ # {" STR ", # [][] int {{ 3 }, { 7 }}, # [][] int {{ 1 , 2 , 4 }}, # }, # {" STR ", # [][] int {{ 3 }, { 9 }}, # [][] int {{ 1 , 2 , 6 }, { 1 , 3 , 5 }, { 2 , 3 , 4 }}, # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := combinationSum 3 ( c . inputs [ 0 ][ 0 ], c . inputs [ 1 ][ 0 ]) # # if ! IsEuqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
for url := range incomingURLs () { # start := time . Now () # value , err := m . Get ( url ) # if err != nil { # log . Print ( err ) # continue # } # fmt . Printf (" STR ", # url , time . Since ( start ), len ( value .([] byte ))) # }
return (& Ewma {}). Init ( halfLife )
s := []* TreeNode {} # for _ , num := range nums { # node := & TreeNode { Val : num } # for len ( s ) != 0 && s [ len ( s )- 1 ]. Val < num { # node . Left = s [ len ( s )- 1 ] # s = s [: len ( s )- 1 ] # } # if len ( s ) != 0 { # s [ len ( s )- 1 ]. Right = node # } # s = append ( s , node ) # } # return s [ 0 ]
GMap := make ( map [ int ] bool ) # for _ , val := range G { # GMap [ val ] = true # } # ans , connected := 0 , false # for head != nil { # if GMap [ head . Val ] { # if ! connected { # ans ++ # } # connected = true # } else { # connected = false # } # head = head . Next # } # return ans
if source == " STR "" { # log . Println (" STR ") # return false # } # source_open , err := os . Open ( source ) # if err != nil { # log . Println ( err . Error ()) # return false # } # defer source_open . Close () # dest_open , err := os . OpenFile ( dest , os . O_CREATE | os . O_WRONLY , 6 4 4 ) # if err != nil { # log . Println ( err . Error ()) # return false # } # defer dest_open . Close () # _ , copy_err := io . Copy ( dest_open , source_open ) # if copy_err != nil { # log . Println ( copy_err . Error ()) # return false # } else { # return true # }
for job := range workerChan { # start := time . Now () # if job . run != nil { # err := job . run ( job ) # if err != nil { # job . err = err # } # } # job . duration = time . Since ( start ) # doneChan <- job # }
http . HandleFunc (" STR ", func ( res http . ResponseWriter , req * http . Request ) { # key := " STR " # file , _ , err := req . FormFile ( key ) # if err != nil { # panic ( err ) # } # defer file . Close () # # bs , _ := ioutil . ReadAll ( file ) # # fmt . Println ( string ( bs )) # res . Header (). Set (" STR ", " STR ") # io . WriteString ( res , `< form method =" STR " enctype =" STR "> # < input type =" STR " name =" STR "> # < input type =" STR "> # </ form >`) # }) # http . ListenAndServe (" STR ", nil )
fmt . Println ( uncommonFromSentences (" STR ", " STR "))
m := map [ rune ] int { # rune (' I '): 1 , # rune (' V '): 5 , # rune (' X '): 1 0 , # rune (' L '): 5 0 , # rune (' C '): 1 0 0 , # rune (' D '): 5 0 0 , # rune (' M '): 1 0 0 0 , # } # runes := [] rune ( s ) # if len ( runes ) == 1 { # return m [ runes [ 0 ]] # } # ret := m [ runes [ 0 ]] # for i := 1 ; i < len ( runes ); i ++ { # if m [ runes [ i - 1 ]] < m [ runes [ i ]] { # ret += m [ runes [ i ]] - 2 * m [ runes [ i - 1 ]] # } else { # ret += m [ runes [ i ]] # } # } # return ret
var last , first , second * TreeNode # var stack []* TreeNode # for 0 < len ( stack ) || root != nil { # for root != nil { # stack = append ( stack , root ) # root = root . Left # } # # top := len ( stack ) - 1 # if last != nil && stack [ top ]. Val <= last . Val { # if first == nil { # first = last # } # second = stack [ top ] # } # last = stack [ top ] # root = stack [ top ]. Right # stack = stack [: top ] # } # first . Val , second . Val = second . Val , first . Val
sum := 1 # for i := 2 ; i < ( n / 2 )+ 1 ; i ++ { # if n % i == 0 { # sum += i # } # } # return sum
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 2 , 2 , 3 , 4 }, 2 }, # {" STR ", [] int { 1 , 2 , 2 , 3 , 3 , 3 }, 3 }, # {" STR ", [] int { 2 , 2 , 2 , 3 , 3 }, - 1 }, # {" STR ", [] int { 1 }, 1 }, # {" STR ", [] int { 5 }, - 1 }, # {" STR ", [] int { 7 , 7 , 7 , 7 , 7 , 7 , 7 }, 7 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
n . t = t # n . c = make ([]* bTreeNode , 1 , 1 ) # n . keyValue = make ([]* keyValue , 0 , 0 ) # n . isLeaf = true # n . bTreeNodeSort = self # return n
var n sync . WaitGroup # for url := range incomingURLs () { # n . Add ( 1 ) # go func ( url string ) { # defer n . Done () # start := time . Now () # value , err := m . Get ( url ) # if err != nil { # log . Print ( err ) # return # } # fmt . Printf (" STR ", # url , time . Since ( start ), len ( value .([] byte ))) # }( url ) # } # n . Wait ()
arr := [] int { 1 , 1 , 2 , 2 , 5 , 3 , 3 } # res := arr [ 0 ] # for i := 1 ; i < len ( arr ); i ++ { # res = res ^ arr [ i ] # } # fmt . Println ( res )
for _ , op := range ops { # if op [ 0 ] < m { # m = op [ 0 ] # } # if op [ 1 ] < n { # n = op [ 1 ] # } # } # return m * n
fmt . Println (" STR ") # # ln , err := net . Listen (" STR ", " STR ") # if err != nil { # log . Fatal ( err ) # } # # conn , err := ln . Accept () # if err != nil { # log . Fatal ( err ) # } # # for { # message , _ := bufio . NewReader ( conn ). ReadString (" STR ") # fmt . Print (" STR ", string ( message )) # newMessage := strings . ToTitle ( message ) # conn . Write ([] byte ( newMessage + " STR ")) # }
emailSet := map [ string ] bool {} # for _ , email := range emails { # parts := strings . Split ( email , " STR ") # localName := strings . Replace ( strings . Split ( parts [ 0 ], " STR ")[ 0 ], " STR ", " STR ", - 1 ) # emailSet [ localName +" STR "+ parts [ 1 ]] = true # } # return len ( emailSet )
s := map [ int ] struct {}{} # for i := 1 ; i <= bound ; i *= x { # for j := 1 ; i + j <= bound ; j *= y { # s [ i + j ] = struct {}{} # if y == 1 { # break # } # } # if x == 1 { # break # } # } # l := make ([] int , 0 , len ( s )) # for k := range s { # l = append ( l , k ) # } # return l
ans , v := make ([] bool , len ( A )), 0 # for i , b := range A { # v = ( v << 1 + b ) % 5 # ans [ i ] = v == 0 # } # return ans
return helper 9 3 ( s , 0 , " STR ", make ([] string , 0 ), make ([] string , 0 ))
if len ( v ) < 2 { # } else if pos && v [ 0 ] == 0 { # for ; v [ n ] == 0 && n + 1 < len ( v ) && ( v [ n + 1 ]&( 1 << 7 ) == 0 ); n ++ { # } # } else if ! pos && v [ 0 ] == 0 xff { # for ; v [ n ] == 0 xff && n + 1 < len ( v ) && ( v [ n + 1 ]&( 1 << 7 ) != 0 ); n ++ { # } # } # return
v 4 := ip . To 4 () # if v 4 != nil { # * ip = append ( make ([] byte , 0 , 4 ), v 4 ...) # }
var combined , ptr * SinglyLL # done := false # for ! done { # remaining := 0 # var smallest * SinglyLL # smallestIndex := 0 # for i := range lists { # if lists [ i ] != nil { # if smallest == nil { # smallest = lists [ i ] # smallestIndex = i # } else if lists [ i ]. Value < smallest . Value { # smallest = lists [ i ] # smallestIndex = i # } # remaining ++ # } # } # switch { # case remaining == 0 : # done = true # case combined == nil : # lists [ smallestIndex ] = lists [ smallestIndex ]. Next # combined = smallest # ptr = smallest # ptr . Next = nil # default : # lists [ smallestIndex ] = lists [ smallestIndex ]. Next # ptr . Next = smallest # ptr = ptr . Next # ptr . Next = nil # } # } # return combined
var tests = [] struct { # houses , heaters [] int # radius int # }{ # {[] int { 1 , 5 }, [] int { 2 }, 3 }, # {[] int { 1 , 5 }, [] int { 1 0 }, 9 }, # {[] int { 1 , 2 , 3 }, [] int { 2 }, 1 }, # {[] int { 1 , 2 , 3 , 4 }, [] int { 1 , 4 }, 1 }, # } # # for _ , tt := range tests { # radius := findRadius ( tt . houses , tt . heaters ) # if radius != tt . radius { # t . Errorf (" STR ", tt . houses , tt . heaters , radius , tt . radius ) # } # }
res := [][] int {} # # var recur func ([] int , [] int ) # recur = func ( nums , tmp [] int ) { # n := len ( nums ) # if n == 0 { # res = append ( res , tmp ) # return # } # recur ( nums [: n - 1 ], tmp ) # recur ( nums [: n - 1 ], append ([] int { nums [ n - 1 ]}, tmp ...)) # } # recur ( nums , [] int {}) # return res
_ , ok := itf .( int ) # return ok
result := 1 # for i := 2 ; i <= 2 0 ; i ++ { # result *= getNewElement ( i ) # } # fmt . Println ( result )
num , _ := strconv . Atoi ( strconv . FormatInt ( int 6 4 ( i ), 7 )) # # base := 1 # prod := 1 # for base <= num { # digit :=(( num / base ) % 1 0 ) + 1 # prod *= digit # base *= 1 0 # } # return prod
if n == 0 { # return true # } # m := len ( flowerbed ) # for i , b := range flowerbed { # if b == 0 && # (( i + 1 < m && flowerbed [ i + 1 ] == 0 ) || i + 1 >= m ) && # (( i - 1 >= 0 && flowerbed [ i - 1 ] == 0 ) || i - 1 < 0 ) { # flowerbed [ i ] = 1 # n -- # if n == 0 { # return true # } # } # } # return false
n := len ( nums ) # # if k > n { # k %= n # } # if k == 0 || k == n { # return # } # # reverse ( nums , 0 , n - 1 ) # reverse ( nums , 0 , k - 1 ) # reverse ( nums , k , n - 1 )
return & inmemService { # m : map [ string ] Profile {}, # }
if l . pos >= len ( l . input ) { # l . width = 0 # return eof # } # r , l . width = utf 8 . DecodeRuneInString ( l . input [ l . pos :]) # l . pos += l . width # return r
sort . Slice ( moves , func ( i , j int ) bool { # return moves [ i ]. Timestamp < moves [ j ]. Timestamp # }) # if len ( moves ) == 0 { # return 0 , 0 # } # var start , end uint 6 4 # var count , maxCount int # for i , move := range moves { # if move . Type == Enter { # count += move . Count # if count > maxCount { # start = move . Timestamp # end = moves [ i + 1 ]. Timestamp # } # } else if move . Type == Exit { # count -= move . Count # } # } # return start , end
if k < 0 { # return 0 # } # # record := make ( map [ int ] int ) # for _ , num := range nums { # record [ num ]++ # } # # ans := 0 # # if k == 0 { # for _ , count := range record { # if count > 1 { # ans ++ # } # } # return ans # } # # for n := range record { # if record [ n - k ] > 0 { # ans ++ # } # } # # return ans
tests := [...] testType { # { # in : [] int { 2 , 2 , 1 }, # want : 1 , # }, # { # in : [] int { 4 , 1 , 2 , 1 , 2 }, # want : 4 , # }, # { # in : [] int { 1 , 2 , 1 , 2 , 3 }, # want : 3 , # }, # } # # for _ , tt := range tests { # got := singleNumber ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if n < 1 { # panic (" STR ") # } # # start := " STR " # # for i := 1 ; i < n ; i ++ { # var parts [] string # # var c rune # # count := 0 # # for i , r := range start { # switch { # case i == 0 : # c = r # count = 1 # case c != r : # parts = append ( parts , fmt . Sprintf (" STR ", count , string ( c ))) # c = r # count = 1 # default : # count ++ # } # } # # parts = append ( parts , fmt . Sprintf (" STR ", count , string ( c ))) # start = strings . Join ( parts , " STR ") # } # # return start
return helper ( nums , 0 , len ( nums )- 1 )
b . lock . Lock () # defer b . lock . Unlock () # # e := b . table [ key ] # if e == nil { # return nil , false # } # # b . touchEntry ( e ) # return e . value , true
s := make ([] bool , 1 0 5 0 0 0 ) # s [ 0 ], s [ 1 ] = true , true # i , p := 2 , 3 # var k int # for { # for k = 2 * p ; k < len ( s ); k += p { # s [ k ] = true # } # for k = p + 2 ; k < len ( s ) && s [ k ]; k += 2 { # } # if k < len ( s ) { # p = k # i ++ # if i == n { # break # } # } else { # break # } # } # return p
numMap := make ( map [ int ] bool ) # for n != 1 { # num := 0 # for i := 0 ; i < len ( strconv . Itoa ( n )); i ++ { # v := n / powerf ( 1 0 , i ) % 1 0 # num += v * v # } # n = num # if _ , ok := numMap [ n ]; ok { # return false # } # numMap [ n ] = true # } # return true
if index > l . Len () { # return nil , errors . New (" STR ") # } # # node := l . Head # for i := 0 ; i < index ; i ++ { # node = node . Next # } # # return node , nil
res = nil # dfs ( root ) # return res
var tests = [] struct { # before [] string # after [] string # }{ # {[] string {" STR ", " STR ", " STR ", " STR "}, [] string {" STR ", " STR "}}, # } # # for _ , tt := range tests { # before := make ([] string , len ( tt . before )) # copy ( before , tt . before ) # # after := findWords ( tt . before ) # if reflect . DeepEqual ( after , tt . after ) == false { # t . Errorf (" STR ", before , after , tt . after ) # } # }
fmt . Println ( toLowerCase (" STR "))
qs := [] question 4 6 { # # { # para 4 6 {[] int { 1 , 2 , 3 }}, # ans 4 6 {[][] int {{ 1 , 2 , 3 }, { 1 , 3 , 2 }, { 2 , 1 , 3 }, { 2 , 3 , 1 }, { 3 , 1 , 2 }, { 3 , 2 , 1 }}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 6 , q . para 4 6 # fmt . Printf (" STR ", p , permute ( p . s )) # } # fmt . Printf (" STR ")
fmt . Println ( findLengthOfLCIS ([] int { 1 , 3 , 5 , 4 , 7 })) # fmt . Println ( findLengthOfLCIS ([] int { 2 , 2 , 2 , 2 , 2 }))
n := len ( customers ) # satisfied , dis , maxDis := 0 , 0 , 0 # for i := 0 ; i < n ; i ++ { # satisfied += customers [ i ] * ( 1 - grumpy [ i ]) # dis += customers [ i ] * grumpy [ i ] # if i - X >= 0 { # dis -= customers [ i - X ] * grumpy [ i - X ] # } # maxDis = max ( maxDis , dis ) # } # return satisfied + maxDis
out := - 5 9 2 3 1 # if x := p 2 7 (); x != out { # t . Errorf (" STR ", x , out ) # }
count := 0 # current := list . head # for current != nil { # count += 1 # current = current . next # } # # return count
fmt . Println ( findPairs ([] int { 3 , 1 , 4 , 1 , 5 }, 2 )) # fmt . Println ( findPairs ([] int { 1 , 2 , 3 , 4 , 5 }, - 1 ))
res := make ([][] int , 0 ) # var dfs func (* TreeNode , int ) # dfs = func ( root * TreeNode , level int ) { # if root == nil { # return # } # # if level >= len ( res ) { # res = append ([][] int {{}}, res ...) # } # n := len ( res ) # res [ n - level - 1 ] = append ( res [ n - level - 1 ], root . Val ) # # dfs ( root . Left , level + 1 ) # dfs ( root . Right , level + 1 ) # } # # dfs ( root , 0 ) # return res
S = myabs ( S ) # sum := 0 # for _ , v := range nums { # sum += v # } # if sum < S || ( S + sum )% 2 != 0 { # return 0 # } # target := ( S + sum ) / 2 # dp := make ([] int , target + 1 ) # dp [ 0 ] = 1 # for _ , num := range nums { # for i := target ; i >= num ; i -- { # dp [ i ] += dp [ i - num ] # } # } # return dp [ target ]
m , i , c := 0 , 0 , 0 # t := kmpTable ( word ) # for m + i < len ( text ) { # fmt . Printf (" STR ", text [ m + i ], word [ i ], m + i , i ) # c ++ # if word [ i ] == text [ m + i ] { # fmt . Printf (" STR ") # if i == len ( word )- 1 { # return Result { # m , c , # } # } # i ++ # } else { # m = m + i - t [ i ] # if t [ i ] > - 1 { # i = t [ i ] # } else { # i = 0 # } # } # } # return Result { notFoundPosition , # c , # }
return len ( this )
words := strings . Fields ( S ) # var buffer bytes . Buffer # # vowels := map [ string ] int { # " STR ": 1 , # " STR ": 1 , # " STR ": 1 , # " STR ": 1 , # " STR ": 1 , # " STR ": 1 , # " STR ": 1 , # " STR ": 1 , # " STR ": 1 , # " STR ": 1 , # } # # for i := 0 ; i < len ( words ); i ++ { # first := string ( words [ i ][ 0 ]) # if vowels [ first ] == 1 { # buffer . WriteString ( words [ i ]) # buffer . WriteString (" STR ") # } else { # buffer . WriteString ( string ( words [ i ][ 1 :])) # buffer . WriteString ( first ) # buffer . WriteString (" STR ") # } # for j := 0 ; j <= i ; j ++ { # buffer . WriteString (" STR ") # } # if i != len ( words )- 1 { # buffer . WriteString (" STR ") # } # # } # return buffer . String ()
m , ans := make ( map [ string ] int , len ( list 1 )), [] string {} # for i , r := range list 1 { # m [ r ] = i # } # for j , r := range list 2 { # if _ , ok := m [ r ]; ok { # m [ r ] += j # if len ( ans ) == 0 || m [ r ] == m [ ans [ 0 ]] { # ans = append ( ans , r ) # } else if m [ r ] < m [ ans [ 0 ]] { # ans = [] string { r } # } # } # } # return ans
left , right , res , isAscending := 0 , 0 , 0 , true # for left < len ( A ) { # if right + 1 < len ( A ) && (( isAscending == true && A [ right + 1 ] > A [ left ] && A [ right + 1 ] > A [ right ]) || ( right != left && A [ right + 1 ] < A [ right ])) { # if A [ right + 1 ] < A [ right ] { # isAscending = false # } # right ++ # } else { # if right != left && isAscending == false { # res = max ( res , right - left + 1 ) # } # left ++ # if right < left { # right = left # } # if right == left { # isAscending = true # } # } # } # return res
for i , parent := h . Len ()- 1 , h . Len ()- 1 ; i > 0 ; i = parent { # parent = i >> 1 # if h . Less ( h . Get ( i ), h . Get ( parent )) { # h . data [ parent ], h . data [ i ] = h . data [ i ], h . data [ parent ] # } else { # break # } # }
visited := make ( map [ Node ] struct {}) # if edges := countEdges ( g ); edges != ( len ( g )- 1 )* 2 { # return false # } # start := randomNode ( g ) # isConnected ( g , start , visited ) # return len ( visited ) == len ( g )
obj := Constructor () # # for _ , word := range [] string {" STR ", " STR ", " STR "} { # obj . AddWord ( word ) # } # # for i , j := range map [ string ] bool {" STR ": false , " STR ": true , " STR ": true , " STR ": true , " STR ": false } { # if res := obj . Search ( i ); res != j { # t . Errorf (" STR ", j , res ) # } # }
size := len ( a ) # es := make ([] entry , 0 , size / 2 ) # for i := 0 ; i + 1 < size ; i += 2 { # if a [ i ] == 0 { # continue # } # es = append ( es , entry { # count : a [ i ], # number : a [ i + 1 ], # }) # } # return RLEIterator { # es : es , # }
root := & trieNode {} # for _ , word := range wordDict { # node := root # for _ , ch := range word { # index := int ( ch - ' a ') # if node . children [ index ] == nil { # node . children [ index ] = & trieNode {} # } # # node = node . children [ index ] # } # # node . isWord = true # } # # memo := make ([][] string , len ( s )+ 1 ) # return helper 1 4 0 ( s , 0 , root , root , " STR ", memo )
fmt . Println ( matrixReshape ([][] int { # { 1 , 2 }, # { 3 , 4 }, # }, 1 , 4 ))
var x int # x = 3 # listNode := & ListNode { # Val : 1 , # Next : & ListNode { # Val : 4 , # Next : & ListNode { # Val : 3 , # Next : & ListNode { # Val : 2 , # Next : & ListNode { # Val : 5 , # Next : & ListNode { # Val : 2 , # Next : nil , # }, # }, # }, # }, # }, # } # partition ( listNode , x )
if root == nil { # return [][] int {} # } # # var ( # queue [] queueEle # res = make ([][] int , 0 ) # ) # # queue = append ( queue , queueEle { Level : 0 , Ele : root }) # # for len ( queue ) > 0 { # node := queue [ 0 ]. Ele # level := queue [ 0 ]. Level # queue = queue [ 1 :] # # if len ( res ) > level { # res [ level ] = append ( res [ level ], node . Val ) # } else { # res = append ( res , [] int { node . Val }) # } # # if node . Left != nil { # queue = append ( queue , queueEle { Level : level + 1 , Ele : node . Left }) # } # if node . Right != nil { # queue = append ( queue , queueEle { Level : level + 1 , Ele : node . Right }) # } # # } # return res
i := uint ( 1 ) # for ; n > 1 ; i ++ { # if n % 2 == 0 { # n = n / 2 # } else { # n = 3 * n + 1 # } # } # return i
if len ( s ) == 0 { # return 0 # } # dp := make ([] int , len ( s )+ 1 ) # dp [ 0 ] = 1 # if s [: 1 ] == " STR " { # dp [ 1 ] = 0 # } else { # dp [ 1 ] = 1 # } # for i := 2 ; i <= len ( s ); i ++ { # lastNum , _ := strconv . Atoi ( s [ i - 1 : i ]) # if lastNum >= 1 && lastNum <= 9 { # dp [ i ] += dp [ i - 1 ] # } # lastNum , _ = strconv . Atoi ( s [ i - 2 : i ]) # if lastNum >= 1 0 && lastNum <= 2 6 { # dp [ i ] += dp [ i - 2 ] # } # } # return dp [ len ( s )]
b . StopTimer () # h := NewFibHeap () # for i := 0 ; i < b . N ; i ++ { # n := rand . Intn ( 1 0 0 0 0 ) # h . Insert ( n , n ) # } # b . StartTimer () # for i := 0 ; i < b . N ; i ++ { # h . ExtractMin () # }
sort . Ints ( nums ) # # for _ , n := range numsCollection { # sort . Ints ( n ) # equal := true # for i := 0 ; i < len ( n ); i ++ { # if nums [ i ] != n [ i ] { # equal = false # break # } # } # # if equal { # return true # } # } # return false
qs := [] question 4 3 3 { # { # para 4 3 3 {" STR ", " STR ", [] string {" STR "}}, # ans 4 3 3 { 1 }, # }, # # { # para 4 3 3 {" STR ", " STR ", [] string {" STR ", " STR ", " STR "}}, # ans 4 3 3 { 2 }, # }, # # { # para 4 3 3 {" STR ", " STR ", [] string {" STR ", " STR ", " STR "}}, # ans 4 3 3 { 3 }, # }, # # { # para 4 3 3 {" STR ", " STR ", [] string {}}, # ans 4 3 3 {- 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 3 3 , q . para 4 3 3 # fmt . Printf (" STR ", p , minMutation ( p . start , p . end , p . bank )) # } # fmt . Printf (" STR ")
if 0 == n || 1 == n { # return 1 # } # if v , ok := table [ n ]; ok { # return v # } # num := 0 # for i := 1 ; i <= n ; i ++ { # num += numTrees ( i - 1 ) * numTrees ( n - i ) # } # table [ n ] = num # return num
if nil == root { # return nil # } # # ans := make ([] float 6 4 , 0 ) # queue := make ([]* TreeNode , 0 ) # queue = append ( queue , root ) # for len ( queue ) != 0 { # n := len ( queue ) # sum := 0 . 0 # for i := 0 ; i < n ; i ++ { # node := queue [ 0 ] # sum += float 6 4 ( node . Val ) # if nil != node . Left { # queue = append ( queue , node . Left ) # } # if nil != node . Right { # queue = append ( queue , node . Right ) # } # queue = queue [ 1 :] # } # ans = append ( ans , sum / float 6 4 ( n )) # } # return ans
n := count ( root ) # a , b := n / k , n % k # # parts := make ([]* ListNode , k ) # prev := new ( ListNode ) # for i := 0 ; i < k ; i ++ { # prev . Next = nil # parts [ i ] = root # for j := 0 ; j < a ; j ++ { # prev = root # root = root . Next # } # if i < b { # prev = root # root = root . Next # } # } # return parts
obj 1 := Constructor 1 5 5 () # obj 1 . Push ( 1 ) # fmt . Printf (" STR ", obj 1 ) # obj 1 . Push ( 0 ) # fmt . Printf (" STR ", obj 1 ) # obj 1 . Push ( 1 0 ) # fmt . Printf (" STR ", obj 1 ) # obj 1 . Pop () # fmt . Printf (" STR ", obj 1 ) # param 3 := obj 1 . Top () # fmt . Printf (" STR ", param 3 ) # param 4 := obj 1 . GetMin () # fmt . Printf (" STR ", param 4 )
return MyHashSet { table : make ([] bool , 1 0 0 0 0 0 1 )}
if len ( os . Args ) < 3 { # log . Fatalln (" STR ") # } # srcFileName := os . Args [ 1 ] # dstFileName := os . Args [ 2 ] # # err := cp ( srcFileName , dstFileName ) # if err != nil { # log . Fatalln ( err ) # }
if i > j { # return i # } # return j
reversed := make ( AdjacencyMatrix , len ( g )) # # for a := range g { # for b := range g [ a ] { # if _ , found := reversed [ b ]; ! found { # reversed [ b ] = make ( map [ rune ] struct {}) # } # # reversed [ b ][ a ] = struct {}{} # } # } # # return reversed
var n 1 , n 2 int # for _ , c := range s { # if c != ' ' { # n 2 ++ # } else if n 2 != 0 { # n 1 , n 2 = n 2 , 0 # } # } # if n 2 == 0 { # n 2 = n 1 # } # return n 2
res := 0 # for i := 1 ; i < len ( points ); i ++ { # res += max ( abs ( points [ i ][ 0 ]- points [ i - 1 ][ 0 ]), abs ( points [ i ][ 1 ]- points [ i - 1 ][ 1 ])) # } # return res
n := len ( A ) # dp := [ 5 0 ][ 5 0 ] int {} # for d := 2 ; d < n ; d ++ { # for i := 0 ; i + d < n ; i ++ { # k := i + d # dp [ i ][ k ] = 1 << 3 0 # for j := i + 1 ; j < k ; j ++ { # dp [ i ][ k ] = min ( dp [ i ][ k ], dp [ i ][ j ]+ dp [ j ][ k ]+ A [ i ]* A [ j ]* A [ k ]) # } # } # } # return dp [ 0 ][ n - 1 ]
wordMap , que , depth := getWordMap ( wordList , beginWord ), [] string { beginWord }, 0 # for len ( que ) > 0 { # depth ++ # qlen := len ( que ) # for i := 0 ; i < qlen ; i ++ { # word := que [ 0 ] # que = que [ 1 :] # candidates := getCandidates ( word ) # for _ , candidate := range candidates { # if _ , ok := wordMap [ candidate ]; ok { # if candidate == endWord { # return depth + 1 # } # delete ( wordMap , candidate ) # que = append ( que , candidate ) # } # } # } # } # return 0
return r . Update ( time . Now ())
var ans int # fibSeq := getFibSeq () # for i := 0 ; i <= N ; i ++ { # ans = fibSeq () # } # return ans
r := 0 # for n > 0 { # r = 1 0 * r + n % 1 0 # n /= 1 0 # } # return r
if len ( str ) == 1 { # return [] string { str } # } # # var ret [] string # for i , chr := range str { # rest := str [: i ] + str [ i + 1 :] # for _ , perm := range permute ( rest ) { # ret = append ( ret , string ( chr )+ perm ) # } # } # return ret
var mu sync . Mutex # var x int # go func () { # mu . Lock () # x = 5 # mu . Unlock () # }() # mu . Lock () # fmt . Println ( x ) # mu . Unlock ()
f , err := os . Create (" STR ") # if err != nil { # fmt . Println ( err . Error ()) # } # defer f . Close () # # f . WriteString ( s ) #
if n <= 0 { # return " STR " # } else if n == 1 { # return " STR " # } # rets := countAndSayInts ( n ) # bytes := make ([] byte , len ( rets )) # intTobyte := [] byte (" STR ") # for index , ret := range rets { # bytes [ index ] = intTobyte [ ret - 1 ] # } # return string ( bytes )
if len ( matrix ) == 0 { # return false # } # # lo , hi := 0 , len ( matrix )- 1 # for lo < hi { # mid := hi - ( hi - lo )/ 2 # switch { # case matrix [ mid ][ 0 ] < target : # lo = mid # case matrix [ mid ][ 0 ] > target : # hi = mid - 1 # default : # return true # } # } # # i := lo # lo , hi = 0 , len ( matrix [ i ])- 1 # for lo <= hi { # mid := lo + ( hi - lo )/ 2 # switch { # case matrix [ i ][ mid ] < target : # lo = mid + 1 # case matrix [ i ][ mid ] > target : # hi = mid - 1 # default : # return true # } # } # return false
ret := make ([] int , len ( nums )) # for k := range ret { # ret [ k ] = 1 # } # tmp := 1 # for i := 1 ; i < len ( nums ); i ++ { # ret [ i ] = ret [ i - 1 ] * nums [ i - 1 ] # } # for i := len ( nums ) - 1 ; i >= 0 ; i -- { # ret [ i ] = ret [ i ] * tmp # tmp *= nums [ i ] # } # return ret
file , err := os . Open ( archive ) # if err != nil { # return err # } # defer file . Close () # tr := tar . NewReader ( file ) # for { # hdr , err := tr . Next () # if err == io . EOF { # fmt . Println (" STR ") # break # } # if err != nil { # return err # } # size := hdr . Size # contents := make ([] byte , size ) # read , err := io . ReadFull ( tr , contents ) # if int 6 4 ( read ) != size { # return fmt . Errorf (" STR ", hdr . Name ) # } # fmt . Printf (" STR ", hdr . Name ) # fmt . Fprintf ( os . Stdout , " STR ", contents ) # } # return nil
size := len ( nums ) # # for i := 0 ; i < size ; i ++ { # nums [ i ] %= size # } # # bits := uint ( unsafe . Sizeof ( size ) - 1 ) # # for i , n := range nums { # mark := ( i + size ) * ( n >> bits | 1 ) # # for - size < n && n < size && n != 0 { # nums [ i ] = mark # # i = ( n + i + size ) % size # n = nums [ i ] # # if n == mark { # return true # } # # if n * mark < 0 { # break # } # } # } # # return false
obj := Constructor 2 3 2 () # fmt . Printf (" STR ", obj ) # obj . Push ( 2 ) # fmt . Printf (" STR ", obj ) # obj . Push ( 1 0 ) # fmt . Printf (" STR ", obj ) # param 2 := obj . Pop () # fmt . Printf (" STR ", param 2 ) # param 3 := obj . Peek () # fmt . Printf (" STR ", param 3 ) # param 4 := obj . Empty () # fmt . Printf (" STR ", param 4 )
for k := range inorder { # if preorder [ 0 ] == inorder [ k ] { # return & TreeNode { # Val : preorder [ 0 ], # Left : buildTree ( preorder [ 1 : k + 1 ], inorder [ 0 : k ]), # Right : buildTree ( preorder [ k + 1 :], inorder [ k + 1 :]), # } # } # } # # return nil
if len ( nums ) == 0 { # return 0 # } # if len ( nums ) == 1 { # return nums [ 0 ] # } # array := make ([] int , len ( nums )) # array [ 0 ] = nums [ 0 ] # if array [ 0 ] > nums [ 1 ] { # array [ 1 ] = array [ 0 ] # } else { # array [ 1 ] = nums [ 1 ] # } # for i := 2 ; i < len ( nums ); i ++ { # if array [ i - 1 ] > array [ i - 2 ]+ nums [ i ] { # array [ i ] = array [ i - 1 ] # } else { # array [ i ] = array [ i - 2 ] + nums [ i ] # } # } # return array [ len ( array )- 1 ]
t . Parallel () # for _ , tc := range testcases { # as := AddSubtract ( tc . input [ 0 ]) # for i := 1 ; i < len ( tc . input ); i ++ { # as = as . __ ( tc . input [ i ]) # } # if result := as . Execute (); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
t . Parallel () # for _ , tc := range testcases { # if result := NoAdjacent ( tc . s ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
ans := " STR " # if num < 0 { # ans , num = " STR ", - num # } # if num >= 7 { # ans += convertToBase 7 ( num / 7 ) # } # return ans + fmt . Sprintf (" STR ", ' 0 '+ num % 7 )
swap := func ( nums [] int , i int ) { # num := nums [ i ] # nums [ i ] = 0 # for num >= 1 && num <= len ( nums ) && num != i + 1 { # temp := nums [ num - 1 ] # nums [ num - 1 ] = num # i = num - 1 # num = temp # } # # if num == i + 1 { # nums [ i ] = num # } # } # # for i , num := range nums { # if num < 1 || num > len ( nums ) { # nums [ i ] = 0 # } else { # swap ( nums , i ) # } # } # # for i , num := range nums { # if num == 0 { # return i + 1 # } # } # # return len ( nums ) + 1
dp := make ([][] int , n + 1 ) # for i := range dp { # dp [ i ] = make ([] int , n + 1 ) # } # # for j := 2 ; j <= n ; j ++ { # for i := j - 1 ; 0 < i ; i -- { # dp [ i ][ j ] = i + dp [ i + 1 ][ j ] # for k := i + 1 ; k < j ; k ++ { # dp [ i ][ j ] = min ( dp [ i ][ j ], k + max ( dp [ i ][ k - 1 ], dp [ k + 1 ][ j ])) # } # } # } # # return dp [ 1 ][ n ]
naturals := make ( chan int ) # squares := make ( chan int ) # # go func () { # for x := 0 ; ; x ++ { # naturals <- x # } # }() # # go func () { # for { # x := <- naturals # squares <- x * x # } # }() # # for { # fmt . Println (<- squares ) # }
if d == 1 { # return & TreeNode { Val : v , Left : root } # } # if d == 2 { # root . Left = & TreeNode { Val : v , Left : root . Left } # root . Right = & TreeNode { Val : v , Right : root . Right } # # } else { # if root . Left != nil { # root . Left = addOneRow ( root . Left , v , d - 1 ) # } # if root . Right != nil { # root . Right = addOneRow ( root . Right , v , d - 1 ) # } # } # return root
for _ , v := range arr { # sum += v # } # return
s := newStruct () # # v := s . Field (" STR "). Value () # val , ok := v .( string ) # if ! ok { # t . Errorf (" STR ") # } # # if val != " STR " { # t . Errorf (" STR ", val ) # } # # defer func () { # err := recover () # if err == nil { # t . Error (" STR ") # } # }() # # _ = s . Field (" STR "). Value ()
isPrime := make ([] bool , num ) # for i := 0 ; i < num ; i ++ { # isPrime [ i ] = true # } # for i := 2 ; i * i < num ; i ++ { # if isPrime [ i ] == false { # continue # } # for j := i * i ; j < num ; j = j + i { # isPrime [ j ] = false # } # } # ans := 0 # for i := 2 ; i < num ; i ++ { # if isPrime [ i ] { # ans ++ # } # } # return ans
if val , ok := dp [ bit ]; ok { # return val # } # if left <= maxInt { # for i := maxInt ; i >= left ; i -- { # if ( bit & bitmap [ i ]) == 0 { # dp [ bit ] = true # return true # } # } # } # for i := maxInt ; i > 0 ; i -- { # if ( bit & bitmap [ i ]) > 0 { # continue # } # bit |= bitmap [ i ] # ret := helper ( maxInt , left - i , bit , dp , bitmap ) # bit &= ^ bitmap [ i ] # if ret == false { # dp [ bit ] = true # return true # } # } # dp [ bit ] = false # return false
tests := [...] testType { # { # in : 1 , # want : 0 , # }, # { # in : 3 , # want : 3 , # }, # { # in : 3 0 , # want : 1 0 , # }, # { # in : 9 7 , # want : 9 7 , # }, # } # for _ , tt := range tests { # got := minSteps ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if root . Val == x || root . Val == y { # return false # } # return bfs ([]* TreeNode { root }, x , y ) #
entries , err := ioutil . ReadDir ( dir ) # if err != nil { # fmt . Fprintf ( os . Stderr , " STR ", err ) # return nil # } # return entries
n := node .(* gbtElement ) # for ! t . color ( n . Parent ) && ! t . color ( n ) { # grandNode := n . Parent . Parent # uncleNode := grandNode . Right # if n . Parent == uncleNode { # uncleNode = grandNode . Left # } # if ! t . color ( uncleNode ) { # t . setColor ( grandNode , red ) # t . setColor ( grandNode . Left , black ) # t . setColor ( grandNode . Right , black ) # n = grandNode # } else { # side := n . Parent == grandNode . Left # t . setColor ( grandNode , red ) # if n == t . otherSideNode ( side , n . Parent ) { # t . sameDirRotation ( side , n . Parent ) # } # t . setColor ( t . sameSideNode ( side , grandNode ), black ) # t . invDirRotation ( side , grandNode ) # } # } # t . setColor ( t . Root ().(* gbtElement ), black )
start , end := 0 , len ( s )- 1 # i , j , times := 0 , 0 , 0 # for start < end { # if s [ start ] == s [ end ] { # start ++ # end -- # } else { # times ++ # if times == 1 { # i , j = start , end # start ++ # } else if times == 2 { # start , end = i , j - 1 # } else { # return false # } # } # } # return true
arr := strings . Split ( s , " STR ") # res := [] string {} # for i := 0 ; i < len ( arr ); i ++ { # if arr [ i ] != " STR " { # res = append ( res , arr [ i ]) # } # } # for i , j := 0 , len ( res )- 1 ; i < j ; i , j = i + 1 , j - 1 { # res [ i ], res [ j ] = res [ j ], res [ i ] # } # # return strings . Replace ( strings . Trim ( fmt . Sprint ( res ), " STR "), " STR ", " STR ", - 1 ) #
squareOfSum , sumOfSquare := 0 , 0 # # for counter := 1 ; counter <= 1 0 0 ; counter ++ { # squareOfSum += counter # sumOfSquare = sumOfSquare + ( counter * counter ) # } # # squareOfSum = squareOfSum * squareOfSum # # answer := squareOfSum - sumOfSquare # fmt . Println ( answer )
o . Status = newStatus
lo , hi := 0 , len ( A )- 1 # for lo < hi { # mid := lo + ( hi - lo )/ 2 # if A [ mid ] > A [ mid + 1 ] { # hi = mid # } else { # lo = mid + 1 # } # } # return lo
dp := make ([] int , target + 1 ) # # var recur func ( int ) int # recur = func ( t int ) int { # if dp [ t ] > 0 { # return dp [ t ] # } # n := uint ( math . Log 2 ( float 6 4 ( t ))) + 1 # if t == 1 << n - 1 { # dp [ t ] = int ( n ) # } else { # dp [ t ] = recur ( 1 << n - 1 - t ) + int ( n ) + 1 # for m := uint ( 0 ); m < n - 1 ; m ++ { # dp [ t ] = min ( dp [ t ], recur ( t - 1 <<( n - 1 )+ 1 << m )+ int ( n - 1 )+ 1 + int ( m )+ 1 ) # } # } # return dp [ t ] # } # return recur ( target )
if target < 0 { # return # } # # if target == 0 { # result = append ( result , solution ) # fmt . Println ( solution ) # return # } # # for i := start ; i < len ( candidates ); i ++ { # if i > start && candidates [ i ] == candidates [ i - 1 ] { # continue # } # # solution = append ( solution , candidates [ i ]) # combinationSumHelper ( candidates , i , target - candidates [ i ], solution , result ) # # solution = solution [: len ( solution )- 1 ] # # } #
m := make ([] int , 2 6 ) # if len ( S ) <= 1 { # return S # } # for _ , s := range S { # m [ s -' a '] += 1 0 0 # } # for i , v := range m { # m [ i ] = v + i # } # sort . Ints ( m ) # ret := make ([] rune , len ( S )) # t := 1 # for _ , c := range m { # cnt , ch := c / 1 0 0 , rune ( c % 1 0 0 +' a ') # if cnt > ( len ( S )+ 1 )/ 2 { # return " STR " # } # for i := 0 ; i < cnt ; i ++ { # if t >= len ( S ) { # t = 0 # } # ret [ t ] = ch # t += 2 # # } # } # return string ( ret ) #
count := 0 # a := make ([] int , N + 1 ) # for i := 0 ; i <= N ; i ++ { # a [ i ] = i # } # # var dfs func ( int ) # dfs = func ( idx int ) { # if idx == 0 { # count ++ # return # } # # for i := idx ; i > 0 ; i -- { # a [ idx ], a [ i ] = a [ i ], a [ idx ] # if isBeautiful ( a [ idx ], idx ) { # dfs ( idx - 1 ) # } # a [ idx ], a [ i ] = a [ i ], a [ idx ] # } # } # # dfs ( N ) # return count
h := newLtHeapArray () # benchmarkHeap ( b , h )
sort . Ints ( nums ) # result := make ([][] int , 0 ) # for i := 0 ; i < len ( nums )- 2 ; { # j , k := i + 1 , len ( nums )- 1 # for j < k { # sum := nums [ i ] + nums [ j ] + nums [ k ] # if sum < 0 { # j ++ # } else if sum > 0 { # k -- # } else { # result = append ( result , [] int { nums [ i ], nums [ j ], nums [ k ]}) # temp := j # for j < k && nums [ j ] == nums [ temp ] { # j ++ # } # } # } # # temp := i # for i < len ( nums )- 2 && nums [ i ] == nums [ temp ] { # i ++ # } # } # # return result
res := 0 # var dfs func (* TreeNode ) int # dfs = func ( node * TreeNode ) int { # if node == nil { # return 2 # } # l , r := dfs ( node . Left ), dfs ( node . Right ) # if l == 0 || r == 0 { # res ++ # return 1 # } # if l == 1 || r == 1 { # return 2 # } # return 0 # } # if dfs ( root ) < 1 { # res ++ # } # return res
for i := 0 ; i < len ( matrix )- 1 ; i ++ { # for j := 0 ; j < len ( matrix [ 0 ])- 1 ; j ++ { # if matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ] { # return false # } # } # } # return true
file , _ := ioutil . ReadFile (" STR ") # num_str := string ( file [: len ( file )]) # trimmed_num_str := strings . TrimSpace ( num_str ) # lines := strings . Split ( trimmed_num_str , " STR ") # # sum := big . NewInt ( 0 ) # # for _ , line := range lines { # i := big . NewInt ( 0 ) # i . SetString ( line , 1 0 ) # sum . Add ( sum , i ) # } # # sum_string := sum . String () # sum_string = sum_string [: 1 0 ] # # fmt . Println ( sum_string )
iE := i .(* ltHeapElement ) # return iE . left
var ( # n int # uuid = make ([] byte , Size ) # ) # if n , err = io . ReadFull ( rand . Reader , uuid ); err != nil { # return # } # if n != Size { # return "", ErrUUIDSize # } # uuid [ 8 ] = uuid [ 8 ]&^ 0 xc 0 | 0 x 8 0 # uuid [ 6 ] = uuid [ 6 ]&^ 0 xf 0 | 0 x 4 0 # str = fmt . Sprintf (" STR ", uuid [ 0 : 4 ], uuid [ 4 : 6 ], uuid [ 6 : 8 ], uuid [ 8 : 1 0 ], uuid [ 1 0 :]) # return
sort . Ints ( A ) # n := len ( A ) # # minDiff := math . MaxInt 6 4 # for i := 1 ; i < n ; i ++ { # minDiff = min ( minDiff , A [ i ]- A [ i - 1 ]) # } # # res := make ([][] int , 0 , n ) # # for i := 1 ; i < n ; i ++ { # if A [ i ]- A [ i - 1 ] == minDiff { # res = append ( res , [] int { A [ i - 1 ], A [ i ]}) # } # } # # return res
for _ , x := range vec { # sum += x # } # return
cases := [] struct { # name string # inputs string # expect int # }{ # {" STR ", " STR ", 3 }, # {" STR ", " STR ", 1 }, # {" STR ", " STR ", 3 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := lengthOfLongestSubstring 2 ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
return ints [ index ]
counter := 2 # primeCounter := 0 # for ; primeCounter < 1 0 0 0 1 ; counter ++ { # if isPrime ( counter ){ # fmt . Println ( counter ) # primeCounter ++ # } # } # fmt . Println ( counter - 1 , primeCounter )
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 2 , 3 }, 6 }, # {" STR ", [] int { 1 , 2 , 3 , 4 }, 2 4 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := maximumProduct ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
return s [ i ] < s [ j ]
sort . Ints ( nums ) # return nums
noZeroPair := [] int {} # for i := 1 ; i <= n / 2 ; i ++ { # if isNoZero ( i ) && isNoZero ( n - i ) { # noZeroPair = append ( noZeroPair , [] int { i , n - i }...) # break # } # } # return noZeroPair
node := hm . getNodeByHash ( hm . hash ( key )) # return node != nil
r := 0 # # fmt . Println (" STR ", r )
nums = InsertSort ( nums ) # # major , count := nums [ 0 ], 0 # # for _ , v := range nums { # if count == 0 { # count ++ # major = v # } else if major == v { # count ++ # } else { # count -- # } # } # # return major
var one , two , three int # # for _ , num := range nums { # two |= one & num # one ^= num # # three = one & two # one &= ^ three # two &= ^ three # } # return one
tests := [...] testType { # { # in : 1 0 0 , # want : " STR ", # }, # { # in : - 7 , # want : " STR ", # }, # { # in : - 1 , # want : " STR ", # }, # { # in : 0 , # want : " STR ", # }, # } # for _ , tt := range tests { # got := convertToBase 7 ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
primes := [] int { 3 , 7 , 9 , 1 1 , 1 3 , 1 7 , 1 9 } # for _ , i := range primes { # if ( n % uint 6 4 ( i )) != 0 { # return false # } # } # rest := [] int { 4 , 8 , 1 2 , 1 4 , 1 6 , 1 8 } # for _ , i := range rest { # if ( n % uint 6 4 ( i )) != 0 { # return false # } # } # return true
qs := [] question 6 8 2 { # # { # para 6 8 2 {[] string {" STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 6 8 2 { 3 0 }, # }, # # { # para 6 8 2 {[] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 6 8 2 { 2 7 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 8 2 , q . para 6 8 2 # fmt . Printf (" STR ", p , calPoints ( p . one )) # } # fmt . Printf (" STR ")
if newton_sqrt ( 3 3 3 , 1 e - 7 , 1 e 7 ) != 1 8 . 2 4 8 2 8 7 5 9 1 6 1 7 5 5 4 || # newton_sqrt ( 6 1 0 0 9 , 1 e - 7 , 1 e 7 ) != 2 4 7 || # newton_sqrt ( 9 , 1 e - 7 , 1 e 7 ) != 3 { # t . Error () # }
sum := 0 # stack := make ([][] int , 0 ) # for i , v := range A { # for len ( stack ) > 0 && stack [ len ( stack )- 1 ][ 0 ] >= v { # num := stack [ len ( stack )- 1 ][ 0 ] # idx := stack [ len ( stack )- 1 ][ 1 ] # stack = stack [: len ( stack )- 1 ] # # prev := - 1 # if len ( stack ) > 0 { # prev = stack [ len ( stack )- 1 ][ 1 ] # } # # sum += num * ( idx - prev ) * ( i - idx ) # sum = sum % 1 0 0 0 0 0 0 0 0 7 # } # # stack = append ( stack , [] int { v , i }) # } # # prev , next := 0 , len ( A )- 1 # for i := range stack { # num , idx := stack [ i ][ 0 ], stack [ i ][ 1 ] # # sum += num * ( idx - prev + 1 ) * ( next - idx + 1 ) # sum = sum % 1 0 0 0 0 0 0 0 0 7 # prev = idx + 1 # } # # return sum
if d == 1 { # return & TreeNode { Val : v , Left : root } # } # insert ( root , v , d ) # return root
low , high := 0 , len ( letters )- 1 # for low <= high { # mid := low + ( high - low )>> 1 # if letters [ mid ] > target { # high = mid - 1 # } else { # low = mid + 1 # } # } # find := letters [ low % len ( letters )] # if find <= target { # return letters [ 0 ] # } # return find
const gridSize = 2 0 # # grid := [ gridSize + 1 ][ gridSize + 1 ] int {} # for i := 0 ; i <= gridSize ; i ++ { # grid [ gridSize ][ i ] = 1 # grid [ i ][ gridSize ] = 1 # } # # for i := gridSize - 1 ; i >= 0 ; i -- { # for j := gridSize - 1 ; j >= 0 ; j -- { # grid [ i ][ j ] = grid [ i + 1 ][ j ] + grid [ i ][ j + 1 ] # } # } # # fmt . Println ( grid [ 0 ][ 0 ])
t . Parallel () # for tcid , tc := range testcases { # if result := BuildTreeFromPostorder ( tc . postorder ); ! equal ( result , tc . expected ) { # t . Errorf (" STR ", tcid ) # } # }
ans , anchor , l := 0 , 0 , len ( chars ) # for i , c := range chars { # if i == l - 1 || c != chars [ i + 1 ] { # chars [ ans ] = chars [ anchor ] # ans ++ # if i > anchor { # for _ , n := range strconv . Itoa ( i - anchor + 1 ) { # chars [ ans ] = byte ( n ) # ans ++ # } # } # anchor = i + 1 # } # } # return ans
size := len ( nums ) # dp := make ([] int , size + 1 ) # for i := 1 ; i <= size ; i ++ { # dp [ i ] = dp [ i - 1 ] + nums [ i - 1 ] # } # # return NumArray { dp : dp }
strMap := make ( map [ string ] int ) # var res [][] string # mapIndex := 0 # for _ , str := range strs { # strSort := sortString ( str ) # # if _ , ok := strMap [ strSort ]; ! ok { # res = append ( res , [] string { str }) # strMap [ strSort ] = mapIndex # mapIndex ++ # } else { # res [ strMap [ strSort ]] = append ( res [ strMap [ strSort ]], str ) # } # } # return res
switch t := T . Underlying ().( type ) { # case * types . Array : # return s . Alignof ( t . Elem ()) # case * types . Struct : # max := int 6 4 ( 1 ) # for i := 0 ; i < t . NumFields (); i ++ { # f := t . Field ( i ) # if a := s . Alignof ( f . Type ()); a > max { # max = a # } # } # return max # case * types . Slice , * types . Interface : # return s . PtrSize # case * types . Basic : # if t . Info ()& types . IsString != 0 { # return s . PtrSize # } # } # a := s . Sizeof ( T ) # if a < 1 { # return 1 # } # if t , ok := T . Underlying ().(* types . Basic ); ok && t . Info ()& types . IsComplex != 0 { # a /= 2 # } # if a > s . MaxAlign { # return s . MaxAlign # } # return a
m , n := 3 , 3 # nums 1 := [] int { 1 , 2 , 3 , 0 , 0 , 0 } # nums 2 := [] int { 2 , 5 , 6 } # ret := [] int { 1 , 2 , 2 , 3 , 5 , 6 } # merge ( nums 1 , m , nums 2 , n ) # for k , v := range ret { # if nums 1 [ k ] != v { # t . Fatalf (" STR ", nums 1 ) # } # }
ttl := 0 # for i := 1 ; i <= x ; i ++ { # ttl += int ( math . Pow ( float 6 4 ( i ), 2 . 0 )) # } # xc <- ttl
cases := [] struct { # name string # input [] int # expect [] int # }{ # {" STR ", [] int { 1 , 2 , 3 }, [] int { 1 , 2 , 4 }}, # {" STR ", [] int { 9 , 9 , 9 }, [] int { 1 , 0 , 0 , 0 }}, # {" STR ", [] int { 5 , 9 , 9 }, [] int { 6 , 0 , 0 }}, # {" STR ", [] int {}, [] int { 1 }}, # } # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i + 1 ), func ( t * testing . T ) { # got := Solution ( c . input ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input ) # } # }) # }
for i := 1 ; num > 0 ; i += 2 { # num -= i # } # return num == 0
m := make ( map [ int ] int ) # for i := 0 ; i < len ( nums ); i ++ { # another := target - nums [ i ] # if _ , ok := m [ another ]; ok { # return [] int { m [ another ], i } # } # m [ nums [ i ]] = i # } # return nil
return math . Sqrt ( n )
return frameInfoLine { # loc : fi . loc , # cfaRegister : fi . cfaRegister , # cfaOffset : fi . cfaOffset , # }
bt := newTestBTree ( 2 ) # arr := RandomSlice ( 0 , 2 0 , 1 0 ) # exp := make ([] int , len ( arr ), cap ( arr )) # copy ( exp , arr ) # sort . Ints ( exp ) # for i := range arr { # bt . insert ( arr [ i ], arr [ i ]) # } # checkBtree ( t , exp , & bt . bTree ) # for i := range arr { # bt . insert ( arr [ i ], arr [ i ]) # } # checkBtree ( t , exp , & bt . bTree )
fmt . Fprintf ( c . output , " STR ") # fmt . Fprintln ( c . output , s )
if z == 0 { # return true # } # # if x + y < z { # return false # } # # if x > y { # x , y = y , x # } # # if x == 0 { # return y == z # } # # for y % x != 0 { # x , y = y % x , x # } # # return z % x == 0
for i := 0 ; i < len ( letters )/ 2 ; i ++ { # if letters [ i ] != letters [ len ( letters )- 1 - i ] { # return false # } # } # return true
var i int # for i < len ( lst ) && lst [ i ] < pivot { # i ++ # } # for i < len ( lst ) && lst [ i ] == pivot { # i ++ # } # for i < len ( lst ) && lst [ i ] > pivot { # i ++ # } # return i == len ( lst )
lenA := len ( a ) # lenB := len ( b ) # if lenB > lenA { # a , b = b , a # lenA , lenB = lenB , lenA # } # b = strings . Repeat (" STR ", lenA - lenB ) + b # lenB = len ( b ) # # carry := byte ( 0 ) # ret := make ([] byte , lenB + 1 ) # # for i := lenB - 1 ; i >= 0 ; i -- { # numA := a [ i ] - " STR " # numB := b [ i ] - " STR " # sum := numA + numB + carry # ret [ i + 1 ] = sum & 1 + " STR " # carry = sum >> 1 # } # if carry == 0 { # ret = ret [ 1 :] # } else { # ret [ 0 ] = carry + " STR " # } # return string ( ret )
if N >= 5 0 0 0 { # return 1 # } # return serve (( N + 2 4 )/ 2 5 , ( N + 2 4 )/ 2 5 )
if x < 2 { # return x # } # r := x / 2 # for r > x / r { # r = ( r + x / r ) / 2 # } # return r
var i int 6 4 = 2 # for ; i < n ; i ++ { # if n % i == 0 { # return false # } # } # # return true
ss , l := [] rune ( s ), len ( s )- 1 # for i := 0 ; i < l ; i += 2 * k { # for m , n := i , i + k - 1 ; m < n ; m , n = m + 1 , n - 1 { # if n > l { # n = l # } # ss [ m ], ss [ n ] = ss [ n ], ss [ m ] # } # } # return string ( ss )
return MyLinkedList { Val : - 9 9 9 , Next : nil }
testData := [] arg { # { # numbers : [] int { 2 , 7 , 1 1 , 1 5 }, # target : 9 , # }, # } # # expectedData := [][] int { # { 1 , 2 }, # } # # for index , data := range testData { # if res := twoSum 2 ( data . numbers , data . target ); ! reflect . DeepEqual ( res , expectedData [ index ]) { # t . Errorf (" STR ", expectedData [ index ], res ) # } # } # # defer func () { # if err := recover (); err == nil { # t . Errorf (" STR ") # } # }() # # twoSum 2 ([] int { 2 , 7 , 1 1 , 1 5 }, 9 0 )
t . Parallel () # for _ , tc := range testcases { # if result := BalanceParens ( tc . parens ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
ans := make ([] byte , 0 , len ( S )) # for i := 0 ; i < len ( S ); i ++ { # n := len ( ans ) - 1 # if n >= 0 && ans [ n ] == S [ i ] { # ans = ans [: n ] # } else { # ans = append ( ans , S [ i ]) # } # } # return string ( ans )
if len ( A ) == 0 { # return [] int {} # } # ret := make ([] int , len ( A )) # a , b := 0 , 1 # for _ , v := range A { # if v % 2 == 0 { # ret [ a ] = v # a += 2 # } else { # ret [ b ] = v # b += 2 # } # } # return ret
res := make ([] bool , len ( A )) # r := 0 # for i , a := range A { # r = ( r * 2 + a ) % 5 # res [ i ] = r == 0 # } # return res
t . Parallel () # # for _ , tc := range testcases { # if bonuses := Bonuses ( tc . locs ); ! reflect . DeepEqual ( bonuses , tc . bonuses ) { # t . Errorf (" STR ", tc . bonuses , bonuses ) # } # }
b , err := marshal ( data ) # if err != nil { # panic ( err ) # } # return b
if left >= right { # if nums [ left ] != t { # return - 1 # } else { # return left # } # } # mid := int (( left + right ) / 2 ) # ret := help ( nums , left , mid , t ) # if ret != - 1 { # return ret # } # return help ( nums , mid + 1 , right , t )
cases := [] struct { # name string # sub string # main string # expect bool # }{ # {" STR ", " STR ", " STR ", true }, # {" STR ", " STR ", " STR ", false }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := isSubsequence ( c . sub , c . main ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . sub , c . main ) # } # }) # }
m := map [ int ] int {} # for _ , e := range edges { # for _ , v := range e { # m [ v ]++ # if 2 == m [ v ] { # return v # } # } # } # return 0
n := len ( A ) # dp := make ([] int , n + 1 ) # for i := 0 ; i < n ; i ++ { # curMax := A [ i ] # for j := 1 ; j <= K && i - j + 1 >= 0 ; j ++ { # curMax = max ( curMax , A [ i - j + 1 ]) # dp [ i + 1 ] = max ( dp [ i + 1 ], dp [ i - j + 1 ]+ curMax * j ) # } # } # return dp [ n ]
if q [ i ] == nil { # return false # } # if q [ j ] == nil { # return true # } # return q [ i ]. Val < q [ j ]. Val
qs := [] question 3 9 3 { # # { # para 3 9 3 {[] int { 1 9 7 , 1 3 0 , 1 }}, # ans 3 9 3 { true }, # }, # # { # para 3 9 3 {[] int { 2 3 5 , 1 4 0 , 4 }}, # ans 3 9 3 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 9 3 , q . para 3 9 3 # fmt . Printf (" STR ", p , validUtf 8 ( p . one )) # } # fmt . Printf (" STR ")
dp := make ([] int , len ( s )) # result := 0 # for i , ch := range [] byte ( s ) { # if ch == ')' { # var len int # if i > 0 && s [ i - 1 ] == '(' { # len = 2 # } else { # if i > 0 { # prev := i - dp [ i - 1 ] - 1 # if prev >= 0 && s [ prev ] == '(' { # len = dp [ i - 1 ] + 2 # } # } # } # # if i - len >= 0 { # len += dp [ i - len ] # } # # dp [ i ] = len # result = int ( math . Max ( float 6 4 ( result ), float 6 4 ( len ))) # } # } # # return result
ans , count := 1 , make ([] int , N + 1 ) # for _ , t := range trust { # count [ t [ 0 ]] = N # count [ t [ 1 ]]++ # if count [ t [ 1 ]] == N - 1 { # ans = t [ 1 ] # } # if ans == t [ 0 ] { # ans = - 1 # } # } # return ans
if l 1 == nil { # return l 2 # } # if l 2 == nil { # return l 1 # } # # if l 1 . Val < l 2 . Val { # l 1 . Next = mergeTwoLists ( l 1 . Next , l 2 ) # return l 1 # } # l 2 . Next = mergeTwoLists ( l 2 . Next , l 1 ) # return l 2 #
cases := [] struct { # name string # inputs [] int # expect [] int # }{ # {" STR ", [] int { 0 }, [] int { 1 }}, # {" STR ", [] int { 9 }, [] int { 1 , 0 }}, # {" STR ", [] int { 2 , 3 }, [] int { 2 , 4 }}, # } # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := plusOne ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
max , start , end := 0 , 0 , len ( height )- 1 # for start < end { # width := end - start # high := 0 # if height [ start ] < height [ end ] { # high = height [ start ] # start ++ # } else { # high = height [ end ] # end -- # } # # temp := width * high # if temp > max { # max = temp # } # } # return max
for i := 1 ; i < len ( A ); i ++ { # A [ i ] += A [ i - 1 ] # } # res , lMax , mMax := A [ L + M - 1 ], A [ L - 1 ], A [ M - 1 ] # for i := L + M ; i < len ( A ); i ++ { # lMax = max ( lMax , A [ i - M ]- A [ i - L - M ]) # mMax = max ( mMax , A [ i - L ]- A [ i - L - M ]) # res = max ( res , max ( lMax + A [ i ]- A [ i - M ], mMax + A [ i ]- A [ i - L ])) # } # return res
return i - 1 , j
connects := make ([][] int , N ) # for _ , p := range paths { # i , j := p [ 0 ]- 1 , p [ 1 ]- 1 # connects [ i ] = append ( connects [ i ], j ) # connects [ j ] = append ( connects [ j ], i ) # } # res := make ([] int , N ) # for i := 0 ; i < N ; i ++ { # isUsed := [ 5 ] bool {} # for _ , j := range connects [ i ] { # isUsed [ res [ j ]] = true # } # for color := 1 ; color <= 4 ; color ++ { # if ! isUsed [ color ] { # res [ i ] = color # break # } # } # } # return res
counts := [ 2 6 ] int {} # length := 0 # for i := 0 ; i < len ( p ); i ++ { # if 0 < i && ( p [ i - 1 ]+ 1 == p [ i ] || p [ i - 1 ] == p [ i ]+ 2 5 ) { # length ++ # } else { # length = 1 # } # # b := p [ i ] - ' a ' # if length > counts [ b ] { # counts [ b ] = length # } # } # # res := 0 # for i := 0 ; i < 2 6 ; i ++ { # res += counts [ i ] # } # return res
x ^= x << 1 3 # x ^= x >> 1 7 # x ^= x << 5 # return x
return (* int )( x )
var ret int # var nums [] int # ret = 7 # nums = [] int { 0 , 0 , 1 , 1 , 1 , 1 , 2 , 3 , 3 } # if ret != removeDuplicates ( nums ) { # t . Fatalf (" STR ", ret ) # }
tests := [...] testType { # { # nums : [] int { 2 , 7 , 1 1 , 1 5 }, # target : 9 , # want : [] int { 0 , 1 }, # }, # { # nums : [] int { 2 , 7 , 1 1 , 1 5 }, # target : 1 0 , # want : nil , # }, # { # nums : [] int { 1 , 2 , 3 , 4 }, # target : 5 , # want : [] int { 1 , 2 }, # }, # } # for _ , tt := range tests { # got := twoSum ( tt . nums , tt . target ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . nums , got , tt . want ) # } # }
err := ll . CheckRangeFromIndex ( left , right ) # if err != nil { # return err # } # tmpNode := NewNode (- 1 ) # tmpNode . Next = ll . Head # pre := tmpNode # for i := 0 ; i < left - 1 ; i ++ { # pre = pre . Next # } # cur := pre . Next # for i := 0 ; i < right - left ; i ++ { # next := cur . Next # cur . Next = next . Next # next . Next = pre . Next # pre . Next = next # } # ll . Head = tmpNode . Next # return nil
queue := []* TreeNode { root } # i := 0 # for i < len ( queue ) && queue [ i ] != nil { # node := queue [ i ] # queue = append ( queue , node . Left ) # queue = append ( queue , node . Right ) # i ++ # } # for i < len ( queue ) && queue [ i ] == nil { # i ++ # } # return i == len ( queue )
size := len ( a ) # delta := make ([] int , size ) # for i := 0 ; i < size ; i ++ { # delta [( i - a [ i ]+ 1 + size )% size ]-- # } # # maxIdx := 0 # for k := 1 ; k < size ; k ++ { # delta [ k ] += delta [ k - 1 ] + 1 # if delta [ maxIdx ] < delta [ k ] { # maxIdx = k # } # } # # return maxIdx
t . Parallel () # # for _ , tc := range testcases { # if res := LargestSubsetCompatibleJobs ( tc . jobs ); ! reflect . DeepEqual ( res , tc . expected ) { # t . Errorf (" STR ", tc . expected , res ) # } # }
sum := 0 # for i := 1 ; i < 1 0 0 0 ; i ++ { # if i % 3 == 0 || i % 5 == 0 { # sum += i # } # } # # fmt . Printf (" STR ", sum )
e := encode ( N ) # for i := uint ( 0 ); i < 3 2 ; i ++ { # if encode ( 1 << i ) == e { # return true # } # } # return false
if root == nil { # return 0 # } # if root . Left == nil && root . Right == nil { # return 1 # } # left , right := - 1 , - 1 # if root . Left != nil { # left = minDepth ( root . Left ) # } # if root . Right != nil { # right = minDepth ( root . Right ) # } # depth := 1 # if left == - 1 { # depth += right # } else if right == - 1 { # depth += left # } else if left < right { # depth += left # } else { # depth += right # } # return depth
file , err := os . Open ( path ) # defer file . Close () # if err != nil { # log . Fatalln ( err . Error ()) # } # # data , err := ioutil . ReadAll ( file ) # return data
start := time . Now () # ch := make ( chan string ) # for _ , url := range os . Args [ 1 :] { # go fetch ( url , ch ) # } # for range os . Args [ 1 :] { # fmt . Println (<- ch ) # } # fmt . Printf (" STR ", time . Since ( start ). Seconds ())
total := 0 # for _ , v := range nums { # total += v # } # l := len ( nums ) # sum := l * ( l + 1 ) / 2 # return sum - total
res := make ([][] int , len ( M )) # for i := range res { # res [ i ] = make ([] int , len ( M [ 0 ])) # for j := range res [ i ] { # res [ i ][ j ] = getValue ( M , i , j ) # } # } # # return res
for buffer := 0 ; buffer < buffers ; buffer ++ { # <- s # }
number := int 6 4 ( 1 0 ) # # b . ResetTimer () # # for i := 0 ; i < b . N ; i ++ { # strconv . FormatInt ( number , 1 0 ) # }
if nil == root { # return 0 # } # left := treeDepth ( root . left ) # right := treeDepth ( root . right ) # if left >= right { # return left + 1 # } else { # return right + 1 # }
m := math . MaxInt 3 2 # for j := 0 ; j < len ( nums ); j ++ { # m = min ( nums [ j ], m ) # if m == nums [ j ] { # continue # } # for k := len ( nums ) - 1 ; k > j ; k -- { # if m < nums [ k ] && nums [ k ] < nums [ j ] { # return true # } # } # } # return false
arrLen := len ( inputArr ) # if arrLen == 0 { # return false # } # # var tmpCopy = make ([] string , arrLen ) # for i , v := range inputArr { # if v == " STR " || v == " STR " || v == " STR " { # tmpCopy [ i ] = v # } else if v == " STR " || v == " STR " || v == " STR " { # if i == 0 || tmpCopy [ i - 1 ] == " STR " { # return false # } # # if ( v == " STR " && tmpCopy [ i - 1 ] == " STR ") || ( v == " STR " && tmpCopy [ i - 1 ] == " STR ") || # ( v == " STR " && tmpCopy [ i - 1 ] == " STR ") { # tmpCopy [ i ] = v # } else { # return false # } # } else { # return false # } # fmt . Println ( tmpCopy ) # } # # return true #
n := node .(* bstElement ) # # leftistNode := func ( curNode * bstElement ) ( nextNode * bstElement ) { # nextNode = curNode # for nextNode . right != nil { # nextNode = t . Min ( nextNode . right ).(* bstElement ) # } # return # } # # for curNode := leftistNode ( t . Min ( n ).(* bstElement )); curNode != n ; { # stop := callback ( t , curNode ) # if stop { # return true # } # parentNode := curNode . parent # if curNode == parentNode . left { # curNode = leftistNode ( parentNode ) # } else { # curNode = parentNode # } # # } # return callback ( t , n )
if n < 2 { # return 1 # } # tmp := [] int { 1 , 2 } # for i := 2 ; i < n ; i ++ { # tmp = append ( tmp , tmp [ i - 1 ]+ tmp [ i - 2 ]) # } # return tmp [ n - 1 ]
qs := [] question 1 6 9 { # # { # para 1 6 9 {[] int { 2 , 2 , 1 }}, # ans 1 6 9 { 2 }, # }, # # { # para 1 6 9 {[] int { 3 , 2 , 3 }}, # ans 1 6 9 { 3 }, # }, # # { # para 1 6 9 {[] int { 2 , 2 , 1 , 1 , 1 , 2 , 2 }}, # ans 1 6 9 { 2 }, # }, # # { # para 1 6 9 {[] int {- 2 1 4 7 4 8 3 6 4 8 }}, # ans 1 6 9 {- 2 1 4 7 4 8 3 6 4 8 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 6 9 , q . para 1 6 9 # fmt . Printf (" STR ", p , majorityElement ( p . s )) # } # fmt . Printf (" STR ")
i := & Index { # Target : & VariableAccess { Name : " STR "}, # Key : & LiteralNode { # Typex : TypeString , # Value : " STR ", # }, # } # # scope := & BasicScope { # VarMap : map [ string ] Variable { # " STR ": Variable { # Type : TypeMap , # Value : map [ string ] Variable { # " STR ": Variable { # Type : TypeString , # Value : " STR ", # }, # " STR ": Variable { # Type : TypeInt , # Value : 4 3 , # }, # }, # }, # }, # } # # _ , err := i . Type ( scope ) # if err == nil || ! strings . Contains ( err . Error (), " STR ") { # t . Fatalf (" STR ") # }
if len ( grid ) == 0 { # return 0 # } # # elemCnt := len ( grid ) * len ( grid [ 0 ]) # colMaxSum := 0 # rowMaxSum := 0 # for i := 0 ; i < len ( grid ); i ++ { # rowIMax := 0 # for j := 0 ; j < len ( grid [ 0 ]); j ++ { # if grid [ i ][ j ] > rowIMax { # rowIMax = grid [ i ][ j ] # } # if grid [ i ][ j ] == 0 { # elemCnt -- # } # } # rowMaxSum += rowIMax # } # for i := 0 ; i < len ( grid [ 0 ]); i ++ { # colIMax := 0 # for j := 0 ; j < len ( grid ); j ++ { # if grid [ j ][ i ] > colIMax { # colIMax = grid [ j ][ i ] # } # } # colMaxSum += colIMax # } # return elemCnt + colMaxSum + rowMaxSum #
if n == 0 || n == 1 { # return big . NewInt ( 1 ) # } # if mem [ n ] != nil { # return mem [ n ] # } # var result * big . Int # result = big . NewInt ( n ). Mul ( big . NewInt ( n ), Factorial ( n - 1 , mem )) # mem [ n ] = result # return result
if n == 0 { # return nil # } # # res := make ([][] int , n ) # for i := range res { # res [ i ] = make ([] int , n ) # } # # max := n * n # next := nextFunc ( n ) # # for i := 1 ; i <= max ; i ++ { # x , y := next () # res [ x ][ y ] = i # } # # return res
dict := make ( map [ int ] int , 0 ) # for _ , v := range nums { # dict [ v ]++ # } # # ans := 0 # for k , v := range dict { # if _ , ok := dict [ k + 1 ]; ok { # ans = myMax ( ans , v + dict [ k + 1 ]) # } # } # return ans
m , n := len ( A ), len ( A [ 0 ]) # res := 0 # for j := 0 ; j < n ; j ++ { # for i := 1 ; i < m ; i ++ { # if A [ i - 1 ][ j ] > A [ i ][ j ] { # res ++ # break # } # } # } # return res
if len ( matrix ) < 1 || len ( matrix [ 0 ]) < 1 { # return false # } # # rowsStart , rowsEnd := 0 , len ( matrix )- 1 # for rowsStart <= rowsEnd { # rowsMid := ( rowsStart + rowsEnd ) / 2 # if target < matrix [ rowsMid ][ 0 ] { # rowsEnd = rowsMid - 1 # continue # } # if target > matrix [ rowsMid ][ len ( matrix [ 0 ])- 1 ] { # rowsStart = rowsMid + 1 # continue # } # # colsStart , colsEnd := 0 , len ( matrix [ 0 ])- 1 # for colsStart <= colsEnd { # colsMid := ( colsStart + colsEnd ) / 2 # switch { # case target == matrix [ rowsMid ][ colsMid ]: # return true # case target < matrix [ rowsMid ][ colsMid ]: # colsEnd = colsMid - 1 # case target > matrix [ rowsMid ][ colsMid ]: # colsStart = colsMid + 1 # } # } # return false # } # return false
total , coins = 2 0 0 , [] int { 1 , 2 , 5 , 1 0 , 2 0 , 5 0 , 1 0 0 , 2 0 0 } # println ( count ( total , len ( coins )))
bToI := map [ byte ] int { # ' 0 ': 0 , # ' 1 ': 1 , # ' 2 ': 2 , # ' 3 ': 3 , # ' 4 ': 4 , # ' 5 ': 5 , # ' 6 ': 6 , # ' 7 ': 7 , # ' 8 ': 8 , # ' 9 ': 9 , # } # i , j := - 1 , - 1 # for i < len ( version 1 ) || j < len ( version 2 ) { # num 1 , num 2 := 0 , 0 # for i ++; i < len ( version 1 ) && version 1 [ i ] != '.'; i ++ { # num 1 = num 1 * 1 0 + bToI [ version 1 [ i ]] # } # for j ++; j < len ( version 2 ) && version 2 [ j ] != '.'; j ++ { # num 2 = num 2 * 1 0 + bToI [ version 2 [ j ]] # } # if num 1 > num 2 { # return 1 # } else if num 1 < num 2 { # return - 1 # } # } # return 0
n , p := build ( numCourses , prerequisites ) # return search ( n , p )
t := strings . Count ( s , " STR ") # if t >= 2 { # return false # } # t = strings . Count ( s , " STR ") # if t > 0 { # return false # } # return true
t . Parallel () # for _ , tc := range testcases { # if minMoves := MinRedistributeNoGapsFaster ( tc . seating ); minMoves != tc . minMoves { # t . Errorf (" STR ", tc . minMoves , minMoves ) # } # }
e := & encoder {} # yaml_emitter_initialize (& e . emitter ) # yaml_emitter_set_output_string (& e . emitter , & e . out ) # yaml_emitter_set_unicode (& e . emitter , true ) # return e
eemap := make ( map [ string ] int , len ( evalvars )) # for i := range evalvars { # eemap [ evalvars [ i ]] = evalints [ i ] # } # # expression = strings . Replace ( expression , " STR ", " STR ", - 1 ) # # numbers := parse ( expression , eemap ) # # return format ( numbers )
http . HandleFunc (" STR ", SendJSON )
h . Cap = cap # h . Count = 0
var min byte = " STR " # c := 0 # for i := 0 ; i < len ( word ); i ++ { # if word [ i ] < min { # min = word [ i ] # c = 0 # } # if word [ i ] == min { # c ++ # } # } # return c
length := len ( s ) # num 1 := make ([] int , 2 5 6 ) # num 2 := make ([] int , 2 5 6 ) # # for i := 0 ; i < length ; i ++ { # if num 1 [ s [ i ]] != num 2 [ t [ i ]] { # return false # } # num 1 [ s [ i ]] = i + 1 # num 2 [ t [ i ]] = i + 1 # } # return true
wordToIndices := make ( map [ string ][] int ) # for i , word := range words { # if indices , exist := wordToIndices [ word ]; exist { # wordToIndices [ word ] = append ( indices , i ) # } else { # indices = make ([] int , 0 ) # wordToIndices [ word ] = append ( indices , i ) # } # } # # return WordDistance { # wordToIndices : wordToIndices , # }
n := len ( A ) # s := [] int {} # res := 0 # for i , a := range A { # if len ( s ) == 0 || A [ s [ len ( s )- 1 ]] > a { # s = append ( s , i ) # } # } # m := len ( s ) - 1 # for i := n - 1 ; i > res ; i -- { # for m >= 0 && A [ s [ m ]] <= A [ i ] { # res = max ( res , i - s [ m ]) # m -- # } # } # return res
r := make ( map [ int ] int ) # return Solution { # rows : rows , # cols : cols , # total : rows * cols , # rec : r , # }
return ll . tail . Data
defer func () { # err := recover () # if err == nil { # t . Errorf (" STR ") # } # # switch code := err .( type ) { # case exitCode : # if code != 1 5 2 { # t . Errorf (" STR ", code , 1 5 2 ) # } # default : # panic ( err ) # } # }() # # Return ( 1 5 2 )
max := 0 # res := 0 # for i , v := range arr { # if v > max { # max = v # } # if max == i { # res ++ # } # } # return res
if head == nil || head . Next == nil { # return head # } # before , after := & ListNode {}, & ListNode {} # bh , ah := before , after # for ; head != nil ; head = head . Next { # if head . Val < x { # before . Next = head # before = before . Next # } else { # after . Next = head # after = after . Next # } # } # after . Next , before . Next = nil , ah . Next # return bh . Next
sLen , pLen := len ( s ), len ( p ) # # dp := make ([][] bool , sLen + 1 ) # for i := 0 ; i < sLen + 1 ; i ++ { # dp [ i ] = make ([] bool , pLen + 1 ) # } # # dp [ 0 ][ 0 ] = true # for i := 1 ; i <= pLen ; i ++ { # if p [ i - 1 ] == '*' { # dp [ 0 ][ i ] = dp [ 0 ][ i - 1 ] # } # } # # for i := 1 ; i <= sLen ; i ++ { # for j := 1 ; j <= pLen ; j ++ { # if p [ j - 1 ] != '*' { # dp [ i ][ j ] = ( p [ j - 1 ] == s [ i - 1 ] || p [ j - 1 ] == '?') && dp [ i - 1 ][ j - 1 ] # } else { # dp [ i ][ j ] = dp [ i - 1 ][ j ] || dp [ i ][ j - 1 ] # } # } # } # return dp [ sLen ][ pLen ]
if head == nil { # return nil # } # # var n int # var p , q * ListNode # for q := head ; q != nil ; q = q . Next { # p = q # n ++ # } # p . Next , q = head , head # # bias := n - k % n # for i := 0 ; i < bias ; i ++ { # p , q = q , q . Next # } # p . Next = nil # return q
tests := [...] testType { # { # in : 1 0 , # want : 4 , # }, # { # in : 2 3 , # want : 1 1 , # }, # { # in : 1 0 0 , # want : 4 0 , # }, # { # in : 2 0 0 , # want : 8 1 , # }, # } # for _ , tt := range tests { # got := rotatedDigits ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
for i := len ( cost ) - 3 ; i >= 0 ; i -- { # cost [ i ] += myMin ( cost [ i + 1 ], cost [ i + 2 ]) # } # return myMin ( cost [ 0 ], cost [ 1 ])
rand . Seed ( time . Now (). UnixNano ()) # var inCircle , total int # for total = 0 ; total < iterations ; total ++ { # x := rand . Float 6 4 () # y := rand . Float 6 4 () # if x * x + y * y <= 1 { # inCircle ++ # } # } # return 4 . 0 * float 6 4 ( inCircle ) / float 6 4 ( total )
if len ( os . Args ) != 2 { # fmt . Println (" STR ") # return # } # conn , err := net . DialTimeout (" STR ", " STR ", 5 * time . Second ) # if err != nil { # fmt . Println (" STR ", err . Error ()) # return # } # defer conn . Close () # go getCmdExecResult ( conn ) # reader := bufio . NewReader ( os . Stdin ) # for { # cmdString , err := reader . ReadString ('\ n ') # isExit := strings . TrimSuffix ( cmdString , " STR ") # if isExit == " STR " { # fmt . Fprintln ( os . Stdout , " STR ") # os . Exit ( 0 ) # return # } # if err != nil { # _ , _ = fmt . Fprintln ( os . Stderr , err ) # } # if err != nil { # _ , _ = fmt . Fprintln ( os . Stderr , err ) # } # _ , _ = conn . Write ([] byte ( cmdString )) # }
for i := 0 ; i < b . N ; i ++ { # recurse ( 1 3 1 3 1 3 1 3 1 , 1 2 3 4 3 5 4 5 ) # }
products := make ([] int , len ( nums )) # # product := 1 # for i := range products { # products [ i ] = product # product *= nums [ i ] # } # # product = 1 # for i := len ( products ) - 1 ; i >= 0 ; i -- { # products [ i ] *= product # product *= nums [ i ] # } # # return products
iterator := func () <- chan VertexId { # ch := make ( chan VertexId ) # go func () { # if connected , ok := g . edges [ vertex ]; ok { # for VertexId , _ := range connected { # if g . IsEdge ( VertexId , vertex ) { # ch <- VertexId # } # } # } # close ( ch ) # }() # return ch # } # # return VerticesIterable (& vertexIterableHelper { iterFunc : iterator })
t . Parallel () # # for _ , tc := range testcases { # copied := append ([] int {}, tc . nums ...) # if result := SingleOccurrenceBrute ( copied ); ! reflect . DeepEqual ( result , tc . singleOccurrence ) { # t . Errorf (" STR ", tc . singleOccurrence , result ) # } # }
size := len ( Profits ) # # caps := make ( capQueue , size ) # for i := range Profits { # p := & project { # profit : Profits [ i ], # capital : Capital [ i ], # } # caps [ i ] = p # } # sort . Sort ( caps ) # # pros := make ( proPQ , 0 , size ) # var i int # for { # for i < len ( caps ) && caps [ i ]. capital <= W { # heap . Push (& pros , caps [ i ]) # i ++ # } # # if len ( pros ) == 0 || k == 0 { # break # } # # W += heap . Pop (& pros ).(* project ). profit # k -- # } # # return W
ret := 0 # for i := range nums { # ret ^= nums [ i ] ^ ( i + 1 ) # } # return ret
if node == nil { # return nil # } else if node . Right == nil { # return node . Parent # } # node = node . Right # for node . Left != nil { # node = node . Left # } # return node
for repeat := 0 ; repeat < 5 ; repeat ++ { # lgu , datas , _ := basicData () # if repeat % 2 == 1 { # lgu , datas , _ = randData () # } # vEBT := newRsVEBTreeUint 3 2 ( lgu ) # insertData ( vEBT , datas ) # for i := range datas { # vEBT . Delete ( i ) # for k := range datas { # member := vEBT . Member ( k ) # if k == i { # if member != nil { # t . Log ( fmt . Sprintf (" STR ", i )) # t . Fail () # } # } else { # e := member . Front () # for j := range datas [ k ] { # if e . Value != datas [ k ][ j ] { # t . Log ( fmt . Sprintf (" STR ", k , datas [ k ][ j ], e . Value )) # t . Fail () # } # e = e . Next () # } # } # } # delete ( datas , i ) # } # }
n := len ( people ) # sort . Ints ( people ) # # res := 0 # for l , r := 0 , n - 1 ; l <= r ; r -- { # if people [ l ]+ people [ r ] <= limit { # l ++ # } # res ++ # } # return res
leaders , votes := make ([] int , len ( persons )), make ([] int , len ( persons )) # leader := persons [ 0 ] # for i := 0 ; i < len ( persons ); i ++ { # p := persons [ i ] # votes [ p ]++ # if votes [ p ] >= votes [ leader ] { # leader = p # } # leaders [ i ] = leader # } # return TopVotedCandidate { persons : leaders , times : times }
_ = <- b . avail # # b . lock . Lock () # defer b . lock . Unlock () # # if b . start == b . pos { # panic (" STR ") # } # # b . pos = ( b . size + b . pos - 1 ) % b . size # v := b . buffer [ b . pos ] # b . buffer [ b . pos ] = nil # # return v
var tests = [] struct { # m , n int # and int # }{ # { 0 , 1 , 0 }, # { 1 , 1 , 1 }, # { 5 , 7 , 4 }, # { 4 1 , 4 4 , 4 0 }, # } # # for _ , tt := range tests { # and := rangeBitwiseAnd ( tt . m , tt . n ) # if and != tt . and { # t . Errorf (" STR ", tt . m , tt . n , and , tt . and ) # } # }
n := len ( arr ) # if n == 1 { # return 1 # } # j := 0 # for i := 1 ; i < n ; i ++ { # if arr [ i ] != arr [ j ] { # arr [ j + 1 ] = arr [ i ] # j = j + 1 # } # } # return j
defer wg . Done () # # for { # fmt . Printf (" STR ", name ) # time . Sleep ( 2 5 0 * time . Millisecond ) # # if atomic . LoadInt 6 4 (& shutdown ) == 1 { # fmt . Printf (" STR ", name ) # break # } # }
length := len ( nums ) # if length < 1 { # return - 1 # } # # sort . Ints ( nums ) # # ans := nums [ length - 1 ] # j := 2 # for i := length - 2 ; i >= 0 && j > 0 ; i -- { # if nums [ i ] != ans { # ans = nums [ i ] # j -- # } # } # # if 0 != j { # ans = nums [ length - 1 ] # } # return ans
t . Parallel () # for _ , tc := range testcases { # if sunsets := SunsetViews ( tc . buildingHeights ); sunsets != tc . sunsetViews { # t . Errorf (" STR ", tc . sunsetViews , sunsets ) # } # }
idm , idn := m - 1 , n - 1 # for i := m + n - 1 ; i >= 0 ; i -- { # if idm < 0 { # nums 1 [ i ] = nums 2 [ idn ] # idn -- # continue # } # if idn < 0 { # nums 1 [ i ] = nums 1 [ idm ] # idm -- # continue # } # if nums 1 [ idm ] >= nums 2 [ idn ] { # nums 1 [ i ] = nums 1 [ idm ] # idm -- # continue # } # if nums 1 [ idm ] < nums 2 [ idn ] { # nums 1 [ i ] = nums 2 [ idn ] # idn -- # continue # } # }
if len ( matrix ) == 0 || len ( matrix [ 0 ]) == 0 { # return 0 # } # max := 0 # for i := 0 ; i < len ( matrix ); i ++ { # heights := make ([] int , len ( matrix [ 0 ])) # for j := 0 ; j < len ( matrix [ 0 ]); j ++ { # if matrix [ i ][ j ] == ' 0 ' { # heights [ j ] = 0 # } else { # for k := i ; k < len ( matrix ); k ++ { # if matrix [ k ][ j ] == ' 0 ' { # break # } # heights [ j ]++ # } # } # } # area := maxArea ( heights ) # if area > max { # max = area # } # } # return max
t = i # defer func () { # t += 3 # }() # return t
sum := big . NewInt ( 0 ) # rem := big . NewInt ( 0 ) # # for num . Cmp ( big . NewInt ( 0 )) > 0 { # num . DivMod ( num , big . NewInt ( 1 0 ), rem ) # sum . Add ( sum , rem ) # } # # return sum . Int 6 4 ()
type person struct { # Name string ` structs :" STR "` # Ports [] int ` structs :" STR "` # } # # p := person { # Name : " STR ", # Ports : [] int { 8 0 }, # } # m := Map ( p ) # # ports , ok := m [" STR "].([] int ) # if ! ok { # t . Errorf (" STR ", m [" STR "]) # } # # if ports [ 0 ] != 8 0 { # t . Errorf (" STR ", ports ) # }
index := m + n - 1 # i := m - 1 # j := n - 1 # for ; i >= 0 && j >= 0 ; index -- { # if nums 1 [ i ] >= nums 2 [ j ] { # nums 1 [ index ] = nums 1 [ i ] # i -- # } else { # nums 1 [ index ] = nums 2 [ j ] # j -- # } # } # for j >= 0 { # nums 1 [ index ] = nums 2 [ j ] # index -- # j -- # }
c := & LiteralNode { Typex : TypeString } # actual , err := c . Type ( nil ) # if err != nil { # t . Fatalf (" STR ", err ) # } # if actual != TypeString { # t . Fatalf (" STR ", actual ) # }
dummy := new ( ListNode ) # curr := dummy # carry := 0 # # for l 1 != nil || l 2 != nil || carry > 0 { # curr . Next = new ( ListNode ) # curr = curr . Next # if l 1 != nil { # carry += l 1 . Val # l 1 = l 1 . Next # } # if l 2 != nil { # carry += l 2 . Val # l 2 = l 2 . Next # } # curr . Val = carry % 1 0 # carry /= 1 0 # } # return dummy . Next
pos := make ([] int 6 4 , len ( num 1 )+ len ( num 2 )) # ans := " STR " # # for i := len ( num 1 ) - 1 ; i >= 0 ; i -- { # for j := len ( num 2 ) - 1 ; j >= 0 ; j -- { # mul := ( num 1 [ i ] - ' 0 ') * ( num 2 [ j ] - ' 0 ') # p 1 , p 2 := i + j , i + j + 1 # sum := int 6 4 ( mul ) + pos [ p 2 ] # # pos [ p 1 ] += sum / 1 0 # pos [ p 2 ] = sum % 1 0 # # } # } # # for _ , v := range pos { # ans += strconv . Itoa ( int ( v )) # } # ans = strings . TrimLeft ( ans , " STR ") # if len ( ans ) == 0 { # return " STR " # } # # return ans
m := make ( map [ string ] bool ) # count := 0 # for _ , email := range emails { # plusIndex := strings . Index ( email , " STR ") # atIndex := strings . Index ( email , " STR ") # if plusIndex == - 1 { # plusIndex = atIndex # } # email = strings . ReplaceAll ( email [ 0 : plusIndex ], " STR ", " STR ") + email [ atIndex :] # if ! m [ email ] { # m [ email ] = true # count ++ # } # } # return count
letters := [] string {" STR ", " STR ", " STR "} # for r , s := range letters { # for i := 0 ; i < len ( s ); i ++ { # rows [ s [ i ]-' a '] = r # } # }
even , odd := 0 , 1 # res := make ([] int , len ( A )) # for _ , val := range A { # if val % 2 == 0 { # res [ even ] = val # even += 2 # } else { # res [ odd ] = val # odd += 2 # } # } # return res
sA , sB := 0 , 0 # mB := make ( map [ int ] bool ) # for _ , v := range A { # sA += v # } # for _ , v := range B { # sB += v # mB [ v ] = true # } # for _ , x := range A { # if mB [ x +( sB - sA )/ 2 ] { # return [] int { x , x + ( sB - sA )/ 2 } # } # } # return nil
 # dp := [ 1 0 1 ][ 1 0 1 ] int {} # dp [ 0 ][ 0 ] = 1 # # size := len ( group ) # # for k := 0 ; k < size ; k ++ { # gk := group [ k ] # pk := profit [ k ] # for i := P ; i >= 0 ; i -- { # ip := min ( i + pk , P ) # for j := G - gk ; j >= 0 ; j -- { # dp [ ip ][ j + gk ] += dp [ i ][ j ] # dp [ ip ][ j + gk ] %= mod # } # } # } # # res := 0 # for i := 0 ; i <= G ; i ++ { # res += dp [ P ][ i ] # } # return res % mod
INT_MAX := int (^ uint ( 0 ) >> 1 ) # INT_MIN := ^ INT_MAX # # if root == nil { # return true # } # # return validate ( root , INT_MAX , INT_MIN ) #
n := len ( S ) # if n == 0 { # return [] int { 0 , 0 } # } # lines , sum := 1 , 0 # for i := 0 ; i < n ; i ++ { # l := widths [ S [ i ]-' a '] # if sum + l > 1 0 0 { # lines ++ # sum = l # } else { # sum += l # } # } # return [] int { lines , sum }
getString := func ( n int ) string { # str := fmt . Sprintf (" STR ", n ) # runes := [] rune ( str ) # sort . Slice ( runes , func ( i , j int ) bool { # return runes [ i ] < runes [ j ] # }) # # return string ( runes ) # } # # nums := make ( map [ string ] bool ) # for i := uint ( 0 ); i < 3 1 ; i ++ { # n := 1 << i # nums [ getString ( n )] = true # } # # str := getString ( N ) # return nums [ str ]
vals 1 := helper 8 7 2 ( root 1 , make ([] int , 0 )) # vals 2 := helper 8 7 2 ( root 2 , make ([] int , 0 )) # return reflect . DeepEqual ( vals 1 , vals 2 )
n , m := len ( matrix ), len ( matrix [ 0 ]) # dp := make ([][] int , n + 1 ) # for i := range dp { # dp [ i ] = make ([] int , m + 1 ) # } # res := 0 # for i := 1 ; i < n + 1 ; i ++ { # for j := 1 ; j < m + 1 ; j ++ { # if matrix [ i - 1 ][ j - 1 ] == 1 { # dp [ i ][ j ] = 1 + min ( dp [ i - 1 ][ j - 1 ], min ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ])) # } # res += dp [ i ][ j ] # } # } # return res
qs := [] question 7 1 3 { # # { # para 7 1 3 {[] int { 1 0 , 5 , 2 , 6 }, 1 0 0 }, # ans 7 1 3 { 8 }, # }, # # { # para 7 1 3 {[] int { 1 0 , 9 , 1 0 , 4 , 3 , 8 , 3 , 3 , 6 , 2 , 1 0 , 1 0 , 9 , 3 }, 1 9 }, # ans 7 1 3 { 1 8 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 1 3 , q . para 7 1 3 # fmt . Printf (" STR ", p , numSubarrayProductLessThanK ( p . s , p . k )) # } # fmt . Printf (" STR ")
dp := make ([] int , len ( word 2 )+ 1 ) # for i := 0 ; i < len ( dp ); i ++ { # dp [ i ] = i # } # # for i := 0 ; i < len ( word 1 ); i ++ { # prev := i # dp [ 0 ] = i + 1 # for j := 0 ; j < len ( word 2 ); j ++ { # cur := prev # if word 1 [ i ] != word 2 [ j ] { # min := math . Min ( float 6 4 ( dp [ j + 1 ]), float 6 4 ( dp [ j ])) # cur = int ( math . Min ( min , float 6 4 ( prev ))) + 1 # } # # prev , dp [ j + 1 ] = dp [ j + 1 ], cur # } # } # # return dp [ len ( word 2 )]
return e . Start + e . Length
if n <= 1 { # return 1 # } # return jumpFloor ( n - 1 ) + jumpFloor ( n - 2 )
base := 1 3 3 7 # # powmod := func ( a , k int ) int { # a %= base # res := 1 # for i := 0 ; i < k ; i ++ { # res = ( res * a ) % base # } # return res # } # # n := len ( b ) # if n == 0 { # return 1 # } # # last := b [ n - 1 ] # b = b [: n - 1 ] # return powmod ( superPow ( a , b ), 1 0 ) * powmod ( a , last ) % base
dp := make ([][] bool , 0 ) # left , right := 0 , 0 # for i := 0 ; i <= len ( s ); i ++ { # dp = append ( dp , make ([] bool , len ( s ))) # } # # for i := len ( s ) - 1 ; i >= 0 ; i -- { # dp [ i ][ i ] = true # for j := i ; j < len ( s ); j ++ { # dp [ j ][ i ] = s [ i ] == s [ j ] && ( i - j < 2 || dp [ j + 1 ][ i - 1 ]) # if dp [ j ][ i ] && j - i > right - left { # left = i # right = j # } # fmt . Println ( i , j ) # Print ( dp ) # # } # } # return s [ left : right + 1 ]
n := len ( nums ) # xor := 0 # for i := 0 ; i < n ; i ++ { # xor ^= nums [ i ] # } # return xor == 0 || n % 2 == 0
if miss > 1 { # return false # } # if wl == ind { # return root . End && miss == 1 # } # ch := int ( word [ ind ] - " STR ") # for i , nc := range root . Children { # if nc != nil { # nm := miss # if i != ch { # nm += 1 # } # if nc . SearchHelper ( word , nm , wl , ind + 1 ) { # return true # } # } # } # return false
if len ( A ) < 3 { # return false # } # i := 0 # l := len ( A ) # for i + 1 < l && A [ i ] < A [ i + 1 ] { # i ++ # } # if i == 0 || i == l - 1 { # return false # } # for i + 1 < l && A [ i ] > A [ i + 1 ] { # i ++ # } # return i == l - 1
var a , b , cur , cb int # res := 0 # for _ , c := range tree { # if c == a || c == b { # cur ++ # } else { # cur = cb + 1 # } # if c == b { # cb ++ # } else { # cb = 1 # a , b = b , c # } # if cur > res { # res = cur # } # } # return res
type A struct { # Name string # } # # type B struct { # A map [ string ]* A # } # # a := & A { Name : " STR "} # # b := & B { # A : map [ string ]* A { # " STR ": a , # }, # } # # m := Map ( b ) # # if typ := reflect . TypeOf ( m ). Kind (); typ != reflect . Map { # t . Errorf (" STR ", typ ) # } # # in , ok := m [" STR "].( map [ string ] interface {}) # if ! ok { # t . Errorf (" STR ", m [" STR "]) # } # # example := in [" STR "].( map [ string ] interface {}) # if name := example [" STR "].( string ); name != " STR " { # t . Errorf (" STR ", name ) # }
red := color . RGBA { 2 5 5 , 0 , 0 , 2 5 5 } # blue := color . RGBA { 0 , 0 , 2 5 5 , 2 5 5 } # # type ColoredPoint struct { # * Point # Color color . RGBA # } # # p := ColoredPoint {& Point { 1 , 1 }, red } # q := ColoredPoint {& Point { 5 , 4 }, blue } # fmt . Println ( p . Distance (* q . Point )) # q . Point = p . Point # p . ScaleBy ( 2 ) # fmt . Println (* p . Point , * q . Point )
for c := range baked { # if s . Verbose { # fmt . Println (" STR ", c ) # } # work ( s . IceTime , s . IceStdDev ) # iced <- c # }
diff , a , b := 0 , 0 , 0 # for _ , num := range nums { # diff ^= num # } # diff &= - diff # for _ , num := range nums { # if num & diff == 0 { # a ^= num # } else { # b ^= num # } # } # return [] int { a , b }
var countS , countG [ 1 0 ] int # bulls , cows := 0 , 0 # for i := range secret { # ns := int ( secret [ i ] - ' 0 ') # ng := int ( guess [ i ] - ' 0 ') # if ng == ns { # bulls ++ # continue # } # # if countG [ ns ] > 0 { # cows ++ # countG [ ns ]-- # } else { # countS [ ns ]++ # } # # if countS [ ng ] > 0 { # cows ++ # countS [ ng ]-- # } else { # countG [ ng ]++ # } # } # # return fmt . Sprintf (" STR ", bulls , cows )
tests := [...] testType { # { # in : [] int {- 4 , - 1 , 0 , 3 , 1 0 }, # want : [] int { 0 , 1 , 9 , 1 6 , 1 0 0 }, # }, # { # in : [] int {- 7 , - 3 , 2 , 3 , 1 1 }, # want : [] int { 4 , 9 , 9 , 4 9 , 1 2 1 }, # }, # } # for _ , tt := range tests { # got := sortedSquares ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
s , sep := " STR "" # for _ , arg := range os . Args [ 1 :] { # s += sep + arg # sep = " STR " # } # fmt . Println ( s )
return TimeMap { make ( map [ string ][] int ), make ( map [ int ] string )}
return RecentCounter { # list : [] int {}, # }
if len ( a ) <= 1 { # return a # } # # e 1 , e 2 , c 1 , c 2 := 0 , 1 , 0 , 0 # for _ , e := range a { # switch { # case e == e 1 : # c 1 ++ # case e == e 2 : # c 2 ++ # case c 1 == 0 : # e 1 = e # c 1 = 1 # case c 2 == 0 : # e 2 = e # c 2 = 1 # default : # c 1 -- # c 2 -- # } # } # # res := [] int {} # # if maj ( a , e 2 ) { # res = append ( res , e 2 ) # } # # if maj ( a , e 1 ) { # res = append ( res , e 1 ) # } # # return res
if nil == numbers || len ( numbers ) < 2 { # return - 1 # } # # min := numbers [ 0 ] # max := numbers [ 1 ] - min # for i := 2 ; i < len ( numbers ); i ++ { # if numbers [ i - 1 ] < min { # min = numbers [ i - 1 ] # } # # currentDiff := numbers [ i ] - min # if currentDiff > max { # max = currentDiff # } # } # return max
if len ( num ) < 3 { # return false # } # for firstEnd := 0 ; firstEnd < len ( num )/ 2 ; firstEnd ++ { # if num [ 0 ] == ' 0 ' && firstEnd > 0 { # break # } # first , _ := strconv . Atoi ( num [: firstEnd + 1 ]) # for secondEnd := firstEnd + 1 ; max ( firstEnd , secondEnd - firstEnd ) <= len ( num )- secondEnd ; secondEnd ++ { # if num [ firstEnd + 1 ] == ' 0 ' && secondEnd - firstEnd > 1 { # break # } # second , _ := strconv . Atoi ( num [ firstEnd + 1 : secondEnd + 1 ]) # if recursiveCheck ( num , first , second , secondEnd + 1 ) { # return true # } # } # } # return false
a := map [ int ] Baz { # 4 : { # A : " STR ", # }, # } # # s := New ( a [ 4 ]) # # if err := s . Field (" STR "). Set (" STR "); err != errNotSettable { # t . Errorf (" STR ", errNotSettable , err ) # }
cases := [] struct { # name string # input 1 [] byte # input 2 int # expect int # }{ # {" STR ", [] byte {' A ', ' A ', ' A ', ' B ', ' B ', ' B '}, 2 , 8 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := leastInterval ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 , c . input 2 ) # } # }) # }
g := make ( map [ rune ] map [ rune ] struct {}) # for i := 1 ; i < len ( sortedWords ); i ++ { # var firstDiff int # for firstDiff = 0 ; sortedWords [ i - 1 ][ firstDiff ] == sortedWords [ i ][ firstDiff ]; firstDiff ++ { # } # if _ , exists := g [ rune ( sortedWords [ i - 1 ][ firstDiff ])]; ! exists { # g [ rune ( sortedWords [ i - 1 ][ firstDiff ])] = make ( map [ rune ] struct {}) # } # g [ rune ( sortedWords [ i - 1 ][ firstDiff ])][ rune ( sortedWords [ i ][ firstDiff ])] = struct {}{} # } # return kahnsTopologicalSort ( g )
var tests = [] struct { # x float 6 4 # n int # xn float 6 4 # }{ # { x : 2 , n : 1 0 }, # { x : 2 . 1 , n : 3 }, # { x : 2 , n : - 2 }, # { x : 1 , n : math . MaxInt 3 2 }, # { x : - 2 . 1 , n : math . MinInt 3 2 }, # } # # for _ , tt := range tests { # tt . xn = math . Pow ( tt . x , float 6 4 ( tt . n )) # # xn := myPow ( tt . x , tt . n ) # if xn != tt . xn { # t . Errorf (" STR ", tt . x , tt . n , xn , tt . xn ) # } # }
if b > 0 { # d , y , x := ExtendedRecursive ( b , a % b ) # y -= ( a / b ) * x # return d , x , y # } # # return a , 1 , 0
defer exportedDefer () # # i := 1 # defer deferred (" STR ", i ) # i ++ # defer func () { # println (" STR ", i ) # }() # i ++ # defer deferred (" STR ", i ) # i ++ # # var t Printer = & Thing {" STR "} # defer t . Print (" STR ") # # println (" STR ") # d := dumb {} # defer d . Value ( 0 )
exist := make ( map [ int ] struct {}) # for _ , num := range nums { # if _ , ok := exist [ num ]; ok { # return true # } # exist [ num ] = struct {}{} # } # return false
count := 0 # for i := 1 ; i <= 2 0 ; i ++ { # j := 1 # for { # number := big . NewInt ( 0 ). Exp ( big . NewInt ( int 6 4 ( i )), big . NewInt ( int 6 4 ( j )), nil ) # digits := len ( number . String ()) # if digits == j { # count ++ # } else { # break # } # j ++ # } # } # return count
ls , lss := len ( haystack ), len ( needle ) # if ls | lss == 0 { # return 0 # } # end := ls - lss + 1 # for i := 0 ; i < end ; i ++ { # var t int # for ii := range needle { # if haystack [ i + ii ] != needle [ ii ] { # break # } # t ++ # } # if t == lss { # return i # } # } # return - 1
if n < 3 { # return 0 # } # # notPrime := make ([] bool , n ) # count := n / 2 # for i := 3 ; i < mySqrt ( n )+ 1 ; i += 2 { # if notPrime [ i ] { # continue # } # # for j := i * i ; j < n ; j += 2 * i { # if ! notPrime [ j ] { # count -- # notPrime [ j ] = true # } # } # } # return count
s := " STR " # fmt . Println ( repeatedSubstringPattern ( s )) # # s 2 := " STR " # fmt . Println ( repeatedSubstringPattern ( s 2 )) #
names := make ([] string , 0 , len ( _bindata )) # for name := range _bindata { # names = append ( names , name ) # } # return names
n := len ( nums ) | 1 # # mid := findMiddle ( nums ) # # gt , lt := 1 , ( len ( nums )- 1 )&(^ 1 ) # for i := 1 ; i & 1 == 1 || i <= lt ; { # if i == n { # i = 0 # } # # if nums [ i ] < mid { # nums [ i ], nums [ lt ] = nums [ lt ], nums [ i ] # lt -= 2 # } else if nums [ i ] > mid { # nums [ i ], nums [ gt ] = nums [ gt ], nums [ i ] # gt += 2 # i += 2 # } else { # i += 2 # } # }
var tests = [] struct { # tree * TreeNode # sum int # numPath int # }{ # { newTree ( 1 0 , 5 , - 3 , 3 , 2 , nil , 1 1 , 3 , - 2 , nil , 1 ), 8 , 3 }, # { newTree ( 1 , - 2 , - 3 , 1 , 3 , - 2 , nil , - 1 ), 1 , 3 }, # } # # for _ , tt := range tests { # numPath := pathSum ( tt . tree , tt . sum ) # if numPath != tt . numPath { # t . Errorf (" STR ", tt . tree , tt . sum , numPath , tt . numPath ) # } # }
dp := make ([][] int , n + 1 ) # for i := range dp { # dp [ i ] = make ([] int , k + 1 ) # dp [ i ][ 0 ] = 1 # } # # for i := 1 ; i <= n ; i ++ { # maxJ := min ( k , i *( i - 1 )/ 2 ) # for j := 1 ; j <= maxJ ; j ++ { # dp [ i ][ j ] = ( dp [ i ][ j - 1 ] + dp [ i - 1 ][ j ]) % m # if j >= i { # dp [ i ][ j ] -= dp [ i - 1 ][ j - i ] # if dp [ i ][ j ] < 0 { # dp [ i ][ j ] += m # } # } # } # } # # return dp [ n ][ k ]
result := make ([] string , 0 ); # currWords := make ([] string , 0 ); # currWordsLen := 0 ; # for _ , word := range words { # if currWordsLen + len ( currWords ) + len ( word ) > k { # if len ( currWords ) == 1 { # result = append ( result , currWords [ 0 ] + strings . Repeat (" STR ", k - currWordsLen )); # } else { # spaces := k - currWordsLen # spacesBetween , extras := spaces / ( len ( currWords ) - 1 ), spaces % ( len ( currWords ) - 1 ); # for i := 0 ; i < extras ; i ++ { # currWords [ i ] += " STR "; # } # result = append ( result , strings . Join ( currWords , strings . Repeat (" STR ", spacesBetween ))); # } # currWords = make ([] string , 0 ); # currWordsLen = 0 ; # } # currWords = append ( currWords , word ); # currWordsLen += len ( word ); # } # result = append ( result , strings . Join ( currWords , " STR ") + strings . Repeat (" STR ", k - currWordsLen - len ( currWords ) + 1 )); # return result ;
return i .( int ) - 1
testFramework ( t , bubbleSort )
n := 1 # for { # time . Sleep ( 1 * time . Second ) # select { # case <- ctx . Done (): # fmt . Println ( ctx . Err (). Error ()) # return # case counter <- n : # n ++ # } # }
if n == 0 || n == 1 { # return n # } # if n == 2 { # return 1 # } # # return getRecurse ( n - 1 ) + getRecurse ( n - 2 )
if x < 0 { # return false # } # if x < 1 0 { # return true # } # s := strconv . Itoa ( x ) # length := len ( s ) # for i := 0 ; i <= length / 2 ; i ++ { # if s [ i ] != s [ length - 1 - i ] { # return false # } # } # return true
random := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # array 1 := make ([] int , random . Intn ( 1 0 0 - 1 0 )+ 1 0 ) # for i := range array 1 { # array 1 [ i ] = random . Intn ( 1 0 0 ) # } # array 2 := make ( sort . IntSlice , len ( array 1 )) # copy ( array 2 , array 1 ) # SelectionSort ( array 1 ) # array 2 . Sort () # for i := range array 1 { # if array 1 [ i ] != array 2 [ i ] { # t . Fail () # } # }
bst := & bsTree {} # bst . tree = & tree { # data : 8 , # left : & tree { # data : 5 , # left : & tree { # data : 3 , # left : nil , # right : nil , # }, # right : nil , # }, # right : & tree { # data : 9 , # left : nil , # right : nil , # }, # } # return bst
for e := m . value . Front (); e != nil ; e = e . Next () { # if e . Value == value { # return e # } # } # return nil
fmt . Printf (" STR ", t . Name , t . Description ) # fmt . Println (" STR ") # for _ , v := range t . TeamMembers { # t := reflect . TypeOf ( v ) # fmt . Println (" STR ", t ) # v . PrintName () # v . PrintDetails () # if t . String () == " STR " { # m := v .( Manager ) # m . ToString () # } # }
t . Parallel () # for _ , tc := range testcases { # result := ConstructAllPossibleBSTs ( tc . n ) # preorders := make ([][] int , 0 , len ( result )) # for _ , root := range result { # preorders = append ( preorders , preorder ( root , [] int {})) # } # if ! reflect . DeepEqual ( preorders , tc . preorders ) { # t . Errorf (" STR ", tc . preorders , preorders ) # } # }
return LoadUint 1 6 (& r . Reg )
err := c . Err () # p . mu . Lock () # if ! p . closed && err == nil && ! forceClose { # p . idle . PushFront ( idleConn { t : nowFunc (), c : c }) # if p . idle . Len () > p . MaxIdle { # c = p . idle . Remove ( p . idle . Back ()).( idleConn ). c # } else { # c = nil # } # } # # if c == nil { # if p . cond != nil { # p . cond . Signal () # } # p . mu . Unlock () # return nil # } # # p . release () # p . mu . Unlock () # return c . Close ()
for num > 9 { # num = num / 1 0 + num % 1 0 # } # return num
var testCasesExtended = [] struct { # name string # a int 6 4 # b int 6 4 # gcd int 6 4 # x int 6 4 # y int 6 4 # }{ # {" STR ", 3 0 , 5 0 , 1 0 , 2 , - 1 }, # } # for _ , tc := range testCasesExtended { # t . Run ( tc . name , func ( t * testing . T ) { # gcd , x , y := Extended ( tc . a , tc . b ) # if gcd != tc . gcd && x != tc . x && y != tc . y { # t . Fatalf (" STR ", tc . gcd , gcd , tc . x , x , tc . y , y ) # } # }) # }
type address struct { # Country string ` structs :" STR "` # } # # type person struct { # Name string ` structs :" STR "` # Addresses []* address ` structs :" STR "` # } # # p := person { # Name : " STR ", # Addresses : []* address { # { Country : " STR "}, # { Country : " STR "}, # }, # } # mp := Map ( p ) # # mpAddresses := mp [" STR "].([] interface {}) # if _ , exists := mpAddresses [ 0 ].( map [ string ] interface {})[" STR "]; exists { # t . Errorf (" STR ") # } # # if _ , exists := mpAddresses [ 0 ].( map [ string ] interface {})[" STR "]; ! exists { # t . Errorf (" STR ") # }
archive := " STR " # files := [] string {" STR ", " STR "} # err := archiveFiles ( files , archive ) # if err != nil { # log . Fatalf (" STR ", err ) # } # fmt . Println (" STR ") # err = readArchive ( archive ) # if err != nil { # log . Fatalf (" STR ", err ) # }
if n . p == nil { # return nil , - 1 # } # # i := n . p . searchKeyIdx ( n . keyValue [ 0 ]. key ) # # if n . p . LessByKey ( n . p . keyValue [ i ]. key , n . keyValue [ 0 ]. key ) { # if i >= n . p . Len ()- 1 { # return nil , - 1 # } # return n . p . c [ i + 2 ], i + 1 # } # return n . p . c [ i + 1 ], i
for i := len ( givenTriangle ) - 2 ; i >= 0 ; i -- { # for j := 0 ; j < len ( givenTriangle [ i ]); j ++ { # if givenTriangle [ i + 1 ][ j ] > givenTriangle [ i + 1 ][ j + 1 ] { # givenTriangle [ i ][ j ] += givenTriangle [ i + 1 ][ j ] # } else { # givenTriangle [ i ][ j ] += givenTriangle [ i + 1 ][ j + 1 ] # } # } # } # fmt . Println ( givenTriangle [ 0 ][ 0 ])
var res int # dfs ( root , root . Val , & res ) # return res
cannonicalName := strings . Replace ( name , " STR ", " STR ", - 1 ) # if f , ok := _bindata [ cannonicalName ]; ok { # a , err := f () # if err != nil { # return nil , fmt . Errorf (" STR ", name , err ) # } # return a . info , nil # } # return nil , fmt . Errorf (" STR ", name )
h := maxHeap { slice : slice , heapSize : len ( slice )} # for i := len ( slice ) / 2 ; i >= 0 ; i -- { # h . MaxHeapify ( i ) # } # return h
m := len ( grid ) # if m == 0 { # return 0 # } # n := len ( grid [ 0 ]) # # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # if i == 0 && j == 0 { # continue # } # if i == 0 { # grid [ i ][ j ] += grid [ i ][ j - 1 ] # } else if j == 0 { # grid [ i ][ j ] += grid [ i - 1 ][ j ] # } else { # grid [ i ][ j ] += mymin ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]) # } # } # } # return grid [ m - 1 ][ n - 1 ]
k %= len ( nums ) # for i := 0 ; i < k / 2 ; i ++ { # nums [ i ], nums [ k - 1 - i ] = nums [ k - 1 - i ], nums [ i ] # } # for i := 0 ; i < ( len ( nums )- k )/ 2 ; i ++ { # nums [ k + i ], nums [ len ( nums )- 1 - i ] = nums [ len ( nums )- 1 - i ], nums [ k + i ] # } # for i := 0 ; i < len ( nums )/ 2 ; i ++ { # nums [ i ], nums [ len ( nums )- 1 - i ] = nums [ len ( nums )- 1 - i ], nums [ i ] # }
var tests = [] struct { # list [] int # tree * TreeNode # }{ # {[] int {- 1 0 , - 3 , 0 , 5 , 9 }, newTree ( 0 , - 3 , 9 , - 1 0 , nil , 5 )}, # } # # for _ , tt := range tests { # tree := sortedListToBST ( newList ( tt . list ...)) # if reflect . DeepEqual ( tree , tt . tree ) == false { # t . Errorf (" STR ", newList ( tt . list ...), tree , tt . tree ) # } # }
return lbt . Locked
var waitShutdown sync . WaitGroup # waitShutdown . Add ( len ( readerWriters )) # # for _ , readerWriter := range readerWriters { # go readerWriter . stop (& waitShutdown ) # } # # waitShutdown . Wait ()
value := make ([][] int , len ( coins )) # for i := range value { # value [ i ] = make ([] int , len ( coins )) # } # for interval := range value { # for i , j := 0 , interval ; j < len ( coins ); i , j = i + 1 , j + 1 { # var a , b , c int # if i + 2 <= j { # a = value [ i + 2 ][ j ] # } # if i + 1 <= j - 1 { # b = value [ i + 1 ][ j - 1 ] # } # if i <= j - 2 { # c = value [ i ][ j - 2 ] # } # value [ i ][ j ] = max ( coins [ i ]+ min ( a , b ), coins [ j ]+ min ( b , c )) # } # } # return value [ 0 ][ len ( coins )- 1 ]
return root 1 == nil && root 2 == nil || root 1 != nil && root 2 != nil && root 1 . Val == root 2 . Val && ( flipEquiv ( root 1 . Left , root 2 . Left ) && flipEquiv ( root 1 . Right , root 2 . Right ) || flipEquiv ( root 1 . Left , root 2 . Right ) && flipEquiv ( root 2 . Left , root 1 . Right ))
maxList := make ( map [ int ][] int , 0 ) # i := 0 # # for _ , str := range triangle { # maxList [ i ] = make ([] int , 0 ) # lines := strings . Split ( str , " STR ") # for _ , ele := range lines { # j , _ := strconv . Atoi ( ele ) # maxList [ i ] = append ( maxList [ i ], j ) # } # # var leftParent int # var rightParent int # for j , _ := range maxList [ i ] { # if _ , ok := maxList [ i - 1 ]; ok { # leftParent = 0 # rightParent = 0 # if j != 0 { # leftParent = maxList [ i - 1 ][ j - 1 ] # } # if j <= i - 1 { # rightParent = maxList [ i - 1 ][ j ] # } # if leftParent > rightParent { # maxList [ i ][ j ] += leftParent # } else { # maxList [ i ][ j ] += rightParent # } # } # } # i ++ # } # # max := 0 # for _ , ele := range maxList [ i - 1 ] { # if ele > max { # max = ele # } # } # return max
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", # [][] int { # { 2 }, # { 3 , 4 }, # { 6 , 5 , 7 }, # { 4 , 1 , 8 , 3 }, # }, # 1 1 }, # {" STR ", # [][] int { # { 1 }, # { 2 , 3 }, # }, # 3 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := minimumTotal 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
var tests = [] struct { # num 1 , num 2 string # product string # }{ # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # } # # for _ , tt := range tests { # product := multiply ( tt . num 1 , tt . num 2 ) # if product != tt . product { # t . Errorf (" STR ", tt . num 1 , tt . num 2 , product , tt . product ) # } # }
return n . Typex , nil
for i := 0 ; i < b . N ; i ++ { # IterativePower ( 1 0 , 5 ) # }
for i , item := range array { # if item == query { # return i # } # } # return - 1
res = [] int {} # preorder ( root , 0 ) # return res
println (" STR ") # for x := 2 1 ; x < math . MaxInt 6 4 ; x ++ { # for i := 2 ; i <= 2 0 ; i ++ { # if ( x % i ) != 0 { # break # } # if i >= 2 0 { # println ( x , " STR ") # return # } # } # }
t . Parallel () # for _ , tc := range testcases { # if result := IsANumber ( tc . input ); result != tc . isNumber { # t . Errorf (" STR ", tc . input , tc . isNumber , result ) # } # }
if len ( distChan ) == 0 { # return # } # allStats := & Stats { # Url : target , # Connections : * numConnections , # Threads : * numThreads , # } # statCount := len ( distChan ) # for res := range distChan { # var stats Stats # err := json . Unmarshal ([] byte ( res ), & stats ) # if err != nil { # fmt . Println ( err ) # } # allStats . Duration += stats . Duration # allStats . Sum += stats . Sum # allStats . Times = append ( allStats . Times , stats . Times ...) # allStats . Resp 2 0 0 += stats . Resp 2 0 0 # allStats . Resp 3 0 0 += stats . Resp 3 0 0 # allStats . Resp 4 0 0 += stats . Resp 4 0 0 # allStats . Resp 5 0 0 += stats . Resp 5 0 0 # allStats . Errors += stats . Errors # allStats . Contains += stats . Contains # # if len ( distChan ) == 0 { # break # } # } # allStats . AvgDuration = allStats . Duration / float 6 4 ( statCount ) # PrintStats ( allStats )
return ( ptr + 3 ) &^ 3
if len ( nums ) == 0 { # return false # } # low , high := 0 , len ( nums )- 1 # for low <= high { # mid := low + ( high - low )>> 1 # if nums [ mid ] == target { # return true # } else if nums [ mid ] > nums [ low ] { # if nums [ low ] <= target && target < nums [ mid ] { # high = mid - 1 # } else { # low = mid + 1 # } # } else if nums [ mid ] < nums [ high ] { # if nums [ mid ] < target && target <= nums [ high ] { # low = mid + 1 # } else { # high = mid - 1 # } # } else { # if nums [ low ] == nums [ mid ] { # low ++ # } # if nums [ high ] == nums [ mid ] { # high -- # } # } # } # return false
Thing () # fmt . Println (" STR ")
t . Parallel () # for _ , tc := range testcases { # if result := FindOnce ( tc . input ); tc . expected != result { # t . Errorf (" STR ", tc . expected , result ) # } # }
currentNode := trie . root # for _ , r := range item { # if _ , ok := currentNode . children [ r ]; ok { # currentNode = currentNode . children [ r ] # } else { # return false # } # } # if currentNode . last == false { # return false # } # currentNode . last = false # symbolIndex := len ( item ) - 1 # for len ( currentNode . children ) == 0 { # delete ( currentNode . children , int 3 2 ( item [ symbolIndex ])) # currentNode = currentNode . parent # symbolIndex -- # } # return true
for i := 0 ; i < b . N ; i ++ { # b . StopTimer () # arrSize := 1 0 0 0 0 # arr := make ([] int , arrSize , arrSize ) # for i := range arr { # arr [ i ] = rand . Intn ( arrSize ) # } # b . StartTimer () # # sortedArr := make ([] int , 0 , 0 ) # for _ , v := range arr { # h . Append ( v ) # } # for h . Len () > 0 { # sortedArr = append ( sortedArr , h . Pop ().( int )) # } # }
pairs := [...][ 2 ] int {{ 1 0 , 2 7 }, { 1 0 0 , 6 4 8 }} # for _ , pair := range pairs { # in , out := pair [ 0 ], pair [ 1 ] # if x := p 2 0 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # } # }
dummyHead := & ListNode {} # dummyHead . Next = head # # cur := dummyHead # # for cur . Next != nil { # if val == cur . Next . Val { # cur . Next = cur . Next . Next # } else { # cur = cur . Next # } # } # return dummyHead . Next
res := 0 # a := [ 1 2 3 ] int {} # for i := range s { # a [ s [ i ]]++ # } # # hasOdd := 0 # for i := range a { # if a [ i ] == 0 { # continue # } # if a [ i ]& 1 == 0 { # res += a [ i ] # } else { # res += a [ i ] - 1 # hasOdd = 1 # } # } # # return res + hasOdd
top , l := 0 , len ( nums ) # if l == 0 { # return 0 # } # for i := 1 ; i < l ; i ++ { # if nums [ i ] != nums [ top ] { # top ++ # nums [ top ] = nums [ i ] # } # } # return top + 1
sort . Ints ( a ) # n := len ( a ) # # res := 0 # for k := n - 1 ; 2 <= k ; k -- { # for i , j := 0 , k - 1 ; i < j ; { # if a [ i ]+ a [ j ] > a [ k ] { # res += j - i # j -- # } else { # i ++ # } # } # } # # return res
return float 6 4 ( f . num ) / float 6 4 ( f . dem )
res := [][] int {} # sort . Ints ( A ) # # var dfs func ( int , [] int ) # dfs = func ( index int , temp [] int ) { # res = append ( res , temp ) # n := len ( temp ) + 1 # for i := index ; i < len ( A ); i ++ { # if i == index || A [ i ] != A [ i - 1 ] { # dfs ( i + 1 , append ( temp , A [ i ])[: n : n ]) # } # } # } # # temp := make ([] int , 0 , 0 ) # dfs ( 0 , temp ) # # return res
fields := make ( map [ string ] reflect . Value ) # v := reflect . ValueOf ( model ) # for i := 0 ; i < v . NumField (); i ++ { # fieldInfo := v . Type (). Field ( i ) # tag := fieldInfo . Tag # name := tag . Get ( dtotag ) # if name == "" { # name = strings . ToLower ( fieldInfo . Name ) # } # fields [ name ] = v . Field ( i ) # } # # val := reflect . New ( TYPE_REGISTRY [ reflect . TypeOf ( model ). String ()+" STR "]). Elem () # # for i := 0 ; i < val . NumField (); i ++ { # fieldInfo := val . Type (). Field ( i ) # tag := fieldInfo . Tag # name := tag . Get ( dtotag ) # for k , v := range fields { # if k == name { # val . Field ( i ). Set ( v ) # break # } # } # } # return val . Interface ()
res := [] string {} # # for i , w := 0 , 0 ; i < len ( words ); i = w { # l := - 1 # for w = i ; w < len ( words ) && l + len ( words [ w ])+ 1 <= maxWidth ; w ++ { # l += len ( words [ w ]) + 1 # } # # str := words [ i ] # space , extra := 1 , 0 # if w != i + 1 && w != len ( words ) { # space = ( maxWidth - l )/( w - i - 1 ) + 1 # extra = ( maxWidth - l ) % ( w - i - 1 ) # } # for j := i + 1 ; j < w ; j ++ { # str += strings . Repeat (" STR ", space ) # if extra > 0 { # str += " STR " # extra -- # } # str += words [ j ] # } # str += strings . Repeat (" STR ", maxWidth - len ( str )) # res = append ( res , str ) # } # return res
if strings . ContainsRune ( S , '@') { # return maskEmail ( strings . ToLower ( S )) # } # return maskPhone ( S )
t . Parallel () # # for _ , tc := range testcases { # if result := SmallestNumberOfPerfectSquaresSum ( tc . n ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
if n == 0 { # return [][] int {} # } # # res := make ([][] int , n ) # for i := 0 ; i < n ; i ++ { # res [ i ] = make ([] int , n ) # } # # top , bottom , left , right := 0 , n - 1 , 0 , n - 1 # num := 1 # for top <= bottom && left <= right { # for i := left ; i <= right ; i ++ { # res [ top ][ i ] = num # num ++ # } # top ++ # # for i := top ; i <= bottom ; i ++ { # res [ i ][ right ] = num # num ++ # } # right -- # # for i := right ; i >= left ; i -- { # res [ bottom ][ i ] = num # num ++ # } # bottom -- # # for i := bottom ; i >= top ; i -- { # res [ i ][ left ] = num # num ++ # } # left ++ # } # return res
iterator := func () <- chan VertexId { # ch := make ( chan VertexId ) # go func () { # if connected , ok := g . edges [ vertex ]; ok { # for VertexId , _ := range connected { # ch <- VertexId # } # } # close ( ch ) # }() # return ch # } # # return VerticesIterable (& vertexIterableHelper { iterFunc : iterator })
var tests = [] struct { # A [] int # B [] int # }{ # {[] int { 3 , 1 , 2 , 4 }, [] int { 4 , 2 , 1 , 3 }}, # } # # for _ , tt := range tests { # A := make ([] int , len ( tt . A )) # copy ( A , tt . A ) # # B := sortArrayByParity ( tt . A ) # if reflect . DeepEqual ( B , tt . B ) == false { # t . Errorf (" STR ", A , B , tt . B ) # } # }
t . Parallel () # for _ , tc := range testcases { # if result := BreakByLength ( tc . long , tc . k ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
matrix := generateMatrix ( 3 ) # for _ , row := range matrix { # for _ , num := range row { # fmt . Printf (" STR ", num ) # } # fmt . Println () # }
if tree . op == NON { # return tree . val # } # left := Calculate ( tree . left ) # right := Calculate ( tree . right ) # var result int # switch tree . op { # case ADD : # result = left + right # case SUB : # result = left - right # case MUL : # result = left * right # case DIV : # result = left / right # } # return result
if rowIndex < 0 { # return make ([] int , 0 ) # } # # row := make ([] int , rowIndex + 1 ) # for i := 0 ; i <= rowIndex ; i ++ { # prev := 1 # for j := 1 ; j < i ; j ++ { # num := prev + row [ j ] # prev = row [ j ] # row [ j ] = num # } # # row [ i ] = 1 # } # # return row
return big . NewInt ( 0 ). Add ( a , b )
return n * n
dp , np := 1 , 1 # for i := 1 ; i < 1 0 ; i ++ { # for den := 1 ; den < i ; den ++ { # for nom := 1 ; nom < den ; nom ++ { # if ( nom * 1 0 + i )* den == nom *( i * 1 0 + den ) { # dp *= den # np *= nom # } # } # } # } # return dp / Gcd ( np , dp )
return len ( strings . Fields ( s ))
index := strings . IndexRune ( p . key , char ) # if index < 0 { # return " STR ", char # } # row := index / p . size # col := index % p . size # chars := [] rune ( p . characters ) # return string ([] rune { chars [ row ], chars [ col ]}), nil
return s . data [ s . top - 1 ]
num 1 := [] int { 3 , 2 , 1 } # num 2 := [] int { 2 , 1 } # num 3 := [] int { 2 , 3 , 2 , 1 } # # fmt . Println ( thirdMax ( num 1 )) # fmt . Println ( thirdMax ( num 2 )) # fmt . Println ( thirdMax ( num 3 ))
qs := [] question 4 8 3 { # # { # para 4 8 3 {" STR "}, # ans 4 8 3 {" STR "}, # }, # # { # para 4 8 3 {" STR "}, # ans 4 8 3 {" STR "}, # }, # # { # para 4 8 3 {" STR "}, # ans 4 8 3 {" STR "}, # }, # # { # para 4 8 3 {" STR "}, # ans 4 8 3 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 8 3 , q . para 4 8 3 # fmt . Printf (" STR ", p , smallestGoodBase ( p . one )) # } # fmt . Printf (" STR ")
var num 2 int # for num >= 1 0 { # num 2 += num / 1 0 # num = num % 1 0 # } # if num 2 += num ; num 2 >= 1 0 { # return addDigits ( num 2 ) # } # return num 2
total := 0 # romanLen := len ( roman ) # for holder := range roman { # if holder + 1 < romanLen && romans [ string ( roman [ holder ])] < romans [ string ( roman [ holder + 1 ])] { # total -= romans [ string ( roman [ holder ])] # } else { # total += romans [ string ( roman [ holder ])] # } # } # return total
if root == nil { # return root # } # root . Left = invertTree ( root . Left ) # root . Right = invertTree ( root . Right ) # root . Left , root . Right = root . Right , root . Left # return root
inLen := len ( c . in ) # for i := seed ; i < inLen - 1 ; i ++ { # c . out = append ( c . out , c . in [ i ]) # fmt . Println ( string ( c . out )) # c . Combine ( i + 1 ) # c . out = c . out [: len ( c . out )- 1 ] # } # c . out = append ( c . out , c . in [ inLen - 1 ]) # fmt . Println ( string ( c . out )) # c . out = c . out [: len ( c . out )- 1 ]
if s == " STR " { # return [] string {} # } # res , ip := [] string {}, [] int {} # dfs ( s , 0 , ip , & res ) # return res
t . Parallel () # for _ , tc := range testcases { # if most := MostPlayerWins ( tc . deck ); most != tc . mostWins { # t . Errorf (" STR ", tc . mostWins , most ) # } # }
t . Parallel () # for _ , tc := range testcases { # r := strings . NewReader ( tc . fileData ) # results := make ([] string , 0 , tc . reads ) # for i := 0 ; i < tc . reads ; i ++ { # results = append ( results , ReadN ( r , tc . n )) # } # if ! reflect . DeepEqual ( tc . expected , results ) { # t . Errorf (" STR ", tc . expected , results ) # } # }
size := len ( A ) # # BI := make ([][ 2 ] int , size ) # for i , n := range B { # BI [ i ][ 0 ], BI [ i ][ 1 ] = n , i # } # # sort . Slice ( BI , func ( i int , j int ) bool { # return BI [ i ][ 0 ] < BI [ j ][ 0 ] # }) # # res := make ([] int , size ) # # sort . Ints ( A ) # # l , r := 0 , size - 1 # for _ , a := range A { # if BI [ l ][ 0 ] < a { # res [ BI [ l ][ 1 ]] = a # l ++ # } else { # res [ BI [ r ][ 1 ]] = a # r -- # } # } # # return res
n := len ( S ) # # last := [ 2 6 ] int {} # for i , c := range S { # last [ c -' a '] = i # } # # stack , top := make ([] int , n ), - 1 # hasSeen := [ 2 6 ] bool {} # for i := 0 ; i < n ; i ++ { # c := int ( S [ i ] - ' a ') # if hasSeen [ c ] { # continue # } # for top >= 0 && # stack [ top ] > c && # i < last [ stack [ top ]] { # pop := stack [ top ] # top -- # hasSeen [ pop ] = false # } # top ++ # stack [ top ] = c # hasSeen [ c ] = true # } # # var sb strings . Builder # for i := 0 ; i <= top ; i ++ { # b := byte ( stack [ i ] + ' a ') # sb . WriteByte ( b ) # } # # return sb . String ()
count := 0 # for i := 1 ; i <= n ; i ++ { # for j := 1 ; j <= n ; j ++ { # if i * j == x { # count ++ # } # } # } # return count
if s == nil && t == nil { # return true # } # if s == nil || t == nil { # return false # } # if s . Val != t . Val { # return false # } # return helper ( s . Left , t . Left ) && helper ( s . Right , t . Right )
increasing , decreasing := true , true # for i , v := range A [ 1 :] { # if v > A [ i ] { # decreasing = false # } else if v < A [ i ] { # increasing = false # } # } # return increasing || decreasing
total := big . NewInt ( 1 ) # for n . Cmp ( big . NewInt ( 0 )) > 0 { # total = total . Mul ( total , n ) # n = n . Sub ( n , big . NewInt ( 1 )) # } # return total
if len ( A ) < 3 { # return 0 # } # quickSort 1 6 4 ( A , 0 , len ( A )- 1 ) # for i := len ( A ) - 1 ; i >= 2 ; i -- { # if ( A [ i ]+ A [ i - 1 ] > A [ i - 2 ]) && ( A [ i ]+ A [ i - 2 ] > A [ i - 1 ]) && ( A [ i - 2 ]+ A [ i - 1 ] > A [ i ]) { # return A [ i ] + A [ i - 1 ] + A [ i - 2 ] # } # } # return 0
sID := m . memory . encIdx ( id ) # item := m . update ( sID ) # var ok bool # if item . Value .(* cacheItem ). value , ok = m . downStreamModel . read ( sID ); ! ok { # panic ( fmt . Sprintf (" STR ", sID )) # } # item . Value .(* cacheItem ). dirty = false # return m . memory . decData ( item . Value .(* cacheItem ). value ), ok
return & loopArrQueue { # data : make ([] interface {}, size ), # head : 0 , # tail : 0 , # size : size , # }
sMap := make ( map [ string ] int ) # # for i := start ; i < end ; i ++ { # if sMap [ string ( s [ i ])] > 0 { # return false # } # sMap [ string ( s [ i ])]++ # } # # return true
tests := [...] testType { # { # in : [][] int { # { 1 , 1 }, # { 2 , 3 }, # { 3 , 2 }, # }, # want : true , # }, # { # in : [][] int { # { 1 , 1 }, # { 2 , 2 }, # { 3 , 3 }, # }, # want : false , # }, # } # for _ , tt := range tests { # got := isBoomerang ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
this . mutex . Lock () # defer this . mutex . Unlock () # if this . closed { # return false # } # if this . list . Len () >= this . maxItems && this . strategy == LimitStrategyReject { # return false # } # space := true # for this . list . Len () >= this . maxItems { # space = false # e := this . list . Front () # if e == nil { # panic (" STR ") # } # this . list . Remove ( e ) # } # this . list . PushBack ( v ) # this . cond . Signal () # return space
t . Write ( l . Message )
n := len ( position ) # cars := make ([]* car , n ) # for i := 0 ; i < n ; i ++ { # cars [ i ] = & car { # pos : position [ i ], # time : float 6 4 ( target - position [ i ]) / float 6 4 ( speed [ i ]), # } # } # sort . Slice ( cars , func ( i , j int ) bool { # return cars [ i ]. pos > cars [ j ]. pos # }) # # cur := 0 . # res := 0 # for _ , car := range cars { # if car . time > cur { # cur = car . time # res ++ # } # } # return res
return & Register { # element : element , # baseAddress : baseAddress , # }
if len ( arr ) == 0 { # return 0 # } # first , last := 0 , len ( arr )- 1 # # for first < last { # if arr [ first ] < arr [ last ] { # return arr [ first ] # } # # mid := first + (( last - first ) >> 1 ) # if arr [ mid ] > arr [ last ] { # first = mid + 1 # } else if arr [ mid ] < arr [ last ] { # last = mid # } else { # last -= 1 # } # } # # return arr [ first ]
cmap := newChainedHashMap () # for i := 0 ; i < 4 ; { # testHashMapDelete ( t , cmap ) # if ! reflect . DeepEqual ( cmap . Count , uint 3 2 ( 0 )) { # t . Log ( fmt . Sprintf (" STR ", 0 ) + fmt . Sprintf (" STR ", cmap . Count )) # t . Fail () # } # if ! reflect . DeepEqual ( cmap . Cap , uint 3 2 ( 0 )) { # t . Log ( fmt . Sprintf (" STR ", uint 3 2 ( 0 )) + fmt . Sprintf (" STR ", cmap . Cap )) # t . Fail () # } # i ++ # }
j := & big . Int {} # j . Exp ( i , i , nil ) # return j
pattern := bm . pattern # aBadChar := make ([] int , 2 5 6 ) # for i , _ := range aBadChar { # aBadChar [ i ] = - 1 # } # for index , char := range pattern { # aBadChar [ int ( char )] = index # } # bm . badCharMap = aBadChar
fmt . Println ( checkPossibility ([] int { 3 , 4 , 2 , 3 })) # fmt . Println ( checkPossibility ([] int { 1 , 4 , 2 , 3 }))
if root == nil { # return nil # } # if key < root . Val { # root . Left = deleteNode ( root . Left , key ) # } else if key > root . Val { # root . Right = deleteNode ( root . Right , key ) # } else { # if root . Left == nil { # return root . Right # } # if root . Right == nil { # return root . Left # } # root . Val = findMin ( root . Right ) # root . Right = deleteNode ( root . Right , root . Val ) # } # return root
sSize , pSize := len ( s ), len ( p ) # # dp := make ([][] bool , sSize + 1 ) # for i := range dp { # dp [ i ] = make ([] bool , pSize + 1 ) # } # dp [ 0 ][ 0 ] = true # # for j := 1 ; j <= pSize ; j ++ { # if p [ j - 1 ] == '*' { # dp [ 0 ][ j ] = dp [ 0 ][ j - 1 ] # } # } # # for i := 1 ; i <= sSize ; i ++ { # for j := 1 ; j <= pSize ; j ++ { # if p [ j - 1 ] != '*' { # dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] && # ( p [ j - 1 ] == s [ i - 1 ] || p [ j - 1 ] == '?') # } else { # dp [ i ][ j ] = dp [ i - 1 ][ j ] || dp [ i ][ j - 1 ] # } # } # } # # return dp [ sSize ][ pSize ]
f := multiFuncDefer () # defer f ( 1 )
t . Parallel () # # for _ , tc := range testcases { # if res := PossibleMaxHeaps ( tc . n ); res != tc . expected { # t . Errorf (" STR ", tc . expected , res ) # } # }
created := time . Now () # return func () { # now := time . Now () # if elapsed := int ( now . Sub ( created ) / time . Millisecond ); elapsed > n { # f () # } # }
check , err := this . Parse ( s ) # if err == nil && ( v & check ) != 0 { # return true # } # return false
rows , cols := len ( grid ), len ( grid [ 0 ]) # visited := make ([] bool , rows * cols ) # max := 0 # for i := 0 ; i < rows ; i ++ { # for j := 0 ; j < cols ; j ++ { # if grid [ i ][ j ] == 1 && ! visited [ i * cols + j ] { # area := getIslandArea ( grid , visited , i , j ) # if area > max { # max = area # } # } # } # } # # return max
tests := [...] testType { # { # in : 4 3 2 6 1 5 9 6 , # want : 9 6 4 1 7 6 1 9 2 , # }, # { # in : 4 2 9 4 9 6 7 2 9 3 , # want : 3 2 2 1 2 2 5 4 7 1 , # }, # } # for _ , tt := range tests { # got := reverseBits ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
m := map [ byte ] int { # ' I ': 1 , # ' V ': 5 , # ' X ': 1 0 , # ' L ': 5 0 , # ' C ': 1 0 0 , # ' D ': 5 0 0 , # ' M ': 1 0 0 0 , # } # result := m [ s [ 0 ]] # for i := 1 ; i < len ( s ); i ++ { # if last , now := m [ s [ i - 1 ]], m [ s [ i ]]; last < now { # result += now - 2 * last # } else { # result += now # } # } # return result
if head == nil || head . Next == nil { # return head # } # # if head . Val == head . Next . Val { # for head . Next != nil && head . Val == head . Next . Val { # head = head . Next # } # return deleteDuplicates ( head . Next ) # } # # head . Next = deleteDuplicates ( head . Next ) # return head
sl . stack . PushFront ( val )
fp , err := os . OpenFile ( executable , os . O_RDWR , 0 ) # if err != nil { # return err # } # defer fp . Close () # # elfFile , err := elf . Open ( executable ) # if err != nil { # return err # } # defer elfFile . Close () # # section := elfFile . Section ( sectionName ) # if section == nil { # return fmt . Errorf (" STR ", sectionName ) # } # # if section . Size != section . FileSize { # return fmt . Errorf (" STR ", sectionName , section . Size , section . FileSize ) # } # # if section . Size != uint 6 4 ( len ( data )) { # return fmt . Errorf (" STR ", sectionName , len ( data ), section . Size ) # } # # _ , err = fp . WriteAt ( data , int 6 4 ( section . Offset )) # return err
Q := [ 2 ] int {- 1 , 1 } # # n := len ( A ) # res := 0 # for _ , a := range Q { # for _ , b := range Q { # low := a * A [ 0 ] + b * B [ 0 ] # for i := 1 ; i < n ; i ++ { # cur := a * A [ i ] + b * B [ i ] + i # res = max ( res , cur - low ) # low = min ( low , cur ) # } # } # } # return res
p . string ( fmt . Sprintf ( format , args ...))
if n < 3 { # return 0 # } # var count int # fMap := make ( map [ int ] bool ) # for i := 2 ; i < n ; i ++ { # if fMap [ i ] { # continue # } # count ++ # fMap [ i ] = false # for j := 2 * i ; j < n ; j += i { # fMap [ j ] = true # } # } # return count
result := & ListNode {} # temp := result # v , n := 0 , 0 # # for { # v , n = add ( l 1 , l 2 , n ) # temp . Val = v # # l 1 = next ( l 1 ) # l 2 = next ( l 2 ) # if l 1 == nil && l 2 == nil { # break # } # # temp . Next = & ListNode {} # temp = temp . Next # } # # if n == 1 { # temp . Next = & ListNode { Val : n } # } # # return result
m := a [ 0 ] # for _ , v := range a { # if v < m { # m = v # } # } # return m
total , curMax , curMin := 0 , 0 , 0 # maxSum , minSum := - 3 0 0 0 1 , 3 0 0 0 1 # # for _ , a := range A { # curMax = max ( curMax + a , a ) # maxSum = max ( maxSum , curMax ) # curMin = min ( curMin + a , a ) # minSum = min ( minSum , curMin ) # total += a # } # # if maxSum > 0 { # return max ( maxSum , total - minSum ) # } # return maxSum
dp := make ( map [ int ] int ) # dp [ 1 ] = 1 # for i := 2 ; i < n + 1 ; i ++ { # j , k := 1 , i - 1 # ans := 0 # for j <= k { # ans = max ( ans , max ( j , dp [ j ])* max ( k , dp [ k ])) # j ++ # k -- # } # dp [ i ] = ans # } # return dp [ n ]
n := len ( senate ) # qr := make ([] int , 0 , n ) # qd := make ([] int , 0 , n ) # for i , b := range senate { # if b == ' R ' { # qr = append ( qr , i ) # } else { # qd = append ( qd , i ) # } # } # # for len ( qr ) > 0 && len ( qd ) > 0 { # ri , di := qr [ 0 ], qd [ 0 ] # qr , qd = qr [ 1 :], qd [ 1 :] # if ri < di { # qr = append ( qr , ri + n ) # } else { # qd = append ( qd , di + n ) # } # } # # if len ( qr ) > 0 { # return " STR " # } # return " STR "
if head == nil || head . Next == nil { # return head # } # # tail := reverseList ( head . Next ) # head . Next . Next = head # head . Next = nil # return tail
nums := make ([] int , max + 1 ) # ch <- 2 # for i := 3 ; i < max ; i += 2 { # if nums [ i ] == 0 { # ch <- i # for n := i ; n <= max ; n += i { # nums [ n ] = 1 # } # } # } # close ( ch )
var numMap = make ( map [ int ] int , 0 ) # for k , v := range nums { # if _ , ok := numMap [ v ]; ok { # return true # } # numMap [ v ] = k # } # return false
res , stack , top , temp := 0 , [] int {}, - 1 , 0 # for _ , s := range S { # if s == '(' { # stack = append ( stack , - 1 ) # top ++ # } else { # temp = 0 # for stack [ top ] != - 1 { # temp += stack [ top ] # stack = stack [: len ( stack )- 1 ] # top -- # } # stack = stack [: len ( stack )- 1 ] # top -- # if temp == 0 { # stack = append ( stack , 1 ) # top ++ # } else { # stack = append ( stack , temp * 2 ) # top ++ # } # } # } # for len ( stack ) != 0 { # res += stack [ top ] # stack = stack [: len ( stack )- 1 ] # top -- # } # return res
res , pos , neg := nums [ 0 ], 1 , 1 # for _ , num := range nums { # if num == 0 { # pos , neg = 0 , 1 # } else if num > 0 { # pos *= num # neg *= num # } else { # pos , neg = neg * num , pos * num # } # if pos > res { # res = pos # } # if pos <= 0 { # pos = 1 # } # } # return res
arr := strings . Split ( path , " STR ") # stack := make ([] string , 0 ) # var res string # for i := 0 ; i < len ( arr ); i ++ { # cur := arr [ i ] # if cur == " STR " { # if len ( stack ) > 0 { # stack = stack [: len ( stack )- 1 ] # } # } else if cur != " STR " && len ( cur ) > 0 { # stack = append ( stack , arr [ i ]) # } # } # if len ( stack ) == 0 { # return " STR " # } # res = strings . Join ( stack , " STR ") # return " STR " + res
sum := 0 # for _ , n := range nums { # sum += n # } # # if sum & 1 == 1 { # return false # } # # sum = sum >> 1 # n := len ( nums ) # # dp := make ([][] bool , n + 1 ) # for i := range dp { # dp [ i ] = make ([] bool , sum + 1 ) # } # # for i := 0 ; i < n + 1 ; i ++ { # dp [ i ][ 0 ] = true # } # # for j := 1 ; j < sum + 1 ; j ++ { # dp [ 0 ][ j ] = false # } # # for i := 1 ; i < n + 1 ; i ++ { # for j := 1 ; j < sum + 1 ; j ++ { # dp [ i ][ j ] = dp [ i - 1 ][ j ] # if j >= nums [ i - 1 ] { # dp [ i ][ j ] = dp [ i ][ j ] || dp [ i - 1 ][ j - nums [ i - 1 ]] # } # } # } # # return dp [ n ][ sum ]
slow := nums [ 0 ] # fast := nums [ nums [ 0 ]] # for fast != slow { # slow = nums [ slow ] # fast = nums [ nums [ fast ]] # } # walker := 0 # for walker != slow { # walker = nums [ walker ] # slow = nums [ slow ] # } # return walker
strList := [] byte ( t ) # patternByte := [] byte ( s ) # if ( s == " STR " && t != " STR ") || ( len ( patternByte ) != len ( strList )) { # return false # } # # pMap := map [ byte ] byte {} # sMap := map [ byte ] byte {} # for index , b := range patternByte { # if _ , ok := pMap [ b ]; ! ok { # if _ , ok = sMap [ strList [ index ]]; ! ok { # pMap [ b ] = strList [ index ] # sMap [ strList [ index ]] = b # } else { # if sMap [ strList [ index ]] != b { # return false # } # } # } else { # if pMap [ b ] != strList [ index ] { # return false # } # } # } # return true
if len ( path ) < 2 { # return 0 # } # steps := 0 # current := path [ 0 ] # for i := 1 ; i < len ( path ); i ++ { # next := path [ i ] # dx , dy := delta ( current , next ) # if dx < dy { # steps += dy # } else { # steps += dx # } # current = next # } # return steps
k := int 6 4 ( 0 ) # for i := 0 ; i < len ( slice ); i ++ { # k = int 6 4 ( 1 0 )* k + int 6 4 ( slice [ i ]) # } # return k
if ! f . IsExported () { # return errNotExported # } # # if ! f . value . CanSet () { # return errNotSettable # } # # given := reflect . ValueOf ( val ) # # if f . value . Kind () != given . Kind () { # return fmt . Errorf (" STR ", given . Kind (), f . value . Kind ()) # } # # f . value . Set ( given ) # return nil
if len ( strs ) == 0 { # return " STR " # } # # prefix := strs [ 0 ] # for i := 1 ; i < len ( strs ); i ++ { # if len ( strs [ i ]) < len ( prefix ) { # prefix = prefix [: len ( strs [ i ])] # } # # var j int # for ; j < len ( prefix ); j ++ { # if strs [ i ][ j ] != prefix [ j ] { # break # } # } # # prefix = prefix [: j ] # if len ( prefix ) == 0 { # break # } # } # return prefix
m := len ( dungeon ) # if m == 0 { # return 1 # } # # n := len ( dungeon [ 0 ]) # if n == 0 { # return 1 # } # # intMax := 1 << 6 3 - 1 # dp := make ([][] int , m + 1 ) # for i := range dp { # dp [ i ] = make ([] int , n + 1 ) # for j := range dp [ i ] { # dp [ i ][ j ] = intMax # } # } # # health := 0 # dp [ m ][ n - 1 ] = 1 # for i := m - 1 ; i >= 0 ; i -- { # for j := n - 1 ; j >= 0 ; j -- { # health = min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]) - dungeon [ i ][ j ] # dp [ i ][ j ] = max ( health , 1 ) # } # } # # return dp [ 0 ][ 0 ]
op := d . lDOperation . init (" STR ", cost ) # op . lDCompute = d # return d
m 1 := make ([] int , 2 5 6 ) # m 2 := make ([] int , 2 5 6 ) # # for i := 0 ; i < len ( s ); i ++ { # if m 1 [ int ( s [ i ])] != m 2 [ int ( t [ i ])] { # return false # } # # i 2 := i + 1 # m 1 [ int ( s [ i ])] = i 2 # m 2 [ int ( t [ i ])] = i 2 # } # # return true
if client == nil { # client = http . DefaultClient # } # resp , err := client . Do ( req ) # if err != nil { # return nil , err # } # defer resp . Body . Close () # # bb := & bytes . Buffer {} # n , err := io . Copy ( bb , resp . Body ) # if err != nil { # return nil , err # } # # resp . ContentLength = n # resp . Body = ioutil . NopCloser ( bb ) # # return resp , nil
dp := [ 1 0 0 1 ] int { 1 : 1 , 2 : 2 , 3 : 5 } # if N <= 3 { # return dp [ N ] # } # # for i := 4 ; i <= N ; i ++ { # dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 3 ] # dp [ i ] %= mod # } # # return dp [ N ]
if list . head == nil { # return 0 , false # } # current := list . head # for current . next != nil { # current = current . next # } # return current . data , true
return len ( l )
dict := make ( map [ int ] int , len ( nums )) # # for i := 0 ; i < len ( nums ); i ++ { # if value , ok := dict [ nums [ i ]]; ok { # if - k <= value - i || value - i <= k { # return true # } # } # dict [ nums [ i ]] = i # } # # return false
sort . Ints ( A ) # minIdx := 0 # for i := 0 ; i < K ; i ++ { # A [ minIdx ] = - A [ minIdx ] # if A [ minIdx + 1 ] < A [ minIdx ] { # minIdx ++ # } # } # sum := 0 # for _ , a := range A { # sum += a # } # return sum
fmt . Println ( toGoatLatin (" STR ")) # fmt . Println ( toGoatLatin (" STR "))
var tests = [] struct { # list [] int # sortedList * ListNode # }{ # { # [] int { 4 , 2 , 1 , 3 }, # newList ( 1 , 2 , 3 , 4 ), # }, # { # [] int {- 1 , 5 , 3 , 4 , 0 }, # newList (- 1 , 0 , 3 , 4 , 5 ), # }, # { # [] int { 1 , 2 , 3 , 4 }, # newList ( 1 , 2 , 3 , 4 ), # }, # { # [] int { 4 , 3 , 2 , 1 }, # newList ( 1 , 2 , 3 , 4 ), # }, # { # nil , # nil , # }, # } # # for _ , tt := range tests { # sortedList := insertionSortList ( newList ( tt . list ...)) # if reflect . DeepEqual ( sortedList , tt . sortedList ) == false { # t . Errorf (" STR ", newList ( tt . list ...), sortedList , tt . sortedList ) # } # }
for i := len ( digits ) - 1 ; i >= 0 ; i -- { # if 9 != digits [ i ] { # digits [ i ]++ # break # } else { # digits [ i ] = 0 # } # } # if 0 == digits [ 0 ] { # newAns := make ([] int , len ( digits )+ 1 ) # newAns [ 0 ] = 1 # return newAns # } # return digits
if sum == target { # tmp := make ([] int , len ( now )) # copy ( tmp , now ) # ret = append ( ret , tmp ) # return # } # if sum > target { # return # } # for i := idx ; i < len ( c ); i ++{ # now = append ( now , c [ i ]) # help ( c , sum + c [ i ], target , i ) # now = now [: len ( now )- 1 ] # }
if n == 1 { # return 0 # } # # for i := 2 ; i < n ; i ++ { # if n % i == 0 { # return i + minSteps ( n / i ) # } # } # # return n
head := & ListNode { # Val : 1 , # Next : & ListNode { # Val : 2 , # Next : & ListNode { # Val : 3 , # }, # }, # } # reverseKGroup ( head , 2 )
lo , hi := 0 , len ( nums )- 1 # for lo < hi { # mid := lo + ( hi - lo )/ 2 # if nums [ mid ] > nums [ mid + 1 ] { # hi = mid # } else { # lo = mid + 1 # } # } # return lo
return ( n * ( n + 1 )) / 2
n := len ( S ) # m := [ 2 6 ] int {} # for i := 0 ; i < n ; i ++ { # m [ S [ i ]-' a '] = i # } # l , r := 0 , m [ S [ 0 ]-' a '] # res := [] int {} # for i := 0 ; i < n ; i ++ { # if i < r { # r = max ( r , m [ S [ i ]-' a ']) # continue # } # res = append ( res , i - l + 1 ) # l = i + 1 # if l < len ( S ) { # r = m [ S [ l ]-' a '] # } # } # return res
result := make ( map [ string ] interface {}) # dfsFlattenMap ([] string {}, m , result ) # return result
var xor , squaresum 1 , squaresum 2 rune # for _ , char := range s { # xor ^= char # squaresum 1 += char * char # } # for _ , char := range t { # xor ^= char # squaresum 2 += char * char # } # return xor == 0 && squaresum 1 == squaresum 2
sum := 0 # # for i := 0 ; i < 2 0 0 0 0 0 0 ; i ++ { # if isPrime ( i ) { # sum += i # } # } # # fmt . Println ( sum )
odd , even := 0 , 0 # for _ , c := range chips { # if c % 2 == 0 { # even ++ # } else { # odd ++ # } # } # return min ( odd , even )
t . Parallel () # for _ , tc := range testcases { # if canColor := CanColor ( 0 , tc . g , make ([] int , len ( tc . g )), tc . k ); canColor != tc . canColor { # t . Errorf (" STR ", tc . canColor , canColor ) # } # }
return len (* s )
n := len ( S ) # l , r := 0 , 0 # for i := 0 ; i < n ; i ++ { # if S [ i ] == '(' { # l ++ # } else if l <= 0 { # r ++ # } else { # l -- # } # } # return l + r
t . Parallel () # for _ , tc := range testcases { # if result := MinRemovedParens ( tc . input ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
var isNotPowerOfTwo uint = 1 # if ( v & ( v - 1 )) == 0 { # isNotPowerOfTwo = 0 # } # return log 2 Floor ( v ) + isNotPowerOfTwo
sort . Slice ( points , func ( i , j int ) bool { # return points [ i ][ 0 ]* points [ i ][ 0 ]+ points [ i ][ 1 ]* points [ i ][ 1 ] < points [ j ][ 0 ]* points [ j ][ 0 ]+ points [ j ][ 1 ]* points [ j ][ 1 ] # }) # return points [: K ]
m := [ 2 6 ] bool {} # for _ , t := range letters { # m [ t -' a '] = true # } # for i := 1 ; i <= 2 6 ; i ++ { # if m [( i + int ( target )-' a ')% 2 6 ] == true { # return byte (( i + int ( target )-' a ')% 2 6 + ' a ') # } # } # return ' a '
res := 0 # count := 0 # var preorder func (* TreeNode ) # preorder = func ( node * TreeNode ) { # if node == nil || count == k { # return # } # preorder ( node . Left ) # count ++ # if count == k { # res = node . Val # } # preorder ( node . Right ) # } # preorder ( root ) # return res
fmt . Println ( countAndSay ( 1 )) # fmt . Println ( countAndSay ( 2 )) # fmt . Println ( countAndSay ( 3 )) # fmt . Println ( countAndSay ( 4 ))
fmt . Println ( myAtoi (" STR ")) # fmt . Println ( myAtoi (" STR "))
a := 1 # b := 1 # c := 1 # sum := 0 # println (" STR ") # for ; a < 9 9 8 ; a ++ { # for ; b < 9 9 8 ; b ++ { # for ; c < 9 9 8 ; c ++ { # sum = a + b + c # if sum == 1 0 0 0 { # if ( pow ( a , 2 ) + pow ( b , 2 )) == pow ( c , 2 ) { # println (" STR ", a * b * c ) # return # } # } # } # c = 1 # } # b = 1 # }
l := newLights ( N ) # for _ , lamp := range lamps { # x , y := lamp [ 0 ], lamp [ 1 ] # l . turnOn ( x , y ) # } # # res := make ([] int , 0 , len ( queries )) # for _ , cell := range queries { # x , y := cell [ 0 ], cell [ 1 ] # res = append ( res , l . checkIlluminated ( x , y )) # } # # return res
result := 0 # for i := range s { # result = result * 2 6 + int ( s [ i ]-' A ') + 1 # } # # return result
res := 0 # # for n >= 5 { # n /= 5 # res += n # } # # return res
if len ( word ) <= 1 { # return true # } # # firstChar := word [ 0 ] # secondChar := word [ 1 ] # if ' a ' <= firstChar && firstChar <= ' z ' { # for i := 1 ; i < len ( word ); i ++ { # if word [ i ] < ' a ' || word [ i ] > ' z ' { # return false # } # } # } else if ' a ' <= secondChar && secondChar <= ' z ' { # for i := 2 ; i < len ( word ); i ++ { # if word [ i ] < ' a ' || word [ i ] > ' z ' { # return false # } # } # } else { # for i := 1 ; i < len ( word ); i ++ { # if word [ i ] < ' A ' || word [ i ] > ' Z ' { # return false # } # } # } # return true
parent := make ([] int , len ( edges )+ 1 ) # var secondLink [] int # for _ , e := range edges { # if parent [ e [ 1 ]] != 0 { # secondLink = [] int { e [ 0 ], e [ 1 ]} # } else { # parent [ e [ 1 ]] = e [ 0 ] # } # } # # if secondLink != nil { # secondParent := secondLink [ 0 ] # secondParentFound := false # startNode := secondLink [ 1 ] # node := 0 # for node = parent [ startNode ]; node != 0 && node != startNode ; node = parent [ node ] { # if node == secondParent { # secondParentFound = true # break # } # } # if node == 0 || secondParentFound { # return secondLink # } # return [] int { parent [ secondLink [ 1 ]], secondLink [ 1 ]} # } # visited := map [ int ] struct {}{} # node := 1 # found := false # for ! found { # visited [ node ] = struct {}{} # node = parent [ node ] # _ , found = visited [ node ] # } # return [] int { parent [ node ], node }
var i , j int # var tmp Problem # # for i = 1 ; i < len ( problems ); i ++ { # tmp = problems [ i ] # for j = i ; j > 0 && problems [ j - 1 ]. Stat . QuestionID > tmp . Stat . QuestionID ; j -- { # problems [ j ] = problems [ j - 1 ] # } # problems [ j ] = tmp # } # # return problems
beforehead := & ListNode {} # before := beforehead # afterhead := & ListNode {} # after := afterhead # for head != nil { # if head . Val < x { # before . Next = head # before = before . Next # } else { # after . Next = head # after = after . Next # } # head = head . Next # } # after . Next = nil # before . Next = afterhead . Next # return beforehead . Next
var z [] int # zlen := len ( x ) + 1 # if zlen <= cap ( x ) { # z = x [: zlen ] # } else { # zcap := zlen # if zcap < 2 * len ( x ) { # zcap = 2 * len ( x ) # } # z = make ([] int , zlen , zcap ) # copy ( z , x ) # } # z [ len ( x )] = y # return z
diag := make ([] float 6 4 , A . cols ) # for i := 0 ; i < len ( diag ); i ++ { # diag [ i ] = A . GetElm ( i , i ) # } # return diag
var tests = [] struct { # tree * TreeNode # balanced bool # }{ # { newTree ( 3 , 9 , 2 0 , nil , nil , 1 5 , 7 ), true }, # { newTree ( 1 , 2 , 2 , 3 ), true }, # { newTree ( 1 , 2 , 2 , 3 , 3 , nil , nil , 4 , 4 ), false }, # { newTree ( 1 , 2 , 2 , 3 , nil , 3 , 3 , 4 ), false }, # { newTree ( 1 , 2 , 2 , nil , nil , nil , 3 , 4 , 4 ), false }, # } # # for _ , tt := range tests { # balanced := isBalanced ( tt . tree ) # if balanced != tt . balanced { # t . Errorf (" STR ", tt . tree , balanced , tt . balanced ) # } # }
hdrs := [] lout { # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemStart , " STR "}, # { itemEnd , " STR "}, # { itemLength , " STR "}}}, # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemStart , " STR "}, # { itemLength , " STR "}}}, # {" STR ", " STR ", [] token { # { itemUnit , " STR "}, # { itemStart , " STR "}, # { itemEnd , " STR "}, # { itemLength , " STR "}}}, # } # for _ , h := range hdrs { # t . Run ( h . Name , lexCmp ( lexResponse , h )) # }
sort . Ints ( lst )
sum := 0 # for _ , n := range l { # sum += n # } # return sum
fmt . Println ( intsToString ([] int { 1 , 2 , 3 }))
iE := i .(* ltHeapElement ) # return iE . Value .( int )
digitsMap := make ( map [ rune ] struct {}) # if len ( number ) != 1 0 || number [ 0 ] == ' 0 ' { # return false # } # for _ , digit := range number { # _ , found := digitsMap [ digit ] # if found { # return false # } # digitsMap [ digit ] = struct {}{} # } # return true
res := [] int {} # m 1 := getInts ( a 1 ) # m 2 := getInts ( a 2 ) # # if len ( m 1 ) > len ( m 2 ) { # m 1 , m 2 = m 2 , m 1 # } # for n := range m 1 { # m 1 [ n ] = min ( m 1 [ n ], m 2 [ n ]) # } # # for n , size := range m 1 { # for i := 0 ; i < size ; i ++ { # res = append ( res , n ) # } # } # # return res
trie := Constructor () # trie . Insert (" STR ") # # for i , j := range map [ string ] bool {" STR ": true , " STR ": false , " STR ": false } { # if res := trie . Search ( i ); res != j { # t . Errorf (" STR ", j , res ) # } # } # # for i , j := range map [ string ] bool {" STR ": true , " STR ": false } { # if res := trie . StartsWith ( i ); res != j { # t . Errorf (" STR ", j , res ) # } # } # # trie . Insert (" STR ") # if res := trie . Search (" STR "); res != true { # t . Errorf (" STR ", true , res ) # }
if len ( A ) == 0 { # return 0 # } # used , p , res := make ([] bool , len ( A )), [] int {}, [][] int {} # sort . Ints ( A ) # generatePermutation 9 9 6 ( A , 0 , p , & res , & used ) # return len ( res )
return me . HasOpt (" STR ")
if a == b { # return a # } # if a == 0 || b == 0 { # return a + b # } # # if a % 2 == 0 { # if b % 2 == 1 { # return recurse ( a >> 1 , b ) # } else { # return recurse ( a >> 1 , b >> 1 ) << 1 # } # } # # if b % 2 == 0 { # return recurse ( a , b >> 1 ) # } # # if a > b { # return recurse (( a - b )>> 1 , b ) # } # # return recurse (( b - a )>> 1 , a )
dx 0 := coordinates [ 1 ][ 0 ] - coordinates [ 0 ][ 0 ] # dy 0 := coordinates [ 1 ][ 1 ] - coordinates [ 0 ][ 1 ] # for i := 1 ; i < len ( coordinates )- 1 ; i ++ { # dx := coordinates [ i + 1 ][ 0 ] - coordinates [ i ][ 0 ] # dy := coordinates [ i + 1 ][ 1 ] - coordinates [ i ][ 1 ] # if dy * dx 0 != dy 0 * dx { # return false # } # } # return true
num , _ := strconv . ParseUint ( n , 1 0 , 6 4 ) # for bit := uint 6 4 ( math . Log 2 ( float 6 4 ( num ))); bit >= 1 ; bit -- { # low , high := uint 6 4 ( 2 ), uint 6 4 ( math . Pow ( float 6 4 ( num ), 1 . 0 / float 6 4 ( bit ))) # for low < high { # mid := uint 6 4 ( low + ( high - low )>> 1 ) # sum := findBase ( mid , bit ) # if sum == num { # return strconv . FormatUint ( mid , 1 0 ) # } else if sum > num { # high = mid - 1 # } else { # low = mid + 1 # } # } # } # return strconv . FormatUint ( num - 1 , 1 0 )
if len ( board ) == row { # temp := make ([] string , 0 ); # for i := range board { # temp = append ( temp , strings . Join ( board [ i ], "")); # } # * res = append (* res , temp ); # return ; # } # for col := 0 ; col < len ( board ); col ++ { # if isValid ( board , row , col ) { # board [ row ][ col ] = " STR "; # helper ( board , res , row + 1 ); # board [ row ][ col ] = " STR "; # } # }
i := sort . Search ( len ( arr )- k , func ( i int ) bool { return x - arr [ i ] <= arr [ i + k ]- x }) # return arr [ i : i + k ]
for row := 0 ; row < 9 ; row ++ { # if ! isValidSudokuRow ( board , row ) { # return false # } # } # # for col := 0 ; col < 9 ; col ++ { # if ! isValidSudokuCol ( board , col ) { # return false # } # } # # for pod := 0 ; pod < 9 ; pod ++ { # if ! isValidSudokuPod ( board , pod ) { # return false # } # } # return true
t . Parallel () # # for _ , tc := range testcases { # if result := MovesToUnlock ( tc . start , tc . target , tc . deadEnds ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
qs := [] question 7 6 3 { # # { # para 7 6 3 {" STR "}, # ans 7 6 3 {[] int { 9 , 7 , 8 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 6 3 , q . para 7 6 3 # fmt . Printf (" STR ", p , partitionLabels ( p . one )) # } # fmt . Printf (" STR ")
t . Parallel () # input := & BinaryTree {" STR ", # & BinaryTree {" STR ", & BinaryTree {" STR ", nil , nil }, & BinaryTree {" STR ", nil , nil }}, # & BinaryTree {" STR ", & BinaryTree {" STR ", nil , nil }, nil }} # original := & BinaryTree {" STR ", # & BinaryTree {" STR ", & BinaryTree {" STR ", nil , nil }, & BinaryTree {" STR ", nil , nil }}, # & BinaryTree {" STR ", & BinaryTree {" STR ", nil , nil }, nil }} # inverted := & BinaryTree {" STR ", # & BinaryTree {" STR ", nil , & BinaryTree {" STR ", nil , nil }}, # & BinaryTree {" STR ", & BinaryTree {" STR ", nil , nil }, & BinaryTree {" STR ", nil , nil }}} # InvertBinaryTree ( input ) # if ! equalTrees ( input , inverted ) { # t . Errorf (" STR ") # } # InvertBinaryTree ( input ) # if ! equalTrees ( input , original ) { # t . Errorf (" STR ") # }
sign := 1 # # if x < 0 { # sign = - 1 # x = - 1 * x # } # # res := 0 # for x > 0 { # temp := x % 1 0 # res = res * 1 0 + temp # x = x / 1 0 # } # # res = sign * res # # if res > math . MaxInt 3 2 || res < math . MinInt 3 2 { # res = 0 # } # # return res
return me . u . Scheme
qs := [] question 1 1 8 9 { # # { # para 1 1 8 9 {" STR "}, # ans 1 1 8 9 { 1 }, # }, # # { # para 1 1 8 9 {" STR "}, # ans 1 1 8 9 { 2 }, # }, # # { # para 1 1 8 9 {" STR "}, # ans 1 1 8 9 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 1 8 9 , q . para 1 1 8 9 # fmt . Printf (" STR ", p , maxNumberOfBalloons ( p . text )) # } # fmt . Printf (" STR ")
tests := [...] testType { # { # a : 1 , # b : 2 , # want : 3 , # }, # { # a : - 2 , # b : 3 , # want : 1 , # }, # } # for _ , tt := range tests { # got := getSum ( tt . a , tt . b ) # if got != tt . want { # t . Fatalf (" STR ", tt . a , tt . b , got , tt . want ) # } # }
type A struct { # Name string # D string # } # a := A { Name : " STR "} # # type B struct { # A A ` structs :" STR "` # C int # } # b := & B { A : a , C : 1 2 3 } # # ok := IsZero ( b ) # if ok { # t . Error (" STR ") # } # # aZero := A {} # bZero := & B { A : aZero } # # ok = IsZero ( bZero ) # if ! ok { # t . Error (" STR ") # } #
qs := [] question 9 7 7 { # # { # para 9 7 7 {[] int {- 4 , - 1 , 0 , 3 , 1 0 }}, # ans 9 7 7 {[] int { 0 , 1 , 9 , 1 6 , 1 0 0 }}, # }, # # { # para 9 7 7 {[] int { 1 }}, # ans 9 7 7 {[] int { 1 }}, # }, # # { # para 9 7 7 {[] int {- 7 , - 3 , 2 , 3 , 1 1 }}, # ans 9 7 7 {[] int { 4 , 9 , 9 , 4 9 , 1 2 1 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 7 7 , q . para 9 7 7 # fmt . Printf (" STR ", p , sortedSquares ( p . one )) # } # fmt . Printf (" STR ")
inc , dec := 1 , 1 # maxLen := min ( 1 , len ( A )) # for i := 1 ; i < len ( A ); i ++ { # if A [ i - 1 ] < A [ i ] { # inc = dec + 1 # dec = 1 # } else if A [ i - 1 ] > A [ i ] { # dec = inc + 1 # inc = 1 # } else { # inc = 1 # dec = 1 # } # maxLen = max ( maxLen , max ( inc , dec )) # } # return maxLen
t . Parallel () # for _ , tc := range testcases { # if result := RotateMatrixRightClockwise 9 0 ( tc . matrix ); ! reflect . DeepEqual ( result , tc . rotated ) { # t . Errorf (" STR ", tc . rotated , result ) # } # }
var tests = [] struct { # nums [] int # target int # index int # }{ # {[] int { 4 , 5 , 6 , 7 , 0 , 1 , 2 }, 0 , 4 }, # {[] int { 4 , 5 , 6 , 7 , 0 , 1 , 2 }, 3 , - 1 }, # {[] int { 0 , 1 , 2 , 4 , 5 , 6 , 7 }, 2 , 2 }, # {[] int { 0 , 1 , 2 , 4 , 5 , 6 , 7 }, 3 , - 1 }, # {[] int { 2 , 4 , 5 , 6 , 7 , 0 , 1 }, 3 , - 1 }, # {[] int { 8 , 9 , 2 , 3 , 4 }, 9 , 1 }, # {[] int { 1 }, 0 , - 1 }, # { nil , 0 , - 1 }, # } # # for _ , tt := range tests { # index := search ( tt . nums , tt . target ) # if index != tt . index { # t . Errorf (" STR ", tt . nums , tt . target , index , tt . index ) # } # }
StoreUint 6 4 (& r . Reg , LoadUint 6 4 (& r . Reg )&^ value )
m , n := len ( A ), len ( A [ 0 ]) # # isBigger := make ([] bool , m ) # res := 0 # # for j := 0 ; j < n ; j ++ { # t := make ([] bool , m ) # i , count := 1 , 1 # for ; i < m ; i ++ { # if isBigger [ i ] || # A [ i ][ j ] > A [ i - 1 ][ j ] { # t [ i ] = true # count ++ # } else if A [ i - 1 ][ j ] > A [ i ][ j ] { # res ++ # break # } # } # if count == m { # break # } # if i == m { # isBigger = t # } # } # # return res
ss := make ( map [ int ] int ) # h := MyHashSet { # s : ss , # } # return h
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int {- 2 , 1 , - 3 , 4 , - 1 , 2 , 1 , - 5 , 4 }, 6 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := maxSubArray ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
n := len ( words ) # # bits := make ([] int , n ) # for i , word := range words { # for j := 0 ; j < len ( word ); j ++ { # bits [ i ] |= 1 << uint 3 2 ( word [ j ]-' a ') # } # } # # res := 0 # for i := 0 ; i < n - 1 ; i ++ { # for j := i + 1 ; j < n ; j ++ { # if bits [ i ]& bits [ j ] != 0 { # continue # } # tmp := len ( words [ i ]) * len ( words [ j ]) # if tmp > res { # res = tmp # } # } # } # return res
tmp := 0 # for i := 0 ; i < k ; i ++ { # tmp += nums [ i ] # } # # max := tmp # for i := k ; i < len ( nums ); i ++ { # tmp = tmp - nums [ i - k ] + nums [ i ] # # if max < tmp { # max = tmp # } # } # # return float 6 4 ( max ) / float 6 4 ( k )
index := math . Floor ( math . Log 2 ( float 6 4 ( label ))) # t := int ( math . Pow ( 2 , index )) # i , sum := int ( index ), t + t / 2 - 1 # res := make ([] int , i + 1 ) # for i >= 0 { # res [ i ] = label # label = sum - label / 2 # sum /= 2 # i -- # } # return res
sort . Ints ( A ) # count := 0 # for i := 0 ; i < len ( A ); i ++ { # j , k := i + 1 , len ( A )- 1 # for j < k { # if A [ i ]+ A [ j ]+ A [ k ] > target { # k -- # } else if A [ i ]+ A [ j ]+ A [ k ] < target { # j ++ # } else if A [ j ] != A [ k ] { # sameIndex 1 := j # for sameIndex 1 < k && A [ sameIndex 1 ] == A [ j ] { # sameIndex 1 ++ # } # # sameIndex 2 := k # for sameIndex 2 > j && A [ sameIndex 2 ] == A [ k ] { # sameIndex 2 -- # } # # count = ( count + ( sameIndex 1 - j )*( k - sameIndex 2 )) % 1 0 0 0 0 0 0 0 0 7 # j , k = sameIndex 1 , sameIndex 2 # } else { # length := k - j + 1 # count = ( count + length *( length - 1 )/ 2 ) % 1 0 0 0 0 0 0 0 0 7 # j = k + 1 # } # } # } # # return count
result := make ([] int , len ( sorted )) # for i := range sorted { # result [ i ] = sorted [ i ] * sorted [ i ] # } # sort . Ints ( result ) # return result
return RangeModule { ranges : make ([]* interval , 0 , 2 0 4 8 )}
rets := [][] int {} # if len ( nums ) == 0 { # return rets # } # currentIndex := make ([] int , len ( nums )) # for i := range currentIndex { # currentIndex [ i ] = - 1 # } # solution := [] int {} # depth , maxDepth := - 1 , len ( nums )- 1 # for { # finish := false # L : # for depth < maxDepth { # for { # childDepth := depth + 1 # preIndex := currentIndex [ childDepth ] # if preIndex == len ( nums )- 1 { # finish = true # currentIndex [ childDepth ] = - 1 # break L # } # currentIndex [ childDepth ]++ # if depth == - 1 || nums [ currentIndex [ depth ]] < nums [ currentIndex [ childDepth ]] { # solution = append ( solution , nums [ currentIndex [ childDepth ]]) # break # } # } # depth ++ # } # if finish || depth == maxDepth { # cp := make ([] int , len ( solution )) # copy ( cp , solution ) # rets = append ( rets , cp ) # finish = false # } # if depth == - 1 { # break # } # depth -- # solution = solution [: len ( solution )- 1 ] # } # return rets
primes := make ( map [ int ] bool , 0 ) # primes [ 2 ] = true # primes [ 3 ] = true # primes [ 5 ] = true # primes [ 7 ] = true # primes [ 1 1 ] = true # primes [ 1 3 ] = true # primes [ 1 7 ] = true # primes [ 1 9 ] = true # # cnt := 0 # for i := L ; i <= R ; i ++ { # bits := 0 # for n := i ; n > 0 ; n /= 2 { # bits += n & 1 # } # if primes [ bits ] { # cnt ++ # } # } # return cnt
cases := [] struct { # name string # matrix [][] int # target int # expect bool # }{ # {" STR ", [][] int { # { 1 , 3 , 5 , 7 }, # { 1 0 , 1 1 , 1 6 , 2 0 }, # { 2 3 , 3 0 , 3 4 , 5 0 }, # }, 3 , true }, # {" STR ", [][] int { # { 1 , 3 , 5 , 7 }, # { 1 0 , 1 3 , 1 6 , 2 0 }, # { 2 3 , 3 0 , 3 4 , 5 0 }, # }, 1 3 , true }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := searchMatrix ( c . matrix , c . target ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . matrix ) # } # }) # }
res , sum := 0 , 0 # m := map [ int ] int {} # m [ 0 ] = 1 # # for _ , num := range nums { # sum += num # if v , ok := m [ sum - k ]; ok { # res += v # } # m [ sum ]++ # } # return res
n := len ( intervals ) # # starts := make ([] int , n ) # indexs := make ( map [ int ] int , n ) # res := make ([] int , n ) # # for i , interval := range intervals { # starts [ i ] = interval . Start # indexs [ interval . Start ] = i # } # # sort . Ints ( starts ) # for i , interval := range intervals { # index := sort . SearchInts ( starts , interval . End ) # if index < n { # res [ i ] = indexs [ starts [ index ]] # } else { # res [ i ] = - 1 # } # } # return res
sort . Ints ( nums ) # res := [][] int {} # # for i := 0 ; i < len ( nums )- 2 ; i ++ { # if i > 0 && nums [ i ] == nums [ i - 1 ] { # continue # } # # l , r := i + 1 , len ( nums )- 1 # for l < r { # if l > i + 1 && nums [ l ] == nums [ l - 1 ] { # l ++ # continue # } # tmp := nums [ i ] + nums [ l ] + nums [ r ] # if tmp == 0 { # res = append ( res , [] int { nums [ i ], nums [ l ], nums [ r ]}) # l ++ # r -- # } else if tmp < 0 { # l ++ # } else { # r -- # } # } # } # return res
_ , err := os . Stat ( filepath . Join ( goroot , " STR ", " STR ", " STR ", " STR ", " STR ")) # return err == nil
fmt . Printf (" STR ")
var tests = [] struct { # tree * TreeNode # tilt int # }{ # { newTree ( 1 , 2 , 3 ), 1 }, # } # # for _ , tt := range tests { # tilt := findTilt ( tt . tree ) # if tilt != tt . tilt { # t . Errorf (" STR ", tt . tree , tilt , tt . tilt ) # } # }
if x < y { # return y # } # return x
println (" STR ", n )
switch operate { # case " STR ": # return a + b # case " STR ": # return a - b # case " STR ": # return a * b # default : # panic (" STR ") # }
if a == 0 && b != 0 { # return 0 # } # if b == 0 { # return 1 # } # # mid := Pow ( a , ( b - 1 )/ 2 ) # mid *= mid # if b % 2 != 0 { # mid *= a # } # # return mid
var s , t byte # for i , j := len ( S )- 1 , len ( T )- 1 ; i >= 0 || j >= 0 ; { # i , s = next ( i , S ) # j , t = next ( j , T ) # if s != t { # return false # } # } # return true
cases := [] struct { # name string # input 1 string # input 2 [] string # expect bool # }{ # {" STR ", " STR ", [] string {" STR ", " STR "}, true }, # {" STR ", " STR ", [] string {" STR ", " STR "}, true }, # {" STR ", " STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR "}, false }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := wordBreak 2 ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 , c . input 2 ) # } # }) # }
left , right , ans := 1 , 1 , make ([] int , len ( a )) # for i := 0 ; i < len ( a ); i ++ { # ans [ i ] = left # left *= a [ i ] # } # for i := len ( a ) - 1 ; i >= 0 ; i -- { # ans [ i ] *= right # right *= a [ i ] # } # return ans
if n < 1 { # return "" # } # # say := [] byte (" STR ") # for i := 0 ; i < n - 1 ; i ++ { # var cnt byte # var nextSay [] byte # for j := 0 ; j < len ( say ); j ++ { # cnt ++ # if j == len ( say )- 1 || say [ j ] != say [ j + 1 ] { # nextSay = append ( nextSay , 4 8 + cnt , say [ j ]) # fmt . Println ( string ( nextSay ), string ( 4 8 + cnt ), string ( say [ j ])) # cnt = 0 # } # } # say = nextSay # } # return string ( say )
bytes , err := assetsHomeCatJpgBytes () # if err != nil { # return nil , err # } # # info := bindataFileInfo { name : " STR ", size : 4 4 2 9 4 , mode : os . FileMode ( 4 1 6 ), modTime : time . Unix ( 1 4 3 6 9 1 4 2 3 8 , 0 )} # a := & asset { bytes : bytes , info : info } # return a , nil
signal . Notify ( r . interrupt , os . Interrupt ) # # go func () { # r . complete <- r . run () # }() # # select { # case err := <- r . complete : # return err # # case <- r . timeout : # return ErrTimeout # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 0 , 1 5 , 2 0 }, 1 5 }, # {" STR ", [] int { 1 , 1 0 0 , 1 , 1 , 1 , 1 0 0 , 1 , 1 , 1 0 0 , 1 }, 6 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := minCostClimbingStairs ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
pos := make ( map [ int ] value ) # bottomView ( root , 0 , 0 , pos ) # result := make ([] interface {}, len ( pos )) # keys := make ([] int , 0 , len ( pos )) # for k := range pos { # keys = append ( keys , k ) # } # sort . Ints ( keys ) # for i , key := range keys { # result [ i ] = pos [ key ]. value # } # return result
var chPosition [ 2 5 6 ] int # maxLength , substringLen , lastRepeatPos := 0 , 0 , 0 # # for i := 0 ; i < len ( s ); i ++ { # if pos := chPosition [ s [ i ]]; pos > 0 { # maxLength = Max ( substringLen , maxLength ) # # chPosition [ s [ i ]] = i + 1 # # lastRepeatPos = Max ( pos , lastRepeatPos ) # # substringLen = i + 1 - lastRepeatPos # } else { # substringLen += 1 # chPosition [ s [ i ]] = i + 1 # } # } # # return Max ( maxLength , substringLen )
qs := [] question 4 7 5 { # # { # para 4 7 5 {[] int { 1 , 2 , 3 }, [] int { 2 }}, # ans 4 7 5 { 1 }, # }, # # { # para 4 7 5 {[] int { 1 , 2 , 3 , 4 }, [] int { 1 , 4 }}, # ans 4 7 5 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 7 5 , q . para 4 7 5 # fmt . Printf (" STR ", p , findRadius ( p . houses , p . heaters )) # } # fmt . Printf (" STR ")
var max , maxA , maxB , value , count int # for a := - 9 9 9 ; a < 1 0 0 0 ; a ++ { # for b := - 1 0 0 0 ; b <= 1 0 0 0 ; b ++ { # count = 0 # for n := 0 ; ; n ++ { # value = ( n * n ) + ( a * n ) + b # if isPrime ( value ) { # count ++ # } else { # if count > max { # maxA = a # maxB = b # max = count # } # break # } # } # } # } # fmt . Println (" STR ", maxA , " STR ", maxB ) # fmt . Println (" STR ", maxA * maxB )
t . Parallel () # # for _ , tc := range testcases { # if res , err := EightPuzzle ( tc . start ); ! reflect . DeepEqual ( res , tc . expected ) || err != tc . expectedErr { # t . Errorf (" STR ", tc . expected , tc . expectedErr , res , err , len ( res )) # } # }
var res [] int = make ([] int , len ( arr )) # var max int = arr [ len ( arr )- 1 ] # res [ len ( arr )- 1 ] = - 1 # for i := len ( arr ) - 2 ; i >= 0 ; i -- { # res [ i ] = max # if arr [ i ] > max { # max = arr [ i ] # } # } # return res
tests := [...] testType { # { # in : 2 8 , # want : true , # }, # { # in : 6 , # want : true , # }, # { # in : 2 4 , # want : false , # }, # { # in : 1 , # want : false , # }, # { # in : 3 3 5 5 0 3 3 6 , # want : true , # }, # } # for _ , tt := range tests { # got := checkPerfectNumber ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # } # for _ , tt := range tests { # got := checkPerfectNumber 2 ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if getRecurse ( 2 5 ) != 7 5 0 2 5 { # fmt . Println ( getRecurse ( 2 5 )) # t . Error () # }
si := & SimpleIterator {} # si . fullNames = [] string {" STR ", " STR ", " STR ", " STR "} # si . Length = 4 # return si
stack := make ([]* TreeNode , 0 ) # cur := root # i := 0 # for cur != nil || len ( stack ) > 0 { # for cur != nil { # stack = append ( stack , cur ) # cur = cur . Left # } # # cur = stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # i ++ # if i == k { # return cur . Val # } # # cur = cur . Right # } # # return - 1
C := 1 # for i := 0 ; i < n ; i ++ { # C = C * 2 * ( 2 * i + 1 ) / ( i + 2 ) # } # return C
sort . Sort ( sort . Reverse ( sort . IntSlice ( s ))) # sort . Sort ( sort . Reverse ( sort . IntSlice ( g ))) # # var ( # si , gi , res int # ) # # for gi < len ( g ) && si < len ( s ) { # if s [ si ] >= g [ gi ] { # res ++ # gi ++ # si ++ # } else { # gi ++ # } # } # # return res
return Encrypt ( input , 2 6 - key )
var res [] int # var min * TreeNode # for root != nil { # if root . Right == nil { # res = append ( res , root . Val ) # root = root . Left # } else { # min = root . Right # for min . Left != nil && min . Left != root . Left { # min = min . Left # } # # if min . Left == nil { # res = append ( res , root . Val ) # min . Left = root . Left # root = root . Right # } else { # root = root . Left # min . Left = nil # } # } # } # # l , r := 0 , len ( res )- 1 # for l < r { # res [ l ], res [ r ] = res [ r ], res [ l ] # l ++ # r -- # } # return res
var deep func (* TreeNode ) (* TreeNode , int ) # deep = func ( node * TreeNode ) (* TreeNode , int ) { # if node == nil { # return nil , 0 # } # l , ld := deep ( node . Left ) # r , rd := deep ( node . Right ) # # if ld == rd { # return node , ld + 1 # } else if ld > rd { # return l , ld + 1 # } else { # return r , rd + 1 # } # } # res , _ := deep ( root ) # return res
var s , sep string # for i := 1 ; i < len ( os . Args ); i ++ { # s += sep + os . Args [ i ] # sep = " STR " # } # fmt . Println ( s )
conn , err := net . Dial (" STR ", " STR ") # if err != nil { # log . Fatal ( err ) # } # for { # reader := bufio . NewReader ( os . Stdin ) # fmt . Print (" STR ") # text , _ := reader . ReadString (" STR ") # fmt . Fprintf ( conn , text +" STR ") # message , _ := bufio . NewReader ( conn ). ReadString (" STR ") # fmt . Print (" STR " + message ) # }
cases := [] struct { # name string # input string # expect string # }{ # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # } # # for _ , testcase := range cases { # t . Run ( testcase . name , func ( t * testing . T ) { # got := toLowerCase ( testcase . input ) # if ! reflect . DeepEqual ( got , testcase . expect ) { # t . Fatalf (" STR ", testcase . expect , got , testcase . input ) # } # }) # }
c . mu . Lock () # err := c . err # c . mu . Unlock () # return err
max := 0 # for i , v := range nums { # if v > 0 { # if i + v > max { # max = i + v # } # } else { # if max == i { # if i == len ( nums )- 1 { # return true # } # return false # } # } # # } # return max >= len ( nums )- 1
number := 2 0 # for ! IsDividedByAll ( number ) { # number ++ # } # return number
commonChars := make ([] string , 0 ) # if len ( A ) == 0 { # return commonChars # } # minFrequencies := [ 2 6 ] int {} # for i := range minFrequencies { # minFrequencies [ i ] = math . MaxInt 3 2 # } # for _ , word := range A { # charFrequencies := [ 2 6 ] int {} # for _ , char := range word { # charFrequencies [ char -' a ']++ # } # for i := 0 ; i < 2 6 ; i ++ { # minFrequencies [ i ] = min ( minFrequencies [ i ], charFrequencies [ i ]) # } # } # for i := 0 ; i < 2 6 ; i ++ { # for minFrequencies [ i ] > 0 { # commonChars = append ( commonChars , string ( rune ( i )+' a ')) # minFrequencies [ i ]-- # } # } # return commonChars
t . Parallel () # for _ , tc := range testcases { # if result := ShortestStandardizedPath ( tc . path ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
t . Parallel () # # for _ , tc := range testcases { # if result := Base 6 4 Delegate ( tc . hexs ); result != tc . expected { # t . Errorf (" STR ", tc . expected , tc . hexs ) # } # }
var data = make ( map [ string ] string ) # for cmd := range commands { # if len ( cmd . Fields ) < 2 { # cmd . Result <- " STR " # continue # } # # fmt . Println (" STR ", cmd ) # # switch cmd . Fields [ 0 ] { # case " STR ": # key := cmd . Fields [ 1 ] # value := data [ key ] # # cmd . Result <- value # # case " STR ": # if len ( cmd . Fields ) != 3 { # cmd . Result <- " STR " # continue # } # key := cmd . Fields [ 1 ] # value := cmd . Fields [ 2 ] # data [ key ] = value # cmd . Result <- "" # case " STR ": # key := cmd . Fields [ 1 ] # delete ( data , key ) # cmd . Result <- "" # default : # cmd . Result <- " STR " + cmd . Fields [ 0 ] + " STR " # } # }
if k < 2 { # return 0 # } # res := 0 # pro := 1 # l := 0 # for r , num := range nums { # pro *= num # for pro >= k { # pro /= nums [ l ] # l ++ # } # res += r - l + 1 # } # return res
var tests = [] struct { # before [] int # x int # after * ListNode # }{ # {[] int { 1 , 4 , 3 , 2 , 5 , 2 }, 3 , newList ( 1 , 2 , 2 , 4 , 3 , 5 )}, # } # # for _ , tt := range tests { # after := partition ( newList ( tt . before ...), tt . x ) # if reflect . DeepEqual ( after , tt . after ) == false { # t . Errorf (" STR ", newList ( tt . before ...), tt . x , after , tt . after ) # } # }
size := len ( nums ) # if size < 2 { # return size # } # # first := make ( map [ int ] int , size ) # count := make ( map [ int ] int , size ) # maxCount := 1 # minLen := size # for i , n := range nums { # count [ n ]++ # if count [ n ] == 1 { # first [ n ] = i # } else { # l := i - first [ n ] + 1 # if maxCount < count [ n ] || # ( maxCount == count [ n ] && minLen > l ) { # maxCount = count [ n ] # minLen = l # } # } # } # # if len ( count ) == size { # return 1 # } # return minLen
cases := [] struct { # name string # inputs * TreeNode # expect bool # }{ # { # " STR ", # & TreeNode { Val : 1 , # Left : & TreeNode { Val : 2 , Right : & TreeNode { Val : 3 }}, # Right : & TreeNode { Val : 2 , Right : & TreeNode { Val : 3 }}, # }, # false , # }, # { # " STR ", # & TreeNode { Val : 1 , # Left : & TreeNode { Val : 2 , # Left : & TreeNode { Val : 3 }, # Right : & TreeNode { Val : 4 }}, # Right : & TreeNode { Val : 2 , # Left : & TreeNode { Val : 4 }, # Right : & TreeNode { Val : 3 }, # }, # }, # true , # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := isSymmetric ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
if known , exists := (* k )[ a ]; exists { # return known [ b ] # } # # return false
ss := make ([] int , 1 0 0 0 0 0 0 ) # for i := 0 ; i < len ( ss ); i ++ { # ss [ i ] = - 1 # } # return MyHashMap { # s : ss , # }
if n == nil { # return # } # fmt . Print ( n . val , " STR ") # PreOrder ( n . left ) # PreOrder ( n . right )
scope := & BasicScope { # FuncMap : map [ string ] Function { # " STR ": Function {}, # }, # } # # if _ , ok := scope . LookupFunc (" STR "); ok { # t . Fatal (" STR ") # } # if _ , ok := scope . LookupFunc (" STR "); ! ok { # t . Fatal (" STR ") # }
var _ fmt . Stringer # println (" STR ")
testCases := [][] int { # { 7 , 1 , 5 , 3 , 6 , 4 }, # { 1 , 2 , 3 , 4 , 5 }, # { 7 , 6 , 4 , 3 , 1 }, # {}, { 1 }, # } # expected := [] int { 7 , 4 , 0 , 0 , 0 } # # for index , data := range testCases { # if res := maxProfit ( data ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
if left == nil { # return nil # } # var pre * ListNode # slow , fast := left , left # for fast != nil && fast . Next != nil { # pre = slow # slow = slow . Next # fast = fast . Next . Next # } # # node := & TreeNode { # Val : slow . Val , # } # # if slow == left { # return node # } # # if pre != nil { # pre . Next = nil # } # # node . Left = sortedListToBST ( left ) # node . Right = sortedListToBST ( slow . Next ) # return node
n := len ( graph ) # painted := make ([] int , n ) # # for i := 0 ; i < n ; i ++ { # if painted [ i ] == 0 && ! isOK ( i , 1 , painted , graph ) { # return false # } # } # # return true
l := f ( h . In ) # return func ( t * testing . T ) { # t . Parallel () # t . Logf (" STR ", h . In ) # for got , i := l . step (), 0 ; got . kind != itemEOF ; got , i = l . step (), i + 1 { # if i == len ( h . Out ) { # t . Errorf (" STR ", len ( h . Out )) # } # want := h . Out [ i ] # t . Logf (" STR ", want , got ) # if want . kind != got . kind { # t . Errorf (" STR ", want . kind , got . kind ) # } # if want . tok != got . tok { # t . Errorf (" STR ", want . tok , got . tok ) # } # } # }
t . Parallel () # for _ , tc := range testcases { # if result := MaxRectangleOfOnesAreaBrute ( tc . matrix ); result != tc . maxArea { # t . Errorf (" STR ", tc . maxArea , result ) # } # }
var tests = [] struct { # n int # pairs [] string # }{ # { 3 , [] string {" STR ", " STR ", " STR ", " STR ", " STR "}}, # } # # for _ , tt := range tests { # pairs := generateParenthesis ( tt . n ) # if reflect . DeepEqual ( pairs , tt . pairs ) == false { # t . Errorf (" STR ", tt . n , pairs , tt . pairs ) # } # }
return i .( int ) >= 0 && i .( int ) < len (* h )
t . Parallel () # for _ , tc := range testcases { # if result := MaxSubarraysBrute ( tc . input , tc . k ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
if num == 0 { # return " STR " # } # ret := " STR " # flag := false # if num < 0 { # flag = true # num = - num # } # for num > 0 { # a := num % 7 # ret = strconv . Itoa ( a ) + ret # num = num / 7 # } # if flag { # ret = " STR " + ret # } # return ret
return n > 0 && ( 0 == 1 1 6 2 2 6 1 4 6 7 % n )
included := struct {}{} # # var a , b int 6 4 # prod := big . NewInt ( 0 ) # # for a = 2 ; a <= 1 0 0 ; a ++ { # A := big . NewInt ( a ) # for b = 2 ; b <= 1 0 0 ; b ++ { # B := big . NewInt ( b ) # prod . Exp ( A , B , nil ) # # s [ prod . String ()] = included # } # } # # fmt . Println ( len ( s ))
n := len ( A ) # for i := 1 ; i < n ; i ++ { # for j := 0 ; j < n ; j ++ { # tmp := A [ i - 1 ][ j ] # if j > 0 { # tmp = min ( tmp , A [ i - 1 ][ j - 1 ]) # } # if j < n - 1 { # tmp = min ( tmp , A [ i - 1 ][ j + 1 ]) # } # A [ i ][ j ] += tmp # } # } # res := A [ n - 1 ][ 0 ] # for i := 1 ; i < n ; i ++ { # res = min ( res , A [ n - 1 ][ i ]) # } # return res
if k == 0 { # return " STR " # } # used , p , res := make ([] bool , n ), [] int {}, " STR " # findPermutation ( n , 0 , & k , p , & res , & used ) # return res
cntByte := func ( x int ) int { # cnt := 0 # for x > 0 { # x &= ( x - 1 ) # cnt ++ # } # return cnt # } # cnt := 0 # for i := L ; i <= R ; i ++ { # x := cntByte ( i ) # if x == 2 || x == 3 || x == 5 || x == 7 || # x == 1 1 || x == 1 3 || x == 1 7 || x == 1 9 { # cnt ++ # } # } # return cnt
var ret [][] string # var strs [] string # # strs = [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "} # ret = [][] string {{" STR ", " STR ", " STR "}, {" STR ", " STR "}, {" STR "}} # for k , str := range groupAnagrams ( strs ) { # for i , v := range str { # if ret [ k ][ i ] != v { # t . Fatalf (" STR ", ret ) # } # } # }
stack := make ([] int , 0 , len ( tokens )/ 2 + 1 ) # for _ , s := range tokens { # if s == " STR " || s == " STR " || s == " STR " || s == " STR " { # n := len ( stack ) # a , b := stack [ n - 2 ], stack [ n - 1 ] # stack [ n - 2 ] = calculate ( a , b , s ) # stack = stack [: n - 1 ] # } else { # tmp , _ := strconv . Atoi ( s ) # stack = append ( stack , tmp ) # } # } # return stack [ 0 ]
if len ( s ) != len ( t ) { # return false # } # # m 1 := make ([] int , 2 5 6 ) # m 2 := make ([] int , 2 5 6 ) # # for i := 0 ; i < len ( s ); i ++ { # if m 1 [ int ( s [ i ])] != m 2 [ int ( t [ i ])] { # return false # } # # m 1 [ int ( s [ i ])] = i + 1 # m 2 [ int ( t [ i ])] = i + 1 # } # # return true
rec := make ( map [ int ] int ) # rec [ 1 ] = 0 # # var ir func ( int ) int # ir = func ( i int ) int { # if n , ok := rec [ i ]; ok { # return n # } # # if i % 2 == 0 { # rec [ i ] = ir ( i / 2 ) + 1 # return rec [ i ] # } # # rec [ i ] = min ( ir ( i + 1 ), ir ( i - 1 )) + 1 # return rec [ i ] # } # # return ir ( n )
res := [] string {} # bs := [] byte {} # mode := false # for _ , s := range source { # n := len ( s ) # for i := 0 ; i < n ; i ++ { # if mode { # if s [ i ] == '*' && i < n - 1 && s [ i + 1 ] == '/' { # mode = false # i ++ # } # } else { # if s [ i ] == '/' && i < n - 1 { # if s [ i + 1 ] == '/' { # break # } else if s [ i + 1 ] == '*' { # mode = true # i ++ # continue # } # } # bs = append ( bs , s [ i ]) # } # } # if mode == false && len ( bs ) != 0 { # res = append ( res , string ( bs )) # bs = bs [: 0 ] # } # } # return res
var evictv interface {} # b . lock . Lock () # # if b . buffer [ b . pos ] != nil { # panic (" STR ") # } # # if ( b . start + b . size - 1 )% b . size == b . pos { # evictv = v # } else { # b . buffer [ b . pos ] = v # b . pos = ( b . pos + 1 ) % b . size # select { # case b . avail <- true : # default : # panic (" STR ") # } # } # b . lock . Unlock () # if evictv != nil && b . Evict != nil { # b . Evict ( evictv ) # return nil # } # return evictv
sort . Ints ( g ) # sort . Ints ( s ) # i := 0 # for j := 0 ; i < len ( g ) && j < len ( s ); j ++ { # if g [ i ] <= s [ j ] { # i ++ # } # if j == len ( s ) { # break # } # # } # return i
dict := make ( map [ byte ] int , 0 ) # for i := 0 ; i < len ( p ); i ++ { # dict [ p [ i ]]++ # } # # ans := make ([] int , 0 ) # left , right , count := 0 , 0 , len ( p ) # for right < len ( s ) { # if dict [ s [ right ]] >= 1 { # count -- # } # dict [ s [ right ]]-- # right ++ # # if 0 == count { # ans = append ( ans , left ) # } # # if right - left == len ( p ) { # if v , ok := dict [ s [ left ]]; ok && v >= 0 { # count ++ # } # dict [ s [ left ]]++ # left ++ # } # } # # return ans
if p := e . prev ; e . list != nil && p != & e . list . root { # return p # } # return nil
return & TimeMap { make ( map [ interface {}][]* TimestampedValue )}
tests := [...] testType { # { # in : [] int { 3 , 2 , 1 , 5 , 6 , 4 }, # k : 2 , # want : 5 , # }, { # in : [] int { 3 , 2 , 3 , 1 , 2 , 4 , 5 , 5 , 6 }, # k : 4 , # want : 4 , # }, # } # for _ , tt := range tests { # got := findKthLargest ( tt . in , tt . k ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
fileName := flag . String (" STR ", " STR ", " STR ") # logLevel := flag . Int (" STR ", 0 , " STR ") # isEnable := flag . Bool (" STR ", false , " STR ") # var num int # flag . IntVar (& num , " STR ", 2 5 , " STR ") # # flag . Parse () # fmt . Println (" STR ", * fileName ) # fmt . Println (" STR ", * logLevel ) # fmt . Println (" STR ", * isEnable ) # fmt . Println (" STR ", num ) # args := flag . Args () # if len ( args ) > 0 { # fmt . Println (" STR ") # for _ , v := range args { # fmt . Println ( v ) # } # } #
count := [ 1 0 0 0 0 ] int {} # count [ 0 ] = 1 # prefix , res := 0 , 0 # for _ , a := range A { # prefix = ( prefix + a % K + K ) % K # res += count [ prefix ] # count [ prefix ]++ # } # return res
v , _ := syscall . Getenv ( key ) # return v
left , right := 0 , len ( nums )- 1 # for left <= right { # mid := ( left + right ) / 2 # if nums [ mid ] == target { # return mid # } else if nums [ mid ] < target { # left = mid + 1 # } else { # if mid == 0 || nums [ mid - 1 ] < target { # return mid # } # # right = mid - 1 # } # } # # return len ( nums )
l , _ := strconv . Atoi ( L ) # r , _ := strconv . Atoi ( R ) # # li := sort . Search ( len ( palindromes ), func ( i int ) bool { # return l <= palindromes [ i ]* palindromes [ i ] # }) # # ri := sort . Search ( len ( palindromes ), func ( i int ) bool { # return r <= palindromes [ i ]* palindromes [ i ] # }) # # return ri - li
res := make ([] float 6 4 , 5 ) # res [ 0 ] = 2 5 5 # sum := 0 # for _ , val := range count { # sum += val # } # left , right := sum / 2 , sum / 2 # if ( sum % 2 ) == 0 { # right ++ # } # pre , mode := 0 , 0 # for i , val := range count { # if val > 0 { # if i < int ( res [ 0 ]) { # res [ 0 ] = float 6 4 ( i ) # } # res [ 1 ] = float 6 4 ( i ) # } # res [ 2 ] += float 6 4 ( i * val ) / float 6 4 ( sum ) # if pre < left && pre + val >= left { # res [ 3 ] += float 6 4 ( i ) / 2 . 0 # } # if pre < right && pre + val >= right { # res [ 3 ] += float 6 4 ( i ) / 2 . 0 # } # pre += val # # if val > mode { # mode = val # res [ 4 ] = float 6 4 ( i ) # } # } # return res
var s int # for _ , c := range m . cache { # s += c . ExpireNow ( now ) # } # return s
if root == nil { # return 0 # } # # queue := make ([]* TreeNode , 0 ) # queue = append ( queue , root ) # count := 0 # for len ( queue ) != 0 { # node := queue [ 0 ] # queue = queue [ 1 :] # count ++ # # if node . Left != nil { # queue = append ( queue , node . Left ) # } # # if node . Right != nil { # queue = append ( queue , node . Right ) # } # } # # return count
return [] int { searchFirstEqualElement ( nums , target ), searchLastEqualElement ( nums , target )} #
if this . queue . Len () > 0 { # return this . deque . Front (). Value .( int ) # } # return - 1
i := 1 # startTime := time . Now () # for { # fmt . Println (" STR ", i ) # var modulo [] int # # for j := 1 ; j <= 2 0 ; j ++ { # result := i % j # # fmt . Println (" STR ", result ) # # modulo = append ( modulo , result ) # } # # sum := 0 # # for _ , number := range modulo { # sum = sum + number # } # # if sum == 0 { # fmt . Println (" STR ", i ) # endTime := time . Now () # elapsed := endTime . Sub ( startTime ) # # fmt . Println (" STR ", elapsed ) # return # } # # i = i + 1 # }
if len ( a ) < 3 { # return 0 # } # res := 0 # # var i , j = 0 , 0 # for i < len ( a ) { # j = i + 2 # for j < len ( a ) && a [ j ]- a [ j - 1 ] == a [ j - 1 ]- a [ j - 2 ] { # j ++ # } # j -- # res += ( j - i - 1 ) * ( j - i ) / 2 # i = j # } # # return res
for i := 0 ; i < 5 ; i ++ { # wg . Add ( 1 ) # go printHello ( i ) # } # wg . Wait ()
if root == nil { # return nil # } # if root . Val == target { # return root # } # # if t := findTarget ( root . Left , target ); t != nil { # return t # } # if t := findTarget ( root . Right , target ); t != nil { # return t # } # return nil
t . Parallel () # for tcid , tc := range testcases { # if result := DoesExistSeqAdj ( tc . board , tc . word ); result != tc . expected { # t . Errorf (" STR ", tcid , tc . expected , result ) # } # }
if p . New == nil { # return nil # } # return p . New ()
ans := input [ I ][ J ] # # for i := I ; i < len ( input )- 1 ; i ++ { # copy ( input [ i ], input [ i + 1 ]) # } # # for i := 0 ; i < len ( input ); i ++ { # copy ( input [ i ][ J : len ( input )- 1 ], input [ i ][ J + 1 :]) # input [ i ] = input [ i ][: len ( input )- 1 ] # } # # return input [: len ( input )- 1 ], ans
sievebound := ( limit - 1 ) / 2 # sieve := make ([] bool , sievebound + 1 ) # crosslimit := int ( math . Sqrt ( float 6 4 ( limit ))- 1 ) / 2 # for i := 1 ; i <= crosslimit ; i ++ { # if ! sieve [ i ] { # for j := 2 * i * ( i + 1 ); j <= sievebound ; j += 2 * i + 1 { # sieve [ j ] = true # } # } # } # sum := 2 # for i := 1 ; i <= sievebound ; i ++ { # if ! sieve [ i ] { # sum += 2 * i + 1 # } # } # return sum
return uint 3 2 (( dev & 0 x 0 0 0 fff 0 0 ) >> 8 )
a := intSqrt ( c ) # for a >= 0 { # if isSquare ( c - a * a ) { # return true # } # a -- # } # return false
qs := [] question 9 1 4 { # # { # para 9 1 4 {[] int { 1 , 2 , 3 , 4 , 4 , 3 , 2 , 1 }}, # ans 9 1 4 { true }, # }, # # { # para 9 1 4 {[] int { 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 }}, # ans 9 1 4 { false }, # }, # # { # para 9 1 4 {[] int { 1 }}, # ans 9 1 4 { false }, # }, # # { # para 9 1 4 {[] int { 1 , 1 }}, # ans 9 1 4 { true }, # }, # # { # para 9 1 4 {[] int { 1 , 1 , 2 , 2 , 2 , 2 }}, # ans 9 1 4 { true }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 1 4 , q . para 9 1 4 # fmt . Printf (" STR ", p , hasGroupsSizeX ( p . one )) # } # fmt . Printf (" STR ")
primeCount := sort . Search ( 2 5 , func ( i int ) bool { return primes [ i ] > n }) # return factorial ( primeCount ) * factorial ( n - primeCount ) % 1 0 0 0 0 0 0 0 0 7
if n % 2 == 0 { # return 2 # } # return ( 2 * n * a ) % ( a * a )
ans := " STR " # length := float 3 2 ( bar ) # for i := float 3 2 ( 0 ); i < length ; i ++ { # if i / length < percent { # ans += " STR " # } else { # ans += " STR " # } # } # ans += " STR " # return ans
isDeadends := dealDeadends ( deadends ) # return bfs ( convert ( target ), isDeadends )
facts := [] int { # 1 , # 1 , # 2 , # 6 , # 2 4 , # 1 2 0 , # 7 2 0 , # 5 0 4 0 , # 4 0 3 2 0 , # 3 6 2 8 8 0 , # } # return facts [ n ]
return ( x 1 * x 2 ) + ( y 1 * y 2 )
tree := make ( map [* TreeNode ] int ) # tree [ root ] = 0 # var treeList []* TreeNode # treeList = append ( treeList , root ) # sum := root . Val # l := 0 # var sumList [] int # level := tree [ root ] # for len ( treeList ) > 0 { # r := treeList [ 0 ] # treeList = treeList [ 1 :] # # if tree [ r ] > level { # sumList = append ( sumList , sum ) # sum = 0 # level = tree [ r ] # } # sum += r . Val # # if r . Left != nil { # treeList = append ( treeList , r . Left ) # tree [ r . Left ] = level + 1 # } # # if r . Right != nil { # treeList = append ( treeList , r . Right ) # tree [ r . Right ] = level + 1 # } # # } # # sumList = append ( sumList , sum ) # max := sumList [ 0 ] # for i , j := range sumList { # if j > max { # max = j # l = i # } # } # return l + 1
for n := 0 ; n < 1 0 2 4 ; n ++ { # data := make ([] bool , n ) # # Line ( len ( data ), func ( start , end int ) { # for i := start ; i < end ; i ++ { # data [ i ] = ! data [ i ] # } # }) # # for _ , d := range data { # if ! d { # t . Errorf (" STR ", n ) # } # } # }
list := variable . Value .([] Variable ) # # return VariableListElementTypesAreHomogenous ( variableName , list )
return s . value . Type (). Name ()
print ( simpleSum (), " STR ", smarterSum ())
r . tasks = append ( r . tasks , tasks ...)
for i := 0 ; i < s . Cakes ; i ++ { # c := cake ( i ) # if s . Verbose { # fmt . Println (" STR ", c ) # } # work ( s . BakeTime , s . BakeStdDev ) # baked <- c # } # close ( baked )
res := make ([] int , people ) # # k := root ( candies ) # # candiesOf := func ( i int ) int { # c 0 := i + 1 # n := ( k - c 0 ) / people # cn := c 0 + n * people # return ( n + 1 ) * ( c 0 + cn ) / 2 # } # # for i := 0 ; i < people && i < k ; i ++ { # res [ i ] = candiesOf ( i ) # } # # res [ k % people ] += candies - k *( k + 1 )/ 2 # # return res
if num <= 0 { # return false # } # sum := 0 # for i := 1 ; i * i <= num ; i ++ { # if num % i == 0 { # sum += i # if i * i != num { # sum += num / i # } # } # } # return sum - num == num
i := 0 # u := len ( a ) - 1 # for i < u { # a [ i ], a [ u ] = a [ u ], a [ i ] # i , u = i + 1 , u - 1 # }
t . Parallel () # # for _ , tc := range testcases { # if s , e := LargestRangeBrute ( tc . nums ); s != tc . start || e != tc . end { # t . Errorf (" STR ", tc . start , tc . end , s , e ) # } # }
max 1 , max 2 , max 3 := 0 , - 1 , - 1 # for i , v := range nums { # if v > nums [ max 1 ] { # max 1 , max 2 , max 3 = i , max 1 , max 2 # } else if ( max 2 == - 1 || v > nums [ max 2 ]) && v != nums [ max 1 ] { # max 2 , max 3 = i , max 2 # } else if ( max 3 == - 1 || v > nums [ max 3 ]) && v != nums [ max 1 ] && v != nums [ max 2 ] { # max 3 = i # } # } # if max 3 == - 1 { # return nums [ max 1 ] # } # return nums [ max 3 ]
cases := [] struct { # Input Pos # String string # }{ # { # Pos { Line : 1 , Column : 1 }, # " STR ", # }, # { # Pos { Line : 2 , Column : 3 }, # " STR ", # }, # { # Pos { Line : 3 , Column : 2 , Filename : " STR "}, # " STR ", # }, # } # # for i , tc := range cases { # t . Run ( strconv . Itoa ( i ), func ( t * testing . T ) { # got := tc . Input . String () # if want , got := tc . String , got ; want != got { # t . Errorf (" STR ", tc . Input , got , want ) # } # }) # }
qs := [] question 5 9 { # # { # para 5 9 { 3 }, # ans 5 9 {[][] int {{ 1 , 2 , 3 }, { 8 , 9 , 4 }, { 7 , 6 , 5 }}}, # }, # # { # para 5 9 { 4 }, # ans 5 9 {[][] int {{ 1 , 2 , 3 , 4 }, { 1 2 , 1 3 , 1 4 , 5 }, { 1 1 , 1 6 , 1 5 , 6 }, { 1 0 , 9 , 8 , 7 }}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 9 , q . para 5 9 # fmt . Printf (" STR ", p , generateMatrix ( p . one )) # } # fmt . Printf (" STR ")
m 1 , m 2 := 0 , 1 # if len ( nums ) <= 1 { # return 0 # } # if nums [ 0 ] < nums [ 1 ] { # m 1 , m 2 = 1 , 0 # } # for i := 2 ; i < len ( nums ); i ++ { # if nums [ i ] > nums [ m 1 ] { # m 1 , m 2 = i , m 1 # } else if nums [ i ] > nums [ m 2 ] { # m 2 = i # } # } # if nums [ m 2 ]* 2 <= nums [ m 1 ] { # return m 1 # } # return - 1
ans := 0 # for i := 0 ; i < len ( grid ); i ++ { # for j := 0 ; j < len ( grid [ 0 ]); j ++ { # if grid [ i ][ j ] == 1 { # if i == 0 || grid [ i - 1 ][ j ] == 0 { # ans ++ # } # if i == len ( grid )- 1 || grid [ i + 1 ][ j ] == 0 { # ans ++ # } # if j == 0 || grid [ i ][ j - 1 ] == 0 { # ans ++ # } # if j == len ( grid [ 0 ])- 1 || grid [ i ][ j + 1 ] == 0 { # ans ++ # } # } # } # } # return ans
if n <= 1 { # return n # } # a , b , c := 1 , 1 , 0 # # for i := 2 ; i <= n ; i ++ { # c = a + b # a = b # b = c # } # return c
t . Parallel () # counter := make ([] int , 6 ) # for i := 0 ; i < 1 0 0 0 0 0 0 ; i ++ { # counter [ Rand 5 ()]++ # } # uniform := 1 0 0 0 0 0 0 / 5 # tolerance := 1 5 0 0 # for i := 1 ; i <= 5 ; i ++ { # if counter [ i ] < uniform - tolerance || counter [ i ] > uniform + tolerance { # t . Errorf (" STR ", uniform , counter [ i ]) # } # }
qs := [] question 1 4 6 4 { # # { # para 1 4 6 4 {[] int { 3 , 4 , 5 , 2 }}, # ans 1 4 6 4 { 1 2 }, # }, # # { # para 1 4 6 4 {[] int { 1 , 5 , 4 , 5 }}, # ans 1 4 6 4 { 1 6 }, # }, # # { # para 1 4 6 4 {[] int { 3 , 7 }}, # ans 1 4 6 4 { 1 2 }, # }, # # { # para 1 4 6 4 {[] int { 1 }}, # ans 1 4 6 4 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 4 6 4 , q . para 1 4 6 4 # fmt . Printf (" STR ", p ) # fmt . Printf (" STR ", maxProduct ( p . nums )) # } # fmt . Printf (" STR ")
if head == nil || head . Next == nil { # return head # } # # node , next := head , head . Next # for next != nil { # tmp := next . Next # next . Next = node # node = next # next = tmp # } # head . Next = nil # return node
t . Parallel () # # for _ , tc := range testcases { # result := ConstructAllPossibleBSTs ( tc . n ) # preorders := make ([][] int , 0 , len ( result )) # # for _ , root := range result { # preorders = append ( preorders , preorder ( root , [] int {})) # } # # if ! reflect . DeepEqual ( preorders , tc . preorders ) { # t . Errorf (" STR ", tc . preorders , preorders ) # } # }
children , err := AssetDir ( name ) # if err != nil { # return RestoreAsset ( dir , name ) # } # for _ , child := range children { # err = RestoreAssets ( dir , filepath . Join ( name , child )) # if err != nil { # return err # } # } # return nil
qs := [] question 4 7 6 { # # { # para 4 7 6 { 5 }, # ans 4 7 6 { 2 }, # }, # # { # para 4 7 6 { 1 }, # ans 4 7 6 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 7 6 , q . para 4 7 6 # fmt . Printf (" STR ", p , findComplement ( p . one )) # } # fmt . Printf (" STR ")
set := make ( map [ string ] bool ) # for a := 2 ; a <= 1 0 0 ; a ++ { # for b := 2 ; b <= 1 0 0 ; b ++ { # ba := big . NewInt ( int 6 4 ( a )) # bb := big . NewInt ( int 6 4 ( b )) # pow := ba . Exp ( ba , bb , big . NewInt ( 0 )) # set [ pow . String ()] = true # } # } # return len ( set )
random := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # array := make ([] int , random . Intn ( 1 0 0 - 1 0 )+ 1 0 ) # for i := range array { # array [ i ] = random . Intn ( 1 0 0 ) # } # SortArray ( array ) # for _ , value := range array { # result := InterpolationSearch ( array , value ) # if result == - 1 { # t . Fail () # } # }
return LoadUint 3 2 (& r . Reg )
n := 1 0 # res := 0 # i := 5 # for n / i >= 1 { # res = res + n / i # i = i * 5 # } # fmt . Println ( res )
go spinner ( 1 0 0 * time . Millisecond ) # const n = 4 5 # fibN := fib ( n ) # fmt . Printf (" STR ", n , fibN )
n := len ( ratings ) # if n == 0 { # return 0 # } # candys := make ([] int , n ) # for i := 1 ; i < n ; i ++ { # if ratings [ i ] > ratings [ i - 1 ] && candys [ i ] <= candys [ i - 1 ] { # candys [ i ] = candys [ i - 1 ] + 1 # } # } # for i := n - 1 ; i > 0 ; i -- { # if ratings [ i - 1 ] > ratings [ i ] && candys [ i - 1 ] <= candys [ i ] { # candys [ i - 1 ] = candys [ i ] + 1 # } # } # for _ , c := range candys { # n += c # } # return n
return e . Err
log . SetFlags ( log . Ldate | log . Ltime | log . Lshortfile )
if s . Size == s . Count { # return false # } # s . Items = append ( s . Items , item ) # s . Count ++ # return true
dists := make ([] int , 0 ) # dists = append ( dists , distSquare ( p 1 , p 2 )) # dists = append ( dists , distSquare ( p 1 , p 3 )) # dists = append ( dists , distSquare ( p 1 , p 4 )) # dists = append ( dists , distSquare ( p 2 , p 3 )) # dists = append ( dists , distSquare ( p 2 , p 4 )) # dists = append ( dists , distSquare ( p 3 , p 4 )) # sort . Ints ( dists ) # # if dists [ 0 ] == 0 { # return false # } # # if dists [ 0 ] != dists [ 1 ] || dists [ 1 ] != dists [ 2 ] || dists [ 2 ] != dists [ 3 ] || dists [ 3 ] != dists [ 0 ] { # return false # } # # if dists [ 4 ] != dists [ 5 ] { # return false # } # # return true
benchmarkFramework ( b , ShellSort )
if len ( os . Args ) == 1 { # flag . Usage () # os . Exit ( 1 ) # } # setRequestBody () # switch * dist { # case " STR ": # MasterNode () # case " STR ": # SlaveNode () # default : # SingleNode ( target ) # }
fmt . Println (" STR ", time . Now ()) # # t := time . Now () # fmt . Println ( t . Year ()) # fmt . Println ( t . Month ()) # fmt . Println ( t . Day ()) # fmt . Println ( t . Hour ()) # fmt . Println ( t . Minute ()) # fmt . Println ( t . Second ()) # fmt . Println ( t . Date ()) # fmt . Println ( t . Clock ()) # # fmt . Println ( t . Format (" STR "))
p , rank = make ( map [ int ] int ), make ( map [ int ] int ) # for _ , v := range nums { # p [ v ] = v # rank [ v ] = 1 # } # return p , rank
return len ( n . keyValue ) == 2 * n . t - 1
lookup := [ 1 2 ] int { 3 1 , 2 8 , 3 1 , 3 0 , 3 1 , 3 0 , 3 1 , 3 1 , 3 0 , 3 1 , 3 0 , 3 1 } # # endday = startday + lookup [ monthindex ] # endday %= 7 # # if monthindex == 1 && year % 4 == 0 { # if year % 1 0 0 == 0 && !( year % 4 0 0 == 0 ) { # return # } # return ( endday + 1 ) % 7 # } # # return
if len ( words ) < 2 { # return true # } # hash := make ( map [ byte ] int ) # for i := 0 ; i < len ( order ); i ++ { # hash [ order [ i ]] = i # } # for i := 0 ; i < len ( words )- 1 ; i ++ { # pointer , word , wordplus := 0 , words [ i ], words [ i + 1 ] # for pointer < len ( word ) && pointer < len ( wordplus ) { # if hash [ word [ pointer ]] > hash [ wordplus [ pointer ]] { # return false # } # if hash [ word [ pointer ]] < hash [ wordplus [ pointer ]] { # break # } else { # pointer = pointer + 1 # } # } # if pointer < len ( word ) && pointer >= len ( wordplus ) { # return false # } # } # return true
if x == 0 { # return true # } # # if x < 0 || x % 1 0 == 0 { # return false # } # # digits := [] int {} # y := x # for y > 0 { # digits = append ( digits , y % 1 0 ) # y = y / 1 0 # } # # newSum := 0 # for i := 0 ; i < len ( digits ); i ++ { # newSum = newSum * 1 0 + digits [ i ] # } # # if newSum == x { # return true # } # # return false #
frequency , maxFreq , smallest := map [ int ][] int {}, 0 , len ( nums ) # for i , num := range nums { # if _ , found := frequency [ num ]; ! found { # frequency [ num ] = [] int { 1 , i , i } # } else { # frequency [ num ][ 0 ]++ # frequency [ num ][ 2 ] = i # } # if maxFreq < frequency [ num ][ 0 ] { # maxFreq = frequency [ num ][ 0 ] # } # } # for _ , indices := range frequency { # if indices [ 0 ] == maxFreq { # if smallest > indices [ 2 ]- indices [ 1 ]+ 1 { # smallest = indices [ 2 ] - indices [ 1 ] + 1 # } # } # } # return smallest
const ( # cycles = 5 # res = 0 . 0 0 1 # size = 1 0 0 # nframes = 6 4 # delay = 8 # ) # freq := rand . Float 6 4 () * 3 . 0 # anim := gif . GIF { LoopCount : nframes } # phase := 0 . 0 # for i := 0 ; i < nframes ; i ++ { # rect := image . Rect ( 0 , 0 , 2 * size + 1 , 2 * size + 1 ) # img := image . NewPaletted ( rect , palette ) # for t := 0 . 0 ; t < cycles * 2 * math . Pi ; t += res { # x := math . Sin ( t ) # y := math . Sin ( t * freq + phase ) # img . SetColorIndex ( size + int ( x * size + 0 . 5 ), size + int ( y * size + 0 . 5 ), # blackIndex ) # } # phase += 0 . 1 # anim . Delay = append ( anim . Delay , delay ) # anim . Image = append ( anim . Image , img ) # } # gif . EncodeAll ( out , & anim )
(* h ) = append ((* h ), i .( int ))
t . Parallel () # for _ , tc := range testcases { # if a , b , c , err := PythagoreanTriplet ( tc . nums ); a != tc . a || b != tc . b || c != tc . c || err != tc . err { # t . Errorf (" STR ", tc . a , tc . b , tc . c , tc . err , a , b , c , err ) # } # }
numsMore := append ([] int {}, nums ...) # numsMore = append ( numsMore , nums ...) # result := [] int {} # for i := 0 ; i < len ( nums ); i ++ { # biggerResult := - 1 # for j := i + 1 ; j < i + len ( nums ); j ++ { # if numsMore [ j ] > nums [ i ] { # biggerResult = numsMore [ j ] # break # } # } # result = append ( result , biggerResult ) # } # return result
cases := [] struct { # name string # inputs string # expect int # }{ # {" STR ", " STR ", 3 }, # {" STR ", " STR ", 1 }, # {" STR ", " STR ", 3 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := lengthOfLongestSubstring ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
m := map [ int ] int {} # m [ 0 ] = - 1 # # zeros , ones , res := 0 , 0 , 0 # # for i , num := range nums { # if num == 0 { # zeros ++ # } else { # ones ++ # } # # if j , ok := m [ zeros - ones ]; ok { # res = max ( res , i - j ) # } else { # m [ zeros - ones ] = i # } # } # return res
var combinations [][] int # # var f func ([] int , int , int ) # f = func ( combination [] int , index int , target int ) { # if target == 0 { # n := make ([] int , len ( combination )) # copy ( n , combination ) # combinations = append ( combinations , n ) # return # } # # for i , c := range candidates [ index :] { # if c <= target { # f ( append ( combination , c ), index + i , target - c ) # } # } # } # # f ( nil , 0 , target ) # return combinations
if nil == nums || len ( nums ) < 1 { # return 0 # } # # preSum , maxSum := nums [ 0 ], nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # if preSum + nums [ i ] <= nums [ i ] { # preSum = nums [ i ] # } else { # preSum += nums [ i ] # } # if preSum > maxSum { # maxSum = preSum # } # } # return maxSum
return s . data [: s . top ]
t . Parallel () # for _ , tc := range testcases { # if index := IndexSortedRotated ( tc . sorted , tc . target ); index != tc . expected { # t . Errorf (" STR ", tc . expected , index ) # } # }
beersCmd := flag . NewFlagSet (" STR ", flag . ExitOnError ) # flag . Parse () # # if flag . NArg () == 0 { # log . Fatal (" STR ") # os . Exit ( 2 ) # } # # switch flag . Arg ( 0 ) { # case " STR ": # ID := beersCmd . String (" STR ", " STR ") # beersCmd . Parse ( os . Args [ 2 :]) # # if * ID != "" { # fmt . Println ( beers [* ID ]) # } else { # fmt . Println ( beers ) # } # }
defer rw . reportShutdown . Done () # # for { # select { # case <- rw . shutdown : # log . Printf (" STR ", rw . name ) # return # default : # rw . performWrite () # } # }
fmt . Println ( solveNQueens ( 4 ))
qs := [] question 3 9 7 { # # { # para 3 9 7 { 8 }, # ans 3 9 7 { 3 }, # }, # # { # para 3 9 7 { 7 }, # ans 3 9 7 { 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 9 7 , q . para 3 9 7 # fmt . Printf (" STR ", p , integerReplacement ( p . s )) # } # fmt . Printf (" STR ")
b := (* root ). Left # br := b . Right # b . Right = * root # (* root ). Left = br # (* root ). Height = height (* root ) # b . Height = height ( b ) # * root = b
return len ( n . numToIndices )
sum , p := 1 , 2 # for p * p <= n && n > 1 { # if n % p == 0 { # j := p * p # n /= p # for n % p == 0 { # j *= p # n /= p # } # sum *= j - 1 # sum /= p - 1 # } # if p == 2 { # p = 3 # } else { # p += 2 # } # } # if n > 1 { # sum *= n + 1 # } # return sum
if nil == p && nil == q { # return true # } else if nil == p || nil == q { # return false # } else if p . Val == q . Val { # return isSameTree ( p . Left , q . Left ) && isSameTree ( p . Right , q . Right ) # } else { # return false # }
tail := make ([] int , 2 6 ) # # total := func () int { # count := 0 # for i := 0 ; i < 2 6 ; i ++ { # count += tail [ i ] # } # return count % mod # } # # for _ , r := range S { # tail [ r -' a '] = total () + 1 # } # # return total ()
var evictv interface {} # b . lock . Lock () # # if b . buffer [ b . pos ] != nil { # panic (" STR ") # } # # b . buffer [ b . pos ] = v # b . pos = ( b . pos + 1 ) % b . size # if b . pos == b . start { # evictv = b . buffer [ b . start ] # b . buffer [ b . start ] = nil # b . start = ( b . start + 1 ) % b . size # } else { # select { # case b . avail <- true : # default : # panic (" STR ") # } # } # b . lock . Unlock () # if evictv != nil && b . Evict != nil { # b . Evict ( evictv ) # return nil # } # return evictv
for { # if r == q . IDs [ r ] { # break # } # q . IDs [ r ] = q . IDs [ q . IDs [ r ]] # r = q . IDs [ r ] # } # return r
if e := m . m [ key ].([] interface {})[ 0 ].(* list . Element ). Next (); e != nil { # return e . Value # } # return nil
cases := [] struct { # name string # nums [][] int # r , c int # expect [][] int # }{ # {" STR ", [][] int {{ 1 , 2 }, { 3 , 4 }}, 1 , 4 , [][] int {{ 1 , 2 , 3 , 4 }}}, # {" STR ", [][] int {{ 1 , 2 }, { 3 , 4 }}, 2 , 4 , [][] int {{ 1 , 2 }, { 3 , 4 }}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . nums , c . r , c . c ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . nums , c . r , c . c ) # } # }) # }
cur := node .(* bstElement ) # for cur . right != nil { # cur = cur . right # } # return cur
l := len ( s ) # flags := make ([] bool , l + 1 ) # flags [ 0 ] = true # for i := 1 ; i <= l ; i ++ { # for j := 0 ; j < i ; j ++ { # if flags [ j ] == true && contain ( s [ j : i ], wordDict ) { # flags [ i ] = true # break # } # } # } # return flags [ l ]
columns := make ([] int , n ) # totalNQueensHelper ( n , 0 , columns , & result ) # return result
return 0 , 0
hash := make ( map [ uint 8 ] int ) # cut := 0 # # for i := 0 ; i < len ( s ); i ++ { # fmt . Println ( s [ i ]) # if _ , ok := hash [ s [ i ]]; ! ok { # cut ++ # } # hash [ s [ i ]]++ # } # # res := "" # for i , j , c := 0 , 0 , 0 ; i < len ( s ); i ++ { # if hash [ s [ i ]] == 1 { # c ++ # } # hash [ s [ i ]]-- # for c == cut && hash [ s [ i ]] < 0 { # hash [ s [ j ]]++ # j ++ # } # if c == cut { # if res == "" || len ( res ) > i - j + 1 { # res = s [ j : i - j + 1 ] # } # } # # } # return res
baton := make ( chan int ) # # wg . Add ( 1 ) # # go Runner ( baton ) # # baton <- 1 # # wg . Wait ()
s . mtx . Lock () # defer s . mtx . Unlock () # if _ , ok := s . m [ id ]; ! ok { # return ErrNotFound # } # delete ( s . m , id ) # return nil
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", [][] int {{ 3 , 2 , 1 , 5 , 6 , 4 }, { 2 }}, 5 }, # {" STR ", [][] int {{ 3 , 2 , 3 , 1 , 2 , 4 , 5 , 5 , 6 }, { 4 }}, 4 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := findKthLargest ( c . inputs [ 0 ], c . inputs [ 1 ][ 0 ]) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if h . GetAlpha () >= 0 . 7 5 { # if h . Cap == 0 { # h . hashMap . Init ( defalutcap ) # } else { # h . Move ( h . Cap << 1 ) # } # }
tests := [...] testType { # { # a : 6 , # b : 2 , # want : " STR ", # }, # { # a : 2 , # b : 6 , # want : " STR ", # }, # { # a : 1 , # b : 2 , # want : " STR ", # }, # { # a : 4 , # b : 1 , # want : " STR ", # }, # } # for _ , tt := range tests { # got := strWithout 3 a 3 b ( tt . a , tt . b ) # if got != tt . want { # t . Fatalf (" STR ", tt . a , tt . b , got , tt . want ) # } # }
if len ( prices ) <= 1 { # return 0 # } # buy , sell := make ([] int , len ( prices )), make ([] int , len ( prices )) # for i := range buy { # buy [ i ] = math . MinInt 6 4 # } # buy [ 0 ] = - prices [ 0 ] # for i := 1 ; i < len ( prices ); i ++ { # buy [ i ] = max ( buy [ i - 1 ], sell [ i - 1 ]- prices [ i ]) # sell [ i ] = max ( sell [ i - 1 ], buy [ i - 1 ]+ prices [ i ]- fee ) # } # return sell [ len ( sell )- 1 ]
bt . t = t # bt . height = 0 # bt . bTreeIf = self # return bt
var largest int # for start , ends := range g { # if start > largest { # largest = start # } # for _ , node := range ends { # if node > largest { # largest = node # } # } # } # result := make ([][] int , largest + 1 ) # for i := range result { # result [ i ] = make ([] int , largest + 1 ) # } # visited := make ( map [ int ] struct {}, largest + 1 ) # result = transitiveClosure (- 1 , g , result , visited ) # return result
var sMap = map [ byte ] int {} # var tMap = map [ byte ] int {} # for i := 0 ; i < len ( s ); i ++ { # sMap [ s [ i ]]++ # tMap [ t [ i ]]++ # } # tMap [ t [ len ( s )]]++ # for b , cnt := range tMap { # if cnt - sMap [ b ] == 1 { # return b # } # } # # return 0
m := make ([] int , 2 ) # for i := 0 ; i < len ( bills ); i ++ { # switch bills [ i ] { # case 5 : # m [ 0 ]++ # break # case 1 0 : # if m [ 0 ] <= 0 { # return false # } # m [ 0 ]-- # m [ 1 ]++ # break # case 2 0 : # flag := false # if m [ 0 ] >= 1 && m [ 1 ] >= 1 { # flag = true # m [ 0 ]-- # m [ 1 ]-- # } else if m [ 0 ] >= 3 { # flag = true # m [ 0 ] -= 3 # } # if ! flag { # return false # } # break # } # # } # return true
wg . Add ( 2 ) # # go incCounter ( 1 ) # go incCounter ( 2 ) # # wg . Wait () # fmt . Printf (" STR ", counter )
sum = 0 # dfs ( root , false , false ) # return sum
max , l , r := 0 , 0 , len ( height )- 1 # for l < r { # # max = Max ( max , Min ( height [ l ], height [ r ])*( r - l )) # if height [ l ] < height [ r ] { # l ++ # } else { # r -- # } # } # return max
left := [][] int { # [] int { 3 , 2 , 4 }, # [] int { 8 , 7 , 3 , 1 }, # [] int { 8 , 1 }, # } # right := [][] int { # [] int { 5 , 8 , 5 }, # [] int { 2 , 1 }, # [] int { 1 , 2 }, # } # results := [][] int { # [] int { 8 , 0 , 0 , 1 }, # [] int { 0 , 9 , 3 , 1 }, # [] int { 9 , 3 }, # } # caseNum := 3 # for i := 0 ; i < caseNum ; i ++ { # l , r := generateNodeList ( left [ i ]), generateNodeList ( right [ i ]) # if ret := addTwoNumbers ( l , r ); ! equal ( ret , generateNodeList ( results [ i ])) { # t . Fatalf (" STR ", i , ret . Val ) # } # }
qs := [] question 4 2 4 { # # { # para 4 2 4 {" STR ", 1 }, # ans 4 2 4 { 4 }, # }, # # { # para 4 2 4 {" STR ", 2 }, # ans 4 2 4 { 4 }, # }, # # { # para 4 2 4 {" STR ", 0 }, # ans 4 2 4 { 3 }, # }, # # { # para 4 2 4 {" STR ", 1 }, # ans 4 2 4 { 2 }, # }, # # { # para 4 2 4 {" STR ", 2 }, # ans 4 2 4 { 5 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 2 4 , q . para 4 2 4 # fmt . Printf (" STR ", p , characterReplacement ( p . s , p . k )) # } # fmt . Printf (" STR ")
res := 0 # for i , row := range grid { # for j , col := range row { # if col == 0 { # continue # } # area := areaOfIsland ( grid , i , j ) # if area > res { # res = area # } # } # } # return res
slow := nums [ 0 ] # fast := nums [ slow ] # for slow != fast { # slow , fast = nums [ slow ], nums [ nums [ fast ]] # } # # slow = 0 # for slow != fast { # slow , fast = nums [ slow ], nums [ fast ] # } # return slow
var tests = [] struct { # n int # total int # }{ # { 5 , 2 }, # { 8 , 3 }, # { 0 , 0 }, # { 1 , 1 }, # } # # for _ , tt := range tests { # total := arrangeCoins ( tt . n ) # if total != tt . total { # t . Errorf (" STR ", tt . n , total , tt . total ) # } # }
for i := 0 ; ; i ++ { # for j := 0 ; ; j ++ { # if j == len ( needle ) { # return i # } # if i + j == len ( haystack ) { # return - 1 # } # if needle [ j ] != haystack [ i + j ] { # break # } # } # }
return 0 , "", 0 , false
var tests = [] struct { # s string # r string # }{ # {" STR ", " STR "}, # {" STR ", " STR "}, # {" STR ", " STR "}, # } # # for _ , tt := range tests { # r := reverseVowels ( tt . s ) # if r != tt . r { # t . Errorf (" STR ", tt . s , r , tt . r ) # } # }
if n == 0 { # return 0 # } # if n == 1 || n == 2 { # return n # } # step := [] int { 1 , 2 } # for i := 2 ; i < n ; i ++ { # step = append ( step , step [ i - 1 ]+ step [ i - 2 ]) # } # return step [ n - 1 ]
color := image [ sr ][ sc ] # if newColor == color { # return image # } # dfs 7 3 3 ( image , sr , sc , newColor ) # return image
if N <= 1 { # return N # } # n , m := 0 , 1 # for i := 2 ; i <= N ; i ++ { # n , m = m , n + m # } # return m
defer conn . Close () # # io . WriteString ( conn , " STR ") # # scanner := bufio . NewScanner ( conn ) # scanner . Scan () # user := User { # Name : scanner . Text (), # Output : make ( chan Message , 1 0 ), # } # chatServer . Join <- user # defer func () { # chatServer . Leave <- user # }() # # go func () { # for scanner . Scan () { # ln := scanner . Text () # chatServer . Input <- Message { user . Name , ln } # } # }() # # for msg := range user . Output { # if msg . Username != user . Name { # _ , err := io . WriteString ( conn , msg . Username +" STR "+ msg . Text +" STR ") # if err != nil { # break # } # } # }
p , err := build . Default . Import (" STR ", "", build . FindOnly ) # # if err != nil { # } # fname := filepath . Join ( p . Dir , " STR ") # f , _ := os . Open ( fname ) # defer f . Close () # # numbers := make ([] int , 0 ) # scanner := bufio . NewScanner ( f ) # # for scanner . Scan () { # s , _ := strconv . Atoi ( scanner . Text ()) # numbers = append ( numbers , s ) # } # # return numbers [ 0 : n ]
ans := 0 # for r := 0 ; r < len ( grid ); r ++ { # for c := 0 ; c < len ( grid [ 0 ]); c ++ { # if grid [ r ][ c ] == 1 { # ans += 4 # if r > 0 && grid [ r - 1 ][ c ] == 1 { # ans -= 2 # } # if c > 0 && grid [ r ][ c - 1 ] == 1 { # ans -= 2 # } # } # } # } # return ans
cases := [] struct { # name string # input 1 * ListNode # input 2 * ListNode # expect * ListNode # }{ # {" STR ", # & ListNode { Val : 2 , Next : & ListNode { Val : 4 , Next : & ListNode { Val : 3 , Next : nil }}}, # & ListNode { Val : 5 , Next : & ListNode { Val : 6 , Next : & ListNode { Val : 4 , Next : nil }}}, # & ListNode { Val : 7 , Next : & ListNode { Val : 0 , Next : & ListNode { Val : 8 , Next : nil }}}}, # } # # for i , c := range cases { # t . Run ( c . name + strconv . Itoa ( i ), func ( t * testing . T ) { # got := addTwoNumbers ( c . input 1 , c . input 2 ) # if ! isEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 ) # } # }) # }
var tests = [] struct { # s , t string # isomorphic bool # }{ # {" STR ", " STR ", true }, # {" STR ", " STR ", false }, # {" STR ", " STR ", false }, # {" STR ", " STR ", true }, # {" STR ", " STR ", false }, # } # # for _ , tt := range tests { # isomorphic := isIsomorphic ( tt . s , tt . t ) # if isomorphic != tt . isomorphic { # t . Errorf (" STR ", tt . s , tt . t , isomorphic , tt . isomorphic ) # } # }
if root == nil { # return nil # } # if root . Val == val { # return root # } # if root . Val > val { # return searchBST ( root . Left , val ) # } else { # return searchBST ( root . Right , val ) # }
err := ioutil . WriteFile ( path , [] byte ( content ), 0 7 5 5 ) # if err != nil { # log . Fatalln ( err . Error ()) # }
var tests = [] struct { # tree * TreeNode # subtrees []* TreeNode # }{ # { newTree ( 1 , 2 , 3 , 4 , nil , 2 , 4 , nil , nil , 4 ), []* TreeNode { newTree ( 4 ), newTree ( 2 , 4 )}}, # { newTree ( 0 , 0 , 0 , 0 , nil , nil , 0 , 0 , 0 , 0 , 0 ), []* TreeNode { newTree ( 0 ), newTree ( 0 , 0 , 0 )}}, # } # # for _ , tt := range tests { # subtrees := findDuplicateSubtrees ( tt . tree ) # if reflect . DeepEqual ( subtrees , tt . subtrees ) == false { # t . Errorf (" STR ", tt . tree , subtrees , tt . subtrees ) # } # }
num := 0 # st := [] int {} # var sign byte # sign = '+' # for i := 0 ; i < len ( s ); i ++ { # if unicode . IsDigit ( rune ( s [ i ])) { # num = num * 1 0 + int ( s [ i ]-' 0 ') # } # if s [ i ] != ' ' && ! unicode . IsDigit ( rune ( s [ i ])) || i == len ( s )- 1 { # switch sign { # case '+': # case '-': # num = - num # case '*': # num = st [ len ( st )- 1 ] * num # st = st [: len ( st )- 1 ] # case '/': # num = st [ len ( st )- 1 ] / num # st = st [: len ( st )- 1 ] # } # sign = s [ i ] # st = append ( st , num ) # num = 0 # } # } # for _ , v := range st { # num += v # } # return num
alphabet := make ([] int , 2 6 ) # sBytes := [] byte ( s ) # tBytes := [] byte ( t ) # if len ( sBytes ) != len ( tBytes ) { # return false # } # for i := 0 ; i < len ( sBytes ); i ++ { # alphabet [ sBytes [ i ]-' a ']++ # } # for i := 0 ; i < len ( tBytes ); i ++ { # alphabet [ tBytes [ i ]-' a ']-- # } # for i := 0 ; i < 2 6 ; i ++ { # if alphabet [ i ] != 0 { # return false # } # } # return true
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 2 , 6 , 4 , 8 , 1 0 , 9 , 1 5 }, 5 }, # {" STR ", [] int { 1 , 2 , 3 , 3 , 3 }, 0 }, # {" STR ", [] int { 1 }, 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
var numMap = map [ int ][] int {} # for idx , num := range nums { # numMap [ num ] = append ( numMap [ num ], idx ) # } # # var indexMap = [] int {} # # for i := 0 ; i < len ( nums ); i ++ { # cur := nums [ i ] # left := target - cur # if cur == left { # if len ( numMap [ cur ]) != 2 { # continue # } # indexMap = numMap [ cur ] # break # } else if _ , ok := numMap [ left ]; ok { # indexMap = [] int { i , numMap [ left ][ 0 ]} # break # } # } # # return indexMap
pst := Position { x : 0 , y : 0 } # # for _ , v := range moves { # if ' R ' == v { # pst . x ++ # } else if ' L ' == v { # pst . x -- # } else if ' U ' == v { # pst . y ++ # } else if ' D ' == v { # pst . y -- # } else { # continue # } # } # # if 0 == pst . x && pst . x == pst . y { # return true # } # return false
if * root == nil { # * root = & Node { # Key : key , # Height : 1 , # } # return # } # if (* root ). Key < key { # Insert (&(* root ). Right , key ) # } else if (* root ). Key > key { # Insert (&(* root ). Left , key ) # } # # (* root ). Height = height (* root ) # # bFactor := balanceFactor (* root ) # # if bFactor == 2 { # bFactor = balanceFactor ((* root ). Left ) # if bFactor == 1 { # llRotation ( root ) # } else if bFactor == - 1 { # lrRotation ( root ) # } # } else if bFactor == - 2 { # bFactor = balanceFactor ((* root ). Right ) # if bFactor == 1 { # rlRotation ( root ) # } else if bFactor == - 1 { # rrRotation ( root ) # } # }
n , farset := len ( nums ), 0 # for i := 0 ; i < n ; i ++ { # if farset < i { # return false # } # farset = Max ( i + nums [ i ], farset ) # } # return true
sort . Ints ( nums ) # sum := 0 # for i := 0 ; i < 4 ; i ++ { # sum = sum * 1 0 + nums [ i ] # } # return ! bad [ sum ]
i , l := 0 , len ( A ) # for j := 1 ; j < l ; j += 2 { # if A [ j ]& 1 == 0 { # for A [ i ]& 1 == 0 { # i += 2 # } # A [ i ], A [ j ] = A [ j ], A [ i ] # } # } # return A
count := 0 # for _ , i := range data { # if count == 0 { # if i >> 3 == 3 0 { # count = 3 # } else if i >> 4 == 1 4 { # count = 2 # } else if i >> 5 == 6 { # count = 1 # } else if i >> 7 > 0 { # return false # } # } else { # if i >> 6 != 2 { # return false # } # count -- # } # } # return count == 0
qs := [] question 4 { # # { # para 4 {[] int { 1 , 3 }, [] int { 2 }}, # ans 4 { 2 . 0 }, # }, # # { # para 4 {[] int { 1 , 2 }, [] int { 3 , 4 }}, # ans 4 { 2 . 5 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 , q . para 4 # fmt . Printf (" STR ", p , findMedianSortedArrays ( p . nums 1 , p . nums 2 )) # } # fmt . Printf (" STR ")
record := make ( map [ int ] int ) # res := make ([] int , 0 ) # for _ , num := range nums 1 { # if _ , ok := record [ num ]; ! ok { # record [ num ] = 1 # } else { # record [ num ]++ # } # } # # for _ , num := range nums 2 { # if count , ok := record [ num ]; ok && count > 0 { # res = append ( res , num ) # record [ num ]-- # } # } # return res
s = strings . TrimRight ( s , " STR ") # return len ( s ) - strings . LastIndex ( s , " STR ") - 1
maxNum , sum := 0 , 0 # for _ , num := range nums { # sum += num # if num > maxNum { # maxNum = num # } # } # if m == 1 { # return sum # } # low , high := maxNum , sum # for low < high { # mid := low + ( high - low )>> 1 # if calSum ( mid , m , nums ) { # high = mid # } else { # low = mid + 1 # } # } # return low
b . StopTimer () # for i := 0 ; i < 1 2 8 ; i ++ { # hmap . HashInsert ( rand . Intn ( 1 2 8 ), i ) # } # b . StartTimer () # for i := 0 ; i < b . N ; i ++ { # hmap . HashGet ( rand . Intn ( 1 2 8 )) # }
maxans := 0 # stk := Stack {} # # stk . Push (- 1 ) # # for i := 0 ; i < len ( s ); i ++ { # if s [ i ] == " STR " { # stk . Push ( i ) # } else { # stk . Pop () # if stk . IsEmpty () { # stk . Push ( i ) # } else { # maxans = Max ( maxans , i - stk . Top ().( int )) # } # } # } # return maxans
c := FToC ( 2 1 2 . 0 ) # fmt . Println ( c . String ()) # fmt . Printf (" STR ", c ) # fmt . Printf (" STR ", c ) # fmt . Println ( c ) # fmt . Printf (" STR ", c ) # fmt . Println ( float 6 4 ( c )) #
t . Parallel () # for _ , tc := range testcases { # if result := MultiplicationTableBrute ( tc . N , tc . X ); result != tc . expected { # t . Errorf (" STR ", tc . N , tc . X , result , tc . expected ) # } # }
var tests = [] struct { # integer int # palindrome bool # }{ # { 1 2 2 1 , true }, # { 1 2 1 , true }, # {- 1 2 1 , false }, # { 1 0 , false }, # } # # for _ , tt := range tests { # palindrome := isPalindrome ( tt . integer ) # if palindrome != tt . palindrome { # t . Errorf (" STR ", tt . integer , palindrome , tt . palindrome ) # } # }
var multiple uint 6 4 = 1 # for i := 0 ; i < len ( window ); i ++ { # digit , _ := strconv . Atoi ( string ( window [ i ])) # multiple *= uint 6 4 ( digit ) # } # return multiple
nums := [] int { 1 , 1 , 2 } # newLength := removeDuplicates ( nums ) # if newLength != 2 { # t . Fail () # } # if ! reflect . DeepEqual ( nums [: newLength ], [] int { 1 , 2 }) { # t . Fail () # }
if k <= 1 { # return 0 # } # # var ( # n = len ( nums ) # l , r int # res int # prod = 1 # ) # # for l < n { # if r < n && prod * nums [ r ] < k { # prod *= nums [ r ] # r ++ # } else if l == r { # l ++ # r ++ # } else { # res += r - l # prod /= nums [ l ] # l ++ # } # } # return res
return P . point 1 . toString () + " STR " + P . point 2 . toString () + " STR " + strconv . FormatFloat ( P . distance , " STR ", - 1 , 6 4 )
t := [] byte ( s ) # m := make ( map [ byte ] bool ) # m [' o '], m [' e '], m [' a '], m [' i '], m [' u '] = true , true , true , true , true # m [' O '], m [' E '], m [' A '], m [' I '], m [' U '] = true , true , true , true , true # for i , j := 0 , len ( t )- 1 ; i < j ; i , j = i + 1 , j - 1 { # for i < j && ! m [ t [ i ]] { # i ++ # } # for j > i && ! m [ t [ j ]] { # j -- # } # if i >= j { # break # } # t [ i ], t [ j ] = t [ j ], t [ i ] # } # return string ( t ) #
defer func () { # err := recover () # if err != nil { # fmt . Printf (" STR ", err ) # t . Error (" STR ") # } # }() # a := & Animal { # Name : " STR ", # Age : 4 , # } # _ = Map (& a ) # # b := & a # _ = Map (& b ) # # c := & b # _ = Map (& c )
cases := [] struct { # name string # inputs [] int # expect [] int # }{ # {" STR ", [] int { 1 7 , 1 8 , 5 , 4 , 6 , 1 }, [] int { 1 8 , 6 , 6 , 6 , 1 , - 1 }}, # {" STR ", [] int {}, [] int {}}, # {" STR ", [] int { 1 0 0 }, [] int {- 1 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
a , b , c , dp := 0 , 0 , 0 , make ([] int , n ) # dp [ 0 ] = 1 # # for i := 1 ; i < n ; i ++ { # n 2 , n 3 , n 5 := dp [ a ]* 2 , dp [ b ]* 3 , dp [ c ]* 5 # dp [ i ] = min ( min ( n 2 , n 3 ), n 5 ) # if dp [ i ] == n 2 { # a ++ # } # if dp [ i ] == n 3 { # b ++ # } # if dp [ i ] == n 5 { # c ++ # } # } # return dp [ n - 1 ]
sourceURL := flag . String (" STR ", " STR ", " STR ") # interruptSystem := flag . String (" STR ", " STR ", " STR ") # flag . Parse () # if flag . NArg () != 2 { # fmt . Fprintln ( os . Stderr , " STR ") # flag . PrintDefaults () # return # } # indir := flag . Arg ( 0 ) # outdir := flag . Arg ( 1 ) # err := generate ( indir , outdir , * sourceURL , * interruptSystem ) # if err != nil { # fmt . Fprintln ( os . Stderr , err ) # os . Exit ( 1 ) # }
if n <= 0 { # return 0 # } # # x := math . Sqrt ( 2 * float 6 4 ( n )+ 0 . 2 5 ) - 0 . 5 # return int ( x )
if len ( prices ) < 1 { # return 0 # } # min , maxProfit := prices [ 0 ], 0 # for i := 1 ; i < len ( prices ); i ++ { # if prices [ i ]- min > maxProfit { # maxProfit = prices [ i ] - min # } # if prices [ i ] < min { # min = prices [ i ] # } # } # return maxProfit
number := 1 0 # # b . ResetTimer () # # for i := 0 ; i < b . N ; i ++ { # fmt . Sprintf (" STR ", number ) # }
num *= math . Pow ( 1 0 , digits ) # # temp := float 6 4 ( int 6 4 ( num )) # # if num - temp > . 5 { # temp ++ # } # # num = temp * math . Pow ( 1 0 , - 1 * digits ) # # return num
counts := map [ string ] int {} # scanner := bufio . NewScanner ( rdr ) # scanner . Split ( bufio . ScanWords ) # for scanner . Scan () { # word := scanner . Text () # word = strings . ToLower ( word ) # counts [ word ]++ # } # return counts
if steps < 0 { # return 0 # } else if steps == 0 { # return 1 # } # sum := 0 # for _ , stride := range strides { # sum += UniqueClimbs ( steps - stride , strides ) # } # return sum
total := 1 # rounds := ( 1 0 0 1 - 1 ) / 2 # sideLength := 1 # lastMax := 1 # for i := 0 ; i < rounds ; i ++ { # sideLength += 2 # for j := 0 ; j < 4 ; j ++ { # lastMax += sideLength - 1 # total += lastMax # } # } # println ( total )
(* h ), i = (* h )[: len (* h )- 1 ], (* h )[ len (* h )- 1 ] # return
n := len ( nums ) # # if 0 == n { # return n # } # # var ( # res = 1 # i = 1 # index = nextDifferentCharacterIndex ( nums , 1 ) # ) # # for index < n { # res ++ # nums [ i ] = nums [ index ] # i ++ # index = nextDifferentCharacterIndex ( nums , index + 1 ) # } # return res
var res [] string # words := strings . Split ( text , " STR ") # if len ( words ) < 3 { # return [] string {} # } # for i := 2 ; i < len ( words ); i ++ { # if words [ i - 2 ] == first && words [ i - 1 ] == second { # res = append ( res , words [ i ]) # } # } # return res
sum := 0 # for i := 0 ; i < 6 ; i ++ { # sum += <- ch # time . Sleep ( time . Microsecond ) # } # println (" STR ", sum )
n -- # return n *( n + 1 )/ 2 + 1
head , length := l , 1 # for l . Next != nil { # l = l . Next # length ++ # } # l . Next = head # return head , length
subArray := strings . Split ( s , " STR ") # for i := len ( subArray ) - 1 ; i >= 0 ; i -- { # length := len ( subArray [ i ]) # if length > 0 { # return length # } # } # return 0
var route [] int # var stack [] int # startIdx := GetIdx ( start , nodes ) # stack = append ( stack , startIdx ) # for len ( stack ) > 0 { # now := stack [ len ( stack )- 1 ] # route = append ( route , nodes [ now ]) # if len ( stack ) > 1 { # stack = stack [: len ( stack )- 1 ] # } else { # stack = stack [: len ( stack )- 1 ] # } # for i := 0 ; i < len ( edges [ now ]); i ++ { # if edges [ now ][ i ] && NotExist ( i , stack ) { # stack = append ( stack , i ) # } # edges [ now ][ i ] = false # edges [ i ][ now ] = false # } # if route [ len ( route )- 1 ] == end { # return route , true # } # } # return nil , false
fmt . Println ( maxProfit ([] int { 7 , 1 , 5 , 3 , 6 , 4 })) # fmt . Println ( maxProfit ([] int { 7 , 6 , 4 , 3 , 1 })) # fmt . Println ( maxProfit ([] int { 1 , 2 }))
if x > y { # return x # } # return y
last , first , second = nil , nil , nil # dfs ( root ) # first . Val , second . Val = second . Val , first . Val
l := len ( nums ) # if l == 0 { # return 0 # } # n := l / 2 + l % 2 # numMap := make ( map [ int ] int ) # for _ , v := range nums { # if _ , ok := numMap [ v ]; ok { # numMap [ v ]++ # } else { # numMap [ v ] = 1 # } # if numMap [ v ] >= n { # return v # } # } # return - 1
if root != nil { # root . Left , root . Right = invertTree ( root . Right ), invertTree ( root . Left ) # } # return root
qs := [] question 9 9 5 { # # { # para 9 9 5 {[] int { 0 , 1 , 0 }, 1 }, # ans 9 9 5 { 2 }, # }, # # { # para 9 9 5 {[] int { 1 , 1 , 0 }, 2 }, # ans 9 9 5 {- 1 }, # }, # # { # para 9 9 5 {[] int { 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 }, 3 }, # ans 9 9 5 { 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 9 5 , q . para 9 9 5 # fmt . Printf (" STR ", p , minKBitFlips ( p . one , p . k )) # } # fmt . Printf (" STR ")
a , err := Asset ( name ) # if ( err != nil ) { # panic (" STR " + name + " STR " + err . Error ()) # } # # return a
m := make ( map [ int ] bool , len ( G )) # for _ , g := range G { # m [ g ] = true # } # res := 0 # for head != nil { # if m [ head . Val ] && ( head . Next == nil || ! m [ head . Next . Val ]) { # res ++ # } # head = head . Next # } # return res
if root == nil { # return false # } # # if root . Left == nil && root . Right == nil { # return root . Val == sum # } # return hasPathSum ( root . Left , sum - root . Val ) || hasPathSum ( root . Right , sum - root . Val )
var tests = [] struct { # numRows int # triangle [][] int # }{ # { # 5 , # [][] int { # { 1 }, # { 1 , 1 }, # { 1 , 2 , 1 }, # { 1 , 3 , 3 , 1 }, # { 1 , 4 , 6 , 4 , 1 }, # }, # }, # } # # for _ , tt := range tests { # triangle := generate ( tt . numRows ) # if reflect . DeepEqual ( triangle , tt . triangle ) == false { # t . Errorf (" STR ", tt . numRows , triangle , tt . triangle ) # } # }
qs := [] question 7 6 2 { # # { # para 7 6 2 { 6 , 1 0 }, # ans 7 6 2 { 4 }, # }, # # { # para 7 6 2 { 1 0 , 1 5 }, # ans 7 6 2 { 5 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 6 2 , q . para 7 6 2 # fmt . Printf (" STR ", p , countPrimeSetBits ( p . l , p . r )) # } # fmt . Printf (" STR ")
if nil == sequence || begin >= end { # return false # } # # root := sequence [ end ] # # i := begin # for ; i < end ; i ++ { # if sequence [ i ] > root { # break # } # } # j := i # for ; j < end ; j ++ { # if sequence [ j ] < root { # return false # } # } # left := true # if 1 < i - begin { # left = verifySquenceOfBST ( sequence , begin , i - 1 ) # } # right := true # if 1 < end - i { # right = verifySquenceOfBST ( sequence , i , end - 1 ) # } # # return left && right
fileBuf , err := ioutil . ReadFile (" STR ") # if err != nil { # panic ( err ) # } # fileStr := string ( fileBuf ) # names := strings . SplitN ( fileStr , " STR ", - 1 ) # for i := range names { # names [ i ] = strings . SplitN ( names [ i ], " STR ", - 1 )[ 1 ] # } # sort . Strings ( names ) # sum := 0 # for i , v := range names { # sum += alphabeticalValue ( v ) * ( i + 1 ) # } # return sum
l := distance ( r . x 1 , r . y 1 , r . x 1 , r . y 2 ) # w := distance ( r . x 1 , r . y 1 , r . x 2 , r . y 1 ) # return l * w
if len ( s ) == 0 { # return 0 # } # count := 0 # odd := 0 # m := make ( map [ byte ] int ) # for i := 0 ; i < len ( s ); i ++ { # m [ s [ i ]]++ # } # for _ , b := range m { # count += b / 2 # if b % 2 != 0 { # odd = 1 # } # } # return 2 * count + odd
if root == nil { # return nil # } # if root . Left == nil && root . Right == nil { # return [] string { strconv . Itoa ( root . Val )} # } # # v := strconv . Itoa ( root . Val ) # paths := append ( binaryTreePaths ( root . Left ), binaryTreePaths ( root . Right )...) # # var b strings . Builder # for i , path := range paths { # b . Reset () # b . WriteString ( v ) # b . WriteString (" STR ") # b . WriteString ( path ) # # paths [ i ] = b . String () # } # return paths
return new ( delete ). init ( cost )
n := & Node {} # n . children = make ( map [ rune ]* Node ) # n . isLeaf = false # return n
for { # if p == q . IDs [ p ] { # return p # } else { # return q . RootRec ( q . IDs [ p ]) # } # }
var combinations [] string # if 0 == len ( digits ) { # return combinations # } # if 1 == len ( digits ) { # return mapping [ digits [ 0 ]] # } # for _ , letter := range mapping [ digits [ 0 ]] { # for _ , suffix := range letterCombinations ( digits [ 1 :]) { # combination := string ( letter ) + suffix # combinations = append ( combinations , combination ) # } # } # return combinations
var record [][] int # traversal ( root , 0 , & record ) # var reversed [][] int # for i := len ( record ) - 1 ; i >= 0 ; i -- { # reversed = append ( reversed , record [ i ]) # } # return reversed
tests := [...] testType { # { # in : [] int { 0 , 1 , 2 , 3 , 4 }, # index : [] int { 0 , 1 , 2 , 2 , 1 }, # want : [] int { 0 , 4 , 1 , 3 , 2 }, # }, # { # in : [] int { 1 , 2 , 3 , 4 , 0 }, # index : [] int { 0 , 1 , 2 , 3 , 0 }, # want : [] int { 0 , 1 , 2 , 3 , 4 }, # }, # { # in : [] int { 1 }, # index : [] int { 0 }, # want : [] int { 1 }, # }, # } # for _ , tt := range tests { # got := createTargetArray ( tt . in , tt . index ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
xor := 0 # for i , n := range nums { # xor ^= i ^ n # } # return xor ^ len ( nums )
lo , hi := 0 , len ( nums )- 1 # for lo < hi { # mid := partition ( nums , lo , hi ) # if k - 1 < mid { # hi = mid - 1 # } else if k - 1 > mid { # lo = mid + 1 # } else { # break # } # } # return nums [ k - 1 ]
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", [][] int { # { 0 , 0 , 0 }, # { 0 , 1 , 0 }, # { 0 , 0 , 0 }, # }, 2 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := uniquePathsWithObstacles ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
ctx := context . Background () # ctx , cancel := context . WithTimeout ( ctx , 3 * time . Second ) # defer cancel () # req , err := http . NewRequest ( http . MethodGet , " http : ) # if err != nil { # log . Fatal ( err ) # } # req = req . WithContext ( ctx ) # resp , err := http . DefaultClient . Do ( req ) # if err != nil { # log . Fatal ( err ) # } # defer resp . Body . Close () # if resp . StatusCode != http . StatusOK { # log . Fatal ( resp . Status ) # } # io . Copy ( os . Stdout , resp . Body )
var tests = [] struct { # num int # isPerfect bool # }{ # { 1 6 , true }, # { 1 4 , false }, # { 0 , true }, # } # # for _ , tt := range tests { # isPerfect := isPerfectSquare ( tt . num ) # if isPerfect != tt . isPerfect { # t . Errorf (" STR ", tt . num , isPerfect , tt . isPerfect ) # } # }
board := make ([][] string , x ) # for i := range board { # board [ i ] = make ([] string , x ) # for j := range board [ i ] { # board [ i ][ j ] = " STR "; # } # } # res := make ([][] string , 0 ) # helper ( board , & res , 0 ); # return res
m , n := len ( A [ 0 ]), len ( A ) # B := make ([][] int , m ) # for i := 0 ; i < m ; i ++ { # B [ i ] = make ([] int , n ) # } # for i , row := range A { # for j , v := range row { # B [ j ][ i ] = v # } # } # return B
jstr := [] byte ( J ) # sstr := [] byte ( S ) # m := make ( map [ byte ] bool ) # for _ , v := range jstr { # m [ v ] = true # } # num := 0 # for _ , v := range sstr { # if _ , ok := m [ v ]; ok { # num ++ # } # } # return num
t . Parallel () # for tcid , tc := range testcases { # if result := CouldBeNonDecreasingByOneChange ( tc . input ); result != tc . expected { # t . Errorf (" STR ", tcid , tc . expected , result ) # } # }
t . Parallel () # for _ , tc := range testcases { # if sum , level := MinimumSumLevel ( tc . tree ); sum != tc . minSum && level != tc . minLevel { # t . Errorf (" STR ", tc . minSum , tc . minLevel , sum , level ) # } # }
t . Parallel () # for tcid , tc := range testcases { # if result := Arbitrage ( tc . rates ); result != tc . arbitragePossible { # t . Errorf (" STR ", tcid , tc . arbitragePossible , result ) # } # }
max := root . Val # # var dfs func (* TreeNode ) int # dfs = func ( root * TreeNode ) int { # if root == nil { # return 0 # } # # l , r := dfs ( root . Left ), dfs ( root . Right ) # if l < 0 { # l = 0 # } # if r < 0 { # r = 0 # } # sum := l + root . Val + r # if sum > max { # max = sum # } # if l > r { # return l + root . Val # } # return root . Val + r # } # dfs ( root ) # return max
return len ( ListQueue )
var rev * ListNode # slow , fast := head , head # for fast != nil && fast . Next != nil { # rev = & ListNode { Val : slow . Val , Next : rev } # slow = slow . Next # fast = fast . Next . Next # } # if fast != nil { # slow = slow . Next # } # for rev != nil && rev . Val == slow . Val { # slow = slow . Next # rev = rev . Next # } # return rev == nil
maxVal := nums [ 0 ]; # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] > maxVal { # maxVal = nums [ i ]; # } # } # return maxVal ;
src , err := os . Open (" STR ") # if err != nil { # panic ( err ) # } # defer src . Close () # # dst , err := os . Create (" STR ") # if err != nil { # panic ( err ) # } # defer dst . Close () # # rows , err := csv . NewReader ( src ). ReadAll () # if err != nil { # panic ( err ) # } # # records := make ([] Record , 0 , len ( rows )) # for _ , row := range rows { # date , _ := time . Parse (" STR ", row [ 0 ]) # open , _ := strconv . ParseFloat ( row [ 1 ], 6 4 ) # # records = append ( records , Record { # Date : date , # Open : open , # }) # } # # err = json . NewEncoder ( dst ). Encode ( records ) # if err != nil { # panic ( err ) # } #
nodes := []* TreeNode { root } # maxDepth := - 1 # val := 0 # for depth := 0 ; len ( nodes ) > 0 ; depth ++ { # copy := nodes [:] # nodes = []* TreeNode {} # for _ , node := range copy { # if depth > maxDepth { # maxDepth = depth # val = node . Val # } # if nil != node . Left { # nodes = append ( nodes , node . Left ) # } # if nil != node . Right { # nodes = append ( nodes , node . Right ) # } # } # } # return val
if root . Left == nil { # return root . Key # } # return min ( root . Left )
var result [ 4 ] int # # result [ 0 ] = A [ 0 ]* B [ 0 ] + A [ 1 ]* B [ 2 ] # result [ 1 ] = A [ 0 ]* B [ 1 ] + A [ 1 ]* B [ 3 ] # result [ 2 ] = A [ 2 ]* B [ 0 ] + A [ 3 ]* B [ 2 ] # result [ 3 ] = A [ 2 ]* B [ 1 ] + A [ 3 ]* B [ 3 ] # # return result
left := new ( maxHeap ) # heap . Init ( left ) # right := new ( minHeap ) # heap . Init ( right ) # # return MedianFinder { # left : left , # right : right , # }
newStack := & Node {} # # newStack . Val = n # newStack . Next = ll . top # # ll . top = newStack # ll . length ++
sum := 0 # for i := 1 0 ; i < 1 0 0 0 0 0 0 ; i ++ { # if passTest ( i ) { # sum += i # } # } # fmt . Println ( sum )
t . Parallel () # for _ , tc := range testcases { # if result := SmallestPositiveIntNotInSubsetSum ( tc . nums ); result != tc . smallest { # t . Errorf (" STR ", tc . nums , tc . smallest , result ) # } # }
i := & Index { # Target : & VariableAccess { Name : " STR "}, # Key : & LiteralNode { # Typex : TypeInt , # Value : 1 , # }, # } # # scope := & BasicScope { # VarMap : map [ string ] Variable { # " STR ": Variable { # Type : TypeList , # Value : [] Variable { # Variable { # Type : TypeInt , # Value : 3 4 , # }, # Variable { # Type : TypeInt , # Value : 5 4 , # }, # }, # }, # }, # } # # actual , err := i . Type ( scope ) # if err != nil { # t . Fatalf (" STR ", err ) # } # if actual != TypeInt { # t . Fatalf (" STR ", actual ) # }
if t . curToken == token . EOF { # return nil , & scanner . Error { # Pos : t . fset . Position ( t . curPos ), # Msg : " STR ", # } # } # prefix := prefixParseFns [ t . curToken ] # if prefix == nil { # return nil , & scanner . Error { # Pos : t . fset . Position ( t . curPos ), # Msg : fmt . Sprintf (" STR ", t . curToken ), # } # } # leftExpr , err := prefix ( t ) # # for t . peekToken != token . EOF && precedence < precedences [ t . peekToken ] { # switch t . peekToken { # case token . ADD , token . SUB , token . MUL , token . QUO , token . REM : # t . Next () # leftExpr , err = parseBinaryExpr ( t , leftExpr ) # } # } # # return leftExpr , err
return len ( n . keyValue )
this . mutex . Lock () # defer this . mutex . Unlock () # # return this . queues [ this . top ]. PeekWait ()
res := [] int { 0 } # for i := 0 ; i < n ; i ++ { # h := 1 << uint ( i ) # size := len ( res ) # for j := size - 1 ; j >= 0 ; j -- { # num := res [ j ] # num += h # res = append ( res , num ) # } # } # return res
if root == nil { # return 0 # } # # left , right := helper 1 1 1 ( root . Left ), helper 1 1 1 ( root . Right ) # if left == 0 { # return right + 1 # } # # if right == 0 { # return left + 1 # } # # if left < right { # return left + 1 # } # # return right + 1
n 1 := len ( s 1 ) # n 2 := len ( s 2 ) # if n 1 > n 2 { # return false # } # # h 1 := 0 # h 2 := 0 # for i := 0 ; i < n 1 ; i ++ { # c 1 := s 1 [ i ] - ' a ' # c 2 := s 2 [ i ] - ' a ' # h 1 += 1 << c 1 # h 2 += 1 << c 2 # } # # if h 1 == h 2 { # return true # } # # for i := n 1 ; i < n 2 ; i ++ { # cb := s 2 [ i - n 1 ] - ' a ' # ce := s 2 [ i ] - ' a ' # h 2 += ( 1 << ce ) - ( 1 << cb ) # if h 1 == h 2 { # return true # } # } # # return false
t . Parallel () # for _ , tc := range testcases { # if result := ReorderPermutation ( tc . input , tc . permutationPositions ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
lenA := len ( a ) # lenB := len ( b ) # if lenB > lenA { # a , b = b , a # lenA , lenB = lenB , lenA # } # b = strings . Repeat (" STR ", lenA - lenB ) + b # lenB = len ( b ) # # carry := byte ( 0 ) # ret := make ([] byte , lenB + 1 ) # # for i := lenB - 1 ; i >= 0 ; i -- { # numA := a [ i ] - ' 0 ' # numB := b [ i ] - ' 0 ' # sum := numA + numB + carry # ret [ i + 1 ] = sum & 1 + ' 0 ' # carry = sum >> 1 # } # if carry == 0 { # ret = ret [ 1 :] # } else { # ret [ 0 ] = carry + ' 0 ' # } # return string ( ret )
callback ( 3 )
size := len ( nums ) # # res := make ([] int , size ) # # left := 1 # for i := 0 ; i < size ; i ++ { # res [ i ] = left # left *= nums [ i ] # } # # right := 1 # for i := size - 1 ; i >= 0 ; i -- { # res [ i ] *= right # right *= nums [ i ] # } # # return res
if root == nil { # return - 1 # } # if root . Val > min { # return root . Val # } # left := dfs ( root . Left , min ) # right := dfs ( root . Right , min ) # if left == - 1 { # return right # } # if right == - 1 { # return left # } # if left < right { # return left # } # return right #
return bits . OnesCount ( uint ( num ))
sum := ( 1 0 0 * 1 0 1 ) / 2 # squareOfSum := sum * sum # # sumOfSquares := ( 1 0 0 * 1 0 1 * 2 0 1 ) / 6 # # fmt . Println ( squareOfSum - sumOfSquares )
if head == nil { # return nil # } # cnt := 0 # for tmp := head ; tmp != nil ; tmp = tmp . Next { # cnt ++ # } # k %= cnt # if k == 0 { # return head # } # pre , post := head , head # for i := 0 ; i < k && post != nil ; i ++ { # post = post . Next # } # if post == nil { # return head # } # for post . Next != nil { # pre , post = pre . Next , post . Next # } # newHead := pre . Next # post . Next = head # pre . Next = nil # return newHead
n := 0 # for _ , v := range b { # if v == c { # n ++ # } # } # return n
vs := getVectors ([][] int { p 1 , p 2 , p 3 , p 4 }) # for i := 0 ; i < 3 ; i ++ { # for j := i + 1 ; j < 4 ; j ++ { # if ! isOK ( vs [ i ], vs [ j ]) { # return false # } # } # } # return true
recMap := map [ int ] bool {} # typeCnt := 0 # for i := 0 ; i < len ( candies ); i ++{ # if recMap [ candies [ i ]] == false { # recMap [ candies [ i ]] = true # typeCnt ++ # } # } # # if typeCnt > len ( candies )/ 2 { # return len ( candies )/ 2 # } # # return typeCnt
if digits [ n ] > 0 { # return digits [ n ] # } # if tens [ n ] > 0 { # return tens [ n ] # } # if n == 1 0 0 0 { # return 3 + 8 # } # if n % 1 0 0 == 0 { # return digits [ n / 1 0 0 ] + 7 # } # if n > 1 0 0 { # return digits [ n / 1 0 0 ] + 1 0 + num_letters ( n % 1 0 0 ) # } # if n % 1 0 == 0 { # return tens [ n / 1 0 ] # } # return tens [ n / 1 0 ] + digits [ n % 1 0 ]
obj := Constructor () # obj . Put ( 1 , 1 ) # obj . Put ( 2 , 2 ) # got := obj . Get ( 1 ) == 1 # got = obj . Get ( 3 ) == - 1 && got # obj . Put ( 2 , 1 ) # got = obj . Get ( 2 ) == 1 && got # obj . Remove ( 2 ) # got = obj . Get ( 2 ) == - 1 && got # if ! got { # t . Fatalf (" STR ", got , true ) # }
var tests = [] struct { # nums [] int # max int # }{ # {[] int {- 2 , - 1 }, - 1 }, # {[] int {- 2 , 1 , - 3 , 4 , - 1 , 2 , 1 , - 5 , 4 }, 6 }, # } # # for _ , tt := range tests { # max := maxSubArray ( tt . nums ) # if max != tt . max { # t . Errorf (" STR ", tt . nums , max , tt . max ) # } # }
n , res , diff := len ( nums ), 0 , math . MaxInt 3 2 # if n > 2 { # sort . Ints ( nums ) # for i := 0 ; i < n - 2 ; i ++ { # for j , k := i + 1 , n - 1 ; j < k ; { # sum := nums [ i ] + nums [ j ] + nums [ k ] # if abs ( sum - target ) < diff { # res , diff = sum , abs ( sum - target ) # } # if sum == target { # return res # } else if sum > target { # k -- # } else { # j ++ # } # } # } # } # return res
if len ( stones ) == 0 { # return [] int { 0 , 0 } # } # sort . Ints ( stones ) # n := len ( stones ) # maxStep , minStep , left , right := max ( stones [ n - 1 ]- stones [ 1 ]- n + 2 , stones [ n - 2 ]- stones [ 0 ]- n + 2 ), math . MaxInt 6 4 , 0 , 0 # for left < n { # if right + 1 < n && stones [ right ]- stones [ left ] < n { # right ++ # } else { # if stones [ right ]- stones [ left ] >= n { # right -- # } # if right - left + 1 == n - 1 && stones [ right ]- stones [ left ]+ 1 == n - 1 { # minStep = min ( minStep , 2 ) # } else { # minStep = min ( minStep , n -( right - left + 1 )) # } # if right == n - 1 && stones [ right ]- stones [ left ] < n { # break # } # left ++ # } # } # return [] int { minStep , maxStep }
t . Parallel () # for tcid , tc := range testcases { # if result := IsValidRules ( tc . rules ); result != tc . isValid { # t . Errorf (" STR ", tcid , tc . isValid , result ) # } # }
pairs := [] primeData { # { 0 , [] int {}}, # { 1 , [] int {}}, # { 2 , [] int { 2 }}, # { 3 , [] int { 2 , 3 }}, # { 4 , [] int { 2 , 3 }}, # { 5 , [] int { 2 , 3 , 5 }}, # { 6 , [] int { 2 , 3 , 5 }}, # { 7 , [] int { 2 , 3 , 5 , 7 }}, # { 8 , [] int { 2 , 3 , 5 , 7 }}, # { 1 0 , [] int { 2 , 3 , 5 , 7 }}, # } # for _ , pair := range pairs { # in , out := pair . in , pair . out # if x := PrimesBelow ( in ); ! IntArrayEquals ( x , out ) { # t . Errorf (" STR ", in , x , out ) # } # }
now := time . Now () # # day := ZeroTime ( now . AddDate ( 0 , 0 , - 7 )) # fmt . Println ( day . Unix ())
return MyCalendarTwo { # events : [][ 2 ] int {}, # conflicts : [][ 2 ] int {}, # }
xor := 0 # # for i , n := range nums { # xor ^= i ^ n # } # # # return xor ^ len ( nums )
if n == 2 { # return 1 # } # if n == 3 { # return 2 # } # res := 1 # for n > 4 { # res *= 3 # n -= 3 # } # res *= n # return res
res := [][] int {} # if root == nil { # return res # } # queue := []* TreeNode { root } # for level := 0 ; len ( queue ) > 0 ; level ++ { # l := len ( queue ) # list := [] int {} # for i := 0 ; i < l ; i ++ { # node := queue [ i ] # if level % 2 == 0 { # list = append ( list , node . Val ) # } else { # list = append ([] int { node . Val }, list ...) # } # if node . Left != nil { # queue = append ( queue , node . Left ) # } # if node . Right != nil { # queue = append ( queue , node . Right ) # } # } # queue = queue [ l :] # res = append ( res , list ) # } # return res
if x <= 1 { # return x # } # l , r := 0 , x # for l < r { # m := ( r - l )/ 2 + l # if m == l || m == r { # return m # } # mm := m * m # if mm == x { # return m # } # if mm > x { # r = m # } else { # l = m # } # } # return l
cases := [] struct { # name string # inputs string # expect int # }{ # {" STR ", " STR ", 2 }, # {" STR ", " STR ", 4 }, # {" STR ", " STR ", 6 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := longestValidParentheses 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
ans := make ([] float 6 4 , 0 , len ( nums )- k ) # window := make ([] float 6 4 , k ) # # for i := 0 ; i <= len ( nums )- k ; i ++ { # copy ( window , nums [ i : k + i ]) # sort . Float 6 4 s ( window ) # # if k % 2 == 0 { # ans = append ( ans , ( window [ k / 2 ]+ window [( k / 2 )- 1 ])/ 2 ) # } else { # ans = append ( ans , window [ k / 2 ]) # } # } # # return ans
if ll . Head == nil { # return # } # var cur * Node # for cur = ll . Head ; cur . Next != nil ; cur = cur . Next { # } # # for ; cur != nil ; cur = cur . Prev { # fmt . Print ( cur . Val , " STR ") # } # # fmt . Print (" STR ")
return uint 6 4 ( i )
t . Parallel () # for _ , tc := range testcases { # if result := HIndex ( tc . citations ); result != tc . hindex { # t . Errorf (" STR ", tc . hindex , result ) # } # }
qs := [] question 6 3 2 { # # { # para 6 3 2 {[][] int {{ 4 , 1 0 , 1 5 , 2 4 , 2 6 }, { 0 , 9 , 1 2 , 2 0 }, { 5 , 1 8 , 2 2 , 3 0 }}}, # ans 6 3 2 {[] int { 2 0 , 2 4 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 3 2 , q . para 6 3 2 # fmt . Printf (" STR ", p , smallestRange ( p . one )) # } # fmt . Printf (" STR ")
visited := make ([][] bool , len ( board )) # for i := 0 ; i < len ( visited ); i ++ { # visited [ i ] = make ([] bool , len ( board [ 0 ])) # } # for i , v := range board { # for j := range v { # if searchWord ( board , visited , word , 0 , i , j ) { # return true # } # } # } # return false
for len ( arr ) > 1 { # primeIdx := partition ( arr ) # if primeIdx < len ( arr )/ 2 { # quickSortTail ( arr [: primeIdx ]) # arr = arr [ primeIdx + 1 :] # } else { # quickSortTail ( arr [ primeIdx + 1 :]) # arr = arr [: primeIdx ] # } # }
return & Map {}
var primes [] int # # ch := make ( chan int ) # go GenerateChannel ( ch ) # # for i := 0 ; i < limit ; i ++ { # primes = append ( primes , <- ch ) # ch 1 := make ( chan int ) # go Sieve ( ch , ch 1 , primes [ i ]) # ch = ch 1 # } # # return primes
var opensIfWildcardCloses , opensIfWildcardOpens int # for _ , c := range input { # switch c { # case '(': # opensIfWildcardCloses ++ # opensIfWildcardOpens ++ # case ')': # opensIfWildcardCloses -- # opensIfWildcardOpens -- # case '*': # opensIfWildcardCloses -- # opensIfWildcardOpens ++ # } # if opensIfWildcardOpens < 0 { # break # } # if opensIfWildcardCloses < 0 { # opensIfWildcardCloses = 0 # } # } # return opensIfWildcardCloses == 0
var haystack string # var needle string # var ret int # # haystack = " STR " # needle = " STR " # ret = 0 # if ret != strStr ( haystack , needle ) { # t . Fatalf (" STR ", ret ) # } # # haystack = " STR " # needle = " STR " # ret = 0 # if ret != strStr ( haystack , needle ) { # t . Fatalf (" STR ", ret ) # } # # haystack = " STR " # needle = " STR " # ret = 2 # if ret != strStr ( haystack , needle ) { # t . Fatalf (" STR ", ret ) # } # # haystack = " STR " # needle = " STR " # ret = - 1 # if ret != strStr ( haystack , needle ) { # t . Fatalf (" STR ", ret ) # } # # haystack = " STR " # needle = " STR " # ret = - 1 # if ret != strStr ( haystack , needle ) { # t . Fatalf (" STR ", ret ) # }
l := len ( nums [ 0 ]) # if l * len ( nums ) < r * c { # return nums # } # newNums := make ([][] int , r ) # for i := 0 ; i < r ; i ++ { # newNums [ i ] = make ([] int , c ) # for j := 0 ; j < c ; j ++ { # n := i * c + j # i 1 , j 1 := n / l , n % l # newNums [ i ][ j ] = nums [ i 1 ][ j 1 ] # } # } # return newNums
base := big . NewInt ( int 6 4 ( a )) # exponent := big . NewInt ( int 6 4 ( b )) # product := base . Exp ( base , exponent , nil ) # digits := [] rune ( product . String ()) # for _ , digit := range digits { # digitValue , _ := strconv . Atoi ( string ( digit )) # total += digitValue # } # return
return len ( list )
var tests = [] struct { # s string # d [] string # w string # }{ # {" STR ", [] string {" STR ", " STR ", " STR ", " STR "}, " STR "}, # {" STR ", [] string {" STR ", " STR ", " STR "}, " STR "}, # } # # for _ , tt := range tests { # w := findLongestWord ( tt . s , tt . d ) # if w != tt . w { # t . Errorf (" STR ", tt . s , tt . d , w , tt . w ) # } # }
val := binary . BigEndian . Uint 6 4 ( self . data ) # self . data = self . data [ 8 :] # return val
t . Parallel () # for _ , tc := range testcases { # if result := TrappedWater ( tc . elevations ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
return s [ 1 ]
for arrayIndex := range array { # minValue := array [ arrayIndex ] # minIndex := arrayIndex # for subArrayIndex := arrayIndex + 1 ; subArrayIndex < len ( array ); subArrayIndex ++ { # if array [ subArrayIndex ] < minValue { # minValue = array [ subArrayIndex ] # minIndex = subArrayIndex # } # } # array [ minIndex ], array [ arrayIndex ] = array [ arrayIndex ], array [ minIndex ] # }
size := len ( n ) # # candidates := getBitChangeCandidates ( size ) # candidates = append ( candidates , getCanidates ( n )...) # # num , _ := strconv . Atoi ( n ) # delta := func ( x int ) int { # if x > num { # return x - num # } # return num - x # } # # res := math . MaxInt 6 4 # for _ , cand := range candidates { # if cand == num { # continue # } # # if delta ( cand ) < delta ( res ) || # ( delta ( cand ) == delta ( res ) && cand < res ) { # res = cand # } # } # # return strconv . Itoa ( res )
if len ( nums ) == 0 { # return false # } # max := 0 # for i := 0 ; i <= max ; i ++ { # if i + nums [ i ] > max { # max = i + nums [ i ] # } # if max >= len ( nums )- 1 { # return true # } # } # return false
var buf bytes . Buffer # buf . WriteByte (" STR ") # for i , v := range values { # if i > 0 { # buf . WriteString (" STR ") # } # fmt . Fprintf (& buf , " STR ", v ) # } # buf . WriteByte (" STR ") # return buf . String ()
tests := [...] testType { # { # g : [] int { 1 , 2 , 3 }, # s : [] int { 1 , 1 }, # want : 1 , # }, # { # g : [] int { 1 , 2 }, # s : [] int { 1 , 2 , 3 }, # want : 2 , # }, # } # for _ , tt := range tests { # got := findContentChildren ( tt . g , tt . s ) # if got != tt . want { # t . Fatalf (" STR ", tt . g , got , tt . want ) # } # }
g := make ([] int , n + 1 ) # g [ 0 ], g [ 1 ] = 1 , 1 # for i := 2 ; i <= n ; i ++ { # for j := 1 ; j <= i ; j ++ { # g [ i ] += g [ j - 1 ] * g [ i - j ] # } # } # return g [ n ]
if start == end { # return 1 # } # # cands := make ([] string , 1 , 1 0 2 4 ) # cands [ 0 ] = start # res := 0 # # isAdded := make ([] bool , len ( bank )) # # for len ( cands ) > 0 { # res ++ # size := len ( cands ) # for i := 0 ; i < size ; i ++ { # cand := cands [ i ] # for i , gene := range bank { # if isAdded [ i ] || ! isMutation ( cand , gene ) { # continue # } # if gene == end { # return res # } # cands = append ( cands , gene ) # isAdded [ i ] = true # } # } # cands = cands [ size :] # } # return - 1
total := 1 0 0 0 # a , b , c := 1 , 1 , total # long , short , hypotenuse := a * a , b * b , c * c # fmt . Println (" STR ", a , b , c , long , short , hypotenuse ) # # L : # for ; a <= total ; a ++ { # for b = 1 ; a + b <= total ; b ++ { # c = total - a - b # long , short , hypotenuse = a * a , b * b , c * c # if long + short == hypotenuse { # fmt . Println (" STR ", a , b , c , long , short , hypotenuse ) # break L # } # } # } # # fmt . Println (" STR ", a + b + c ) # fmt . Println (" STR ", long + short , " STR ", hypotenuse ) # fmt . Println (" STR ", a * b * c )
n := len ( S ) # l , r := 0 , n # res := make ([] int , n + 1 ) # for i := 0 ; i < n ; i ++ { # if S [ i ] == ' I ' { # res [ i ] = l # l ++ # } else { # res [ i ] = r # r -- # } # } # res [ n ] = l # return res
return lq . queue . Len () == 0
if height == nil { # return 0 # } # if len ( height ) == 1 { # return height [ 0 ] # } # var stack [] int # maxArea := 0 # n := len ( height ) # var w int # for i := 0 ; i < n + 1 ; i ++ { # for len ( stack ) > 0 && ( i == n || height [ stack [ len ( stack )- 1 ]] > height [ i ]) { # pop := stack [ len ( stack )- 1 ] # stack = append ([] int {}, stack [ 0 : len ( stack )- 1 ]...) # h := height [ pop ] # if len ( stack ) > 0 { # w = i - stack [ len ( stack )- 1 ] - 1 # } else { # w = i # } # maxArea = int ( math . Max ( float 6 4 ( maxArea ), float 6 4 ( h * w ))) # } # stack = append ( stack , i ) # } # return maxArea
m , max , left := make ( map [ rune ] int ), 0 , 0 # for idx , c := range s { # if _ , okay := m [ c ]; okay == true && m [ c ] >= left { # if idx - left > max { # max = idx - left # } # left = m [ c ] + 1 # } # m [ c ] = idx # } # if len ( s )- left > max { # max = len ( s ) - left # } # return max
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 4 }, 2 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := hammingDistance ( c . inputs [ 0 ], c . inputs [ 1 ]) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
c := 1 # for i := len ( digits ) - 1 ; i >= 0 ; i -- { # n := digits [ i ] + c # digits [ i ] = n % 1 0 # c = n / 1 0 # } # if c == 1 { # digits = append ([] int { 1 }, digits ...) # } # return digits
B := new ( Matrix ) # B . rows = A . rows # B . cols = A . cols # B . step = A . step # # B . Elements = make ([] float 6 4 , A . cols * A . rows ) # # for i := 0 ; i < A . rows ; i ++ { # for j := 0 ; j < A . cols ; j ++ { # B . Elements [ i * A . step + j ] = A . GetElm ( i , j ) # } # } # return B
m , n := len ( A ), len ( A [ 0 ]) # dp := make ([] int , n ) # for i := 0 ; i < n ; i ++ { # dp [ i ] = 1 # } # res := n - 1 # for j := 0 ; j < n ; j ++ { # L : # for i := 0 ; i < j ; i ++ { # for k := 0 ; k < m ; k ++ { # if A [ k ][ i ] > A [ k ][ j ] { # continue L # } # } # if dp [ i ]+ 1 > dp [ j ] { # dp [ j ] = dp [ i ] + 1 # } # } # res = min ( res , n - dp [ j ]) # } # return res
t . Parallel () # for _ , tc := range testcases { # if result := DoesMappingExist ( tc . s 1 , tc . s 2 ); result != tc . exists { # t . Errorf (" STR ", tc . exists , result ) # } # }
obj := Constructor 7 4 5 ([] string {" STR "}) # fmt . Printf (" STR ", obj ) # param 1 := obj . F (" STR ", " STR ") # fmt . Printf (" STR ", param 1 , obj ) # param 2 := obj . F (" STR ", " STR ") # fmt . Printf (" STR ", param 2 , obj )
b := filledMultiLRU ( time . Now (). Add ( time . Duration ( 4 ))) # # cpu := runtime . GOMAXPROCS ( 0 ) # ch := make ( chan bool ) # worker := func () { # for i := 0 ; i < bb . N / cpu ; i ++ { # b . Get ( randomString ( 2 )) # } # ch <- true # } # for i := 0 ; i < cpu ; i ++ { # go worker () # } # for i := 0 ; i < cpu ; i ++ { # _ = <- ch # }
sort . Ints ( g ) # sort . Ints ( s ) # gi , si , res := 0 , 0 , 0 # for gi < len ( g ) && si < len ( s ) { # if s [ si ] >= g [ gi ] { # res ++ # si ++ # gi ++ # } else { # si ++ # } # } # return res
ch := make ( chan int ) # go Generate ( ch ) # # for i := 0 ; i < 1 0 0 0 1 ; i ++ { # prime := <- ch # fmt . Printf (" STR ", i + 1 , prime ) # ch 1 := make ( chan int ) # go Filter ( ch , ch 1 , prime ) # ch = ch 1 # }
sMap , tMap := map [ uint 8 ] int {}, map [ uint 8 ] int {} # for i := range s { # if sMap [ s [ i ]] != tMap [ t [ i ]] { # return false # } else { # sMap [ s [ i ]] = i + 1 # tMap [ t [ i ]] = i + 1 # } # } # return true
this . mutex . Lock () # defer this . mutex . Unlock () # # if priority < 0 || priority > this . max { # return nil # } # # if this . total == 0 { # return nil # } # # this . waiting [ priority ] = 0 # ret := this . queues [ priority ]. Remove () # # this . updateRemoval () # # return ret
pair := make ([] byte , n + n ) # return dfs ( nil , pair , n , 0 , 0 )
left , right := 0 , len ( numbers )- 1 # for left < right { # sum := numbers [ left ] + numbers [ right ] # if sum < target { # left ++ # } else if sum > target { # right -- # } else { # return [] int { left + 1 , right + 1 } # } # } # return nil
if t % 2 == 0 { # return Kind (( t >> 1 ) % 3 2 ) # } else { # return Kind ( t >> 1 )% 8 + 1 9 # }
if node . stackSizeType == Undefined { # node . determineStackSize ( make ( map [* CallNode ] struct {})) # } # return node . stackSize , node . stackSizeType , node . missingFrameInfo
fmt . Println ( lengthOfLastWord (" STR "))
qs := [] question 9 2 3 { # # { # para 9 2 3 {[] int { 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 }, 8 }, # ans 9 2 3 { 2 0 }, # }, # # { # para 9 2 3 {[] int { 1 , 1 , 2 , 2 , 2 , 2 }, 5 }, # ans 9 2 3 { 1 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 2 3 , q . para 9 2 3 # fmt . Printf (" STR ", p , threeSumMulti ( p . a , p . t )) # } # fmt . Printf (" STR ")
i , j := 0 , len ( nums )- 1 # for { # for i < len ( nums ) && nums [ i ] != val { # i ++ # } # # for j >= 0 && nums [ j ] == val { # j -- # } # # if i >= j { # break # } # # nums [ i ], nums [ j ] = nums [ j ], nums [ i ] # } # # return i
quick := head # slow := head # # for quick . Next . Next != nil && slow . Next != nil { # quick = quick . Next . Next # slow = slow . Next # if slow == quick { # return true # } # } # return false
cases := [] struct { # name string # inputs [] string # expect [] string # }{ # {" STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR "}, [] string {" STR ", " STR ", " STR ", " STR ", " STR "}}, # {" STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if len ( matrix ) == 0 || len ( matrix [ 0 ]) == 0 { # return false # } # # rows , cols := len ( matrix ), len ( matrix [ 0 ]) # left , right := 0 , rows * cols - 1 # for left <= right { # mid := ( left + right ) / 2 # row , col := mid / cols , mid % cols # if matrix [ row ][ col ] == target { # return true # } # # if matrix [ row ][ col ] < target { # left = mid + 1 # } else { # right = mid - 1 # } # } # # return false
if root == nil { # return nil # } # l := root . Left # r := root . Right # for l != nil { # l . Next = r # l = l . Right # r = r . Left # } # connect ( root . Left ) # connect ( root . Right ) # return root
type Server struct { # Name string # ID int 3 2 # Enabled bool # } # # server := & Server { # Name : " STR ", # ID : 1 2 3 4 5 6 , # Enabled : true , # } # # s := New ( server ) # # fmt . Printf (" STR ", s . Name ()) # fmt . Printf (" STR ", s . Values ()) # fmt . Printf (" STR ", s . Field (" STR "). Value ()) #
if root == nil { # return 0 # } # if root . Left == nil { # return minDepth ( root . Right ) + 1 # } # if root . Right == nil { # return minDepth ( root . Left ) + 1 # } # return min ( minDepth ( root . Left ), minDepth ( root . Right )) + 1
return reflect . ArrayOf ( count , elem )
result := make ([] int , 0 ) # if len ( matrix ) == 0 || len ( matrix [ 0 ]) == 0 { # return result # } # # rows , cols := len ( matrix ), len ( matrix [ 0 ]) # for i := 0 ; 2 * i < rows && 2 * i < cols ; i ++ { # row , col := i , i # for ; col < cols - i ; col ++ { # result = append ( result , matrix [ row ][ col ]) # } # # row , col = row + 1 , col - 1 # for ; row < rows - i ; row ++ { # result = append ( result , matrix [ row ][ col ]) # } # # row , col = row - 1 , col - 1 # for ; row > i && col >= i ; col -- { # result = append ( result , matrix [ row ][ col ]) # } # # row , col = row - 1 , col + 1 # for ; 2 * i + 1 < cols && row > i ; row -- { # result = append ( result , matrix [ row ][ col ]) # } # } # # return result
uint 3 2 Val := uint 3 2 ( self . table [ index ]. Num ) # return math . Float 3 2 frombits ( uint 3 2 Val )
if head == nil { # return [] int {} # } # pre , cur , next , ans := & ListNode {}, head , head . Next , [] int {} # for cur != nil { # next = cur . Next # cur . Next = pre # # pre = cur # cur = next # } # for pre . Next != nil { # ans = append ( ans , pre . Val ) # pre = pre . Next # } # return ans
m , n , i := len ( name ), len ( typed ), 0 # for j := 0 ; j < n ; j ++ { # if i < m && name [ i ] == typed [ j ] { # i ++ # } else if j == 0 || typed [ j ] != typed [ j - 1 ] { # return false # } # } # return i == m
const divs = 5 0 0 # triNumber , natNumber := 1 , 1 # for factors ( triNumber ) < divs { # natNumber ++ # triNumber += natNumber # } # println ( triNumber )
s := newStruct () # # defer func () { # err := recover () # if err == nil { # t . Error (" STR ") # } # }() # # _ = s . Field (" STR ")
return & arrayQueue { # Items : make ([] interface {}, size ), # Size : size , # Head : 0 , # Tail : 0 , # }
return len ( d )
if x < 0 || ( x != 0 && x % 1 0 == 0 ) { # return false # } # # return x == reverse ( x )
var ( # bucketno uint 3 2 # found bool # bucket * countBucket # ) # # if bucketno , found = ss . hash [ key ]; found { # bucket = & ss . olist [ bucketno ] # } else { # bucketno = 0 # bucket = & ss . olist [ bucketno ] # delete ( ss . hash , bucket . key ) # ss . hash [ key ] = bucketno # bucket . error = bucket . count # bucket . key = key # } # # bucket . count += 1 # # for { # if bucketno == uint 3 2 ( len ( ss . olist ))- 1 { # break # } # # b 1 := & ss . olist [ bucketno ] # b 2 := & ss . olist [ bucketno + 1 ] # if b 1 . count < b 2 . count { # break # } # # ss . hash [ b 1 . key ] = bucketno + 1 # ss . hash [ b 2 . key ] = bucketno # * b 1 , * b 2 = * b 2 , * b 1 # bucketno += 1 # }
t := buildTrie ( dict ) # visited := make ([][] bool , len ( board )) # for i := range visited { # visited [ i ] = make ([] bool , len ( board [ i ])) # } # result := make ([] string , 0 , len ( dict )) # for i := range board { # for j := range board [ i ] { # result = append ( result , boggleSolver ( board , visited , t , [] rune {}, i , j )...) # } # } # m := make ( map [ string ] struct {}) # for _ , w := range result { # m [ w ] = struct {}{} # } # result = make ([] string , 0 , len ( m )) # for w := range m { # result = append ( result , w ) # } # return result
res := make ([][] int , 0 , 1 << 5 ) # dfs ( root , 0 , & res ) # return res
t . Parallel () # x := 0 # f := func () { # x ++ # } # dbf := Debounced ( f , 5 0 0 ) # for i := 0 ; i < 1 0 ; i ++ { # dbf () # } # if x != 0 { # t . Errorf (" STR ") # } # time . Sleep ( 8 0 0 * time . Millisecond ) # for i := 0 ; i < 1 0 ; i ++ { # dbf () # } # if x != 1 0 { # t . Errorf (" STR ") # }
fmt . Println ( searchInsert ([] int { 1 , 3 , 5 , 6 }, 5 )) # fmt . Println ( searchInsert ([] int { 1 , 3 , 5 , 6 }, 2 )) # fmt . Println ( searchInsert ([] int { 1 , 3 , 5 , 6 }, 0 ))
defer wg . Done () # defer close ( webResponses ) # var wgUrlReq sync . WaitGroup # wgUrlReq . Add ( len ( urls )) # for _ , v := range urls { # go func ( url string ) { # defer wgUrlReq . Done () # responseVal := webResponse {} # responseVal . requestUrl = url # response , err := http . Get ( url ) # if err != nil { # responseVal . error = err # responseVal . status = http . StatusInternalServerError # } else { # defer response . Body . Close () # body , err := ioutil . ReadAll ( response . Body ) # if err == nil { # responseVal . responseText = string ( body ) # } # responseVal . error = err # responseVal . status = response . StatusCode # } # webResponses <- responseVal # }( v ) # } # wgUrlReq . Wait ()
m , n := len ( nums 1 ), len ( nums 2 ) # if m == 0 || n == 0 { # return nil # } # # psLen := min ( k , m ) # ps := make ( pairs , psLen ) # for i := 0 ; i < psLen ; i ++ { # ps [ i ] = & pair { i , 0 , nums 1 [ i ] + nums 2 [ 0 ]} # } # # heap . Init (& ps ) # # res := [][] int {} # for k > 0 && len ( ps ) > 0 { # min := heap . Pop (& ps ).(* pair ) # res = append ( res , [] int { nums 1 [ min . i ], nums 2 [ min . j ]}) # if min . j + 1 < n { # heap . Push (& ps , & pair { min . i , min . j + 1 , nums 1 [ min . i ] + nums 2 [ min . j + 1 ]}) # } # k -- # } # return res
qs := [] question 9 2 5 { # # { # para 9 2 5 {" STR ", " STR "}, # ans 9 2 5 { true }, # }, # # { # para 9 2 5 {" STR ", " STR "}, # ans 9 2 5 { false }, # }, # # { # para 9 2 5 {" STR ", " STR "}, # ans 9 2 5 { true }, # }, # # { # para 9 2 5 {" STR ", " STR "}, # ans 9 2 5 { true }, # }, # # { # para 9 2 5 {" STR ", " STR "}, # ans 9 2 5 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 2 5 , q . para 9 2 5 # fmt . Printf (" STR ", p , isLongPressedName ( p . name , p . typed )) # } # fmt . Printf (" STR ")
ps := PubSub { # host : host , # } # # # return & ps
res , count := nums [ 0 ], 0 # for i := 0 ; i < len ( nums ); i ++ { # if count == 0 { # res , count = nums [ i ], 1 # } else { # if nums [ i ] == res { # count ++ # } else { # count -- # } # } # } # return res
node := & ListNode { Val : 0 , Next : nil } # n 1 , n 2 , tmp := l 1 , l 2 , node # sum := 0 # # for n 1 != nil || n 2 != nil { # sum /= 1 0 # if n 1 != nil { # sum += n 1 . Val # n 1 = n 1 . Next # # } # if n 2 != nil { # sum += n 2 . Val # n 2 = n 2 . Next # } # tmp . Next = & ListNode { Val : sum % 1 0 } # tmp = tmp . Next # } # if sum / 1 0 != 0 { # tmp . Next = & ListNode { Val : 1 } # } # return node . Next
for i , j , k := m - 1 , n - 1 , m + n - 1 ; j >= 0 ; k -- { # if i >= 0 && nums 1 [ i ] > nums 2 [ j ] { # nums 1 [ k ] = nums 1 [ i ] # i -- # } else { # nums 1 [ k ] = nums 2 [ j ] # j -- # } # }
switch v . Kind () { # case reflect . Invalid : # return " STR " # case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , # reflect . Int 3 2 , reflect . Int 6 4 : # return strconv . FormatInt ( v . Int (), 1 0 ) # case reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , # reflect . Uint 3 2 , reflect . Uint 6 4 , reflect . Uintptr : # return strconv . FormatUint ( v . Uint (), 1 0 ) # case reflect . Bool : # if v . Bool () { # return " STR " # } # return " STR " # case reflect . String : # return strconv . Quote ( v . String ()) # case reflect . Chan , reflect . Func , reflect . Ptr , # reflect . Slice , reflect . Map : # return v . Type (). String () + " STR " + # strconv . FormatUint ( uint 6 4 ( v . Pointer ()), 1 6 ) # default : # return v . Type (). String () + " STR " # }
t . Parallel () # for _ , tc := range testcases { # if result := PossibleWaysToThrow ( tc . n , tc . faces , tc . total ); result != tc . possibleWays { # t . Errorf (" STR ", tc . possibleWays , result ) # } # }
if len ( deck ) < 2 { # return false # } # m , g := map [ int ] int {}, - 1 # for _ , d := range deck { # m [ d ]++ # } # for _ , v := range m { # if g == - 1 { # g = v # } else { # g = gcd ( g , v ) # } # } # return g >= 2
x ^= y # res := 0 # for x > 0 { # res += x & 1 # x >>= 1 # } # return res
l , r := 0 , 5 *( k + 1 ) # for l <= r { # m := l + ( r - l )/ 2 # km := zeros ( m ) # if km < k { # l = m + 1 # } else if km > k { # r = m - 1 # } else { # return 5 # } # } # return 0
max := candies [ 0 ] # for i := 1 ; i < len ( candies ); i ++ { # if candies [ i ] > max { # max = candies [ i ] # } # } # res := make ([] bool , 0 ) # for i := 0 ; i < len ( candies ); i ++ { # if candies [ i ]+ extraCandies >= max { # res = append ( res , true ) # } else { # res = append ( res , false ) # } # } # return res
idxs := make ([] int 6 4 , len ( lists )) # var result [] int # hasMore := true # for hasMore { # listID := - 1 # smallest := math . MaxInt 6 4 # for i , idx := range idxs { # if idx < int 6 4 ( len ( lists [ i ])) && lists [ i ][ idx ] < smallest { # smallest = lists [ i ][ idx ] # listID = i # } # } # if listID == - 1 { # hasMore = false # } else { # result = append ( result , smallest ) # idxs [ listID ]++ # } # } # return result
if b . pointer == len ( b . data ) { # b . pointer = 0 # } # b . data [ b . pointer ] = i # b . pointer += 1
type arg struct { # s string # p string # } # cases := [] arg { # { # s : " STR ", # p : " STR ", # }, # { # s : " STR ", # p : " STR ", # }, # { # p : " STR ", # s : " STR ", # }, # } # # expected := [][] int { # { 0 , 6 }, # { 0 , 1 , 2 }, # {}, # } # # for index , args := range cases { # if res := findAnagrams ( args . s , args . p ); ! reflect . DeepEqual ( res , expected [ index ]) { # t . Errorf (" STR ", expected [ index ], res ) # } # }
s . top = & stackElement { value , s . top } # s . size ++
tmp , isSorted := 0 , false # # for isSorted == false { # # isSorted = true # # for i := 1 ; i < len ( arr ) - 1 ; i = i + 2 { # if arr [ i ] > arr [ i + 1 ] { # tmp = arr [ i ] # arr [ i ] = arr [ i + 1 ] # arr [ i + 1 ] = tmp # # isSorted = false # } # } # # for i := 0 ; i < len ( arr ) - 1 ; i = i + 2 { # if arr [ i ] > arr [ i + 1 ] { # tmp = arr [ i ] # arr [ i ] = arr [ i + 1 ] # arr [ i + 1 ] = tmp # # isSorted = false # } # } # }
pos , err := r . Seek ( offset , whence ) # if err != nil { # return err # } # if pos != newPos { # return errSeekPosMismatch # } # return nil
sum := 0 # if root != nil { # if isLeaf ( root . Left ) { # sum += root . Left . Val # } else { # sum += sumOfLeftLeaves ( root . Left ) # } # sum += sumOfLeftLeaves ( root . Right ) # } # return sum
var result interface {} # var count int # for element := range stream { # if count == 0 { # result = element # } else if randomizer . Intn ( count ) == 0 { # result = element # } # count ++ # } # return result
bytes , err := dataProfilesJsonBytes () # if err != nil { # return nil , err # } # # info := bindataFileInfo { name : " STR ", size : 3 3 5 6 , mode : os . FileMode ( 4 2 0 ), modTime : time . Unix ( 1 4 5 6 5 9 1 4 2 8 , 0 )} # a := & asset { bytes : bytes , info : info } # return a , nil
l , r := 0 , len ( a )- 1 # for { # m := ( l + r ) / 2 # switch { # case a [ m ] < a [ m + 1 ]: # l = m # case a [ m - 1 ] > a [ m ]: # r = m # default : # return m # } # }
TemplateBenchmarkGCD ( b , Iterative )
res := [] string {} # for i := 1 ; i <= n ; i ++ { # if i % 3 == 0 && i % 1 5 == 0 { # res = append ( res , " STR ") # } else if i % 3 == 0 { # res = append ( res , " STR ") # } else if i % 5 == 0 { # res = append ( res , " STR ") # } else { # res = append ( res , strconv . Itoa ( i )) # } # # } # return res
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 2 , 2 , 1 }, 1 }, # {" STR ", [] int { 4 , 1 , 2 , 1 , 2 }, 4 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := singleNumber 3 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if len ( s ) != 2 * HashSize { # err = fmt . Errorf (" STR ", len ( s )) # return # } # n , err := hex . Decode ( h [:], [] byte ( s )) # if err != nil { # return # } # if n != HashSize { # panic ( n ) # } # return
if len ( nums ) < 3 { # return 0 # } # # sort . Ints ( nums ) # ans 1 , ans 2 := 1 , 1 # for i := len ( nums ) - 1 ; i >= len ( nums )- 3 ; i -- { # ans 1 *= nums [ i ] # } # # for i := 0 ; i < 2 ; i ++ { # ans 2 *= nums [ i ] # } # ans 2 *= nums [ len ( nums )- 1 ] # # if ans 1 > ans 2 { # return ans 1 # } # return ans 2
if getIter ( 2 5 ) != 7 5 0 2 5 { # fmt . Println ( getIter ( 2 5 )) # t . Error () # }
lgu := rand . Intn ( 2 5 ) + 7 # datasKey := RandomSlice ( 1 , ( 1 << uint 3 2 ( lgu ))- 1 , rand . Intn (( 1 << 7 )- 1 )+ 1 ) # datas := make ( map [ uint 3 2 ][] int ) # for _ , v := range datasKey { # arr := RandomSlice ( 0 , 6 4 , rand . Intn ( 1 0 )+ 1 ) # datas [ uint 3 2 ( v )] = arr # } # return lgu , datas , datasKey
min 1 , min 2 := math . MaxInt 3 2 , math . MaxInt 3 2 # max 1 , max 2 , max 3 := math . MinInt 3 2 , math . MinInt 3 2 , math . MinInt 3 2 # for _ , v := range nums { # if v <= min 1 { # min 2 , min 1 = min 1 , v # } else if v <= min 2 { # min 2 = v # } # if v >= max 1 { # max 3 , max 2 , max 1 = max 2 , max 1 , v # } else if v >= max 2 { # max 3 , max 2 = max 2 , v # } else if v >= max 3 { # max 3 = v # } # } # m 1 := min 1 * min 2 * max 1 # m 2 := max 1 * max 2 * max 3 # if m 1 > m 2 { # return m 1 # } # return m 2
m := make ( map [ int ] struct {}) # for _ , num := range nums { # if _ , ok := m [ num ]; ok { # return true # } # m [ num ] = struct {}{} # } # return false
Palindrome := 0 # for x := 9 0 0 ; x <= 9 9 9 ; x ++ { # for y := 9 0 0 ; y <= 9 9 9 ; y ++ { # sum := x * y # if isPalindrome ( strconv . Itoa ( sum )) && ( sum ) > Palindrome { # Palindrome = sum # } # } # } # # print ( Palindrome )
var ones , twos int # for _ , v := range nums { # twos |= ones & v # ones ^= v # not := ^( ones & twos ) # ones &= not # twos &= not # } # return ones
var ( # n int # i = len ( g ) - 1 # j = len ( s ) - 1 # ) # sort . Ints ( g ) # sort . Ints ( s ) # for i >= 0 && j >= 0 { # if s [ j ] >= g [ i ] { # n ++ # j -- # } # i -- # } # return n
t . Parallel () # for _ , tc := range testcases { # if result := GhostWinningLetterPlayerOne ( tc . dict ); ! reflect . DeepEqual ( result , tc . result ) { # t . Errorf (" STR ", string ( tc . result ), string ( result )) # } # }
length := len ( nums ) # max , min := make ([] int , length ), make ([] int , length ) # max [ 0 ], min [ length - 1 ] = nums [ 0 ], nums [ length - 1 ] # for idx := 1 ; idx < length ; idx ++ { # max [ idx ] = max [ idx - 1 ] # if nums [ idx ] > max [ idx ] { # max [ idx ] = nums [ idx ] # } # # i := length - 1 - idx # min [ i ] = min [ i + 1 ] # if nums [ i ] < min [ i ] { # min [ i ] = nums [ i ] # } # } # # idx := 1 # for ; idx < length ; idx ++ { # if min [ idx ] >= max [ idx - 1 ] { # break # } # } # # return idx
return link ( FindSet ( e 1 ), FindSet ( e 2 ))
nA := NumArray { sum : make ([] int , 1 )} # for _ , num := range nums { # nA . sum = append ( nA . sum , nA . sum [ len ( nA . sum )- 1 ]+ num ) # } # return nA
t . Parallel () # var cfb ConnectFourBoard # for i := 0 ; i < 3 ; i ++ { # if err := cfb . Move ( Red , 0 ); err != nil { # t . Errorf (" STR ", err ) # } # if p := cfb . Winner (); p != None { # t . Errorf (" STR ", p ) # } # if err := cfb . Move ( Black , 0 ); err != nil { # t . Errorf (" STR ", err ) # } # if p := cfb . Winner (); p != None { # t . Errorf (" STR ", p ) # } # } # if err := cfb . Move ( Red , 0 ); err == nil { # t . Errorf (" STR ") # } # if err := cfb . Move ( None , 1 ); err == nil { # t . Errorf (" STR ") # } # if err := cfb . Move ( Black + Red , 1 ); err == nil { # t . Errorf (" STR ") # }
if len ( matrix ) == 0 || len ( matrix [ 0 ]) == 0 { # return false # } # m , n := len ( matrix ), len ( matrix [ 0 ]) # i , j := 0 , n - 1 # for i < m && j >= 0 { # if matrix [ i ][ j ] < target { # i ++ # } else if matrix [ i ][ j ] > target { # j -- # } else { # return true # } # } # return false
ret := make ([] int , 1 ) # helper ( root , ret ) # return ret [ 0 ]
for i := 0 ; i < A . rows ; i ++ { # for j := 0 ; j < A . cols ; j ++ { # A . SetElm ( i , j , a * A . GetElm ( i , j )) # } # }
cases := [] struct { # name string # inputs int # expect int # }{ # {" STR ", 5 , 4 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := firstBadVersion ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
h := append ( heights , - 1 ) # n := len ( h ) # # var maxArea , height , left , right , area int # var stack [] int # # for right < n { # if len ( stack ) == 0 || h [ stack [ len ( stack )- 1 ]] <= h [ right ] { # stack = append ( stack , right ) # right ++ # continue # } # # height = h [ stack [ len ( stack )- 1 ]] # stack = stack [: len ( stack )- 1 ] # # if len ( stack ) == 0 { # left = - 1 # } else { # left = stack [ len ( stack )- 1 ] # } # # area = ( right - left - 1 ) * height # if maxArea < area { # maxArea = area # } # } # # return maxArea
srcFile , err := os . Open (" STR ") # if err != nil { # log . Fatalln ( err ) # } # defer srcFile . Close () # # scanner := bufio . NewScanner ( srcFile ) # for scanner . Scan () { # line := scanner . Text () # fmt . Println (" STR ", line ) # }
t . Parallel () # for _ , tc := range testcases { # q := NewQueue () # for _ , v := range tc . inserts { # q . Enqueue ( v ) # } # for _ , v := range tc . inserts { # if res , err := q . Dequeue (); err != nil { # t . Errorf (" STR ") # } else if res != v { # t . Errorf (" STR ", v , res ) # } # } # if _ , err := q . Dequeue (); err == nil { # t . Errorf (" STR ") # } # }
n := len ( Profits ) # pl := make ([]* project , n ) # for i := 0 ; i < n ; i ++ { # pl [ i ] = & project { # profit : Profits [ i ], # capital : Capital [ i ], # } # } # # sort . Slice ( pl , func ( i , j int ) bool { # return pl [ i ]. capital < pl [ j ]. capital # }) # # ph := make ( projectHeap , 0 , n ) # i := 0 # for k > 0 { # for i < n && pl [ i ]. capital <= W { # heap . Push (& ph , pl [ i ]) # i ++ # } # # if len ( ph ) == 0 { # break # } # W += heap . Pop (& ph ).(* project ). profit # k -- # } # return W
var tests = [] struct { # s string # IPs [] string # }{ # {" STR ", [] string {" STR "}}, # {" STR ", [] string {" STR "}}, # {" STR ", [] string {" STR ", " STR ", " STR "}}, # {" STR ", [] string {" STR ", " STR ", " STR ", " STR "}}, # {" STR ", [] string {" STR ", " STR "}}, # } # # for _ , tt := range tests { # IPs := restoreIpAddresses ( tt . s ) # if reflect . DeepEqual ( IPs , tt . IPs ) == false { # t . Errorf (" STR ", tt . s , IPs , tt . IPs ) # } # }
fmt . Println ( findAndReplacePattern ([] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, " STR "))
left , right := 0 , len ( nums )- 1 # for left < right { # mid := left + ( right - left )/ 2 # if nums [ mid ] < target { # left = mid + 1 # } else { # right = mid # } # } # if target > nums [ left ] { # left ++ # } # return left
var z [] int # zlen := len ( x ) + len ( y ) # if zlen <= cap ( x ) { # z = x [: zlen ] # } else { # zcap := zlen # if zcap < 2 * len ( x ) { # zcap = 2 * len ( x ) # } # z = make ([] int , zlen , zcap ) # copy ( z , x ) # } # copy ( z [ len ( x ):], y ) # return z
return a / b , a % b
m := make ( map [ int ] int , len ( nums )) # for _ , num := range nums { # m [ num ]++ # } # # counts := make ([][ 2 ] int , 0 , len ( m )) # for num , count := range m { # counts = append ( counts , [ 2 ] int { count , num }) # } # sort . Slice ( counts , func ( i , j int ) bool { # return counts [ i ][ 0 ] > counts [ j ][ 0 ] # }) # # res := make ([] int , k ) # for i := 0 ; i < k ; i ++ { # res [ i ] = counts [ i ][ 1 ] # } # return res
if num 1 == " STR " || num 2 == " STR " { # return " STR " # } # len 1 , len 2 := len ( num 1 ), len ( num 2 ) # product := make ([] int , len 1 + len 2 ) # # for i := 0 ; i < len 1 ; i ++ { # for j := 0 ; j < len 2 ; j ++ { # product [ i + j + 1 ] += int ( num 1 [ i ]-' 0 ') * int ( num 2 [ j ]-' 0 ') # } # } # # for i := len ( product ) - 1 ; i > 0 ; i -- { # product [ i - 1 ] += product [ i ] / 1 0 # product [ i ] = product [ i ] % 1 0 # } # # if product [ 0 ] == 0 { # product = product [ 1 :] # } # # bs := make ([] byte , len ( product )) # for i , v := range product { # bs [ i ] = ' 0 ' + byte ( v ) # } # return string ( bs )
var res [][] int # if root == nil { # return res # } # queue := []* TreeNode { root } # # for len ( queue ) > 0 { # l := len ( queue ) # list := make ([] int , 0 ) # for i := 0 ; i < l ; i ++ { # node := queue [ i ] # list = append ( list , node . Val ) # if node . Left != nil { # queue = append ( queue , node . Left ) # } # if node . Right != nil { # queue = append ( queue , node . Right ) # } # } # res = append ([][] int { list }, res ...) # queue = queue [ l :] # } # return res
cases := [] struct { # name string # inputs int # expect string # }{ # {" STR ", 3 , " STR "}, # {" STR ", 4 , " STR "}, # {" STR ", 9 , " STR "}, # {" STR ", 5 8 , " STR "}, # {" STR ", 1 9 9 4 , " STR "}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := intToRoman ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
location := [ 1 0 0 1 ] int {} # for _ , t := range trips { # num , start , end := t [ 0 ], t [ 1 ], t [ 2 ] # location [ start ] += num # location [ end ] -= num # } # # p := 0 # for _ , c := range location { # p += c # if p > capacity { # return false # } # } # return true
head := & ListNode {} # cur := head # # for _ , num := range nums { # cur . Next = & ListNode { Val : num } # cur = cur . Next # } # return head . Next
m , ans := make ( map [ rune ] int ), 0 # # for _ , v := range S { # m [ v ]++ # } # # for _ , v := range J { # ans += m [ v ] # } # # return ans
var urls = [] struct { # url string # statusCode int # }{ # { # " http : , # http . StatusOK , # }, # { # " http : , # http . StatusNotFound , # }, # } # # t . Log (" STR ") # { # for _ , u := range urls { # t . Logf (" STR ", # u . url , u . statusCode ) # { # resp , err := http . Get ( u . url ) # if err != nil { # t . Fatal (" STR ", # ballotX , err ) # } # t . Log (" STR ", # checkMark ) # # defer resp . Body . Close () # # if resp . StatusCode == u . statusCode { # t . Logf (" STR ", # u . statusCode , checkMark ) # } else { # t . Errorf (" STR ", # u . statusCode , ballotX , resp . StatusCode ) # } # } # } # }
oldBackets := h . backets # h . Init ( cap ) # for _ , v := range oldBackets { # if v != nil { # h . HashInsert ( v . Key , v . Value ) # } # }
result := 0 # for _ , num := range nums { # result ^= num # } # # return result
end , count := 0 , 1 # # for i , char := range chars { # if i + 1 < len ( chars ) && char == chars [ i + 1 ] { # count ++ # } else { # chars [ end ] = char # end ++ # # if count > 1 { # for _ , num := range strconv . Itoa ( count ) { # chars [ end ] = byte ( num ) # end ++ # } # } # # count = 1 # } # } # # return end
maxArea , n := 0 . 0 , len ( points ) # for i := 0 ; i < n ; i ++ { # for j := i + 1 ; j < n ; j ++ { # for k := j + 1 ; k < n ; k ++ { # maxArea = max ( maxArea , area ( points [ i ], points [ j ], points [ k ])) # } # } # } # return maxArea
qs := [] question 4 0 9 { # # { # para 4 0 9 {" STR "}, # ans 4 0 9 { 7 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 0 9 , q . para 4 0 9 # fmt . Printf (" STR ", p , longestPalindrome ( p . one )) # } # fmt . Printf (" STR ")
countingArr := make ([] int , bias + 1 , bias + 1 ) # retArr = make ([] int , len ( arr ), cap ( arr )) # for _ , v := range arr { # countingArr [ v ]++ # } # for i := 1 ; i < len ( countingArr ); i ++ { # countingArr [ i ] += countingArr [ i - 1 ] # } # for i := len ( arr ) - 1 ; i >= 0 ; i -- { # retArr [ countingArr [ arr [ i ]]- 1 ] = arr [ i ] # countingArr [ arr [ i ]]-- # } # return
if num <= 1 { # return false # } # sum , bound := 1 , int ( math . Sqrt ( float 6 4 ( num )))+ 1 # for i := 2 ; i < bound ; i ++ { # if num % i != 0 { # continue # } # corrDiv := num / i # sum += corrDiv + i # } # return sum == num
m := len ( matrix ) # if m == 0 { # return false # } # n := len ( matrix [ 0 ]) # if n == 0 { # return false # } # # i , j := m - 1 , 0 # for 0 <= i && j < n { # if matrix [ i ][ j ] == target { # return true # } # # if matrix [ i ][ j ] < target { # j ++ # } else { # i -- # } # } # return false
t := & Thing {} # for _ , opt := range opts { # opt ( t ) # } # return t
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 3 , 2 }, 3 }, # {" STR ", [] int { 7 , 3 }, 2 8 }, # {" STR ", [] int { 1 , 1 }, 1 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := uniquePaths ( c . inputs [ 0 ], c . inputs [ 1 ]) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
fmt . Println ( numSpecialEquivGroups ([] string {" STR ", " STR ", " STR "})) # fmt . Println ( numSpecialEquivGroups ([] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "})) # fmt . Println ( numSpecialEquivGroups ([] string {" STR ", " STR ", " STR ", " STR "}))
dummy := & ListNode { # Next : head , # } # # node := dummy # for node != nil { # next 1 , next 2 := node . Next , node . Next # for next 2 != nil && next 2 . Val == next 1 . Val { # next 2 = next 2 . Next # } # # if next 1 != nil && next 2 != next 1 . Next { # node . Next = next 2 # } else { # node = next 1 # } # } # # return dummy . Next
if len ( triangle ) == 0 || len ( triangle [ 0 ]) == 0 { # return 0 # } # # for i := len ( triangle ) - 2 ; i >= 0 ; i -- { # for j := len ( triangle [ i ]) - 1 ; j >= 0 ; j -- { # triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]) # } # } # return triangle [ 0 ][ 0 ]
m , n := len ( grid ), len ( grid [ 0 ]) # res := 0 # var dfs func ( int , int ) int # dfs = func ( i , j int ) int { # if i < 0 || i >= m || j < 0 || j >= n || grid [ i ][ j ] == 0 { # return 0 # } # grid [ i ][ j ] = 0 # return 1 + dfs ( i + 1 , j ) + dfs ( i - 1 , j ) + dfs ( i , j + 1 ) + dfs ( i , j - 1 ) # } # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # res = max ( res , dfs ( i , j )) # } # } # return res
return MyCalendarThree { # m : make ( map [ int ] int ), # }
br := [] int {} # for num > 0 { # br = append ( br , num % 2 ) # num /= 2 # } # n := len ( br ) # a , b := make ([] int , n ), make ([] int , n ) # a [ 0 ], b [ 0 ] = 1 , 1 # # for i := 1 ; i < n ; i ++ { # a [ i ] = a [ i - 1 ] + b [ i - 1 ] # b [ i ] = a [ i - 1 ] # } # # res := a [ n - 1 ] + b [ n - 1 ] # for i := n - 2 ; i >= 0 ; i -- { # if br [ i ] == 1 && br [ i + 1 ] == 1 { # break # } # if br [ i ] == 0 && br [ i + 1 ] == 0 { # res -= b [ i ] # } # } # return res
if len ( s 1 ) != len ( s 2 ) { # return false # } # m := make ( map [ rune ] rune ) # for i , r := range s 1 { # if t , exists := m [ r ]; exists && rune ( s 2 [ i ]) != t { # return false # } else if ! exists { # m [ r ] = rune ( s 2 [ i ]) # } # } # return true
return & DirGraph { # graph { # edgesCount : 0 , # edges : make ( map [ VertexId ] map [ VertexId ] int ), # isDirected : true , # }, # }
sums , cnts := dfs ( nil , nil , 0 , root ) # for i , cnt := range cnts { # sums [ i ] /= float 6 4 ( cnt ) # } # return sums
if len ( nums ) == 0 { # return 0 # } # last , finder := 0 , 0 # for last < len ( nums )- 1 { # for nums [ finder ] == nums [ last ] { # finder ++ # if finder == len ( nums ) { # return last + 1 # } # } # nums [ last + 1 ] = nums [ finder ] # last ++ # } # return last + 1
type Person struct { # Name string # Number int # } # # type Access struct { # Person Person # HasPermission bool # LastAccessed time . Time # } # # access := & Access { # Person : Person { Name : " STR ", Number : 1 2 3 4 5 6 7 }, # LastAccessed : time . Now (), # HasPermission : true , # } # # s := New ( access ) # # p := s . Field (" STR ") # # name := p . Field (" STR ") # # fmt . Printf (" STR ", name . Value ()) # #
t := [ 2 6 ] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "} # m := map [ string ] struct {}{} # for _ , word := range words { # bs := strings . Builder {} # for i := 0 ; i < len ( word ); i ++ { # bs . WriteString ( t [ word [ i ]-' a ']) # } # m [ bs . String ()] = struct {}{} # } # return len ( m )
t . Parallel () # for _ , tc := range testcases { # if result := LookAndSay ( tc . n ); result != tc . result { # t . Errorf (" STR ", tc . result , result ) # } # }
n := len ( letters ) # i := sort . Search ( n , func ( i int ) bool { # return target < letters [ i ] # }) # return letters [ i % n ]
cases := [] struct { # name string # inputs [] int # expect int # }{ # { # " STR ", # [] int { 1 0 0 , 4 , 2 0 0 , 1 , 3 , 2 }, # 4 , # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := longestConsecutive ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", c . expect , got , c . inputs ) # } # }) # }
i , j := 0 , len ( a )- 1 # for { # for i < j && a [ i ]% 2 == 0 { # i ++ # } # for i < j && a [ j ]% 2 == 1 { # j -- # } # # if i < j { # a [ i ], a [ j ] = a [ j ], a [ i ] # } else { # break # } # # } # return a
var stack [] int # result := make ([] int , len ( nums )) # for i := len ( nums ) - 1 ; i >= 0 ; i -- { # for len ( stack ) > 0 && stack [ len ( stack )- 1 ] <= nums [ i ] { # stack = stack [: len ( stack )- 1 ] # } # if len ( stack ) == 0 { # result [ i ] = - 1 # } else { # result [ i ] = stack [ len ( stack )- 1 ] # } # stack = append ( stack , nums [ i ]) # fmt . Println (" STR ", stack , nums [ i ]) # } # return result
testCases := [][] int { # { 1 , 3 , 5 , 6 }, # { 1 , 3 , 5 , 6 }, # { 1 , 3 , 5 , 6 }, # { 1 , 3 , 5 , 6 }, # } # targets := [] int { 5 , 2 , 7 , 0 } # # expected := [] int { 2 , 1 , 4 , 0 } # # for index , nums := range testCases { # if res := searchInsert ( nums , targets [ index ]); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
if v < min { # return min # } else if v > max { # return max # } else { # return v # }
if len ( nums ) == 0 { # return # } # # r := 0 # w := 0 # b := 0 # for _ , num := range nums { # if num == 0 { # nums [ b ] = 2 # b ++ # nums [ w ] = 1 # w ++ # nums [ r ] = 0 # r ++ # } else if num == 1 { # nums [ b ] = 2 # b ++ # nums [ w ] = 1 # w ++ # } else if num == 2 { # b ++ # } # }
t . Parallel () # for _ , tc := range testcases { # if sorted := SortK ( tc . nums , tc . k ); ! reflect . DeepEqual ( sorted , tc . sorted ) { # t . Errorf (" STR ", tc . sorted , sorted ) # } # }
rets := make ([] int , rowIndex + 1 ) # rets [ 0 ] = 1 # for i := 1 ; i <= rowIndex ; i ++ { # rets [ i ] = 1 # for j := i - 1 ; j > 0 ; j -- { # rets [ j ] += rets [ j - 1 ] # } # } # return rets
var maxarea , left , right , area int = 0 , 0 , len ( height )- 1 , 0 # # for left < right { # # area = ( right - left ) * calu 3 ( height [ left ], height [ right ]) # maxarea = calu 3 ( area , maxarea ) # # if height [ left ] < height [ right ] { # # left ++ # # for left < right && height [ left - 1 ] >= height [ left ] { # left ++ # } # # } else { # # right -- # # for right > left && height [ right + 1 ] >= height [ right ] { # right -- # } # # } # } # # return maxarea #
testCases := [][]* ListNode { # { # createSingleList ([] int { 1 , 4 , 5 }), # createSingleList ([] int { 2 , 3 , 4 }), # createSingleList ([] int { 4 , 6 }), # }, # { # createSingleList ([] int {}), # createSingleList ([] int { 4 , 5 }), # createSingleList ([] int {}), # }, # { # createSingleList ([] int {}), # createSingleList ([] int {}), # createSingleList ([] int {}), # }, # { # createSingleList ([] int { 1 , 4 , 5 }), # createSingleList ([] int { 1 , 3 , 4 }), # createSingleList ([] int { 2 , 6 }), # }, # } # # expected := []* ListNode { # createSingleList ([] int { 1 , 2 , 3 , 4 , 4 , 4 , 5 , 6 }), # createSingleList ([] int { 4 , 5 }), # nil , # createSingleList ([] int { 1 , 1 , 2 , 3 , 4 , 4 , 5 , 6 }), # } # # for index , lists := range testCases { # if res := mergeKLists ( lists ); ! reflect . DeepEqual ( res , expected [ index ]) { # t . Errorf (" STR ", expected [ index ], res ) # } # }
t . Parallel () # for _ , tc := range testcases { # if result := MinimumRooms ( tc . lectures ); result != tc . roomsNeeded { # t . Errorf (" STR ", tc . roomsNeeded , result ) # } # }
if v == 0 { # return " STR ", nil # } # s := make ([] string , 0 ) # vn := uint 6 4 ( 1 ) # for vn != uint 6 4 ( 0 x 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ) { # if ( v & vn ) != 0 { # sn , ok := this . values [ vn ] # if ! ok { # return " STR ", vn # } # s = append ( s , sn ) # } # vn <<= 1 # } # return strings . Join ( s , " STR "), nil
if len ( nums ) == 0 { # return false # } # for i := 1 ; i < len ( nums ); i ++ { # j := 0 # if i - k > 0 { # j = i - k # } # for ; j >= 0 && j < i ; j ++ { # if abs ( nums [ i ]- nums [ j ]) <= t { # return true # } # } # } # return false
fmt . Println (" STR ") # fmt . Println (" STR ", message )
var e struct {} # # for buffer := 0 ; buffer < buffers ; buffer ++ { # s <- e # }
timer := & Timer {} # return timer
dp := make ([] int , len ( s )+ 1 ) # for i := range dp { # dp [ i ] = 1 # } # # for i := range t { # prev := dp [ 0 ] # dp [ 0 ] = 0 # for j := range s { # cur := dp [ j ] # if t [ i ] == s [ j ] { # cur += prev # } # # prev , dp [ j + 1 ] = dp [ j + 1 ], cur # } # } # # return dp [ len ( s )]
nums := [] int { 1 , 1 , 0 , 1 , 1 , 1 } # # fmt . Println ( findMaxConsecutiveOnes ( nums ))
n := len ( nums ) # taken := make ([] bool , n ) # res := [][] int {} # # var makePermutation func ( cur int , vector [] int ) # makePermutation = func ( cur int , vector [] int ) { # if cur == n { # tmp := make ([] int , n ) # copy ( tmp , vector ) # res = append ( res , tmp ) # return # } # # for i := 0 ; i < n ; i ++ { # if ! taken [ i ] { # taken [ i ] = true # vector [ cur ] = nums [ i ] # makePermutation ( cur + 1 , vector ) # taken [ i ] = false # } # } # } # # makePermutation ( 0 , make ([] int , n )) # return res
tests := [...] castType { # { # nums : [] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 }, # k : 3 , # want : [] int { 5 , 6 , 7 , 1 , 2 , 3 , 4 }, # }, # { # nums : [] int {- 1 , - 1 0 0 , 3 , 9 9 }, # k : 2 , # want : [] int { 3 , 9 9 , - 1 , - 1 0 0 }, # }, # { # nums : [] int {- 1 }, # k : 2 , # want : [] int {- 1 }, # }, # } # # for _ , tt := range tests { # got := make ([] int , len ( tt . nums )) # copy ( got , tt . nums ) # rotate ( got , tt . k ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . nums , tt . k , got , tt . want ) # } # }
type arg struct { # n , k int # } # # testCases := [] arg { # { n : 0 , k : 2 }, # { n : 2 , k : 0 }, # { n : 1 , k : 5 }, # { n : 4 , k : 2 }, # } # expected := [][][] int { # {}, # {}, # {}, # {{ 1 , 2 }, { 1 , 3 }, { 1 , 4 }, { 2 , 3 }, { 2 , 4 }, { 3 , 4 }}, # } # # for index , data := range testCases { # if res := combine ( data . n , data . k ); ! reflect . DeepEqual ( res , expected [ index ]) { # t . Errorf (" STR ", expected [ index ], res ) # } # }
fakeHead := & LL { 0 , head } # # for start := fakeHead ; start != nil ; start = start . Next { # var sum int # # var farthest * LL # # var found bool # # for next := start . Next ; next != nil ; next = next . Next { # sum += next . Value # if sum == 0 { # farthest = next . Next # found = true # } # } # # if found { # start . Next = farthest # } # } # # return fakeHead . Next
isLand , neighbours := 0 , 0 # # for i := 0 ; i < len ( grid ); i ++ { # for j := 0 ; j < len ( grid [ i ]); j ++ { # if 1 == grid [ i ][ j ] { # isLand ++ # if i < len ( grid )- 1 && 1 == grid [ i + 1 ][ j ] { # neighbours ++ # } # if j < len ( grid [ i ]) - 1 && 1 == grid [ i ][ j + 1 ] { # neighbours ++ # } # } # } # } # return isLand * 4 - neighbours * 2
count := 0 # current := list . head # for current != nil { # count += 1 # current = current . next # } # return count
p . m . Lock () # defer p . m . Unlock () # # if p . closed { # return # } # # p . closed = true # # close ( p . resources ) # # for r := range p . resources { # r . Close () # }
res , left , right := 0 , 0 , 0 # for i := 0 ; i < len ( S ); i ++ { # left = i - 1 # for left >= 0 && S [ left ] != S [ i ] { # left -- # } # right = i + 1 # for right < len ( S ) && S [ right ] != S [ i ] { # right ++ # } # res += ( i - left ) * ( right - i ) # } # return res % 1 0 0 0 0 0 0 0 0 7
cases := [] struct { # name string # inputs string # expect string # }{ # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
d = new ( PostgresDriver ) # sql . Register (" STR ", d )
misses := 0 # bucks := float 6 4 ( 1 ) # for i := 0 ; i < flips ; i ++ { # if bucks < billion { # bucks *= ( 1 + 2 * f ) # } else { # bucks *= ( 1 - f ) # misses ++ # } # } # if bucks >= billion { # return misses # } # if misses > 0 { # return misses - 1 # } # # return 0 #
if p == nil { # return q == nil # } # if q == nil { # return p == nil # } # if p . Val == q . Val { # return isSameTree ( p . Left , q . Left ) && isSameTree ( p . Right , q . Right ) # } # return false
var palindromics [] int 6 4 # for a := 1 ; a < 1 0 ; a ++ { # for b := 0 ; b < 1 0 ; b ++ { # for c := 0 ; c < 1 0 ; c ++ { # palindromic , err := strconv . ParseInt ( fmt . Sprintf (" STR ", a , b , c , c , b , a ), 1 0 , 0 ) # if err != nil { # log . Fatal ( err ) # } # palindromics = append ( palindromics , palindromic ) # } # } # } # # var palindromic int 6 4 # for _ , p := range palindromics { # for i := int 6 4 ( 1 0 0 ); i < 1 0 0 0 ; i ++ { # if p % i == 0 { # result := p / i # if result <= 9 9 9 { # palindromic = p # } # } # } # } # # fmt . Println ( palindromic )
plates := make ([]* plate , 1 , 1 0 2 4 ) # plates [ 0 ] = newPlate ( capacity ) # return DinnerPlates { # cap : capacity , # in : 0 , # out : - 1 , # plates : plates , # }
for _ , tc := range testCases { # t . Run ( tc . name , func ( t * testing . T ) { # actual := f ( tc . a , tc . b ) # if actual != tc . output { # t . Errorf (" STR ", tc . a , tc . b , tc . output , actual ) # } # }) # }
abunList = list . New () # limit = 2 8 1 2 4 # writable = make ([] bool , limit ) # for i := 1 ; i < limit ; i ++ { # writable [ i ] = false # if i < sumOfProperDivisors ( i ) { # abunList . PushBack ( i ) # } # } # # checkWritables () # # sum := 0 # for i := 1 ; i < limit ; i ++ { # if ! writable [ i ] { # sum += i # } # } # println ( sum )
m . Employee . PrintDetails () # fmt . Println (" STR ") # for _ , v := range m . Projects { # fmt . Println ( v ) # } # fmt . Println (" STR ") # for _ , v := range m . Locations { # fmt . Println ( v ) # }
qs := [] question 3 4 4 { # # { # para 3 4 4 {[] byte {' h ', ' e ', ' l ', ' l ', ' o '}}, # ans 3 4 4 {[] byte {' o ', ' l ', ' l ', ' e ', ' h '}}, # }, # # { # para 3 4 4 {[] byte {' H ', ' a ', ' n ', ' n ', ' a ', ' h '}}, # ans 3 4 4 {[] byte {' h ', ' a ', ' n ', ' n ', ' a ', ' H '}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 4 4 , q . para 3 4 4 # fmt . Printf (" STR ", p . one ) # reverseString ( p . one ) # fmt . Printf (" STR ", p . one ) # } # fmt . Printf (" STR ")
fmt . Println ( convertToTitle ( 2 7 ))
sum := 0 # fib := 1 # prevFib := 1 # for fib <= 4 0 0 0 0 0 0 { # prevFib , fib = fib , prevFib + fib # if fib % 2 == 0 { # sum += fib # } # } # fmt . Println ( sum )
if N == 0 { # return " STR " # } # # B := make ([] byte , 0 , 3 0 ) # for N > 0 { # switch N & 3 { # case 0 , 1 : # B = append ( B , byte ( N & 1 )+' 0 ', ' 0 ') # default : # B = append ( B , byte ( N & 1 )+' 0 ', ' 1 ') # N += 4 # } # N >>= 2 # } # # swap ( B ) # # if B [ 0 ] == ' 0 ' { # B = B [ 1 :] # } # # return string ( B )
nodes := [] int { # 1 , 2 , 3 , 4 , 5 , 6 , # } # # edges := [][] bool { # { false , true , true , false , false , false }, # { true , false , false , true , false , false }, # { true , false , false , true , false , false }, # { false , true , true , false , true , false }, # { false , false , false , true , false , true }, # { false , false , false , false , true , false }, # } # # start := 1 # end := 6 # # actual , actualIsFound := DepthFirstSearch ( start , end , nodes , edges ) # expected := [] int { 1 , 3 , 4 , 5 , 6 } # expectedIsFound := true # t . Run (" STR ", func ( t * testing . T ) { # if ! reflect . DeepEqual ( expected , actual ) || ! reflect . DeepEqual ( actualIsFound , expectedIsFound ) { # t . Errorf (" STR ", actual , expected ) # t . Errorf (" STR ", actualIsFound , expectedIsFound ) # } # })
for _ , sym := range symbolList { # if address >= sym . Address && address < sym . Address + sym . Size { # return sym # } # } # return nil
b := [] byte ( s ) # for l , r := 0 , len ( s )- 1 ; l < r ; l , r = l + 1 , r - 1 { # for l < r && ! isVowels ( b [ l ]) { # l ++ # } # for l < r && ! isVowels ( b [ r ]) { # r -- # } # b [ l ], b [ r ] = b [ r ], b [ l ] # } # return string ( b )
n := len ( nums ) # if n == 0 { # return 0 # } # if n == 1 { # return nums [ 0 ] # } # if n == 2 { # return max ( nums [ 0 ], nums [ 1 ]) # } # return max ( rob 2 1 3 _ 1 ( nums , 0 , n - 2 ), rob 2 1 3 _ 1 ( nums , 1 , n - 1 ))
for run := 0 ; run < runs ; run ++ { # baked := make ( chan cake , s . BakeBuf ) # iced := make ( chan cake , s . IceBuf ) # go s . baker ( baked ) # for i := 0 ; i < s . NumIcers ; i ++ { # go s . icer ( iced , baked ) # } # s . inscriber ( iced ) # }
val := self . data [ 0 ] # self . data = self . data [ 1 :] # return val
t . Parallel () # for _ , tc := range testcases { # if result := StrobogrammaticNumber ( tc . digits ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
qs := [] question 5 3 { # # { # para 5 3 {[] int {- 2 , 1 , - 3 , 4 , - 1 , 2 , 1 , - 5 , 4 }}, # ans 5 3 { 6 }, # }, # { # para 5 3 {[] int { 2 , 7 , 9 , 3 , 1 }}, # ans 5 3 { 2 2 }, # }, # # { # para 5 3 {[] int { 2 }}, # ans 5 3 { 2 }, # }, # # { # para 5 3 {[] int {- 1 , - 2 }}, # ans 5 3 {- 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 3 , q . para 5 3 # fmt . Printf (" STR ", p , maxSubArray ( p . one )) # } # fmt . Printf (" STR ")
n := len ( A ) # maxRightIs := make ([] int , n ) # maxLeftIs := make ([] int , n ) # maxRightIs [ 0 ] = A [ 0 ] # maxLeftIs [ n - 1 ] = A [ n - 1 ] # res := A [ 0 ] # for i := 1 ; i < n ; i ++ { # maxRightIs [ i ] = max ( A [ i ], maxRightIs [ i - 1 ]+ A [ i ]) # j := n - i - 1 # maxLeftIs [ j ] = max ( A [ j ], A [ j ]+ maxLeftIs [ j + 1 ]) # res = max ( res , maxRightIs [ i ]) # } # for i := 1 ; i < n - 1 ; i ++ { # res = max ( res , maxRightIs [ i - 1 ]+ maxLeftIs [ i + 1 ]) # } # return res
profit := 0 # for i := 1 ; i < len ( prices ); i ++ { # if prices [ i ] > prices [ i - 1 ] { # profit += prices [ i ] - prices [ i - 1 ] # } # } # return profit
return ValueOf ( i ). typecode
cases := [] struct { # name string # inputs [] Interval # expect [] Interval # }{ # {" STR ", # [] Interval { # Interval { Start : 1 , End : 3 }, # Interval { Start : 1 5 , End : 1 8 }, # Interval { Start : 2 , End : 6 }, # Interval { Start : 8 , End : 1 0 }, # }, # [] Interval { # Interval { Start : 1 , End : 6 }, # Interval { Start : 8 , End : 1 0 }, # Interval { Start : 1 5 , End : 1 8 }, # }}, # {" STR ", # [] Interval { # Interval { Start : 1 , End : 4 }, # Interval { Start : 4 , End : 5 }, # }, # [] Interval { # Interval { Start : 1 , End : 5 }, # }}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := merge ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
max := arr [ 0 ] # for _ , item := range arr { # if item > max { # max = item # } # } # return max
n := len ( A ) # swap , fix := 1 , 0 # for i := 1 ; i < n ; i ++ { # if A [ i - 1 ] >= B [ i ] || B [ i - 1 ] >= A [ i ] { # swap ++ # } else if A [ i - 1 ] >= A [ i ] || B [ i - 1 ] >= B [ i ] { # swap , fix = fix + 1 , swap # } else { # tmp := min ( swap , fix ) # swap , fix = tmp + 1 , tmp # } # } # return min ( swap , fix )
if len ( triangle ) == 0 || len ( triangle [ 0 ]) == 0 { # return 0 # } # _dfs ( triangle , 0 , 0 , " STR ", 0 ) # # return minSum
if nil == nums || len ( nums ) < 1 { # return 0 # } # # start , end := 0 , len ( nums )- 1 # for start <= end { # middle := ( start + end ) / 2 # if nums [ middle ] == target { # return middle # } else if nums [ middle ] < target { # start = middle + 1 # } else { # end = middle - 1 # } # } # return start
var tests = [] struct { # tree * TreeNode # diameter int # }{ # { newTree ( 1 , 2 , 3 , 4 , 5 ), 3 }, # { newTree ( 1 , 2 , 3 , nil , nil , 4 , 5 ), 3 }, # } # # for _ , tt := range tests { # diameter := diameterOfBinaryTree ( tt . tree ) # if diameter != tt . diameter { # t . Errorf (" STR ", tt . tree , diameter , tt . diameter ) # } # }
t . Parallel () # for _ , tc := range testcases { # if result := MaxWrapSubarraySum ( tc . nums ); result != tc . maxSum { # t . Errorf (" STR ", tc . maxSum , result ) # } # }
nums := [] int { 0 , 1 , 2 , 2 , 3 , 0 , 4 , 2 } # val := 2 # expected := 5 # # if res := removeElement ( nums , val ); res != expected { # t . Errorf (" STR ", expected , res ) # }
n := len ( nums ) # sort . Ints ( nums ) # med := nums [ n / 2 ] # # i , l , r := 0 , 0 , n - 1 # for i <= r { # index := mapIndex ( i , n ) # if nums [ index ] > med { # swap ( nums , mapIndex ( l , n ), index ) # l ++ # i ++ # } else if nums [ index ] < med { # swap ( nums , mapIndex ( r , n ), index ) # r -- # } else { # i ++ # } # }
var err error # _ , err = los . Stat ( filename ) # return err == nil || los . IsExist ( err )
for _ , test := range searchTests { # actual := Binary ( test . data , test . key , 0 , len ( test . data )- 1 ) # if actual != test . expected { # t . Errorf (" STR ", test . name ) # } # }
qs := [] question 1 7 4 { # # { # para 1 7 4 {[][] int {{ 2 , 1 }, { 1 , - 1 }}}, # ans 1 7 4 { 1 }, # }, # # { # para 1 7 4 {[][] int {{- 3 , 5 }}}, # ans 1 7 4 { 4 }, # }, # # { # para 1 7 4 {[][] int {{ 1 0 0 }}}, # ans 1 7 4 { 1 }, # }, # # { # para 1 7 4 {[][] int {{- 2 , - 3 , 3 }, {- 5 , - 1 0 , 1 }, { 1 0 , 3 0 , - 5 }}}, # ans 1 7 4 { 7 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 7 4 , q . para 1 7 4 # fmt . Printf (" STR ", p , calculateMinimumHP 1 ( p . s )) # } # fmt . Printf (" STR ")
var chapts map [ int ] string # # chapts = make ( map [ int ] string ) # # chapts [ 1 ] = " STR " # chapts [ 2 ] = " STR " # chapts [ 3 ] = " STR " # # for k , v := range chapts { # fmt . Printf (" STR ", k , v ) # } # # langs := map [ string ] string { # " STR ": " STR ", # " STR ": " STR ", # " STR ": " STR ", # " STR ": " STR ", # " STR ": " STR ", # } # # delete ( langs , " STR ") # if lan , ok := langs [" STR "]; ok { # fmt . Println ( lan ) # } else { # fmt . Println (" STR ") # } # # langs [" STR "] = " STR " # for k , v := range langs { # fmt . Printf (" STR ", k , v ) # }
for _ , tagOpt := range t { # if tagOpt == opt { # return true # } # } # # return false
println (" STR ", s . next . next )
if len ( a ) != len ( b ) { # return false # } # # for i , v := range a { # if v != b [ i ] { # return false # } # } # # return true
if nil == head || nil == head . Next { # return # } # mid := findMid ( head ) # first , second := head , reverseList ( mid . Next ) # mid . Next = nil # # newHead := new ( ListNode ) # current := newHead # for first != nil || second != nil { # if first != nil { # current . Next = & ListNode { first . Val , nil } # current = current . Next # first = first . Next # } # if second != nil { # current . Next = & ListNode { second . Val , nil } # current = current . Next # second = second . Next # } # } # head . Next = newHead . Next . Next
if len ( nums ) == 0 { # return 0 # } # # if target <= nums [ 0 ] { # return 0 # } # # if target > nums [ len ( nums )- 1 ] { # return len ( nums ) # } # # for i := 0 ; i < len ( nums )- 1 ; i ++ { # if target > nums [ i ] && target <= nums [ i + 1 ] { # return i + 1 # } # } # return 0
var f = boilingF # var c = ( f - 3 2 ) * 5 / 9 # fmt . Printf (" STR ", f , c )
m , n := len ( num 1 ), len ( num 2 ) # if m == 0 { # return num 2 # } # if n == 0 { # return num 1 # } # if m > n { # m , n , num 1 , num 2 = n , m , num 2 , num 1 # } # carry := byte ( 0 ) # buf := make ([] byte , n + 1 ) # for i := 1 ; i <= n ; i ++ { # if i <= m { # buf [ n - i + 1 ] = num 1 [ m - i ] - ' 0 ' # } # buf [ n - i + 1 ] += num 2 [ n - i ] + carry # if buf [ n - i + 1 ] > ' 9 ' { # buf [ n - i + 1 ] -= 1 0 # carry = byte ( 1 ) # } else { # carry = byte ( 0 ) # } # } # if carry == 1 { # buf [ 0 ] = ' 1 ' # return string ( buf ) # } # return string ( buf [ 1 :])
if da . Capacity == 0 { # da . Capacity = defaultCapacity # } else { # da . Capacity = da . Capacity << 1 # } # # newDataElement := make ([] interface {}, da . Capacity ) # # copy ( newDataElement , da . ElementData ) # # da . ElementData = newDataElement
counter := make ( map [ rune ] int ) # for _ , r := range s { # counter [ r ]++ # } # answer := 0 # for _ , v := range counter { # answer += v / 2 * 2 # if answer % 2 == 0 && v % 2 == 1 { # answer ++ # } # } # return answer
amicableSum := 0 # # for i := 1 ; i < 1 0 0 0 0 ; i ++ { # # if i == d ( d ( i )) && i != d ( i ) { # amicableSum += i # } # } # # fmt . Println ( amicableSum ) #
cases := [] struct { # name string # s , t string # expect bool # }{ # {" STR ", " STR ", " STR ", true }, # {" STR ", " STR ", " STR ", false }, # {" STR ", " STR ", " STR ", false }, # {" STR ", " STR ", " STR ", true }, # {" STR ", " STR ", " STR ", true }, # {" STR ", " STR ", " STR ", true }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . s , c . t ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . s , c . t ) # } # }) # }
max := uint ( math . Ceil ( math . Sqrt ( float 6 4 ( n )))) # var i uint # for i = 2 ; i <= max ; i ++ { # if n % i == 0 { # return false # } # } # return true
a := [] float 6 4 { 1 , 2 , 3 , 4 } # A := MakeMatrix ( a , 2 , 2 ) # # if A . trace () != 5 { # t . Error () # }
sum := ( 1 + maxChoosableInteger ) * maxChoosableInteger / 2 # if sum < desiredTotal { # return false # } # # bit := make ([] int , maxChoosableInteger + 1 ) # for i := maxChoosableInteger ; i > 0 ; i -- { # bit [ i ] = 1 << uint 8 ( i ) # } # # dp := make ( map [ int ] bool , maxChoosableInteger * maxChoosableInteger ) # # return dfs ( 0 , desiredTotal , maxChoosableInteger , dp , bit )
if len ( matrix ) == 0 { # return 0 # } # m := len ( matrix ) # low , high := matrix [ 0 ][ 0 ], matrix [ m - 1 ][ m - 1 ] # for low < high { # mid := ( low + high ) / 2 # cc := helper ( matrix , mid ) # if cc < k { # low = mid + 1 # } else { # high = mid # } # } # return low
record := make ( map [ int ] int ) # for _ , num := range nums { # if _ , ok := record [ num ]; ok { # delete ( record , num ) # } else { # record [ num ] = 1 # } # } # var res int # for key := range record { # res = key # } # return res
ret := [][] int {} # if numRows == 0 { # return ret # } # ret = append ( ret , [] int { 1 }) # if numRows == 1 { # return ret # } # for i := 2 ; i <= numRows ; i ++ { # cur := [] int { 1 } # for j := 1 ; j < i - 1 ; j ++ { # cur = append ( cur , ret [ i - 2 ][ j - 1 ]+ ret [ i - 2 ][ j ]) # } # cur = append ( cur , 1 ) # ret = append ( ret , cur ) # } # return ret
if n <= 6 { # return n # } # # pos := [] int { 0 , 0 , 0 } # factors := [] int { 2 , 3 , 5 } # candidates := [] int { 2 , 3 , 5 } # # res := make ([] int , n ) # # res [ 0 ] = 1 # # for i := 1 ; i < n ; i ++ { # res [ i ] = min ( candidates ) # for j := 0 ; j < 3 ; j ++ { # if res [ i ] == candidates [ j ] { # pos [ j ]++ # candidates [ j ] = res [ pos [ j ]] * factors [ j ] # } # } # } # # return res [ n - 1 ]
if len ( nums ) == 0 { # return nil # } # # var max , maxi int # for i , num := range nums { # if num > max { # max = num # maxi = i # } # } # # return & TreeNode { # Val : max , # Left : constructMaximumBinaryTree ( nums [: maxi ]), # Right : constructMaximumBinaryTree ( nums [ maxi + 1 :]), # }
differenceSet := New () # for _ , item := range st . GetItems () { # if ! st 2 . In ( item ) { # differenceSet . Add ( item ) # } # } # return differenceSet
if len ( nums ) < 2 { # return # } # i := len ( nums ) - 1 # for ; i > 0 ; i -- { # if nums [ i - 1 ] < nums [ i ] { # break # } # } # if i != 0 { # for t := len ( nums ) - 1 ; t >= i ; t -- { # if nums [ t ] > nums [ i - 1 ] { # nums [ t ], nums [ i - 1 ] = nums [ i - 1 ], nums [ t ] # break # } # } # } # reverseSlice ( nums [ i :])
l := len ( nums ) # if l == 0 { # return 0 # } # if l == 1 { # return nums [ 0 ] # } # dp 1 , dp 2 := make ([] int , l ), make ([] int , l ) # dp 1 [ 0 ] = nums [ 0 ] # dp 1 [ 1 ] = max ( dp 1 [ 0 ], nums [ 1 ]) # dp 2 [ 0 ] = 0 # dp 2 [ 1 ] = max ( dp 2 [ 0 ], nums [ 1 ]) # for i := 2 ; i < l ; i ++ { # if i < l - 1 { # dp 1 [ i ] = max ( dp 1 [ i - 1 ], dp 1 [ i - 2 ]+ nums [ i ]) # } else { # dp 1 [ i ] = dp 1 [ i - 1 ] # } # dp 2 [ i ] = max ( dp 2 [ i - 1 ], dp 2 [ i - 2 ]+ nums [ i ]) # } # return max ( dp 1 [ l - 1 ], dp 2 [ l - 1 ])
h . tasks = tasks # h . schTaskList . init ( h , tasks ) # return h
point := int 6 4 ( 0 ) # # for i := int 6 4 ( 0 ); i <= to ; i ++ { # for eval ( i , point + 1 ) { # point ++ # } # store += point # } # store *= 4 # # if isOdd { # store -= 2 * point # } # # return store
server , err := net . Listen (" STR ", " STR ") # if err != nil { # log . Fatalln ( err . Error ()) # } # defer server . Close () # # chatServer := & ChatServer { # Users : make ( map [ string ] User ), # Join : make ( chan User ), # Leave : make ( chan User ), # Input : make ( chan Message ), # } # go chatServer . Run () # # for { # conn , err := server . Accept () # if err != nil { # log . Fatalln ( err . Error ()) # } # go handleConn ( chatServer , conn ) # }
return fmt . Sprintf (" STR ", r . First , r . Last , r . Description )
result := [][] string {} # current := make ([] string , 0 , len ( s )) # dfs ( s , 0 , current , & result ) # return result
tests := [...] testType { # { # A : " STR ", # B : " STR ", # want : true , # }, # { # A : " STR ", # B : " STR ", # want : false , # }, # { # A : " STR ", # B : " STR ", # want : false , # }, # } # for _ , tt := range tests { # got := rotateString ( tt . A , tt . B ) # if got != tt . want { # t . Fatalf (" STR ", tt . A , tt . B , got , tt . want ) # } # }
return MinStack {}
fmt . Fprintf ( w , " STR ", r . URL . Path )
prev , now := make ([] bool , len ( p )+ 1 ), make ([] bool , len ( p )+ 1 ) # for i := 0 ; i <= len ( s ); i ++ { # now , prev = prev , now # now [ 0 ] = i == 0 # for j := 1 ; j <= len ( p ); j ++ { # if p [ j - 1 ] == " STR " { # now [ j ] = prev [ j ] || prev [ j - 1 ] || now [ j - 1 ] # } else { # now [ j ] = prev [ j - 1 ] && ( s [ i - 1 ] == p [ j - 1 ] || p [ j - 1 ] == " STR ") # } # } # } # return now [ len ( p )]
return uint 3 2 ( id .( int ))
t . Parallel () # # for _ , tc := range testcases { # if result := StringMatchKMP ( tc . input , tc . substr ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
graph := make ( undirectedGraph ) # for _ , e := range edges { # if _ , found := graph [ e . Start ]; ! found { # graph [ e . Start ] = make ( map [ int ] struct {}) # } # if _ , found := graph [ e . End ]; ! found { # graph [ e . End ] = make ( map [ int ] struct {}) # } # graph [ e . Start ][ e . End ] = struct {}{} # graph [ e . End ][ e . Start ] = struct {}{} # } # visited := make ([] bool , len ( graph )) # disc := make ([] int , len ( graph )) # low := make ([] int , len ( graph )) # parent := make ([] int , len ( graph )) # for i := range disc { # disc [ i ] = int (^ uint ( 0 ) >> 1 ) # low [ i ] = int (^ uint ( 0 ) >> 1 ) # parent [ i ] = - 1 # } # var result [] Edge # for i := range visited { # if ! visited [ i ] { # result = findAllBridges ( graph , i , 0 , visited , parent , low , disc , result ) # } # } # return result
for i := 0 ; i < b . N ; i ++ { # a := big . NewInt ( 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 ) # mul ( a , a ) # }
switch c . fn { # case " STR ": # return math . Pow ( c . args [ 0 ]. Eval ( env ), c . args [ 1 ]. Eval ( env )) # case " STR ": # return math . Sin ( c . args [ 0 ]. Eval ( env )) # case " STR ": # return math . Sqrt ( c . args [ 0 ]. Eval ( env )) # } # panic ( fmt . Sprintf (" STR ", c . fn ))
sort . Ints ( nums ) # # longest := 0 # current := 1 # # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] == nums [ i - 1 ]+ 1 { # current ++ # } else { # if current > longest { # longest = current # } # current = 1 # } # } # # if current > longest { # longest = current # } # # return longest
ans := make ([] int , 1 ) # if nil != root { # dfs ( root , ans ) # } # return ans [ 0 ]
size := len ( A ) # res := make ([] int , size ) # for l , r , i := 0 , size - 1 , size - 1 ; l <= r ; i -- { # if A [ l ]+ A [ r ] < 0 { # res [ i ] = A [ l ] * A [ l ] # l ++ # } else { # res [ i ] = A [ r ] * A [ r ] # r -- # } # } # return res
cases := [] struct { # name string # head * ListNode # x int # expect * ListNode # }{ # {" STR ", MakeListNode ([] int { 1 , 4 , 3 , 2 , 5 , 2 }), 3 , MakeListNode ([] int { 1 , 2 , 2 , 4 , 3 , 5 })}, # {" STR ", MakeListNode ([] int {}), 0 , MakeListNode ([] int {})}, # {" STR ", MakeListNode ([] int { 1 , 4 , 3 , 2 , 5 , 2 }), 0 , MakeListNode ([] int { 1 , 4 , 3 , 2 , 5 , 2 })}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := Solution ( c . head , c . x ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . head , c . x ) # } # }) # }
if len ( grid ) == 0 || len ( grid [ 0 ]) == 0 { # return 0 # } # # max := func ( m , n int ) int { # return int ( math . Max ( float 6 4 ( m ), float 6 4 ( n ))) # } # # result := 0 # xProj , yProj := make ([] int , len ( grid [ 0 ])), make ([] int , len ( grid )) # for _ , row := range grid { # for j , num := range row { # xProj [ j ] = max ( xProj [ j ], num ) # if num > 0 { # result += 1 # } # } # } # # for i := 0 ; i < len ( grid [ 0 ]); i ++ { # for j := 0 ; j < len ( grid ); j ++ { # yProj [ j ] = max ( yProj [ j ], grid [ j ][ i ]) # } # } # # for _ , p := range xProj { # result += p # } # # for _ , p := range yProj { # result += p # } # # return result
ans , hash := 0 , make ([] int , 6 0 ) # for _ , t := range time { # v := t % 6 0 # if v == 0 { # ans += hash [ 0 ] # } else { # ans += hash [ 6 0 - v ] # } # hash [ v ]++ # } # return ans
int 6 4 Val := int 6 4 ( math . Float 6 4 bits ( value )) # self . SetLong ( index , int 6 4 Val )
lenA := len ( a ) # # if lenA == 0 { # return [] Interval { newItv } # } # # if newItv . End < a [ 0 ]. Start { # return append ([] Interval { newItv }, a ...) # } # # if a [ lenA - 1 ]. End < newItv . Start { # return append ( a , newItv ) # } # # res := make ([] Interval , 0 , len ( a )) # for i := range a { # if isOverlap ( a [ i ], newItv ) { # newItv = merge ( a [ i ], newItv ) # # if i == lenA - 1 { # res = append ( res , newItv ) # } # # continue # } # # if a [ i ]. End < newItv . Start { # res = append ( res , a [ i ]) # continue # } # # if newItv . End < a [ i ]. Start { # res = append ( res , newItv ) # res = append ( res , a [ i :]...) # break # } # # } # # return res
res := [] int {} # for i := left ; i <= right ; i ++ { # j := i # for j > 0 { # r := j % 1 0 # if r == 0 || i % r != 0 { # break # } # j /= 1 0 # } # if j == 0 { # res = append ( res , i ) # } # } # return res
testCases := [][] int { # { 1 0 , 5 , 2 , 6 }, # { 1 0 , 5 , 2 , 6 }, # { 1 0 , 5 , 1 0 0 , 6 }, # } # # ks := [] int { 1 0 0 , 0 , 1 0 0 } # expected := [] int { 8 , 0 , 4 } # # functions := [] func ([] int , int ) int { # numSubArrayProductLessThanK , # numSubArrayProductLessThanK 2 , # } # for _ , testFunc := range functions { # for index , data := range testCases { # if res := testFunc ( data , ks [ index ]); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # } # }
end := N >> 1 # for N >= end { # if ! strings . Contains ( S , binaryString ( N )) { # return false # } # N -- # } # return true
nodeG := TreeNode { Val : 1 , Left : nil , Right : nil } # nodeF := TreeNode { Val : 2 , Left : & nodeG , Right : nil } # nodeE := TreeNode { Val : 3 , Left : nil , Right : nil } # nodeD := TreeNode { Val : 4 , Left : & nodeE , Right : nil } # nodeC := TreeNode { Val : 5 , Left : nil , Right : nil } # nodeB := TreeNode { Val : 6 , Left : & nodeD , Right : & nodeF } # nodeA := TreeNode { Val : 7 , Left : & nodeB , Right : & nodeC } # # result := preorderTraversal (& nodeA ) # result 2 := preorderTraversal 2 (& nodeA ) # expected := [] int { 7 , 6 , 4 , 3 , 2 , 1 , 5 } # if ! reflect . DeepEqual ( result , expected ) && ! reflect . DeepEqual ( result 2 , expected ) { # t . Fatalf (" STR ", # expected , result ) # }
tests := [...] testType { # { # in : [] byte {' c ', ' f ', ' j '}, # target : ' a ', # want : ' c ', # }, # { # in : [] byte {' c ', ' f ', ' j '}, # target : ' c ', # want : ' f ', # }, # { # in : [] byte {' c ', ' f ', ' j '}, # target : ' d ', # want : ' f ', # }, # { # in : [] byte {' c ', ' f ', ' j '}, # target : ' g ', # want : ' j ', # }, # { # in : [] byte {' c ', ' f ', ' j '}, # target : ' j ', # want : ' c ', # }, # { # in : [] byte {' c ', ' f ', ' j '}, # target : ' k ', # want : ' c ', # }, # } # for _ , tt := range tests { # got := nextGreatestLetter ( tt . in , tt . target ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
even , odd := 0 , len ( A )- 1 # for even <= odd { # switch A [ even ] & 1 { # case 0 : # even ++ # case 1 : # A [ even ], A [ odd ] = A [ odd ], A [ even ] # odd -- # } # } # return A
n := len ( nums ) # if n < 2 { # return false # } # m := make ( map [ int ] int , n ) # m [ 0 ] = - 1 # # sum := 0 # for i , num := range nums { # sum += num # if k != 0 { # sum %= k # } # # if index , ok := m [ sum ]; ok { # if i - index > 1 { # return true # } # } else { # m [ sum ] = i # } # } # return false
l := strings . ToLower ( word ) # u := strings . ToUpper ( word ) # t := strings . ToUpper ( string ( word [: 1 ])) + strings . ToLower ( word [ 1 :]) # return l == word || u == word || t == word #
if head == nil { # return nil # } # # temp := head # # for temp . Next != nil { # if temp . Val == temp . Next . Val { # temp . Next = temp . Next . Next # } else { # temp = temp . Next # } # } # # return head
return WordDictionary {& node { next : make ( map [ byte ]* node )}}
tests := [...] testType { # { # in : [] byte {' h ', ' e ', ' l ', ' l ', ' o '}, # want : [] byte {' o ', ' l ', ' l ', ' e ', ' h '}, # }, # { # in : [] byte {' H ', ' a ', ' n ', ' n ', ' a ', ' h '}, # want : [] byte {' h ', ' a ', ' n ', ' n ', ' a ', ' H '}, # }, # } # for _ , tt := range tests { # got := make ([] byte , len ( tt . in )) # copy ( got , tt . in ) # reverseString ( got ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
count := [ 1 0 0 0 ] int {} # for _ , v := range answers { # count [ v ]++ # } # res := 0 # for v , c := range count { # if c == 0 { # continue # } # v ++ # res += c / v * v # if c % v > 0 { # res += v # } # } # return res
n := at . r # at . r = e # e . l = at # e . r = n # n . l = e # e . p = l . p # e . list = l # l . len ++ # return e
count := make ([] int , K ) # count [ 0 ] = 1 # p , res := 0 , 0 # for _ , a := range A { # p = ( p + a ) % K # if p < 0 { # p += K # } # res += count [ p ] # count [ p ]++ # } # return res
if len ( nums ) == 0 { # return 0 # } # # res = nums [ 0 ] # # for _ , num := range nums { # if num < res { # res = num # } # } # return
root := NewTree () # # if Get ( root , 5 ) != nil { # t . Error (" STR ") # } # # Insert (& root , 5 ) # Insert (& root , 4 ) # Insert (& root , 3 ) # # n := Get ( root , 4 ) # if n . Key != 4 { # t . Error (" STR ") # } # if n . Right . Key != 5 { # t . Error (" STR ") # } # # if n . Left . Key != 3 { # t . Error (" STR ") # } #
if l == r { # return nums [ l ] # } # mid := ( l + r ) >> 1 # lmax , lsum , rmax , rsum := nums [ mid ], 0 , nums [ mid + 1 ], 0 # # for i := mid ; i >= 1 ; i -- { # lsum += nums [ i ] # lmax = max ( lmax , lsum ) # } # # for i := mid + 1 ; i <= r ; i ++ { # rsum += nums [ i ] # rmax = max ( rmax , rsum ) # } # # return max ( max ( calc ( l , mid , nums ), calc ( mid + 1 , r , nums )), lmax + rmax )
return t . name
m := make ( map [ string ][] string ) # for _ , path := range paths { # fs := strings . Split ( path , " STR ") # p := fs [ 0 ] # for i := 1 ; i < len ( fs ); i ++ { # filename , content := splitFileNameAndContent ( fs [ i ]) # m [ content ] = append ( m [ content ], p +" STR "+ filename ) # } # } # # res := [][] string {} # for _ , files := range m { # if len ( files ) > 1 { # res = append ( res , files ) # } # } # return res
http . HandleFunc (" STR ", index ) # # server := & http . Server { # Addr : " STR ", # ReadTimeout : 6 0 * time . Second , # WriteTimeout : 6 0 * time . Second , # } # # log . Println (" STR ") # server . ListenAndServe ()
return float 6 4 ( s . totalCompletedTime ) / float 6 4 ( s . finishedCnt )
fmt . Println ( convertToBase 7 ( 7 )) # fmt . Println ( convertToBase 7 (- 7 )) # fmt . Println ( convertToBase 7 ( 1 0 0 ))
size := len ( A ) # res := make ([] int , 0 , size * 2 ) # for Ai := size ; Ai > 1 ; Ai -- { # if A [ Ai - 1 ] == Ai { # continue # } # i := Ai - 2 # for A [ i ] != Ai { # i -- # } # if i != 0 { # reverse ( A , i + 1 ) # res = append ( res , i + 1 ) # } # reverse ( A , Ai ) # res = append ( res , Ai ) # } # return res
println (" STR ", string ( r ))
X 0 , Y 0 , X 1 , Y 1 := max ( A , E ), max ( B , F ), min ( C , G ), min ( D , H ) # return area ( A , B , C , D ) + area ( E , F , G , H ) - area ( X 0 , Y 0 , X 1 , Y 1 )
nodeOrKeyValue , _ := n . getChildOrKeyValue ( key ) # if keyValue , ok := nodeOrKeyValue .(* keyValue ); ok { # keyValue . value = value # return nil # } # # if n . isFull () { # if n . p == nil { # n . p = bt . bTreeIf . newNode ( bt . t ) # n . p . isLeaf = false # bt . root = n . p # bt . height ++ # } # p := n . p # i := bt . split ( n ) # if p . keyValue [ i ]. key == key { # p . keyValue [ i ]. value = value # return nil # } else if p . LessByKey ( key , p . keyValue [ i ]. key ) { # return p . c [ i ] # } else { # return p . c [ i + 1 ] # } # } else if n . isLeaf { # n . addKeyValue ( key , value ) # return nil # } else { # return nodeOrKeyValue .(* bTreeNode ) # }
if m . keyL . Len () == 0 { # return nil # } # return m . keyL . Front (). Value
p , q := 0 , 0 # for i := range nums { # if nums [ i ] == 1 { # p ++ # if q < p { # q = p # } # } else { # p = 0 # } # } # return q
n := len ( nums ) # low := 0 # high := n - 1 # # for low <= high { # mid := low + ( high - low )/ 2 # if nums [ mid ] == target { # return mid # } # if target > nums [ mid ] { # low = mid + 1 # } else { # high = mid - 1 # } # # } # # return low
if list == nil || list . Size == 0 || index > list . Size - 1 { # return false # } # # list . mutex . Lock () # defer list . mutex . Unlock () # # if index == 0 { # head := list . Head . Next # list . Head = head # if list . Size == 1 { # list . Tail = nil # } # list . Size -= 1 # return true # } # # ptr := list . Head # var i uint # for i = 1 ; i < index ; i ++ { # ptr = ptr . Next # } # next := ptr . Next # # ptr . Next = next . Next # if index == list . Size - 1 { # list . Tail = ptr # } # list . Size -= 1 # return true
p , q := headA , headB # for p != q { # if p == nil { # p = headA # } else { # p = p . Next # } # if q == nil { # q = headB # } else { # q = q . Next # } # } # return p
p . mu . Lock () # idle := p . idle # p . idle . Init () # p . closed = true # p . active -= idle . Len () # if p . cond != nil { # p . cond . Broadcast () # } # p . mu . Unlock () # for e := idle . Front (); e != nil ; e = e . Next () { # e . Value .( idleConn ). c . Close () # } # return nil
n := len ( grid ) # pq := PQ {} # visited := make ([] bool , n * n ) # heap . Push (& pq , & entry { # x : 0 , # y : 0 , # max : grid [ 0 ][ 0 ], # }) # visited [ 0 ] = true # dirs := [ 4 ][ 2 ] int {{- 1 , 0 }, { 1 , 0 }, { 0 , - 1 }, { 0 , 1 }} # for { # pre := heap . Pop (& pq ).(* entry ) # for _ , dir := range dirs { # x , y := pre . x + dir [ 0 ], pre . y + dir [ 1 ] # if x < 0 || x >= n || y < 0 || y >= n || visited [ x * n + y ] { # continue # } # if x == n - 1 && y == n - 1 { # return max ( pre . max , grid [ x ][ y ]) # } # heap . Push (& pq , & entry { # x : x , # y : y , # max : max ( pre . max , grid [ x ][ y ]), # }) # visited [ x * n + y ] = true # } # }
data := s . data . Back (). Value # s . data . Remove ( s . data . Back ()) # return data
var count int # for x := range grid { # for y := range grid [ x ] { # if grid [ x ][ y ] == ' 1 ' { # search ( grid , x , y ) # count ++ # } # } # } # return count
sum := 0 # for _ , num := range nums { # sum += num # } # # if sum % 2 == 1 { # return false # } # # sum = sum / 2 # dp := make ([] bool , sum + 1 ) # dp [ 0 ] = true # # for i := 0 ; i < len ( nums ); i ++ { # for j := sum ; j >= 0 ; j -- { # dp [ j ] = dp [ j ] || ( j >= nums [ i ] && dp [ j - nums [ i ]]) # } # } # # return dp [ sum ]
if n < 1 { # panic (" STR ") # } # # perfectNum := 1 0 # for n != 0 { # perfectNum += 9 # digits := perfectNum # sum := 0 # # for digits != 0 { # sum += ( digits % 1 0 ) # digits /= 1 0 # } # # if sum == 1 0 { # n -- # } # } # # return perfectNum
ans := N * ( N + 1 ) / 2 # ans *= ans # sos := 0 # for i := 1 ; i <= N ; i ++ { sos += i * i } # ans -= sos # fmt . Println ( ans )
sum () # sum 1 ()
return rx * q [ 0 ] + ry * q [ 1 ] + rz * q [ 2 ]
var v * interface { # String () string # } # return v
if k == 0 || head == nil { # return head # } # # tail := head # for i := 0 ; i < k ; i ++ { # if tail . Next == nil { # return rotateRight ( head , k %( i + 1 )) # } # tail = tail . Next # } # # newTail := head # for tail . Next != nil { # newTail , tail = newTail . Next , tail . Next # } # # newHead := newTail . Next # newTail . Next , tail . Next = nil , head # # return newHead
return & ast . Ident { # NamePos : t . curPos , # Name : " STR " + t . curValue , # }, nil
for i := 1 ; i < n ; i ++ { # if n % i == 0 { # sum += i # } # } # return sum
for _ , tc := range testCases { # t . Run ( tc . name , func ( t * testing . T ) { # actual := RecursivePower ( tc . base , tc . power ) # if actual != tc . expected { # t . Errorf (" STR ", tc . base , tc . power , tc . expected , actual ) # } # }) # }
var tests = [] struct { # vals [] interface {} # tree * TreeNode # }{ # {[] interface {}{ 5 , 3 , 6 , 2 , 4 , nil , 8 , 1 , nil , nil , nil , 7 , 9 }, newTree ( 1 , nil , 2 , nil , 3 , nil , 4 , nil , 5 , nil , 6 , nil , 7 , nil , 8 , nil , 9 )}, # } # # for _ , tt := range tests { # tree := increasingBST ( newTree ( tt . vals ...)) # if reflect . DeepEqual ( tree , tt . tree ) == false { # t . Errorf (" STR ", newTree ( tt . vals ...), tree , tt . tree ) # } # }
var bull , cow int # var countS , countG [ 1 0 ] int # # size := len ( secret ) # for i := 0 ; i < size ; i ++ { # ns := int ( secret [ i ] - ' 0 ') # ng := int ( guess [ i ] - ' 0 ') # # if ns == ng { # bull ++ # } else { # if countG [ ns ] > 0 { # cow ++ # countG [ ns ]-- # } else { # countS [ ns ]++ # } # # if countS [ ng ] > 0 { # cow ++ # countS [ ng ]-- # } else { # countG [ ng ]++ # } # } # } # # return strconv . Itoa ( bull ) + " STR " + strconv . Itoa ( cow ) + " STR "
out := make ( map [ string ] interface {}) # s . FillMap ( out ) # return out
m := make ([] int , 4 5 , 4 5 ) # return jumpFloorRecursion ( n , m )
for i := 2 ; i * i <= c ; i ++ { # if c % i == 0 { # var cnt int # for c % i == 0 { # c /= i # cnt ++ # } # # if cnt & 1 == 1 && i % 4 == 3 { # return false # } # } # } # return c % 4 != 3
strChar := [] rune ( s ) # # start , end := 0 , 0 # for i := 0 ; i < len ( s ); i ++ { # if s [ i ] == ' ' { # end = i - 1 # reverse ( strChar , start , end ) # start = i + 1 # } # } # end = len ( s )- 1 # reverse ( strChar , start , end ) # return string ( strChar )
println ( multiply (" STR ", " STR "))
res := make ([] int , 0 ) # # for num := left ; num <= right ; num ++ { # flag := true # strNum := strconv . Itoa ( num ) # # for j := 0 ; j < len ( strNum ); j ++ { # if divisor := int ( strNum [ j ] - ' 0 '); divisor == 0 || num % divisor != 0 { # flag = false # } # } # if flag { # res = append ( res , num ) # } # } # return res
return binary . Write ( w , binary . BigEndian , data )
end := head # for k > 0 && end != nil { # end = end . Next # k -- # } # if k > 0 { # return head # } # res , pNode := end , head # var qNode * ListNode # for pNode != end { # qNode = pNode . Next # pNode . Next = res # res = pNode # pNode = qNode # } # return res
return checkFlags ( name , list , validCompilerFlags , validCompilerFlagsWithNextArg )
if A > B { # A , B = B , A # } # # if B % A == 0 { # return A # } # # return gcd ( B - A , A )
for i , c := range " STR " { # println ( i , c ) # }
n := len ( grid ) # res := 0 # for i := 0 ; i < n ; i ++ { # for j := 0 ; j < n ; j ++ { # v := grid [ i ][ j ] # if v == 0 { # continue # } # res += 4 * v + 2 # if i != 0 { # res -= min ( v , grid [ i - 1 ][ j ]) * 2 # } # if j != 0 { # res -= min ( v , grid [ i ][ j - 1 ]) * 2 # } # } # } # return res
n := len ( A ) # res := make ([] int , n ) # l , r := 0 , n - 1 # for i := 0 ; i < n ; i ++ { # if A [ i ]% 2 == 0 { # res [ l ] = A [ i ] # l ++ # } else { # res [ r ] = A [ i ] # r -- # } # } # return res
m := map [ int ] int {} # max := 0 # # var postorder func (* TreeNode ) int # postorder = func ( node * TreeNode ) int { # if node == nil { # return 0 # } # sum := node . Val + postorder ( node . Left ) + postorder ( node . Right ) # # m [ sum ]++ # if m [ sum ] > max { # max = m [ sum ] # } # return sum # } # # postorder ( root ) # # res := [] int {} # for sum , count := range m { # if count == max { # res = append ( res , sum ) # } # } # return res
m := map [ int ] struct {}{} # s 1 , s 2 := [] int {}, [] int {} # for _ , a := range A { # s := map [ int ] struct {}{ a : struct {}{}} # m [ a ] = struct {}{} # s 2 = append ( s 2 , a ) # for _ , b := range s 1 { # b |= a # if _ , ok := s [ b ]; ! ok { # s [ b ] = struct {}{} # m [ b ] = struct {}{} # s 2 = append ( s 2 , b ) # } # } # s 1 , s 2 = s 2 , s 1 [: 0 ] # } # return len ( m )
s := new ( stack ) # # for _ , b := range str { # switch b { # case '(', '[', '{': # s . push ( b ) # case ')', ']', '}': # if r , ok := s . pop (); ! ok || r != matching [ b ] { # return false # } # } # } # # if len (* s ) > 0 { # return false # } # # return true
iStr := fmt . Sprint ( x ) # jStr := fmt . Sprint ( y ) # if iStr + jStr > jStr + iStr { # return true # } # return false
var strs [] string # # length := 0 # # for i := 1 ; i <= 1 0 0 0 ; i ++ { # n := i # val := " STR " # # if n >= 1 0 0 && n < 1 0 0 0 { # hundred := n / 1 0 0 # val += translation [ hundred ] + " STR " # # n -= hundred * 1 0 0 # # if n > 0 { # val += " STR " # } # } # # if n <= 2 0 || n == 1 0 0 0 { # val += translation [ n ] # } else if n > 0 && n < 1 0 0 { # tenMul := n % 1 0 # val += translation [ n - tenMul ] # # if tenMul > 0 { # val += translation [ tenMul ] # } # } # # length += len ( val ) # strs = append ( strs , val ) # } # # fmt . Println ( length )
fmt . Println ( canConstruct (" STR ", " STR "))
if num == 0 { # return false # } # for num % 2 == 0 { # num = num / 2 # } # for num % 3 == 0 { # num = num / 3 # } # for num % 5 == 0 { # num = num / 5 # } # if num == 1 { # return true # } # return false
var newNode Node # newNode . Data = n # # if ll . tail != nil { # ll . tail . Next = & newNode # } # # ll . tail = & newNode # # if ll . head == nil { # ll . head = & newNode # } # ll . length ++
result := 0 # prevToLens := make ([] map [ int ] int , len ( A )) # for i , num := range A { # prevToLens [ i ] = make ( map [ int ] int ) # for j := 0 ; j <= i - 1 ; j ++ { # prev , lenJToI := num - A [ j ], 2 # if A [ j ] > prev { # if len , exists := prevToLens [ j ][ prev ]; exists { # lenJToI = len + 1 # } # } # # prevToLens [ i ][ A [ j ]] = lenJToI # result = int ( math . Max ( float 6 4 ( result ), float 6 4 ( lenJToI ))) # } # } # # if result < 3 { # return 0 # } # # return result
if headA == nil && headB == nil { # return true # } # for curA , curB := headA , headB ; curA != nil && curB != nil ; curA , curB = curA . Next , curB . Next { # if curA . Val != curB . Val { # return false # } # } # return true
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 2 , 2 , 3 , 4 }, 3 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := triangleNumber ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
blocks := " STR " + strings . Join ( allowed , " STR ") # # var dfs func ( string , int , int ) bool # dfs = func ( bottom string , curr , length int ) bool { # if curr + 2 > length { # bottom = bottom [ length :] # length = len ( bottom ) # if length == 1 { # return true # } # return dfs ( bottom , 0 , length ) # } # # b := " STR " + bottom [ curr : curr + 2 ] # beg := 0 # for beg < len ( blocks ) { # index := strings . Index ( blocks [ beg :], b ) + beg # if index < beg { # break # } # beg = index + 4 # color := blocks [ index + 3 : index + 4 ] # if dfs ( bottom + color , curr + 1 , length ) { # return true # } # } # # return false # } # # return dfs ( bottom , 0 , len ( bottom ))
ans := make ([] int , len ( A )) # for i , k , j := 0 , len ( A )- 1 , len ( ans )- 1 ; i <= j ; k -- { # if A [ i ]* A [ i ] > A [ j ]* A [ j ] { # ans [ k ] = A [ i ] * A [ i ] # i ++ # } else { # ans [ k ] = A [ j ] * A [ j ] # j -- # } # } # return ans
for { # switch r := l . next (); { # case r == " STR ": # l . emit ( itemStart ) # return byteLen # case unicode . IsNumber ( r ): # case r == " STR ": # l . backup () # l . emit ( itemStart ) # return byteEnd # case r == " STR ": # return l . error (" STR ") # default : # return l . error (" STR ") # } # }
qs := [] question 8 3 6 { # # { # para 8 3 6 {[] int { 0 , 0 , 2 , 2 }, [] int { 1 , 1 , 3 , 3 }}, # ans 8 3 6 { true }, # }, # # { # para 8 3 6 {[] int { 0 , 0 , 1 , 1 }, [] int { 1 , 0 , 2 , 1 }}, # ans 8 3 6 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 3 6 , q . para 8 3 6 # fmt . Printf (" STR ", p , isRectangleOverlap ( p . rec 1 , p . rec 2 )) # } # fmt . Printf (" STR ")
result := uint ( 1 ) # for i := uint ( 0 ); i < y ; i ++ { # result *= x # } # # return result
n := len ( a ) # res := 0 # maxLen := 0 # # length := make ([] int , n ) # count := make ([] int , n ) # # for j := 0 ; j < n ; j ++ { # length [ j ] = 1 # count [ j ] = 1 # for i := 0 ; i < j ; i ++ { # if a [ i ] < a [ j ] { # if length [ j ] == length [ i ]+ 1 { # count [ j ] += count [ i ] # } else if length [ j ] < length [ i ]+ 1 { # length [ j ] = length [ i ] + 1 # count [ j ] = count [ i ] # } # } # } # # if maxLen == length [ j ] { # res += count [ j ] # } else if maxLen < length [ j ] { # res = count [ j ] # maxLen = length [ j ] # } # } # # return res
s := strings . Split ( w , " STR ") # sort . Strings ( s ) # return strings . Join ( s , " STR ")
lo , hi := 0 , 0 # for _ , w := range weights { # lo = max ( lo , w ) # hi += w # } # # for lo < hi { # mid := ( lo + hi ) >> 1 # days , cur := 1 , 0 # for _ , w := range weights { # if cur + w > mid { # days ++ # cur = 0 # } # cur += w # } # if days > D { # lo = mid + 1 # } else { # hi = mid # } # } # # return lo
sum := uint 6 4 ( 0 ) # for _ , c := range s { # n , _ := strconv . Atoi ( string ( c )) # sum += uint 6 4 ( n ) # } # return sum
var mask = ^ 0 # for num & mask > 0 { # mask <<= 1 # } # mask = ^ mask # return mask ^ num
hash := fnv . New 3 2 a () # hash . Write ([] byte ( s )) # return uint 8 ( hash . Sum 3 2 () % 2 5 6 )
m := make ( map [ int ][] int ) # for i := 0 ; i < len ( nums ); i ++ { # m [ nums [ i ]] = append ( m [ nums [ i ]], i ) # } # # degree , ret := 0 , len ( nums ) # for _ , v := range m { # if degree < len ( v ) { # degree = len ( v ) # ret = v [ len ( v )- 1 ] - v [ 0 ] + 1 # } else if degree == len ( v ) { # if ret > v [ len ( v )- 1 ]- v [ 0 ]+ 1 { # ret = v [ len ( v )- 1 ] - v [ 0 ] + 1 # } # } # } # return ret
row 1 := make ([] int , len ( str 2 )+ 1 ) # row 2 := make ([] int , len ( str 2 )+ 1 ) # # for i := 1 ; i <= len ( str 2 ); i ++ { # row 1 [ i ] = i * icost # } # # for i := 1 ; i <= len ( str 1 ); i ++ { # row 2 [ 0 ] = i * dcost # # for j := 1 ; j <= len ( str 2 ); j ++ { # if str 1 [ i - 1 ] == str 2 [ j - 1 ] { # row 2 [ j ] = row 1 [ j - 1 ] # } else { # ins := row 2 [ j - 1 ] + icost # del := row 1 [ j ] + dcost # sub := row 1 [ j - 1 ] + scost # # if ins < del && ins < sub { # row 2 [ j ] = ins # } else if del < sub { # row 2 [ j ] = del # } else { # row 2 [ j ] = sub # } # } # } # row 1 , row 2 = row 2 , row 1 # } # # return row 1 [ len ( row 1 )- 1 ]
return s . size
var ( # y int # z = x # ) # # for x > 0 { # y = y * 1 0 + x % 1 0 # x /= 1 0 # } # return y == z
return Solution { # m : map [ int ] int {}, # r : n_rows , # c : n_cols , # total : n_rows * n_cols , # }
arr := [] int { 1 , 3 , 2 , 2 , 4 , 5 } # sortedArr := make ([] int , 0 , 0 ) # h := NewFibHeap () # for _ , v := range arr { # h . Insert ( v , v ) # } # for h . n > 0 { # min := h . ExtractMin () # sortedArr = append ( sortedArr , min . Key .( int )) # } # sort . Sort ( sort . Reverse ( sort . IntSlice ( arr ))) # if ! reflect . DeepEqual ( sortedArr , arr ) { # t . Log ( fmt . Sprintf (" STR ", arr ) + fmt . Sprintf (" STR ", sortedArr )) # t . Fail () # }
right := len ( arr ) / 2 # left := right - 1 # for { # if left < 0 { # min = arr [ right ] # break # } # if arr [ left ] > arr [ right ] { # min = arr [ right ] # break # } else { # right -- # left = right - 1 # } # } # return min
n := len ( a ) # r 0 , r 1 := 0 , 1 # # for i := 1 ; i < n ; i ++ { # newR 0 , newR 1 := 1 << 6 3 - 1 , 1 << 6 3 - 1 # if a [ i ] > a [ i - 1 ] && b [ i ] > b [ i - 1 ] { # newR 0 = min ( newR 0 , r 0 ) # newR 1 = min ( newR 1 , r 1 + 1 ) # } # if a [ i ] > b [ i - 1 ] && b [ i ] > a [ i - 1 ] { # newR 0 = min ( newR 0 , r 1 ) # newR 1 = min ( newR 1 , r 0 + 1 ) # } # r 0 , r 1 = newR 0 , newR 1 # } # return min ( r 0 , r 1 )
t . Parallel () # for _ , tc := range testcases { # if result := SquareElementsSortedBrute ( tc . input ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
for _ , c := range ransomNote { # idx := strings . IndexRune ( magazine , c ) # if idx > - 1 { # magazine = magazine [: idx ] + magazine [ idx + 1 :] # } else { # return false # } # } # return true
t . Parallel () # # for _ , tc := range testcases { # if result := ShortestSubstringContains ( tc . str , tc . letters ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
dp := make ([][] int , m + 1 ) # for i := 0 ; i < m + 1 ; i ++ { # dp [ i ] = make ([] int , n + 1 ) # } # for _ , s := range strs { # zero := strings . Count ( s , " STR ") # one := len ( s ) - zero # if zero > m || one > n { # continue # } # for i := m ; i >= zero ; i -- { # for j := n ; j >= one ; j -- { # dp [ i ][ j ] = max ( dp [ i ][ j ], 1 + dp [ i - zero ][ j - one ]) # } # } # } # return dp [ m ][ n ]
if len ( matrix ) < 2 { # return 0 # } # removals := 0 # for col := 0 ; col < len ( matrix [ 0 ]); col ++ { # for row := 1 ; row < len ( matrix ); row ++ { # if matrix [ row ][ col ] < matrix [ row - 1 ][ col ] { # removals ++ # break # } # } # } # return removals
var s seqStack # s . top = - 1 # result := [] int {} # # if root != nil { # for root != nil || s . top != - 1 { # for root != nil { # s . top ++ # s . data = append ( s . data , root ) # root = root . Left # } # s . top -- # root = s . data [ len ( s . data )- 1 ] # s . data = s . data [: len ( s . data )- 1 ] # result = append ( result , root . Val ) # root = root . Right # } # } # return result
chars := [] rune ( strings . ToUpper ( text )) # decryptedText := "" # for i := 0 ; i < len ( chars ); i += 2 { # decryptedChar , err := p . decipher ( chars [ i : int ( math . Min ( float 6 4 ( i + 2 ), float 6 4 ( len ( chars ))))]) # if err != nil { # return " STR ", err # } # decryptedText += decryptedChar # } # return decryptedText , nil
if num 1 == " STR " || num 2 == " STR " { # return " STR " # } # # bsi := [] byte ( num 1 ) # bsj := [] byte ( num 2 ) # # temp := make ([] int , len ( num 1 )+ len ( num 2 )) # for i := 0 ; i < len ( bsi ); i ++ { # for j := 0 ; j < len ( bsj ); j ++ { # temp [ i + j + 1 ] += int ( bsi [ i ]-' 0 ') * int ( bsj [ j ]-' 0 ') # } # } # # for i := len ( temp ) - 1 ; i > 0 ; i -- { # temp [ i - 1 ] += temp [ i ] / 1 0 # temp [ i ] = temp [ i ] % 1 0 # } # # if temp [ 0 ] == 0 { # temp = temp [ 1 :] # } # # res := make ([] byte , len ( temp )) # for i := 0 ; i < len ( temp ); i ++ { # res [ i ] = ' 0 ' + byte ( temp [ i ]) # } # # return string ( res )
sys := System { # Puller : Xenia {}, # Storer : Pillar {}, # } # # if err := Copy (& sys , 3 ); err != io . EOF { # fmt . Println ( err ) # }
cases := [] struct { # name string # inputs [] int # expect bool # }{ # {" STR ", [] int { 2 , 3 , 1 , 1 , 4 }, true }, # {" STR ", [] int { 3 , 2 , 1 , 0 , 4 }, false }, # {" STR ", [] int { 0 , 2 , 3 }, false }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := canJump ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
p . flushPendingBytes () # p . queue <- queueItem { pr : ch }
if numRows == 1 { # return s # } # runes := [] rune ( s ) # rows := make ([][] rune , numRows ) # i := 0 # status := down # for index := range runes { # rows [ i ] = append ( rows [ i ], runes [ index ]) # if status == down { # i ++ # if i == numRows - 1 { # status = up # } # } else { # i -- # if i == 0 { # status = down # } # } # } # retRunes := [] rune {} # for index := range rows { # retRunes = append ( retRunes , rows [ index ]...) # } # return string ( retRunes )
cmap := newOpenHashMap () # basicTestHashMap ( t , cmap )
out := 1 7 1 # if x := p 1 9 (); x != out { # t . Errorf (" STR ", x , out ) # }
profits := make ([][] int , k + 1 ) # for i := range profits { # profits [ i ] = make ([] int , len ( prices )+ 1 ) # } # for i := 1 ; i <= k ; i ++ { # diff := - int (^ uint ( 0 )>> 1 ) - 1 # for j := 1 ; j < len ( prices ); j ++ { # diff = max ( diff , profits [ i - 1 ][ j - 1 ]- prices [ j - 1 ]) # profits [ i ][ j ] = max ( profits [ i ][ j - 1 ], prices [ j ]+ diff ) # } # } # return profits [ k ][ len ( prices )- 1 ]
size := len ( s ) # # stack := make ([] byte , size ) # top := 0 # # for i := 0 ; i < size ; i ++ { # c := s [ i ] # switch c { # case '(': # stack [ top ] = c + 1 # top ++ # case '[', '{': # stack [ top ] = c + 2 # top ++ # case ')', ']', '}': # if top > 0 && stack [ top - 1 ] == c { # top -- # } else { # return false # } # } # } # # return top == 0
if len ( arr ) == 0 { # return 1 # } # # k := arr [ 0 ] # # for _ , v := range arr { # if v > k { # k = v # } # } # # return k + 1
var tests = [] struct { # nums [] int # dup int # }{ # {[] int { 1 , 3 , 4 , 2 , 2 }, 2 }, # {[] int { 3 , 1 , 3 , 4 , 2 }, 3 }, # } # # for _ , tt := range tests { # dup := findDuplicate ( tt . nums ) # if dup != tt . dup { # t . Errorf (" STR ", tt . nums , dup , tt . dup ) # } # }
t := make ([] int , 0 , 1 0 0 0 0 ) # return ExamRoom { # seats : & t , # N : N , # }
if x == 1 { # x = bound + 1 # } # if y == 1 { # y = bound + 1 # } # # res := make ([] int , 0 , 1 2 8 ) # for i := 1 ; i < bound ; i *= x { # for j := 1 ; i + j <= bound ; j *= y { # res = append ( res , i + j ) # } # } # # return removeRepeated ( res )
if a == b { # return true # } # # n := len ( a ) # # rec := make ([] int , 2 5 6 ) # for i := 0 ; i < n ; i ++ { # rec [ a [ i ]]++ # rec [ b [ i ]]-- # } # for i := range rec { # if rec [ i ] != 0 { # return false # } # } # # for i := 1 ; i < n ; i ++ { # if isScramble ( a [ 0 : i ], b [ 0 : i ]) && # isScramble ( a [ i :], b [ i :]) { # return true # } # # if isScramble ( a [ 0 : i ], b [ n - i :]) && # isScramble ( a [ i :], b [ 0 : n - i ]) { # return true # } # } # # return false
if e := m . m [ key ].([] interface {})[ 0 ].(* list . Element ). Prev (); e != nil { # return e . Value # } # return nil
return func ( e Extent , c Callback ) bool { # return Scan ( li , e , c ) # }
sort . Ints ( heaters ) # # var radius int # for _ , house := range houses { # i := findIndex ( heaters , house ) # # min := int ( 1 e 9 ) # if i >= 0 { # min = house - heaters [ i ] # } # if i + 1 < len ( heaters ) && heaters [ i + 1 ]- house < min { # min = heaters [ i + 1 ] - house # } # # if min > radius { # radius = min # } # } # return radius
println (" STR ", len ( m )) # println (" STR ", key , " STR ", m [ key ]) # keys := make ([] string , 0 , len ( m )) # for k := range m { # keys = append ( keys , k ) # } # sort . Strings ( keys ) # for _ , k := range keys { # v := m [ k ] # println (" STR ", k , " STR ", v ) # }
rand . Seed ( time . Now (). UnixNano ()) # M := N - len ( blacklist ) # # blackMap := make ( map [ int ] int , len ( blacklist )) # for _ , b := range blacklist { # blackMap [ b ] = b # } # # for _ , b := range blacklist { # if b >= M { # continue # } # # # N -- # for blackMap [ N ] == N { # N -- # } # # blackMap [ b ] = N # } # # return Solution { # M : M , # blackMap : blackMap , # } #
if root == nil { # return # } # # flatten ( root . Left ) # flatten ( root . Right ) # # left , right := root . Left , root . Right # root . Left = nil # node := left # if node != nil { # for node . Right != nil { # node = node . Right # } # # root . Right = left # node . Right = right # }
defer waitShutdown . Done () # # log . Printf (" STR ", rw . name ) # # close ( rw . shutdown ) # # rw . reportShutdown . Wait () # # log . Printf (" STR ", rw . name )
if n == 1 { # return " STR " # } # # if n % 3 == 0 { # return " STR " + checker ( n / 3 ) # } # # if n % 3 == 1 { # return " STR " + checker (( 4 * n + 2 )/ 3 ) # } # # return " STR " + checker (( 2 * n - 1 )/ 3 )
var ret int # nums 1 := [] int { 1 , 1 , 2 } # ret = 2 # if removeDuplicates ( nums 1 ) != ret { # t . Fatalf (" STR ", ret ) # } # # nums 2 := [] int { 0 , 0 , 1 , 1 , 1 , 2 , 2 , 3 , 3 , 4 } # ret = 5 # if removeDuplicates ( nums 2 ) != ret { # t . Fatalf (" STR ", ret ) # } # # nums 3 := [] int {} # ret = 0 # if removeDuplicates ( nums 3 ) != ret { # t . Fatalf (" STR ", ret ) # }
this . mutex . Lock () # if this . closed { # this . mutex . Unlock () # return nil # } # this . wg . Add ( 1 ) # defer this . wg . Done () # e := this . list . Front () # for e == nil { # this . cond . Wait () # if this . closed { # this . mutex . Unlock () # return nil # } # e = this . list . Front () # } # defer this . mutex . Unlock () # return e . Value
result , maxNum , minNum , index := make ([] int , len ( S )+ 1 ), len ( S ), 0 , 0 # for _ , ch := range S { # if ch == ' I ' { # result [ index ] = minNum # minNum ++ # } else { # result [ index ] = maxNum # maxNum -- # } # index ++ # } # result [ index ] = minNum # return result
low , high := uint 6 4 ( 0 ), uint 6 4 ( 2 0 0 0 0 0 0 ) # s := sumOfPrimesBetween ( low , high ) # # fmt . Println (" STR ", low , " STR ", high , " STR ", s )
cases := [] struct { # name string # inputs * TreeNode # expect bool # }{ # {" STR ", # & TreeNode { 2 , # & TreeNode { 1 , nil , nil }, # & TreeNode { 3 , nil , nil }}, # true , # }, # {" STR ", # & TreeNode { 5 , # & TreeNode { 1 , nil , nil }, # & TreeNode { 4 , # & TreeNode { 3 , nil , nil }, # & TreeNode { 6 , nil , nil }}}, # false , # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := isValidBST ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
a := & Animal { # Name : " STR ", # Age : 4 , # } # # d := & Dog { # Animal : a , # } # # defer func () { # err := recover () # if err != nil { # fmt . Printf (" STR ", err ) # t . Error (" STR ") # } # }() # # s := New ( d ) # # s . TagName = " STR " # m := s . Map () # # if _ , exists := m [" STR "]; exists { # t . Errorf (" STR ") # }
if x == 1 && y == 1 { # if bound < 2 { # return [] int {} # } # return [] int { 2 } # } # if x > y { # x , y = y , x # } # visit , result := make ( map [ int ] bool ), make ([] int , 0 ) # for i := 0 ; ; i ++ { # found := false # for j := 0 ; pow ( x , i )+ pow ( y , j ) <= bound ; j ++ { # v := pow ( x , i ) + pow ( y , j ) # if ! visit [ v ] { # found = true # visit [ v ] = true # result = append ( result , v ) # } # } # if ! found { # break # } # } # return result
m := map [ int ] int {} # for k , v := range nums { # if 0 < v { # m [ k ] = v # } # } # return SparseVector { # m : m , # }
var prev , Next * Node # cur := ll . Head # # for cur != nil { # Next = cur . Next # cur . Next = prev # prev = cur # cur = Next # } # # ll . Head = prev
i , j := math . MaxInt 3 2 , math . MaxInt 3 2 # for _ , num := range nums { # if num <= i { # i = num # } else if num <= j { # j = num # } else { # return true # } # } # return false
fmt . Println (" STR ")
if nil == numbers || len ( numbers ) < 5 { # return false # } # # sort . Ints ( numbers ) # numberOfZero , numberOfGap := 0 , 0 # for _ , value := range numbers { # if value == 0 { # numberOfZero ++ # } # } # # small , big := 0 , 1 # for big < len ( numbers ) { # if numbers [ small ] == numbers [ big ] { # return false # } # numberOfGap += numbers [ big ] - numbers [ small ] - 1 # small = big # big ++ # } # if numberOfGap > numberOfZero { # return false # } # return true
n := len ( m ) # for i := 0 ; i < n / 2 ; i ++ { # for j := i ; j < n - i - 1 ; j ++ { # temp := m [ i ][ j ] # m [ i ][ j ] = m [ n - j - 1 ][ i ] # m [ n - j - 1 ][ i ] = m [ n - i - 1 ][ n - j - 1 ] # m [ n - i - 1 ][ n - j - 1 ] = m [ j ][ n - i - 1 ] # m [ j ][ n - i - 1 ] = temp # } # }
var nums [] int # for head != nil { # nums = append ( nums , head . Val ) # head = head . Next # } # return sortedArrayToBST ( nums )
if l 1 == nil { # return l 2 # } # if l 2 == nil { # return l 1 # } # if l 1 . Val < l 2 . Val { # l 1 . Next = mergeTwoLists ( l 1 . Next , l 2 ) # return l 1 # } else { # l 2 . Next = mergeTwoLists ( l 1 , l 2 . Next ) # return l 2 # } #
qs := [] question 8 8 { # # # { # para 8 8 {[] int { 1 , 2 , 3 , 0 , 0 , 0 }, 3 , [] int { 2 , 5 , 6 }, 3 }, # ans 8 8 {[] int { 1 , 2 , 2 , 3 , 5 , 6 }}, # }, # } # fmt . Printf (" STR ") # for _ , q := range qs { # _ , p := q . ans 8 8 , q . para 8 8 # fmt . Printf (" STR ", p . one , p . m , p . two , p . n ) # merge ( p . one , p . m , p . two , p . n ) # fmt . Printf (" STR ", p ) # } # fmt . Printf (" STR ")
var jumps [ 1 0 ][ 1 0 ] int # jumps [ 1 ][ 3 ], jumps [ 3 ][ 1 ] = 2 , 2 # jumps [ 7 ][ 9 ], jumps [ 9 ][ 7 ] = 8 , 8 # jumps [ 1 ][ 7 ], jumps [ 7 ][ 1 ] = 4 , 4 # jumps [ 3 ][ 9 ], jumps [ 9 ][ 3 ] = 6 , 6 # jumps [ 1 ][ 9 ], jumps [ 9 ][ 1 ], jumps [ 2 ][ 8 ], jumps [ 8 ][ 2 ], # jumps [ 3 ][ 7 ], jumps [ 7 ][ 3 ], jumps [ 4 ][ 6 ], jumps [ 6 ][ 4 ] = 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 # var visited [ 1 0 ] bool # ways := 0 # for numDots := 4 ; numDots < 1 0 ; numDots ++ { # ways += 4 * validUnlockKeypadNumber ( visited , jumps , 1 , numDots - 1 ) # ways += 4 * validUnlockKeypadNumber ( visited , jumps , 2 , numDots - 1 ) # ways += validUnlockKeypadNumber ( visited , jumps , 5 , numDots - 1 ) # } # return ways
numbers := parseToIntSlice ( source ) # length := 1 3 # current := prod ( numbers [ 0 : length ]) # max := current # for i := length + 1 ; i <= len ( numbers ); i ++ { # current = makenext ( current , numbers [ i - length - 1 : i ]) # if current > max { # max = current # } # } # fmt . Println (" STR ", max )
n := len ( edges ) # # parent := make ([] int , n + 1 ) # var first , last [] int # # for k := range edges { # p , c := edges [ k ][ 0 ], edges [ k ][ 1 ] # if parent [ c ] == 0 { # parent [ c ] = p # } else { # first = [] int { parent [ c ], c } # last = edges [ k ] # edges [ k ] = nil # break # } # } # # root := parent # # for i := 0 ; i <= n ; i ++ { # root [ i ] = i # } # # rootOf := func ( i int ) int { # for i != root [ i ] { # i = root [ i ] # } # return i # } # # for _ , edge := range edges { # if edge == nil { # continue # } # # p := edge [ 0 ] # c := edge [ 1 ] # r := rootOf ( p ) # # if r == c { # if first == nil { # return edge # } # return first # } # # root [ c ] = r # } # # return last
node := q . list . Get ( 0 ) # if node == nil { # return nil # } # q . list . Delete ( 0 ) # return node . Data
if len ( nums ) < 1 { # return - 1 # } # if len ( nums ) == 1 { # return 0 # } # # id 1 , id 2 := - 1 , - 1 # for i := 0 ; i < len ( nums ); i ++ { # if - 1 == id 1 || nums [ i ] > nums [ id 1 ] { # id 2 = id 1 # id 1 = i # } else if - 1 == id 2 || nums [ i ] > nums [ id 2 ] { # id 2 = i # } # } # # if nums [ id 2 ]* 2 <= nums [ id 1 ] { # return id 1 # } # return - 1
r := " STR " # for i := 1 ; i < n ; i ++ { # r = say ( r ) # } # return r
if n == 2 { # return true # } # if n <= 1 || n % 2 == 0 { # return false # } # # upper := uint ( math . Sqrt ( float 6 4 ( n ))) # # for k := uint ( 3 ); k <= upper ; k += 2 { # if n % k == 0 { # return false # } # } # # return true
size := len ( seats ) # maxDis := 0 # e := 0 # for i := 0 ; i < size ; i ++ { # if e == i { # maxDis = e # } else { # maxDis = max ( maxDis , ( e + e % 2 )/ 2 ) # } # if seats [ i ] == 1 { # e = 0 # } else { # e ++ # } # } # # return max ( maxDis , e )
fmt . Println ( largestPalindrome ( 2 )) # fmt . Println ( largestPalindrome ( 3 )) # fmt . Println ( largestPalindrome ( 4 ))
if n < 1 { # return false # } # for n % 3 == 0 { # n /= 3 # } # return n == 1
res := make ([] string , 0 , n * n ) # bytes := make ([] byte , n * 2 ) # dfs ( n , n , 0 , bytes , & res ) # return res
var max int 3 2 # for _ , v := range nums { # if v > max { # max = v # } # } # exp := int 3 2 ( 1 ) # for max / exp > 0 { # CountingSort ( nums , exp ) # exp *= 1 0 # }
return list . rear == nil
bs := [] byte ( s ) # n := len ( s ) # for i := 0 ; i < n ; i += 2 * k { # j := min ( i + k , n ) # reverse ( bs [ i : j ]) # } # return string ( bs )
size := len ( nums ) # if k == 0 || t < 0 || size <= 1 { # return false # } # t ++ # nMap := make ( map [ int ] int , size ) # var ni , m int # for i := 0 ; i < size ; i ++ { # ni = nums [ i ] # m = ni / t # if ni < 0 { # m -- # } # if _ , ok := nMap [ m ]; ok { # return true # } else if n , ok := nMap [ m - 1 ]; ok && abs ( ni , n ) < t { # return true # } else if n , ok := nMap [ m + 1 ]; ok && abs ( ni , n ) < t { # return true # } # # nMap [ m ] = ni # if i >= k { # delete ( nMap , nums [ i - k ]/ t ) # } # } # # return false
fmt . Println ( jump ([] int { 2 , 3 , 1 , 1 , 4 }))
t . Parallel () # # for _ , tc := range testcases { # if result := CountPathsBrute ( tc . m , tc . n ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
const limit = 4 0 0 0 0 0 0 # # var x , y , z , sum int # # fmt . Println (" STR ") # x = 1 # for { # z = y # y = x # x = y + z # if x > limit { # break # } # if x % 2 == 0 { # sum += x # } # } # fmt . Println ( sum )
m := make ( map [ int ] bool ) # i := 0 # for ; i < len ( nums ) && i <= k ; i ++ { # if m [ nums [ i ]] { # return true # } # # m [ nums [ i ]] = true # } # # for ; i < len ( nums ); i ++ { # m [ nums [ i - k - 1 ]] = false # if m [ nums [ i ]] { # return true # } # # m [ nums [ i ]] = true # } # # return false
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 2 , 3 , 4 , 5 }, 4 }, # {" STR ", [] int { 7 , 6 , 4 , 3 , 1 }, 0 }, # } # # for i , c := range cases { # t . Run ( c . name + strconv . Itoa ( i ), func ( t * testing . T ) { # got := maxProfit ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
preHead := & ListNode { Val : 0 , Next : nil } # cur := preHead # preHead . Next = head # for cur . Next != nil && cur . Next . Next != nil { # tmp := cur . Next . Next # cur . Next . Next = tmp . Next # tmp . Next = cur . Next # cur . Next = tmp # cur = cur . Next . Next # } # return preHead . Next
r := 1 # for _ , s := range v { # r *= s # } # return r
return x - y
if a <= b { # return a # } # return b
return MinStack { # elems : make ([] int , 0 ), # mins : make ([] int , 0 ), # }
if val [ 0 ] > val [ 1 ] { # val [ 0 ], val [ 1 ] = val [ 1 ], val [ 0 ] # } # return val [ 0 ]* 1 0 + val [ 1 ]
val := (* valsPtr )[ 0 ] # * valsPtr = (* valsPtr )[ 1 :] # if val == " STR " { # return nil # } # valInt , _ := strconv . Atoi ( val ) # node := & TreeNode { Val : valInt } # node . Left = dfs ( valsPtr ) # node . Right = dfs ( valsPtr ) # return node
count := 0 # smallerThan := mat [ i 1 ][ j 1 ] # largerThan := mat [ i 2 ][ j 2 ] # for i := range mat { # for j := range mat [ i ] { # if mat [ i ][ j ] < smallerThan { # count ++ # } else if mat [ i ][ j ] > largerThan { # count ++ # } # } # } # return count
base := [...] int { 1 0 0 0 , 9 0 0 , 5 0 0 , 4 0 0 , 1 0 0 , 9 0 , 5 0 , 4 0 , 1 0 , 9 , 5 , 4 , 1 } # bs := [...] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "} # ans := " STR " # for i , b := range base { # for num / b > 0 { # ans += bs [ i ] # num -= b # } # } # return ans
for o := 0 ; o < len ( tp . list_of_pools ); o ++ { # p := & tp . list_of_pools [ o ] # p . mu . Lock () # p . list = make ([][] byte , 0 , cap ( p . list )/ 2 ) # p . mu . Unlock () # }
var err error # # err = read ( r , qSize , h ) # if err != nil { # return err # } # # err = seek ( r , qSize , io . SeekCurrent , hSize ) # if err != nil { # return err # } # # return read ( r , hSize , h )
return MyQueue {}
if ! lq . Empty () { # val := lq . queue . Front (). Value # return val , nil # } # # return " STR "
var tests = [] struct { # s , t string # isAnagram bool # }{ # { # " STR ", " STR ", # true , # }, # { # " STR ", " STR ", # false , # }, # { # " STR ", " STR ", # false , # }, # } # # for _ , tt := range tests { # anagram := isAnagram ( tt . s , tt . t ) # if anagram != tt . isAnagram { # t . Errorf (" STR ", tt . s , tt . t , anagram , tt . isAnagram ) # } # }
m , n := len ( nums 1 ), len ( nums 2 ) # # res := make ([] int , k ) # for i := 0 ; i <= m && i <= k ; i ++ { # if n < k - i { # continue # } # # tmp := combine ( maxK ( nums 1 , i ), maxK ( nums 2 , k - i )) # if more ( tmp , res ) { # copy ( res , tmp ) # } # } # return res
for i , tword := range t . words { # if i < len ( s . words ) { # s . words [ i ] |= tword # } else { # s . words = append ( s . words , tword ) # } # }
if root == nil { # return # } # if root . Left == nil && root . Right == nil { # * ret = append (* ret , root . Val ) # } # leaf ( root . Left , ret ) # leaf ( root . Right , ret )
obj := Constructor () # obj . Push ( 4 ) # obj . Push ( 0 ) # obj . Push ( 9 ) # obj . Push ( 3 ) # obj . Push ( 4 ) # obj . Push ( 2 ) # obj . Pop () # obj . Push ( 6 ) # obj . Pop () # obj . Push ( 1 ) # obj . Pop () # obj . Push ( 1 ) # obj . Pop () # obj . Push ( 4 ) # obj . Pop () # obj . Pop () # obj . Pop () # obj . Pop () # obj . Pop () # obj . Pop ()
t . Parallel () # for _ , tc := range testcases { # var input []* SinglyLL # for i := range tc . lists { # input = append ( input , createSinglyLL ( tc . lists [ i ])) # } # head := MergeKSortedLists ( input ) # result := convertSinglyLLToSlice ( head ) # if ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
return reflect . ValueOf ( i )
return fmt . Sprintf (" STR ", pc . A , pc . B , pc . C , pc . D , pc . Port )
qs := [] question 9 9 6 { # # { # para 9 9 6 {[] int { 1 , 1 7 , 8 }}, # ans 9 9 6 { 2 }, # }, # # { # para 9 9 6 {[] int { 1 }}, # ans 9 9 6 { 1 }, # }, # # { # para 9 9 6 {[] int { 2 , 2 , 2 }}, # ans 9 9 6 { 1 }, # }, # # { # para 9 9 6 {[] int { 5 1 7 6 8 , 4 7 8 6 1 , 4 8 1 4 3 , 3 3 2 2 1 , 5 0 8 9 3 , 5 6 7 5 8 , 3 9 9 4 6 , 1 0 3 1 2 , 2 0 2 7 6 , 4 0 6 1 6 , 4 3 6 3 3 }}, # ans 9 9 6 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 9 6 , q . para 9 9 6 # fmt . Printf (" STR ", p , numSquarefulPerms ( p . one )) # } # fmt . Printf (" STR ")
u := struct { # Name string # Email string # }{ # Name : " STR ", # Email : " STR ", # } # # rw . Header (). Set (" STR ", " STR ") # rw . WriteHeader ( 2 0 0 ) # json . NewEncoder ( rw ). Encode (& u )
type S struct { # F string ` species :" STR " color :" STR "` # } # # s := S {} # st := reflect . TypeOf ( s ) # field := st . Field ( 0 ) # println ( field . Tag . Get (" STR "), field . Tag . Get (" STR "))
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int {}, 0 }, # {" STR ", [] int { 3 }, 3 }, # {" STR ", [] int { 1 , 2 , 3 , 1 }, 4 }, # {" STR ", [] int { 2 , 7 , 9 , 3 , 1 }, 1 2 }, # {" STR ", [] int { 5 , 2 , 6 , 7 , 3 , 1 }, 1 4 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := rob 4 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
type B struct { # Foo map [ string ] string # } # # type A struct { # B * B # } # # b := & B { # Foo : map [ string ] string { # " STR ": " STR ", # }, # } # # a := & A { B : b } # # m := Map ( a ) # # if typ := reflect . TypeOf ( m ). Kind (); typ != reflect . Map { # t . Errorf (" STR ", typ ) # } # # in , ok := m [" STR "].( map [ string ] interface {}) # if ! ok { # t . Errorf (" STR ", m [" STR "]) # } # # foo := in [" STR "].( map [ string ] string ) # if name := foo [" STR "]; name != " STR " { # t . Errorf (" STR ", name ) # }
bs := [] byte {} # for i := len ( S ) - 1 ; i >= 0 ; i -- { # b := S [ i ] # if b == '-' { # continue # } # if len ( bs )%( K + 1 ) == K { # bs = append ( bs , '-') # } # if b >= ' a ' { # b -= 3 2 # } # bs = append ( bs , b ) # } # i , j := 0 , len ( bs )- 1 # for i < j { # bs [ i ], bs [ j ] = bs [ j ], bs [ i ] # i ++ # j -- # } # return string ( bs )
return ll . length == 0
fmt . Println ( hammingWeight ( uint 3 2 ( 1 1 )))
cases := [] struct { # name string # inputs string # expect string # }{ # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := longestPalindrome 1 ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
m . cache [ m . bucketNo ( key )]. Set ( key , value , expire )
root := & LockableBinaryTree {} # left := & LockableBinaryTree { Parent : root } # right := & LockableBinaryTree { Parent : root } # root . Left = left # root . Right = right # return []* LockableBinaryTree { root , left , right }
n , _ := strconv . Atoi ( num ) # hex := fmt . Sprintf (" STR ", n ) # hex = strings . NewReplacer (" STR ", " STR ", " STR ", " STR "). Replace ( hex ) # for _ , v := range hex { # if v < ' A ' { # return " STR " # } # } # return hex
t . Parallel () # us := NewInMemoryURLShortener () # for _ , tc := range urls { # if short := us . Shorten ( tc . url ); short != tc . short { # t . Errorf (" STR ", tc . short , short ) # } # } # for _ , tc := range urls { # if url := us . Restore ( tc . short ); url != tc . url { # t . Errorf (" STR ", tc . url , url ) # } # }
tests := [...] testType { # { # in : 2 7 , # want : true , # }, # { # in : 0 , # want : false , # }, # { # in : 1 , # want : true , # }, # { # in : 9 , # want : true , # }, # { # in : 4 5 , # want : false , # }, # } # for _ , tt := range tests { # got := isPowerOfThree ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
sold , held , reset := - 1 << 3 1 , - 1 << 3 1 , 0 # # for _ , price := range prices { # preSold := sold # sold = held + price # held = max ( held , reset - price ) # reset = max ( reset , preSold ) # # } # return max ( sold , reset )
count := 0 # tmp := head # for tmp != nil { # count ++ # tmp = tmp . Next # } # return Solution { # head : head , # n : count , # }
t . Parallel () # for _ , tc := range testcases { # if result := NQueens ( tc . n , [] int {}); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
arr := make ([] bool , 1 0 0 0 0 0 0 ) # arr [ 0 ], arr [ 1 ], arr [ 2 ] = false , false , true # i := 3 # var composite , found bool # var tmp , tmp 2 int # loop : # for { # composite = false # inner : # for j := 2 ; j < i ; j ++ { # if arr [ j ] && i % j == 0 { # composite = true # break inner # } # } # if composite { # found = false # inner 2 : # for j := 2 ; j < i ; j ++ { # if arr [ j ] { # tmp = ( i - j ) # if tmp 2 = int ( math . Sqrt ( float 6 4 ( tmp / 2 ))); tmp % 2 == 0 && tmp 2 * tmp 2 == tmp / 2 { # found = true # break inner 2 # } # } # } # if ! found { # println ( i ) # break loop # } # } else { # arr [ i ] = true # } # i += 2 # }
return func ( t * testing . T ) { # t . Parallel () # # h := md 5 . New () # err := def . tFunc ( getNewReader (), h ) # md 5 sum := fmt . Sprintf (" STR ", h . Sum ( nil )) # # if err != def . err { # t . Fatalf (" STR ", def . err , err ) # } # if md 5 sum != def . md 5 sum { # t . Fatalf (" STR ", def . md 5 sum , md 5 sum ) # } # }
qs := [] question 7 8 4 { # # { # para 7 8 4 {" STR "}, # ans 7 8 4 {[] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # }, # # { # para 7 8 4 {" STR "}, # ans 7 8 4 {[] string {" STR ", " STR "}}, # }, # # { # para 7 8 4 {" STR "}, # ans 7 8 4 {[] string {" STR ", " STR ", " STR ", " STR "}}, # }, # # { # para 7 8 4 {" STR "}, # ans 7 8 4 {[] string {" STR ", " STR "}}, # }, # # { # para 7 8 4 {" STR "}, # ans 7 8 4 {[] string {" STR "}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 8 4 , q . para 7 8 4 # fmt . Printf (" STR ", p , letterCasePermutation 1 ( p . one )) # } # fmt . Printf (" STR ")
tests := [...] testType { # { # in : [][] int { # { 0 , 0 , 0 }, # { 0 , 1 , 0 }, # { 0 , 0 , 0 }, # }, # want : [][] int { # { 0 , 0 , 0 }, # { 0 , 1 , 0 }, # { 0 , 0 , 0 }, # }, # }, # { # in : [][] int { # { 0 , 0 , 0 }, # { 0 , 1 , 0 }, # { 1 , 1 , 1 }, # }, # want : [][] int { # { 0 , 0 , 0 }, # { 0 , 1 , 0 }, # { 1 , 2 , 1 }, # }, # }, # } # for _ , tt := range tests { # got := updateMatrix ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
cases := [] struct { # name string # inputs int # expect int # }{ # {" STR ", 5 , 2 }, # {" STR ", 8 , 3 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := arrangeCoins ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
dp := make ([][] int , m + 1 ) # for j := range dp { # dp [ j ] = make ([] int , n + 1 ) # } # # for _ , str := range strs { # zero , one := 0 , 0 # for _ , b := range str { # if b == ' 0 ' { # zero ++ # } else { # one ++ # } # } # # for j := m ; j >= 0 ; j -- { # for k := n ; k >= 0 ; k -- { # if j >= zero && k >= one && dp [ j - zero ][ k - one ]+ 1 > dp [ j ][ k ] { # dp [ j ][ k ] = dp [ j - zero ][ k - one ] + 1 # } # } # } # } # # return dp [ m ][ n ]
beerType := toID [ t ] # return & beerType
if da . Size == da . Capacity { # da . NewCapacity () # } # # da . ElementData [ da . Size ] = element # da . Size ++
ch <- 1 # wg . Done ()
t . Parallel () # for _ , tc := range testcases { # if pi := EstimatePi ( tc . iterations ); math . Abs ( pi - tc . expected ) > tc . delta { # t . Errorf (" STR ", tc . expected , pi , tc . delta ) # } # }
n := len ( S ) # res := [] int {} # var recur func ( int ) bool # recur = func ( index int ) bool { # if index == n && len ( res ) >= 3 { # return true # } # for i := index ; i < n ; i ++ { # if S [ index ] == ' 0 ' && i > index { # break # } # num , err := strconv . Atoi ( S [ index : i + 1 ]) # if err != nil || num > math . MaxInt 3 2 { # break # } # size := len ( res ) # if size >= 2 && num > res [ size - 1 ]+ res [ size - 2 ] { # break # } # if size <= 1 || num == res [ size - 1 ]+ res [ size - 2 ] { # res = append ( res , num ) # if recur ( i + 1 ) { # return true # } # res = res [: size ] # } # } # return false # } # recur ( 0 ) # return res
cases := [] struct { # name string # input 1 [] int # input 2 int # expect [][] int # }{ # {" STR ", # [] int { 1 , 0 , - 1 , 0 , - 2 , 2 }, # 0 , # [][] int { # {- 1 , 0 , 0 , 1 }, # {- 2 , - 1 , 1 , 2 }, # {- 2 , 0 , 0 , 2 }, # }}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := fourSum ( c . input 1 , c . input 2 ) # fmt . Println ( got ) # }) # }
n := len ( nums ) # taken := make ([] bool , n ) # res := [][] int {} # # var makePermutation func ( cur int , vector [] int ) # makePermutation = func ( cur int , vector [] int ) { # if cur == n { # tmp := make ([] int , n ) # copy ( tmp , vector ) # res = append ( res , tmp ) # return # } # used := make ( map [ int ] bool , n - cur ) # for i := 0 ; i < n ; i ++ { # if ! taken [ i ] && ! used [ nums [ i ]] { # used [ nums [ i ]] = true # taken [ i ] = true # vector [ cur ] = nums [ i ] # makePermutation ( cur + 1 , vector ) # taken [ i ] = false # } # } # } # # makePermutation ( 0 , make ([] int , n )) # return res
var tests = [] struct { # list [] int # reversedList * ListNode # }{ # { # [] int { 1 , 2 , 3 , 4 , 5 }, # newList ( 5 , 4 , 3 , 2 , 1 ), # }, # { # [] int { 5 , 4 , 3 , 2 , 1 }, # newList ( 1 , 2 , 3 , 4 , 5 ), # }, # } # # for _ , tt := range tests { # reversedList := reverseList ( newList ( tt . list ...)) # if reflect . DeepEqual ( reversedList , tt . reversedList ) == false { # t . Errorf (" STR ", newList ( tt . list ...), reversedList , tt . reversedList ) # } # }
var T = struct { # A string # B int # C bool ` structs :" STR "` # D [] string # }{ # A : " STR ", # B : 2 , # } # # ok := HasZero ( T ) # if ! ok { # t . Error (" STR ") # } # # var X = struct { # A string # F * bool # }{ # A : " STR ", # } # # ok = HasZero ( X ) # if ! ok { # t . Error (" STR ") # } # # var Y = struct { # A string # B int # }{ # A : " STR ", # B : 1 2 3 , # } # # ok = HasZero ( Y ) # if ok { # t . Error (" STR ") # }
var target * bstElement # n , isNode := node .(* bstElement ) # if ! isNode { # n = new ( bstElement ) # n . Key = node .( uint 3 2 ) # } # for cur := t . root ; cur != nil ; { # target = cur # if n . Key < cur . Key { # cur = cur . left # } else { # cur = cur . right # } # } # n . parent = target # if target == nil { # t . root = n # } else if n . Key < target . Key { # target . left = n # } else { # target . right = n # } # return n
fmt . Printf (" STR ", combinationSum ([] int { 2 , 3 , 6 , 7 }, 7 ))
var tests = [] struct { # nums [] int # single int # }{ # {[] int { 2 , 2 , 1 }, 1 }, # {[] int { 4 , 1 , 2 , 1 , 2 }, 4 }, # } # # for _ , tt := range tests { # single := singleNumber ( tt . nums ) # if single != tt . single { # t . Errorf (" STR ", tt . nums , single , tt . single ) # } # }
length := len ( digits ) # if length == 0 { # return [] int { 1 } # } # # digits [ length - 1 ]++ # # for i := length - 1 ; i > 0 ; i -- { # if digits [ i ] < 1 0 { # break # } # digits [ i ] -= 1 0 # digits [ i - 1 ]++ # } # # if digits [ 0 ] > 9 { # digits [ 0 ] -= 1 0 # digits = append ([] int { 1 }, digits ...) # } # # return digits
if isIPv 4 ( IP ) { # return " STR " # } else if isIPv 6 ( IP ) { # return " STR " # } # return " STR "
freq , sum , res := make ([] int , len ( A )+ 1 ), 0 , 0 # freq [ 0 ] = 1 # for _ , v := range A { # t := sum + v - S # if t >= 0 { # res += freq [ t ] # } # sum += v # freq [ sum ]++ # fmt . Printf (" STR ", freq , sum , res , t ) # } # return res
t . Parallel () # for _ , tc := range testcases { # if result := MinRemoveNoOverlap ( tc . intervals ); result != tc . removes { # t . Errorf (" STR ", tc . removes , result ) # } # }
qs := [] question 6 2 { # # { # para 6 2 { 3 , 2 }, # ans 6 2 { 3 }, # }, # # { # para 6 2 { 7 , 3 }, # ans 6 2 { 2 8 }, # }, # # { # para 6 2 { 1 , 2 }, # ans 6 2 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 2 , q . para 6 2 # fmt . Printf (" STR ", p , uniquePaths ( p . m , p . n )) # } # fmt . Printf (" STR ")
n := len ( s ) # rs := reverse ( s ) # mirror := s + " STR " + rs # next := make ([] int , 2 * n + 1 ) # for i := 1 ; i < 2 * n + 1 ; i ++ { # j := next [ i - 1 ] # for j > 0 && mirror [ i ] != mirror [ j ] { # j = next [ j - 1 ] # } # if mirror [ i ] == mirror [ j ] { # j ++ # } # next [ i ] = j # # } # return rs [: n - next [ 2 * n ]] + s
random := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # array 1 := make ([] int , random . Intn ( 1 0 0 - 1 0 )+ 1 0 ) # for i := range array 1 { # array 1 [ i ] = random . Intn ( 1 0 0 ) # } # array 2 := make ( sort . IntSlice , len ( array 1 )) # copy ( array 2 , array 1 ) # MergeSort ( array 1 , 0 , len ( array 1 )- 1 ) # array 2 . Sort () # for i := range array 1 { # if array 1 [ i ] != array 2 [ i ] { # t . Fail () # } # }
AppConfig = Configuration {}
t := s . value . Type () # # field , ok := t . FieldByName ( name ) # if ! ok { # return nil , false # } # # return & Field { # field : field , # value : s . value . FieldByName ( name ), # defaultTag : s . TagName , # }, true
cases := [] Case {} # N := 1 0 # for i := 0 ; i < N ; i ++ { # name := " STR " # input := UnmarshalListByRand ( 1 0 0 , 1 0 0 0 0 0 ) # exect := Solution ( input ) # cases = append ( cases , Case { Name : name , Input : input , Expect : exect }) # } # for _ , c := range cases { # t . Run ( c . Name , func ( t * testing . T ) { # got := Solution ( c . Input ) # if isEqual ( got , c . Expect ) { # t . Fatalf (" STR ", # c . Expect , got , c . Input ) # } # }) # }
tests := [...] testType { # { # s : " STR ", # k : 2 , # want : " STR ", # }, # { # s : " STR ", # k : 4 , # want : " STR ", # }, # { # s : " STR ", # k : 4 , # want : " STR ", # }, # { # s : " STR ", # k : 8 , # want : " STR ", # }, # } # for _ , tt := range tests { # got := reverseStr ( tt . s , tt . k ) # if got != tt . want { # t . Fatalf (" STR ", tt . s , tt . k , got , tt . want ) # } # }
end , factor , prod := 2 0 , 0 , 1 # factormax := make ([] int , end ) # # for n := 2 ; n <= end ; n ++ { # num := n # factornum := make ([] int , end ) # for num != 1 { # factor = chop ( num ) # factornum [ factor - 1 ]++ # num = num / factor # } # for i := 0 ; i < end ; i ++ { # factormax [ i ] = max ( factornum [ i ], factormax [ i ]) # } # } # for i := 0 ; i < end ; i ++ { # prod *= pow ( i + 1 , factormax [ i ]) # } # fmt . Println ( prod )
len , count , start := 1 , 9 , 1 # # for n > len * count { # n -= len * count # len ++ # count *= 1 0 # start *= 1 0 # } # # start += ( n - 1 ) / len # s := strconv . Itoa ( start ) # return int ( s [( n - 1 )% len ] - ' 0 ')
fmt . Println ( topKFrequent ([] int { 2 , 2 , 1 , 1 , 1 , 3 }, 2 ))
minOfA := 1 # A = append ( A , minOfA - 1 ) # # size := len ( A ) # sum := 0 # s := new ( stack ) # # for k := 0 ; k < size ; k ++ { # for s . len () > 0 && A [ s . top ()] > A [ k ] { # j := s . pop () # i := s . top () # sum += ( j - i ) * ( k - j ) * A [ j ] # } # s . push ( k ) # } # # return sum % modulo
tests := [...] testType { # { # in : " STR ", # want : 1 , # }, # { # in : " STR ", # want : 3 , # }, # { # in : " STR ", # want : 2 6 , # }, # { # in : " STR ", # want : 2 7 , # }, # { # in : " STR ", # want : 2 8 , # }, # { # in : " STR ", # want : 7 0 1 , # }, { # in : " STR ", # want : 7 0 3 , # }, # { # in : " STR ", # want : 1 6 9 0 0 , # }, # } # for _ , tt := range tests { # got := titleToNumber ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if root == nil { # return false # } # # if root . Left == nil && root . Right == nil { # return targetSum == root . Val # } # return hasPathSum ( root . Left , targetSum - root . Val ) || hasPathSum ( root . Right , targetSum - root . Val )
return item . prev
if grid [ 0 ][ 0 ] == 1 { # return - 1 # } # # N := len ( grid ) # # cells := make ([][ 2 ] int , 1 , N * N ) # grid [ 0 ][ 0 ] = 1 # length := 1 # # for len ( cells ) > 0 { # size := len ( cells ) # for s := 0 ; s < size ; s ++ { # c := cells [ s ] # x , y := c [ 0 ], c [ 1 ] # if x == N - 1 && y == N - 1 { # return length # } # for k := 0 ; k < 8 ; k ++ { # i , j := x + dx [ k ], y + dy [ k ] # if i < 0 || N <= i || # j < 0 || N <= j || # grid [ i ][ j ] == 1 { # continue # } # cells = append ( cells , [ 2 ] int { i , j }) # grid [ i ][ j ] = 1 # } # } # length ++ # cells = cells [ size :] # } # # return - 1
heights = append ( heights , - 1 ) # hLen := len ( heights ) # # left , right := 0 , 0 # area , maxArea := 0 , 0 # # stack := [] int {} # # for right < hLen { # if len ( stack ) == 0 || heights [ stack [ len ( stack )- 1 ]] <= heights [ right ] { # stack = append ( stack , right ) # right ++ # continue # } # # height := heights [ stack [ len ( stack )- 1 ]] # stack = stack [: len ( stack )- 1 ] # # if len ( stack ) == 0 { # left = - 1 # } else { # left = stack [ len ( stack )- 1 ] # } # # area = height * ( right - left - 1 ) # if area > maxArea { # maxArea = area # } # } # # return maxArea
return count ( nums , 0 , len ( nums ))
t . Parallel () # for _ , tc := range testcases { # if result := SmallestNumberOfPerfectSquaresSum ( tc . n ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
tmp , err := xtime . ParseDuration ( string ( text )) # if err == nil { # * d = Duration ( tmp ) # } # return err
tests := [] string { # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # } # results := [] int { # 3 , # 1 , # 5 , # 0 , # 3 , # } # caseNum := 5 # for i := 0 ; i < caseNum ; i ++ { # if ret := lengthOfLongestSubstring ( tests [ i ]); ret != results [ i ] { # t . Fatalf (" STR ", i , ret , results [ i ]) # } # }
tests := [...] testType { # { # in : [] int { 1 , 2 , 3 , 4 }, # want : false , # }, # { # in : [] int { 3 , 1 , 4 , 2 }, # want : true , # }, # { # in : [] int {- 1 , 3 , 2 , 0 }, # want : true , # }, # } # for _ , tt := range tests { # got := find 1 3 2 pattern ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if len ( arr ) <= 1 { # return arr # } # # middle := len ( arr ) / 2 # # left := MergeSort ( arr [: middle ]) # right := MergeSort ( arr [ middle :]) # # return Merge ( left , right )
return strings . Split ( s , " STR ")
x := xyrange * ( float 6 4 ( i )/ cells - 0 . 5 ) # y := xyrange * ( float 6 4 ( j )/ cells - 0 . 5 ) # # z := f ( x , y ) # # sx := width / 2 + ( x - y )* cos 3 0 * xyscale # sy := height / 2 + ( x + y )* sin 3 0 * xyscale - z * zscale # return sx , sy
var ur , ul , dr , dl = 1 , 1 , 1 , 1 # var diff = 2 # var sum = 1 # var n = 1 0 0 1 # # for ; ur < n * n ; { # dr += diff # diff += 2 # dl += diff # diff += 2 # ul += diff # diff += 2 # ur += diff # diff += 2 # # sum += dr + dl + ul + ur # } # # return sum
primes := PrimesBelow ( 8 7 4 0 0 ) # bPos := primes [ 0 : 1 6 8 ] # max , p := 0 , 0 # for a := - 9 9 9 ; a < 1 0 0 0 ; a += 2 { # for i := 1 ; i < len ( bPos ); i ++ { # for j := 0 ; j < 2 ; j ++ { # n := 0 # sign := 1 # if j != 0 { # sign = - 1 # } # aodd := 0 # if i % 2 == 0 { # aodd = - 1 # } # for IsPrime ( abs ( n * n +( a + aodd )* n + sign * bPos [ i ]), primes ) { # n ++ # } # if max < n { # max = n # p = a * bPos [ i ] # } # } # } # } # return p
ret := [] string {} # for i := 1 ; i <= n ; i ++ { # if i % 3 == 0 && i % 5 == 0 { # ret = append ( ret , " STR ") # } else if i % 3 == 0 { # ret = append ( ret , " STR ") # } else if i % 5 == 0 { # ret = append ( ret , " STR ") # } else { # ret = append ( ret , strconv . Itoa ( i )) # } # } # return ret
this . mutex . Lock () # defer this . mutex . Unlock () # # if this . closed { # return 0 # } # return MaxInt ( 0 , this . maxItems - this . list . Len ())
m := len ( mat ) # if m == 0 { # return false # } # # n := len ( mat [ 0 ]) # if n == 0 { # return false # } # # if target < mat [ 0 ][ 0 ] || mat [ m - 1 ][ n - 1 ] < target { # return false # } # # r := 0 # for r < m && mat [ r ][ 0 ] <= target { # r ++ # } # r -- # # i , j := 0 , n - 1 # for i <= j { # med := ( i + j ) / 2 # switch { # case mat [ r ][ med ] < target : # i = med + 1 # case target < mat [ r ][ med ]: # j = med - 1 # default : # return true # } # } # # return mat [ r ][ j ] == target
ans := 0 # for i := 0 ; i < len ( s ); i ++ { # if s [ i ] != ' ' && ( 0 == i || ' ' == s [ i - 1 ]) { # ans ++ # } # } # return ans
if i >= m 1 || j >= n 1 || si + sj > k 1 || visited [ i ][ j ] { # return 0 # } # visited [ i ][ j ] = true # # sj 1 := sj + 1 # si 1 := si + 1 # if ( j + 1 )% 1 0 == 0 { # sj 1 = sj - 8 # } # if ( i + 1 )% 1 0 == 0 { # si 1 = si - 8 # } # # return 1 + dfs ( i , j + 1 , si , sj 1 ) + dfs ( i + 1 , j , si 1 , sj )
t . Parallel () # for _ , tc := range testcases { # if result , err := MinimumSteps ( tc . board , tc . start , tc . end , # make ( map [ Cell ] struct {})); result != tc . expected || err != tc . err { # t . Errorf (" STR ", # tc . expected , tc . err , result , err ) # } # }
int 6 4 Val := int 6 4 ( math . Float 6 4 bits ( value )) # self . PushLong ( int 6 4 Val )
if len ( nums ) == 0 { # return 0 # } # if len ( nums ) == 1 { # return nums [ 0 ] # } # dp := make ([] int , len ( nums )) # dp [ 0 ] = nums [ 0 ] # dp [ 1 ] = mymax ( nums [ 0 ], nums [ 1 ]) # for i := 2 ; i < len ( nums ); i ++ { # dp [ i ] = mymax ( dp [ i - 2 ]+ nums [ i ], dp [ i - 1 ]) # } # return dp [ len ( nums )- 1 ]
dp := make ([][ 2 ] int , len ( nums )+ 1 ) # # for i := 1 ; i <= len ( nums ); i ++ { # dp [ i ][ 0 ] = max ( dp [ i - 1 ][ 0 ], dp [ i - 1 ][ 1 ]) # dp [ i ][ 1 ] = nums [ i - 1 ] + dp [ i - 1 ][ 0 ] # } # return max ( dp [ len ( nums )][ 0 ], dp [ len ( nums )][ 1 ])
max := int 6 4 ( 1 0 0 0 0 ) # # sum := 0 # for i := int 6 4 ( 1 0 ); i < max ; i ++ { # if isLychrel ( i ) { # sum ++ # } # } # fmt . Println ( sum )
println (" STR ", s . a )
var s int # for _ , c := range m . cache { # s += c . Len () # } # return s
for node := list . Head ; node != nil ; node = node . Next { # n := node . Value .(* Node ) # f ( n ) # }
wg . Add ( 3 ) # randoms := make ( chan int ) # fibs := make ( chan fibvalue ) # go randomCounter ( randoms ) # go generateFibonacci ( fibs , randoms ) # go printFibonacci ( fibs ) # wg . Wait ()
if index >= da . Size || index < 0 { # return errors . New (" STR ") # } # return nil
for r := 0 ; r < len ( matrix ); r ++ { # for c := 0 ; c < len ( matrix [ 0 ]); c ++ { # if r > 0 && c > 0 && matrix [ r - 1 ][ c - 1 ] != matrix [ r ][ c ] { # return false # } # } # } # return true
const ( # plainText = " STR " # size = 5 # characters = " STR " # key = " STR " # ) # p , err := NewPolybius ( key , size , characters ) # if err != nil { # log . Fatalf (" STR ", err ) # } # encryptedText , err := p . Encrypt ( plainText ) # if err != nil { # log . Fatalf (" STR ", err ) # } # fmt . Printf (" STR ", plainText , encryptedText ) # # decryptedText , err := p . Decrypt ( encryptedText ) # if err != nil { # log . Fatalf (" STR ", err ) # } # fmt . Printf (" STR ", encryptedText , decryptedText ) #
itemIndex := 0 # for itemIndex < len ( array )- 1 { # if array [ itemIndex ] > array [ itemIndex + 1 ] { # array [ itemIndex ], array [ itemIndex + 1 ] = array [ itemIndex + 1 ], array [ itemIndex ] # if itemIndex != 0 { # itemIndex -= 1 # } # } else { # itemIndex += 1 # } # }
N = ( N - 1 )% 1 4 + 1 # # n := cells 2 int ( cells ) # # for i := 0 ; i < N ; i ++ { # n = (^(( n >> 1 ) ^ ( n << 1 ))) & 0 x 7 e # } # # return int 2 cells ( n )
mm := [] byte ( moves ) # if len ( moves ) == 0 { # return true # } # su , sd , sl , sr := 0 , 0 , 0 , 0 # for _ , v := range mm { # if v == ' U ' { # su ++ # } # if v == ' D ' { # sd ++ # } # if v == ' L ' { # sl ++ # } # if v == ' R ' { # sr ++ # } # } # return su == sd && sl == sr
var stack * Stack = new ( Stack ) # # stack . depth = 0 # return stack
i := & Index { # Target : & VariableAccess { Name : " STR "}, # Key : & LiteralNode { # Typex : TypeInt , # Value : 1 , # }, # } # # scope := & BasicScope { # VarMap : map [ string ] Variable { # " STR ": Variable { # Type : TypeList , # Value : [] Variable {}, # }, # }, # } # # actual , err := i . Type ( scope ) # if err == nil || ! strings . Contains ( err . Error (), " STR ") { # t . Fatalf (" STR ", err ) # } # if actual != TypeInvalid { # t . Fatalf (" STR ", actual ) # }
ret := i # for _ , i := range rest { # if i < ret { # ret = i # } # } # return ret
rows , cols , blocks := make ([] map [ byte ] bool , 9 ), make ([] map [ byte ] bool , 9 ), make ([] map [ byte ] bool , 9 ) # for i := 0 ; i < 9 ; i ++ { # rows [ i ], cols [ i ], blocks [ i ] = make ( map [ byte ] bool ), make ( map [ byte ] bool ), make ( map [ byte ] bool ) # } # # for i := 0 ; i < 9 ; i ++ { # for j := 0 ; j < 9 ; j ++ { # if board [ i ][ j ] != '.' { # blockIndex , n := ( i / 3 )* 3 + j / 3 , board [ i ][ j ] # rows [ i ][ n ], cols [ j ][ n ], blocks [ blockIndex ][ n ] = true , true , true # } # } # } # # helper 3 7 ( board , 0 , 0 , rows , cols , blocks )
mask := ^ 0 # for num & mask != 0 { # mask <<= 1 # } # return ^ mask & ^ num
if 0 > x || ( 0 == x % 1 0 && 0 != x ) { # return false # } # # var revertedNumber int # for x > revertedNumber { # revertedNumber = revertedNumber * 1 0 + x % 1 0 # x /= 1 0 # } # # return ( x == revertedNumber ) || ( x == revertedNumber / 1 0 )
getCharCounts := func ( str string ) map [ rune ] int { # counts := make ( map [ rune ] int ) # for _ , r := range str { # counts [ r ] = counts [ r ] + 1 # } # # return counts # } # # maxCounts := make ( map [ rune ] int , 0 ) # for _ , str := range B { # countsB := getCharCounts ( str ) # for r , c := range countsB { # if maxCounts [ r ] < c { # maxCounts [ r ] = c # } # } # } # # result := make ([] string , 0 ) # for _ , str := range A { # countsA := getCharCounts ( str ) # isValid := true # # for r , c := range maxCounts { # if countsA [ r ] < c { # isValid = false # break # } # } # # if isValid { # result = append ( result , str ) # } # } # # return result
var res [] int # for 0 < label { # res = append ( res , label ) # label >>= 1 # } # # i , j := 0 , len ( res )- 1 # for i < j { # res [ i ], res [ j ] = res [ j ], res [ i ] # i ++ # j -- # } # # y := len ( res ) % 2 # for k , v := range res { # if k % 2 == y { # res [ k ] = 1 <<( k + 1 ) + 1 << k - v - 1 # } # } # # return res
nums := make ([] int , n ) # nums [ 0 ] = 1 # for i := 0 ; i < m ; i ++ { # for j := 1 ; j < n ; j ++ { # nums [ j ] += nums [ j - 1 ] # } # } # return nums [ n - 1 ]
x , y := f ( 5 0 ) # fmt . Println ( x , y )
return (& EwmaRate {}). Init ( halfLife )
fmt . Println ( badFrequencySort (" STR ")) # fmt . Println ( frequencySort (" STR "))
inputSlice := generateInput ( 9 9 9 ) # multiplesOf 3 or 5 := inputSlice . getMultiplesOf 3 or 5 () # sumOfMultiplesOf 3 or 5 := multiplesOf 3 or 5 . sumAllNumbers () # # fmt . Println (" STR ", multiplesOf 3 or 5 ) # fmt . Println (" STR ", sumOfMultiplesOf 3 or 5 )
for i , a := range n . Args { # n . Args [ i ] = a . Accept ( v ) # } # # return v ( n )
if i < 0 { # return a [ len ( a )+ i ] # } # return a [ i ]
t . Run (" STR ", func ( t * testing . T ) { # nums 1 := [] int { 1 , 2 , 3 , 0 , 0 , 0 } # m := 3 # nums 2 := [] int { 2 , 5 , 6 } # n := 3 # # merge ( nums 1 , m , nums 2 , n ) # # fmt . Println ( nums 1 ) # # })
left , right , steps := 0 , 0 , 0 # for right < len ( nums )- 1 { # max := right + 1 # for i := left ; i <= right ; i ++ { # if max < nums [ i ]+ i { # max = nums [ i ] + i # } # } # # left = right + 1 # right = max # steps ++ # } # # return steps
nums := [] int {} # for i := 0 ; i < N ; i ++ { # nums = append ( nums , rand . Int ()) # } # nums = append ( nums , 7 , 2 ) # # b . ResetTimer () # for i := 0 ; i < b . N ; i ++ { # TwoSum 1 ( nums , 9 ) # }
n := len ( ratings ) # if n < 2 { # return n # } # num := make ([] int , n ) # for i := 0 ; i < n ; i ++ { # num [ i ] = 1 # } # for i := 1 ; i < n ; i ++ { # if ratings [ i ] > ratings [ i - 1 ] { # num [ i ] = num [ i - 1 ] + 1 # } # } # for i := n - 1 ; i > 0 ; i -- { # if ratings [ i - 1 ] > ratings [ i ] && num [ i ]+ 1 > num [ i - 1 ] { # num [ i - 1 ] = num [ i ] + 1 # } # } # # sum := 0 # for _ , i := range num { # sum += i # } # return sum
tree := & TreeNode { # Val : 4 , # Right : & TreeNode { Val : 4 }, # } # fmt . Println ( tree 2 str ( tree ))
unique := make ( map [ int ] bool , len ( a )) # var prev , next [] int # for _ , x := range a { # isInNext := make ( map [ int ] bool , len ( prev )) # isInNext [ x ], unique [ x ] = true , true # next = append ( next , x ) # for _ , y := range prev { # y |= x # if ! isInNext [ y ] { # isInNext [ y ], unique [ y ] = true , true # next = append ( next , y ) # } # } # prev , next = next , prev [: 0 ] # } # return len ( unique )
var stack * Stack = New () # # stack . Push ( 1 ) # stack . Push ( 2 ) # stack . Push ( 3 ) # stack . Push ( 4 ) # stack . Push ( 5 ) # # for i := 5 ; i > 0 ; i -- { # item := stack . Pop () # # if item != i { # t . Error (" STR ", i ) # } # }
var notifiedUser , notifiedMsg string # notifyUser = func ( user , msg string ) { # notifiedUser , notifiedMsg = user , msg # } # # const user = " STR " # usage [ user ] = 9 8 0 0 0 0 0 0 0 # # CheckQuota ( user ) # if notifiedUser == " STR "" { # t . Fatalf (" STR ") # } # if notifiedUser != user { # t . Errorf (" STR ", # notifiedUser , user ) # } # const wantSubstring = " STR " # if ! strings . Contains ( notifiedMsg , wantSubstring ) { # t . Errorf (" STR "+ # " STR ", notifiedMsg , wantSubstring ) # }
t . Parallel () # for _ , tc := range testcases { # if result := IsKPalindromeBrute ( tc . input , tc . k ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
dp , mod := make ([][] int , L + 1 ), 1 0 0 0 0 0 0 0 0 7 # for i := 0 ; i < L + 1 ; i ++ { # dp [ i ] = make ([] int , N + 1 ) # } # dp [ 0 ][ 0 ] = 1 # for i := 1 ; i <= L ; i ++ { # for j := 1 ; j <= N ; j ++ { # dp [ i ][ j ] = ( dp [ i - 1 ][ j - 1 ] * ( N - ( j - 1 ))) % mod # if j > K { # dp [ i ][ j ] = ( dp [ i ][ j ] + ( dp [ i - 1 ][ j ]*( j - K ))% mod ) % mod # } # } # } # return dp [ L ][ N ]
if len ( s ) != len ( t ) { # return false # } # counts := [ 2 5 6 ] rune {} # for _ , r := range s { # counts [ r ]++ # } # for _ , r := range t { # counts [ r ]-- # } # for _ , c := range counts { # if c != 0 { # return false # } # } # return true
h := newLtHeapArray () # testHeap ( t , h )
sum := 0 # for i := 1 ; i < 1 0 0 0 ; i ++ { # if i % 3 == 0 || i % 5 == 0 { # sum += i # } # } # # fmt . Println ( sum )
l := len ( S ) # dp := make ([][] int , l + 1 ) # for i := 0 ; i < l + 1 ; i ++ { # dp [ i ] = make ([] int , 2 ) # } # for i := 1 ; i <= l ; i ++ { # if S [ i - 1 ] == ' 0 ' { # dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ] # dp [ i ][ 1 ] = mymin ( dp [ i - 1 ][ 0 ], dp [ i - 1 ][ 1 ]) + 1 # } else { # dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ] + 1 # dp [ i ][ 1 ] = mymin ( dp [ i - 1 ][ 0 ], dp [ i - 1 ][ 1 ]) # } # } # return mymin ( dp [ l ][ 0 ], dp [ l ][ 1 ])
result = 0 # # if r > n { # err = errors . New ( fmt . Sprintf (" STR ", n , r )) # return # } # # a := Factorial ( big . NewInt ( n )) # b := Factorial ( big . NewInt ( r )) # c := Factorial ( big . NewInt ( n - r )) # # divisor := new ( big . Int ) # divisor . Mul ( b , c ) # # divResult := new ( big . Int ) # divResult . Div ( a , divisor ) # # result = divResult . Uint 6 4 () # # return
node := NewNode ( value ) # # if l . Len () == 0 { # l . Head = node # l . Tail = l . Head # } else { # formerTail := l . Tail # formerTail . Next = node # # node . Prev = formerTail # l . Tail = node # } # # l . Length ++
cases := [] struct { # name string # inputs int # expect int # }{ # {" STR ", 2 , 2 }, # {" STR ", 3 , 3 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := climbStairs ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
n := len ( persons ) # m := make ([] int , n ) # count := make ([] int , n ) # lead := - 1 # for i , person := range persons { # count [ person ]++ # if i == 0 || count [ person ] >= count [ lead ] { # lead = person # } # m [ i ] = lead # } # return TopVotedCandidate { # m : m , # t : times , # }
n := len ( S ) # if n == 0 { # return " STR " # } # m := map [ byte ] struct {}{} # for _ , vowel := range [] byte (" STR ") { # m [ vowel ] = struct {}{} # } # bs := strings . Builder {} # index := 1 # for _ , word := range strings . Fields ( S ) { # if index != 1 { # bs . WriteByte (' ') # } # f := word [ 0 ] # if _ , ok := m [ f ]; ok { # bs . WriteString ( word ) # } else { # bs . WriteString ( word [ 1 :]) # bs . WriteByte ( f ) # } # bs . WriteString (" STR ") # for i := 0 ; i < index ; i ++ { # bs . WriteByte (' a ') # } # index ++ # } # return bs . String ()
if p 4 := net . ParseIP ( IP ). To 4 (); len ( p 4 ) == net . IPv 4 len && p 4 . String () == IP { # return " STR " # } else if regexp . MustCompile (`^([ 0 - 9 A - Fa - f ]{ 1 , 4 }:){ 7 }[ 0 - 9 A - Fa - f ]{ 1 , 4 }$`). MatchString ( IP ) { # return " STR " # } # return " STR "
max := 1 0 0 # # var commonDigit , newI , newJ int # nominatorProduct , denominatorProduct := 1 , 1 # for i := 1 0 ; i < max ; i ++ { # for j := i + 1 ; j < max ; j ++ { # commonDigit = getCommonDigit ( i , j ) # if commonDigit > 0 { # newI , newJ = removeDigitFromTwoDigitsNumber ( i , commonDigit ), removeDigitFromTwoDigitsNumber ( j , commonDigit ) # if newI != 0 && newJ != 0 { # if float 6 4 ( i )/ float 6 4 ( j ) == float 6 4 ( newI )/ float 6 4 ( newJ ) { # fmt . Printf (" STR ", i , j , newI , newJ ) # nominatorProduct *= newI # denominatorProduct *= newJ # } # } # } # } # } # # gcd := gcd ( nominatorProduct , denominatorProduct ) # fmt . Println ( denominatorProduct / gcd )
if numRows == 0 { # return [][] int {} # } # # var res = make ([][] int , numRows ) # res [ 0 ] = [] int { 1 } # for i := 1 ; i < numRows ; i ++ { # internalArr := make ([] int , i + 1 ) # internalArr [ 0 ] = 1 # internalArr [ len ( internalArr )- 1 ] = 1 # for j := 1 ; j < len ( internalArr )- 1 ; j ++ { # internalArr [ j ] = res [ i - 1 ][ j - 1 ] + res [ i - 1 ][ j ] # } # res [ i ] = internalArr # } # return res
s := [] byte ( str ) # for i := 0 ; i < len ( s ); i ++ { # if s [ i ] >= ' A ' && s [ i ] <= ' Z ' { # s [ i ] += ' a ' - ' A ' # } # } # return string ( s )
return int ( pc [ byte ( x >>( 0 * 8 ))] + # pc [ byte ( x >>( 1 * 8 ))] + # pc [ byte ( x >>( 2 * 8 ))] + # pc [ byte ( x >>( 3 * 8 ))] + # pc [ byte ( x >>( 4 * 8 ))] + # pc [ byte ( x >>( 5 * 8 ))] + # pc [ byte ( x >>( 6 * 8 ))] + # pc [ byte ( x >>( 7 * 8 ))])
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", [][] int {{ 4 , 5 , 6 , 7 , 0 , 1 , 2 }, { 0 }}, 4 }, # {" STR ", [][] int {{ 4 , 5 , 6 , 7 , 0 , 1 , 2 }, { 3 }}, - 1 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := search ( c . inputs [ 0 ], c . inputs [ 1 ][ 0 ]) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
t . Parallel () # for _ , tc := range testcases { # if possible := CanAdvanceToEndBrute ( tc . advanceFrom ); possible != tc . possible { # t . Errorf (" STR ", tc . advanceFrom , tc . possible , possible ) # } # }
cases := [] struct { # name string # inputs string # expect [] string # }{ # {" STR ", " STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := depthSolution ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
f , err := os . Open ( os . Args [ 1 ]) # if err != nil { # panic ( err ) # } # defer f . Close () # # h := fnv . New 6 4 () # io . Copy ( h , f ) # fmt . Println (" STR ", h . Sum 6 4 ())
t . Parallel () # for tcid , tc := range testcases { # if result := SortedSliceToBST ( tc . sorted ); ! equal ( tc . expected , result ) { # t . Errorf (" STR ", tcid ) # } # }
nums := [] int { 5 , 4 , 3 , 2 , 1 } # # fmt . Println ( findRelativeRanks ( nums ))
var res = [] int {} # # var target , window [ 2 6 ] int # for i := 0 ; i < len ( p ); i ++ { # target [ p [ i ]-' a ']++ # } # # check := func ( i int ) { # if window == target { # res = append ( res , i ) # } # } # # for i := 0 ; i < len ( s ); i ++ { # window [ s [ i ]-' a ']++ # if i == len ( p )- 1 { # check ( 0 ) # } else if len ( p ) <= i { # window [ s [ i - len ( p )]-' a ']-- # check ( i - len ( p ) + 1 ) # } # } # # return res
if nil == nums { # return # } # # length := len ( nums ) # if k > length { # k %= length # } # if 0 == k || k == length { # return # } # # reverse ( nums ) # reverse ( nums [: k ]) # reverse ( nums [ k :])
w := ( int )( math . Sqrt ( float 6 4 ( area ))) # for area % w != 0 { # w -- # } # return [] int { area / w , w }
return LRUCache { # cap : capacity , # nodes : make ( map [ int ]* dLinkedNode , capacity ), # }
aChar := [] rune ( a ) # bChar := [] rune ( b ) # var s [] rune # var c rune # i , j := len ( a )- 1 , len ( b )- 1 # for i >= 0 || j >= 0 || c == 1 { # if i >= 0 { # c += aChar [ i ] - ' 0 ' # i -- # } # if j >= 0 { # c += bChar [ j ] - ' 0 ' # j -- # } # s = append ( s , c % 2 +' 0 ') # c /= 2 # } # # for i , j := 0 , len ( s )- 1 ; i < j ; i , j = i + 1 , j - 1 { # s [ i ], s [ j ] = s [ j ], s [ i ] # } # # return string ( s )
i := & Index { # Target : & VariableAccess { Name : " STR "}, # Key : & LiteralNode { # Typex : TypeString , # Value : " STR ", # }, # } # # scope := & BasicScope { # VarMap : map [ string ] Variable { # " STR ": Variable { # Type : TypeMap , # Value : map [ string ] Variable {}, # }, # }, # } # # actual , err := i . Type ( scope ) # if err == nil || ! strings . Contains ( err . Error (), " STR ") { # t . Fatalf (" STR ", err ) # } # if actual != TypeInvalid { # t . Fatalf (" STR ", actual ) # }
t . Parallel () # # for _ , tc := range testcases { # if pairs := PositiveIntegerPairs ( tc . m , tc . n ); ! reflect . DeepEqual ( pairs , tc . expected ) { # t . Errorf (" STR ", tc . expected , pairs ) # } # }
sum , r := sumAndMax ( piles ) # l := ( sum + h - 1 ) / h # # for l < r { # m := ( l + r ) / 2 # if canEatAll ( m , h , piles ) { # r = m # } else { # l = m + 1 # } # } # # return r
res := 0 # # for i := 0 ; i < len ( s ); i ++ { # temp := int ( s [ i ] - ' A ' + 1 ) # res = res * 2 6 + temp # } # # return res
var tests = [] struct { # tree * TreeNode # maxSum int # }{ # { newTree (- 3 ), - 3 }, # { newTree ( 1 , 2 , 3 ), 6 }, # { newTree (- 1 0 , 9 , 2 0 , nil , nil , 1 5 , 7 ), 4 2 }, # { newTree ( 5 , 4 , 8 , 1 1 , nil , 1 3 , 4 , 7 , 2 , nil , nil , 1 ), 4 8 }, # } # # for _ , tt := range tests { # maxSum := maxPathSum ( tt . tree ) # if maxSum != tt . maxSum { # t . Errorf (" STR ", tt . tree , maxSum , tt . maxSum ) # } # }
orig := [] rune ( str ) # rev := make ([] rune , len ( orig )) # # for i := 0 ; i < len ( orig ); i ++ { # rev [ i ] = orig [ len ( orig )- 1 - i ] # } # # return isKPalindromeBrute ( orig , rev , len ( orig ), len ( rev )) <= k * 2
left , right := 0 , len ( nums )- 1 # # for left < right { # mid := left + ( right - left )/ 2 # if nums [ mid ] == target { # return mid # } else if nums [ mid ] < target { # left = mid + 1 # } else if nums [ mid ] > target { # right = mid - 1 # } # } # return - 1
if len ( nums ) == 0 { # return 0 # } # j := 0 # for i := 0 ; i < len ( nums ); i ++ { # if nums [ i ] != val { # if i != j { # nums [ i ], nums [ j ] = nums [ j ], nums [ i ] # j ++ # } else { # j ++ # } # } # } # return j
el := l . Front () # l . Remove ( el ) # return el
size := len ( s ) # if size == 0 { # return 0 # } # res := 0 # for i := size - 1 ; i >= 0 ; i -- { # if s [ i ] == ' ' { # if res != 0 { # return res # } # continue # } # res ++ # } # # return res
return n > 0 && n &( n - 1 ) == 0 && n & 0 x 5 5 5 5 5 5 5 5 == n
var m = map [* Node ] struct {}{} # for p != nil { # m [ p ] = struct {}{} # p = p . Parent # } # # for q != nil { # if _ , ok := m [ q ]; ok { # return q # } # q = q . Parent # } # return nil
benchmarkHashMapInsert ( b , newOpenHashMap ())
m , n := len ( A ), len ( A [ 0 ]) # # var dfs func ( int , int ) # dfs = func ( x , y int ) { # if x < 0 || m <= x || # y < 0 || n <= y || # A [ x ][ y ] == 0 { # return # } # A [ x ][ y ] = 0 # for i := 0 ; i < 4 ; i ++ { # dfs ( x + dx [ i ], y + dy [ i ]) # } # } # # line := func ( i , di , j , dj int ) { # for i < m && j < n { # dfs ( i , j ) # i += di # j += dj # } # } # # line ( 0 , 0 , 0 , 1 ) # line ( m - 1 , 0 , 0 , 1 ) # line ( 0 , 1 , 0 , 0 ) # line ( 0 , 1 , n - 1 , 0 ) # # res := 0 # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # res += A [ i ][ j ] # } # } # # return res
letters := [] rune ( str ) # favorLeft := make ([] rune , len ( letters )) # copy ( favorLeft , letters ) # favorRight := make ([] rune , len ( letters )) # copy ( favorRight , letters ) # left , right := 0 , len ( favorLeft )- 1 # for left < right { # if favorLeft [ left ] != favorLeft [ right ] { # favorLeft = append ( favorLeft , ' x ') # copy ( favorLeft [ right + 2 :], favorLeft [ right + 1 :]) # favorLeft [ right + 1 ] = favorLeft [ left ] # right ++ # } # left ++ # right -- # } # left , right = 0 , len ( favorRight )- 1 # for left < right { # if favorRight [ left ] != favorRight [ right ] { # favorRight = append ( favorRight , ' x ') # copy ( favorRight [ left + 1 :], favorRight [ left :]) # favorRight [ left ] = favorRight [ right + 1 ] # right ++ # } # left ++ # right -- # } # return chooseResult ( favorLeft , favorRight )
qs := [] question 1 2 6 { # { # para 1 2 6 {" STR ", " STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 1 2 6 {[][] string {{" STR ", " STR ", " STR ", " STR ", " STR "}, {" STR ", " STR ", " STR ", " STR ", " STR "}}}, # }, # # { # para 1 2 6 {" STR ", " STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 1 2 6 {[][] string {}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 6 , q . para 1 2 6 # fmt . Printf (" STR ", p , findLadders ( p . b , p . e , p . w )) # } # fmt . Printf (" STR ")
if res , ok := check ( A , B , A [ 0 ]); ok { # return res # } # if res , ok := check ( A , B , B [ 0 ]); ok { # return res # } # return - 1
a := 1 # b := a + 1 # c := 1 0 0 0 - ( a + b ) # # for ; (( a + b ) <= 1 0 0 0 ) && (( a * a ) + ( b * b ) < ( c * c )) ; a ++ { # for ; (( a + b ) <= 1 0 0 0 ) && (( a * a ) + ( b * b ) < ( c * c )) ; b ++ { # c = 1 0 0 0 - ( a + b ) # sum := ( a * a ) + ( b * b ) # cval := ( c * c ) # if sum == cval { # fmt . Printf (" STR ", a , b , c ) # answer := ( a * b * c ) # fmt . Printf (" STR ", answer ) # return # } # } # b = a + 1 # c = 1 0 0 0 - ( a + b ) # }
hasher := sha 1 . New () # hasher . Write ( b ) # copy ( ret [:], hasher . Sum ( nil )) # return
var allox int # for i := range nums { # allox ^= nums [ i ] # } # mask := 1 # for ; mask & allox == 0 ; mask <<= 1 { # } # var ret 1 , ret 2 int # for i := range nums { # if nums [ i ]& mask != 0 { # ret 1 ^= nums [ i ] # } else { # ret 2 ^= nums [ i ] # } # } # return [] int { ret 1 , ret 2 }
for _ , tc := range testcases { # buff := new ( bytes . Buffer ) # out = buff # PrintZigZag ( tc . letters , tc . k ) # if result := buff . String (); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
total := 0 # for _ , n := range nums { # total += n # } # if S > total || ( S + total )% 2 == 1 { # return 0 # } # target := ( S + total ) / 2 # dp := make ([] int , target + 1 ) # dp [ 0 ] = 1 # for _ , n := range nums { # for i := target ; i >= n ; i -- { # dp [ i ] += dp [ i - n ] # } # } # return dp [ target ]
c := & Call { Func : " STR "} # scope := & BasicScope { # FuncMap : map [ string ] Function { # " STR ": Function { ReturnType : TypeString }, # }, # } # # actual , err := c . Type ( scope ) # if err != nil { # t . Fatalf (" STR ", err ) # } # if actual != TypeString { # t . Fatalf (" STR ", actual ) # }
bs := [] byte ( S ) # shift := 0 # for i := len ( bs ) - 1 ; i >= 0 ; i -- { # shift += shifts [ i ] # bs [ i ] = byte (( int ( S [ i ]-' a ')+ shift )% 2 6 + ' a ') # } # return string ( bs )
var ret int # var nums [] int # # nums = [] int { 1 , 8 , 6 , 2 , 5 , 4 , 8 , 3 , 7 } # ret = 4 9 # if ret != maxArea ( nums ) { # t . Fatalf (" STR ", ret ) # }
t . Parallel () # for _ , tc := range testcases { # if result := MinSquared ( tc . n ); result != tc . expected { # t . Errorf (" STR ", tc . n , tc . expected , result ) # } # }
n := len ( A ) # l , h , p , q := 0 ., 1 . 0 , 0 , 1 # for l < h { # mid := ( l + h ) / 2 # count := 0 # p = 0 # for i , j := 0 , n - 1 ; i < n ; i ++ { # for j >= 0 && float 6 4 ( A [ i ]) > mid * float 6 4 ( A [ n - 1 - j ]) { # j -- # } # count += j + 1 # if j >= 0 && p * A [ n - 1 - j ] < q * A [ i ] { # p , q = A [ i ], A [ n - 1 - j ] # } # } # if count == K { # return [] int { p , q } # } else if count < K { # l = mid # } else { # h = mid # } # } # return [] int { p , q }
if head == nil { # return head # } # # length := 0 # node := head # for node != nil { # length , node = length + 1 , node . Next # } # # k = k % length # if k == 0 { # return head # } # # slow , fast := head , head # for i := 0 ; i < k ; i ++ { # fast = fast . Next # } # # for fast . Next != nil { # fast , slow = fast . Next , slow . Next # } # # newHead := slow . Next # slow . Next , fast . Next = nil , head # return newHead
this . mutex . Lock () # defer this . mutex . Unlock () # # if this . total == 0 { # return nil # } # # next := this . nextQueue () # ret := this . queues [ next ]. Remove () # # this . updateRemoval () # # return ret
var freq [ 2 5 6 ] int # if len ( s 2 ) == 0 || len ( s 2 ) < len ( s 1 ) { # return false # } # for i := 0 ; i < len ( s 1 ); i ++ { # freq [ s 1 [ i ]-' a ']++ # } # left , right , count := 0 , 0 , len ( s 1 ) # # for right < len ( s 2 ) { # if freq [ s 2 [ right ]-' a '] >= 1 { # count -- # } # freq [ s 2 [ right ]-' a ']-- # right ++ # if count == 0 { # return true # } # if right - left == len ( s 1 ) { # if freq [ s 2 [ left ]-' a '] >= 0 { # count ++ # } # freq [ s 2 [ left ]-' a ']++ # left ++ # } # } # return false
start := time . Now () # count , n , x := 0 , 1 0 0 0 1 , 1 # for count < n { # x ++ # if x == chop ( x ) { # fmt . Println ( x ) # count ++ # } # } # fmt . Println ( time . Since ( start ))
x , y := productOfConsecutiveNumbers ( 1 3 ) # # fmt . Print (" STR ", x , " STR ", y )
maxPalindrome := 0 # # for i := 9 9 9 ; i > 9 9 ; i -- { # for j := i ; j > 9 9 ; j -- { # p := i * j # # if isPalindrome ( p ) && p > maxPalindrome { # maxPalindrome = p # } # } # } # # fmt . Println ( maxPalindrome )
stackArray = append ([] interface {}{ n }, stackArray ...)
var tests = [] struct { # num int # ugly bool # }{ # { 0 , false }, # { 6 , true }, # { 8 , true }, # { 1 4 , false }, # } # # for _ , tt := range tests { # ugly := isUgly ( tt . num ) # if ugly != tt . ugly { # t . Errorf (" STR ", tt . num , ugly , tt . ugly ) # } # }
r := root .(* gbtElement ) # if r == nil { # r = t . Root ().(* gbtElement ) # } # n := node .(* gbtElement ) # if t . IsNil ( n ) { # return t . NilNode # } # if ! t . IsNil ( n . Left ) { # return t . Max ( n . Left ) # } # cur := n # for cur != r && cur . Parent . Right != cur { # cur = cur . Parent # } # if cur == r { # return t . NilNode # } # return cur . Parent
if row == n { # * count ++ # } # for col := 0 ; col < n ; col ++ { # id 1 := col - row + n # id 2 := col + row # if cols [ col ] || d 1 [ id 1 ] || d 2 [ id 2 ] { # continue # } # cols [ col ] = true # d 1 [ id 1 ] = true # d 2 [ id 2 ] = true # helper ( row + 1 , cols , d 1 , d 2 , n , count ) # cols [ col ] = false # d 1 [ id 1 ] = false # d 2 [ id 2 ] = false # }
if c . writeTimeout != 0 { # c . conn . SetWriteDeadline ( time . Now (). Add ( c . writeTimeout )) # } # if err = c . writeDeleteCommand ( key ); err == nil { # err = c . bw . Flush () # } # if err != nil { # return c . fatal ( err ) # } # if c . readTimeout != 0 { # c . conn . SetReadDeadline ( time . Now (). Add ( c . readTimeout )) # } # err = c . readDeleteReply () # return
return partition ( nums , 0 , len ( nums )- 1 , k )
fmt . Println ( findShortestSubArray ([] int { 1 , 2 , 2 , 3 , 1 })) # fmt . Println ( findShortestSubArray ([] int { 1 , 2 , 2 , 3 , 1 , 4 , 2 }))
for i , j := 0 , len ( s )- 1 ; i < j ; i , j = i + 1 , j - 1 { # for i < len ( s ) && ! unicode . IsLetter ( rune ( s [ i ])) && ! unicode . IsNumber ( rune ( s [ i ])) { # i ++ # } # # for j >= 0 && ! unicode . IsLetter ( rune ( s [ j ])) && ! unicode . IsNumber ( rune ( s [ j ])) { # j -- # } # # if i >= j { # break # } # # chI , chJ := unicode . ToUpper ( rune ( s [ i ])), unicode . ToUpper ( rune ( s [ j ])) # if chI != chJ { # return false # } # } # # return true
t . Parallel () # for tcid , tc := range testcases { # if result := SameTreeSubstructure ( tc . t , tc . s ); result != tc . expected { # t . Errorf (" STR ", tcid , tc . expected , result ) # } # }
qs := [] question 4 5 6 { # # { # para 4 5 6 {[] int {}}, # ans 4 5 6 { false }, # }, # # { # para 4 5 6 {[] int { 1 , 2 , 3 , 4 }}, # ans 4 5 6 { false }, # }, # # { # para 4 5 6 {[] int { 3 , 1 , 4 , 2 }}, # ans 4 5 6 { true }, # }, # # { # para 4 5 6 {[] int {- 1 , 3 , 2 , 0 }}, # ans 4 5 6 { true }, # }, # # { # para 4 5 6 {[] int { 3 , 5 , 0 , 3 , 4 }}, # ans 4 5 6 { true }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 5 6 , q . para 4 5 6 # fmt . Printf (" STR ", p , find 1 3 2 pattern ( p . one )) # } # fmt . Printf (" STR ")
res := [][] string {} # record := make ( map [ string ][] string ) # # for _ , str := range strs { # temp := sortString ( str ) # record [ temp ] = append ( record [ temp ], str ) # } # for _ , v := range record { # sort . Strings ( v ) # res = append ( res , v ) # } # # return res
return BSTIterator { root : root }
cases := [] struct { # name string # input 1 * ListNode # input 2 int # expect * ListNode # }{ # { # " STR ", # UnmarshalListBySlice ([] int { 1 , 2 , 3 , 4 , 5 }), # 2 , # UnmarshalListBySlice ([] int { 2 , 1 , 4 , 3 , 5 })}, # { # " STR ", # UnmarshalListBySlice ([] int { 1 , 2 , 3 , 4 , 5 }), # 3 , # UnmarshalListBySlice ([] int { 3 , 2 , 1 , 4 , 5 }), # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := reverseKGroup ( c . input 1 , c . input 2 ) # if ! isEqual ( got , c . expect ) { # # PrintList ( got ) # PrintList ( c . expect ) # # } # }) # }
dp := make ([] int , amount + 1 ) # for i := 0 ; i <= amount ; i ++ { # dp [ i ] = amount + 1 # } # dp [ 0 ] = 0 # # for i := 1 ; i <= len ( coins ); i ++ { # for j := 0 ; j <= amount ; j ++ { # if j >= coins [ i - 1 ] { # dp [ j ] = int ( math . Min ( float 6 4 ( dp [ j ]), float 6 4 ( dp [ j - coins [ i - 1 ]]+ 1 ))) # } # } # } # if dp [ amount ] > amount { # return - 1 # } else { # return dp [ amount ] # }
tests := [...] testType { # { # nums : [][] int { # { 1 , 2 }, # { 3 , 4 }, # }, # r : 1 , # c : 4 , # want : [][] int { # { 1 , 2 , 3 , 4 }, # }, # }, # { # nums : [][] int { # { 1 , 2 }, # { 3 , 4 }, # }, # r : 2 , # c : 4 , # want : [][] int { # { 1 , 2 }, # { 3 , 4 }, # }, # }, # } # for _ , tt := range tests { # got := matrixReshape ( tt . nums , tt . r , tt . c ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . nums , got , tt . want ) # # } # }
qs := [] question 6 6 8 { # # { # para 6 6 8 { 3 , 3 , 5 }, # ans 6 6 8 { 3 }, # }, # # { # para 6 6 8 { 2 , 3 , 6 }, # ans 6 6 8 { 6 }, # }, # # { # para 6 6 8 { 1 , 3 , 2 }, # ans 6 6 8 { 2 }, # }, # # { # para 6 6 8 { 4 2 , 3 4 , 4 0 1 }, # ans 6 6 8 { 1 2 6 }, # }, # # { # para 6 6 8 { 7 3 4 1 , 1 3 5 3 5 , 1 2 3 3 0 0 2 7 }, # ans 6 6 8 { 2 6 7 3 7 8 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 6 8 , q . para 6 6 8 # fmt . Printf (" STR ", p , findKthNumber ( p . m , p . n , p . k )) # } # fmt . Printf (" STR ")
type arg struct { # root , p , q * TreeNode # } # # testCases := [] arg { # { root : createBinaryTree ([] int { 6 , 2 , 8 , 0 , 4 , 7 , 9 , - 1 , 1 , 3 , 5 }), p : & TreeNode { Val : 3 }, q : & TreeNode { Val : 5 }}, # { p : & TreeNode { Val : 2 }, q : & TreeNode { Val : 8 }}, # } # expected := []* TreeNode {{ Val : 4 }, nil } # # for index , data := range testCases { # if res := lowestCommonAncestor ( data . root , data . p , data . q ); res != nil && res . Val != expected [ index ]. Val { # t . Errorf (" STR ", expected [ index ], res ) # } else if res == nil && res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
bfs := barcodesFrequencySort ( barcodes ) # if len ( bfs ) == 0 { # return [] int {} # } # res := [] int {} # j := ( len ( bfs )- 1 )/ 2 + 1 # for i := 0 ; i <= ( len ( bfs )- 1 )/ 2 ; i ++ { # res = append ( res , bfs [ i ]) # if j < len ( bfs ) { # res = append ( res , bfs [ j ]) # } # j ++ # } # return res
if head == nil || head . Next == nil { # return # } # p 1 , p 2 := head , head . Next # for p 2 != nil && p 2 . Next != nil { # p 1 = p 1 . Next # p 2 = p 2 . Next . Next # } # # cur := p 1 . Next # p 1 . Next = nil # # p 2 = cur . Next # cur . Next = nil # # for p 2 != nil { # p 1 = p 2 . Next # p 2 . Next = cur # cur = p 2 # p 2 = p 1 # } # p 1 = head # p 2 = cur # for p 1 != nil { # tmp := p 1 . Next # p 1 . Next = p 2 # p 1 = p 2 # p 2 = tmp # }
if root == nil { # return nil # } # root . Left , root . Right = invertTree ( root . Right ), invertTree ( root . Left ) # return root
if head == nil || head . Next == nil { # return # } # # slow , fast := head , head # for fast . Next != nil && fast . Next . Next != nil { # fast = fast . Next . Next # slow = slow . Next # } # # head 1 , head 2 := head , slow . Next # slow . Next = nil # # var prev * ListNode # node := head 2 # for node != nil { # next := node . Next # node . Next = prev # prev = node # node = next # } # # head 2 = prev # dummy := & ListNode {} # node = dummy # i := 0 # for head 1 != nil || head 2 != nil { # if i % 2 == 0 { # node . Next = head 1 # node , head 1 = node . Next , head 1 . Next # } else { # node . Next = head 2 # node , head 2 = node . Next , head 2 . Next # } # # i ++ # }
fmt . Println ( combinationSum 3 ( 3 , 7 )) # fmt . Println ( combinationSum 3 ( 3 , 2 )) # fmt . Println ( combinationSum 3 ( 2 , 1 8 ))
qs := [] question 7 7 { # # { # para 7 7 { 4 , 2 }, # ans 7 7 {[][] int {{ 2 , 4 }, { 3 , 4 }, { 2 , 3 }, { 1 , 2 }, { 1 , 3 }, { 1 , 4 }}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 7 , q . para 7 7 # fmt . Printf (" STR ", p , combine ( p . n , p . k )) # } # fmt . Printf (" STR ")
for i := 0 ; i < 4 0 ; i ++ { # println ( countAndSay ( i )) # }
pattern := " STR " # str := " STR " # # fmt . Println ( wordPattern ( pattern , str ))
return MapSum {& node { next : make ( map [ rune ]* node )}}
l := p * q / gcd ( p , q ) # if ( l / q )% 2 == 0 { # return 2 # } # return ( l / p ) % 2
if x < 0 { # return false # } # str := strconv . Itoa ( x ) # len := len ( str ) # for i := 0 ; i < len ; i ++ { # if str [ i : i + 1 ] != str [ len - i - 1 : len - i ] { # return false # } # } # return true
qs := [] question 7 6 6 { # # { # para 7 6 6 {[][] int {{ 1 , 2 , 3 , 4 }, { 5 , 1 , 2 , 3 }, { 9 , 5 , 1 , 2 }}}, # ans 7 6 6 { true }, # }, # # { # para 7 6 6 {[][] int {{ 1 , 2 }, { 2 , 2 }}}, # ans 7 6 6 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 6 6 , q . para 7 6 6 # fmt . Printf (" STR ", p , isToeplitzMatrix ( p . A )) # } # fmt . Printf (" STR ")
var factor int 6 4 # for i := 0 ; i < len ( primes ); i ++ { # if primes [ i ] < n { # if n % primes [ i ] == 0 { # factor = n / primes [ i ] # return findLargestPrimeFactor ( factor ) # } # } # } # return n
if p == nil || q == nil { # return p == q # } # if p . Val != q . Val { # return false # } # # return isSameTree ( p . Left , q . Left ) && isSameTree ( p . Right , q . Right )
var tests = [] struct { # before [] interface {} # after * TreeNode # }{ # {[] interface {}{ 4 , 2 , 7 , 1 , 3 , 6 , 9 }, newTree ( 4 , 7 , 2 , 9 , 6 , 3 , 1 )}, # } # # for _ , tt := range tests { # after := invertTree ( newTree ( tt . before ...)) # if reflect . DeepEqual ( after , tt . after ) == false { # t . Errorf (" STR ", newTree ( tt . before ...), after , tt . after ) # } # }
h , h 2 := newLtHeapArray (), newLtHeapArray () # testHeapUnion ( t , h , h 2 )
if n == 0 { # return 1 # } # if n == 1 { # return x # } # if n < 0 { # n = - n # x = 1 / x # } # tmp := myPow ( x , n / 2 ) # if n % 2 == 0 { # return tmp * tmp # } # return tmp * tmp * x
return uint 3 2 ( v )
size := len ( a ) # if size == 0 { # return [] int {} # } # # sort . Ints ( a ) # # max := 1 # idx := 0 # # dp := make ([] int , size ) # for i := range dp { # dp [ i ] = 1 # } # # next := make ([] int , size ) # # for i := size - 2 ; 0 <= i ; i -- { # for j := size - 1 ; i < j ; j -- { # if a [ j ]% a [ i ] != 0 { # continue # } # if dp [ i ] < dp [ j ]+ 1 { # next [ i ] = j # dp [ i ] = dp [ j ] + 1 # } # if max < dp [ i ] { # max = dp [ i ] # idx = i # } # } # } # # res := make ([] int , max ) # for i := range res { # res [ i ] = a [ idx ] # idx = next [ idx ] # } # # return res
if len ( nums ) == 0 { # return 0 # } # visited := map [ int ] struct {}{} # existed := map [ int ] struct {}{} # for i := range nums { # existed [ nums [ i ]] = struct {}{} # } # max := 0 # for i := range nums { # count := 0 # left := nums [ i ] # for { # if _ , ok := visited [ left ]; ok { # break # } else if _ , ok := existed [ left ]; ok { # visited [ left ] = struct {}{} # count ++ # left -- # } else { # break # } # } # right := nums [ i ] + 1 # for { # if _ , ok := visited [ right ]; ok { # break # } else if _ , ok := existed [ right ]; ok { # visited [ right ] = struct {}{} # count ++ # right ++ # } else { # break # } # } # if count > max { # max = count # } # } # return max
i , sum := 0 , 0 # for i < 1 0 0 0 { # if i % 3 == 0 || i % 5 == 0 { # sum += i # } # i ++ # } # println ( sum )
if len ( nums ) < 2 { # return # } # swapIndex := - 1 # for i := len ( nums ) - 1 ; i > 0 ; i -- { # if nums [ i - 1 ] < nums [ i ] { # swapIndex = i - 1 # break # } # } # if swapIndex == - 1 { # reverseNums ( nums ) # return # } # for i := len ( nums ) - 1 ; i > swapIndex ; i -- { # if nums [ i ] > nums [ swapIndex ] { # nums [ i ], nums [ swapIndex ] = nums [ swapIndex ], nums [ i ] # reverseNums ( nums [ swapIndex + 1 :]) # break # } # } # return
t . Run (" STR ", func ( t * testing . T ) { # err := UrlPath (" https : ) # if err != nil { # t . Fatal ( err . Error ()) # } # })
dp := [ 5 0 ][ 5 0 ] int {} # # for k := 0 ; k < N ; k ++ { # prior := make ([] int , n ) # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # paths := 0 # # if i == 0 { # paths ++ # } else { # paths += prior [ j ] # } # # if j == 0 { # paths ++ # } else { # paths += prior [ j - 1 ] # } # # if i == m - 1 { # paths ++ # } else { # paths += dp [ i + 1 ][ j ] # } # # if j == n - 1 { # paths ++ # } else { # paths += dp [ i ][ j + 1 ] # } # # paths %= mod # prior [ j ] = dp [ i ][ j ] # dp [ i ][ j ] = paths # } # } # } # # return dp [ i ][ j ]
events := make ([] lectureEvent , 0 , 2 * len ( lectures )) # for i := range lectures { # events = append ( events , lectureEvent { lectures [ i ]. start , true }) # events = append ( events , lectureEvent { lectures [ i ]. end , false }) # } # sort . Slice ( events , func ( i , j int ) bool { # return events [ i ]. time < events [ j ]. time # }) # var max , active int # for i := range events { # if events [ i ]. starting { # active ++ # } else { # active -- # } # if max < active { # max = active # } # } # return max
return q . list . Append (& SingleNode { Data : data })
tp . Drain () # if tp . drainTicker != nil { # tp . drainTicker . Stop () # tp . drainTicker = nil # }
t . Parallel () # for _ , tc := range testcases { # if result := LengthLongestCommonSubseqOf 3 Recursive ( tc . one , tc . two , tc . three ); tc . longest != result { # t . Errorf (" STR ", tc . longest , result ) # } # }
fmt . Println ( missingNumber ([] int { 3 , 0 , 1 })) # fmt . Println ( bestMissingNumber ([] int { 3 , 0 , 1 })) # fmt . Println ( bestMissingNumber ([] int { 0 }))
cases := [] Case {} # N := 1 0 # for i := 0 ; i < N ; i ++ { # name := " STR " # input := UnmarshalListByRand ( 1 0 0 , 1 0 0 0 0 0 0 ) # exect := Solution ( input ) # cases = append ( cases , Case { Name : name , Input : input , Expect : exect }) # } # for _ , c := range cases { # b . Run ( c . Name , func ( b * testing . B ) { # got := reverseList 1 ( c . Input ) # if isEqual ( got , c . Expect ) { # b . Fatalf (" STR ", # c . Expect , got , c . Input ) # } # }) # }
arr := randomSlice ( 0 , 2 0 , 1 0 ) # gbt := newGBT () # for _ , v := range arr { # gbt . Insert ( uint 3 2 ( v )) # } # sort . Ints ( arr ) # key := getRand (). Intn ( len ( arr )- 2 ) + 1 # result := int ( gbt . Successor ( gbt . Search ( uint 3 2 ( arr [ key ])), gbt . Root ()).(* gbtElement ). Key ) # if result != arr [ key + 1 ] { # t . Log ( fmt . Sprintf (" STR ", arr [ key ], arr [ key + 1 ], result )) # t . Fail () # }
cases := [] struct { # name string # inputs int # expect bool # }{ # {" STR ", 6 , true }, # {" STR ", 8 , true }, # {" STR ", 1 4 , false }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := isUgly ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
dp := make ([] int , n + 1 ) # dp [ 0 ], dp [ 1 ] = 1 , 1 # for i := 2 ; i <= n ; i ++ { # for j := 1 ; j <= i ; j ++ { # dp [ i ] += dp [ j - 1 ] * dp [ i - j ] # } # } # return dp [ n ]
m := len ( nums ) # if m == 0 { # return nil # } # n := len ( nums [ 0 ]) # if n == 0 { # return nil # } # if m * n != r * c || ( m == r && n == c ) { # return nums # } # # res := make ([][] int , r ) # for i := 0 ; i < r ; i ++ { # res [ i ] = make ([] int , c ) # # for j := 0 ; j < c ; j ++ { # x := ( i * c + j ) / n # y := ( i * c + j ) - x * n # res [ i ][ j ] = nums [ x ][ y ] # } # } # return res
return & XorList { val : val , both : 0 }
println ( minDistance (" STR ", " STR "))
qs := [] question 4 3 8 { # # { # para 4 3 8 {" STR ", " STR "}, # ans 4 3 8 {[] int { 0 , 1 , 2 }}, # }, # # { # para 4 3 8 {" STR ", " STR "}, # ans 4 3 8 {[] int { 0 , 6 }}, # }, # # { # para 4 3 8 {" STR ", " STR "}, # ans 4 3 8 {[] int {}}, # }, # # { # para 4 3 8 {" STR ", " STR "}, # ans 4 3 8 {[] int { 1 , 2 , 3 , 5 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 3 8 , q . para 4 3 8 # fmt . Printf (" STR ", p , findAnagrams ( p . s , p . p )) # } # fmt . Printf (" STR ")
if x < 0 { # return false # } # if x != 0 && x % 1 0 == 0 { # return false # } # y := 0 # c := x # for x != 0 { # y = y * 1 0 + x % 1 0 # x /= 1 0 # } # return c == y
a , b := headA , headB # la , lb := 0 , 0 # for a != nil { # a = a . Next # la ++ # } # for b != nil { # b = b . Next # lb ++ # } # a , b = headA , headB # for la < lb { # b = b . Next # lb -- # } # for lb < la { # a = a . Next # la -- # } # for a != b { # a = a . Next # b = b . Next # } # return a
http . HandleFunc (" STR ", iconHandler ) # http . Handle (" STR ", Adapt ( http . HandlerFunc ( index ), middlewareSecond (), middlewareFirst ())) # http . Handle (" STR ", Adapt ( http . HandlerFunc ( message ), middlewareSecond (), middlewareFirst ())) # server := & http . Server { # Addr : " STR ", # } # log . Println (" STR ") # server . ListenAndServe ()
var dec decoder # return dec . decode ( r )
batch := make ([] Value , 0 ) # for i := 1 ; i < 1 0 ; i ++ { # batch = append ( batch , Value { i , 1 . 5 , " STR "}) # } # # for _ , v := range batch { # fmt . Println ( v ) # }
if n <= 1 { # return n # } # array := make ([] int , n + 1 ) # array [ 0 ], array [ 1 ] = 1 , 1 # for i := 2 ; i <= n ; i ++ { # for j := 0 ; j < i ; j ++ { # array [ i ] += array [ j ] * array [ i - j - 1 ] # } # } # return array [ n ]
return helper 9 9 6 ( A , 0 , 0 )
if nil == data || k > len ( data ) { # return nil # } # leastNumbers := make ([] int , k ) # for i := 0 ; i < k ; i ++ { # leastNumbers [ i ] = data [ i ] # } # sort . Ints ( leastNumbers ) # # for i := k ; i < len ( data ); i ++ { # if data [ i ] < leastNumbers [ k - 1 ] { # leastNumbers [ k - 1 ] = data [ i ] # sort . Ints ( leastNumbers ) # } # } # return leastNumbers
num := make ([] int , 1 0 0 0 1 ) # selectbefore , skipbefore := 0 , 0 # maxv , minv := 0 , 1 0 0 0 1 # for _ , v := range nums { # num [ v ] += v # if v > maxv { # maxv = v # } # if v < minv { # minv = v # } # } # for i := minv ; i <= maxv ; i ++ { # selectbefore , skipbefore = skipbefore + num [ i ], func () int { # if selectbefore > skipbefore { # return selectbefore # } # return skipbefore # }() # } # if selectbefore > skipbefore { # return selectbefore # } # return skipbefore
var longest , substringStart int # stk := make ([] int , len ( s )) # top := - 1 # for i := 0 ; i < len ( s ); i ++ { # if s [ i ] == '(' { # top ++ # stk [ top ] = i # } else { # if top == - 1 { # substringStart = i + 1 # } else { # top -- # var length int # if top == - 1 { # length = i - substringStart + 1 # } else { # length = i - stk [ top ] # } # if length > longest { # longest = length # } # } # } # } # return longest
sums := make ([] int , K ) # sums [ 0 ] = 1 # sum := 0 # count := 0 # for _ , num := range A { # sum += num # index := sum % K # if index < 0 { # index += K # } # # count += sums [ index ] # sums [ index ]++ # } # # return count
if 1 == n { # return 1 # } # # f := make ([] int , n + 1 ) # f [ 1 ], f [ 2 ] = 1 , 2 # # for i := 3 ; i < len ( f ); i ++ { # f [ i ] = f [ i - 1 ] + f [ i - 2 ] # } # return f [ n ]
for id , task := range r . tasks { # if r . gotInterrupt () { # return ErrInterrupt # } # # task ( id ) # } # # return nil
tests := [...] testType { # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : false , # }, # } # for _ , tt := range tests { # got := detectCapitalUse ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
data := [] int { 7 , 5 , 6 , 4 } # fmt . Println ( inversePairs ( data ))
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", [][] int { # { 2 , 4 , 1 }, # { 2 }, # }, 2 }, # {" STR ", [][] int { # { 3 , 2 , 6 , 5 , 0 , 3 }, # { 7 }, # }, 7 }, # } # # for i , c := range cases { # t . Run ( c . name + strconv . Itoa ( i ), func ( t * testing . T ) { # got := maxProfit ( c . inputs [ 0 ][ 0 ], c . inputs [ 0 ]) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
return len (* s ) == 0
if start == len ( arr ) { # * choice = append (* choice , strings . Join ( arr , " STR ")) # return # } # for i := start ; i < len ( arr ); i ++ { # if i != start { # tmp := arr [ start ] # arr [ start ] = arr [ i ] # arr [ i ] = tmp # } # calcCombination ( arr , start + 1 , choice ) # if i != start { # tmp := arr [ start ] # arr [ start ] = arr [ i ] # arr [ i ] = tmp # } # }
x , y , dx , dy := 0 , 0 , 0 , 1 # for _ , i := range instructions { # switch i { # case ' G ': # x , y = x + dx , y + dy # case ' L ': # dx , dy = - dy , dx # case ' R ': # dx , dy = dy , - dx # } # } # return x == 0 && y == 0 || dx != 0 || dy != 1
if ! StateExists ( fromState , at ) { # return - 1 # } # toState , ok := at [ fromState ][ overChar ] # if ! ok { # return - 1 # } # return toState
out = ( 3 0 0 - n ) * r # # for i := 3 0 0 - n + 1 ; i <= 3 0 0 - 2 ; i ++ { # out = ( out + float 6 4 ( i )) * r # # } # # return
res , cur , isInMap := [] int {}, [] int {}, make ( map [ int ] bool ) # cur = append ( cur , 0 ) # for _ , v := range A { # var cur 2 [] int # for _ , vv := range cur { # tmp := v | vv # if ! inSlice ( cur 2 , tmp ) { # cur 2 = append ( cur 2 , tmp ) # } # } # if ! inSlice ( cur 2 , v ) { # cur 2 = append ( cur 2 , v ) # } # cur = cur 2 # for _ , vv := range cur { # if _ , ok := isInMap [ vv ]; ! ok { # isInMap [ vv ] = true # res = append ( res , vv ) # } # } # } # return len ( res )
ret = 0 # helper ( root , 0 ) # return ret
m = len ( grid ) # if m <= 0 { # return 0 # } # n = len ( grid [ 0 ]) # # visited = make ([][] bool , m ) # for i := 0 ; i < m ; i ++ { # visited [ i ] = make ([] bool , n ) # } # # var res int # # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # if grid [ i ][ j ] == ' 1 ' && ! visited [ i ][ j ] { # res ++ # dfs ( grid , i , j ) # } # } # } # return res
if len ( nums ) == 0 { # return " STR " # } # numStrs := toStringArray ( nums ) # quickSortString ( numStrs , 0 , len ( numStrs )- 1 ) # res := " STR " # for _ , str := range numStrs { # if res == " STR " && str == " STR " { # continue # } # res = res + str # } # return res
m , n := len ( A ), len ( A [ 0 ]) # res := make ([][] int , n ) # for i := 0 ; i < n ; i ++ { # res [ i ] = make ([] int , m ) # } # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # res [ j ][ i ] = A [ i ][ j ] # } # } # return res
bytes := [] byte ( s ) # # for i := 0 ; i < len ( s ); i += 2 * k { # j := min ( i + k , len ( s )) # reverse ( bytes [ i : j ]) # } # # return string ( bytes )
expression := & ast . BinaryExpr { # X : left , # Op : t . curToken , # OpPos : t . curPos , # } # precedence := precedences [ t . curToken ] # t . Next () # right , err := parseConstExpr ( t , precedence ) # expression . Y = right # return expression , err
if elem , found := lc . data [ key ]; found { # lc . l . MoveToFront ( elem ) # elem . Value = kvPair { k : key , v : value } # return # } # if len ( lc . data ) == lc . capacity { # oldest := lc . l . Back () # delete ( lc . data , oldest . Value .( kvPair ). k ) # lc . l . Remove ( oldest ) # } # e := lc . l . PushFront ( kvPair { k : key , v : value }) # lc . data [ key ] = e
if len ( nums ) <= 0 { # return - 1 # } # var sum , leftSum int # for _ , num := range nums { # sum += num # } # for index , num := range nums { # if leftSum * 2 + num == sum { # return index # } # leftSum += num # } # return - 1
n := uint 6 4 ( 0 ) # for i := uint 6 4 ( 1 ); ; i ++ { # n += i # count := numFactors ( n ) # if count >= factors { # fmt . Println (" STR ", n ) # break # } # }
n := len ( nums ) # res , i , j , sum := n + 1 , 0 , 0 , 0 # for j < n { # sum += nums [ j ] # j ++ # # for sum >= s { # sum -= nums [ i ] # i ++ # if res > j - i + 1 { # res = j - i + 1 # } # } # } # return res % ( n + 1 )
t . Parallel () # for _ , tc := range testcases { # if profit := MaxProfitBrute ( tc . prices ); tc . maxProfit != profit { # t . Errorf (" STR ", tc . maxProfit , profit ) # } # }
cubeDigits := [][ 1 0 ] int {} # i := 1 . 0 # for { # cube := int ( math . Pow ( i , 3 . 0 )) # var digits [ 1 0 ] int # for cube >= 1 { # digits [ cube % 1 0 ]++ # cube /= 1 0 # } # # if iterationsOf ( cubeDigits , digits ) == 4 { # fmt . Println ( int 6 4 ( math . Pow ( float 6 4 ( firstIteration ( cubeDigits , digits )+ 1 ), 3 . 0 ))) # break # } # cubeDigits = append ( cubeDigits , digits ) # i ++ # }
cases := [] struct { # name string # inputs [] string # expect string # }{ # {" STR ", [] string {" STR ", " STR "}, " STR "}, # {" STR ", [] string {" STR ", " STR "}, " STR "}, # {" STR ", [] string {" STR ", " STR "}, " STR "}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # }) # }
if len ( inputStr ) < nRows || nRows <= 0 { # return " STR " # } # # inputArr = strings . Split ( inputStr , " STR ") # tmpArr := make ([] string , nRows ) # # for i := 0 ; i < len ( inputArr ); i ++ { # # if x == nRows - 1 { # step = - 1 # # } # # if x == 0 { # step = 1 # } # # fmt . Println (" STR ", x ) # # tmpArr [ x ] = tmpArr [ x ] + inputArr [ i ] # x += step # # fmt . Println ( tmpArr ) # # } # # return " STR "
streakX , streakY := true , true # # var changeXtoY , changeYtoX int # # for forward , backward := 0 , len ( input )- 1 ; forward < len ( input ); forward , backward = forward + 1 , backward - 1 { # if streakX && input [ forward ] != ' x ' { # streakX = false # } # # if streakY && input [ backward ] != ' y ' { # streakY = false # } # # if ! streakX && input [ forward ] == ' x ' { # changeXtoY ++ # } # # if ! streakY && input [ backward ] == ' y ' { # changeYtoX ++ # } # } # # if changeXtoY < changeYtoX { # return changeXtoY # } # # return changeYtoX
if n < 1 { # panic (" STR ") # } # # seen := make ( map [ int ] struct {}) # q := [] int { n } # # var steps int # # for len ( q ) != 0 { # nextQ := make ([] int , 0 , 2 * len ( q )) # # for _ , v := range q { # if v == 1 { # nextQ = nil # break # } else if _ , found := seen [ v ]; ! found { # seen [ v ] = struct {}{} # nextQ = append ( nextQ , v - 1 ) # a := v # for b := int ( math . Sqrt ( float 6 4 ( v ))); b > 0 ; b -- { # if v % b == 0 { # a = v / b # break # } # } # nextQ = append ( nextQ , a ) # } # } # # q = nextQ # steps ++ # } # # return steps - 1
n := make ([] int , 0 ) # for c . Empty () != true { # n = append ( n , c . Get ().( int )) # } # return n
var minPriceI , max int # # for i , price := range prices { # profit := price - prices [ minPriceI ] # if profit > max { # max = profit # } else if profit < 0 { # minPriceI = i # } # } # return max
n := node .(* bstElement ) # if n != nil { # stop := t . PostOrderWalk ( n . left , callback ) # if stop { # return true # } # stop = t . PostOrderWalk ( n . right , callback ) # if stop { # return true # } # stop = callback ( t , n ) # return stop # } # return false
if len ( path ) < 2 { # return 0 # } # # steps := 0 # current := path [ 0 ] # # for i := 1 ; i < len ( path ); i ++ { # next := path [ i ] # if dx , dy := delta ( current , next ); dx < dy { # steps += dy # } else { # steps += dx # } # # current = next # } # # return steps
u , err := url . Parse ( urlStr ) # if err != nil { # return nil # } # return urlNetAddr { u }
if i == aLength { # if dist > maxDist { # maxDist = dist # maxSeq = seq # } # return # } # # if j == - 1 || a [ i ] > a [ j ] { # nSeq := append ( seq , a [ i ]) # calcLongSeqBackTrace ( a , i + 1 , i , aLength , dist + 1 , nSeq ) # } # calcLongSeqBackTrace ( a , i + 1 , j , aLength , dist , seq )
var res [] int # dfs ( root , & res ) # return res
t . Parallel () # # for _ , tc := range testcases { # var stack StackHeap # # for i := range tc . items { # stack . Push ( tc . items [ i ]) # } # # for i := range tc . items { # if result := stack . Pop (); result != tc . items [ len ( tc . items )- 1 - i ] { # t . Errorf (" STR ", tc . items [ len ( tc . items )- 1 - i ], result ) # } # } # }
eqs := strings . Split ( strings . TrimSpace ( equations ), " STR ") # eqDatas := make ([] eqData , 0 , len ( eqs )) # # for _ , eq := range eqs { # sides := strings . Split ( strings . TrimSpace ( eq ), " STR ") # if len ( sides ) != 2 { # panic (" STR ") # } # # lhs , rhs := strings . TrimSpace ( sides [ 0 ]), strings . TrimSpace ( sides [ 1 ]) # vars := make ( map [ string ] int ) # total := 0 # # for _ , v := range strings . Split ( lhs , " STR ") { # if i , err := strconv . Atoi ( v ); err == nil { # total -= i # } else { # vars [ v ]++ # } # } # # for _ , v := range strings . Split ( rhs , " STR ") { # v = strings . TrimSpace ( v ) # if i , err := strconv . Atoi ( v ); err == nil { # total += i # } else { # vars [ v ]-- # } # } # # eqDatas = append ( eqDatas , eqData { vars , total }) # } # # return solveArithmeticEquations ( eqDatas )
rows , cols := make ([] int , 0 ), make ([] int , 0 ) # for i := range grid { # for j , val := range grid [ i ] { # if val == 1 { # rows = append ( rows , i ) # cols = append ( cols , j ) # } # } # } # # return minDist 1 D ( rows ) + minDist 1 D ( cols )
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 2 , 3 , 1 , 1 , 4 }, 2 }, # {" STR ", [] int { 2 }, 0 }, # {" STR ", [] int { 1 0 , 3 , 4 }, 1 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := jump ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
t . Parallel () # for _ , tc := range testcases { # words := BoggleSolver ( tc . board , tc . dict ) # m := make ( map [ string ] struct {}, len ( tc . valid )) # for _ , w := range tc . valid { # m [ w ] = struct {}{} # } # for _ , w := range words { # if _ , found := m [ w ]; ! found { # t . Errorf (" STR ", w ) # } else { # delete ( m , w ) # } # } # if len ( m ) != 0 { # t . Errorf (" STR ", m ) # } # }
ans := 0 . 0 # for _ , i := range points { # for _ , j := range points { # for _ , k := range points { # ans = math . Max ( ans , 0 . 5 * math . Abs ( float 6 4 ( i [ 0 ]* j [ 1 ]+ j [ 0 ]* k [ 1 ]+ k [ 0 ]* i [ 1 ]- i [ 0 ]* k [ 1 ]- j [ 0 ]* i [ 1 ]- k [ 0 ]* j [ 1 ]))) # } # } # } # return ans
for len ( a 1 ) > 0 && len ( a 2 ) > 0 { # x := a 1 [ 0 ] # y := a 2 [ 0 ] # if x >= y { # arr = append ( arr , y ) # a 2 = a 2 [ 1 :] # } else { # arr = append ( arr , x ) # a 1 = a 1 [ 1 :] # } # } # if len ( a 1 ) > 0 { # arr = append ( arr , a 1 ...) # } # if len ( a 2 ) > 0 { # arr = append ( arr , a 2 ...) # } # return
n := NewNode ( val ) # # if ll . Head == nil { # ll . Head = n # ll . length ++ # return # } # # cur := ll . Head # for ; cur . Next != nil ; cur = cur . Next { # } # cur . Next = n # ll . length ++
if len ( inorder ) == 0 { # return nil # } # # res := & TreeNode { Val : preorder [ 0 ]} # if len ( inorder ) == 1 { # return res # } # # index := 0 # for i , v := range inorder { # if v == res . Val { # index = i # break # } # } # # res . Left = buildTree ( preorder [ 1 : index + 1 ], inorder [: index ]) # res . Right = buildTree ( preorder [ index + 1 :], inorder [ index + 1 :]) # return res
numsMap := make ( map [ int ] int ) # for k , v := range nums { # if _ , ok := numsMap [ target - v ]; ok { # return [] int { numsMap [ target - v ], k } # } # numsMap [ v ] = k # } # return [] int {}
t . Parallel () # for i , tc := range testcases { # if result := MergeKSortedLists ( tc . input ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", i , result ) # } # }
for i := range pc { # pc [ i ] = pc [ i / 2 ] + byte ( i & 1 ) # }
var ( # dummyHead 1 = & ListNode {} # dummyHead 2 = & ListNode {} # cur 1 = dummyHead 1 # cur 2 = dummyHead 2 # ) # # for cur := head ; cur != nil ; { # if cur . Val < x { # cur 1 . Next = cur # cur 1 = cur 1 . Next # cur = cur . Next # cur 1 . Next = nil # } else { # cur 2 . Next = cur # cur 2 = cur 2 . Next # cur = cur . Next # cur 2 . Next = nil # } # } # cur 1 . Next = dummyHead 2 . Next # return dummyHead 1 . Next
fmt . Fprintf ( w , " STR ", r . Method , r . URL , r . Proto ) # for k , v := range r . Header { # fmt . Fprintf ( w , " STR ", k , v ) # } # fmt . Fprintf ( w , " STR ", r . Host ) # fmt . Fprintf ( w , " STR ", r . RemoteAddr ) # if err := r . ParseForm (); err != nil { # log . Print ( err ) # } # for k , v := range r . Form { # fmt . Fprintf ( w , " STR ", k , v ) # }
swapped := true # for swapped { # swapped = false # for i := 0 ; i < len ( arr )- 1 ; i ++ { # if arr [ i + 1 ] < arr [ i ] { # arr [ i + 1 ], arr [ i ] = arr [ i ], arr [ i + 1 ] # swapped = true # } # } # } # return arr
if len ( A ) < 3 { # return false # } # total := 0 # for _ , v := range A { # total += v # } # if total % 3 != 0 { # return false # } # sum := 0 # for _ , v := range A { # sum += v # if sum == total / 3 { # sum = 0 # } # } # return sum == 0
cases := [] struct { # name string # inputs [] int # fee int # expect int # }{ # {" STR ", [] int { 1 , 3 , 2 , 8 , 4 , 9 }, 2 , 8 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := maxProfit ( c . inputs , c . fee ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
m := make ( map [ int ] int , len ( nums )) # for i , v := range nums { # if vv , has := m [ v ]; has { # if i - vv <= k { # return true # } # } # m [ v ] = i # } # return false
self . top -- # value := self . slots [ self . top ] # self . slots [ self . top ]. Num = 0 # self . slots [ self . top ]. Ref = nil # return value
m := make ( map [ int ] int , len ( nums )) # # for i , n := range nums { # if j , ok := m [ target - n ]; ok { # return [] int { j , i } # } # m [ n ] = i # } # return nil
if N <= 2 { # return 2 # } else if N == 3 { # return 3 # } else if N <= 5 { # return 5 # } else if N <= 7 { # return 7 # } else if N <= 1 1 { # return 1 1 # } # # for lm := genLM ( N ); lm <= 1 0 0 0 0 0 0 0 0 ; lm ++ { # p := genPalindrome ( lm ) # if p >= N && isPrime ( p ) { # return p # } # } # return - 1
count := make ( chan int ) # wg . Add ( 2 ) # # fmt . Println (" STR ") # go printCounts (" STR ", count ) # go printCounts (" STR ", count ) # fmt . Println (" STR ") # count <- 1 # fmt . Println (" STR ") # wg . Wait () # fmt . Println (" STR ")
var s seqStack # s . top = - 1 # result := [] int {} # # if root == nil { # return result # } # for root != nil || s . top != - 1 { # for root != nil { # result = append ( result , root . Val ) # s . top ++ # s . data = append ( s . data , root ) # root = root . Left # } # root = s . data [ len ( s . data )- 1 ] # s . data = s . data [: len ( s . data )- 1 ] # root = root . Right # s . top -- # } # return result
if end < start || ( end - start ) < count { # return nil # } # nums := make ([] int , 0 ) # for len ( nums ) < count { # num := GetRand (). Intn (( end - start )) + start # exist := false # for _ , v := range nums { # if v == num { # exist = true # break # } # } # if ! exist { # nums = append ( nums , num ) # } # } # return nums
var ( # fi , div , sqrt float 6 4 # sum , idiv , isqrt int # d [ N + 1 ] int # checked [ N + 1 ] bool # ) # for i := 1 ; i <= N ; i ++ { # fi = float 6 4 ( i ) # sqrt = math . Sqrt ( fi ) # isqrt = int ( sqrt ) # if sqrt == float 6 4 ( isqrt ) { d [ i ] = isqrt } # for n := 1 ; n < isqrt ; n ++ { # div = fi / float 6 4 ( n ) # idiv = int ( div ) # if div == float 6 4 ( idiv ) { # if div < fi { d [ i ] += idiv } # d [ i ] += n # } # } # } # for i := 1 ; i <= N ; i ++ { # if ! checked [ i ] && d [ i ] <= N && i != d [ i ] && i == d [ d [ i ]] { # checked [ d [ i ]] = true # sum += i + d [ i ] # } # checked [ i ] = true # } # println ( sum )
counts := make ( map [ string ] int ) # files := os . Args [ 1 :] # if len ( files ) == 0 { # countLines ( os . Stdin , counts ) # } else { # for _ , arg := range files { # f , err := os . Open ( arg ) # if err != nil { # fmt . Fprintf ( os . Stderr , " STR ", err ) # continue # } # countLines ( f , counts ) # f . Close () # } # } # for line , n := range counts { # if n > 1 { # fmt . Printf (" STR ", n , line ) # } # }
b := make ([] byte , fSize ) # copy ( b , testData ) # return New ( bytes . NewReader ( b ))
res := 0 # for n > 1 { # if ( n & 1 ) == 0 { # n >>= 1 # } else if ( n + 1 )% 4 == 0 && n != 3 { # n ++ # } else { # n -- # } # res ++ # } # return res
ans = [][] int {} # visit = make ([] bool , len ( nums )) # dfs ( nums , [] int {}) # return ans
result := make ([][] int , 0 ) # return helper 7 8 ( nums , 0 , make ([] int , 0 ), result )
sID , sData := m . memory . encIdx ( id ), m . memory . encData ( data ) # item := m . update ( sID ) # item . Value .(* cacheItem ). value = sData # item . Value .(* cacheItem ). dirty = true
ans := make ([] int , 0 ) # # for i := 0 ; i < len ( nums ); i ++ { # id := abs ( nums [ i ]) - 1 # if nums [ id ] > 0 { # nums [ id ] = - nums [ id ] # } # } # # for i := 0 ; i < len ( nums ); i ++ { # if nums [ i ] > 0 { # ans = append ( ans , i + 1 ) # } # } # return ans
s . mtx . Lock () # defer s . mtx . Unlock () # p , ok := s . m [ profileID ] # if ! ok { # return ErrNotFound # } # newAddresses := make ([] Address , 0 , len ( p . Addresses )) # for _ , address := range p . Addresses { # if address . ID == addressID { # continue # } # newAddresses = append ( newAddresses , address ) # } # if len ( newAddresses ) == len ( p . Addresses ) { # return ErrNotFound # } # p . Addresses = newAddresses # s . m [ profileID ] = p # return nil
c . mu . Lock () # if c . err == nil { # c . err = err # c . conn . Close () # } # c . mu . Unlock () # return c . err
switch s { # case Undefined : # return " STR " # case Unknown : # return " STR " # case Bounded : # return " STR " # case Recursive : # return " STR " # case IndirectCall : # return " STR " # default : # return " STR " # }
var tests = [] struct { # nums [] int # target int # index int # }{ # {[] int {- 1 , 0 , 3 , 5 , 9 , 1 2 }, 9 , 4 }, # {[] int {- 1 , 0 , 3 , 5 , 9 , 1 2 }, 2 , - 1 }, # { nil , 0 , - 1 }, # } # # for _ , tt := range tests { # index := search ( tt . nums , tt . target ) # if index != tt . index { # t . Errorf (" STR ", tt . nums , tt . target , index , tt . index ) # } # }
if len ( nums ) < 2 { # return 0 # } # # var quickSort func ( i , j int ) # quickSort = func ( i , j int ) { # ci , cj := i , j # c := i # for i < j { # for nums [ j ] >= nums [ c ] && i < j { # j -- # } # for nums [ i ] <= nums [ c ] && i < j { # i ++ # } # nums [ i ], nums [ j ] = nums [ j ], nums [ i ] # } # nums [ i ], nums [ c ] = nums [ c ], nums [ i ] # c = i # if ci < c { # quickSort ( ci , c ) # } # if c + 1 < cj { # quickSort ( c + 1 , cj ) # } # } # # quickSort ( 0 , len ( nums )- 1 ) # # ret := 0 # for i := 1 ; i < len ( nums ); i ++ { # tmp := nums [ i ] - nums [ i - 1 ] # if ret < tmp { # ret = tmp # } # } # # return ret
cases := [] struct { # name string # inputs bool # expect bool # }{ # {" STR ", true , true }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := Solution ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
return ! isNaN ( f ) && ! isFinite ( f )
n := len ( s ) # max , start := 0 , 0 # for i := 0 ; i < n ; { # l , r := i , i # for r < ( n - 1 ) && s [ r ] == s [ r + 1 ] { # r ++ # } # i = r + 1 # for l > 0 && r < n - 1 && s [ l - 1 ] == s [ r + 1 ] { # l -- # r ++ # } # tmp := r - l + 1 # if tmp > max { # max = tmp # start = l # } # } # return s [ start : start + max ]
a := [] float 6 4 { 1 , 1 , 1 , 1 } # A := MakeMatrix ( a , 2 , 2 ) # B := MakeMatrix ([] float 6 4 { 2 , 2 , 2 , 2 }, 2 , 2 ) # # A . scale ( 2 ) # # if ! FloatArrayEquals ( A . Elements , B . Elements ) { # t . Error () # }
fields := s . structFields () # # for _ , field := range fields { # val := s . value . FieldByName ( field . Name ) # # _ , tagOpts := parseTag ( field . Tag . Get ( s . TagName )) # # if IsStruct ( val . Interface ()) && ! tagOpts . Has (" STR ") { # ok := IsZero ( val . Interface ()) # if ! ok { # return false # } # # continue # } # # zero := reflect . Zero ( val . Type ()). Interface () # # current := val . Interface () # # if ! reflect . DeepEqual ( current , zero ) { # return false # } # } # # return true
sum := 2 # var ( # first_number = 1 # second_number = 2 # ) # for second_number < 4 0 0 0 0 0 0 { # first_number , second_number = second_number , first_number + second_number # if second_number % 2 == 0 { # sum += second_number # } # } # fmt . Println ( sum )
flag . Usage = Usage # flag . Parse () # if flag . NArg () < 1 { # flag . Usage () # return # } # args := flag . Args () # cmdName := flag . Arg ( 0 ) # for _ , cmd := range Commands { # if cmd . Name () == cmdName { # cmd . Run ( cmd , args [ 1 :]) # return # } # } # fmt . Printf (" STR ", CmdName , cmdName ) # fmt . Printf (" STR ", CmdName )
blackCnt := 0 # if tree . IsNil ( n . Right ) && tree . IsNil ( n . Left ) { # for curNode := n ; ! tree . IsNil ( curNode ); curNode = curNode . Parent { # if tree . color ( curNode ) { # blackCnt ++ # } # } # if len (* blackCntQ ) != 0 { # if blackCnt != (* blackCntQ )[ 0 ] { # t . Log ( fmt . Sprintf (" STR ", blackCnt , n , (* blackCntQ )[ 0 ])) # t . FailNow () # } # } else { # if blackCnt == 0 { # t . Log ( fmt . Sprintf (" STR ", n )) # t . FailNow () # } # * blackCntQ = append (* blackCntQ , blackCnt ) # } # }
res := make ([] int , 0 , n ) # dfs 3 8 6 ( 1 , n , & res ) # return res
bs := [] byte ( S ) # stack := make ([] byte , len ( S )) # top := - 1 # # for _ , b := range bs { # top ++ # stack [ top ] = b # switch top { # case 0 : # if b != ' a ' { # return false # } # case 1 : # default : # if b == ' c ' && # stack [ top - 1 ] == ' b ' && # stack [ top - 2 ] == ' a ' { # top -= 3 # } # } # } # # return top == - 1
ldc . ops = append ([]* lDOperation { op }, ldc . ops ...)
countDashs := strings . Count ( s , " STR ") # countAN := len ( s ) - countDashs # # if countAN == 0 { # return " STR " # } # # s = strings . Replace ( s , " STR ", " STR ", - 1 ) # s = strings . ToUpper ( s ) # # res := make ([] byte , ( countAN + k - 1 )/ k - 1 + countAN ) # # i , j := len ( res ), len ( s ) # for 0 <= j - k { # copy ( res [ i - k : i ], s [ j - k : j ]) # # if 0 <= i - k - 1 { # res [ i - k - 1 ] = '-' # } # # i -= k + 1 # j -= k # } # # if j > 0 { # copy ( res [: j ], s [: j ]) # } # # return string ( res )
r := math . Hypot ( x , y ) # return math . Sin ( r ) / r
n := len ( nums ) # if n == 0 { # return 0 # } # if n == 1 { # return nums [ 0 ] # } # dp := make ([] int , n ) # dp [ 0 ], dp [ 1 ] = nums [ 0 ], max ( nums [ 0 ], nums [ 1 ]) # for i := 2 ; i < n ; i ++ { # dp [ i ] = max ( nums [ i ]+ dp [ i - 2 ], dp [ i - 1 ]) # } # return dp [ n - 1 ]
return nil , nil
for _ , c := range p { # if c == " STR " { # w . line = append ( w . line , [] byte ( TermColorReset )...) # w . line = append ( w . line , " STR ") # _ , err := w . Out . Write ( w . line ) # w . line = w . line [: 0 ] # w . line = append ( w . line , [] byte ( w . Color + w . Prefix )...) # if err != nil { # return 0 , err # } # } else { # w . line = append ( w . line , c ) # } # } # return len ( p ), nil
dict 1 := make ( map [ string ] int , len ( list 1 )) # dict 2 := make ( map [ string ] int , len ( list 2 )) # # for id , v := range list 1 { # dict 1 [ v ] = id + 1 # } # for id , v := range list 2 { # dict 2 [ v ] = id + 1 # } # # ans := make ([] string , 0 ) # min := 2 0 0 1 # for k , v := range dict 1 { # if v 2 , ok := dict 2 [ k ]; ok && v + v 2 <= min { # if v + v 2 < min { # min = v + v 2 # ans = ans [: 0 ] # } # ans = append ( ans , k ) # } # } # # return ans
fmt . Println ( maximumProduct ([] int { 1 , 0 , 1 0 0 })) # fmt . Println ( maximumProduct ([] int {- 4 , - 3 , - 2 , - 1 , 6 0 }))
stack := make ([] rune , len ( s )) # top := 0 # # for _ , c := range s { # switch c { # case " STR ": # stack [ top ] = " STR " # top += 1 # break # case " STR ": # stack [ top ] = " STR " # top += 1 # break # case " STR ": # stack [ top ] = " STR " # top += 1 # break # default : # if top == 0 || stack [ top - 1 ] != c { # return false # } # top -= 1 # break # } # } # # return top == 0
p , q := m - 1 , n - 1 # tail := m + n - 1 # for p >= 0 && q >= 0 { # if nums 1 [ p ] > nums 2 [ q ] { # nums 1 [ tail ] = nums 1 [ p ] # p -- # } else { # nums 1 [ tail ] = nums 2 [ q ] # q -- # } # tail -- # } # if p == - 1 && q >= 0 { # for q >= 0 { # nums 1 [ tail ] = nums 2 [ q ] # q -- # tail -- # } # } # if q == - 1 && p >= 0 { # for p >= 0 { # nums 1 [ tail ] = nums 1 [ p ] # p -- # tail -- # } # }
if len ( b . priorityQueue ) == 0 { # return nil # } # # if now . IsZero () { # now = time . Now () # } # # if e := b . priorityQueue [ 0 ]; e . expire . Before ( now ) { # return e # } # return nil
return uint 8 ( v )
tests := [...] testType { # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := lastSubstring ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
qs := [] question 3 8 6 { # # { # para 3 8 6 { 1 3 }, # ans 3 8 6 {[] int { 1 , 1 0 , 1 1 , 1 2 , 1 3 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 8 6 , q . para 3 8 6 # fmt . Printf (" STR ", p , lexicalOrder ( p . n )) # } # fmt . Printf (" STR ")
if len ( timeSeries ) == 0 || duration == 0 { # return 0 # } # # res , start , end := 0 , timeSeries [ 0 ], timeSeries [ 0 ]+ duration # for _ , ts := range timeSeries { # if ts > end { # res += end - start # start = ts # } # end = ts + duration # } # res += end - start # return res
lo , hi := 0 , len ( nums )- 1 # for lo < hi { # mid := lo + ( hi - lo )/ 2 # switch { # case nums [ mid ] > nums [ hi ]: # lo = mid + 1 # case nums [ mid ] < nums [ hi ]: # hi = mid # default : # hi -- # } # } # return nums [ lo ]
var newPos int 6 4 # # switch whence { # case io . SeekStart : # newPos = offset # case io . SeekCurrent : # newPos = srs . pos + offset # case io . SeekEnd : # fallthrough # default : # return srs . pos , ErrSeekWhence # } # # if newPos < srs . rpos { # return srs . pos , ErrSeekOffset # } # # srs . pos = newPos # # return newPos , nil
type A struct { # Name string # } # a := A { Name : " STR "} # # type B struct { # A A # C int # } # b := & B { A : a , C : 1 2 3 } # # s := Values ( b ) # # inSlice := func ( val interface {}) bool { # for _ , v := range s { # if reflect . DeepEqual ( v , val ) { # return true # } # } # return false # } # # for _ , val := range [] interface {}{" STR ", 1 2 3 } { # if ! inSlice ( val ) { # t . Errorf (" STR ", val ) # } # }
l . next () # l . ignore ()
h . root = newFabHeapElementList ( nil ) # h . min = nil # h . n = 0 # h . mixin = mixin # return h
if atomic . LoadUint 3 2 (& o . done ) != 0 { # return nil # } # # o . L . Lock () # defer o . L . Unlock () # # for o . running { # if err := ctx . Err (); err != nil { # return err # } # o . Wait () # } # o . running = true # defer func () { # o . running = false # }() # # if err := ctx . Err (); err != nil { # return err # } # if atomic . LoadUint 3 2 (& o . done ) != 0 { # return nil # } # # if err := o . invoke ( f ); err != nil { # o . Signal () # return err # } # # atomic . StoreUint 3 2 (& o . done , 1 ) # o . Broadcast () # return nil
cases := [] struct { # name string # inputs [] int # expect bool # }{ # {" STR ", [] int { 1 , 2 , 3 , 4 , 4 , 3 , 2 , 1 }, true }, # {" STR ", [] int { 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 }, false }, # {" STR ", [] int { 1 }, false }, # {" STR ", [] int { 1 , 1 }, true }, # {" STR ", [] int { 1 , 1 , 2 , 2 , 2 , 2 }, true }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if len ( args ) == 0 { # return # } # # firstValue := * args [ 0 ] # for i := 0 ; i < len ( args )- 1 ; i ++ { # * args [ i ] = * args [ i + 1 ] # } # * args [ len ( args )- 1 ] = firstValue
return & priorityQueue { # heap : make ([] node , capacity + 1 ), # capacity : capacity , # used : 0 , # }
nums := [] int { 2 , 7 , 1 1 , 1 5 } # # funcs := [] func ([] int , int ) [] int { twoSum , twoSum 1 } # # for _ , testFunc := range funcs { # if res := testFunc ( nums , 9 ); ! reflect . DeepEqual ( res , [] int { 0 , 1 }) { # t . Error (" STR ") # } # # if res := testFunc ( nums , 6 ); ! reflect . DeepEqual ( res , [] int {}) { # t . Error (" STR ") # } # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 2 , 3 , 1 , 1 , 4 }, 2 }, # {" STR ", [] int { 2 }, 0 }, # {" STR ", [] int { 1 0 , 3 , 4 }, 1 }, # {" STR ", [] int { 4 , 1 , 1 , 3 , 1 , 1 , 1 }, 2 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := jump 2 ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
ret := [] int {} # for i := left ; i <= right ; i ++ { # flag := true # for tmp := i ; flag && tmp > 0 ; { # if tmp % 1 0 == 0 || i %( tmp % 1 0 ) > 0 { # flag = false # } # tmp /= 1 0 # } # if flag { # ret = append ( ret , i ) # } # } # return ret
qs := [] question 8 1 1 { # # { # para 8 1 1 {[] string {" STR "}}, # ans 8 1 1 {[] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # }, # # { # para 8 1 1 {[] string {" STR ", " STR ", " STR ", " STR "}}, # ans 8 1 1 {[] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 1 1 , q . para 8 1 1 # fmt . Printf (" STR ", p , subdomainVisits ( p . one )) # } # fmt . Printf (" STR ")
var maxlen int # lastError := - 1 # var stack [] int # for i := 0 ; i < len ( s ); i ++ { # if s [ i ] == '(' { # stack = append ( stack , i ) # } else if s [ i ] == ')' { # if len ( stack ) > 0 { # stack = stack [: len ( stack )- 1 ] # length := 0 # if len ( stack ) == 0 { # length = i - lastError # } else { # length = i - stack [ len ( stack )- 1 ] # } # if length > maxlen { # maxlen = length # } # } else { # lastError = i # } # } # } # return maxlen
return subSet . IsSubsetOf ( st )
sort . Ints ( nums ) # result := make ([][] int , 0 ) # for i := 0 ; i < len ( nums )- 3 ; { # for j := i + 1 ; j < len ( nums )- 2 ; { # k , m := j + 1 , len ( nums )- 1 # for k < m { # sum := nums [ i ] + nums [ j ] + nums [ k ] + nums [ m ] # if sum < target { # k ++ # } else if sum > target { # m -- # } else { # result = append ( result , [] int { nums [ i ], nums [ j ], nums [ k ], nums [ m ]}) # k = increaseIndex 1 8 ( nums , k ) # } # } # # j = increaseIndex 1 8 ( nums , j ) # } # # i = increaseIndex 1 8 ( nums , i ) # } # # return result
result := make ([] int , 0 , len ( hints )+ 1 ) # count := 0 # for _ , r := range hints { # if r == '+' { # count ++ # } # } # first := len ( hints ) - count # result = append ( result , first ) # small , large := first - 1 , first + 1 # for _ , r := range hints { # if r == '+' { # result = append ( result , large ) # large ++ # } else { # result = append ( result , small ) # small -- # } # } # return result
p , err := c . br . ReadSlice (" STR ") # if err == bufio . ErrBufferFull { # return nil , protocolError (" STR ") # } # if err != nil { # return nil , err # } # i := len ( p ) - 2 # if i < 0 || p [ i ] != " STR " { # return nil , protocolError (" STR ") # } # line := p [: i ] # if len ( line ) == 0 { # return nil , protocolError (" STR ") # } # return line , nil
res := 0 # stack := make ([] int , 0 , len ( s )) # sign := 1 # num := 0 # # for i := 0 ; i < len ( s ); i ++ { # switch s [ i ] { # case ' 1 ', ' 2 ', ' 3 ', ' 4 ', ' 5 ', ' 6 ', ' 7 ', ' 8 ', ' 9 ', ' 0 ': # num = 0 # for ; i < len ( s ) && s [ i ] >= ' 0 ' && s [ i ] <= ' 9 '; i ++ { # num = 1 0 * num + int ( s [ i ]-' 0 ') # } # res += sign * num # i -- # case '+': # sign = 1 # case '-': # sign = - 1 # case '(': # stack = append ( stack , res , sign ) # res = 0 # sign = 1 # case ')': # sign = stack [ len ( stack )- 1 ] # temp := stack [ len ( stack )- 2 ] # stack = stack [: len ( stack )- 2 ] # res = sign * res + temp # } # } # # return res
benchmarkHashMapGet ( b , newOpenHashMap ())
var tests = [] struct { # left , right int # nums [] int # }{ # { 1 , 2 2 , [] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 1 , 1 2 , 1 5 , 2 2 }}, # } # # for _ , tt := range tests { # nums := selfDividingNumbers ( tt . left , tt . right ) # if reflect . DeepEqual ( nums , tt . nums ) == false { # t . Errorf (" STR ", tt . left , tt . right , nums , tt . nums ) # } # }
if intervals == nil || len ( intervals ) <= 1 { # return intervals # } # sort . Sort ( SortByInt ( intervals )) # # start := intervals [ 0 ]. Start # end := intervals [ 0 ]. End # # ans := make ([] Interval , 0 ) # # for _ , v := range intervals { # if v . Start <= end { # end = Max ( end , v . End ) # } else { # ans = append ( ans , Interval { Start : start , End : end }) # start = v . Start # end = v . End # } # } # ans = append ( ans , Interval { Start : start , End : end }) # return ans
clumps := countClumps ([] int { 1 , 1 , 1 , 1 , 1 }) # fmt . Println ( clumps )
<- ch # wg . Done ()
cap := randuint 3 2 () % uint 3 2 ( max + 1 ) # len := randuint 3 2 () % ( cap + 1 ) # s := make ([] uint 3 2 , len , cap ) # for i := uint 3 2 ( 0 ); i < len ; i ++ { # s [ i ] = randuint 3 2 () # } # return s
matrix := make ([][] int , n ) # for row := 0 ; row < len ( matrix ); row ++ { # matrix [ row ] = make ([] int , n ) # } # # v := 1 # topBoundary , rightBoundary , bottomBoundary , # leftBoundary := 0 , len ( matrix [ 0 ]), len ( matrix ), 0 # for topBoundary < bottomBoundary { # for col := leftBoundary ; col < rightBoundary ; col ++ { # matrix [ topBoundary ][ col ] = v # v ++ # } # topBoundary ++ # # for row := topBoundary ; row < bottomBoundary ; row ++ { # matrix [ row ][ rightBoundary - 1 ] = v # v ++ # } # rightBoundary -- # # for col := rightBoundary - 1 ; col >= leftBoundary ; col -- { # matrix [ bottomBoundary - 1 ][ col ] = v # v ++ # } # bottomBoundary -- # # for row := bottomBoundary - 1 ; row >= topBoundary ; row -- { # matrix [ row ][ leftBoundary ] = v # v ++ # } # leftBoundary ++ # } # # return matrix
if numRows == 1 { # return s # } # # item_len := 2 * numRows - 2 # res := make ([][] string , numRows , numRows ) # # for index , v := range s { # # mod := index % item_len # # if mod < numRows { # res [ mod ] = append ( res [ mod ], string ( v )) # } else { # i := numRows - ( mod - numRows ) - 2 # res [ i ] = append ( res [ i ], string ( v )) # } # } # # var str string # # for _ , arr := range res { # for _ , v := range arr { # str += v # } # } # # return str
sort . Slice ( nums , func ( m , n int ) bool { # mn := fmt . Sprintf (" STR ", nums [ m ], nums [ n ]) # nm := fmt . Sprintf (" STR ", nums [ n ], nums [ m ]) # return strings . Compare ( mn , nm ) > 0 # }) # # var result string # for _ , num := range nums { # if result == " STR " { # result = fmt . Sprintf (" STR ", num ) # } else { # result = fmt . Sprintf (" STR ", result , num ) # } # } # # return result
if rowIndex == 0 { # return [] int { 1 } # } # # var res = make ([][] int , rowIndex + 1 ) # res [ 0 ] = [] int { 1 } # for i := 1 ; i <= rowIndex ; i ++ { # internalArr := make ([] int , i + 1 ) # internalArr [ 0 ] = 1 # internalArr [ len ( internalArr )- 1 ] = 1 # for j := 1 ; j < len ( internalArr )- 1 ; j ++ { # internalArr [ j ] = res [ i - 1 ][ j - 1 ] + res [ i - 1 ][ j ] # } # res [ i ] = internalArr # } # return res [ len ( res )- 1 ]
return m . cache [ m . bucketNo ( key )]. GetStaleNow ( key , now )
const max = 0 x 7 fffffff # min := func ( m , n int ) int { # if m < n { # return m # } # # return n # } # # if len ( triangle ) == 0 { # return 0 # } # # dp := make ([] int , len ( triangle )) # dp [ 0 ] = triangle [ 0 ][ 0 ] # for i := 1 ; i < len ( triangle ); i ++ { # for j := len ( triangle [ i ]) - 1 ; j >= 0 ; j -- { # k := max # if j < i { # k = min ( k , dp [ j ]) # } # # if j >= 1 { # k = min ( k , dp [ j - 1 ]) # } # # dp [ j ] = k + triangle [ i ][ j ] # } # } # # k := max # for i := 0 ; i < len ( triangle ); i ++ { # k = min ( k , dp [ i ]) # } # # return k
starttime := time . Now () # # fmt . Println (" STR ", time . Since ( starttime ))
if node == nil { # return false # } # if stop := callback ( bt , node ); stop { # return true # } # for i := range node . c { # if stop := bt . preOrderWalk ( node . c [ i ], callback ); stop { # return true # } # } # return false
p , c := 0 , 1 # cnt := 0 # for i := 1 ; i < len ( s ); i ++ { # if s [ i ] == s [ i - 1 ] { # c ++ # } else { # p = c # c = 1 # } # if p >= c { # cnt ++ # } # # } # return cnt
arr := [] int { 1 , 1 , 2 , 2 , 2 , 3 } # half := len ( arr ) / 2 # d := make ( map [ int ] interface {}) # for _ , v := range arr { # if d [ v ] == nil { # d [ v ] = 1 # } else { # d [ v ] = d [ v ].( int ) + 1 # } # } # for k , item := range d { # if item .( int ) >= half { # fmt . Println ( k ) # } # }
stk := NewStack () # stk . Push ( 1 ) # stk . Push ( 2 ) # stk . Push ( 3 ) # stk . Push ( 4 ) # stk . Push ( 5 ) # fmt . Println ( stk . Pop ()) # fmt . Println ( stk . Pop ()) # fmt . Println ( stk . Pop ()) # fmt . Println ( stk . Pop ()) # fmt . Println ( stk . Pop ()) # fmt . Println ( stk . Empty ()) # # for ! stk . Empty () { # fmt . Println ( stk . Pop ()) # }
table := make ([][] int , ndice + 1 ) # for i := range table { # table [ i ] = make ([] int , total + 1 ) # } # table [ 0 ][ 0 ] = 1 # for i := 1 ; i <= ndice ; i ++ { # for j := i ; j <= total ; j ++ { # table [ i ][ j ] = table [ i ][ j - 1 ] + table [ i - 1 ][ j - 1 ] # if j - faces - 1 >= 0 { # table [ i ][ j ] -= table [ i - 1 ][ j - faces - 1 ] # } # } # } # return table [ ndice ][ total ]
starttime := time . Now () # # count := make ( map [ int 6 4 ] int ) # # for a := int 6 4 ( 1 ); a < maxA ; a ++ { # # for c := 2 * a - 1 ; c >= 0 ; c -- { # # n := 4 * a * a - c * c # # if n > top { # break # } # # if a - c > 0 { # count [ n ]++ # } # if a + c > 0 && c != 0 { # count [ n ]++ # # } # } # # } # # total := 0 # for _ , mult := range count { # # if mult == 1 0 { # # total ++ # } # } # # fmt . Println ( total ) # # fmt . Println (" STR ", time . Since ( starttime ))
qs := [] question 1 0 5 4 { # # { # para 1 0 5 4 {[] int { 1 , 1 , 1 , 2 , 2 , 2 }}, # ans 1 0 5 4 {[] int { 2 , 1 , 2 , 1 , 2 , 1 }}, # }, # # { # para 1 0 5 4 {[] int { 1 , 1 , 1 , 1 , 2 , 2 , 3 , 3 }}, # ans 1 0 5 4 {[] int { 1 , 3 , 1 , 3 , 2 , 1 , 2 , 1 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 5 4 , q . para 1 0 5 4 # fmt . Printf (" STR ", p , rearrangeBarcodes ( p . one )) # } # fmt . Printf (" STR ")
var pair [ 2 ] int # pair [ 0 ] = 1 # pair [ 1 ] = 1 # sum := 0 # for ( pair [ 0 ] + pair [ 1 ]) < 4 0 0 0 0 0 0 { # newItem := pair [ 0 ] + pair [ 1 ] # pair [ 0 ] = pair [ 1 ] # pair [ 1 ] = newItem # if pair [ 1 ]% 2 == 0 { # sum += pair [ 1 ] # } # } # # fmt . Printf (" STR ", sum )
n := len ( grid ) # xz , yz := make ([] int , n ), make ([] int , n ) # res := 0 # for x , axis := range grid { # for y , z := range axis { # if z == 0 { # continue # } # res ++ # xz [ y ] = max ( xz [ y ], z ) # yz [ x ] = max ( yz [ x ], z ) # } # } # for i := range xz { # res += xz [ i ] + yz [ i ] # } # return res
if len ( prices ) <= 1 { # return 0 # } # buy , sell := make ([] int , len ( prices )), make ([] int , len ( prices )) # for i := range buy { # buy [ i ] = math . MinInt 6 4 # } # buy [ 0 ] = - prices [ 0 ] # buy [ 1 ] = max ( buy [ 0 ], - prices [ 1 ]) # sell [ 1 ] = max ( sell [ 0 ], buy [ 0 ]+ prices [ 1 ]) # for i := 2 ; i < len ( prices ); i ++ { # sell [ i ] = max ( sell [ i - 1 ], buy [ i - 1 ]+ prices [ i ]) # buy [ i ] = max ( buy [ i - 1 ], sell [ i - 2 ]- prices [ i ]) # } # return sell [ len ( sell )- 1 ]
var found bool # if nil == data || 1 > len ( data ) { # return 0 , 0 , found # } # # ahead , behind := 0 , len ( data )- 1 # for ahead < behind { # currentSum := data [ ahead ] + data [ behind ] # if currentSum == sum { # found = true # return data [ ahead ], data [ behind ], found # } else if currentSum < sum { # ahead ++ # } else { # behind -- # } # } # return 0 , 0 , found
this . mutex . Lock () # defer this . mutex . Unlock () # return this . list . Len ()
var buf [ 4 0 9 6 ] byte # n := runtime . Stack ( buf [:], false ) # os . Stdout . Write ( buf [: n ])
r . targets = append ( r . targets , t )
srcFile , err := os . Open (" STR ") # if err != nil { # log . Fatalln ( err ) # } # defer srcFile . Close () # # scanner := bufio . NewScanner ( srcFile ) # scanner . Split ( bufio . ScanWords ) # for scanner . Scan () { # line := scanner . Text () # if len ( line ) > 0 { # line = strings . ToUpper ( string ( line [ 0 ])) + line [ 1 :] # } # fmt . Println ( line ) # }
if num % 2 == 1 { # return false # } # # if num % 1 0 != 6 && num % 1 0 0 != 2 8 { # return false # } # # sum := 1 # for i := 2 ; i <= mySqrt ( num ); i ++ { # if num % i == 0 { # sum += i + num / i # } # } # return sum == num
self . top -- # value := self . slots [ self . top ]. Num # return value
var prev , cur * BST # if root . right != nil { # prev = root # cur = root . right # for cur . right != nil { # cur = cur . right # prev = prev . right # } # cur = prev # } else { # cur = root . left # for cur . right != nil { # cur = cur . right # } # } # return cur . val
return N % 2 == 0
total , sumMax , sumMin := 0 , 0 , 0 # max , min := A [ 0 ], A [ 0 ] # for _ , num := range A { # total += num # # if sumMax <= 0 { # sumMax = num # } else { # sumMax += num # } # # if max < sumMax { # max = sumMax # } # # if sumMin >= 0 { # sumMin = num # } else { # sumMin += num # } # # if min > sumMin { # min = sumMin # } # } # # if max < 0 { # return max # } # # return int ( math . Max ( float 6 4 ( max ), float 6 4 ( total - min )))
cases := [] struct { # name string # inputs [][] byte # expect int # }{ # {" STR ", [][] byte { # {" STR ", " STR ", " STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR ", " STR ", " STR "}, # }, 6 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := maximalRectangle ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
ans := 0 # for _ , value := range nums { # ans ^= value # } # return ans
return s . minStack [ len ( s . minStack )- 1 ]
if number == 1 { # return [] int {} # } # vals := [] int { 1 } # sqrt := int ( math . Sqrt ( float 6 4 ( number ))) # for idx := 2 ; idx <= sqrt ; idx ++ { # if number % idx == 0 { # vals = append ( vals , idx ) # another := number / idx # if another != idx { # vals = append ( vals , another ) # } # } # } # return vals
if len ( pts ) < 2 { # return nil # } else if len ( pts ) == 2 { # return pts # } # res := make ([] Point , 2 ) # dist := math . MaxFloat 6 4 # for i := 0 ; i < len ( pts )- 1 ; i ++ { # for j := i + 1 ; j < len ( pts ); j ++ { # d := math . Sqrt ( # math . Pow ( float 6 4 ( pts [ i ]. X - pts [ j ]. X ), 2 . 0 ) + # math . Pow ( float 6 4 ( pts [ i ]. Y - pts [ j ]. Y ), 2 . 0 )) # if d < dist { # dist = d # res [ 0 ] = pts [ i ] # res [ 1 ] = pts [ j ] # } # } # } # return res
res := [] string {} # for _ , v := range words { # if exist ( board , v ) { # res = append ( res , v ) # } # } # return res
sum := n * ( n + 1 ) / 2 # sum_sq := ( 2 * n + 1 ) * ( n + 1 ) * n / 6 # return sum * sum - sum_sq
var ( # obj map [ string ] interface {} # ks string # ok bool # bs [] byte # ) # err = json . Unmarshal ( data , & obj ) # if err != nil { # return # } # k , ok := obj [ PublicKeyField ] # if ! ok { # goto missing # } # ks , ok = k .( string ) # if ! ok { # goto invalid # } # if len ( ks ) != 6 4 { # goto invalid # } # bs , err = hex . DecodeString ( ks ) # if err != nil { # goto invalid # } # if len ( bs ) != 3 2 { # goto invalid # } # copy ( key [:], bs ) # return # missing : # err = ErrPublicKeyMissing # return # invalid : # err = ErrPublicKeyInvalid # return
return list . len
var result int # for i := 0 ; i < len ( roman ); i ++ { # if first := romanNumeralMap [ rune ( roman [ i ])]; i + 1 < len ( roman ) { # if second := romanNumeralMap [ rune ( roman [ i + 1 ])]; first >= second { # result += first # } else { # result += second - first # i ++ # } # } else { # result += first # i ++ # } # } # return result
return helper ([] byte ( s ), 0 , len ( s )- 1 , false )
if len ( A ) == 0 { # return A # } # x := len ( A ) # y := len ( A [ 0 ]) # resultMatrix := make ([][] int , y ) # for i := 0 ; i < len ( resultMatrix ); i ++ { # resultMatrix [ i ] = make ([] int , x ) # } # # for i := 0 ; i < x ; i ++ { # for j := 0 ; j < y ; j ++ { # resultMatrix [ j ][ i ] = A [ i ][ j ] # } # } # return resultMatrix
file , err := os . Open ( filename ) # if err != nil { # return err # } # defer file . Close () # # dec := json . NewDecoder ( file ) # return dec . Decode ( v )
counts := make ([] int , len ( ratings )) # for i := 0 ; i < len ( ratings ); i ++ { # if i > 0 && ratings [ i ] > ratings [ i - 1 ] { # counts [ i ] = counts [ i - 1 ] + 1 # } else { # counts [ i ] = 1 # } # } # # for i := len ( ratings ) - 2 ; i >= 0 ; i -- { # if ratings [ i ] > ratings [ i + 1 ] && counts [ i ] < counts [ i + 1 ]+ 1 { # counts [ i ] = counts [ i + 1 ] + 1 # } # } # # result := 0 # for _ , c := range counts { # result += c # } # # return result
rc , err := zip . OpenReader ( archive ) # if err != nil { # return err # } # defer rc . Close () # for _ , file := range rc . File { # frc , err := file . Open () # if err != nil { # return err # } # defer frc . Close () # fmt . Fprintf ( os . Stdout , " STR ", file . Name ) # copied , err := io . Copy ( os . Stdout , frc ) # if err != nil { # return err # } # if uint 6 4 ( copied ) != file . UncompressedSize 6 4 { # return fmt . Errorf (" STR ", file . Name ) # } # fmt . Println () # } # return nil
qs := [] question 2 2 { # # { # para 2 2 { 3 }, # ans 2 2 {[] string { # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 2 , q . para 2 2 # fmt . Printf (" STR ", p , generateParenthesis ( p . one )) # } # fmt . Printf (" STR ")
return min ( # move ( math . MaxInt 6 4 , 0 , A ), # move ( A [ 0 ], 1 , A ), # )
var tests = [] struct { # tree * TreeNode # sums [] int # }{ # { newTree ( 5 , 2 , - 3 ), [] int {- 3 , 2 , 4 }}, # { newTree ( 5 , 2 , - 5 ), [] int { 2 }}, # } # # for _ , tt := range tests { # sums := findFrequentTreeSum ( tt . tree ) # sort . Ints ( sums ) # if reflect . DeepEqual ( sums , tt . sums ) == false { # t . Errorf (" STR ", tt . tree , sums , tt . sums ) # } # }
qs := [] question 1 6 { # # { # para 1 6 {[] int {- 1 , 0 , 1 , 1 , 5 5 }, 3 }, # ans 1 6 { 2 }, # }, # # { # para 1 6 {[] int { 0 , 0 , 0 }, 1 }, # ans 1 6 { 0 }, # }, # # { # para 1 6 {[] int {- 1 , 2 , 1 , - 4 }, 1 }, # ans 1 6 { 2 }, # }, # # { # para 1 6 {[] int { 1 , 1 , - 1 }, 0 }, # ans 1 6 { 1 }, # }, # # { # para 1 6 {[] int {- 1 , 2 , 1 , - 4 }, 1 }, # ans 1 6 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 6 , q . para 1 6 # fmt . Printf (" STR ", p , threeSumClosest ( p . a , p . target )) # } # fmt . Printf (" STR ")
testCases := [][] int { # { 1 , 2 , 3 , 1 }, # { 1 , 2 , 3 , 4 }, # } # expected := [] bool { true , false } # # for index , nums := range testCases { # if res := containsDuplicate ( nums ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
result := make ([] int , amount + 1 ) # tmp := make ([] int , amount + 1 ) # sort . Ints ( coins ) # result [ 0 ] = 1 # baseCoin := coins [ 0 ] # for idx := baseCoin ; idx <= amount ; idx += baseCoin { # result [ idx ] = 1 # } # for idx := 1 ; idx < len ( coins ); idx ++ { # for start := 0 ; start <= amount ; start ++ { # for walker := 0 ; walker + start <= amount ; walker += coins [ idx ] { # tmp [ walker + start ] += result [ start ] # } # } # for idx := 0 ; idx <= amount ; idx ++ { # result [ idx ], tmp [ idx ] = tmp [ idx ], 0 # } # } # return result [ amount ]
if len ( board ) == 0 { # return 0 # } # # m , n := len ( board ), len ( board [ 0 ]) # # count := 0 # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # if board [ i ][ j ] == ' X ' && ( i == 0 || board [ i - 1 ][ j ] == '.') && ( j == 0 || board [ i ][ j - 1 ] == '.') { # count ++ # } # } # } # # return count
fmt . Println ( Average ( 7 , 8 , 1 0 ))
cases := [] struct { # name string # inputs [] int # expect * TreeNode # }{ # {" STR ", [] int {- 1 0 , - 3 , 0 , 5 , 9 }, & TreeNode { # Val : 0 , # Left : & TreeNode { # Val : - 3 , # Left : & TreeNode { Val : - 1 0 }, # }, # Right : & TreeNode { # Val : 9 , # Left : & TreeNode { Val : 5 }, # }, # }}, # {" STR ", [] int { 1 , 3 }, & TreeNode { Val : 3 , Left : & TreeNode { Val : 1 }, Right : nil }}, # {" STR ", [] int { 1 }, & TreeNode { Val : 1 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
numMap := make ( map [ int ] bool ) # for _ , v := range nums { # if _ , ok := numMap [ v ]; ok { # numMap [ v ] = false # } else { # numMap [ v ] = true # } # } # for _ , v := range nums { # if numMap [ v ] == true { # return v # } # } # return 0
t . Parallel () # for _ , tc := range testcases { # if result := SmallestSetCoverage ( tc . intervals ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
count = len ( value . String ()) # return
for { # if r == q . IDs [ r ] { # break # } # r = q . IDs [ r ] # } # return r
hasSeen := [ 1 0 0 0 0 ] bool {} # var res int # for _ , res = range A { # if hasSeen [ res ] { # break # } # hasSeen [ res ] = true # } # return res
m := 1 0 0 0 0 0 0 0 0 7 # n := len ( s ) # if n == 0 { # return 0 # } # # dp := make ([] int , n + 1 ) # dp [ 0 ], dp [ 1 ] = 1 , one ( s [ 0 ]) # for i := 2 ; i <= n ; i ++ { # w 1 , w 2 := one ( s [ i - 1 ]), two ( s [ i - 2 ], s [ i - 1 ]) # dp [ i ] = dp [ i - 1 ]* w 1 + dp [ i - 2 ]* w 2 # if dp [ i ] == 0 { # return 0 # } # dp [ i ] %= m # } # return dp [ n ]
x , y := 1 , 0 # for 0 < n { # carry := n % 1 0 # n /= 1 0 # x *= carry # y += carry # } # return x - y
return syscall . Getppid ()
tests := [...] testType { # { # s : " STR ", # t : " STR ", # want : true , # }, # { # s : " STR ", # t : " STR ", # want : false , # }, # { # s : " STR ", # t : " STR ", # want : false , # }, # { # s : " STR ", # t : " STR ", # want : false , # }, # { # s : " STR ", # t : " STR ", # want : true , # }, # } # # for _ , tt := range tests { # got := isAnagram ( tt . s , tt . t ) # if got != tt . want { # t . Fatalf (" STR ", tt . s , tt . t , got , tt . want ) # } # }
e := encode ( pattern ) # res := [] string {} # for _ , word := range words { # if encode ( word ) == e { # res = append ( res , word ) # } # } # return res
var i , j int # table := buildTable ( substr ) # for i < len ( input ) { # if substr [ j ] == input [ i ] { # i ++ # j ++ # } # if j == len ( substr ) { # return i - j # } # if i < len ( input ) && substr [ j ] != input [ i ] { # if j != 0 { # j = table [ j - 1 ] # } else { # i ++ # } # } # } # return - 1
res , i , n := 0 , 0 , len ( chars ) # for i < n { # b := chars [ i ] # count := 0 # for i < n && chars [ i ] == b { # i ++ # count ++ # } # chars [ res ] = b # res ++ # if count != 1 { # cs := strconv . Itoa ( count ) # for j := 0 ; j < len ( cs ); j ++ { # chars [ res ] = cs [ j ] # res ++ # } # } # } # return res
tree , visited , count , res := make ([][] int , N ), make ([] bool , N ), make ([] int , N ), make ([] int , N ) # for _ , e := range edges { # i , j := e [ 0 ], e [ 1 ] # tree [ i ] = append ( tree [ i ], j ) # tree [ j ] = append ( tree [ j ], i ) # } # deepFirstSearch ( 0 , visited , count , res , tree ) # visited = make ([] bool , N ) # deepSecondSearch ( 0 , visited , count , res , tree ) # # return res
t . Parallel () # for _ , tc := range testcases { # if result := CryptarithmeticAdditionPuzzle ( tc . first , tc . second , tc . result ); ! reflect . DeepEqual ( result , tc . solution ) { # t . Errorf (" STR ", tc . solution , result ) # } # }
fmt . Println ( subsets ([] int { 1 , 2 , 3 })) # fmt . Println ( subsets ([] int { 1 , 2 , 3 , 4 }))
i := 1 # defer deferred (" STR ", i ) # i += 1 # defer deferred (" STR ", i ) # println (" STR ")
if n == nil { # return slice # } # sum -= n . Val # stack = append ( stack , n . Val ) # # if sum == 0 && n . Left == nil && n . Right == nil { # slice = append ( slice , append ([] int ( nil ), stack ...)) # stack = stack [: len ( stack )- 1 ] # } # # slice = pathSumHelper ( n . Left , sum , slice , stack ) # slice = pathSumHelper ( n . Right , sum , slice , stack ) # return slice
if root == nil { # return [][] int {} # } # res := make ([][] int , 0 ) # stack := []* TreeNode { root } # reverse := false # for len ( stack ) > 0 { # temp := make ([]* TreeNode , 0 ) # tempVals := make ([] int , 0 ) # for len ( stack ) > 0 { # node := stack [ 0 ] # tempVals = append ( tempVals , node . Val ) # if node . Left != nil { # temp = append ( temp , node . Left ) # } # if node . Right != nil { # temp = append ( temp , node . Right ) # } # stack = stack [ 1 :] # } # if reverse { # for i , j := 0 , len ( tempVals ) - 1 ; i < j ; i , j = i + 1 , j - 1 { # tempVals [ i ], tempVals [ j ] = tempVals [ j ], tempVals [ i ] # } # } # reverse = ! reverse # res = append ( res , tempVals ) # stack = append ( stack , temp ...) # } # return res
if num <= 0 { # return false # } # for num % 2 == 0 { # num /= 2 # } # for num % 3 == 0 { # num /= 3 # } # for num % 5 == 0 { # num /= 5 # } # return num == 1 #
qs := [] question 1 0 2 1 { # { # para 1 0 2 1 {" STR "}, # ans 1 0 2 1 {" STR "}, # }, # # { # para 1 0 2 1 {" STR "}, # ans 1 0 2 1 {" STR "}, # }, # # { # para 1 0 2 1 {" STR "}, # ans 1 0 2 1 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 2 1 , q . para 1 0 2 1 # fmt . Printf (" STR ", p , removeOuterParentheses ( p . one )) # } # fmt . Printf (" STR ")
target := make ([] byte , n - 1 ) # for i := 0 ; i < n - 1 ; i ++ { # target [ i ] = ' 0 ' # } # # pref := map [ string ] int {} # # for { # cur := string ( target [ len ( target )-( n - 1 ):]) # # if r , ok := pref [ cur ]; ! ok { # pref [ cur ] = k - 1 # } else if r < 0 { # return string ( target ) # } # # target = append ( target , ' 0 '+ byte ( pref [ cur ])) # pref [ cur ]-- # }
output := make ([] string , 0 ) # for k , v := range FIELD_ACCESS_FLAGS { # if flags & k != 0 { # output = append ( output , v ) # } # } # return strings . Join ( output , " STR ")
var numCases int # fmt . Scanf (" STR ", & numCases ) # # for i := 1 ; i <= numCases ; i ++{ # var N int # fmt . Scanf (" STR ",& N ) # LargestPrimeFactor ( N ) # }
if ! sort . IntsAreSorted ( inputArr ) { # sort . Ints ( inputArr ) # sortArr = inputArr # } # # arrLen = len ( sortArr ) # # for i := 0 ; i < arrLen - 2 ; i ++ { # if i > 0 && sortArr [ i - 1 ] == sortArr [ i ] { # continue # } # # currNum := sortArr [ i ] # # low := i + 1 # high := arrLen - 1 # # for low < high { # lowNum := sortArr [ low ] # highNum := sortArr [ high ] # # sumNum := currNum + lowNum + highNum # # if sumNum == target { # resNum [ 0 ] = currNum # resNum [ 1 ] = lowNum # resNum [ 2 ] = highNum # resNum [ 3 ] = currInput # printer ( resNum , target ) # low ++ # # } else if sumNum > 0 { # # for high > 0 && sortArr [ high ] == sortArr [ high - 1 ] { # high -- # } # # high -- # # } else { # # for low < arrLen && sortArr [ low ] == sortArr [ low + 1 ] { # # low ++ # } # low ++ # } # # } # } # # return inputArr
min , val := root . Val , - 1 # # var f func (* TreeNode ) # f = func ( root * TreeNode ) { # if root == nil { # return # } # # if root . Val == min { # f ( root . Left ) # f ( root . Right ) # } else if root . Val < val || val == - 1 { # val = root . Val # } # } # f ( root ) # # return val
t . Parallel () # for _ , tc := range testcases { # if result := MinimizeQux ( tc . input ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
strs := make ([] string , len ( nums )) # for i , n := range nums { # strs [ i ] = strconv . Itoa ( n ) # } # # switch len ( strs ) { # case 1 : # return strs [ 0 ] # case 2 : # return strings . Join ( strs , " STR ") # default : # return strs [ 0 ] + " STR " + strings . Join ( strs [ 1 :], " STR ") + " STR " # }
path := make ( map [* Node ] struct {}) # for n 1 != nil { # if _ , seen := path [ n 1 ]; seen { # return nil # } # path [ n 1 ] = struct {}{} # n 1 = n 1 . Parent # } # path 2 := make ( map [* Node ] struct {}) # for n 2 != nil { # if _ , seen := path 2 [ n 2 ]; seen { # return nil # } # path 2 [ n 2 ] = struct {}{} # if _ , found := path [ n 2 ]; found { # return n 2 # } # n 2 = n 2 . Parent # } # return nil
t . Parallel () # # for _ , tc := range testcases { # if result := HIndex ( tc . citations ); result != tc . hindex { # t . Errorf (" STR ", tc . hindex , result ) # } # }
return x >> y
res := [][] int {} # sort . Ints ( nums ) # # var dfs func ( int , [] int ) # dfs = func ( idx int , temp [] int ) { # t := make ([] int , len ( temp )) # copy ( t , temp ) # res = append ( res , t ) # # for i := idx ; i < len ( nums ); i ++ { # if i == idx || nums [ i ] != nums [ i - 1 ] { # dfs ( i + 1 , append ( temp , nums [ i ])) # } # } # } # # temp := make ([] int , 0 , len ( nums )) # dfs ( 0 , temp ) # # return res
t . Parallel () # # for _ , tc := range testcases { # if res := Embolden ( tc . s , tc . lst ); res != tc . expected { # t . Errorf (" STR ", tc . expected , res ) # } # }
intersections := 0 # for i := range p { # for j := i + 1 ; j < len ( q ); j ++ { # diffP := p [ j ] - p [ i ] # diffQ := q [ j ] - q [ i ] # if ( diffP < 0 && diffQ > 0 ) || ( diffP > 0 && diffQ < 0 ) { # intersections ++ # } # } # } # return intersections
start , end , step , n := 0 , 0 , 0 , len ( nums ) # for end < n - 1 { # step ++ # maxEnd := end + 1 # for i := start ; i < end + 1 ; i ++ { # tmp := i + nums [ i ] # if tmp >= n - 1 { # return step # } # if tmp > maxEnd { # maxEnd = tmp # } # } # start , end = end + 1 , maxEnd # } # return step
cases := [] struct { # name string # inputs * TreeNode # expect bool # }{ # { # " STR ", # & TreeNode { Val : 1 , # Left : & TreeNode { Val : 2 , Right : & TreeNode { Val : 3 }}, # Right : & TreeNode { Val : 2 , Right : & TreeNode { Val : 3 }}, # }, # false , # }, # { # " STR ", # & TreeNode { Val : 1 , # Left : & TreeNode { Val : 2 , # Left : & TreeNode { Val : 3 }, # Right : & TreeNode { Val : 4 }}, # Right : & TreeNode { Val : 2 , # Left : & TreeNode { Val : 4 }, # Right : & TreeNode { Val : 3 }, # }, # }, # true , # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := isSymmetric_BFS ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
sum := 0 # for _ , v := range nums { # sum += v # } # if sum % 2 != 0 { # return false # } # n , C , dp := len ( nums ), sum / 2 , make ([] bool , sum / 2 + 1 ) # for i := 0 ; i <= C ; i ++ { # dp [ i ] = ( nums [ 0 ] == i ) # } # for i := 1 ; i < n ; i ++ { # for j := C ; j >= nums [ i ]; j -- { # dp [ j ] = dp [ j ] || dp [ j - nums [ i ]] # } # } # return dp [ C ]
sum := 1 # previous := 1 # # var fibEven [] int # # for sum <= 4 0 0 0 0 0 0 { # # x := sum # # sum = sum + previous # # previous = x # # if sum % 2 == 0 { # fibEven = append ( fibEven , sum ) # } # } # # evenSum := 0 # # for _ , num := range fibEven { # evenSum += num # } # # fmt . Println ( evenSum ) #
(* p )[ i ], (* p )[ j ] = (* p )[ j ], (* p )[ i ]
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 3 , 0 , 1 }, 2 }, # {" STR ", [] int { 9 , 6 , 4 , 2 , 3 , 5 , 7 , 0 , 1 }, 8 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if p [ x ] != x { # p [ x ] = find ( p [ x ]) # } # return p [ x ]
ans := nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i - 1 ] > 0 { # nums [ i ] += nums [ i - 1 ] # } # ans = max ( ans , nums [ i ]) # } # return ans
if n <= 2 { # return n # } # dp := make ([] int , n ) # dp [ 0 ] = 1 # dp [ 1 ] = 2 # for i := 2 ; i < n ; i ++ { # dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] # } # return dp [ n - 1 ]
n -- # first , digits := 1 , 1 # for n / 9 / first / digits >= 1 { # n -= 9 * first * digits # digits ++ # first *= 1 0 # } # return int ( strconv . Itoa ( first + n / digits )[ n % digits ] - ' 0 ')
cases := [] struct { # name string # inputs string # expect string # }{ # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := longestPalindrome 5 ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
return & IPList { # ranges : initSorted , # }
reverse := 0 # orignal := i # for i != 0 { # reverse =( reverse * 1 0 ) + i % 1 0 # i = i / 1 0 # } # if orignal == reverse { # return true # } # return false
matrix , res := make ([][] int , n ), 0 # for i := range matrix { # matrix [ i ] = make ([] int , m ) # } # for _ , indice := range indices { # for i := 0 ; i < m ; i ++ { # matrix [ indice [ 0 ]][ i ]++ # } # for j := 0 ; j < n ; j ++ { # matrix [ j ][ indice [ 1 ]]++ # } # } # for _ , m := range matrix { # for _ , v := range m { # if v & 1 == 1 { # res ++ # } # } # } # return res
benchmark ( bb , 3 2 7 6 8 , 0 . 9 )
ex := trimAllSpaces ( expr ) # return simpleMath ([] rune ( ex ))
qs := [] question 1 3 0 6 { # # { # para 1 3 0 6 {[] int { 4 , 2 , 3 , 0 , 3 , 1 , 2 }, 5 }, # ans 1 3 0 6 { true }, # }, # # { # para 1 3 0 6 {[] int { 4 , 2 , 3 , 0 , 3 , 1 , 2 }, 0 }, # ans 1 3 0 6 { true }, # }, # # { # para 1 3 0 6 {[] int { 3 , 0 , 2 , 1 , 2 }, 2 }, # ans 1 3 0 6 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 3 0 6 , q . para 1 3 0 6 # fmt . Printf (" STR ", p , canReach ( p . arr , p . start )) # } # fmt . Printf (" STR ")
var max , sum int # for i , num := range nums { # sum += num # # if sum > max || i == 0 { # max = sum # } # if sum < 0 { # sum = 0 # } # } # return max
dp , res := make ([] int , len ( nums )+ 1 ), 0 # dp [ 0 ] = 0 # for i := 1 ; i <= len ( nums ); i ++ { # for j := 1 ; j < i ; j ++ { # if nums [ j - 1 ] < nums [ i - 1 ] { # dp [ i ] = max ( dp [ i ], dp [ j ]) # } # } # dp [ i ] = dp [ i ] + 1 # res = max ( res , dp [ i ]) # } # return res
s = strings . ToLower ( s ) # if s == " STR " { # v := uint 6 4 ( 0 ) # for vn := range this . values { # v |= vn # } # return v , nil # } else if s == " STR " { # return 0 , nil # } # ss := strings . Split ( s , " STR ") # if len ( ss ) == 0 { # return 0 , fmt . Errorf (" STR ") # } # v := uint 6 4 ( 0 ) # for _ , sn := range ss { # vn , ok := this . fields [ sn ] # if ! ok { # return 0 , fmt . Errorf (" STR ", sn ) # } # v |= vn # } # return v , nil
if GCD ( 1 0 0 , 2 0 0 ) != 5 0 { # t . Error (" STR ") # } # # if GCD ( 4 , 2 ) != 1 { # t . Error (" STR ") # } # # if GCD ( 6 , 3 ) != 3 { # t . Error (" STR ") # }
l := make ([] int , k + 1 ) # return MyCircularQueue { start : 0 , end : 0 , cap : k + 1 , l : l }
pre , ans , l := 0 , make ([][] int , 0 ), len ( S ) # for i , v := range S { # if i == l - 1 || v != rune ( S [ i + 1 ]) { # if i - pre >= 2 { # ans = append ( ans , [] int { pre , i }) # } # pre = i + 1 # } # } # return ans
buildMap := func ( words [] string ) map [ string ] int { # strToCount := make ( map [ string ] int ) # for _ , word := range words { # count := strToCount [ word ] # strToCount [ word ] = count + 1 # } # # return strToCount # } # # words 1 , words 2 := strings . Split ( A , " STR "), strings . Split ( B , " STR ") # map 1 , map 2 := buildMap ( words 1 ), buildMap ( words 2 ) # var result [] string # for _ , word := range words 1 { # if map 1 [ word ] == 1 && map 2 [ word ] == 0 { # result = append ( result , word ) # } # } # # for _ , word := range words 2 { # if map 2 [ word ] == 1 && map 1 [ word ] == 0 { # result = append ( result , word ) # } # } # # return result
return w . buf
if head == nil || head . Next == nil { # return head # } # # temp := head . Next # head . Next = swapPairs ( temp . Next ) # temp . Next = head # # return temp
min := int 6 4 ( 2 ) # max := int 6 4 ( 1 0 0 ) # # var distinctTerms []* big . Int # var combination * big . Int # for a := int 6 4 ( min ); a <= max ; a ++ { # for b := int 6 4 ( min ); b <= max ; b ++ { # combination = new ( big . Int ). Exp ( big . NewInt ( a ), big . NewInt ( b ), nil ) # if ! containsBigInt ( distinctTerms , combination ) { # distinctTerms = append ( distinctTerms , combination ) # } # } # } # fmt . Println ( len ( distinctTerms ))
left , right , ans := 1 , 2 , [][] int {} # for left < right { # sum := ( left + right ) * ( right - left + 1 ) / 2 # if sum == target { # arr := [] int {} # for i := left ; i <= right ; i ++ { # arr = append ( arr , i ) # } # ans = append ( ans , arr ) # left ++ # } else if sum < target { # right ++ # } else { # left ++ # } # } # return ans
maxArea := 0 # for i := range grid { # for j := range grid [ i ] { # maxArea = max ( maxArea , getArea ( grid , i , j )) # } # } # return maxArea
return & Random { rand . New ( rand . NewSource ( time . Now (). UnixNano ()))}
rows , columns := len ( matrix ), len ( matrix [ 0 ]) # for i := 1 ; i < rows ; i ++ { # for j := 1 ; j < columns ; j ++ { # if matrix [ i - 1 ][ j - 1 ] != matrix [ i ][ j ] { # return false # } # } # } # return true
if n == tree . Root () { # if ! tree . color ( n ) { # t . Log ( fmt . Sprintf (" STR ", n )) # t . FailNow () # } # }
testCases := [] string { # " STR ", # " STR ", # " STR ", # " STR ", # } # # expected := [] string { # " STR ", # " STR ", # " STR ", # " STR ", # } # # for index , data := range testCases { # if res := reverseVowels ( data ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
ret := 1 # # for ; x < GRID_SIZE && y < GRID_SIZE ; x ++ { # ret += countRoutes ( x , y + 1 ) # } # # return ret
return cardValues [ c . r ]
sum := 0 # for _ , v := range arr { # sum += v # } # if sum % 2 == 1 { # return false # } # halfSum := sum / 2 # dp := make ([][] bool , len ( arr )+ 1 ) # for k , _ := range dp { # item := make ([] bool , halfSum + 1 ) # dp [ k ] = item # dp [ k ][ 0 ] = true # } # for i := 1 ; i <= len ( arr ); i ++ { # for w := 1 ; w <= halfSum ; w ++ { # if w - arr [ i - 1 ] < 0 { # dp [ i ][ w ] = dp [ i - 1 ][ w ] # } else { # dp [ i ][ w ] = dp [ i - 1 ][ w ] || dp [ i - 1 ][ w - arr [ i - 1 ]] # } # } # } # return dp [ len ( arr )][ halfSum ]
m , l := make ( map [ int ] int ), len ( deck ) # for _ , v := range deck { # m [ v ]++ # } # flag : # for x := 2 ; x <= l ; x ++ { # if l % x == 0 { # for _ , v := range m { # if v % x != 0 { # continue flag # } # } # return true # } # } # return false
h := new ( openHashMap ) # h . hashMapBase . hashMap = h # h . hashMapBase . scaleableMap = h # return h
if n == 0 { # return false # } # # for n != 1 { # if n % 4 != 0 { # return false # } # # n /= 4 # } # # return true
testData := [][][] int { # { # { 0 , 0 , 0 }, # { 0 , 1 , 0 }, # { 0 , 0 , 0 }, # }, # { # { 0 , 0 , 0 }, # { 0 , 1 , 0 }, # { 0 , 0 , 0 }, # { 0 , 1 , 0 }, # }, # { # { 1 }, # }, # { # { 1 , 0 }, # }, # } # # expectedData := [] int { 2 , 2 , 0 , 0 } # # for index , data := range testData { # if res := uniquePathsWithObstacles ( data ); res != expectedData [ index ] { # t . Errorf (" STR ", expectedData [ index ], res ) # } # }
qP := []* TreeNode { p } # qQ := []* TreeNode { q } # # for len ( qP ) != 0 && len ( qQ ) != 0 { # pNode := qP [ 0 ] # qP = qP [ 1 :] # # qNode := qQ [ 0 ] # qQ = qQ [ 1 :] # # if pNode == nil && qNode == nil { # continue # } # if pNode == nil && qNode != nil || pNode != nil && qNode == nil { # return false # } # if pNode . Val != qNode . Val { # return false # } # # qP = append ( qP , pNode . Left , pNode . Right ) # qQ = append ( qQ , qNode . Left , qNode . Right ) # } # # if len ( qP ) == 0 && len ( qQ ) == 0 { # return true # } # return false
if head == nil { # return nil # } # odd , even := head , head . Next # evenHead := even # for even != nil && even . Next != nil { # odd . Next = even . Next # odd = odd . Next # even . Next = odd . Next # even = even . Next # } # odd . Next = evenHead # return head
if len ( digits ) == 1 { # return digits [ 0 ] == goal # } # # for i := 0 ; i < len ( digits )- 1 ; i ++ { # for _ , op := range [] rune {'+', '-', '*', '/'} { # var next [] int # next = append ( next , digits [: i ]...) # # switch op { # case '+': # next = append ( next , digits [ i ]+ digits [ i + 1 ]) # case '-': # next = append ( next , digits [ i ]- digits [ i + 1 ]) # case '*': # next = append ( next , digits [ i ]* digits [ i + 1 ]) # case '/': # if digits [ i + 1 ] == 0 { # continue # } # # next = append ( next , digits [ i ]/ digits [ i + 1 ]) # } # # next = append ( next , digits [ i + 2 :]...) # # if TwentyFourGame ( next ) { # return true # } # } # } # # return false
var res uint = 1 # for power > 0 { # if ( power & 1 ) != 0 { # res = res * n # } # # power = power >> 1 # n *= n # } # return res
sum := 0 # for _ , v := range stones { # sum += v # } # n , C , dp := len ( stones ), sum / 2 , make ([] int , sum / 2 + 1 ) # for i := 0 ; i <= C ; i ++ { # if stones [ 0 ] <= i { # dp [ i ] = stones [ 0 ] # } else { # dp [ i ] = 0 # } # } # for i := 1 ; i < n ; i ++ { # for j := C ; j >= stones [ i ]; j -- { # dp [ j ] = max ( dp [ j ], dp [ j - stones [ i ]]+ stones [ i ]) # } # } # return sum - 2 * dp [ C ]
return this . reader . Close ()
if data , err := ioutil . ReadFile ( filepath . Join ( # goroot , " STR ", " STR ", " STR ", " STR ", " STR ")); err == nil { # # r := regexp . MustCompile (" STR ") # matches := r . FindSubmatch ( data ) # if len ( matches ) != 2 { # return " STR " + string ( data ) # } # # return string ( matches [ 1 ]), nil # # } else if data , err := ioutil . ReadFile ( filepath . Join ( goroot , " STR ")); err == nil { # return string ( data ), nil # # } else { # return "", err # }
fmt . Println ( arrangeCoins ( 5 )) # fmt . Println ( arrangeCoins ( 8 ))
if head == nil || head . Next == nil { # return head # } # # n 1 , n 2 := & ListNode {}, & ListNode {} # p 1 , p 2 := n 1 , n 2 # p := head # for p != nil { # if p . Val < x { # n 1 . Next = p # n 1 = n 1 . Next # } else { # n 2 . Next = p # n 2 = n 2 . Next # } # p , p . Next = p . Next , nil # } # n 1 . Next = p 2 . Next # return p 1 . Next
if head == nil || head . Next == nil { # return head # } # # m := findMiddle ( head ) # # r := sortList ( m . Next ) # m . Next = nil # l := sortList ( head ) # # return merge ( l , r )
qs := [] question 5 6 7 { # # { # para 5 6 7 {" STR ", " STR "}, # ans 5 6 7 { true }, # }, # # { # para 5 6 7 {" STR ", " STR "}, # ans 5 6 7 { true }, # }, # # { # para 5 6 7 {" STR ", " STR "}, # ans 5 6 7 { false }, # }, # # { # para 5 6 7 {" STR ", " STR "}, # ans 5 6 7 { true }, # }, # # { # para 5 6 7 {" STR ", " STR "}, # ans 5 6 7 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 6 7 , q . para 5 6 7 # fmt . Printf (" STR ", p , checkInclusion ( p . s , p . p )) # } # fmt . Printf (" STR ")
start , end := 0 , len ( nums )- 1 # for { # if start > end { # break # } # mid := ( start + end ) / 2 # if nums [ mid ] == target { # return true # } # if nums [ start ] < nums [ mid ] { # if target >= nums [ start ] && target < nums [ mid ] { # end = mid - 1 # } else { # start = mid + 1 # } # } else if nums [ mid ] < nums [ end ] { # if target > nums [ mid ] && target <= nums [ end ] { # start = mid + 1 # } else { # end = mid - 1 # } # } else if nums [ start ] == nums [ mid ] { # start ++ # } else { # end -- # } # } # return false
mux := http . NewServeMux () # mux . HandleFunc (" STR ", index ) # mux . HandleFunc (" STR ", welcome ) # mux . HandleFunc (" STR ", message ) # log . Println (" STR ") # server := & http . Server { # Addr : " STR ", # Handler : mux , # } # server . ListenAndServe ()
defer wg . Done () # for { # val , ok := <- count # if ! ok { # fmt . Println (" STR ") # return # } # fmt . Printf (" STR ", val , label ) # if val == 1 0 { # fmt . Printf (" STR ", label ) # close ( count ) # return # } # val ++ # count <- val # }
isLess := func ( str 1 , str 2 string , dict [] int ) bool { # for i := 0 ; i < len ( str 1 ) && i < len ( str 2 ); i ++ { # idx 1 := dict [ int ( str 1 [ i ]-' a ')] # idx 2 := dict [ int ( str 2 [ i ]-' a ')] # if idx 1 < idx 2 { # return true # } # # if idx 1 > idx 2 { # return false # } # } # # return len ( str 1 ) <= len ( str 2 ) # } # # dict := make ([] int , 2 6 ) # for i , b := range order { # dict [ int ( b -' a ')] = i # } # # for i := 0 ; i < len ( words )- 1 ; i ++ { # if ! isLess ( words [ i ], words [ i + 1 ], dict ) { # return false # } # } # # return true
qs := [] question 6 6 { # # { # para 6 6 {[] int { 1 , 2 , 3 }}, # ans 6 6 {[] int { 1 , 2 , 4 }}, # }, # # { # para 6 6 {[] int { 4 , 3 , 2 , 1 }}, # ans 6 6 {[] int { 4 , 3 , 2 , 2 }}, # }, # # { # para 6 6 {[] int { 9 , 9 }}, # ans 6 6 {[] int { 1 , 0 , 0 }}, # }, # # { # para 6 6 {[] int { 0 }}, # ans 6 6 {[] int { 0 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 6 , q . para 6 6 # fmt . Printf (" STR ", p , plusOne ( p . one )) # } # fmt . Printf (" STR ")
var tail , next * ListNode # for head != nil && head . Next != nil { # next = head . Next # head . Next = tail # tail = head # head = next # } # if head != nil { # head . Next = tail # } # return head
result := " STR " # for i := 2 ; i <= n ; i ++ { # temp := " STR " # for j := 0 ; j < len ( result ); { # k := j # for k < len ( result ) && result [ k ] == result [ j ] { # k ++ # } # # temp = fmt . Sprintf (" STR ", temp , k - j , result [ j ]) # j = k # } # # result = temp # } # # return result
mod := 1 0 0 0 0 0 0 0 0 7 # sort . Ints ( A ) # dp := make ( map [ int ] int ) # for i := 0 ; i < len ( A ); i ++ { # dp [ A [ i ]] = 1 # for j := 0 ; j < i ; j ++ { # if A [ i ]% A [ j ] == 0 { # if _ , ok := dp [ A [ i ]/ A [ j ]]; ok { # dp [ A [ i ]] += ( dp [ A [ j ]] * dp [ A [ i ]/ A [ j ]]) % mod # } # } # } # } # ans := 0 # for _ , v := range dp { # ans += v # } # return ans % mod
cases := [] struct { # name string # queries , words [] string # expect [] int # }{ # {" STR ", [] string {" STR "}, [] string {" STR "}, [] int { 1 }}, # {" STR ", [] string {" STR ", " STR "}, [] string {" STR ", " STR ", " STR ", " STR "}, [] int { 1 , 2 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . queries , c . words ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . queries , c . words ) # } # }) # }
digitsMap := make ( map [ rune ] struct {}) # if len ( number ) != 9 { # return false # } # for _ , digit := range number { # _ , found := digitsMap [ digit ] # if found || digit == ' 0 ' { # return false # } # digitsMap [ digit ] = struct {}{} # } # return true
if x < 0 || x == len ( grid [ 0 ]) || # y < 0 || y == len ( grid ) || # grid [ y ][ x ] == - 1 { # return 0 # } # if grid [ y ][ x ] == 2 { # if n == 0 { # return 1 # } else { # return 0 # } # } # # grid [ y ][ x ] = - 1 # # path := dfs ( grid , x + 1 , y , n - 1 ) + # dfs ( grid , x - 1 , y , n - 1 ) + # dfs ( grid , x , y + 1 , n - 1 ) + # dfs ( grid , x , y - 1 , n - 1 ) # # grid [ y ][ x ] = 0 # # return path
var divisors [] int # for i := 1 ; i < 1 0 0 0 ; i += 1 { # if i % 3 == 0 || i % 5 == 0 { # divisors = append ( divisors , i ) # } # } # # sum := 0 # for i := 0 ; i < len ( divisors ); i += 1 { # sum += divisors [ i ] # } # # fmt . Println (" STR ", sum )
for i := 0 ; i < len ( divs ); i += 1 { # if x % divs [ i ] == 0 { # return false # } # } # return true
low , high := 1 , num # for low <= high { # mid := low + ( high - low )>> 1 # if mid * mid == num { # return true # } else if mid * mid < num { # low = mid + 1 # } else { # high = mid - 1 # } # } # return false
sort . Ints ( candidates ) # var helper func ( candidate , share [] int , target int ) # var r [][] int # helper = func ( c , share [] int , target int ) { # if target == 0 { # r = append ( r , share ) # return # } # if len ( c ) == 0 || target < c [ 0 ] { # return # } # share = share [: len ( share ): len ( share )] # # helper ( c , append ( share , c [ 0 ]), target - c [ 0 ]) # helper ( c [ 1 :], share , target ) # } # helper ( candidates , [] int {}, target ) # return r
left := 0 # right := len ( arr ) - 1 # for left <= right { # mid := left + (( right - left ) >> 1 ) # if arr [ mid ] > target { # right = mid - 1 # } else if arr [ mid ] < target { # left = mid + 1 # } else { # if ( mid == 0 ) || arr [ mid - 1 ] != target { # return arr [ mid ], mid # } else { # right = mid - 1 # } # } # } # return val , - 1
index := 0 # return GenTreeHelp ( x , & index )
t . Parallel () # for tcid , tc := range testcases { # copied := cloneLL ( tc . input ) # if result := RotateRightLL ( copied , tc . k ); ! equal ( tc . expected , result ) { # t . Errorf (" STR ", tcid ) # } # }
qs := [] question 4 7 { # # { # para 4 7 {[] int { 1 , 1 , 2 }}, # ans 4 7 {[][] int {{ 1 , 1 , 2 }, { 1 , 2 , 1 }, { 2 , 1 , 1 }}}, # }, # # { # para 4 7 {[] int { 1 , 2 , 2 }}, # ans 4 7 {[][] int {{ 1 , 2 , 2 }, { 2 , 2 , 1 }, { 2 , 1 , 2 }}}, # }, # # { # para 4 7 {[] int { 2 , 2 , 2 }}, # ans 4 7 {[][] int {{ 2 , 2 , 2 }}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 7 , q . para 4 7 # fmt . Printf (" STR ", p , permuteUnique ( p . s )) # } # fmt . Printf (" STR ")
t . Parallel () # # for _ , tc := range testcases { # if numDigits := NumberOfDigits ( tc . n ); numDigits != tc . numDigits { # t . Errorf (" STR ", tc . n , tc . numDigits , numDigits ) # } # }
runes := [] rune ( str ) # i , j := 0 , len ( runes )- 1 # for i < j { # temp := runes [ i ] # runes [ i ] = runes [ j ] # runes [ j ] = temp # i ++ # j -- # } # return string ( runes )
if len ( loc ) == 0 { # return nil # } else if len ( loc ) == 1 { # return [] int { 1 } # } # # bonuses := make ([] int , 0 , len ( loc )) # segs := segments ( loc ) # # for _ , seg := range segs { # asc , run := seg . ascending , seg . run # segBonuses := make ([] int , run ) # # for i := range segBonuses { # segBonuses [ i ] = i # } # # if ! asc { # for i := 0 ; i < len ( segBonuses )/ 2 ; i ++ { # segBonuses [ i ], segBonuses [ len ( segBonuses )- 1 - i ] = segBonuses [ len ( segBonuses )- 1 - i ], segBonuses [ i ] # } # } # # bonuses = append ( bonuses , segBonuses ...) # } # # for i := range bonuses { # bonuses [ i ]++ # } # # return bonuses
rec := [ 6 0 ] int {} # for _ , t := range time { # rec [ t % 6 0 ]++ # } # # res := rec [ 0 ] * ( rec [ 0 ] - 1 ) / 2 # res += rec [ 3 0 ] * ( rec [ 3 0 ] - 1 ) / 2 # for i := 1 ; i < 3 0 ; i ++ { # res += rec [ i ] * rec [ 6 0 - i ] # } # # return res
n := len ( A [ 0 ]) # m := map [[ 2 6 ] int ] struct {}{} # for _ , a := range A { # count := [ 2 6 ] int {} # i := 0 # for ; i + 1 < n ; i += 2 { # count [ a [ i ]-' a ']++ # count [ a [ i + 1 ]-' a '] += 2 1 # } # if i < n { # count [ a [ i ]-' a ']++ # } # m [ count ] = struct {}{} # } # return len ( m )
tests := [...] testType { # { # n : 3 , # paths : [][] int { # { 1 , 2 }, # { 2 , 3 }, # { 3 , 1 }, # }, # want : [] int { 1 , 2 , 3 }, # }, # { # n : 4 , # paths : [][] int { # { 1 , 2 }, # { 3 , 4 }, # }, # want : [] int { 1 , 2 , 1 , 2 }, # }, # { # n : 4 , # paths : [][] int { # { 1 , 2 }, # { 2 , 3 }, # { 3 , 4 }, # { 4 , 1 }, # { 1 , 3 }, # { 2 , 4 }, # }, # want : [] int { 1 , 2 , 3 , 4 }, # }, # } # for _ , tt := range tests { # got := gardenNoAdj ( tt . n , tt . paths ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . n , got , tt . want ) # } # }
var vals [] int # # var f func (* TreeNode ) int # f = func ( root * TreeNode ) int { # if root == nil { # return - 1 # } # if root == target { # vals = down ( vals , K , root ) # return 0 # } # # var d int # var to * TreeNode # # if d = f ( root . Left ); d != - 1 { # to = root . Right # } else if d = f ( root . Right ); d != - 1 { # to = root . Left # } else { # return - 1 # } # # if d + 1 == K { # vals = append ( vals , root . Val ) # } else if d + 1 < K { # vals = down ( vals , K - d - 2 , to ) # } # # return d + 1 # } # f ( root ) # # return vals
st := & SegmentTree 7 3 2 { # start : 0 , # end : 1 e 9 , # } # return MyCalendarThree { # st : st , # }
from := [] int { # 1 0 0 0 , 9 0 0 , 5 0 0 , 4 0 0 , 1 0 0 , 9 0 , 5 0 , 4 0 , 1 0 , 9 , 5 , 4 , 1 , # } # to := [] string { # " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", # } # var s [] byte # for k , v := range from { # if num < v { # continue # } # i := num / v # num %= v # for j := 0 ; j < i ; j ++ { # s = append ( s , [] byte ( to [ k ])...) # } # } # return string ( s )
return item . next
res := [] string {} # n := len ( S ) # var recur func ( string , int ) # recur = func ( cur string , i int ) { # if i == n { # res = append ( res , cur ) # return # } # if ' 0 ' <= S [ i ] && S [ i ] <= ' 9 ' { # recur ( cur + S [ i : i + 1 ], i + 1 ) # } else { # recur ( cur + strings . ToLower ( S [ i : i + 1 ]), i + 1 ) # recur ( cur + strings . ToUpper ( S [ i : i + 1 ]), i + 1 ) # } # } # recur (" STR ", 0 ) # return res
m , n := len ( grid ), len ( grid [ 0 ]) # # zeros := collectZero ( grid ) # if len ( zeros ) <= 1 { # return m * n # } # # colors := addColor ( grid ) # # res := 0 # # for _ , z := range zeros { # i , j := z [ 0 ], z [ 1 ] # isConnected := make ([] bool , len ( colors )) # temp := 1 # for k := 0 ; k < 4 ; k ++ { # x := i + dx [ k ] # y := j + dy [ k ] # if 0 <= x && x < m && # 0 <= y && y < n && # grid [ x ][ y ] > 1 && ! isConnected [ grid [ x ][ y ]] { # temp += colors [ grid [ x ][ y ]] # isConnected [ grid [ x ][ y ]] = true # } # } # res = max ( res , temp ) # } # # return res
resp , err := http . Get ( url ) # if err != nil { # return nil , err # } # defer resp . Body . Close () # return ioutil . ReadAll ( resp . Body )
l . item = token { k , l . input [ l . start : l . pos ]} # l . start = l . pos
return & Singly {}
err := read ( r , hSize , nil ) # if err != nil { # return err # } # # return seek ( r , 0 , io . SeekStart , 0 )
curLength , maxLength := 0 , 0 # position := make ([] int , 2 6 ) # for i := 0 ; i < 2 6 ; i ++ { # position [ i ] = - 1 # } # # for i := 0 ; i < len ( str ); i ++ { # preIndex := position [ str [ i ]-' a '] # if 0 > preIndex || i - preIndex > curLength { # curLength ++ # } else { # if curLength > maxLength { # maxLength = curLength # } # curLength = i - preIndex # } # position [ str [ i ]-' a '] = i # if curLength > maxLength { # maxLength = curLength # } # } # return maxLength
var nums [] int # nums = dfs (& nums , root ) # return nums [ k - 1 ]
return f . field . PkgPath == ""
cases := [] struct { # name string # distance [] int # start int # destination int # expect int # }{ # {" STR ", [] int { 1 , 2 , 3 , 4 }, 0 , 1 , 1 }, # {" STR ", [] int { 1 , 2 , 3 , 4 }, 0 , 2 , 3 }, # {" STR ", [] int { 1 , 2 , 3 , 4 }, 0 , 3 , 4 }, # {" STR ", [] int { 1 , 2 , 3 , 4 }, 1 , 4 , 1 }, # {" STR ", [] int { 1 , 2 , 3 , 4 }, 3 , 2 , 3 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . distance , c . start , c . destination ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . distance , c . start , c . destination ) # } # }) # }
tests := [] string { # " STR ", # " STR ", # " STR ", # } # rows := [] int { # 1 , # 3 , # 3 , # } # results := [] string { # " STR ", # " STR ", # " STR ", # } # caseNum := 3 # for i := 0 ; i < caseNum ; i ++ { # if ret := convert ( tests [ i ], rows [ i ]); ret != results [ i ] { # t . Fatalf (" STR ", i , ret , results [ i ]) # } # }
var termios syscall . Termios # _ , _ , err := syscall . Syscall 6 ( syscall . SYS_IOCTL , fd , ioctlReadTermios , uintptr ( unsafe . Pointer (& termios )), 0 , 0 , 0 ) # return err == 0
t . Parallel () # # for n , tc := range testcases { # gol := NewGameOfLife ( tc . board ) # # for i := 0 ; i < tc . steps ; i ++ { # gol . Step () # } # # if result := gol . String (); result != tc . expected { # t . Errorf (" STR ", n , tc . expected , result ) # } # }
if m > n { # m , n = n , m # } # l , r := 1 , m * n # for l < r { # mid := ( l + r ) / 2 # c := count ( mid , m , n ) # if c >= k { # r = mid # } else { # l = mid + 1 # } # } # return r
if s 1 == s 2 { # return true # } # # n := len ( s 1 ) # count := make ([] int , 2 6 ) # for i := 0 ; i < n ; i ++ { # count [ s 1 [ i ]-' a ']++ # count [ s 2 [ i ]-' a ']-- # } # # for _ , c := range count { # if c != 0 { # return false # } # } # # for i := 1 ; i < n ; i ++ { # if isScramble ( s 1 [ 0 : i ], s 2 [ 0 : i ]) && isScramble ( s 1 [ i :], s 2 [ i :]) { # return true # } # # if isScramble ( s 1 [ 0 : i ], s 2 [ n - i :]) && isScramble ( s 1 [ i :], s 2 [ 0 : n - i ]) { # return true # } # } # return false
for i := range arr { # for j := i ; j < len ( arr ); j ++ { # if arr [ i ] > arr [ j ] { # arr [ i ], arr [ j ] = arr [ j ], arr [ i ] # } # } # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int {- 2 , 1 , - 3 , 4 , - 1 , 2 , 1 , - 5 , 4 }, 6 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := maxSubArray 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
size := len ( stickers ) # # ss := make ([][] int , size ) # for i := range ss { # ss [ i ] = make ([] int , 2 6 ) # for _ , c := range stickers [ i ] { # ss [ i ][ c -' a ']++ # } # } # # dp := make ( map [ string ] int , size ) # dp [" STR "] = 0 # # helper ( dp , ss , target ) # # return dp [ target ]
res , _ := dfs ( root , 0 ) # return res
var total int # runes := [] rune ( s ) # for _ , token := range runes { # value := int ( token -' A ') + 1 # total += value # } # return total
for i := 0 ; i < len ( arr ); i ++ { # for j := 0 ; j < len ( arr )- 1 - i ; j ++ { # if arr [ j ] > arr [ j + 1 ] { # arr [ j ], arr [ j + 1 ] = arr [ j + 1 ], arr [ j ] # } # } # }
cases := [] struct { # name string # inputs [][] int # expect bool # }{ # {" STR ", [][] int {{ 1 , 2 , 3 , 4 }, { 5 , 1 , 2 , 3 }, { 9 , 5 , 1 , 2 }}, true }, # {" STR ", [][] int {{ 1 , 2 }, { 2 , 2 }}, false }, # {" STR ", [][] int {{ 1 , 2 , 3 }, { 4 , 1 , 2 }, { 5 , 4 , 1 }}, true }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
f := & forest { # f : make ( map [ int ] int ), # } # for _ , stone := range stones { # f . union ( stone [ 0 ], ^ stone [ 1 ]) # } # return len ( stones ) - f . islands
return MyCircularDeque { # cap : k , # }
intMap := make ( map [ int ] int ) # for i := range nums { # k := nums [ i ] # _ , has := intMap [ k ] # if has { # intMap [ k ]++ # continue # } # intMap [ k ] = 1 # } # # h := new ( intHeap ) # for i := range intMap { # heap . Push ( h , entity { num : intMap [ i ], value : i }) # } # # result := make ([] int , 0 , k ) # for i := 0 ; i < k ; i ++ { # result = append ( result , heap . Pop ( h ).( entity ). value ) # } # return result
ret := 0 # for i := 0 ; i < len ( nums ); i ++ { # ret ^= nums [ i ] # } # return ret
return Solution { # r : radius , # x : x_center , # y : y_center , # }
return len ( b . avail ) == 0
for _ , v := range args { # if maxVal < v { # maxVal = v # } # } # return maxVal
if e . list == l { # e . l . r = e . r # e . r . l = e . l # e . r = nil # e . l = nil # e . list = nil # e . p = nil # l . len -- # }
tests := [...] testType { # { # in : 1 , # want : 1 , # }, # { # in : 2 , # want : 2 , # }, # { # in : 3 , # want : 3 , # }, # } # for _ , tt := range tests { # got := climbStairs ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
log . Printf (" STR ", args . A , args . B ) # * result = Result ( args . A * args . B ) # return nil
return & line { p 0 , p 1 , nil }
cases := [] struct { # name string # input 1 [] int # input 2 int # expect [] int # }{ # {" STR ", [] int { 1 , 1 , 1 , 2 , 2 , 3 }, 2 , [] int { 1 , 2 }}, # {" STR ", [] int { 1 }, 1 , [] int { 1 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := topKFrequent ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 , c . input 2 ) # } # }) # }
a := uint 3 2 ( 2 ) # # for i := 0 ; i < b . N ; i ++ { # slow_power ( a , 1 0 0 0 0 0 ) # }
t . Parallel () # # for _ , tc := range testcases { # if result := CountParensEqualTrue ( tc . input ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
if u . Kind () != Interface { # panic (" STR ") # } # return t . AssignableTo ( u )
data , err := ioutil . ReadFile ( SOURCE_SOLUTION_SUMMARY_FILE_PATH ) # if err != nil { # log . Panicln (" STR ", err . Error ()) # } # fmt . Println ( string ( data )) # return string ( data )
l , r := 0 , 5 *( K + 1 ) # for l <= r { # m := l + ( r - l )/ 2 # km := zeros ( m ) # if km < K { # l = m + 1 # } else if km > K { # r = m - 1 # } else { # return 5 # } # } # return 0
var ret string # var s string # # s = " STR " # ret = " STR " # if ret != reverseVowels ( s ) { # t . Fatalf (" STR ", ret ) # } #
if nil == strs || 0 >= len ( strs ) { # return " STR " # } # sort . Strings ( strs ) # # first := strs [ 0 ] # last := strs [ len ( strs )- 1 ] # var i , length int # if len ( first ) < len ( last ) { # length = len ( first ) # } else { # length = len ( last ) # } # # for i < length && first [ i ] == last [ i ] { # i ++ # } # return first [ 0 : i ]
var lw string # for _ , w := range d { # if len ( w ) < len ( lw ) || len ( w ) == len ( lw ) && w >= lw { # continue # } # var i int # for j := 0 ; i < len ( w ) && j < len ( s ); j ++ { # if s [ j ] == w [ i ] { # i ++ # } # } # if i == len ( w ) { # lw = w # } # } # return lw
var b BitMask # b . Add (" STR ") # b . Add (" STR ") # v , err := b . Parse (" STR ") # if err != nil { # log . Fatal ( err ) # } # fmt . Printf (" STR ", v ) # fmt . Printf (" STR ", b . IsSet ( v , " STR "), b . IsSet ( v , " STR "), b . IsSet ( v , " STR ")) # s , err := b . Format ( v ) # fmt . Println ( s )
if nil == nums || len ( nums ) < 2 { # return nil # } # # ans := make ([] int , 0 ) # for _ , v := range nums { # if 0 > nums [ myAbs ( v )- 1 ] { # ans = append ( ans , myAbs ( v )) # } else { # nums [ myAbs ( v )- 1 ] *= - 1 # } # } # for i := 0 ; i < len ( nums ); i ++ { # if nums [ i ] > 0 { # ans = append ( ans , i + 1 ) # } # } # return ans
xs , os := count ( board ) # # if isWin (' X ', board ) { # return xs == os + 1 && ! isWin (' O ', board ) # } # # if isWin (' O ', board ) { # return xs == os && ! isWin (' X ', board ) # } # # return xs == os + 1 || xs == os
qs := [] question 3 5 { # # { # para 3 5 {[] int { 1 , 3 , 5 , 6 }, 5 }, # ans 3 5 { 2 }, # }, # # { # para 3 5 {[] int { 1 , 3 , 5 , 6 }, 2 }, # ans 3 5 { 1 }, # }, # # { # para 3 5 {[] int { 1 , 3 , 5 , 6 }, 7 }, # ans 3 5 { 4 }, # }, # # { # para 3 5 {[] int { 1 , 3 , 5 , 6 }, 0 }, # ans 3 5 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 5 , q . para 3 5 # fmt . Printf (" STR ", p , searchInsert ( p . nums , p . target )) # } # fmt . Printf (" STR ")
matrix := make ([][] int , m ) # for i := range matrix { # matrix [ i ] = make ([] int , n ) # } # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # if i == 0 || j == 0 { # matrix [ i ][ j ] = 1 # } else { # matrix [ i ][ j ] = matrix [ i - 1 ][ j ] + matrix [ i ][ j - 1 ] # } # } # } # return matrix [ m - 1 ][ n - 1 ]
fmt . Println ( threeSum ([] int {- 1 , 0 , 1 , 2 , - 1 , - 4 })) # fmt . Println ( badTwoSum ([] int {- 1 , 0 , 1 , 2 , - 1 , - 4 })) # fmt . Println ( threeSum ([] int {- 2 , 0 , 0 , 2 , 2 }))
cases := [] struct { # name string # inputs [][] int # expect [] int # }{ # {" STR ", [][] int {{ 3 , 7 , 8 }, { 9 , 1 1 , 1 3 }, { 1 5 , 1 6 , 1 7 }}, [] int { 1 5 }}, # {" STR ", [][] int {{ 1 , 1 0 , 4 , 2 }, { 9 , 3 , 8 , 7 }, { 1 5 , 1 6 , 1 7 , 1 2 }}, [] int { 1 2 }}, # {" STR ", [][] int {{ 7 , 8 }, { 1 , 2 }}, [] int { 7 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if root == nil { # return nil # } # root . Left , root . Right = root . Right , root . Left # invertTree ( root . Right ) # invertTree ( root . Left ) # return root
dict := make ( map [ string ] bool ) # return dfs ( s , wordDict , dict )
t . Parallel () # for _ , tc := range testcases { # if result := CountPathsBrute ( tc . m , tc . n ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
if begin > end { # return []* TreeNode { nil } # } # if begin == end { # return []* TreeNode {{ Val : begin }} # } # var trees []* TreeNode # for i := begin ; i <= end ; i ++ { # left := generate ( begin , i - 1 ) # right := generate ( i + 1 , end ) # for _ , j := range left { # for _ , k := range right { # root := & TreeNode { Val : i , Left : j , Right : k } # trees = append ( trees , root ) # } # } # } # return trees
sort . Slice ( intervals , func ( i , j int ) bool { # if intervals [ i ][ 1 ] == intervals [ j ][ 1 ] { # return intervals [ i ][ 0 ] > intervals [ j ][ 0 ] # } # return intervals [ i ][ 1 ] < intervals [ j ][ 1 ] # }) # # res := 0 # left := intervals [ 0 ][ 1 ] - 1 # right := intervals [ 0 ][ 1 ] # res += 2 # # n := len ( intervals ) # # for i := 1 ; i < n ; i ++ { # a , b := intervals [ i ][ 0 ], intervals [ i ][ 1 ] # if left < a && a <= right { # res ++ # left = right # right = b # } else if right < a { # res += 2 # left = b - 1 # right = b # } # } # # return res
ans := " STR " # s := strings . Split ( S , " STR ") # for i , word := range s { # switch word [ 0 ] { # case ' a ', ' e ', ' i ', ' o ', ' u ', ' A ', ' E ', ' I ', ' O ', ' U ': # ans += " STR " + word + " STR " # default : # ans += " STR " + word [ 1 :] + word [ 0 : 1 ] + " STR " # } # ans += strings . Repeat (" STR ", i + 1 ) # } # return ans [ 1 :]
if nil == nums || len ( nums ) <= 0 { # return false # } # if len ( nums ) == 1 { # return true # } # # count := 0 # for i := 1 ; i < len ( nums ) && count <= 1 ; i ++ { # if nums [ i - 1 ] > nums [ i ] { # count ++ # if i - 2 < 0 || nums [ i - 2 ] <= nums [ i ] { # nums [ i - 1 ] = nums [ i ] # } else { # nums [ i ] = nums [ i - 1 ] # } # } # } # # return count <= 1
for i := 0 ; i < 3 ; i ++ { # x , o := 0 , 0 # for j := 0 ; j < 3 ; j ++ { # if moves [ j ][ i ] == " STR " { # x ++ # } else if moves [ j ][ i ] == " STR " { # o ++ # } # } # if x == 3 { # return " STR " # } else if o == 3 { # return " STR " # } # } # return " STR "
if ans , ok := triMem [[ 3 ] int { i , j , depth }]; ok { # return ans # } # # if depth == 1 { # return int 6 4 ( tri ( i , j )) # } # # ans := triangle ( i , j , depth - 1 ) + row ( i + depth - 1 , j , depth ) # # triMem [[ 3 ] int { i , j , depth }] = ans # # return ans
nBinaryStr := strconv . FormatInt ( int 6 4 ( N ), 2 ) # maxGap := 0 # currentGap := 0 # for i := 1 ; i < len ( nBinaryStr ); i ++ { # currentGap ++ # if nBinaryStr [ i ] == ' 0 ' { # continue # } # # if nBinaryStr [ i ] == ' 1 ' { # if currentGap > maxGap { # maxGap = currentGap # } # currentGap = 0 # } # } # # return maxGap
TemplateBenchmarkGCD ( b , Recursive )
ip := ps . Ip # port := ps . Port # s 5 port := ps . S 5 Port # listen , err := net . ListenTCP (" STR ", & net . TCPAddr { net . ParseIP ( ip ), port , " STR "}) # if err != nil { # panic ( err ) # } # defer listen . Close () # fmt . Println (" STR ", port ) # s 5 listen , err := net . ListenTCP (" STR ", & net . TCPAddr { net . ParseIP ( ip ), s 5 port , " STR "}) # if err != nil { # panic ( err ) # } # defer s 5 listen . Close () # fmt . Println (" STR ", s 5 port ) # ps . server ( listen , s 5 listen )
return f . value . Interface ()
if item . Expiration == 0 { # return false # } # return time . Now (). UnixNano () > item . Expiration
swap := func ( nums [] int , i , j int ) { # nums [ i ], nums [ j ] = nums [ j ], nums [ i ] # } # # start , end := 0 , len ( nums )- 1 # for i := start ; i <= end ; { # switch nums [ i ] { # case 0 : # if start < i { # swap ( nums , i , start ) # } # start ++ # i ++ # case 1 : # i ++ # case 2 : # if nums [ end ] < 2 { # swap ( nums , i , end ) # } # end -- # } # }
gap := 0 # res := 0 # for N > 0 { # if N & 1 == 1 { # if gap > res { # res = gap # } # gap = 1 # } else if gap > 0 { # gap ++ # } # N >>= 1 # } # return res
sort . Ints ( nums ) # length := len ( nums ) - 2 # end := len ( nums ) - 1 # var closest , distance , d int # for i := 0 ; i < length ; i ++ { # if i > 0 && nums [ i - 1 ] == nums [ i ] { # continue # } # left , right := i + 1 , end # for left < right { # sum := nums [ i ] + nums [ left ] + nums [ right ] # if sum < target { # d = target - sum # left ++ # } else if sum > target { # d = sum - target # right -- # } else { # return sum # } # if d < distance || distance == 0 { # closest = sum # distance = d # } # } # } # return closest
t . Parallel () # for _ , tc := range testcases { # if result := UniqueClimbs ( tc . steps , tc . strides ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
n := len ( nums ) # s := math . MinInt 3 2 # stack := [] int {} # for i := n - 1 ; i >= 0 ; i -- { # if nums [ i ] < s { # return true # } # for len ( stack ) != 0 && nums [ i ] > stack [ len ( stack )- 1 ] { # s = stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # } # stack = append ( stack , nums [ i ]) # } # return false
sortStr := func ( str string ) string { # var odd , even [] byte # for i , b := range str { # if i % 2 == 0 { # even = append ( even , byte ( b )) # } else { # odd = append ( odd , byte ( b )) # } # } # # sort . Slice ( odd , func ( i , j int ) bool { return odd [ i ] < odd [ j ] }) # sort . Slice ( even , func ( i , j int ) bool { return even [ i ] < even [ j ] }) # return string ( even ) + string ( odd ) # } # # allSorted := make ( map [ string ] bool ) # for _ , str := range A { # sorted := sortStr ( str ) # allSorted [ sorted ] = true # } # # return len ( allSorted )
end := 1 0 0 . # # var sum 1 , sum 2 uint 6 4 = 0 ., 0 . # for i := 0 .; i <= end ; i += 1 . { # sum 1 += uint 6 4 ( i * i ) # sum 2 += uint 6 4 ( i ) # } # # fmt . Println (" STR ", ( sum 2 * sum 2 - sum 1 ))
fmt . Println ( isToeplitzMatrix ([][] int { # # { 3 6 , 5 9 , 7 1 , 1 5 , 2 6 , 8 2 , 8 7 }, # { 5 6 , 3 6 , 5 9 , 7 1 , 1 5 , 2 6 , 8 2 }, # { 1 5 , 0 , 3 6 , 5 9 , 7 1 , 1 5 , 2 6 }, # }))
if n != nil { # inorderCopy ( n . left , array , index ) # array [* index ] = n . val # * index ++ # inorderCopy ( n . right , array , index ) # }
b . bag = append ( b . bag , i ) # b . index ++
type link struct { # value string # tail * link # } # a , b , c := & link { value : " STR "}, & link { value : " STR "}, & link { value : " STR "} # a . tail , b . tail , c . tail = b , a , c # fmt . Println ( Equal ( a , a )) # fmt . Println ( Equal ( b , b )) # fmt . Println ( Equal ( c , c )) # fmt . Println ( Equal ( a , b )) # fmt . Println ( Equal ( a , c )) #
if root == nil { # return [] int {} # } # # if root . Left == nil && root . Right == nil { # return [] int { root . Val } # } # # left := preorderTraversal ( root . Left ) # right := preorderTraversal ( root . Right ) # # res := [] int { root . Val } # res = append ( res , left ...) # res = append ( res , right ...) # return res
return performSum ( root , false )
n := len ( s ) # f := make ([] int , n + 1 ) # f [ 0 ] = 1 # for i := 1 ; i <= n ; i ++ { # if s [ i - 1 ] != ' 0 ' { # f [ i ] += f [ i - 1 ] # } # if i >= 2 { # t := ( s [ i - 2 ]-' 0 ')* 1 0 + s [ i - 1 ] - ' 0 ' # if t >= 1 0 && t <= 2 6 { # f [ i ] += f [ i - 2 ] # } # } # } # return f [ n ]
if p == nil && q == nil { # return true # } else if p == nil || q == nil { # return false # } # # if p . Val == q . Val { # return isSameTree ( p . Left , q . Left ) && # isSameTree ( p . Right , q . Right ) # } # # return false
var tests = [] struct { # tree * TreeNode # target int # exist bool # }{ # { newTree ( 5 , 3 , 6 , 2 , 4 , nil , 7 ), 9 , true }, # { newTree ( 5 , 3 , 6 , 2 , 4 , nil , 7 ), 4 , false }, # { newTree ( 5 , 3 ), 8 , true }, # { nil , 2 , false }, # } # # for _ , tt := range tests { # exist := findTarget ( tt . tree , tt . target ) # if exist != tt . exist { # t . Errorf (" STR ", tt . tree , tt . target , exist , tt . exist ) # } # }
res := make ([] int , 0 , max ) # # var dfs func ( int ) # dfs = func ( x int ) { # limit := ( x + 1 0 ) / 1 0 * 1 0 # for x <= max && x < limit { # res = append ( res , x ) # if x * 1 0 <= max { # dfs ( x * 1 0 ) # } # x ++ # } # } # # dfs ( 1 ) # return res
var T = struct { # A string # B int # C bool ` structs :" STR "` # D [] string # }{} # # ok := IsZero ( T ) # if ! ok { # t . Error (" STR ") # } # # var X = struct { # A string # F * bool # }{ # A : " STR ", # } # # ok = IsZero ( X ) # if ok { # t . Error (" STR ") # } # # var Y = struct { # A string # B int # }{ # A : " STR ", # B : 1 2 3 , # } # # ok = IsZero ( Y ) # if ok { # t . Error (" STR ") # }
sum := 0 # sort . Ints ( nums ) # for i , v := range nums { # if i & 1 == 0 { # sum += v # } # } # return sum
m . cache [ m . bucketNo ( key )]. SetNow ( key , value , expire , now )
sort . Ints ( candidates ) # var r [][] int # var helper func ( c , share [] int , t int ) # helper = func ( newCandidates , share [] int , newTarget int ) { # if newTarget == 0 { # r = append ( r , share ) # return # } # if len ( newCandidates ) == 0 || newTarget < newCandidates [ 0 ] { # return # } # share = share [: len ( share ): len ( share )] # helper ( newCandidates [ 1 :], append ( share , newCandidates [ 0 ]), newTarget - newCandidates [ 0 ]) # var i int # for k := range newCandidates { # if newCandidates [ k ] != newCandidates [ 0 ] { # i = k # break # } else { # i ++ # } # } # newCandidates = newCandidates [ i :] # helper ( newCandidates , share , newTarget ) # } # helper ( candidates , [] int {}, target ) # return r
if len ( s ) == 0 { # return "" # } # # start , end := 0 , 0 # for i := 0 ; i < len ( s ); i ++ { # len 1 := expandAroundCenter ( s , i , i ) # len 2 := expandAroundCenter ( s , i , i + 1 ) # len := Max ( len 1 , len 2 ) # # if len > end - start { # # start = i - ( len - 1 )/ 2 # end = i + len / 2 # } # } # # return s [ start : end + 1 ]
qs := [] question 4 5 1 { # { # para 4 5 1 {" STR "}, # ans 4 5 1 {" STR "}, # }, # # { # para 4 5 1 {" STR "}, # ans 4 5 1 {" STR "}, # }, # # { # para 4 5 1 {" STR "}, # ans 4 5 1 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 5 1 , q . para 4 5 1 # fmt . Printf (" STR ", p , frequencySort ( p . one )) # } # fmt . Printf (" STR ")
cmap := newOpenHashMap () # testHashMapResize ( t , cmap ) # if ! reflect . DeepEqual ( cmap . Cap , uint 3 2 ( 1 6 )) { # t . Log ( fmt . Sprintf (" STR ", uint 3 2 ( 1 6 )) + fmt . Sprintf (" STR ", cmap . Cap )) # t . Fail () # }
if len ( arr ) <= 1 { # return arr # } # # median := arr [ rand . Intn ( len ( arr ))] # # low_part := make ([] int , 0 , len ( arr )) # high_part := make ([] int , 0 , len ( arr )) # middle_part := make ([] int , 0 , len ( arr )) # # for _ , item := range arr { # switch { # case item < median : # low_part = append ( low_part , item ) # case item == median : # middle_part = append ( middle_part , item ) # case item > median : # high_part = append ( high_part , item ) # } # } # # low_part = QuickSort ( low_part ) # high_part = QuickSort ( high_part ) # # low_part = append ( low_part , middle_part ...) # low_part = append ( low_part , high_part ...) # # return low_part
n := len ( tickets ) # nexts := make ( map [ string ][] string , n + 1 ) # for _ , t := range tickets { # nexts [ t [ 0 ]] = append ( nexts [ t [ 0 ]], t [ 1 ]) # } # # for k := range nexts { # sort . Strings ( nexts [ k ]) # } # # res := make ([] string , 0 , n + 1 ) # # var visit func ( string ) # visit = func ( airport string ) { # for len ( nexts [ airport ]) != 0 { # next := nexts [ airport ][ 0 ] # nexts [ airport ] = nexts [ airport ][ 1 :] # visit ( next ) # } # res = append ( res , airport ) # } # # visit (" STR ") # i , j := 0 , len ( res )- 1 # for i < j { # res [ i ], res [ j ] = res [ j ], res [ i ] # i ++ # j -- # } # return res
fmt . Println ( totalFruit ([] int { 1 })) # fmt . Println ( totalFruit ([] int { 1 , 2 , 1 })) # fmt . Println ( totalFruit ([] int { 0 , 1 , 2 , 2 })) # fmt . Println ( totalFruit ([] int { 1 , 2 , 3 , 2 , 2 })) # fmt . Println ( totalFruit ([] int { 3 , 3 , 3 , 1 , 2 , 1 , 1 , 2 , 3 , 3 , 4 }))
if p == nil && q == nil { # return true # } # # if p == nil || q == nil { # return false # } # # return p . Val == q . Val && # isSameTree ( p . Left , q . Left ) && # isSameTree ( p . Right , q . Right )
var s struct {} # fmt . Println ( unsafe . Sizeof ( s )) # var x [ 1 0 0 0 0 0 ] struct {} # fmt . Println ( unsafe . Sizeof ( x )) # # m := make ( map [ string ] struct {}) # m [" STR "] = struct {}{} # # if _ , ok := m [" STR "]; ok { # fmt . Println (" STR ") # } else { # fmt . Println (" STR ") # } # # for i := range N ( 5 ) { # fmt . Println ( i ) # } #
return list . last
remainder := 1 # i := 1 # for ; remainder != 0 ; i ++ { # remainder *= 1 0 # remainder ++ # remainder %= n # } # return i
var shift uint 8 # for { # b , err := r . ReadByte () # if err != nil { # return 0 , err # } # result |= uint 6 4 ( b & 0 x 7 f ) << shift # if b & 0 x 8 0 == 0 { # break # } # shift += 7 # } # return
qs := [] question 3 4 { # # { # para 3 4 {[] int { 5 , 7 , 7 , 8 , 8 , 1 0 }, 8 }, # ans 3 4 {[] int { 3 , 4 }}, # }, # # { # para 3 4 {[] int { 5 , 7 , 7 , 8 , 8 , 1 0 }, 6 }, # ans 3 4 {[] int {- 1 , - 1 }}, # }, # } # # fmt . Printf (" STR ") # for _ , q := range qs { # _ , p := q . ans 3 4 , q . para 3 4 # fmt . Printf (" STR ", p , searchRange ( p . nums , p . target )) # } # fmt . Printf (" STR ")
n := len ( prices ) # if n == 0 { # return 0 # } # # buy := make ([] int , n + 1 ) # buy [ 1 ] = 0 - prices [ 0 ] # sel := make ([] int , n + 1 ) # # for i := 2 ; i <= n ; i ++ { # buy [ i ] = max ( buy [ i - 1 ], sel [ i - 2 ]- prices [ i - 1 ]) # sel [ i ] = max ( sel [ i - 1 ], buy [ i - 1 ]+ prices [ i - 1 ]) # } # # return sel [ n ]
var target int # var nums [] int # var ret [] int # # nums = [] int { 2 , 7 , 1 1 , 1 5 } # target = 9 # ret = [] int { 1 , 2 } # # for k , v := range twoSum ( nums , target ) { # if v != ret [ k ] { # t . Fatalf (" STR ", ret ) # } # } # # nums = [] int { 2 , 7 , 1 1 , 1 5 } # target = 1 3 # ret = [] int { 1 , 3 } # # for k , v := range twoSum ( nums , target ) { # if v != ret [ k ] { # t . Fatalf (" STR ", ret ) # } # }
return LRUCache { # capacity : capacity , # list : list . New (), # cache : make ( map [ int ]* list . Element ), # }
cases := [] struct { # name string # input 1 * ListNode # input 2 int # expect []* ListNode # }{ # {" STR ", MakeListNode ([] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 0 }), 3 , # []* ListNode { MakeListNode ([] int { 1 , 2 , 3 , 4 }), MakeListNode ([] int { 5 , 6 , 7 }), MakeListNode ([] int { 8 , 9 , 1 0 })}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 , c . input 2 ) # } # }) # }
println (" STR ", someGlobal )
if root == nil { # return # } # fmt . Println ( level , root . Val ) # dfs ( root . Left , level + 1 , m ) # m [ level ] += root . Val # dfs ( root . Right , level + 1 , m )
var total , sum , diff , start int # for i := range gas { # diff = gas [ i ] - cost [ i ] # total += diff # if sum < 0 { # sum = diff # start = i # } else { # sum += diff # } # } # if total < 0 { # return - 1 # } else { # return start # }
result := FibEvenTotal ( 2 ) # if result != 0 { # t . Errorf (" STR ", result , 0 ) # } # # result = FibEvenTotal ( 3 ) # if result != 2 { # t . Errorf (" STR ", result , 2 ) # } # # result = FibEvenTotal ( 1 4 ) # if result != 1 0 { # t . Errorf (" STR ", result , 1 0 ) # } # # result = FibEvenTotal ( 1 0 0 ) # if result != 4 4 { # t . Errorf (" STR ", result , 4 4 ) # }
mc := getCount ( magazine ) # # for _ , b := range ransomNote { # mc [ b -' a ']-- # if mc [ b -' a '] < 0 { # return false # } # } # # return true
var out [ arraySize ] int # # if i >= len ( out ) { # return out , false # } # # for u := 0 ; u < len ( out ); u ++ { # if i >= len ( b . data ) { # i = 0 # } # out [ u ] = b . data [ i ] # i += 1 # } # return out , true
m := len ( mat ) # if m == 0 { # return 0 # } # # n := len ( mat [ 0 ]) # if n == 0 { # return 0 # } # # dp := make ([][] int , m ) # for i := 0 ; i < m ; i ++ { # dp [ i ] = make ([] int , n ) # } # # for j := 0 ; j < n ; j ++ { # dp [ 0 ][ j ] = int ( mat [ 0 ][ j ] - ' 0 ') # for i := 1 ; i < m ; i ++ { # if mat [ i ][ j ] == ' 1 ' { # dp [ i ][ j ] = dp [ i - 1 ][ j ] + 1 # } # } # } # # max := 0 # for i := 0 ; i < m ; i ++ { # tmp := largestRectangleArea ( dp [ i ]) # if max < tmp { # max = tmp # } # } # # return max
rfw . filename = filename # rfw . rotateCallback = callback # rfw . opaque = opaque # rfw . maxSize = maxSize # rfw . maxDuration = maxDuration # # err := os . MkdirAll ( filepath . Dir ( filename ), 0 7 5 5 ) # if err != nil { # return nil , err # } # # fi , err := os . Stat ( filename ) # if err == nil { # rfw . byteCount = fi . Size () # } # # f , err := os . OpenFile ( filename , os . O_CREATE | os . O_WRONLY | os . O_APPEND , 0 6 4 4 ) # if err != nil { # return nil , err # } # rfw . currentFile = f # rfw . startTime = time . Now () # # return rfw , nil
StoreUint 1 6 (& r . Reg , LoadUint 1 6 (& r . Reg )&^( mask << pos )| value << pos )
if n == 0 { # return 1 # } # if n == 2 || n == 1 { # return n # } # dp := make ([] int , n + 1 ) # dp [ 0 ] = 1 # dp [ 1 ] = 1 # for i := 2 ; i <= n ; i ++ { # dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ]) % 1 0 0 0 0 0 0 0 0 7 # } # return dp [ n ]
test 0 ( s 0 {}) # test 1 ( s 1 { 1 }) # test 2 ( s 2 { 1 , 2 }) # test 3 ( s 3 { 1 , 2 , 3 }) # test 4 ( s 4 { 1 , 2 , 3 , 4 }) # test 5 ( s 5 { a : struct { # aa byte # ab byte # }{ 1 , 2 }, b : 3 }) # test 6 ( s 6 {" STR ", 5 }) # test 7 ( s 7 { a : nil , b : 8 }) # test 8 ( s 8 {[] byte { 1 2 , 1 3 , 1 4 }[: 2 ], 6 }) # test 9 ( s 9 { next : & s 9 {}})
sort . Ints ( A ) # # factorIndex := make ( map [ int ] int , len ( A )) # for i := range A { # factorIndex [ A [ i ]] = i # } # # ress := make ([] int , len ( A )) # # for i := 0 ; i < len ( A ); i ++ { # ress [ i ] = 1 # for j := 0 ; j < i ; j ++ { # quotient , remainder := A [ i ]/ A [ j ], A [ i ]% A [ j ] # k , isFactor := factorIndex [ quotient ] # # if remainder != 0 || ! isFactor { # continue # } # # ress [ i ] += ress [ j ] * ress [ k ] # } # ress [ i ] = mod ( ress [ i ]) # } # # return sum ( ress )
res := 0 # for i := 0 ; i < len ( points ); i ++ { # lines := map [ Line ] int {} # overlap := 0 # count := 0 # # for j := i + 1 ; j < len ( points ); j ++ { # l := reduceSegment ( points [ i ], points [ j ]) # if l . a == 0 && l . b == 0 { # overlap ++ # } else { # lines [ l ]++ # if count < lines [ l ] { # count = lines [ l ] # } # } # } # count += overlap + 1 # if count > res { # res = count # } # } # return res
lens := len ( s ) # if lens == 0 { # return " STR " # } # count := [ 2 6 ] int {} # var ch rune # for _ , ch = range s { # count [ ch -' a ']++ # } # # imc := 0 # for i := range s { # if s [ imc ] > s [ i ] { # imc = i # } # count [ s [ i ]-' a ']-- # if count [ s [ i ]-' a '] == 0 { # break # } # } # # return string ( s [ imc ]) + removeDuplicateLetters ( strings . Replace ( s [ imc + 1 :], string ( s [ imc ]), " STR ", - 1 ))
var s string # for i := len ( d ) - 2 ; i >= 0 ; i -- { # s += fmt . Sprintf (" STR ", d [ i ]) # } # return s
res := 0 # i , j := findRook ( board ) # for k := 0 ; k < 4 ; k ++ { # x , y := i + dx [ k ], j + dy [ k ] # for 0 <= x && x < 8 && # 0 <= y && y < 8 && # board [ x ][ y ] != ' B ' { # if board [ x ][ y ] == ' p ' { # res ++ # break # } # x += dx [ k ] # y += dy [ k ] # } # } # return res
if len ( com ) == k && n == 0 { # c := make ([] int , len ( com )) # copy ( c , com ) # result = append ( result , c ) # } else if idx <= 9 && len ( com ) < k && n > 0 { # result = helper 2 1 6 ( k , idx + 1 , n , com , result ) # # com = append ( com , idx ) # result = helper 2 1 6 ( k , idx + 1 , n - idx , com , result ) # com = com [: len ( com )- 1 ] # } # # return result
benchmark ( bb , 1 0 2 4 , 1 )
copied := append ([] Job {}, jobs ...) # sort . Slice ( copied , func ( i , j int ) bool { # if copied [ i ]. End < copied [ j ]. End { # return true # } else if copied [ i ]. End == copied [ j ]. End { # return copied [ i ]. Start < copied [ j ]. Start # } # # return false # }) # # possible := make ([][] Job , 0 ) # # for _ , job := range copied { # added := false # # for i , p := range possible { # left := p [ len ( p )- 1 ] # # if job . Start >= left . End { # possible [ i ] = append ( p , job ) # } # } # # if ! added { # possible = append ( possible , [] Job { job }) # } # } # # largestSize := 0 # # var largest [] Job # # for _ , p := range possible { # if len ( p ) > largestSize { # largestSize = len ( p ) # largest = p # } # } # # return largest
c . bw . WriteString ( cmd ) # c . bw . WriteByte ( space ) # c . bw . WriteString ( key ) # c . bw . WriteByte ( space ) # c . bw . Write ( strconv . AppendUint ( c . numScratch [: 0 ], delta , 1 0 )) # _ , err = c . bw . Write ( crlf ) # return
if nil == head { # return nil # } # newHead := new ( ListNode ) # newHead . Next = & ListNode { head . Val , nil } # # head = head . Next # for head != nil { # prev , current := newHead , newHead . Next # for current != nil { # if head . Val < current . Val { # prev . Next = & ListNode { head . Val , current } # break # } # prev , current = prev . Next , current . Next # } # if nil == current && head . Val >= prev . Val { # prev . Next = & ListNode { head . Val , nil } # } # head = head . Next # } # return newHead . Next
ss := (& Rate {}). Init ( uint 3 2 ( n ), 1 * time . Second ) # # for i := 0 ; i < n ; i += 1 { # ss . Touch ( string ( i ), time . Now ()) # } # # for i := 0 ; i < n ; i += 1 { # ss . Touch ( string ( rand . Intn ( n )), time . Now ()) # } # # topRange := int ( float 6 4 ( n ) * 1 / hitrate ) # bb . ResetTimer () # for i := 0 ; i < bb . N ; i += 1 { # ss . Touch ( string ( rand . Intn ( topRange )), time . Now ()) # }
type A struct { # Name string # } # a := A { Name : " STR "} # # type B struct { # A # C int # } # b := & B { C : 1 2 3 } # b . A = a # # s := Values ( b ) # # inSlice := func ( val interface {}) bool { # for _ , v := range s { # if reflect . DeepEqual ( v , val ) { # return true # } # } # return false # } # # for _ , val := range [] interface {}{" STR ", 1 2 3 } { # if ! inSlice ( val ) { # t . Errorf (" STR ", val ) # } # }
pmax , tmax , k := 0 , 0 , 0 # for s := 1 ; s <= 1 0 0 0 ; s ++ { # t := 0 # mlimit := int ( math . Sqrt ( float 6 4 ( s ) / 2 )) # for m := 2 ; m <= mlimit ; m ++ { # if ( s / 2 )% m == 0 { # if m % 2 == 0 { # k = m + 1 # } else { # k = m + 2 # } # for k < 2 * m && k <= s /( 2 * m ) { # if s /( 2 * m )% k == 0 && Gcd ( k , m ) == 1 { # t ++ # } # k += 2 # } # } # } # if t > tmax { # tmax = t # pmax = s # } # } # return pmax
if h . Cap == 0 { # return 1 . 0 # } # return float 6 4 ( h . Count ) / float 6 4 ( h . Cap )
benchmark ( bb , 4 0 9 6 , 1 )
tests := [...] testType { # { # in : 1 6 , # want : true , # }, # { # in : 1 4 , # want : false , # }, # { # in : 0 , # want : true , # }, # { # in : 1 , # want : true , # }, # { # in : 3 , # want : false , # }, # } # for _ , tt := range tests { # got := isPerfectSquare ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
max := int ( math . Ceil ( math . Sqrt ( float 6 4 ( n )))) # var i int # if n == 1 { # return false # } # if n == 2 { # return true # } # for i = 2 ; i <= max ; i ++ { # if n % i == 0 { # return false # } # } # return true
var width int # # var left [] int # var f func (* TreeNode , int , int ) # f = func ( root * TreeNode , depth , i int ) { # if root == nil { # return # } # # if depth == len ( left ) { # left = append ( left , i ) # } # if i - left [ depth ]+ 1 > width { # width = i - left [ depth ] + 1 # } # f ( root . Left , depth + 1 , i + i ) # f ( root . Right , depth + 1 , i + i + 1 ) # } # f ( root , 0 , 0 ) # # return width
n := len ( a ) # if n < 2 { # return a , 0 # } # # b , left := recursiveCount ( a [: n >> 1 ]) # c , right := recursiveCount ( a [ n >> 1 :]) # d := make ([] int , 0 ) # # i , j := 0 , 0 # inversions := 0 # # for k := 0 ; k < n ; k ++ { # if b [ i ] < c [ j ] { # d = append ( d , b [ i ]) # i ++ # if i == len ( b ) { # for j < len ( c ) { # d = append ( d , c [ j ]) # j ++ # } # break # } # } else { # d = append ( d , c [ j ]) # j ++ # inversions += len ( b ) - i # if j == len ( c ) { # for i < len ( b ) { # d = append ( d , b [ i ]) # i ++ # } # break # } # } # } # # return d , left + right + inversions
b . lruList . MoveToFront (& e . element )
if node != nil { # stack := []* BtreeNode { node } # var res [] int # for len ( stack ) > 0 { # node = stack [ 0 ] # stack = stack [ 1 :] # if node . left != nil { # stack = append ( stack , node . left ) # } # if node . right != nil { # stack = append ( stack , node . right ) # } # res = append ( res , node . Data ) # } # # return res # } # return nil
min := 1 2 3 4 # max := 9 8 7 6 # # var pandigitals [] int # var divisors [] int # var sum int # # for i := max ; i > min ; i -- { # divisors = getDivisors ( i ) # for j := 0 ; j < len ( divisors ); j ++ { # if isPandigital ( i , divisors [ j ]) { # fmt . Printf (" STR ", divisors [ j ], i / divisors [ j ], i ) # sum += i # break # pandigitals = append ( pandigitals , i ) # } # } # } # fmt . Println ( sum )
var res int # dfs ( root , & k , & res ) # return res
defer conn . Close () # scanner := bufio . NewScanner ( conn ) # i := 0 # headers := map [ string ] string {} # var url , method string # for scanner . Scan () { # ln := scanner . Text () # fmt . Println ( ln ) # # if i == 0 { # fs := strings . Fields ( ln ) # method = fs [ 0 ] # url = fs [ 1 ] # fmt . Println (" STR ", method ) # fmt . Println (" STR ", url ) # } else { # if ln == "" { # break # } # fs := strings . SplitN ( ln , " STR ", 2 ) # headers [ fs [ 0 ]] = fs [ 1 ] # } # # i ++ # } # # if method == " STR " || method == " STR " { # } # # body := ` test < strong > test </ strong >` # # io . WriteString ( conn , " STR ") # fmt . Fprintf ( conn , " STR ", len ( body )) # fmt . Fprintf ( conn , " STR ") # fmt . Fprintf ( conn , " Location : http : ) # io . WriteString ( conn , " STR ") # io . WriteString ( conn , body )
if i >= 0 { # return i # } # return - i
data := & Node { data : i } # if list . head != nil { # data . next = list . head # } # list . head = data
tests := map [ string ] int { # " STR ": 5 , # " STR ": 5 , # " STR ": 6 , # " STR ": 0 , # " STR ": 0 , # " STR ": 1 , # " STR ": 1 , # } # # for in , want := range tests { # got := lengthOfLastWord ( in ) # if got != want { # t . Fatalf (" STR ", in , got , want ) # } # }
t . Parallel () # # ss := (& Rate {}). Init ( 2 , 1 * time . Second ) # el := ss . GetAll ( time . Now ()) # # if len ( el ) != 0 { # t . Error (" STR ") # } # #
res := 1 # # root := int ( math . Sqrt ( float 6 4 ( 2 * N ))) # for k := 2 ; k <= root ; k ++ { # kx := N - k *( k - 1 )/ 2 # if kx % k == 0 { # res ++ # } # } # # return res
var m [ 1 2 8 ] int # for _ , c := range magazine { # m [ c ]++ # } # for _ , c := range ransomNote { # m [ c ]-- # if m [ c ] < 0 { # return false # } # } # return true
return MagicDictionary { # keys : [] string {}, # }
for _ , c := range m . cache { # c . ExpireGracePeriod = p # }
hlen , nlen := len ( haystack ), len ( needle ) # for i := 0 ; i <= hlen - nlen ; i ++ { # if haystack [ i : i + nlen ] == needle { # return i # } # } # # return - 1
low , high := 0 , len ( nums )- 1 # for low <= high { # mid := low + ( high - low )>> 1 # if nums [ mid ] >= target { # high = mid - 1 # } else { # if ( mid == len ( nums )- 1 ) || ( nums [ mid + 1 ] >= target ) { # return mid + 1 # } # low = mid + 1 # } # } # return 0
n := len ( prices ) # if n < 2 { # return 0 # } # # if k >= n / 2 { # res := 0 # for i := 1 ; i < n ; i ++ { # tmp := prices [ i ] - prices [ i - 1 ] # if tmp > 0 { # res += tmp # } # } # return res # } # # dp := make ([][] int , k + 1 ) # for i := 0 ; i < k + 1 ; i ++ { # dp [ i ] = make ([] int , n ) # } # for i := 1 ; i < k + 1 ; i ++ { # tmp := - prices [ 0 ] # for j := 1 ; j < n ; j ++ { # dp [ i ][ j ] = max ( dp [ i ][ j - 1 ], prices [ j ]+ tmp ) # tmp = max ( tmp , dp [ i - 1 ][ j - 1 ]- prices [ j ]) # } # } # return dp [ k ][ n - 1 ]
i := & Index { # Target : & VariableAccess { Name : " STR "}, # Key : & LiteralNode { # Typex : TypeInt , # Value : 1 , # }, # } # # scope := & BasicScope { # VarMap : map [ string ] Variable { # " STR ": Variable { # Type : TypeList , # Value : [] Variable { # Variable { # Type : TypeString , # Value : " STR ", # }, # Variable { # Type : TypeInt , # Value : 4 3 , # }, # }, # }, # }, # } # # _ , err := i . Type ( scope ) # if err == nil || ! strings . Contains ( err . Error (), " STR ") { # t . Fatalf (" STR ") # }
t . Parallel () # # for _ , tc := range testcases { # tree := & TernarySearchTree {} # # for _ , word := range tc . words { # tree . Insert ( word ) # } # # if ! equalTernaryTree ( tree , tc . tree ) { # t . Errorf (" STR ") # } # # for _ , word := range tc . words { # if ! tree . Search ( word ) { # t . Errorf (" STR ", word ) # } # } # # for _ , word := range tc . notWords { # if tree . Search ( word ) { # t . Errorf (" STR ", word ) # } # } # }
starttime := time . Now () # # for j := len ( triangle ) - 2 ; j >= 0 ; j -- { # for i := range triangle [ j ] { # max := triangle [ j + 1 ][ i ] # if triangle [ j + 1 ][ i + 1 ] > max { # max = triangle [ j + 1 ][ i + 1 ] # } # triangle [ j ][ i ] += max # } # } # # fmt . Println ( triangle [ 0 ][ 0 ]) # # fmt . Println (" STR ", time . Since ( starttime ))
qs := [] question 7 { # # { # para 7 { 3 2 1 }, # ans 7 { 1 2 3 }, # }, # # { # para 7 {- 1 2 3 }, # ans 7 {- 3 2 1 }, # }, # # { # para 7 { 1 2 0 }, # ans 7 { 2 1 }, # }, # # { # para 7 { 1 5 3 4 2 3 6 4 6 9 }, # ans 7 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 , q . para 7 # fmt . Printf (" STR ", p . one , reverse 7 ( p . one )) # } # fmt . Printf (" STR ")
sort . Slice ( nums , func ( i , j int ) bool { # return nums [ i ] < nums [ j ] # }) # dp := make ([] int , len ( nums )) # dp [ len ( dp )- 1 ] = 1 # var largestI , largestVal int # for i := len ( dp ) - 2 ; i >= 0 ; i -- { # m := 0 # for j := i + 1 ; j < len ( dp ); j ++ { # if nums [ j ]% nums [ i ] == 0 { # m = max ( m , dp [ j ]) # } # } # if dp [ i ] = 1 + m ; dp [ i ] > largestVal { # largestI = i # largestVal = dp [ i ] # } # } # result := make ([] int , 0 , largestVal ) # for i := largestI ; i < len ( nums ); i ++ { # if nums [ i ]% nums [ largestI ] == 0 { # result = append ( result , nums [ i ]) # } # } # return result
res = 0 # dfs ( root ) # return res
_ , err = c . bw . WriteString ( cmd ) # for _ , key := range keys { # if err != nil { # break # } # c . bw . WriteByte ( space ) # _ , err = c . bw . WriteString ( key ) # } # _ , err = c . bw . Write ( crlf ) # return
maxProfit := 0 # minPrice := price [ 0 ] # for _ , v := range price { # maxProfit = int ( math . Max ( float 6 4 ( maxProfit ), float 6 4 ( v - minPrice ))) # minPrice = int ( math . Min ( float 6 4 ( minPrice ), float 6 4 ( v ))) # } # return maxProfit
ret = [] string {} # helper (" STR ", n , n ) # return ret
t . Parallel () # # for _ , tc := range testcases { # if result , err := ShortestRunnerPath ( tc . elevations , tc . paths ); result != tc . shortestRoute || err != tc . err { # t . Errorf (" STR ", tc . shortestRoute , tc . err , result , err ) # } # }
if v . Kind () == reflect . Ptr { # v = v . Elem () # } # # t := v . Type () # # var fields []* Field # # for i := 0 ; i < t . NumField (); i ++ { # field := t . Field ( i ) # # if tag := field . Tag . Get ( tagName ); tag == " STR " { # continue # } # # f := & Field { # field : field , # value : v . FieldByName ( field . Name ), # } # # fields = append ( fields , f ) # # } # # return fields
res := 0 # for i := 0 ; i < len ( s ); i ++ { # tmp := int ( s [ i ] - ' A ' + 1 ) # res = res * 2 6 + tmp # } # return res
start := grid [ c . Row ][ c . Col ] # replaceAdjacentColorPixel ( grid , c , start , color )
return lq . queue . Len ()
length := len ( s ) # reverse := make ([] byte , length ) # for idx := length - 1 ; idx >= 0 ; idx -- { # reverse [ length - idx - 1 ] = s [ idx ] # } # # str := string ( reverse ) # idx := length # for ; idx > 0 ; idx -- { # if s [: idx ] == str [ length - idx :] { # break # } # } # if idx == length { # return s # } # # return str [: length - idx ] + s
count := [ 1 << 1 6 ] int {} # for _ , Ai := range A { # for _ , Aj := range A { # count [ Ai & Aj ]++ # } # } # # res := 0 # for AiAndAj , c := range count { # if c == 0 { # continue # } # for _ , Ak := range A { # if AiAndAj & Ak == 0 { # res += c # } # } # } # # return res
for i := 0 ; i < 9 ; i ++ { # for j := 0 ; j < 9 ; j ++ { # if board [ i ][ j ] != '.' { # continue # } # var c byte # for c = ' 1 '; c <= ' 9 '; c ++ { # if isValid ( board , i , j , c ) { # board [ i ][ j ] = c # if solve ( board ) { # return true # } # board [ i ][ j ] = '.' # } # } # return false # } # } # return true
return len ( q )
if list . top == nil { # return 0 , false # } # i := list . top . data # list . top = list . top . next # return i , true
bs := [] byte ( S ) # stack , top := make ([] byte , len ( S )), - 1 # for _ , b := range bs { # if top >= 0 && stack [ top ] == b { # top -- # } else { # top ++ # stack [ top ] = b # } # } # return string ( stack [: top + 1 ])
n := len ( s ) # if n == 0 { # return 0 # } # # dp := make ([] int , n + 1 ) # dp [ 0 ], dp [ 1 ] = 1 , one ( s [ 0 ]) # for i := 2 ; i <= n ; i ++ { # w 1 , w 2 := one ( s [ i - 1 ]), two ( s [ i - 2 ], s [ i - 1 ]) # dp [ i ] = dp [ i - 1 ]* w 1 + dp [ i - 2 ]* w 2 # if dp [ i ] == 0 { # return 0 # } # } # return dp [ n ]
t . Fatalf (" STR ", " STR ")
qs := [] question 3 5 4 { # # { # para 3 5 4 {[][] int {{ 5 , 4 }, { 6 , 4 }, { 6 , 7 }, { 2 , 3 }}}, # ans 3 5 4 { 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 5 4 , q . para 3 5 4 # fmt . Printf (" STR ", p , maxEnvelopes ( p . envelopes )) # } # fmt . Printf (" STR ")
if len ( cost ) < 2 { # return 0 # } # dp := make ([] int , len ( cost )+ 1 ) # dp [ 0 ], dp [ 1 ] = 0 , 0 # for i := 2 ; i <= len ( cost ); i ++ { # dp [ i ] = cost [ i - 1 ] + dp [ i - 1 ] # if dp [ i ] > cost [ i - 2 ]+ dp [ i - 2 ] { # dp [ i ] = cost [ i - 2 ] + dp [ i - 2 ] # } # } # return dp [ len ( cost )] #
l , r := 0 , len ( A )- 1 # tmp := A [ l ] # for l < r { # for l < r && A [ r ]% 2 == 1 { # r -- # } # A [ l ] = A [ r ] # for l < r && A [ l ]% 2 == 0 { # l ++ # } # A [ r ] = A [ l ] # } # A [ l ] = tmp # return A
newNode := new ( reverseLink ) # for node . next != nil { # next := node . next # node . next = newNode # newNode = node # node = next # } # return newNode
if X >= Y { # return X - Y # } # # if Y % 2 == 0 { # return 1 + brokenCalc ( X , Y / 2 ) # } # # return 1 + brokenCalc ( X , Y + 1 )
cache := [] int {} # var num 1 , num 2 , num int # for i := range tokens { # if tokens [ i ] == " STR " || tokens [ i ] == " STR " || tokens [ i ] == " STR " || tokens [ i ] == " STR " { # num 2 = cache [ len ( cache )- 1 ] # num 1 = cache [ len ( cache )- 2 ] # cache [ len ( cache )- 2 ] = calculate ( num 1 , num 2 , tokens [ i ]) # cache = cache [: len ( cache )- 1 ] # } else { # num , _ = strconv . Atoi ( tokens [ i ]) # cache = append ( cache , num ) # } # } # return cache [ 0 ]
if head == nil || head . Next == nil { # return head # } # fake := & ListNode { Next : head } # tail := head # var cur * ListNode # for tail . Next != nil { # cur = tail . Next # p := fake # for ; p . Next != cur ; p = p . Next { # if p . Next . Val >= cur . Val { # tmp := p . Next # p . Next = cur # tail . Next = cur . Next # cur . Next = tmp # break # } # } # if p == tail { # tail = cur # } # } # return fake . Next
mp := map [ int ] int {} # for i := 1 ; i < 2 0 0 ; i ++ { # for j := 1 ; j < 5 0 0 0 ; j ++ { # if isPandigital ( i , j , i * j ) { # mp [ i * j ] = 1 # } # } # } # sum := 0 # for key , _ := range mp { # sum += key # } # println ( sum )
vals := strings . Split ( data , " STR ") # return dfs (& vals )
type A struct { # Name string # } # a := A { Name : " STR "} # # type B struct { # A ` structs :" STR "` # Name string # C int # } # b := & B { C : 1 2 3 , Name : " STR "} # b . A = a # # m := Map ( b ) # # _ , ok := m [" STR "].( map [ string ] interface {}) # if ok { # t . Error (" STR ") # } # # expectedMap := map [ string ] interface {}{" STR ": " STR ", " STR ": 1 2 3 } # if ! reflect . DeepEqual ( m , expectedMap ) { # t . Errorf (" STR ", expectedMap , m ) # }
n := len ( nums ) # if n == 0 { # return 0 # } # # sums := make ([] int , n + 1 ) # for i , n := range nums { # sums [ i + 1 ] = sums [ i ] + n # } # return countWhilemergeSort ( sums , 0 , n + 1 , lower , upper )
sum , ans := 1 , [] int {} # for i := 0 ; i < n ; i ++ { # sum *= 1 0 # } # for i := 0 ; i < sum - 1 ; i ++ { # ans = append ( ans , i + 1 ) # } # return ans
var n int # for _ , num := range nums { # if num != val { # nums [ n ] = num # n ++ # } # } # return n
m := len ( grid ) # n := len ( grid [ 0 ]) # for i := 1 ; i < m ; i ++ { # grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ] # } # for i := 1 ; i < n ; i ++ { # grid [ 0 ][ i ] += grid [ 0 ][ i - 1 ] # } # for i := 1 ; i < m ; i ++ { # for j := 1 ; j < n ; j ++ { # if grid [ i - 1 ][ j ] < grid [ i ][ j - 1 ] { # grid [ i ][ j ] += grid [ i - 1 ][ j ] # } else { # grid [ i ][ j ] += grid [ i ][ j - 1 ] # } # } # } # return grid [ m - 1 ][ n - 1 ]
cur := n % 2 # n /= 2 # for n > 0 { # if cur == n % 2 { # return false # } # cur = n % 2 # n /= 2 # } # return true
var queue * Queue = New () # # queue . Enqueue ( 1 ) # queue . Enqueue ( 2 ) # queue . Enqueue ( 3 ) # queue . Enqueue ( 4 ) # queue . Enqueue ( 5 ) # # for i := 1 ; i < 6 ; i ++ { # item := queue . Dequeue () # # if ( item != i ) { # t . Error (" STR ", i ) # } # } #
match := func ( str 1 , str 2 string ) bool { # charMap := make ( map [ byte ] byte ) # for i , b 1 := range [] byte ( str 1 ) { # if b 2 , exists := charMap [ b 1 ]; exists { # if b 2 != byte ( str 2 [ i ]) { # return false # } # } else { # charMap [ b 1 ] = byte ( str 2 [ i ]) # } # } # # return true # } # # var result [] string # for _ , word := range words { # if len ( word ) == len ( pattern ) && match ( word , pattern ) && match ( pattern , word ) { # result = append ( result , word ) # } # } # # return result
return n > 0
res := [] int { 0 , 1 , 0 , 0 , 2 , 1 0 , 4 , 4 0 , 9 2 , 3 5 2 , 7 2 4 } # return res [ n ]
valMap := make ( map [ string ] bool ) # var val string # for a := 2 ; a <= 1 0 0 0 ; a ++ { # for b := 2 ; b <= 1 0 0 0 ; b ++ { # val = pow ( a , b ). String () # if ! valMap [ val ] { # valMap [ val ] = true # } # } # } # # fmt . Println (" STR ", len ( valMap ))
var m , n , cm , cn int # for i := range nums { # if nums [ i ] == m { # cm ++ # } else if nums [ i ] == n { # cn ++ # } else if cm == 0 { # m = nums [ i ] # cm ++ # } else if cn == 0 { # n = nums [ i ] # cn ++ # } else { # cm -- # cn -- # } # } # cm , cn = 0 , 0 # for i := range nums { # if nums [ i ] == m { # cm ++ # } else if nums [ i ] == n { # cn ++ # } # } # var ret [] int # if cm > len ( nums )/ 3 { # ret = append ( ret , m ) # } # if cn > len ( nums )/ 3 { # ret = append ( ret , n ) # } # return ret
in , out := 1 0 0 0 , 4 7 8 2 # if x := p 2 5 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # }
testCases := [][] int { # { 1 0 , 2 }, # { 3 , 3 0 , 3 4 , 5 , 9 }, # { 0 }, # } # # expected := [] string { # " STR ", # " STR ", # " STR ", # } # # for index , nums := range testCases { # if res := largestNumber ( nums ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
elements := make ([] Element , 0 , len ( ss . hash )) # for i := len ( ss . olist ) - 1 ; i >= 0 ; i -= 1 { # b := & ss . olist [ i ] # if b . key == "" { # continue # } # elements = append ( elements , Element { # Key : b . key , # LoCount : b . count - b . error , # HiCount : b . count , # }) # } # return elements
return strings . Contains (( s + s )[ 1 : 2 * len ( s )- 1 ], s )
if bt == nil { # return # } # fmt . Println ( bt . data ) # if bt . left != nil { # preOrder ( bt . left ) # } # if bt . right != nil { # preOrder ( bt . right ) # }
type C struct { # something int # Props map [ string ] interface {} # } # # defer func () { # err := recover () # if err != nil { # fmt . Printf (" STR ", err ) # t . Error (" STR ") # } # }() # # _ = Map (& C {}) # _ = Fields (& C {}) # _ = Values (& C {}) # _ = IsZero (& C {}) # _ = HasZero (& C {})
if _value , isList := value .(* list . List ); isList { # m . value = _value # } else { # m . value . PushBack ( value ) # }
for node := list . Head ; node != nil ; node = node . Next { # f (* node ) # }
tests := [...] testType { # { # in : [] int { 2 , 2 , 3 , 4 }, # want : 2 , # }, # { # in : [] int { 1 , 2 , 2 , 3 , 3 , 3 }, # want : 3 , # }, # { # in : [] int { 2 , 2 , 2 , 3 , 3 }, # want : - 1 , # }, # { # in : [] int { 5 }, # want : - 1 , # }, # { # in : [] int { 7 , 7 , 7 , 7 , 7 , 7 , 7 }, # want : 7 , # }, # } # for _ , tt := range tests { # got := findLucky ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if node == nil { # return false # } # list . mutex . Lock () # defer list . mutex . Unlock () # if list . Size == 0 { # list . Head = node # list . Tail = node # list . Size = 1 # return true # } # # tail := list . Tail # tail . Next = node # list . Tail = node # list . Size += 1 # return true
var stepMap = map [ byte ] int {} # for i := 0 ; i < len ( moves ); i ++{ # stepMap [ moves [ i ]]++ # } # # if stepMap [' U '] == stepMap [' D '] && stepMap [' L '] == stepMap [' R '] { # return true # } # return false
var order [] string # seen := make ( map [ string ] bool ) # var visitAll func ( items [] string ) # # visitAll = func ( items [] string ) { # for _ , item := range items { # if ! seen [ item ] { # seen [ item ] = true # visitAll ( m [ item ]) # order = append ( order , item ) # } # } # } # # var keys [] string # for key := range m { # keys = append ( keys , key ) # } # # sort . Strings ( keys ) # visitAll ( keys ) # return order
tests := [...] testType { # { # in : [] int { 4 , 1 , 8 , 7 }, # want : true , # }, # { # in : [] int { 1 , 2 , 1 , 2 }, # want : false , # }, # } # for _ , tt := range tests { # got := judgePoint 2 4 ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
tests := [...] testType { # { # in : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := reverseWords ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
Points := make ([] point , 1 0 ) # for i := 0 ; i < 1 0 ; i ++ { # a := makePoint ( float 6 4 ( i ), float 6 4 ( i * i )) # # Points [ i ] = * a # } # # for i := 0 ; i < b . N ; i ++ { # BruteForce ( Points ) # }
pl := & pipeline { # queue : make ( chan queueItem , 5 1 2 ), # done : make ( chan struct {}), # } # go pl . run () # return pl
if node == nil { # return # } # # traverse ( node . Left , res ) # * res = append (* res , node . Val ) # traverse ( node . Right , res )
gol := & GameOfLife { living : make ( map [ Coord ] struct {})} # rows := strings . Split ( board , " STR ") # gol . maxY = int 6 4 ( len ( rows )) # for y := 0 ; y < len ( rows ); y ++ { # for x , val := range rows [ len ( rows )- 1 - y ] { # if val == '*' { # gol . living [ Coord { int 6 4 ( x ), int 6 4 ( y )}] = struct {}{} # if int 6 4 ( x ) >= gol . maxX { # gol . maxX = int 6 4 ( x ) + 1 # } # } # } # } # gol . minX , gol . minY = - 1 , - 1 # return gol
t . Parallel () # for _ , tc := range testcases { # if s 1 , s 2 := SubsetsSmallestDifference ( tc . nums ); sum ( s 1 , s 2 ) != tc . diff { # t . Errorf (" STR ", tc . diff , s 1 , s 2 , sum ( s 1 , s 2 )) # } # }
sum , ec := 0 , 1 # for _ , v := range flowerbed { # if v == 0 { # ec ++ # } else { # sum += ( ec - 1 ) / 2 # ec = 0 # } # } # sum += ec / 2 # return sum >= n
qs := [] question 9 6 9 { # # { # para 9 6 9 {[] int {}}, # ans 9 6 9 {[] int {}}, # }, # # { # para 9 6 9 {[] int { 1 }}, # ans 9 6 9 {[] int { 1 }}, # }, # # { # para 9 6 9 {[] int { 3 , 2 , 4 , 1 }}, # ans 9 6 9 {[] int { 3 , 4 , 2 , 3 , 1 , 2 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 6 9 , q . para 9 6 9 # fmt . Printf (" STR ", p , pancakeSort ( p . one )) # } # fmt . Printf (" STR ")
a , err := Asset ( name ) # if err != nil { # panic (" STR " + name + " STR " + err . Error ()) # } # # return a
jumpValue := int ( math . Floor ( math . Sqrt ( float 6 4 ( len ( array ))))) # minIndex := 0 # maxIndex := jumpValue # for array [ maxIndex ] <= number { # minIndex += jumpValue # maxIndex = minIndex + jumpValue # if maxIndex >= len ( array ) { # maxIndex = len ( array ) # minIndex = maxIndex - jumpValue # break # } # } # for i := minIndex ; i < maxIndex ; i ++ { # if array [ i ] == number { # return i # } # } # return - 1
i , j := 0 , len ( numbers )- 1 # var sum int # for i < j { # sum = numbers [ i ] + numbers [ j ] # if sum == target { # return [] int { i + 1 , j + 1 } # } # if sum < target { # i ++ # } else { # j -- # } # } # return [] int {}
for i := int 6 4 ( 2 ); ; i ++ { # t := ( i * ( i + 1 )) / 2 # p := ( i * (( 3 * i ) - 1 )) / 2 # h := ( i * (( 2 * i ) - 1 )) # # penmap [ p ] = true # hexmap [ h ] = true # # if penmap [ t ] && hexmap [ t ] && t > 4 0 7 5 5 { # fmt . Println ( t ) # return # } # # }
if W == 1 { # return true # } # # if W > len ( hand ) || len ( hand )% W != 0 { # return false # } # # size := len ( hand ) / W # # groups := make ([][] int , size ) # # sort . Ints ( hand ) # # for _ , c := range hand { # i := 0 # for ; i < size ; i ++ { # if len ( groups [ i ]) == W { # continue # } # last := len ( groups [ i ]) - 1 # if last == - 1 || groups [ i ][ last ]+ 1 == c { # groups [ i ] = append ( groups [ i ], c ) # break # } # } # if i == size { # return false # } # } # # return true
if len ( nums ) < 2 { # return 0 # } # current_max_index , pre_max_max_index , jump_min := nums [ 0 ], nums [ 0 ], 1 # # for i := 1 ; i < len ( nums ); i ++ { # if i > current_max_index { # jump_min ++ # current_max_index = pre_max_max_index # } # if pre_max_max_index < nums [ i ]+ i { # pre_max_max_index = nums [ i ] + i # } # fmt . Println (" STR ", i , current_max_index , pre_max_max_index , jump_min ) # } # return jump_min
ls , lt := len ( s ), len ( t ) # if ls != lt { # return false # } # # mapping := make ( map [ byte ] byte ) # reverseMapping := make ( map [ byte ] struct {}) # for idx := 0 ; idx < ls ; idx ++ { # if v , ok := mapping [ s [ idx ]]; ok { # if v != t [ idx ] { # return false # } # continue # } # if _ , ok := reverseMapping [ t [ idx ]]; ok { # return false # } # # mapping [ s [ idx ]] = t [ idx ] # reverseMapping [ t [ idx ]] = struct {}{} # } # # return true
i := 0 # j := 0 # for i < len ( name ) && j < len ( typed ) { # var ch 1 , ch 2 byte # var count 1 , count 2 int # ch 1 , i , count 1 = parseName ( name , i ) # ch 2 , j , count 2 = parseName ( typed , j ) # if ch 1 != ch 2 || count 1 > count 2 { # return false # } # } # # return i == len ( name ) && j == len ( typed )
type arg struct { # head * ListNode # n int # } # # testCase := [] arg { # { head : createSingleLinkedList ([] int { 1 , 2 , 3 , 4 , 5 }), n : 2 }, # { head : createSingleLinkedList ([] int { 1 , 2 , 3 , 4 , 5 }), n : 0 }, # } # # expected := []* ListNode { # createSingleLinkedList ([] int { 1 , 2 , 3 , 5 }), # createSingleLinkedList ([] int { 1 , 2 , 3 , 4 , 5 }), # } # # for index , data := range testCase { # if res := removeNthFromEnd ( data . head , data . n ); ! reflect . DeepEqual ( res , expected [ index ]) { # t . Errorf (" STR ") # } # }
qs := [] question 1 3 6 { # # { # para 1 3 6 {[] int { 2 , 2 , 1 }}, # ans 1 3 6 { 1 }, # }, # # { # para 1 3 6 {[] int { 4 , 1 , 2 , 1 , 2 }}, # ans 1 3 6 { 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 3 6 , q . para 1 3 6 # fmt . Printf (" STR ", p , singleNumber ( p . s )) # } # fmt . Printf (" STR ")
intDigits := convertToInt ( strings . Split ( str , " STR ")) # fmt . Println ( getGreatestProduct ( intDigits , 4 )) # fmt . Println ( getGreatestProduct ( intDigits , 1 3 ))
var tests = [] struct { # tree * TreeNode # validBST bool # }{ # { newTree (), true }, # { newTree ( 2 , 1 , 3 ), true }, # { newTree ( 4 , 2 , 6 , 1 , 5 ), false }, # { newTree ( 5 , 1 , 4 , nil , nil , 3 , 6 ), false }, # { newTree ( 3 , nil , 3 0 , 1 0 , nil , nil , 1 5 , nil , 4 5 ), false }, # } # # for _ , tt := range tests { # validBST := isValidBST ( tt . tree ) # if validBST != tt . validBST { # t . Errorf (" STR ", tt . tree , validBST , tt . validBST ) # } # }
if len ( matrix ) == 0 || len ( matrix [ 0 ]) == 0 { # return 0 # } # # heights := make ([] int , len ( matrix [ 0 ])) # maxArea := 0 # for i := 0 ; i < len ( matrix ); i ++ { # for j := 0 ; j < len ( matrix [ 0 ]); j ++ { # if matrix [ i ][ j ] == ' 0 ' { # heights [ j ] = 0 # } else { # heights [ j ]++ # } # } # # area := largestRectangleArea ( heights ) # if maxArea < area { # maxArea = area # } # } # # return maxArea
flag := false # if len ( A ) < 3 { # return false # } # for i , v := range A [ 1 :] { # if ! flag && v <= A [ i ] { # if flag = true ; i == 0 { # return false # } # } # if flag && v >= A [ i ] { # return false # } # } # return flag
sort . Ints ( candidates ) # res := [][] int {} # var dfs func ( remain int , combo [] int , index int ) # dfs = func ( remain int , combo [] int , index int ) { # if remain == 0 { # t := make ([] int , len ( combo )) # copy ( t , combo ) # res = append ( res , t ) # return # } # # for i := index ; i < len ( candidates ); i ++ { # if candidates [ i ] > remain { # break # } # if i > index && candidates [ i ] == candidates [ i - 1 ] { # continue # } # dfs ( remain - candidates [ i ], append ( combo , candidates [ i ]), i + 1 ) # } # } # dfs ( target , [] int {}, 0 ) # return res
return s . stores [ len ( s . stores )- 1 ]
if n == 1 { # return 1 # } # next := 0 # if n % 2 == 0 { # next = n / 2 # } else { # next = 3 * n + 1 # } # return 1 + collatz ( next )
sort . Ints ( A ) # # lo , hi := 0 . 0 , 1 . 0 # for { # mid := ( lo + hi ) / 2 # # p , q , count := countUnder ( mid , A ) # # switch { # case count < K : # lo = mid # case count > K : # hi = mid # default : # return [] int { p , q } # } # }
cases := [] struct { # name string # inputs [] int # expect bool # }{ # {" STR ", [] int { 2 , 3 , 1 , 1 , 4 }, true }, # {" STR ", [] int { 3 , 2 , 1 , 0 , 4 }, false }, # {" STR ", [] int { 0 , 2 , 3 }, false }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := canJump 3 ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
qs := [] question 3 4 2 { # # { # para 3 4 2 { 1 6 }, # ans 3 4 2 { true }, # }, # # { # para 3 4 2 { 5 }, # ans 3 4 2 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 4 2 , q . para 3 4 2 # fmt . Printf (" STR ", p , isPowerOfFour ( p . one )) # } # fmt . Printf (" STR ")
count := 0 # for i := 2 ; i <= N ; i ++ { # x , ok := i , 0 # for x != 0 { # switch x % 1 0 { # case 2 , 5 , 6 , 9 : # ok = 1 # case 3 , 4 , 7 : # ok , x = 0 , 0 # } # x /= 1 0 # } # count += ok # } # return count
n := node .(* bstElement ) # if n != nil { # stop := t . InOrderWalk ( n . left , callback ) # if stop { # return true # } # stop = callback ( t , n ) # if stop { # return true # } # stop = t . InOrderWalk ( n . right , callback ) # return stop # } # return false
qs := [] question 7 1 7 { # # { # para 7 1 7 {[] int { 1 , 0 , 0 }}, # ans 7 1 7 { true }, # }, # # { # para 7 1 7 {[] int { 1 , 1 , 1 , 0 }}, # ans 7 1 7 { false }, # }, # # { # para 7 1 7 {[] int { 0 , 1 , 1 , 1 , 0 , 0 }}, # ans 7 1 7 { true }, # }, # # { # para 7 1 7 {[] int { 1 , 1 , 1 , 1 , 0 }}, # ans 7 1 7 { true }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 1 7 , q . para 7 1 7 # fmt . Printf (" STR ", p , isOneBitCharacter ( p . one )) # } # fmt . Printf (" STR ")
if nums == nil { # return 0 # } # for i := 0 ; i < len ( nums ); { # if nums [ i ] == val { # nums = append ( nums [: i ], nums [ i + 1 :]...) # i -- # } # i ++ # } # return len ( nums ) #
qs := [] question 2 2 3 { # # { # para 2 2 3 {- 3 , 0 , 3 , 4 , 0 , - 1 , 9 , 2 }, # ans 2 2 3 { 4 5 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 2 3 , q . para 2 2 3 # fmt . Printf (" STR ", p , computeArea ( p . A , p . B , p . C , p . D , p . E , p . F , p . G , p . H )) # } # fmt . Printf (" STR ")
m := make ( map [ int ] int , len ( A )* len ( B )) # for _ , a := range A { # for _ , b := range B { # m [ a + b ]++ # } # } # ret := 0 # for _ , c := range C { # for _ , d := range D { # ret += m [ 0 - c - d ] # } # } # # return ret
if ! hasFile ( path ) { # return 0 # } # # return llp (" STR "+ path ) - 1
list . Size = 0 # list . Head = nil # list . Tail = nil # list . mutex = new ( sync . RWMutex )
counter := make ( chan int ) # counter <- 1 0 # fmt . Println (<- counter )
t . Parallel () # for _ , tc := range testcases { # if result := SumSublist ( tc . L , tc . start , tc . end ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
position := [] int {- 1 , - 1 } # # hi := len ( nums ) - 1 # position [ 0 ] = pos 1 ( nums , target , 0 , hi ) # if position [ 0 ] == - 1 { # return position # } # # position [ 1 ] = pos 2 ( nums , target , position [ 0 ], hi ) # return position
if len ( c ) > amount { # return c # } # missing := amount - len ( c ) # builder := strings . Builder {} # for i := 0 ; i < missing ; i ++ { # builder . Write ([] byte { offsetByte }) # } # builder . WriteString ( c ) # return builder . String ()
data := [] string {" STR ", " STR "} # fmt . Printf (" STR ", nonempty ( data )) # fmt . Printf (" STR ", data )
result := make ([] int , 2 6 ) # for i := 0 ; i < len ( s ); i ++ { # result [ s [ i ]-' a ']++ # } # for i := 0 ; i < len ( s ); i ++ { # if result [ s [ i ]-' a '] == 1 { # return i # } # } # return - 1
if root == nil { # return true # } else { # if isBalanced ( root . left ) && isBalanced ( root . right ) { # return math . Abs ( float 6 4 ( depth ( root . left )- depth ( root . right ))) <= 1 # } else { # return false # } # } # return false
l := new ( List ) # l . Length = 0 # return l
dp := make ([] int , amount + 1 ) # for i := 1 ; i <= amount ; i ++ { # dp [ i ] = - 1 # for _ , c := range coins { # if i >= c && dp [ i - c ] >= 0 { # if dp [ i ] == - 1 { # dp [ i ] = dp [ i - c ] + 1 # } else if dp [ i ] > dp [ i - c ]+ 1 { # dp [ i ] = dp [ i - c ] + 1 # } # } # } # } # # return dp [ amount ]
qs := [] question 1 9 8 { # # { # para 1 9 8 {[] int { 1 , 2 }}, # ans 1 9 8 { 2 }, # }, # # { # para 1 9 8 {[] int { 1 , 2 , 3 , 1 }}, # ans 1 9 8 { 4 }, # }, # { # para 1 9 8 {[] int { 2 , 7 , 9 , 3 , 1 }}, # ans 1 9 8 { 1 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 9 8 , q . para 1 9 8 # fmt . Printf (" STR ", p , rob 1 9 8 ( p . one )) # } # fmt . Printf (" STR ")
arr := randomSlice ( 0 , 2 0 , 1 0 ) # nodeCnt := 0 # gbt := newGBT () # for _ , v := range arr { # gbt . Insert ( uint 3 2 ( v )) # } # gbt . InOrderWalk ( gbt . Root (), checkGBT ( t , & nodeCnt , * debug )) # if nodeCnt != len ( arr ) { # t . Log (" STR ", len ( arr ), " STR ", nodeCnt ) # t . Fail () # }
problems = CheckProblemExists ( problems ) # # file , err := os . OpenFile ( SOURCE_SOLUTION_SUMMARY_FILE_PATH , os . O_RDONLY , 0 6 0 0 ) # defer file . Close () # if err != nil { # log . Panicf (" STR ", err . Error ()) # } # # buffer , err := ioutil . ReadAll ( file ) # if err != nil { # log . Panicf (" STR ", err . Error ()) # } # # var tmpRes bytes . Buffer # # tmpl , err := template . New (" STR "). Parse ( string ( buffer )) # err = tmpl . Execute (& tmpRes , problems ) # write (" STR ", string ( tmpRes . Bytes ()))
t . Parallel () # for _ , tc := range testcases { # if primes := SieveOfEratosthenes ( tc . n ); ! reflect . DeepEqual ( primes , tc . primes ) { # t . Errorf (" STR ", tc . primes , primes ) # } # }
ch := make ( chan VertexId ) # go func () { # for vertex , _ := range g . edges { # ch <- vertex # } # close ( ch ) # }() # return ch
res := 0 # for i := 2 ; i < n ; i ++ { # if isPrime ( i ) { # res = res + 1 # } # } # return res
s := " STR " # fmt . Println ( letterCasePermutation ( s )) # # s 1 := " STR " # fmt . Println ( letterCasePermutation ( s 1 ))
return math . Hypot ( q . X - p . X , q . Y - p . Y )
qs := [] question 3 9 { # # { # para 3 9 {[] int { 2 , 3 , 6 , 7 }, 7 }, # ans 3 9 {[][] int {{ 7 }, { 2 , 2 , 3 }}}, # }, # # { # para 3 9 {[] int { 2 , 3 , 5 }, 8 }, # ans 3 9 {[][] int {{ 2 , 2 , 2 , 2 }, { 2 , 3 , 3 }, { 3 , 5 }}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 9 , q . para 3 9 # fmt . Printf (" STR ", p , combinationSum ( p . n , p . k )) # } # fmt . Printf (" STR ")
wg . Add ( 2 ) # # go incCounter ( 1 ) # go incCounter ( 2 ) # # wg . Wait () # fmt . Println (" STR ", counter )
n := len ( P ) # # if n == 2 { # return makePair ( P [ 0 ], P [ 1 ]) # } # # xP := make ([] point , n ) # yP := make ([] point , n ) # # for i := 0 ; i < n ; i ++ { # xP [ i ] = P [ i ] # yP [ i ] = P [ i ] # } # # _ , pair := divideAndConquer ( xP , yP ) # # return pair
if this . top == 0 || this . waitLimit == 0 { # return this . top # } # # next := this . top # for i := this . top ; i >= 0 ; i -- { # if this . queues [ i ]. Len () > 0 && this . waiting [ i ] >= this . waitLimit { # next = i # break # } # } # # for i , q := range this . queues { # if i != next && q . Len () > 0 { # this . waiting [ i ]++ # } # } # this . waiting [ next ] = 0 # # return next
var nodes [] string # for p := head ; nil != p ; p = p . Next { # nodes = append ( nodes , strconv . Itoa ( p . Val )) # } # return strings . Join ( nodes , " STR ")
h . tasks = append ( h . tasks , v .(* task ))
res := 0 # # size := len ( points ) # if size < 3 { # return 0 # } # # for i := 0 ; i < size ; i ++ { # dMap := make ( map [ int ] int , size ) # # for j := 0 ; j < size ; j ++ { # if i == j { # continue # } # # d := dSquare ( points [ i ], points [ j ]) # # if _ , ok := dMap [ d ]; ok { # dMap [ d ]++ # } else { # dMap [ d ] = 1 # } # } # # for _ , v := range dMap { # res += v * ( v - 1 ) # } # } # # return res
n := len ( ints ) # if n == 0 { # return nil # } # # root := & TreeNode { # Val : ints [ 0 ], # } # # queue := make ([]* TreeNode , 1 , n * 2 ) # queue [ 0 ] = root # # i := 1 # for i < n { # node := queue [ 0 ] # queue = queue [ 1 :] # # if i < n && ints [ i ] != NULL { # node . Left = & TreeNode { Val : ints [ i ]} # queue = append ( queue , node . Left ) # } # i ++ # # if i < n && ints [ i ] != NULL { # node . Right = & TreeNode { Val : ints [ i ]} # queue = append ( queue , node . Right ) # } # i ++ # } # # return root
ms := newOrderMap () # ms . insert (" STR ", " STR ") # ms . insert (" STR ", " STR ") # ms . printAll () #
fmt . Println ( strconv . Itoa ( 1 )) # fmt . Println ( strings . Compare (" STR "," STR ")) # fmt . Println ( math . Abs ( 1 . 0 )) # fmt . Println ( unicode . IsDigit (' 1 '))
qs := [] question 1 3 1 3 { # # { # para 1 3 1 3 {[] int { 1 , 2 , 3 , 4 }}, # ans 1 3 1 3 {[] int { 2 , 4 , 4 , 4 }}, # }, # # { # para 1 3 1 3 {[] int { 1 , 1 , 2 , 3 }}, # ans 1 3 1 3 {[] int { 1 , 3 , 3 }}, # }, # # { # para 1 3 1 3 {[] int {}}, # ans 1 3 1 3 {[] int {}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 3 1 3 , q . para 1 3 1 3 # fmt . Printf (" STR ", p ) # fmt . Printf (" STR ", decompressRLElist ( p . nums )) # } # fmt . Printf (" STR ")
a := A [ 0 ] # res := 0 # for j := 1 ; j < len ( A ); j ++ { # res = max ( res , a + A [ j ]- j ) # a = max ( a , A [ j ]+ j ) # } # return res
return root == nil || isSymmetricHelper ( root . Left , root . Right )
divisors := 1 # triangleN := uint 6 4 ( 1 ) # for i := 2 ; divisors < 5 0 0 ; i ++ { # triangleN += uint 6 4 ( i ) # divisors = noOfDivisors ( triangleN ) # } # println ( triangleN )
start := time . Date ( 1 9 0 1 , time . January , 1 , 1 2 , 0 , 0 , 0 , time . UTC ) # end := time . Date ( 2 0 0 0 , time . December , 3 1 , 1 2 , 0 , 0 , 0 , time . UTC ) # oneDay := time . Hour * 2 4 # counter := 0 # # for start != end { # if start . Weekday () == time . Sunday && start . Day () == 1 { # counter ++ # } # start = start . Add ( oneDay ) # } # fmt . Println ( counter )
n := len ( stations ) # gases := intHeap {} # miles , res := startFuel , 0 # i := 0 # for { # if miles >= target { # return res # } # # for i < n && stations [ i ][ 0 ] <= miles { # heap . Push (& gases , stations [ i ][ 1 ]) # i ++ # } # # if len ( gases ) == 0 { # break # } # gas := heap . Pop (& gases ).( int ) # res ++ # miles += gas # } # return - 1
m := map [ string ] struct {}{} # for _ , word := range words { # m [ word ] = struct {}{} # } # for _ , word := range words { # for i := 1 ; i < len ( word ); i ++ { # delete ( m , word [ i :]) # } # } # res := 0 # for word := range m { # res += len ( word ) + 1 # } # return res
var nums 1 [] int # var nums 2 [] int # var ret [] int # # nums 1 = [] int { 1 , 2 , 2 , 1 } # nums 2 = [] int { 2 , 2 } # ret = [] int { 2 } # for i , v := range intersection ( nums 1 , nums 2 ) { # if v != ret [ i ] { # t . Fatalf (" STR ", ret ) # } # } # # nums 1 = [] int {} # nums 2 = [] int { 2 , 2 } # ret = [] int {} # fmt . Println ( intersection ( nums 1 , nums 2 )) # for i , v := range intersection ( nums 1 , nums 2 ) { # if v != ret [ i ] { # t . Fatalf (" STR ", ret ) # } # }
return s 1 != s 2
fmt . Println ( getSumOfArrayItems ( getMultiples ( 1 0 ))) # fmt . Println ( getSumOfArrayItems ( getMultiples ( 1 0 0 0 )))
log . Printf (" STR ", term ) # # var r [] Result # # time . Sleep ( time . Millisecond * time . Duration ( rand . Int 6 3 n ( 9 0 0 ))) # # r = append ( r , Result { # Engine : " STR ", # Title : " STR ", # Description : " STR ", # Link : " https : , # }) # # log . Printf (" STR ", len ( r )) # results <- r
s . data = append ( s . data , v )
if len ( s ) == 1 { # return s # } # ans := "" # ansLength := 0 # # for i := 0 ; i < len ( s ); i ++ { # for j := len ( s ); j > i + ansLength ; j -- { # subString := s [ i : j ] # if isPalindrome ( subString ) && len ( subString ) > ansLength { # ans = subString # ansLength = len ( subString ) # } # } # } # # return ans
size := len ( stones ) # if ( size - 1 )%( K - 1 ) != 0 { # return - 1 # } # # sum := [ 3 1 ] int {} # for i := 0 ; i < size ; i ++ { # sum [ i + 1 ] = sum [ i ] + stones [ i ] # } # # dp := [ 3 1 ][ 3 1 ] int {} # # for width := K ; width <= size ; width ++ { # for l := 0 ; l + width <= size ; l ++ { # r := l + width - 1 # dp [ l ][ r ] = 1 << 3 2 # for m := l ; m < r ; m += K - 1 { # dp [ l ][ r ] = min ( dp [ l ][ r ], dp [ l ][ m ]+ dp [ m + 1 ][ r ]) # } # if ( r - l )%( K - 1 ) == 0 { # dp [ l ][ r ] += sum [ r + 1 ] - sum [ l ] # } # } # } # # return dp [ 0 ][ size - 1 ]
var r , g , b float 6 4 # if s == 0 { # r , g , b = l , l , l # } else { # var q , p float 6 4 # if l < 0 . 5 { # q = l * ( 1 + s ) # } else { # q = l + s - l * s # } # p = 2 * l - q # r = hueToRGB ( p , q , h + 1 . 0 / 3 . 0 ) # g = hueToRGB ( p , q , h ) # b = hueToRGB ( p , q , h - 1 . 0 / 3 . 0 ) # } # return color . RGBA { R : uint 8 ( r * 2 5 5 ), G : uint 8 ( g * 2 5 5 ), B : uint 8 ( b * 2 5 5 ), A : 2 5 5 }
sort . Ints ( g ) # sort . Ints ( s ) # var ans , i , j int # for i < len ( g ) && j < len ( s ) { # if g [ i ] <= s [ j ] { # ans , i = ans + 1 , i + 1 # } # j ++ # } # return ans
isSub := func ( w string ) int { # f := 0 # for i := 0 ; i < len ( w ); i ++ { # if index := strings . IndexByte ( S [ f :], w [ i ]); index >= 0 { # f += index + 1 # } else { # return 0 # } # } # return 1 # } # sort . Strings ( words ) # p , a := " STR ", 1 # res := 0 # for _ , word := range words { # if word != p { # p , a = word , isSub ( word ) # } # res += a # } # return res
return eval ( expression , nil )
d , headIsNthFromEnd := getDaddy ( head , n ) # # if headIsNthFromEnd { # return head . Next # } # # d . Next = d . Next . Next # # return head
return performCreate ( nums , 0 )
arr := randomSlice ( 0 , 2 0 , 1 0 ) # bst := newBstRecrusive () # for _ , v := range arr { # bst . Insert ( uint 3 2 ( v )) # } # checkBstPreOrder ( t , bst )
cases := [] struct { # name string # inputs [] int # expect [] int # }{ # { # " STR ", # [] int { 1 , 2 , 3 , 3 , 4 , 4 , 5 }, # [] int { 1 , 2 , 5 }, # }, # { # " STR ", # [] int { 1 , 1 , 1 , 2 , 3 }, # [] int { 2 , 3 }, # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := Solution ( UnmarshalListBySlice ( c . inputs )) # if ! isEqual ( ret , UnmarshalListBySlice ( c . expect )) { # PrintList ( ret ) # PrintList ( UnmarshalListBySlice ( c . expect )) # t . Fatalf (" STR ", c . expect , ret , c . inputs ) # } # }) # }
benchmarkFramework ( b , InsertionSort )
_ , err := os . Stat ( path ) # if err == nil { # return true , nil # } # if os . IsNotExist ( err ) { # return false , nil # } # return false , err
if N . key == key { # N . val = value # return # } # if N . next == nil { # N . next = & HashNode { key , value , nil } # return # } # N . next . Put ( key , value )
for i , t := 1 , 1 ; t < 1 0 0 0 ; i , t = i + 1 , t + i + 1 { # triangle [ t ] = struct {}{} # }
testCases := [] map [ string ] string { # {" STR ": " STR ", " STR ": " STR "}, # {" STR ": " STR ", " STR ": " STR "}, # {" STR ": " STR ", " STR ": " STR "}, # {" STR ": " STR ", " STR ": " STR "}, # } # # for _ , testCase := range testCases { # if testCase [" STR "] != removeOuterParentheses ( testCase [" STR "]) { # t . Errorf (" STR ") # } # }
i , _ := g . edges [ vertex ] # if i != nil { # return errors . New (" STR ") # } # # g . edges [ vertex ] = make ( map [ VertexId ] int ) # # return nil
var tests = [] struct { # nums [] int # target int # sum int # }{ # {[] int {- 1 , 2 , 1 , - 4 }, 1 , 2 }, # {[] int {- 1 , 0 , 1 , 2 , - 1 , - 4 , - 4 }, 1 , 1 }, # } # # for _ , tt := range tests { # sum := threeSumClosest ( tt . nums , tt . target ) # if sum != tt . sum { # t . Errorf (" STR ", tt . nums , tt . target , sum , tt . sum ) # } # }
return bindataRead ( # _dataProfilesJson , # " STR ", # )
t := time . Date ( year , time . Month ( month ), day , 0 , 0 , 0 , 0 , time . UTC ) # return t . Weekday (). String ()
min := math . MaxInt 6 4 # # var prev * TreeNode # var f func (* TreeNode ) # f = func ( root * TreeNode ) { # if root == nil { # return # } # # f ( root . Left ) # if prev != nil && root . Val - prev . Val < min { # min = root . Val - prev . Val # } # prev = root # f ( root . Right ) # } # f ( root ) # # return min
l , r := 0 , len ( nums ) # # for l < r { # m := ( l + r ) / 2 # if nums [ m ] > target || ( left && target == nums [ m ]) { # r = m # } else { # l = m + 1 # } # } # return l
plus := 1 # for i := len ( digits ) - 1 ; i >= 0 ; i -- { # digits [ i ] += plus # if digits [ i ] >= 1 0 { # plus = 1 # digits [ i ] -= 1 0 # } else { # return digits # } # } # if plus == 1 { # digits = append ([] int { 1 }, digits ...) # } # return digits
if root == nil { # return # } # if len (* res ) <= depth { # * res = append (* res , [] int { root . Val }) # goto DFS # } # switch depth % 2 { # case 0 : # (* res )[ depth ] = append ((* res )[ depth ], root . Val ) # case 1 : # (* res )[ depth ] = append ([] int { root . Val }, (* res )[ depth ]...) # } # # DFS : # dfs ( root . Left , depth + 1 , res ) # dfs ( root . Right , depth + 1 , res )
return new ( insert ). init ( cost )
ss := make ( map [ rune ] int ) # for _ , c := range s { # ss [ c ]++ # } # # var nn , odd int # for _ , n := range ss { # if n % 2 == 0 { # nn += n # } else { # nn += n - 1 # odd = 1 # } # } # return nn + odd
start := time . Now () # log . Printf (" STR ", msg ) # return func () { log . Printf (" STR ", msg , time . Since ( start )) }
return [] int { i . Start , i . End }
_ , balanced := height ( root ) # return balanced
node := l . head # if node == nil { # return " STR " # } # # var b strings . Builder # # b . WriteByte ('(') # b . WriteString ( strconv . Itoa ( node . val )) # for node = node . next ; node != nil ; node = node . next { # b . WriteString (" STR ") # b . WriteString ( strconv . Itoa ( node . val )) # } # b . WriteByte (')') # # return b . String ()
var root * tree # for _ , v := range values { # root = add ( root , v ) # } # appendValues ( values [: 0 ], root )
tmp := make ( map [ int ] int ) # res := [] int {} # s := [][] int {} # for _ , v := range nums { # tmp [ v ]++ # } # for i , v := range tmp { # s = append ( s , [] int { i , v }) # } # sort . Slice ( s , func ( a , b int ) bool { # return s [ a ][ 1 ] > s [ b ][ 1 ] # }) # for i := 0 ; i < k ; i ++ { # res = append ( res , s [ i ][ 0 ]) # } # return res
var prev * TreeNode # recur ( root , & prev )
fmt . Println ( findMaxAverage ([] int { 0 , 1 , 1 , 3 , 3 }, 4 ))
res := 0 # for _ , char := range s { # res *= 2 6 # res += int ( char -' A ') + 1 # } # return res
return strings . Repeat ( str , n )
sort . Slice ( intervals , func ( i , j int ) bool { # if intervals [ i ][ 1 ] == intervals [ j ][ 1 ] { # return intervals [ i ][ 0 ] > intervals [ j ][ 0 ] # } # return intervals [ i ][ 1 ] < intervals [ j ][ 1 ] # }) # # l , r := intervals [ 0 ][ 1 ]- 1 , intervals [ 0 ][ 1 ] # res := 2 # for _ , interval := range intervals { # a , b := interval [ 0 ], interval [ 1 ] # if l < a && a <= r { # res ++ # l , r = r , b # } else if r < a { # res += 2 # l , r = b - 1 , b # } # } # return res
root := createBinaryTree ([] int { 1 , 2 , 3 , 4 , 5 }) # expected := 3 # # if res := maxDepth ( root ); res != expected { # t . Errorf (" STR ", expected , res ) # } #
maxSliceSize := uint 3 2 ( 1 0 2 4 ) # if ^ uintptr ( 0 ) <= 0 xffff { # maxSliceSize = 6 4 # } # for i := 0 ; i < 1 0 0 0 ; i ++ { # index := randuint 3 2 () % 4 # # rand := randSeeds [ index ] # for _ , b := range scalarSlices [ index ] { # rand = xorshift 3 2 ( rand ) # if b != byte ( rand ) { # panic (" STR ") # } # } # # sliceLen := randuint 3 2 () % maxSliceSize # slice := make ([] byte , sliceLen ) # cutLen := randuint 3 2 () % maxSliceSize # if cutLen < sliceLen { # slice = slice [ cutLen :] # } # scalarSlices [ index ] = slice # # rand = randuint 3 2 () + 1 # randSeeds [ index ] = rand # for i := 0 ; i < len ( slice ); i ++ { # rand = xorshift 3 2 ( rand ) # slice [ i ] = byte ( rand ) # } # } # println (" STR ")
bytes := [] byte ( s ) # var ret int # for i := range bytes { # ret = 2 6 * ret + int ( bytes [ i ]-' A '+ 1 ) # } # return ret
return IsUnknown ( Variable { # Type : n . Typex , # Value : n . Value , # })
return func ( acc float 6 4 ) float 6 4 { # return acc * n # }
countStr := " STR " # nStr := res [ n - 1 ] # for i := 0 ; i < len ( nStr ); i ++ { # cnt := 1 # currentChar := nStr [ i ] # for i + 1 < len ( nStr ) && nStr [ i + 1 ] == nStr [ i ] { # cnt ++ # i ++ # } # countStr = countStr + fmt . Sprint ( cnt ) + string ([] byte { currentChar }) # } # # return countStr
if list . head == nil { # return false # } # first := list . First () # # for { # if first . Val == value { # return true # } else { # if first . next != nil { # first = first . next # } else { # return false # } # } # } # # return false
t . Parallel () # for tcid , tc := range testcases { # if result := PruneZeroSubtrees ( tc . head ); ! treeEqual ( result , tc . expected ) { # t . Errorf (" STR ", tcid ) # } # }
cases := [] struct { # name string # inputs * ListNode # expect * ListNode # }{ # {" STR ", # & ListNode { Val : 1 , Next : & ListNode { Val : 2 , Next : & ListNode { Val : 3 , Next : & ListNode { Val : 4 , Next : nil }}}}, # & ListNode { Val : 2 , Next : & ListNode { Val : 1 , Next : & ListNode { Val : 4 , Next : & ListNode { Val : 3 , Next : nil }}}}, # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := swapPairs ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
if ! sl . Empty () { # element := sl . stack . Front () # sl . stack . Remove ( element ) # return element . Value , nil # } # return " STR "
if index == 2 { # return false # } # return true
err := da . CheckRangeFromIndex ( index ) # # if err != nil { # return err # } # # copy ( da . ElementData [ index :], da . ElementData [ index + 1 : da . Size ]) # da . ElementData [ da . Size - 1 ] = nil # # da . Size -- # # return nil
a , b := 5 , 8 # # fn := func ( sum int ) ( int , int ) { # x := sum * a / b # y := sum - x # return x , y # } # SplitValues ( fn ) # # fn 1 := func ( sum int ) ( int , int ) { # x := sum / a + b # y := sum - x # return x , y # } # SplitValues ( fn 1 ) #
if ans , ok := luke [ n ]; ok { # return ans # } # ans := lucas ( n - 1 ) + lucas ( n - 2 ) # luke [ n ] = ans # return ans
return & global { evenOrOdd : 0 , even : & singleton { 0 }, odd : & singleton { 1 }}
dp := make ([][] int , len ( coins )+ 1 ) # for k , _ := range dp { # item := make ([] int , amount + 1 ) # item [ 0 ] = 1 # dp [ k ] = item # fmt . Println ( item ) # } # for i := 1 ; i <= len ( coins ); i ++ { # for j := 1 ; j <= amount ; j ++ { # if j - coins [ i - 1 ] >= 0 { # dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - coins [ i - 1 ]] # } else { # dp [ i ][ j ] = dp [ i - 1 ][ j ] # } # } # } # return dp [ len ( coins )][ amount ]
l . item = token { itemError , fmt . Sprintf (" STR ", s , l . input [ l . start : l . pos ])} # return nil
max , sum := 0 , 0 # for i , v := range nums { # sum += v # if i == k - 1 { # max = sum # } else if i >= k { # sum -= nums [ i - k ] # } # if sum > max { # max = sum # } # } # return float 6 4 ( max ) / float 6 4 ( k )
sum , na := 0 , NumArray { make ([] int , len ( nums )+ 1 )} # na . sum [ 0 ] = 0 # for i , v := range nums { # sum += v # na . sum [ i + 1 ] = sum # } # return na
if p := e . next ; e . list != nil && p != & e . list . root { # return p # } # return nil
return res [ n - 1 ]
resultArr := make ([] int , 0 , 0 ) # expArr := make ([] int , 0 , 0 ) # bst . PostOrderWalk ( bst . Root (), func ( tree binaryTreeIf , node interface {}) bool { # n := node .(* bstElement ) # resultArr = append ( resultArr , int ( n . Key )) # return false # }) # # curNode := bst . Min ( bst . Root ()).(* bstElement ) # for curNode . right != nil { # curNode = bst . Min ( curNode . right ).(* bstElement ) # } # expArr = append ( expArr , int ( curNode . Key )) # for curNode . parent != nil { # nextNode := curNode . parent # if curNode == nextNode . left { # for nextNode . right != nil { # nextNode = bst . Min ( nextNode . right ).(* bstElement ) # } # } # curNode = nextNode # expArr = append ( expArr , int ( curNode . Key )) # } # # if ! reflect . DeepEqual ( resultArr , expArr ) { # t . Log ( fmt . Sprintf (" STR ", expArr ) + fmt . Sprintf (" STR ", resultArr )) # t . Fail () # }
n := len ( mat ) # # lo , hi := mat [ 0 ][ 0 ], mat [ n - 1 ][ n - 1 ] # # for lo < hi { # mid := lo + ( hi - lo )>> 1 # count := 0 # j := n - 1 # for i := 0 ; i < n ; i ++ { # for j >= 0 && mat [ i ][ j ] > mid { # j -- # } # count += j + 1 # } # # if count < k { # lo = mid + 1 # } else { # hi = mid # } # } # # return lo
cmap := newOpenHashMap () # for i := 0 ; i < 4 ; { # testHashMapDelete ( t , cmap ) # if ! reflect . DeepEqual ( cmap . Count , uint 3 2 ( 0 )) { # t . Log ( fmt . Sprintf (" STR ", 0 ) + fmt . Sprintf (" STR ", cmap . Count )) # t . Fail () # } # if ! reflect . DeepEqual ( cmap . Cap , uint 3 2 ( 0 )) { # t . Log ( fmt . Sprintf (" STR ", 0 ) + fmt . Sprintf (" STR ", cmap . Cap )) # t . Fail () # } # i ++ # }
pq := make ( ListNodeQueue , len ( lists )) # for i := range lists { # pq [ i ] = lists [ i ] # } # heap . Init (& pq ) # if pq . Len () < 1 { # return nil # } # # result := heap . Pop (& pq ).(* ListNode ) # if result == nil { # return result # } # if result . Next != nil { # heap . Push (& pq , result . Next ) # } # tail := result # for pq . Len () > 0 { # tail . Next = heap . Pop (& pq ).(* ListNode ) # tail = tail . Next # if tail == nil { # break # } # if tail . Next != nil { # heap . Push (& pq , tail . Next ) # } # } # # return result
for i := 0 ; i <= max ; i ++ { # if sumDivisors ( i ) > i { # abundant = append ( abundant , i ) # } # } # isSum := false # sum , a 1 , a 2 := 0 , 0 , 0 # for i := 0 ; i < max ; i ++ { # isSum = false # for a := range abundant { # a 1 = abundant [ a ] # for b := a ; b < len ( abundant ) && ! isSum ; b ++ { # a 2 = abundant [ b ] # if a 1 + a 2 == i { # fmt . Println (" STR ", i , " STR ", a 1 , " STR ", a 2 ) # isSum = true # } else if a 1 + a 2 > i { # break # } # } # } # if ! isSum { # sum += i # } # } # fmt . Println (" STR ", sum )
var sum int # for i := start ; i < end ; i ++ { # sum += l [ i ] # } # # return sum
t . Parallel () # expected := [] int { 2 , 3 , 5 , 7 , 1 1 , 1 3 , 1 7 , 1 9 , 2 3 , 2 9 , 3 1 , 3 7 , # 4 1 , 4 3 , 4 7 , 5 3 , 5 9 , 6 1 , 6 7 , 7 1 , 7 3 , 7 9 , 8 3 , 8 9 , 9 7 } # # if result := Sieve ( 1 0 0 ); ! reflect . DeepEqual ( expected , result ) { # t . Errorf (" STR ", expected , result ) # }
res , ok := memo . cache [ key ] # if ! ok { # res . value , res . err = memo . f ( key ) # memo . cache [ key ] = res # } # return res . value , res . err
return MyCalendar { head : & entry {}}
node , err := NewLiteralNode ( value , pos ) # if err != nil { # panic ( err ) # } # return node
qs := [] question 4 3 5 { # # { # para 4 3 5 {[][] int {{ 1 , 2 }, { 2 , 3 }, { 3 , 4 }, { 1 , 3 }}}, # ans 4 3 5 { 1 }, # }, # # { # para 4 3 5 {[][] int {{ 1 , 2 }, { 1 , 2 }, { 1 , 2 }}}, # ans 4 3 5 { 2 }, # }, # # { # para 4 3 5 {[][] int {{ 1 , 2 }, { 2 , 3 }}}, # ans 4 3 5 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 3 5 , q . para 4 3 5 # fmt . Printf (" STR ", p , eraseOverlapIntervals 1 ( p . one )) # } # fmt . Printf (" STR ")
return pc . c . Store ( cmd , key , value , flags , timeout , cas )
ans := 0 # for 0 != n { # n &= n - 1 # ans ++ # } # return ans
current := big . NewInt ( 1 ) # last := big . NewInt ( 0 ) # next := big . NewInt ( 0 ) # # # for i := 2 ; true ; i ++ { # # next = next . Add ( last , current ) # last . Set ( current ) # current . Set ( next ) # # bytes , _ := current . MarshalText () # # length := len ([] rune ( string ( bytes ))) # # if length == 1 0 0 0 { # # fmt . Println ( i ) # # return # } # # } #
sum := 0 # for i := range nums { # sum += nums [ i ] # } # # left := 0 # for i := range nums { # if left * 2 + nums [ i ] == sum { # return i # } # left += nums [ i ] # } # # return - 1
for len ( stones ) >= 2 { # n := len ( stones ) - 1 # sort . Ints ( stones ) # v := stones [ n ] - stones [ n - 1 ] # if v > 0 { # stones [ n - 1 ] = v # } else { # n -- # } # stones = stones [: n ] # } # stones = append ( stones , 0 ) # return stones [ 0 ]
if s == " STR " { # return true # } # s = strings . Replace ( s , " STR ", " STR ", - 1 ) # stack := list . New () # trMap := map [ string ] string { # " STR ": " STR ", # " STR ": " STR ", # " STR ": " STR ", # } # for v := range s { # switch s [ v : v + 1 ] { # case " STR ", " STR ", " STR ": # stack . PushBack ( s [ v : v + 1 ]) # case " STR ", " STR ", " STR ": # if stack . Len () == 0 || stack . Back (). Value != trMap [ s [ v : v + 1 ]] { # return false # } else { # stack . Remove ( stack . Back ()) # } # } # } # return stack . Len () == 0
t . Parallel () # # var stack ThreeStacks # # for i := 0 ; i < 1 0 0 ; i ++ { # stack . Push ( i , i % 3 ) # } # # for i := 9 9 ; i >= 0 ; i -- { # if v , err := stack . Pop ( i % 3 ); err != nil || v != i { # t . Errorf (" STR ", i , v , err ) # } # }
cases := [] struct { # name string # inputs [][] int # expect [][] int # }{ # {" STR ", [][] int {{ 1 , 1 , 0 }, { 1 , 0 , 1 }, { 0 , 0 , 0 }}, [][] int {{ 1 , 0 , 0 }, { 0 , 1 , 0 }, { 1 , 1 , 1 }}}, # {" STR ", [][] int {{ 1 , 1 , 0 , 0 }, { 1 , 0 , 0 , 1 }, { 0 , 1 , 1 , 1 }, { 1 , 0 , 1 , 0 }}, [][] int {{ 1 , 1 , 0 , 0 }, { 0 , 1 , 1 , 0 }, { 0 , 0 , 0 , 1 }, { 1 , 0 , 1 , 0 }}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
count := 0 # for _ , d := range data { # if count == 0 { # if d >= 2 4 8 { # return false # } else if d >= 2 4 0 { # count = 3 # } else if d >= 2 2 4 { # count = 2 # } else if d >= 1 9 2 { # count = 1 # } else if d > 1 2 7 { # return false # } # } else { # if d <= 1 2 7 || d >= 1 9 2 { # return false # } # count -- # } # } # return count == 0
if len ( haystack ) < len ( needle ) { # return - 1 # } # if len ( needle ) == 0 { # return 0 # } # # for i := 0 ; i <= len ( haystack )- len ( needle ); i ++ { # j := 0 # for ; j < len ( needle ); j ++ { # if haystack [ i + j ] != needle [ j ] { # break # } # } # # if j == len ( needle ) { # return i # } # } # return - 1
qs := [] question 3 3 1 { # # { # para 3 3 1 {" STR "}, # ans 3 3 1 { true }, # }, # # { # para 3 3 1 {" STR "}, # ans 3 3 1 { false }, # }, # # { # para 3 3 1 {" STR "}, # ans 3 3 1 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 3 1 , q . para 3 3 1 # fmt . Printf (" STR ", p , isValidSerialization ( p . one )) # } # fmt . Printf (" STR ")
for { # i := <- in # if i % prime != 0 { # out <- i # } # }
sd := [] int 3 2 { 1 , 6 , 3 , 2 , 1 9 2 3 , 1 2 3 , - 1 2 3 , - 2 9 , 3 , 0 , 1 } # sort . Slice ( sd , func ( i , j int ) bool { # return sd [ i ] > sd [ j ] # }) # println (" STR ") # for _ , d := range sd { # println ( d ) # } # # ud := [] uint 3 2 { 1 , 6 , 3 , 2 , 1 9 2 3 , 1 2 3 , 2 9 , 3 , 0 , 1 } # sort . Slice ( ud , func ( i , j int ) bool { # return ud [ i ] > ud [ j ] # }) # println (" STR ") # for _ , d := range ud { # println ( d ) # }
count := [ 1 0 0 1 ] int {} # trustSomebody := [ 1 0 0 1 ] bool {} # for _ , t := range trust { # count [ t [ 1 ]]++ # trustSomebody [ t [ 0 ]] = true # } # # for i := 1 ; i <= N ; i ++ { # if count [ i ] == N - 1 && ! trustSomebody [ i ] { # return i # } # } # # return - 1
tests := map [ int ] int { # 0 : 0 , # 1 : 0 , # 2 : 0 , # 3 : 1 , # 5 : 2 , # 7 : 3 , # 1 0 : 4 , # 1 0 0 : 2 5 , # 2 0 0 : 4 6 , # 3 0 0 : 6 2 , # } # # for in , want := range tests { # got := countPrimes ( in ) # if got != want { # t . Fatalf (" STR ", in , got , want ) # } # }
max := 1 << 6 3 - 1 # ai , aj := max , max # # for _ , ak := range a { # if ak <= ai { # ai = ak # } else if ak <= aj { # aj = ak # } else { # return true # } # } # # return false
if len ( inorder ) == 0 { # return nil # } # # i := findIndex ( inorder , preorder [ 0 ]) # return & TreeNode { # Val : preorder [ 0 ], # Left : buildTree ( preorder [ 1 : i + 1 ], inorder [: i ]), # Right : buildTree ( preorder [ i + 1 :], inorder [ i + 1 :]), # }
if s == "" { # return "", ErrEmpty # } # return strings . ToUpper ( s ), nil
if root == nil { # return true # } # # if root . Val <= min { # return false # } # # if root . Val >= max { # return false # } # # return validate ( root . Left , root . Val , min ) && validate ( root . Right , max , root . Val )
var a , b int # for i , v := range nums { # if i % 2 == 0 { # a = max ( a + v , b ) # } else { # b = max ( a , b + v ) # } # } # # return max ( a , b )
countA := 0 # # for i := 0 ; i < len ( s ); i ++ { # if s [ i ] == ' A ' { # countA ++ # } # if s [ i ] == ' L ' { # if i + 2 < len ( s ) && s [ i + 1 ] == ' L ' && s [ i + 2 ] == ' L ' { # return false # } # } # } # # if countA > 1 { # return false # } # return true
qs := [] question 8 5 0 { # # { # para 8 5 0 {[][] int {{ 0 , 0 , 3 , 3 }, { 2 , 0 , 5 , 3 }, { 1 , 1 , 4 , 4 }}}, # ans 8 5 0 { 1 8 }, # }, # # { # para 8 5 0 {[][] int {{ 0 , 0 , 1 , 1 }, { 2 , 2 , 3 , 3 }}}, # ans 8 5 0 { 2 }, # }, # # { # para 8 5 0 {[][] int {{ 0 , 0 , 2 , 2 }, { 1 , 0 , 2 , 3 }, { 1 , 0 , 3 , 1 }}}, # ans 8 5 0 { 6 }, # }, # # { # para 8 5 0 {[][] int {{ 0 , 0 , 1 0 0 0 0 0 0 0 0 0 , 1 0 0 0 0 0 0 0 0 0 }}}, # ans 8 5 0 { 4 9 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 5 0 , q . para 8 5 0 # fmt . Printf (" STR ", p , rectangleArea ( p . one )) # } # fmt . Printf (" STR ")
left , right := 0 , len ( nums )- 1 # for left < right && nums [ left ] >= nums [ right ] { # if left + 1 == right { # return nums [ right ] # } # # mid := ( left + right ) / 2 # if nums [ left ] == nums [ right ] && nums [ left ] == nums [ mid ] { # right -- # } else if nums [ mid ] >= nums [ left ] { # left = mid # } else { # right = mid # } # } # # return nums [ left ]
t := & tokenizer { # peekPos : start , # fset : fset , # buf : buf , # peekToken : token . ILLEGAL , # } # t . Next () # t . Next () # return t
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", [][] int {{ 3 , 2 , 1 , 5 , 6 , 4 }, { 2 }}, 5 }, # {" STR ", [][] int {{ 3 , 2 , 3 , 1 , 2 , 4 , 5 , 5 , 6 }, { 4 }}, 4 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := findKthLargest 2 ( c . inputs [ 0 ], c . inputs [ 1 ][ 0 ]) # if ! reflect . DeepEqual ( got , c . expect ) { # } # }) # }
res := make ([] string , 0 , 1 2 8 ) # for i := ' a '; i <= ' z '; i ++ { # sub := string ( i ) # count := strings . Count ( A [ 0 ], sub ) # for j := 1 ; j < len ( A ) && count > 0 ; j ++ { # count = min ( count , strings . Count ( A [ j ], sub )) # } # for count > 0 { # res = append ( res , sub ) # count -- # } # } # return res
line , err := c . readLine () # if err != nil { # return c . fatal ( err ) # } # switch { # case bytes . Equal ( line , replyOK ): # return nil # case bytes . Equal ( line , replyDeleted ): # return nil # case bytes . Equal ( line , replyNotFound ): # return ErrNotFound # } # return protocolError ( string ( line ))
a := uint 3 2 ( 2 ) # # for i := 0 ; i < 1 0 0 0 0 0 ; i ++ { # n , ok := slow_power ( a , i ) # # if ok != nil || n != uint 3 2 ( math . Pow ( float 6 4 ( a ), float 6 4 ( i ))) { # t . Error () # } # }
if m == 0 { # copy ( nums 1 , nums 2 ) # return # } # i := m - 1 # j := n - 1 # k := m + n - 1 # for ; i >= 0 && j >= 0 ; k -- { # if nums 1 [ i ] > nums 2 [ j ] { # nums 1 [ k ] = nums 1 [ i ] # i -- # } else { # nums 1 [ k ] = nums 2 [ j ] # j -- # } # } # for ; j >= 0 ; k -- { # nums 1 [ k ] = nums 2 [ j ] # j -- # }
if n == 1 || n == 0 { # return n # } # return Fibonacci ( n - 1 ) + Fibonacci ( n - 2 )
for n := 9 ; n < 1 0 0 0 0 0 ; n ++ { # val := getProductConcat ( n ) # if isPandigital ( val ) { # fmt . Print (" STR ") # for _ , r := range val { # fmt . Print ( uint 6 4 ( r - ' 0 ')) # } # fmt . Print (" STR ") # } # }
products := make ( map [ int ] bool ) # sum := 0 # var prod , compiled int # # for m := 2 ; m < 2 0 0 ; m ++ { # nbegin := 1 2 3 4 # if m > 9 { # nbegin = 1 2 3 # } # nend := 1 0 0 0 0 / m + 1 # for n := nbegin ; n < nend ; n ++ { # prod = m * n # compiled = concat ( concat ( prod , n ), m ) # if compiled >= 1 E 8 && compiled < 1 E 9 && isPandigital ( uint ( compiled )) { # products [ prod ] = true # } # } # } # for i := range products { # sum += i # } # return sum
table := [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "} # ret := [] string {} # if len ( digits ) > 0 { # help (& ret , digits , " STR ", 0 , table ) # } # return ret
for i , j := 0 , 0 ; j < len ( nums ); j ++ { # if nums [ j ] != 0 { # nums [ i ], nums [ j ] = nums [ j ], nums [ i ] # i ++ # } # }
stack , maxDepth , res := 0 , 0 , [] int {} # for _ , v := range seq { # if v == '(' { # stack ++ # maxDepth = max ( stack , maxDepth ) # } else { # stack -- # } # } # stack = 0 # for i := 0 ; i < len ( seq ); i ++ { # if seq [ i ] == '(' { # stack ++ # if stack <= maxDepth / 2 { # res = append ( res , 0 ) # } else { # res = append ( res , 1 ) # } # } else { # if stack <= maxDepth / 2 { # res = append ( res , 0 ) # } else { # res = append ( res , 1 ) # } # stack -- # } # } # return res
digits := [] rune ( n . String ()) # count := 0 # for _ , rune := range digits { # count += int ( rune ) - 4 8 # } # return count
sort . Ints ( nums ) # # res := make ([][] int , 0 ) # f := func ( nums [] int , begin int , end int , target int ) { # for begin < end { # if nums [ begin ]+ nums [ end ]+ target == 0 { # r := make ([] int , 0 ) # r = append ( r , nums [ begin ], nums [ end ], target ) # res = append ( res , r ) # for begin < end && nums [ begin ] == nums [ begin + 1 ] { # begin ++ # } # for begin < end && nums [ end ] == nums [ end - 1 ] { # end -- # } # begin ++ # end -- # } else if ( target + nums [ begin ] + nums [ end ]) < 0 { # begin ++ # } else { # end -- # } # } # } # l := len ( nums ) # for i := 0 ; i < l - 2 ; i ++ { # if i > 0 && nums [ i ] == nums [ i - 1 ] { # continue # } # f ( nums , i + 1 , l - 1 , nums [ i ]) # } # return res
tests := [...] testType { # { # in : [] byte {' a ', ' a ', ' b ', ' b ', ' c ', ' c ', ' c '}, # want : [] byte {' a ', ' 2 ', ' b ', ' 2 ', ' c ', ' 3 '}, # }, # { # in : [] byte {' a '}, # want : [] byte {' a '}, # }, # { # in : [] byte {' a ', ' a '}, # want : [] byte {' a ', ' 2 '}, # }, # { # in : [] byte {' a ', ' b ', ' b ', ' b ', ' b ', ' b ', ' b ', ' b ', ' b ', ' b ', ' b ', ' b ', ' b '}, # want : [] byte {' a ', ' b ', ' 1 ', ' 2 '}, # }, # } # for _ , tt := range tests { # l := compress ( tt . in ) # if ! reflect . DeepEqual ( tt . in [: l ], tt . want ) { # t . Fatalf (" STR ", tt . in , l , tt . want ) # } # }
parent := this # for _ , ch := range word { # if child , ok := parent . Children [ ch ]; ok { # parent = child # continue # } # return false # } # return parent . IsTerminated
qs := [] question 2 0 5 { # # { # para 2 0 5 {" STR ", " STR "}, # ans 2 0 5 { true }, # }, # # { # para 2 0 5 {" STR ", " STR "}, # ans 2 0 5 { false }, # }, # # { # para 2 0 5 {" STR ", " STR "}, # ans 2 0 5 { true }, # }, # # { # para 2 0 5 {" STR ", " STR "}, # ans 2 0 5 { true }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 0 5 , q . para 2 0 5 # fmt . Printf (" STR ", p , isIsomorphic ( p . one , p . two )) # } # fmt . Printf (" STR ")
dirs := [ 4 ][ 2 ] int {{- 1 , 0 }, { 1 , 0 }, { 0 , - 1 }, { 0 , 1 }} # oldColor := image [ sr ][ sc ] # if oldColor == newColor { # return image # } # m , n := len ( image ), len ( image [ 0 ]) # var fill func ( int , int ) # fill = func ( r , c int ) { # image [ r ][ c ] = newColor # # for _ , dir := range dirs { # x , y := r + dir [ 0 ], c + dir [ 1 ] # if 0 <= x && x < m && 0 <= y && y < n && # image [ x ][ y ] == oldColor { # fill ( x , y ) # } # } # } # fill ( sr , sc ) # return image
return n .(* gbtElement ) == t . NilNode
if val < 0 { # return " STR " + uitoa ( uint (- val )) # } # return uitoa ( uint ( val ))
i := & Index { # Target : & VariableAccess { Name : " STR "}, # Key : & LiteralNode { # Typex : TypeInt , # Value : 1 , # }, # } # # scope := & BasicScope { # VarMap : map [ string ] Variable { # " STR ": Variable { # Type : TypeList , # Value : [] Variable { # Variable { # Type : TypeString , # Value : " STR ", # }, # Variable { # Type : TypeString , # Value : " STR ", # }, # }, # }, # }, # } # # actual , err := i . Type ( scope ) # if err != nil { # t . Fatalf (" STR ", err ) # } # if actual != TypeString { # t . Fatalf (" STR ", actual ) # }
mod := 1 0 0 0 0 0 0 0 0 7 # if A < B { # A , B = B , A # } # lcm := A * B / gcd ( A , B ) # l , r := B * N / 2 , A * N # for l < r { # m := ( l + r ) / 2 # if m / A + m / B - m / lcm < N { # l = m + 1 # } else { # r = m # } # } # return l % mod
kthLarges := Constructor 1 ( 3 , [] int { 4 , 5 , 8 , 2 }) # # fmt . Println ( kthLarges . Add ( 3 )) # fmt . Println ( kthLarges . Add ( 5 )) # fmt . Println ( kthLarges . Add ( 1 0 )) # fmt . Println ( kthLarges . Add ( 9 )) # fmt . Println ( kthLarges . Add ( 4 ))
Trace . Println (" STR ") # Info . Println (" STR ") # Warning . Println (" STR ") # Error . Println (" STR ")
server , err := net . Listen (" STR ", " STR ") # if err != nil { # log . Fatalln ( err . Error ()) # } # defer server . Close () # # for { # conn , err := server . Accept () # if err != nil { # log . Fatalln ( err . Error ()) # } # go handleConn ( conn ) # }
var ( # currentValue = 3 # currentPrimeIndex = 1 # ) # # for ; ; currentValue += 2 { # if isPrime ( currentValue ) { # currentPrimeIndex ++ # if currentPrimeIndex == 1 0 0 0 1 { # break # } # } # } # fmt . Println ( currentValue )
this . mutex . Lock () # defer this . mutex . Unlock () # # return this . queues [ this . top ]. Peek ()
t . Parallel () # # for _ , tc := range testcases { # if result := MaxRemovedEdgesEvenSubtrees ( tc . tree ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
mat := make ([][] int , n ) # for i , _ := range mat { # mat [ i ] = make ([] int , m ) # } # for _ , val := range indices { # r , c := val [ 0 ], val [ 1 ] # for i := 0 ; i < m ; i ++ { # mat [ r ][ i ]++ # } # for i := 0 ; i < n ; i ++ { # mat [ i ][ c ]++ # } # } # c := 0 # for i := 0 ; i < n ; i ++ { # for j := 0 ; j < m ; j ++ { # if mat [ i ][ j ]% 2 == 1 { # c ++ # } # } # } # return c
return binary . Read ( r , binary . BigEndian , i )
var strIndex int = 0 # return conFromPreStrHelper ( str , & strIndex )
if len ( arr ) <= 1 { # return arr # } # # median := arr [ rand . Intn ( len ( arr ))] # # low_part := make ([] int , 0 , len ( arr )) # high_part := make ([] int , 0 , len ( arr )) # middle_part := make ([] int , 0 , len ( arr )) # # for _ , item := range arr { # switch { # case item < median : # low_part = append ( low_part , item ) # case item == median : # middle_part = append ( middle_part , item ) # case item > median : # high_part = append ( high_part , item ) # } # } # # low_part = quick_sort ( low_part ) # high_part = quick_sort ( high_part ) # # low_part = append ( low_part , middle_part ...) # low_part = append ( low_part , high_part ...) # # return low_part
self . top -- # value := self . slots [ self . top ]. Ref # self . slots [ self . top ]. Ref = nil # return value
n := node .(* gbtElement ) # # leftistNode := func ( curNode * gbtElement ) ( nextNode * gbtElement ) { # nextNode = curNode # for ! t . IsNil ( nextNode . Right ) { # nextNode = t . Min ( nextNode . Right ).(* gbtElement ) # } # return # } # # for curNode := leftistNode ( t . Min ( n ).(* gbtElement )); curNode != n ; { # stop := callback ( t . Object , curNode ) # if stop { # return true # } # parentNode := curNode . Parent # if curNode == parentNode . Left { # curNode = leftistNode ( parentNode ) # } else { # curNode = parentNode # } # # } # return callback ( t , n )
for i := 0 ; i < len ( nums ); i ++ { # for nums [ i ] != nums [ nums [ i ]- 1 ] { # nums [ i ], nums [ nums [ i ]- 1 ] = nums [ nums [ i ]- 1 ], nums [ i ] # } # } # # res := make ([] int , 0 , len ( nums )) # # for i , n := range nums { # if n != i + 1 { # res = append ( res , i + 1 ) # } # } # # return res
input := " STR " # # for i := 0 ; i < b . N ; i ++ { # IsBalanced ( input ) # }
ans := 0 # # for i := 0 ; i < len ( points ); i ++ { # dict := make ( map [ int ] int , 0 ) # for j := 0 ; j < len ( points ); j ++ { # if i == j { # continue # } # # d := getDistance ( points [ i ], points [ j ]) # dict [ d ]++ # } # # for _ , v := range dict { # ans += v * ( v - 1 ) # } # } # # return ans
if err != nil { # _ , file , line , _ := runtime . Caller ( 1 ) # fmt . Printf (" STR ", filepath . Base ( file ), line , err . Error ()) # tb . FailNow () # }
ans := 0 # for _ , value := range s { # ans = int ( value ) - int (' A ') + 1 + ans * 2 6 # } # return ans
words := strings . Split ( str , " STR ") # if len ( pattern ) != len ( words ) { # return false # } # # dictPattern := make ( map [ byte ] int ) # dictString := make ( map [ string ] int ) # for i := 0 ; i < len ( pattern ); i ++ { # patternValue := dictPattern [ pattern [ i ]] # dictPattern [ pattern [ i ]] = i + 1 # # stringValue := dictString [ words [ i ]] # dictString [ words [ i ]] = i + 1 # # if patternValue != stringValue { # return false # } # } # return true
res , prefixSum := len ( A )+ 1 , make ([] int , len ( A )+ 1 ) # for i := 0 ; i < len ( A ); i ++ { # prefixSum [ i + 1 ] = prefixSum [ i ] + A [ i ] # } # deque := [] int {} # for i := range prefixSum { # for len ( deque ) > 0 && prefixSum [ i ]- prefixSum [ deque [ 0 ]] >= K { # length := i - deque [ 0 ] # if res > length { # res = length # } # deque = deque [ 1 :] # } # for len ( deque ) > 0 && prefixSum [ i ] <= prefixSum [ deque [ len ( deque )- 1 ]] { # deque = deque [: len ( deque )- 1 ] # } # deque = append ( deque , i ) # } # if res <= len ( A ) { # return res # } # return - 1
if 0 == len ( needle ) { # return 0 # } # # for i , j := 0 , 0 ; i <= len ( haystack )- len ( needle ); i ++ { # for j = 0 ; j < len ( needle ); j ++ { # if haystack [ i + j ] != needle [ j ] { # break # } # } # if len ( needle ) == j { # return i # } # } # return - 1
return ( a + b + players + players ) % players
if n < 2 { # return 1 # } # # res := make ([] int , n ) # res [ 0 ], res [ 1 ] = 1 , 2 # for i := 2 ; i < n ; i ++ { # res [ i ] = res [ i - 1 ] + res [ i - 2 ] # } # return res [ n - 1 ]
ans := make ([] int , 0 ) # if nil == root { # return ans # } # # max , count , pre := 1 , 0 , root . Val # traverse ( root , & ans , & max , & count , & pre ) # return ans
i , j , k := m - 1 , n - 1 , m + n - 1 # for i >= 0 || j >= 0 { # if j < 0 || ( i >= 0 && nums 1 [ i ] >= nums 2 [ j ]) { # nums 1 [ k ] = nums 1 [ i ] # k , i = k - 1 , i - 1 # } else { # nums 1 [ k ] = nums 2 [ j ] # k , j = k - 1 , j - 1 # } # }
t , _ := time . Parse (" STR ", date ) # return t . YearDay ()
v := reflect . ValueOf ( s ) # if v . Kind () == reflect . Ptr { # v = v . Elem () # } # # if v . Kind () == reflect . Invalid { # return false # } # # return v . Kind () == reflect . Struct
t . Parallel () # for _ , tc := range testcases { # if result := LargestProductOf 3 ( tc . input ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
return Trie { isWord : false , children : make ( map [ rune ]* Trie )}
var maxGap int # for N > 0 && N & 1 == 0 { # N >>= 1 # } # for i := 0 ; N > 0 ; N >>= 1 { # switch N & 1 { # case 0 : # i ++ # case 1 : # if i > maxGap { # maxGap = i # } # i = 1 # } # } # return maxGap
var rev uint 3 2 # offset := uint ( 3 2 ) # for num != 0 { # offset -- # rev <<= 1 # if num & 1 == 1 { # rev ^= 1 # } # num >>= 1 # } # return rev << offset
a , b , sum := 1 , 2 , 0 # for b < 4 0 0 0 0 0 0 { # if b % 2 == 0 { # sum += b # } # a , b = b , a + b # } # println ( sum )
ones , twos := 0 , 0 # for i := 0 ; i < len ( nums ); i ++ { # ones = ( ones ^ nums [ i ]) & ^ twos # twos = ( twos ^ nums [ i ]) & ^ ones # } # return ones
return t . IsNil ( node ) || node . SideValue .( bool )
if head == nil { # return nil # } # size := 1 # var end * LL # for end = head ; end . Next != nil ; end = end . Next { # size ++ # } # if k % size == 0 { # return head # } # k %= size # curr := head # for i := 0 ; i < k - 1 ; i ++ { # curr = curr . Next # } # newHead := curr . Next # curr . Next = nil # end . Next = head # return newHead
var result [] string # marked := make ( map [ string ] int ) # for n := range prereq { # if _ , found := marked [ n ]; ! found { # newest := visit ( n , prereq , marked , result ) # if len ( newest ) > len ( result ) { # result = newest # } # } # } # if len ( marked ) != len ( prereq ) { # return nil # } # reverse ( result ) # return result
var T = struct { # A string # B int # C bool # }{ # A : " STR ", # B : 2 , # C : true , # } # # s := Names ( T ) # # if len ( s ) != 3 { # t . Errorf (" STR ", len ( s )) # } # # inSlice := func ( val string ) bool { # for _ , v := range s { # if reflect . DeepEqual ( v , val ) { # return true # } # } # return false # } # # for _ , val := range [] string {" STR ", " STR ", " STR "} { # if ! inSlice ( val ) { # t . Errorf (" STR ", val ) # } # }
if S == T { # return 0 # } # # hasT := false # buses := make ( map [ int ][] int , len ( routes )) # for i , route := range routes { # for _ , r := range route { # buses [ r ] = append ( buses [ r ], i ) # if r == T { # hasT = true # } # } # } # if ! hasT { # return - 1 # } # # visited := map [ int ] struct {}{} # q := [] int { S } # res := 0 # for len ( q ) != 0 { # n := len ( q ) # res ++ # for i := 0 ; i < n ; i ++ { # cur := q [ i ] # bs := buses [ cur ] # for _ , bus := range bs { # if _ , ok := visited [ bus ]; ok { # continue # } # visited [ bus ] = struct {}{} # for _ , r := range routes [ bus ] { # if r == T { # return res # } # q = append ( q , r ) # } # } # } # q = q [ n :] # } # return - 1
var tests = [] struct { # n int # s string # }{ # { 1 , " STR "}, # { 2 , " STR "}, # { 3 , " STR "}, # { 4 , " STR "}, # { 5 , " STR "}, # } # # for _ , tt := range tests { # s := countAndSay ( tt . n ) # if s != tt . s { # t . Errorf (" STR ", tt . n , s , tt . s ) # } # }
for i := 0 ; i < b . N ; i ++ { # IsPalindrome (" STR ") # }
N := len ( D ) # # dp := make ([][] int , N ) # for i := 0 ; i < N ; i ++ { # dp [ i ] = make ([] int , N ) # dp [ i ][ i ] = 0 # } # # for l := 2 ; l < N ; l ++ { # for i := 1 ; i < N - l + 1 ; i ++ { # j := i + l - 1 # dp [ i ][ j ] = 1 << 3 1 # for k := i ; k < j ; k ++ { # prod := dp [ i ][ k ] + dp [ k + 1 ][ j ] + D [ i - 1 ]* D [ k ]* D [ j ] # dp [ i ][ j ] = Min ( prod , dp [ i ][ j ]) # } # } # } # # return dp [ 1 ][ N - 1 ]
return t . root
goType := reflect . TypeOf ( value ) # var hilType Type # # switch goType . Kind () { # case reflect . Bool : # hilType = TypeBool # case reflect . Int : # hilType = TypeInt # case reflect . Float 6 4 : # hilType = TypeFloat # case reflect . String : # hilType = TypeString # default : # return nil , fmt . Errorf (" STR ", value ) # } # # return & LiteralNode { # Value : value , # Typex : hilType , # Posx : pos , # }, nil
sum := 0 # for i := 0 ; i < 2 ; i ++ { # n := <- ch # sum += n # } # println (" STR ", sum ) # wg . Done ()
return len ( stackArray ) == 0
 return letterCount ()
max , mult , n := 0 , 1 0 , 1 # for i := 1 ; i < 9 9 9 9 9 9 9 ; i ++ { # if mult / i == 0 { # mult *= 1 0 # n ++ # } # if isNPandigital ( i , n ) && isPrime ( i ) { # max = i # } # } # fmt . Println (" STR ", max )
ret , depth , maxDepth := 0 , - 1 , n - 1 # nextIndex := make ([] int , n ) # stack := [] int {} # for { # L : # for depth < maxDepth { # for { # childDepth := depth + 1 # if nextIndex [ childDepth ] == n { # nextIndex [ childDepth ] = 0 # break L # } # index := nextIndex [ childDepth ] # nextIndex [ childDepth ]++ # if isValid ( stack , childDepth , index ) { # stack = append ( stack , index ) # break # } # } # depth ++ # } # if depth == maxDepth { # ret ++ # } # if depth == - 1 { # break # } # depth -- # stack = stack [: len ( stack )- 1 ] # } # return ret
target := int 6 4 ( 6 0 0 8 5 1 4 7 5 1 4 3 ) # arr := make ([] bool , 1 0 0 0 0 ) # prime := 3 # var k int # for { # for k = 2 * prime ; k < len ( arr ); k += prime { # arr [ k ] = true # } # for k = prime + 2 ; k < len ( arr ) && arr [ k ]; k += 2 { # } # if k < len ( arr ) { # prime = k # if target % int 6 4 ( k ) == 0 { # target = target / int 6 4 ( k ) # if target == 1 { # println ( k ) # return # } # } # } else { # break # } # }
if len ( s ) == 0 { # return nil # } # # minIndex := 0 # # for i := range s { # if s [ i ] < s [ minIndex ] { # minIndex = i # } # } # # root := & IntBinaryTree { s [ minIndex ], nil , nil } # root . Left = CartesianTree ( s [: minIndex ]) # root . Right = CartesianTree ( s [ minIndex + 1 :]) # # return root
if head == nil || head . Next == nil { # return head # } # newHead := head . Next # newHead . Next , head . Next = head , swapPairs ( newHead . Next ) # return newHead
res := [][] int {} # var dfs func ( int , int , int , [] int ) # dfs = func ( level , start , n int , path [] int ) { # if level == k && n == 0 { # tmp := make ([] int , len ( path )) # copy ( tmp , path ) # res = append ( res , tmp ) # return # } # for i := start ; i <= n && i < 1 0 ; i ++ { # path = append ( path , i ) # dfs ( level + 1 , i + 1 , n - i , path ) # path = path [: len ( path )- 1 ] # } # } # dfs ( 0 , 1 , n , [] int {}) # return res
qs := [] question 7 7 1 { # { # para 7 7 1 {" STR ", " STR "}, # ans 7 7 1 { 3 }, # }, # # { # para 7 7 1 {" STR ", " STR "}, # ans 7 7 1 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 7 1 , q . para 7 7 1 # fmt . Printf (" STR ", p , numJewelsInStones ( p . one , p . two )) # } # fmt . Printf (" STR ")
str 1 := [] rune ( num 1 ) # str 2 := [] rune ( num 2 ) # ans := make ([] rune , 0 ) # var carry rune = 0 # for i , j := len ( str 1 )- 1 , len ( str 2 )- 1 ; i >= 0 || j >= 0 || 1 == carry ; i , j = i - 1 , j - 1 { # var x , y rune = 0 , 0 # if i >= 0 { # x = str 1 [ i ] - ' 0 ' # } # if j >= 0 { # y = str 2 [ j ] - ' 0 ' # } # bit := ( x + y + carry )% rune ( 1 0 ) + ' 0 ' # carry = ( x + y + carry ) / rune ( 1 0 ) # ans = append ( ans , bit ) # } # # for i , j := 0 , len ( ans )- 1 ; i < j ; { # ans [ i ], ans [ j ] = ans [ j ], ans [ i ] # i ++ # j -- # } # return string ( ans )
i := 0 # for _ , s := range strings { # if s != "" { # strings [ i ] = s # i ++ # } # } # return strings [: i ]
for i := int ( math . Sqrt ( float 6 4 ( area ))); i > 1 ; i -- { # if area % i == 0 { # return [] int { area / i , i } # } # } # # return [] int { area , 1 }
b := make ([] byte , 0 , len ( s )) # cap := true # for _ , c := range s { # if c == '-' { # cap = true # continue # } # if cap && ' a ' <= c && c <= ' z ' { # c -= ' a ' - ' A ' # } # cap = false # b = append ( b , byte ( c )) # } # return string ( b )
t . Parallel () # # for _ , tc := range testcases { # if result := UniqueClimbs ( tc . steps , tc . strides ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
t . Log (" STR ")
word := strconv . Itoa ( num ) # center := int ( len ( word ) / 2 ) # equalNumbers := 0 # for i := 0 ; i < center ; i ++ { # if word [ i ] == word [ len ( word )-( i + 1 )] { # equalNumbers ++ # } # } # return equalNumbers == center
colors := [] int { 2 , 0 , 2 , 1 , 1 , 0 } # sortColors ( colors )
return recur ( n , 1 , [] int { 0 })
n := len ( A ) # dp := make ([] int , n + 1 ) # for l := 1 ; l <= n ; l ++ { # m := 0 # for k := 1 ; k <= K && 0 <= l - k ; k ++ { # m = max ( m , A [ l - k ]) # sum := dp [ l - k ] + m * k # dp [ l ] = max ( dp [ l ], sum ) # } # } # return dp [ n ]
dm , dsm , sign := true , true , true # if dividend < 0 { # dm = false # dividend = - dividend # } # if divisor < 0 { # dsm = false # divisor = - divisor # } # # if ( dm && ! dsm ) || (! dm && dsm ) { # sign = false # } # # if divisor == 0 { # return math . MaxInt 3 2 # } # # h := 0 # out := 0 # if dividend < divisor { # return 0 # } # for ( divisor << uint ( h )) <= dividend { # h ++ # } # h -- # for i := h ; i >= 0 ; i -- { # if dividend >= ( divisor << uint ( i )) { # dividend -= ( divisor << uint ( i )) # out |= 1 << uint ( i ) # } # } # # if ! sign { # out = - out # } # if out > math . MaxInt 3 2 { # return math . MaxInt 3 2 # } else if out < math . MinInt 3 2 { # return math . MinInt 3 2 # } else { # return out # }
ret := 1 # # if n == 1 { # return ret # } else if memory , has := memo [ n ]; has { # return memory + ret # } # # if n % 2 == 0 { # ret += countChain ( n / 2 ) # } else { # ret += countChain ( 3 * n + 1 ) # } # # memo [ n ] = ret # return ret
tests := [...] testType { # { # in : [] int { 3 , 0 , 1 }, # want : 2 , # }, # { # in : [] int { 0 , 1 , 2 , 4 , 5 , 6 }, # want : 3 , # }, # { # in : [] int { 9 , 6 , 4 , 2 , 3 , 5 , 7 , 0 , 1 }, # want : 8 , # }, # } # for _ , tt := range tests { # got := missingNumber ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
m , ans := make ( map [ int ] int ), - 1 # dfs ( root , 1 , m ) # fmt . Println ( m ) # for _ , v := range m { # if v > ans { # ans = v # } # print ( v ) # } # return ans
t . Parallel () # for _ , tc := range testcases { # if smallest := FindSmallestOnRotated ( tc . nums ); smallest != tc . smallest { # t . Errorf (" STR ", tc . smallest , smallest ) # } # }
start := 0 # success := 0 # # for i := 0 ; i <= len ( inputStr ); i ++ { # tmpSubstr := inputStr [ start : i ] # for j := 0 ; j < len ( dict ); j ++ { # if tmpSubstr == dict [ j ] { # start = i # success ++ # if success == len ( dict ) { # return true # } # } # # } # # } # # return false
t . Parallel () # # for _ , tc := range testcases { # if result := IsPowerFourBrute ( tc . n ); result != tc . isPowerFour { # t . Errorf (" STR ", tc . n , tc . isPowerFour , result ) # } # }
res := " STR " # var permute func ( int , int ) # permute = func ( l , r int ) { # if l == r { # if A [ 0 ]* 1 0 + A [ 1 ] < 2 4 && A [ 2 ] < 6 { # tmp := fmt . Sprintf (" STR ", A [ 0 ], A [ 1 ], A [ 2 ], A [ 3 ]) # if tmp > res { # res = tmp # } # } # } # for i := l ; i <= r ; i ++ { # A [ i ], A [ l ] = A [ l ], A [ i ] # permute ( l + 1 , r ) # A [ i ], A [ l ] = A [ l ], A [ i ] # } # } # permute ( 0 , len ( A )- 1 ) # return res
return n > 0 && 1 1 6 2 2 6 1 4 6 7 % n == 0
const count int = 1 0 0 # result := 0 # for i := 1 ; i <= 1 0 0 ; i ++ { # for j := 1 ; j <= 1 0 0 ; j ++ { # if i != j { # result += i * j # } # } # } # fmt . Println ( result )
M := N - len ( blacklist ) # m := make ( map [ int ] int , len ( blacklist )) # for _ , b := range blacklist { # m [ b ] = b # } # for _ , b := range blacklist { # if b >= M { # continue # } # # N -- # for m [ N ] == N { # N -- # } # m [ b ] = N # } # # return Solution { # M : M , # m : m , # } #
var sum , max = 0 , 0 # for _ , num := range nums { # sum += num # if num > max { # max = num # } # } # return sum , max
input := " STR " # # got := IsBalanced ( input ) # want := true # # if got != want { # t . Errorf (" STR ", input , got , want ) # }
arr := make ([] int , n ) # steps , maxSteps , cur , max , notFound := 0 , 0 , 0 , 0 , true # for i := 1 ; i < len ( arr ); i ++ { # notFound = true # cur = i # steps = 0 # for notFound { # if cur == 1 { # notFound = false # arr [ i ] = steps # if steps > maxSteps { # maxSteps = steps # max = i # } # } else if cur < i { # notFound = false # steps = steps + arr [ cur ] # arr [ i ] = steps # if steps > maxSteps { # maxSteps = steps # max = i # } # } else { # if cur % 2 == 0 { # cur /= 2 # } else { # cur = 3 * cur + 1 # } # } # steps ++ # } # } # return max
fmt . Println ( hasAlternatingBits 2 ( 5 )) # fmt . Println ( hasAlternatingBits 2 ( 7 ))
out := 2 1 1 2 4 # if x := p 1 7 (); x != out { # t . Errorf (" STR ", x , out ) # }
random := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # array := make ([] int , random . Intn ( 1 0 0 - 1 0 )+ 1 0 ) # for i := range array { # array [ i ] = random . Intn ( 1 0 0 ) # } # SortArray ( array ) # for _ , value := range array { # result := BinarySearch ( array , value ) # if result == - 1 { # t . Fail () # } # }
println (" STR ") # select {} # println (" STR ")
return WordDictionary { # root : & Trie {}, # }
fmt . Printf (" STR ", CmdName ) # fmt . Println (" STR ") # fmt . Printf (" STR ", CmdName ) # fmt . Println (" STR ") # for _ , cmd := range Commands { # if ! cmd . Hidden { # fmt . Printf (" STR ", cmd . Name (), cmd . Short ) # } # } # fmt . Printf (" STR ", CmdName )
if 0 == len ( data ) { # return true # } # switch { # case 0 x 0 0 == 0 x 8 0 & data [ 0 ]: # return validUtf 8 ( data [ 1 :]) # case 0 xC 0 == 0 xE 0 & data [ 0 ] && # len ( data ) > 1 && 0 x 8 0 == 0 xC 0 & data [ 1 ]: # return validUtf 8 ( data [ 2 :]) # case 0 xE 0 == 0 xF 0 & data [ 0 ] && # len ( data ) > 2 && 0 x 8 0 == 0 xC 0 & data [ 1 ] && # 0 x 8 0 == 0 xC 0 & data [ 2 ]: # return validUtf 8 ( data [ 3 :]) # case 0 xF 0 == 0 xF 8 & data [ 0 ] && # len ( data ) > 3 && 0 x 8 0 == 0 xC 0 & data [ 1 ] && # 0 x 8 0 == 0 xC 0 & data [ 2 ] && 0 x 8 0 == 0 xC 0 & data [ 3 ]: # return validUtf 8 ( data [ 4 :]) # } # return false
data , err := Asset ( name ) # if err != nil { # return err # } # info , err := AssetInfo ( name ) # if err != nil { # return err # } # err = os . MkdirAll ( _filePath ( dir , filepath . Dir ( name )), os . FileMode ( 0 7 5 5 )) # if err != nil { # return err # } # err = ioutil . WriteFile ( _filePath ( dir , name ), data , info . Mode ()) # if err != nil { # return err # } # err = os . Chtimes ( _filePath ( dir , name ), info . ModTime (), info . ModTime ()) # if err != nil { # return err # } # return nil
if pos < 1 { # return " STR " # } # pos -- # var ans [] rune # for pos >= 0 { # ans = append ( ans , ' A '+ rune ( pos % 2 6 )) # pos /= 2 6 # if pos == 0 { # pos = - 1 # } # pos -- # } # for i := 0 ; i < len ( ans )/ 2 ; i ++ { # ans [ i ], ans [ len ( ans )- 1 - i ] = ans [ len ( ans )- 1 - i ], ans [ i ] # } # return string ( ans )
if nil == M || len ( M ) <= 0 || len ( M [ 0 ]) <= 0 { # return nil # } # # nx , ny := len ( M ), len ( M [ 0 ]) # ans := make ([][] int , nx ) # for i := 0 ; i < nx ; i ++ { # ans [ i ] = make ([] int , ny ) # for j := 0 ; j < ny ; j ++ { # ans [ i ][ j ] = smooth ( M , i , j ) # } # } # return ans
return helper ( nums , 3 )
var tests = [] struct { # s string # r string # }{ # {" STR ", " STR "}, # {" STR ", " STR "}, # } # # for _ , tt := range tests { # r := reverseWords ( tt . s ) # if r != tt . r { # t . Errorf (" STR ", tt . s , r , tt . r ) # } # }
return new ( bstRecrusive )
var inorder [] interface {} # curr := root # for curr != nil { # if curr . Left == nil { # inorder = append ( inorder , curr . Value ) # curr = curr . Right # } else { # pre := curr . Left # for pre . Right != nil && pre . Right != curr { # pre = pre . Right # } # if pre . Right == nil { # pre . Right = curr # curr = curr . Left # } else { # pre . Right = nil # inorder = append ( inorder , curr . Value ) # curr = curr . Right # } # } # } # return inorder
start , end := 0 , len ( nums )- 1 # for { # if start > end { # break # } # mid := ( start + end ) / 2 # if nums [ mid ] == target { # return mid # } # if nums [ start ] <= nums [ mid ] { # if target >= nums [ start ] && target < nums [ mid ] { # end = mid - 1 # } else { # start = mid + 1 # } # } else { # if target > nums [ mid ] && target <= nums [ end ] { # start = mid + 1 # } else { # end = mid - 1 # } # } # } # return - 1
limit := int ( math . Sqrt ( float 6 4 ( c ))) # for i := 0 ; i <= limit ; i ++ { # k := c - i * i # tmp := int ( math . Sqrt ( float 6 4 ( k ))) # if tmp * tmp == k { # return true # } # # } # return false
if start > end { # return - 1 # } # # middleIndex := ( start + end ) / 2 # middleData := numbers [ middleIndex ] # if middleData == k { # if ( 0 < middleIndex && numbers [ middleIndex - 1 ] != k ) || 0 == middleIndex { # return middleIndex # } else { # end = middleIndex - 1 # } # } else if middleData > k { # end = middleIndex - 1 # } else { # start = middleIndex + 1 # } # return getFirstK ( numbers , k , start , end )
var tests = [] struct { # tree * TreeNode # sum int # }{ # { newTree (), 0 }, # { newTree ( 3 , 9 , 2 0 , nil , nil , 1 5 , 7 ), 2 4 }, # } # # for _ , tt := range tests { # sum := sumOfLeftLeaves ( tt . tree ) # if sum != tt . sum { # t . Errorf (" STR ", tt . tree , sum , tt . sum ) # } # }
testCases := [] int { 6 6 , 9 9 , 9 } # expected := [] int { 8 , 9 , 3 } # # for index , data := range testCases { # if res := mySqrt ( data ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
for root != nil { # if val < root . Val { # root = root . Left # } else if val > root . Val { # root = root . Right # } else { # break # } # } # return root
freq := make ( map [ int ] int ) # subtreeFreqCount ( head , freq ) # var result , mostFreq int # for sum , count := range freq { # if count > mostFreq { # mostFreq = count # result = sum # } # } # return result
i , j := 0 , len ( numbers )- 1 # for i < j { # sum := numbers [ i ] + numbers [ j ] # if sum < target { # i ++ # } else if sum > target { # j -- # } else { # return [] int { i + 1 , j + 1 } # } # } # return [] int { 0 , 0 }
low := - 1 # high := len ( nums ) # mid := ( low + high ) / 2 # # for low + 1 <= mid && mid < high - 1 { # if nums [ mid ] < nums [ mid + 1 ] { # low = mid # } else { # high = mid + 1 # } # mid = ( high + low ) / 2 # } # # return low + 1
p , q := 0 , len ( s )- 1 # for p < q { # s [ p ], s [ q ] = s [ q ], s [ p ] # p ++ # q -- # }
return & UnGraph { # graph { # edgesCount : 0 , # edges : make ( map [ VertexId ] map [ VertexId ] int ), # isDirected : false , # }, # }
var t * Tree # for _ , v := range inputArr { # # t = insert ( t , v ) # } # return t
var m [ 2 6 ] int # for _ , c := range s { # m [ c -' a ']++ # } # l := len ( s ) # ans := make ([] byte , 0 , l ) # appendChar := func ( c int ) { # if m [ c ] > 0 { # m [ c ]-- # l -- # ans = append ( ans , byte ( c +' a ')) # } # } # for l > 0 { # for i := 0 ; i <= 2 5 ; i ++ { # appendChar ( i ) # } # for i := 2 5 ; i >= 0 ; i -- { # appendChar ( i ) # } # } # return string ( ans )
n := len ( matrix ) # for i := 0 ; i < n / 2 ; i ++ { # for j := i ; j < n - i - 1 ; j ++ { # tmp := matrix [ i ][ j ] # matrix [ i ][ j ] = matrix [ n - j - 1 ][ i ] # matrix [ n - j - 1 ][ i ] = matrix [ n - i - 1 ][ n - j - 1 ] # matrix [ n - i - 1 ][ n - j - 1 ] = matrix [ j ][ n - i - 1 ] # matrix [ j ][ n - i - 1 ] = tmp # } # }
qs := [] question 3 5 7 { # # { # para 3 5 7 { 1 }, # ans 3 5 7 { 1 0 }, # }, # # { # para 3 5 7 { 2 }, # ans 3 5 7 { 9 1 }, # }, # # { # para 3 5 7 { 3 }, # ans 3 5 7 { 7 3 9 }, # }, # # { # para 3 5 7 { 4 }, # ans 3 5 7 { 5 2 7 5 }, # }, # # { # para 3 5 7 { 5 }, # ans 3 5 7 { 3 2 4 9 1 }, # }, # # { # para 3 5 7 { 6 }, # ans 3 5 7 { 1 6 8 5 7 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 5 7 , q . para 3 5 7 # fmt . Printf (" STR ", p , countNumbersWithUniqueDigits ( p . one )) # } # fmt . Printf (" STR ")
this . mutex . Lock () # defer this . mutex . Unlock () # err := this . rotate ( true ) # if err != nil { # return err # } # return this . currentFile . Close ()
fmt . Println ( convert (" STR ", 4 ))
k := arr [ i ] # arr [ i ] = arr [ j ] # arr [ j ] = k
ch := make ( chan string ) # go func () { # for _ , v := range s . fullNames { # ch <- v # } # close ( ch ) # }() # return ch
dp , stoneToIndex := make ([][] bool , len ( stones )), make ( map [ int ] int ) # for i , s := range stones { # dp [ i ] = make ([] bool , len ( stones )) # stoneToIndex [ s ] = i # } # # if stones [ 1 ] == 1 { # dp [ 0 ][ 1 ] = true # } # # for i := 1 ; i < len ( stones )- 1 ; i ++ { # for j := 0 ; j < i ; j ++ { # if dp [ j ][ i ] { # dist := stones [ i ] - stones [ j ] # dists := [ 3 ] int { dist , dist - 1 , dist + 1 } # for _ , d := range dists { # if d > 0 { # pos := stones [ i ] + d # if next , exists := stoneToIndex [ pos ]; exists { # dp [ i ][ next ] = true # } # } # } # } # } # } # # for i := 0 ; i < len ( stones ); i ++ { # if dp [ i ][ len ( stones )- 1 ] { # return true # } # } # # return false
tmp := make ([] int , 2 6 ) # temp := [] int {} # p := 1 # for _ , v := range tasks { # tmp [ v -" STR "]++ # } # for _ , v := range tmp { # temp = append ( temp , v ) # } # sort . Slice ( temp , func ( a , b int ) bool { # return temp [ a ] > temp [ b ] # }) # for i := 1 ; i < len ( temp ); i ++ { # if temp [ 0 ] == temp [ i ] { # p ++ # } # } # return max (( n + 1 )*( temp [ 0 ]- 1 )+ p , len ( tasks ))
if strings . IndexByte ( network , " STR ") != - 1 { # return " STR " # } else { # return " STR " # }
if root == nil { # return nil # } # root . Right , root . Left = root . Left , root . Right # invertTree ( root . Left ) # invertTree ( root . Right ) # return root
return & lexer { # input : input , # state : startRequest , # }
num 1 := Number ( 1 0 0 ) # num 2 := Number (- 5 0 ) # fmt . Printf (" STR ", num 1 , num 1 . Positive ()) # fmt . Printf (" STR ", num 2 , num 2 . Positive ()) #
return new ( kill ). init ( cost )
tests := [...] testType { # { # in : [] int { 5 , 2 , 3 , 1 }, # want : [] int { 1 , 2 , 3 , 5 }, # }, # { # in : [] int { 5 , 1 , 1 , 2 , 0 , 0 }, # want : [] int { 0 , 0 , 1 , 1 , 2 , 5 }, # }, # } # for _ , tt := range tests { # got := sortArray ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
sum := data [ 0 ] # for i := 1 ; i < 2 4 ; i ++ { # sum += data [ i ] # data [ i ] = sum # } # return & readOptimized { data : data }
if root == nil { # return nil # } # root . Left , root . Right = root . Right , root . Left # invertTree ( root . Left ) # invertTree ( root . Right ) # return root
if nums == nil || len ( nums ) < 2 { # return [] int {- 1 , - 1 } # } # # res := [] int {- 1 , - 1 } # # intMap := map [ int ] int {} # for i := 0 ; i < len ( nums ); i ++ { # if _ , ok := intMap [ target - nums [ i ]]; ok { # res [ 0 ] = intMap [ target - nums [ i ]] # res [ 1 ] = i # break # } # intMap [ nums [ i ]] = i # } # return res
t . Parallel () # for _ , tc := range testcases { # if path := LongestPath ( tc . weights ); path != tc . longestPath { # t . Errorf (" STR ", tc . longestPath , path ) # } # }
return permuteInternal ( A , 0 , " STR ")
tests := [...] testType { # { # in : 1 6 , # want : true , # }, # { # in : 5 , # want : false , # }, # { # in : 6 , # want : false , # }, # { # in : 1 2 , # want : false , # }, # { # in : 0 , # want : false , # }, # { # in : 1 , # want : true , # }, # } # for _ , tt := range tests { # got := isPowerOfFour ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
l := & ListNode { Next : head } # prev := l # for i := 0 ; i < m - 1 ; i ++ { # prev = prev . Next # } # head = prev . Next # # p , q := prev . Next , prev . Next . Next # for i := m ; i < n ; i ++ { # next := q . Next # q . Next = p # p , q = q , next # } # prev . Next , head . Next = p , q # return l . Next
for i , v := range values { # values [ i ] = v << 1 6 + labels [ i ] # } # # sort . Slice ( values , func ( i int , j int ) bool { # return values [ i ] > values [ j ] # }) # # count := [ 2 0 0 0 1 ] int {} # res := 0 # for _ , v := range values { # if count [ v & 0 xFFFF ] == use_limit { # continue # } # res += v >> 1 6 # count [ v & 0 xFFFF ]++ # num_wanted -- # if num_wanted == 0 { # break # } # } # # return res
if index > l . Len () { # return errors . New (" STR ") # } # # node := NewNode ( value ) # # if l . Len () == 0 || index == 0 { # l . Prepend ( value ) # return nil # } # # if l . Len ()- 1 == index { # l . Append ( value ) # return nil # } # # nextNode , _ := l . Get ( index ) # prevNode := nextNode . Prev # # prevNode . Next = node # node . Prev = prevNode # # nextNode . Prev = node # node . Next = nextNode # # l . Length ++ # # return nil
qs := [] question 1 5 1 { # # { # para 1 5 1 {" STR "}, # ans 1 5 1 {" STR "}, # }, # # { # para 1 5 1 {" STR "}, # ans 1 5 1 {" STR "}, # }, # { # para 1 5 1 {" STR "}, # ans 1 5 1 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 5 1 , q . para 1 5 1 # fmt . Printf (" STR ", p , reverseWords 1 5 1 ( p . one )) # } # fmt . Printf (" STR ")
var result int 6 4 # for 0 != x { # result = result * 1 0 + int 6 4 ( x % 1 0 ) # x /= 1 0 # } # # if result > math . MaxInt 3 2 || result < math . MinInt 3 2 { # return 0 # } # return int ( result )
fmt . Println ( maxChunksToSorted ([] int { 4 , 3 , 2 , 1 , 0 })) # fmt . Println ( maxChunksToSorted ([] int { 1 , 0 , 2 , 3 , 4 }))
obj := Constructor 7 0 5 () # obj . Add ( 7 ) # fmt . Printf (" STR ", obj . Contains ( 7 )) # obj . Remove ( 1 0 ) # fmt . Printf (" STR ", obj . Contains ( 1 0 )) # obj . Add ( 2 0 ) # fmt . Printf (" STR ", obj . Contains ( 2 0 )) # obj . Remove ( 3 0 ) # fmt . Printf (" STR ", obj . Contains ( 3 0 )) # obj . Add ( 8 ) # fmt . Printf (" STR ", obj . Contains ( 8 )) # obj . Remove ( 8 ) # fmt . Printf (" STR ", obj . Contains ( 8 )) # param 1 := obj . Contains ( 7 ) # fmt . Printf (" STR ", param 1 )
fmt . Println (" STR ") # # grid := [ GridSize + 1 ][ GridSize + 1 ] int 6 4 {} # # for i := 0 ; i <= GridSize ; i ++ { # grid [ 0 ][ i ] = 1 # grid [ i ][ 0 ] = 1 # } # # for i := 1 ; i <= GridSize ; i ++ { # for j := 1 ; j <= GridSize ; j ++ { # grid [ i ][ j ] = grid [ i - 1 ][ j ] + grid [ i ][ j - 1 ] # } # } # # fmt . Println ( grid [ GridSize ][ GridSize ])
return modularExponentiation ( generator , prvKey , primeNumber )
t . Parallel () # for _ , tc := range testcases { # if result := GrayCodes ( tc . bits ); ! reflect . DeepEqual ( result , tc . codes ) { # t . Errorf (" STR ", tc . bits , result ) # } # }
return self . localVariables
if s [ i ]. Start != s [ j ]. Start { # return s [ i ]. Start < s [ j ]. Start # } # return s [ i ]. End < s [ j ]. End
for _ , ele := range i { # slice = appendUnique ( slice , ele ) # } # return slice
fibonacciSequence := generateFibonacciSeqence () # result := fibonacciSequence . sumOfEvenNumbers () # # fmt . Println (" STR ", fibonacciSequence ) # fmt . Println (" STR ", result )
return New ( s ). HasZero ()
endA , endB := len ( a )- 1 , len ( b )- 1 # if endA < endB { # a , b = b , a # endA , endB = endB , endA # } # r := make ([] byte , len ( a )) # var carry uint 8 = 0 # f := func ( foo uint 8 ) { # switch foo { # case 0 : # r [ endA ] = ' 0 ' # case 1 : # r [ endA ] = ' 1 ' # carry = 0 # case 2 : # r [ endA ] = ' 0 ' # carry = 1 # case 3 : # r [ endA ] = ' 1 ' # carry = 1 # } # } # for endB >= 0 { # f ( a [ endA ] + b [ endB ] - 4 8 * 2 + carry ) # endA -- # endB -- # } # for ; endA >= 0 ; endA -- { # f ( a [ endA ] - 4 8 + carry ) # } # if carry == 1 { # return " STR " + *((* string )( unsafe . Pointer (& r ))) # } # return *((* string )( unsafe . Pointer (& r )))
if len ( nums )% 2 == 0 { # return true # } # x := 0 # for _ , num := range nums { # x ^= num # } # return x == 0
return len ( st . elements )
b . StopTimer () # for i := 0 ; i < 1 2 8 ; i ++ { # hmap . HashInsert ( rand . Intn ( 1 2 8 ), i ) # } # for i := 0 ; i < b . N ; i ++ { # b . StartTimer () # hmap . HashDelete ( rand . Intn ( 1 2 8 )) # b . StopTimer () # hmap . HashInsert ( rand . Intn ( 1 2 8 ), i ) # }
delta , last := 0 , 0 # totalCost , totalGas := 0 , 0 # for i := range gas { # totalCost += cost [ i ] # totalGas += gas [ i ] # delta += gas [ i ] - cost [ i ] # if delta < 0 { # last = i + 1 # delta = 0 # } # } # # if totalCost > totalGas { # return - 1 # } # # return last
println (" STR ", encode ( 3 )) # println (" STR ", encode ( 3 . 1 4 )) # println (" STR ", encode (" STR ")) # println (" STR ", encode ([] string {" STR ", " STR "}))
left := true # step , head := 1 , 1 # for n > 1 { # if left || n % 2 == 1 { # head = head + step # } # n /= 2 # step *= 2 # left = ! left # } # return head
ret := searchRange ([] int { 1 , 2 , 3 , 3 , 3 , 3 , 4 , 5 , 9 }, 3 ) # println (" STR ", ret [ 0 ], ret [ 1 ])
testData := [] string { # " STR ", # " STR ", # } # # expectedData := [][] string { # {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # {}, # } # # for index , digits := range testData { # if res := letterCombinations ( digits ); ! reflect . DeepEqual ( res , expectedData [ index ]) { # t . Errorf (" STR ", expectedData [ index ], res ) # } # }
println ( addBinary (" STR ", " STR "))
qs := [] question 1 3 2 { # # { # para 1 3 2 {" STR "}, # ans 1 3 2 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 3 2 , q . para 1 3 2 # fmt . Printf (" STR ", p , minCut ( p . s )) # } # fmt . Printf (" STR ")
pop := stackArray [ 0 ] # stackArray = stackArray [ 1 :] # return pop
for { # switch r := l . next (); { # case unicode . IsNumber ( r ): # case r == " STR ": # l . backup () # l . emit ( itemStart ) # l . chomp () # return lastByte # default : # return l . error (" STR ") # } # }
m := map [ int ] int { 3 : 3 0 , 5 : 5 0 } # func () { # defer delete ( m , 3 ) # if m [ 3 ] != 3 0 { # println (" STR ") # } # }() # if m [ 3 ] != 0 { # println (" STR ") # }
var data = [] int 3 2 { 4 2 1 , 1 5 , - 1 7 5 , 9 0 , - 2 , 2 1 4 , - 5 2 , - 1 6 6 } # fmt . Println (" STR ", data ) # radixsort ( data ) # fmt . Println (" STR ", data , " STR ")
a := big . NewInt ( 2 ) # a . Exp ( a , big . NewInt ( 1 0 0 0 ), nil ) # ttl := 0 # for _ , digit := range a . String () { # ttl += int ( digit - ' 0 ') # } # println ( ttl )
data := [] byte {' a ', ' a ', ' b ', ' b ', ' c ', ' c ', ' c '} # fmt . Println ( compress ( data ))
s = strings . Trim ( s , " STR ") # segs := strings . Split ( s , " STR ") # if len ( segs ) > 2 { # return false # } # # num := removeSign ( segs [ 0 ]) # if len ( num ) == 0 { # return false # } # # if len ( segs ) == 2 { # exponent := removeSign ( segs [ 1 ]) # if len ( exponent ) == 0 || ! isUnsignedDigits ( exponent ) { # return false # } # } # # segs = strings . Split ( num , " STR ") # if len ( segs ) > 2 { # return false # } # # integer := segs [ 0 ] # if len ( integer ) > 0 && ! isUnsignedDigits ( integer ) { # return false # } # # if len ( segs ) == 2 { # float := segs [ 1 ] # if len ( integer ) == 0 && len ( float ) == 0 { # return false # } # # if len ( float ) > 0 && ! isUnsignedDigits ( float ) { # return false # } # } # # return true
t . Parallel () # tree := GenerateUnboundBinaryTree () # for i := 0 ; i < 1 0 0 0 ; i ++ { # tree = tree . Left () # tree = tree . Right () # } # if tree . Value () != UnboundBinaryTree ( nil ) { # t . Errorf (" STR ") # } # if tree . Left () == nil { # t . Errorf (" STR ") # } # if tree . Right () == nil { # t . Errorf (" STR ") # }
tests := [...] testType { # { # a : " STR ", # b : " STR ", # want : " STR ", # }, # { # a : " STR ", # b : " STR ", # want : " STR ", # }, # { # a : " STR ", # b : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := addBinary ( tt . a , tt . b ) # if got != tt . want { # t . Fatalf (" STR ", tt . a , tt . b , got , tt . want ) # } # }
if n == 0 { # return " STR " # } # # if n * d < 0 { # return " STR " + fractionToDecimal ( abs ( n ), abs ( d )) # } # # n , d = abs ( n ), abs ( d ) # # if n >= d { # ds := fractionToDecimal ( n % d , d ) # return strconv . Itoa ( n / d ) + ds [ 1 :] # } # # digits := make ([] byte , 2 , 1 0 2 4 ) # digits [ 0 ] = ' 0 ' # digits [ 1 ] = '.' # idx := 2 # rec := make ( map [ int ] int , 1 0 2 4 ) # for { # if i , ok := rec [ n ]; ok { # return fmt . Sprintf (" STR ", string ( digits [: i ]), string ( digits [ i :])) # } # # rec [ n ] = idx # # n *= 1 0 # idx ++ # # digits = append ( digits , byte ( n / d )+' 0 ') # n %= d # # if n == 0 { # return string ( digits ) # } # }
type A struct { # CreatedAt time . Time # } # # a := & A { CreatedAt : time . Now (). UTC ()} # m := Map ( a ) # # _ , ok := m [" STR "].( time . Time ) # if ! ok { # t . Error (" STR ") # }
n := len ( nums ) # if n == 1 { # return 0 # } # # i 1 , i 2 := 0 , 1 # if nums [ i 1 ] < nums [ i 2 ] { # i 1 , i 2 = i 2 , i 1 # } # # for i := 2 ; i < n ; i ++ { # if nums [ i 1 ] < nums [ i ] { # i 2 , i 1 = i 1 , i # } else if nums [ i 2 ] < nums [ i ] { # i 2 = i # } # } # # if nums [ i 2 ] == 0 || nums [ i 1 ]/ nums [ i 2 ] >= 2 { # return i 1 # } # return - 1
i , j := 0 , len ( height )- 1 # max := 0 # # for i < j { # a , b := height [ i ], height [ j ] # h := min ( a , b ) # # area := h * ( j - i ) # if max < area { # max = area # } # # if a < b { # i ++ # } else { # j -- # } # } # # return max
res := [] int {} # # max , pre , cur := 0 , 0 , 0 # var inorder func (* TreeNode ) # inorder = func ( node * TreeNode ) { # if node == nil { # return # } # inorder ( node . Left ) # # if node . Val == pre { # cur ++ # } else { # cur = 1 # pre = node . Val # } # if cur == max { # res = append ( res , node . Val ) # } else if cur > max { # max = cur # res = [] int { node . Val } # } # # inorder ( node . Right ) # } # # inorder ( root ) # return res
for _ , url := range os . Args [ 1 :] { # local , n , err := fetch ( url ) # if err != nil { # fmt . Fprintf ( os . Stderr , " STR ", url , err ) # continue # } # fmt . Fprintf ( os . Stderr , " STR ", url , local , n ) # }
l , p , g , c := len ( N ), 0 , 0 , func ( idx int ) int { # chr , _ := strconv . Atoi ( N [ idx : idx + 1 ]) # return chr # } # for i , m := 0 , l - 4 ; i < m ; i ++ { # if p == 0 { # p = c ( i ) * c ( i + 1 ) * c ( i + 2 ) * c ( i + 3 ) * c ( i + 4 ) # } else { # p = p / c ( i - 1 ) * c ( i + 4 ) # } # if g == 0 || p > g { # g = p # } # } # fmt . Println ( g )
validSequence := (( a + b + c ) == 1 0 0 0 ) && ( a < b && b < c ) # if ! validSequence { # return false # } # return a * a + b * b == c * c
tests := [...] testType { # { # in : [] int { 7 , 1 , 5 , 3 , 6 , 4 }, # want : 7 , # }, # { # in : [] int { 1 , 2 , 3 , 4 , 5 }, # want : 4 , # }, # { # in : [] int { 7 , 6 , 4 , 3 , 1 }, # want : 0 , # }, # } # # for _ , tt := range tests { # got := maxProfit ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
m := make ( map [ int ] int ) # sum := 0 # ret := make ([] int , 2 ) # for _ , v := range nums { # if _ , ok := m [ v ]; ok { # ret [ 0 ] = v # } else { # m [ v ] = 1 # sum += v # } # } # l := len ( nums ) # ret [ 1 ] = l *( 1 + l )/ 2 - sum # return ret
if subtree . left != nil { # tree . InorderTraversal ( subtree . left , callback ) # } # callback ( subtree . data ) # if subtree . right != nil { # tree . InorderTraversal ( subtree . right , callback ) # }
if a > b { return a } # return b
_ , res := check ( root ) # return res
if nil == s || nil == t { # return s == t || nil == t # } # # return isSame ( s , t ) || isSubtree ( s . Left , t ) || isSubtree ( s . Right , t )
t . Parallel () # for _ , tc := range testcases { # tdi := NewTwoDimensionalIterator ( tc . input ) # for _ , v := range tc . expected { # if ! tdi . HasNext () { # t . Error (" STR ") # } # if result , err := tdi . Next (); result != v || err != nil { # t . Errorf (" STR ", v , result , err ) # } # } # if tdi . HasNext () { # t . Error (" STR ") # } # if _ , err := tdi . Next (); err == nil { # t . Errorf (" STR ") # } # }
starttime := time . Now () # # zero := big . NewInt ( 0 ) # two := big . NewInt ( 2 ) # ten := big . NewInt ( 1 0 ) # tothe := big . NewInt ( top ) # # mod := big . NewInt ( 0 ) # exp := big . NewInt ( 0 ) # # exp . Exp ( two , tothe , nil ) # # sum := int 6 4 ( 0 ) # # for zero . Cmp ( exp ) < 0 { # # mod . Mod ( exp , ten ) # exp . Quo ( exp , ten ) # # sum += mod . Int 6 4 () # # } # # fmt . Println ( sum ) # # fmt . Println (" STR ", time . Since ( starttime ))
max := func ( m , n int ) int { # if m > n { # return m # } # # return n # } # # result := 0 # if len ( grid ) == 0 || len ( grid [ 0 ]) == 0 { # return result # } # # for i , row := range grid { # for j , num := range row { # left , up , right , down := num , num , num , num # if i != 0 { # up = max ( 0 , num - grid [ i - 1 ][ j ]) # } # # if i != len ( grid )- 1 { # down = max ( 0 , num - grid [ i + 1 ][ j ]) # } # # if j != 0 { # left = max ( 0 , num - row [ j - 1 ]) # } # # if j != len ( row )- 1 { # right = max ( 0 , num - row [ j + 1 ]) # } # # result += left + up + right + down # if num != 0 { # result += 2 # } # } # } # # return result
if getMatrix ( 2 5 ) != 7 5 0 2 5 { # fmt . Println ( getMatrix ( 2 5 )) # t . Error () # }
cases := [] struct { # name string # inputs [][] byte # expect bool # }{ # {" STR ", # [][] byte { # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # }, true }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := isValidSudoku ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
num := 1 # for i := 2 ; i <= len ( digits ); i ++ { # num *= i # } # copied := make ([] int , len ( digits )) # copy ( copied , digits ) # perms := make ( chan [] int , num ) # go generateRecursive ( len ( copied ), copied , perms ) # return perms
if len ( height ) < 2 { # return 0 # } # max , left , right := 0 , 0 , len ( height )- 1 # for left < right { # area := minHeight ( height [ left ], height [ right ]) * ( right - left ) # if area > max { # max = area # } # if height [ left ] < height [ right ] { # for left < len ( height )- 1 { # left ++ # if height [ left ] > height [ left - 1 ] { # break # } # } # } else { # for right > 0 { # right -- # if height [ right ] > height [ right + 1 ] { # break # } # } # } # } # return max
if len ( prices ) < 2 { # return 0 # } # # buy := prices [ 0 ] # # var maxProfit int # # for i := 1 ; i < len ( prices ); i ++ { # if prices [ i ] > buy + fee { # thisTradeProfit := prices [ i ] - buy - fee # totalProfit := thisTradeProfit + MaxProfitWithFee ( prices [ i + 1 :], fee ) # # if totalProfit > maxProfit { # maxProfit = totalProfit # } # } # } # # return maxProfit
c 1 := sha 2 5 6 . Sum 2 5 6 ([] byte (" STR ")) # c 2 := sha 2 5 6 . Sum 2 5 6 ([] byte (" STR ")) # fmt . Printf (" STR ", c 1 , c 2 , c 1 == c 2 , c 1 )
dummy 1 , dummy 2 := & ListNode {}, & ListNode {} # node 1 , node 2 := dummy 1 , dummy 2 # node := head # for node != nil { # if node . Val < x { # node 1 . Next = node # node 1 = node 1 . Next # } else { # node 2 . Next = node # node 2 = node 2 . Next # } # # node = node . Next # } # # node 1 . Next , node 2 . Next = dummy 2 . Next , nil # return dummy 1 . Next
fmt . Println ( maxSubArray ([] int {- 3 , 4 , - 1 , 3 , - 5 })) # fmt . Println ( maxSubArray ([] int {- 2 , - 1 }))
res = 0 # if root != nil { # dfs ( root , 0 ) # } # return res
word , bit := x / 6 4 , uint ( x % 6 4 ) # return word < len ( s . words ) && s . words [ word ]&( 1 << bit ) != 0
m := make ( map [ string ] int ) # var maxLen int # var lastRepeatPos int = 0 # # for i := 0 ; i < len ( s ); i ++ { # # if _ , ok := m [ string ( s [ i ])]; ok && lastRepeatPos < m [ string ( s [ i ])] { # fmt . Println (" STR ", m [ string ( s [ i ])]) # lastRepeatPos = m [ string ( s [ i ])] # continue # } # # if _ , ok := m [ string ( s [ i ])]; ! ok { # m [ string ( s [ i ])] = i # } # # fmt . Println (" STR ", m ) # # } # # if lastRepeatPos == 0 { # maxLen = 1 # } else { # maxLen = lastRepeatPos + 1 # } # return maxLen
if n != len ( edges )+ 1 { # return false # } # # parents := make ([] int , n ) # for i := 0 ; i < len ( parents ); i ++ { # parents [ i ] = i # } # # for _ , edge := range edges { # parent 1 := getParent 2 6 1 ( parents , edge [ 0 ]) # parent 2 := getParent 2 6 1 ( parents , edge [ 1 ]) # if parent 1 == parent 2 { # return false # } # # union 2 6 1 ( parents , parent 1 , parent 2 ) # } # # return true
rw . readerControl . Release ( rw . maxReads ) # # rw . write . Done ()
hn := New ( 3 , func ( key [] byte ) uint 3 2 { # i , _ := strconv . Atoi ( string ( key )) # return uint 3 2 ( i ) # }) # hn . Add (" STR ", " STR ", " STR ") # t . Logf (" STR ", 3 , len ( hn . Keys ), hn . Keys ) # testCases := map [ string ] string { # " STR ": " STR ", # " STR ": " STR ", # " STR ": " STR ", # " STR ": " STR ", # } # for k , v := range testCases { # if hn . Get ( k ) != v { # t . Errorf (" STR ", k , v ) # } # } # # hn . Add (" STR ") # testCases [" STR "] = " STR " # # for k , v := range testCases { # if hn . Get ( k ) != v { # t . Errorf (" STR ", k , v ) # } # } #
hash := make ( map [ int ] int ) # for i , num := range nums { # if v , ok := hash [ num ]; ok { # if i - v <= k { # return true # } # } # hash [ num ] = i # } # return false
const intSize = 6 4 # digitSums := make ([] int , intSize ) # for _ , num := range nums { # for i := intSize - 1 ; i >= 0 ; i -- { # flag := 1 << i # digit := ( num & flag ) >> i # if digit != 0 { # digitSums [ intSize - 1 - i ]++ # } # } # } # # unique := 0 # for i , s := range digitSums { # if s % 3 == 1 { # unique |= 1 << ( intSize - 1 - i ) # } # } # # return unique
if remain < 0 || len ( comb ) > length { # return # } # if remain == 0 && len ( comb ) == length { # combCopy := make ([] int , len ( comb )) # copy ( combCopy , comb ) # * result = append (* result , combCopy ) # return # } # # for i := num ; i <= 9 ; i ++ { # comb = append ( comb , i ) # dfs ( result , comb , remain - i , i + 1 , length ) # comb = comb [: len ( comb )- 1 ] # }
if len ( nodes ) == 0 { # return & ListNode {} # } # list := & ListNode {} # head := list # list . Val = nodes [ 0 ] # for i := 1 ; i < len ( nodes ); i ++ { # list . Next = & ListNode {} # list = list . Next # list . Val = nodes [ i ] # } # return head
if root != nil { # if R < root . Val { # return trimBST ( root . Left , L , R ) # } # if root . Val < L { # return trimBST ( root . Right , L , R ) # } # root . Left = trimBST ( root . Left , L , R ) # root . Right = trimBST ( root . Right , L , R ) # } # return root
var newHead * ListNode # for nil != head { # nextNode := head . Next # head . Next = newHead # newHead = head # head = nextNode # } # return newHead
if lgu < 1 || lgu > 3 2 { # panic ( fmt . Sprintf (" STR ", lgu )) # } # return new ( rsVEBTreeElement ). init ( lgu , new ( rsVEBTreeUInt 3 2 Mixin ))
k 1 , k 2 , k 3 := " STR ", " STR ", " STR " # v 1 , v 2 , v 3 := " STR ", " STR ", " STR " # cap := len ( k 1 + k 2 + v 1 + v 2 ) # lru := New ( int 6 4 ( cap ), nil ) # lru . Add ( k 1 , String ( v 1 )) # lru . Add ( k 2 , String ( v 2 )) # lru . Add ( k 3 , String ( v 3 )) # # if _ , ok := lru . Get (" STR "); ok || lru . Len () != 2 { # t . Fatalf (" STR ") # }
qs := [] question 8 9 8 { # # { # para 8 9 8 {[] int { 0 }}, # ans 8 9 8 { 1 }, # }, # # { # para 8 9 8 {[] int { 1 , 1 , 2 }}, # ans 8 9 8 { 3 }, # }, # # { # para 8 9 8 {[] int { 1 , 2 , 4 }}, # ans 8 9 8 { 6 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 9 8 , q . para 8 9 8 # fmt . Printf (" STR ", p , subarrayBitwiseORs ( p . one )) # } # fmt . Printf (" STR ")
x := N # x |= 1 # x |= x >> 1 # x |= x >> 2 # x |= x >> 4 # x |= x >> 8 # x |= x >> 1 6 # return x ^ N
var sumOfSquares , squareOfSums uint 6 4 = 0 , 0 # # for i := 1 ; i <= 1 0 0 ; i ++ { # squareOfSums += uint 6 4 ( i ) # sumOfSquares += uint 6 4 ( math . Pow ( float 6 4 ( i ), 2 . 0 )) # } # squareOfSums = uint 6 4 ( math . Pow ( float 6 4 ( squareOfSums ), 2 . 0 )) # fmt . Println ( sumOfSquares ) # fmt . Println ( squareOfSums ) # diff := squareOfSums - sumOfSquares # fmt . Println ( diff )
n := len ( s ) # if n == 0 { # return 0 # } # # dp := make ([] int , n + 1 ) # for i := 0 ; i < n + 1 ; i ++ { # dp [ i ] = i - 1 # } # # for i := 0 ; i < n + 1 ; i ++ { # for j := 0 ; 0 <= i - j && i + j < n && s [ i - j ] == s [ i + j ]; j ++ { # dp [ i + j + 1 ] = min ( dp [ i - j ]+ 1 , dp [ i + j + 1 ]) # } # # for j := 1 ; 0 <= i - j + 1 && i + j < n && s [ i - j + 1 ] == s [ i + j ]; j ++ { # dp [ i + j + 1 ] = min ( dp [ i - j + 1 ]+ 1 , dp [ i + j + 1 ]) # } # } # # return dp [ n ]
v 1 := strings . Split ( version 1 , " STR ") # v 2 := strings . Split ( version 2 , " STR ") # ret := 1 # i := 0 # for i = 0 ; i < len ( v 1 ) && i < len ( v 2 ); i ++ { # a , _ := strconv . Atoi ( v 1 [ i ]) # b , _ := strconv . Atoi ( v 2 [ i ]) # if a > b { # return 1 # } else if a < b { # return - 1 # } # } # if len ( v 1 ) < len ( v 2 ) { # ret = - 1 # v 1 = v 2 # } # for ; i < len ( v 1 ); i ++ { # a , _ := strconv . Atoi ( v 1 [ i ]) # if a != 0 { # return ret # } # } # return 0
if c < 0 { # return false # } # # left , right := 0 , int ( math . Sqrt ( float 6 4 ( c ))) # for left <= right { # current := left * left + right * right # if current < c { # left ++ # } else if current > c { # right -- # } else { # return true # } # } # return false
n := len ( A ) # if n <= 0 { # return - 1 # } # # if n == 1 { # if A [ 0 ] == key { # return 0 # } # return - 1 # } # # low , high := 0 , n - 1 # # for low <= high { # if A [ low ] <= A [ high ] && ( key < A [ low ] || key > A [ high ]) { # return - 1 # } # # mid := low + ( high - low )/ 2 # # if A [ mid ] == key { # return mid # } # # if A [ low ] < A [ mid ] && key >= A [ low ] && key < A [ mid ] { # high = mid - 1 # continue # } # # if A [ mid ] < A [ high ] && key > A [ mid ] && key <= A [ high ] { # low = mid + 1 # continue # } # # if A [ low ] > A [ mid ] { # high = mid - 1 # continue # } # # if A [ mid ] > A [ high ] { # low = mid + 1 # continue # } # } # # return - 1 #
m := make ( map [ string ] int ) # m 1 := make ( map [ string ] bool ) # for _ , v := range banned { # m 1 [ v ] = true # } # p := strings . ToLower ( paragraph ) # re , _ := regexp . Compile (" STR ") # p = re . ReplaceAllString ( p , " STR ") # r := strings . Split ( p , " STR ") # for _ , v := range r { # if _ , ok := m [ v ]; ok { # m [ v ]++ # } else { # if _ , ok := m 1 [ v ]; ! ok && strings . Trim ( v , " STR ") != " STR " { # m [ v ] = 1 # } # } # } # max := 0 # ret := " STR " # for v := range m { # if m [ v ] > max { # max = m [ v ] # ret = v # } # } # return ret
ids = make ( map [ int ] bool ) # dfs ( root , 0 ) # for i := 0 ; i < len ( ids ); i ++ { # if ! ids [ i ] { # return false # } # } # return true
if n == 1 { # return false # } # if n == 2 { # return true # } # # for x := 2 ; x * x <= n ; x = x + 1 { # if n % x == 0 { # return false # } # } # return true
file , err := os . Open ( path ) # if err != nil { # log . Fatal ( err ) # } # defer file . Close () # # data , err := ioutil . ReadAll ( file ) # if err != nil { # log . Fatal ( err ) # } # # return string ( data )
cases := [] struct { # name string # inputs [][] int # expect [] int # }{ # {" STR ", [][] int {{ 2 , 7 , 1 1 , 1 5 }, { 9 }}, [] int { 0 , 1 }}, # {" STR ", [][] int {{ 3 , 2 , 4 }, { 6 }}, [] int { 1 , 2 }}, # {" STR ", [][] int {{ 2 , 7 , 1 1 , 1 5 }, { 9 }}, [] int { 0 , 1 }}, # {" STR ", [][] int {{ 7 , 6 , 5 , 3 , 2 , 1 , 4 , 9 , 1 0 }, { 1 7 }}, [] int { 0 , 8 }}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := TwoSum 2 ( c . inputs [ 0 ], c . inputs [ 1 ][ 0 ]) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
return unmarshal ( in , out , false )
var result , count int # for i := range nums { # if nums [ i ] == result { # count ++ # } else if count > 0 { # count -- # } else { # result , count = nums [ i ], 1 # } # } # # return result
if x < 0 { # return false # } # t := x # var r int # for x > 0 { # r = r * 1 0 + x % 1 0 # x /= 1 0 # } # return t == r
var res [] float 6 4 # w := getWindowList ( nums [: k ], k ) # res = append ( res , getMedian ( w , k )) # # for p 1 := k ; p 1 < len ( nums ); p 1 ++ { # w = removeFromWindow ( w , nums [ p 1 - k ]) # w = insertInWindow ( w , nums [ p 1 ]) # res = append ( res , getMedian ( w , k )) # } # return res
for k := 0 ; k < len ( A ); k ++ { # i , j := 0 , len ( A [ k ])- 1 # for i < j { # A [ k ][ i ], A [ k ][ j ] = invert ( A [ k ][ j ]), invert ( A [ k ][ i ]) # i ++ # j -- # } # if i == j { # A [ k ][ i ] = invert ( A [ k ][ i ]) # } # } # return A
node := root # for node != nil { # sibling , next , isLeft := getNextChild 1 1 7 ( node , true ) # child := next # for sibling != nil && child != nil { # var nextSibling , nextChild * TreeNodeWithNext # if isLeft { # nextSibling , nextChild , isLeft = getNextChild 1 1 7 ( sibling , false ) # } else { # nextSibling , nextChild , isLeft = getNextChild 1 1 7 ( sibling . Next , true ) # } # # child . Next = nextChild # # sibling , child = nextSibling , nextChild # } # # node = next # } # # return root
cache := make ( map [ string ][] int ) # var dfs func ( string ) [] int # dfs = func ( s string ) [] int { # res := make ([] int , 0 , len ( s )) # if t , ok := cache [ s ]; ok { # return t # } # # for i := range s { # if s [ i ] == '+' || s [ i ] == '-' || s [ i ] == '*' { # for _ , left := range dfs ( s [: i ]) { # for _ , right := range dfs ( s [ i + 1 :]) { # res = append ( res , operate ( left , right , s [ i ])) # } # } # } # } # # if len ( res ) == 0 { # temp , _ := strconv . Atoi ( s ) # res = append ( res , temp ) # } # # cache [ s ] = res # return res # } # # return dfs ( input )
primes := make ([] bool , n ) # for i := 2 ; i < n ; i ++ { # primes [ i ] = true # } # # for i := 2 ; i * i < n ; i ++ { # if primes [ i ] { # for j := i * i ; j < n ; j += i { # primes [ j ] = false # } # } # } # # var cnt int # for i := 2 ; i < n ; i ++ { # if primes [ i ] { # cnt ++ # } # } # return cnt
numbers := [] int { math . MaxInt 3 2 , - 1 } # # if nil == root { # return numbers [ 0 ] # } # core ( root , numbers ) # return numbers [ 0 ]
node := root # var prev * TreeNode # stack := make ([]* TreeNode , 0 ) # for node != nil || len ( stack ) > 0 { # for node != nil { # stack = append ( stack , node ) # node = node . Left # } # # node = stack [ len ( stack )- 1 ] # if prev != nil && prev . Val >= node . Val { # return false # } # # stack = stack [: len ( stack )- 1 ] # prev = node # node = node . Right # } # # return true
length 1 := getListLength ( head 1 ) # length 2 := getListLength ( head 2 ) # var lengthDif int # var listHeadLong , listHeadShort , firstCommonNode * ListNode # if length 1 >= length 2 { # lengthDif = length 1 - length 2 # listHeadLong = head 1 # listHeadShort = head 2 # } else { # lengthDif = length 2 - length 1 # listHeadLong = head 2 # listHeadShort = head 1 # } # # for i := 0 ; i < lengthDif ; i ++ { # listHeadLong = listHeadLong . next # } # for listHeadLong != listHeadShort && nil != listHeadLong && nil != listHeadShort { # listHeadLong = listHeadLong . next # listHeadShort = listHeadShort . next # } # firstCommonNode = listHeadLong # return firstCommonNode
if len ( S ) == 0 { # return S # } # anchor , bal , mountains := 0 , 0 , [] string {} # for i := 0 ; i < len ( S ); i ++ { # if S [ i ] == ' 1 ' { # bal += 1 # } else { # bal += - 1 # } # if bal == 0 { # mountains = append ( mountains , " STR "+ makeLargestSpecial ( string ( S [ anchor + 1 : 1 + i ]))+" STR ") # anchor = i + 1 # } # } # sort . Strings ( mountains ) # ret := " STR " # for i := len ( mountains ) - 1 ; i >= 0 ; i -- { # ret += mountains [ i ] # } # return ret
sum = 0 # dfs ( root ) # return root
if len ( me ) < 1 { # return false # } # for _ , s := range me [ 1 :] { # if s == opt { # return true # } # } # return false
e := 0 # res := 0 # for i , s := range seats { # if e == i { # res = e # } else { # res = max ( res , ( e + e % 2 )/ 2 ) # } # if s == 1 { # e = 0 # } else { # e ++ # } # } # return max ( res , e )
max := 0 # # for i := range a { # temp := 1 # # for a [ i ] != i { # a [ i ], a [ a [ i ]] = a [ a [ i ]], a [ i ] # temp ++ # } # # if max < temp { # max = temp # } # } # # return max
kthLargest := KthLargest 1 { heap : make ([] int , k )} # kthLargest . k = k # for i , _ := range kthLargest . heap { # kthLargest . heap [ i ] = math . MinInt 3 2 # } # # for i := 0 ; i < k && i < len ( nums ); i ++ { # kthLargest . heap [ i ] = nums [ i ] # } # # kthLargest . heap = InsertSort ( kthLargest . heap ) # # for i := k ; i < len ( nums ); i ++ { # kthLargest . Add ( nums [ i ]) # } # # fmt . Println ( kthLargest . heap ) # # return kthLargest
var sum , i int 6 4 = 0 , 0 # # for i = 0 ; i < 1 0 0 0 0 0 0 ; i ++ { # if isPalindrome ( strconv . FormatInt ( i , 1 0 )) && isPalindrome ( strconv . FormatInt ( i , 2 )) { # sum += i # } # } # # fmt . Println ( sum )
var tests = [] struct { # n int # seq [] int # }{ # { 0 , [] int { 0 }}, # { 1 , [] int { 0 , 1 }}, # { 2 , [] int { 0 , 1 , 3 , 2 }}, # { 3 , [] int { 0 , 1 , 3 , 2 , 6 , 7 , 5 , 4 }}, # } # # for _ , tt := range tests { # seq := grayCode ( tt . n ) # if reflect . DeepEqual ( seq , tt . seq ) == false { # t . Errorf (" STR ", tt . n , seq , tt . seq ) # } # }
if 0 > number { # return 0 # } # return getTranslationCore ( strconv . Itoa ( number ))
http . HandleFunc (" STR ", func ( res http . ResponseWriter , req * http . Request ) { # cookie , err := req . Cookie (" STR ") # if err == http . ErrNoCookie { # cookie = & http . Cookie { # Name : " STR ", # Value : " STR ", # } # } # # count , _ := strconv . Atoi ( cookie . Value ) # count ++ # cookie . Value = strconv . Itoa ( count ) # # http . SetCookie ( res , cookie ) # # io . WriteString ( res , cookie . Value ) # # }) # http . ListenAndServe (" STR ", nil )
return len ( pq )
fmt . Printf (" STR ", p . FirstName , p . LastName )
return " STR " + e . Method + " STR "
var last * TreeNode # var stack []* TreeNode # for 0 < len ( stack ) || root != nil { # for root != nil { # stack = append ( stack , root ) # root = root . Left # } # # top := len ( stack ) - 1 # if last != nil && stack [ top ]. Val < last . Val { # return false # } # last = stack [ top ] # root = stack [ top ]. Right # stack = stack [: top ] # } # return true
var i , j , tmp int # for i = 1 ; i < len ( arr ); i ++ { # tmp = arr [ i ] # for j = i ; j > 0 && arr [ j - 1 ] < tmp ; j -- { # arr [ j ] = arr [ j - 1 ] # } # arr [ j ] = tmp # } # return arr
n := len ( S ) # pos := - n # res := make ([] int , n ) # for i := 0 ; i < n ; i ++ { # if S [ i ] == C { # pos = i # } # res [ i ] = i - pos # } # for i := n - 1 ; i >= 0 ; i -- { # if S [ i ] == C { # pos = i # } # res [ i ] = min ( res [ i ], abs ( i - pos )) # } # return res
tmp := strings . Trim ( s , " STR ") # start , end , ans := len ( tmp )- 1 , len ( tmp )- 1 , "" # for start >= 0 { # for start >= 0 && tmp [ start ] != " STR " { # start -- # } # ans += tmp [ start + 1 : end + 1 ] + " STR " # for start >= 0 && tmp [ start ] == " STR " { # start -- # } # end = start # } # return strings . Trim ( ans , " STR ")
if len ( grid ) == 0 || len ( grid [ 0 ]) == 0 { # return 0 # } # # rows , cols := len ( grid ), len ( grid [ 0 ]) # dp := make ([] int , cols ) # # sum := 0 # for i := 0 ; i < cols ; i ++ { # dp [ i ] = sum + grid [ 0 ][ i ] # sum = dp [ i ] # } # # for i := 1 ; i < rows ; i ++ { # dp [ 0 ] += grid [ i ][ 0 ] # # for j := 1 ; j < cols ; j ++ { # min := int ( math . Min ( float 6 4 ( dp [ j ]), float 6 4 ( dp [ j - 1 ]))) # dp [ j ] = grid [ i ][ j ] + min # } # } # # return dp [ cols - 1 ]
var tests = [] struct { # tree * TreeNode # subtree * TreeNode # }{ # { newTree ( 3 , 5 , 1 , 6 , 2 , 0 , 8 , nil , nil , 7 , 4 ), newTree ( 2 , 7 , 4 )}, # } # # for _ , tt := range tests { # subtree := subtreeWithAllDeepest ( tt . tree ) # if reflect . DeepEqual ( subtree , tt . subtree ) == false { # t . Errorf (" STR ", tt . tree , subtree , tt . subtree ) # } # }
return (* h )[ i .( int )]
max := 0 # nums = parseToIntSlice ( source ) # for i := 0 ; i < len ( nums ); i ++ { # max = maxVal ( max , getProd ( i , 1 , 0 )) # max = maxVal ( max , getProd ( i , 1 , - 1 )) # max = maxVal ( max , getProd ( i , 0 , 1 )) # max = maxVal ( max , getProd ( i , 1 , 1 )) # } # fmt . Println (" STR ", max )
if rowIndex == 0 { # return [] int { 1 } # } # row := append ( getRow ( rowIndex - 1 ), 1 ) # for i := rowIndex - 1 ; i > 0 ; i -- { # row [ i ] += row [ i - 1 ] # } # return row
tests := [...] testType { # { # a : [] int { 1 , 2 }, # b : [] int {- 2 , - 1 }, # c : [] int {- 1 , 2 }, # d : [] int { 0 , 2 }, # want : 2 , # }, # } # for _ , tt := range tests { # got := fourSumCount ( tt . a , tt . b , tt . c , tt . d ) # if got != tt . want { # t . Fatalf (" STR ", tt , got , tt . want ) # } # }
Do () # Do () # Do ()
return & linkStack { nil }
n := len ( nums ) # # if n == 0 { # return # } # # tmp := nums [ 0 ] # nums [ 0 ] = 1 # # i , j , k := 0 , 1 , n - 1 # for j <= k { # if nums [ j ] == 0 { # nums [ i ], nums [ j ] = nums [ j ], nums [ i ] # i ++ # j ++ # } else if nums [ j ] == 1 { # j ++ # } else { # nums [ j ], nums [ k ] = nums [ k ], nums [ j ] # k -- # } # } # # if tmp == 0 { # nums [ i ] = tmp # } else if tmp == 2 { # nums [ k ] = tmp # }
tests := [...] testType { # { # in : [] int { 1 , 2 , 3 , 3 }, # want : 3 , # }, # { # in : [] int { 2 , 1 , 2 , 5 , 3 , 2 }, # want : 2 , # }, # { # in : [] int { 5 , 1 , 5 , 2 , 5 , 3 , 5 , 4 }, # want : 5 , # }, # { # in : [] int { 1 , 2 , 3 }, # want : 0 , # }, # } # # for _ , tt := range tests { # got := repeatedNTimes ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if len ( coins ) == 1 { # return 1 # } # # if answer , ok := memo [[ 2 ] int { len ( coins ), amount }]; ok { # return answer # } # # for i := 0 ; i <= amount / coins [ 0 ]; i ++ { # answer += ways ( coins [ 1 :], amount -( coins [ 0 ]* i )) # } # # memo [[ 2 ] int { len ( coins ), amount }] = answer # # return
s . lock . Lock () # defer s . lock . Unlock () # # prepend := make ([] interface {}, 1 ) # prepend [ 0 ] = el # s . stack = append ( prepend , s . stack ...) # s . len ++
if p . Filename == "" { # return fmt . Sprintf (" STR ", p . Line , p . Column ) # } else { # return fmt . Sprintf (" STR ", p . Filename , p . Line , p . Column ) # }
if l 1 == nil { # return l 2 # } # if l 2 == nil { # return l 1 # } # # var head , node * ListNode # if l 1 . Val < l 2 . Val { # head = l 1 # node = l 1 # l 1 = l 1 . Next # } else { # head = l 2 # node = l 2 # l 2 = l 2 . Next # } # # for l 1 != nil && l 2 != nil { # if l 1 . Val < l 2 . Val { # node . Next = l 1 # l 1 = l 1 . Next # } else { # node . Next = l 2 # l 2 = l 2 . Next # } # # node = node . Next # } # # if l 1 != nil { # node . Next = l 1 # } # # if l 2 != nil { # node . Next = l 2 # } # # return head
for i , num := range funcVals { # if got := Nth ( num ); got != fibNth [ i ] { # t . Errorf (" STR ", num , got , fibNth [ i ]) # } # }
t . Parallel () # expected := [] int { 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 } # result := BadSnippet () # if ! reflect . DeepEqual ( expected , result ) { # t . Errorf (" STR ", expected , result ) # }
if len ( A ) != len ( B ) { # return false # } # if A == B { # exist := [ 2 6 ] bool {} # for _ , c := range A { # k := c - ' a ' # if exist [ k ] { # return true # } # exist [ k ] = true # } # return false # } # m , n := - 1 , - 1 # for i , c := range A { # if B [ i ] != byte ( c ) { # if m == - 1 { # m = i # } else if n == - 1 { # n = i # } else { # return false # } # } # } # return n != - 1 && A [ m ] == B [ n ] && A [ n ] == B [ m ]
fmt . Println ( firstUniqChar (" STR ")) # fmt . Println ( firstUniqChar (" STR "))
now := time . Now (). UTC () # nanos := now . Sub ( timer . start ). Nanoseconds () # micros := nanos / 1 0 0 0 # return micros
res := make ([] int , n + 1 ) # for _ , b := range bookings { # i , j , k := b [ 0 ], b [ 1 ], b [ 2 ] # res [ i - 1 ] += k # res [ j ] -= k # } # # for i := 1 ; i < n ; i ++ { # res [ i ] += res [ i - 1 ] # } # # return res [: n ]
return modularExponentiation ( shareKey , prvKey , primeNumber )
nodes := [] int { # 1 , 2 , 3 , 4 , 5 , 6 , # } # # edges := [][] bool { # { false , true , true , false , false , false }, # { true , false , false , true , false , false }, # { true , false , false , true , false , false }, # { false , true , true , false , true , false }, # { false , false , false , true , false , true }, # { false , false , false , false , true , false }, # } # start := 1 # end := 6 # result := breadthFirstSearch ( start , end , nodes , edges ) # fmt . Println ( result )
nums := [] int { 3 , 0 , 1 } # nums 2 := [] int { 9 , 6 , 4 , 2 , 3 , 5 , 7 , 0 , 1 } # fmt . Println ( missingNumber ( nums )) # fmt . Println ( missingNumber ( nums 2 ))
var min int = 0 # var tmp int = 0 # # for i := 0 ; i < len ( arr ); i ++ { # min = i # for j := i + 1 ; j < len ( arr ); j ++ { # if arr [ j ] < arr [ min ] { # min = j # } # } # # tmp = arr [ i ] # arr [ i ] = arr [ min ] # arr [ min ] = tmp # }
cases := [] struct { # name string # inputs * ListNode # expect * ListNode # }{ # {" STR ", MakeListNode ([] int { 1 , 2 , - 3 , 3 , 1 }), MakeListNode ([] int { 3 , 1 })}, # {" STR ", MakeListNode ([] int { 1 , 2 , 3 , - 3 , 4 }), MakeListNode ([] int { 1 , 2 , 4 })}, # {" STR ", MakeListNode ([] int { 1 , 2 , 3 , - 3 , - 2 }), MakeListNode ([] int { 1 })}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
pq [ i ], pq [ j ] = pq [ j ], pq [ i ] # pq [ i ]. index = i # pq [ j ]. index = j
parent := make ([] int , size ) # for i := range parent { # parent [ i ] = i # } # return & unionFind { # parent : parent , # }
i , j := 0 , len ( nums )- 1 # for i < j { # if nums [ i ] < nums [ j ] { # return nums [ i ] # } # mid := ( i + j ) / 2 # if nums [ mid ] >= nums [ i ] { # i = mid + 1 # } else { # j = mid # } # } # return nums [ i ]
m , n := len ( matrix ), len ( matrix [ 0 ]) # for i := 0 ; i < m - 1 ; i ++ { # for j := 0 ; j < n - 1 ; j ++ { # if matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ] { # return false # } # } # } # return true
t . Parallel () # for _ , tc := range testcases { # if min , max := MaxMinNotGoodEnough ( tc . nums ); min != tc . min || max != tc . max { # t . Errorf (" STR ", tc . min , tc . max , min , max ) # } # }
var result [] int # # if root == nil { # return result # } # # stack 1 := NewStack () # stack 2 := NewStack () # # stack 1 . Push ( root ) # for { # node , err := stack 1 . Pop () # if err != nil { # break # } # # stack 2 . Push ( node ) # if node . Left != nil { # stack 1 . Push ( node . Left ) # } # # if node . Right != nil { # stack 1 . Push ( node . Right ) # } # } # # for { # node , err := stack 2 . Pop () # if err != nil { # break # } # # result = append ( result , node . Val ) # } # # return result
testData := [][] int { # { 3 , 4 , 6 7 , 8 }, # {}, # { 5 4 , 3 , 1 2 , 1 }, # } # expectedData := [] int { 3 , 0 , 1 } # # for index , data := range testData { # if res := CalcMinInt ( data ...); res != expectedData [ index ] { # t . Errorf (" STR ", expectedData [ index ], res ) # } # }
return & Trie { # root : & trieNode { root : true , children : make ( map [ byte ]* trieNode )}, # size : 1 , # }
n := len ( s ) # m := make ([] int , 2 6 ) # # res := 0 # for h := 1 ; h <= 2 6 ; h ++ { # for i := range m { # m [ i ] = 0 # } # i , j := 0 , 0 # unique , noLessThanK := 0 , 0 # for j < n { # if unique <= h { # index := s [ j ] - ' a ' # if m [ index ] == 0 { # unique ++ # } # m [ index ]++ # if m [ index ] == k { # noLessThanK ++ # } # j ++ # } else { # index := s [ i ] - ' a ' # if m [ index ] == k { # noLessThanK -- # } # m [ index ]-- # if m [ index ] == 0 { # unique -- # } # i ++ # } # # if unique == h && unique == noLessThanK && j - i > res { # res = j - i # # } # } # } # return res
for i := range s { # if s [ i ] != s [ len ( s )- 1 - i ] { # return false # } # } # return true
bs := [] byte ( S ) # # left , right := 0 , len ( bs )- 1 # for left < right { # for left < right && ! isLetter ( bs [ left ]) { # left ++ # } # for left < right && ! isLetter ( bs [ right ]) { # right -- # } # bs [ left ], bs [ right ] = bs [ right ], bs [ left ] # left ++ # right -- # } # # return string ( bs )
cases := [] struct { # name string # inputs string # expect [][] int # }{ # {" STR ", " STR ", [][] int {{ 3 , 6 }}}, # {" STR ", " STR ", [][] int {{ 3 , 5 }, { 6 , 9 }, { 1 2 , 1 4 }}}, # {" STR ", " STR ", [][] int {}}, # {" STR ", " STR ", [][] int {{ 0 , 2 }, { 3 , 6 }}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
var cnt uint = 0 # for m != n { # cnt ++ # m >>= 1 # n >>= 1 # } # return m << cnt
if r 1 == nil && r 2 == nil { # return true # } # if r 1 == nil || r 2 == nil { # return false # } # if r 1 . Val != r 2 . Val { # return false # } # return isMirror ( r 1 . Left , r 2 . Right ) && isMirror ( r 1 . Right , r 2 . Left )
t . Parallel () # for _ , tc := range testcases { # in := make ([] int , len ( tc . in )) # copy ( in , tc . in ) # NextPermutation ( in ) # if ! reflect . DeepEqual ( in , tc . out ) { # t . Errorf (" STR ", tc . out , in ) # } # }
counts := make ( map [ string ] int ) # input := bufio . NewScanner ( os . Stdin ) # for input . Scan () { # counts [ input . Text ()]++ # } # for line , n := range counts { # if n > 1 { # fmt . Printf (" STR ", n , line ) # } # }
if nil == root { # return [] int {} # } # # vals := [] int {} # nodes := []* TreeNode { root } # for len ( nodes ) > 0 { # node := nodes [ len ( nodes )- 1 ] # # if nil != node . Left { # nodes = append ( nodes , node . Left ) # node . Left = nil # continue # } # # vals = append ( vals , node . Val ) # nodes = nodes [: len ( nodes )- 1 ] # if nil != node . Right { # nodes = append ( nodes , node . Right ) # } # } # # return vals
sort . Ints ( arr ) # var cand [] int # combinationSum ( arr , cand , target , aRes ) # return
uf . count = n # uf . parent = make ([] int , n ) # uf . rank = make ([] int , n ) # for i := range uf . parent { # uf . parent [ i ] = i # }
if math . IsNaN ( x ) || math . IsInf ( x , 0 ) { # return 0 # } # # sign := float 6 4 ( 1 . 0 ) # if x < 0 { # sign = - 1 # x *= - 1 # } # # _ , frac := math . Modf ( x ) # if frac >= 0 . 5 { # x = math . Ceil ( x ) # } else { # x = math . Floor ( x ) # } # # return int 6 4 ( x * sign )
borad := [][] byte { # [] byte {' A ', ' B ', ' C ', ' E '}, # [] byte {' S ', ' F ', ' C ', ' S '}, # [] byte {' A ', ' D ', ' E ', ' E '}, # } # t . Log (" STR ", exist ( borad , " STR ")) # t . Log (" STR ", exist ( borad , " STR ")) # t . Log (" STR ", exist ( borad , " STR "))
n := len ( A ) # stack , top := make ([] int , n ), 0 # stack [ top ] = n - 1 # # for i := n - 2 ; i >= 0 ; i -- { # if A [ i ] <= A [ stack [ top ]] { # top ++ # stack [ top ] = i # continue # } # for top - 1 >= 0 && # A [ stack [ top ]] < A [ stack [ top - 1 ]] && # A [ stack [ top - 1 ]] < A [ i ] { # top -- # } # j := stack [ top ] # A [ i ], A [ j ] = A [ j ], A [ i ] # break # } # # return A
p . Location = newLocation
str := " STR " # fmt . Println ( isPalindrome ( str )) # # str 2 := " STR " # fmt . Println ( isPalindrome ( str 2 ))
const max = 1 e 6 # # chain , bestChain , bestChainIndex := 0 , 0 , 0 # for i := 1 ; i < max ; i ++ { # chain = chainLength ( i ) # if chain > bestChain { # bestChain = chain # bestChainIndex = i # } # } # # fmt . Println ( bestChainIndex )
return & node { val , nil , nil }
if root == nil { # return [][] int {} # } # stack := []* TreeNode { root } # rets := [][] int {} # for len ( stack ) != 0 { # tmpStack := []* TreeNode {} # ret := [] int {} # for i := range stack { # ret = append ( ret , stack [ i ]. Val ) # if stack [ i ]. Left != nil { # tmpStack = append ( tmpStack , stack [ i ]. Left ) # } # if stack [ i ]. Right != nil { # tmpStack = append ( tmpStack , stack [ i ]. Right ) # } # } # rets = append ( rets , ret ) # stack = tmpStack # } # return rets
qs := [] question 6 3 3 { # # { # para 6 3 3 { 1 }, # ans 6 3 3 { true }, # }, # # { # para 6 3 3 { 2 }, # ans 6 3 3 { true }, # }, # # { # para 6 3 3 { 3 }, # ans 6 3 3 { false }, # }, # # { # para 6 3 3 { 4 }, # ans 6 3 3 { true }, # }, # # { # para 6 3 3 { 5 }, # ans 6 3 3 { true }, # }, # # { # para 6 3 3 { 6 }, # ans 6 3 3 { false }, # }, # # { # para 6 3 3 { 1 0 4 9 7 6 }, # ans 6 3 3 { true }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 3 3 , q . para 6 3 3 # fmt . Printf (" STR ", p , judgeSquareSum ( p . one )) # } # fmt . Printf (" STR ")
if len ( nums 1 ) == 0 || len ( nums 2 ) == 0 { # return [] int {} # } # res , reocrd := [] int {}, map [ int ] int {} # for i , v := range nums 2 { # reocrd [ v ] = i # } # for i := 0 ; i < len ( nums 1 ); i ++ { # flag := false # for j := reocrd [ nums 1 [ i ]]; j < len ( nums 2 ); j ++ { # if nums 2 [ j ] > nums 1 [ i ] { # res = append ( res , nums 2 [ j ]) # flag = true # break # } # } # if flag == false { # res = append ( res , - 1 ) # } # } # return res
return syscall . Getegid ()
m 1 , m 2 := vote 2 ( nums ) # var c 1 , c 2 int # for _ , num := range nums { # switch num { # case m 1 : # c 1 ++ # case m 2 : # c 2 ++ # } # } # # var majority [] int # if c 1 > len ( nums )/ 3 { # majority = append ( majority , m 1 ) # } # if c 2 > len ( nums )/ 3 { # majority = append ( majority , m 2 ) # } # return majority
var ret int # p := & TreeNode { # Val : 2 , # Left : & TreeNode { # Val : 3 , # Left : & TreeNode { # Val : 4 , # Left : nil , # Right : nil , # }, # Right : & TreeNode { # Val : 5 , # Left : nil , # Right : nil , # }, # }, # Right : & TreeNode { # Val : 3 , # Left : nil , # Right : & TreeNode { # Val : 4 , # Left : nil , # Right : nil , # }, # }, # } # # ret = 3 # if ret != maxDepth ( p ) { # t . Fatalf (" STR ", ret ) # } #
if n == 0 { # return 0 # } # if n == 1 { # return 1 # } # # power := string ( strconv . FormatInt ( int 6 4 ( n - 1 ), 2 )) # powers := make ([] int , 0 ) # # for i , r := range power { # if string ( r ) == " STR " { # powers = append ([] int { int ( math . Pow ( 2 , float 6 4 ( len ( power )- i - 1 )))}, powers ...) # } # } # # Q := [ 4 ] int { 1 , 1 , 1 , 0 } # matrices := make ([][ 4 ] int , 0 ) # # for _ , p := range powers { # matrices = append ( matrices , _raiseToPower ( Q , p , memo )) # } # # for len ( matrices ) > 1 { # M 1 := matrices [ 0 ] # M 2 := matrices [ 1 ] # R := _multiplyMatrix ( M 1 , M 2 ) # matrices = matrices [ 2 : len ( matrices )] # matrices = append ( matrices , R ) # } # # return matrices [ 0 ][ 0 ]
m := make ([] int , 2 6 ) # for _ , v := range s { # m [ v -" STR "]++ # } # # for _ , v := range s { # if m [ v -" STR "] == 1 { # return byte ( v ) # } # } # return " STR "
var m = map [ int ] int {} # for _ , v := range nums { # m [ v ] = m [ v ] + 1 # } # # var res int # for _ , v := range m { # res += v * ( v - 1 ) / 2 # } # return res
if len ( nums ) == 0 { # return false # } # for i := 0 ; i < len ( nums ); i ++ { # if nums [ i ] == 0 { # continue # } # slow , fast , val := i , getNextIndex ( nums , i ), 0 # for nums [ fast ]* nums [ i ] > 0 && nums [ getNextIndex ( nums , fast )]* nums [ i ] > 0 { # if slow == fast { # if slow == getNextIndex ( nums , slow ) { # break # } # return true # } # slow = getNextIndex ( nums , slow ) # fast = getNextIndex ( nums , getNextIndex ( nums , fast )) # } # slow , val = i , nums [ i ] # for nums [ slow ]* val > 0 { # next := getNextIndex ( nums , slow ) # nums [ slow ] = 0 # slow = next # } # } # return false
return len ( h )
count := uint 6 4 ( 8 ) # if n % uint 6 4 ( 3 ) == 0 { # count += 1 # } # if n % uint 6 4 ( 7 ) == 0 { # count += 1 # } # for i := uint 6 4 ( 1 1 ); i < n / 2 ; i ++ { # if ( n % i ) == 0 { # count += 1 # } # } # return count
n := mySqrt ( 2 * N ) # res := 1 # for k := 2 ; k <= n ; k ++ { # if ( N -( k *( k - 1 )/ 2 ))% k == 0 { # res ++ # } # } # return res
log . Println (" STR ") # s . searchers [" STR "] = yahoo {}
const sign = 1 << 6 3 # return float 6 4 frombits ( float 6 4 bits ( x )&^ sign | float 6 4 bits ( y )& sign )
var sum uint # # for vec != 0 { # if vec & 1 != 0 { # sum ^= mat [ 0 ] # } # vec >>= 1 # mat = mat [ 1 :] # } # return sum
sort . Slice ( arr , func ( i , j int ) bool { # if arr [ i ][ 0 ] > arr [ j ][ 0 ] { # return false # } # if arr [ i ][ 0 ] == arr [ j ][ 0 ] { # if arr [ i ][ 1 ] > arr [ j ][ 1 ] { # return true # } # return false # } # return true # }) # return arr
perms := make ( chan [][] int ) # go func () { # permutations ( nums , [] int {}, [] int {}, perms ) # close ( perms ) # }() # minSum := int (^ uint ( 0 ) >> 1 ) # var s 1 , s 2 [] int # for subsets := range perms { # if s := sum ( subsets [ 0 ], subsets [ 1 ]); s < minSum { # minSum = s # s 1 = subsets [ 0 ] # s 2 = subsets [ 1 ] # } # } # return s 1 , s 2
in := make ([] int , n ) # frees := make ([][] int , n ) # next := make ([] int , 0 , n ) # for _ , v := range pre { # in [ v [ 0 ]]++ # frees [ v [ 1 ]] = append ( frees [ v [ 1 ]], v [ 0 ]) # } # for i := 0 ; i < n ; i ++ { # if in [ i ] == 0 { # next = append ( next , i ) # } # } # for i := 0 ; i != len ( next ); i ++ { # c := next [ i ] # v := frees [ c ] # for _ , vv := range v { # in [ vv ]-- # if in [ vv ] == 0 { # next = append ( next , vv ) # } # } # } # return len ( next ) == n
c := NewCircularBuffer ( 1 0 ) # # for i := 0 ; i < 9 ; i ++ { # v := c . NBPush ( i ) # if v != nil { # t . Error ( v ) # } # } # v := c . NBPush ( 9 ) # if v != 0 { # t . Error ( v ) # } # # for i := 1 ; i < 1 0 ; i ++ { # v := c . Get ().( int ) # if i != v { # t . Error ( v ) # } # } # # if c . verifyIsEmpty () != true { # t . Error (" STR ") # }
size := len ( pushed ) # # stack := make ([] int , size ) # top := - 1 # # for in , out := 0 , 0 ; in < size ; in ++ { # if pushed [ in ] != popped [ out ] { # top ++ # stack [ top ] = pushed [ in ] # } else { # out ++ # for top >= 0 && stack [ top ] == popped [ out ] { # top -- # out ++ # } # } # } # # return top == - 1
minCap = math . MinInt 6 4 # for _ , v := range arr { # sumCap += v # if v > minCap { # minCap = v # } # } # return
fmt . Println ( repeatedSubstringPattern (" STR "))
c := nums [ 0 ] # count := 1 # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] == c { # count ++ # } else { # count -- # } # if count < 1 { # count = 1 # c = nums [ i ] # } # } # return c
sign , res := - 1 , 0 # if dividend == 0 { # return 0 # } # if divisor == 1 { # return dividend # } # if dividend == math . MinInt 3 2 && divisor == - 1 { # return math . MaxInt 3 2 # } # if dividend > 0 && divisor > 0 || dividend < 0 && divisor < 0 { # sign = 1 # } # if dividend > math . MaxInt 3 2 { # dividend = math . MaxInt 3 2 # } # res = binarySearchQuotient ( 0 , abs ( dividend ), abs ( divisor ), abs ( dividend )) # if res > math . MaxInt 3 2 { # return sign * math . MaxInt 3 2 # } # if res < math . MinInt 3 2 { # return sign * math . MinInt 3 2 # } # return sign * res
primes := [] int {} # for i := 2 ; i < 5 0 0 0 0 ; i ++ { # if big . NewInt ( int 6 4 ( i )). ProbablyPrime ( 2 0 ) { # primes = append ( primes , i ) # } # } # # sum := 0 # biggestConsecutivePrime := [] int {} # for i := len ( primes ) - 1 ; i >= 2 1 ; i -- { # for j := 0 ; j < i - 2 1 ; j ++ { # if i - j > len ( biggestConsecutivePrime ) { # sum = arraySum ( primes [ j : i ]) # if sum < 1 0 0 0 0 0 0 && big . NewInt ( int 6 4 ( sum )). ProbablyPrime ( 2 0 ) { # fmt . Printf (" STR ", primes [ j : i ], sum ) # biggestConsecutivePrime = primes [ j : i ] # } # } # } # }
full := fmt . Sprintf (" STR ", a , b , c ) # if len ( full ) != 9 { # return false # } # set := map [ rune ] int {} # for _ , r := range full { # if r == ' 0 ' || set [ r ] > 0 { # return false # } # set [ r ] = 1 # } # return true
if root == nil { # return nil # } # if root == p || root == q { # return root # } # left := detectCommonAncestor ( root . left , p , q ) # right := detectCommonAncestor ( root . right , p , q ) # if left != nil && right != nil { # return root # } # if left == nil && right == nil { # return nil # } # if left != nil { # return left # } # return right
n := 3 # go func ( x int ) { # n = 7 # }( 5 ) # print ( n )
realA , imagA := parse ( a ) # realB , imagB := parse ( b ) # real := realA * realB - imagA * imagB # imag := realA * imagB + realB * imagA # return strconv . Itoa ( real ) + " STR " + strconv . Itoa ( imag ) + " STR "
qs := [] question 2 7 5 { # # { # para 2 7 5 {[] int { 3 , 6 , 9 , 1 }}, # ans 2 7 5 { 3 }, # }, # { # para 2 7 5 {[] int { 1 }}, # ans 2 7 5 { 1 }, # }, # # { # para 2 7 5 {[] int {}}, # ans 2 7 5 { 0 }, # }, # # { # para 2 7 5 {[] int { 3 , 0 , 6 , 1 , 5 }}, # ans 2 7 5 { 3 }, # }, # # { # para 2 7 5 {[] int { 0 , 1 , 3 , 5 , 6 }}, # ans 2 7 5 { 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 7 5 , q . para 2 7 5 # fmt . Printf (" STR ", p , hIndex 2 7 5 ( p . one )) # } # fmt . Printf (" STR ")
return len ( ListQueue ) == 0
res := make ([][] int , 1 , 1 0 2 4 ) # for _ , n := range nums { # for _ , r := range res { # res = append ( res , append ([] int { n }, r ...)) # } # } # return res
return x >= y
for i := 0 ; i < s . Cakes ; i ++ { # c := <- iced # if s . Verbose { # fmt . Println (" STR ", c ) # } # work ( s . InscribeTime , s . InscribeStdDev ) # if s . Verbose { # fmt . Println (" STR ", c ) # } # }
request , err := http . Get (" https : ) # # if err != nil { # log . Panicln (" STR ", err ) # } # # if request . StatusCode != 2 0 0 { # log . Panicln (" STR ", err ) # } # # body , _ := ioutil . ReadAll ( request . Body ) # return body
game := SnakeGame {} # game . width = width # game . height = height # game . board = make ([][] bool , height ) # for i := 0 ; i < height ; i ++ { # game . board [ i ] = make ([] bool , width ) # } # game . board [ 0 ][ 0 ] = true # # game . pos = [] int { 0 , 0 } # game . snake = make ([][] int , 0 ) # game . snake = append ( game . snake , [] int { 0 , 0 }) # game . food = food # game . foodIndex = 0 # # return game
index := [ 2 5 6 ] int {} # for i := range index { # index [ i ] = - 1 # } # # res , i := 0 , - 1 # # for j , c := range s { # if index [ c ] > i { # i = index [ c ] # } # l := j - i # if l > res { # res = l # } # index [ c ] = j # } # return res
if row >= n { # count ++ # return # } # bits := (^( cols | pie | na ) & (( 1 << uint ( n )) - 1 )) # for bits > 0 { # p := bits & - bits # dfs ( n , row + 1 , cols | p , ( pie | p )>> 1 , ( na | p )<< 1 ) # bits = bits & ( bits - 1 ) # }
cur , neg , max := 1 , 1 , a [ 0 ] # # for i := 0 ; i < len ( a ); i ++ { # # switch { # case a [ i ] > 0 : # cur , neg = a [ i ]* cur , a [ i ]* neg # case a [ i ] < 0 : # cur , neg = a [ i ]* neg , a [ i ]* cur # default : # cur , neg = 0 , 1 # } # # if max < cur { # max = cur # } # # if cur <= 0 { # cur = 1 # } # } # # return max
m . Count -- # if ! m . IsInWords [ word ] { # return - 1 # } # return matches ( m . Secret , word )
start := time . Now () # # for time . Since ( start ) < 1 0 0 0 { # if head == nil { # return false # } # # head = head . Next # } # return true
var tests = [] struct { # put bool # key , value int # }{ # { true , 1 , 1 }, # { true , 2 , 2 }, # { false , 1 , 1 }, # { true , 3 , 2 }, # { true , 3 , 3 }, # { false , 2 , - 1 }, # { true , 4 , 4 }, # { false , 1 , - 1 }, # { false , 3 , 3 }, # { false , 4 , 4 }, # } # # cache := Constructor ( 2 ) # for _ , tt := range tests { # if tt . put { # cache . Put ( tt . key , tt . value ) # t . Logf (" STR ", tt . key , tt . value ) # } else { # value := cache . Get ( tt . key ) # t . Logf (" STR ", tt . key , value ) # if value != tt . value { # t . Errorf (" STR ", tt . value ) # } # } # }
m := make ( map [ int ] int ) # for i , num := range nums { # v , ok := m [ num ] # if ok && i - v <= k { # return true # } # m [ num ] = i # } # return false
total := 0 # ws := make ([] int , len ( w )) # for i , v := range w { # total += v # ws [ i ] = total # } # return Solution { # w : ws , # total : total , # }
if num < 1 { # return false # } # for _ , n := range [...] int { 2 , 3 , 5 } { # for num % n == 0 { # num /= n # } # } # return num == 1
return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { # log . Println (" STR ") # next . ServeHTTP ( w , r ) # log . Println (" STR ") # })
names := sort . StringSlice ( readNames ()) # names . Sort () # # var sum uint 6 4 = 0 # for rank , name := range names { # score := 0 # for _ , letter := range name { # score += int ( letter - 6 4 ) # } # # sum += uint 6 4 ( score * ( rank + 1 )) # } # # fmt . Println ( sum )
if defaultLoger != nil { # defaultLoger . SetPrefix (" STR ") # defaultLoger . Printf ( msg ) # }
if floors < 0 || eggs < 0 { # panic (" STR ") # } # dp := make ([][] int , eggs + 1 ) # for i := range dp { # dp [ i ] = make ([] int , floors + 1 ) # dp [ i ][ 0 ] = 1 # } # for i := 1 ; i < floors + 1 ; i ++ { # dp [ 1 ][ i ] = i # } # for i := 2 ; i < eggs + 1 ; i ++ { # for j := 2 ; j < floors + 1 ; j ++ { # dp [ i ][ j ] = int (^ uint ( 0 ) >> 1 ) # for k := 1 ; k < j + 1 ; k ++ { # res := 1 + max ( dp [ i - 1 ][ k - 1 ], dp [ i ][ j - k ]) # if res < dp [ i ][ j ] { # dp [ i ][ j ] = res # } # } # } # } # return dp [ eggs ][ floors ]
hash := uint 3 2 ( 0 ) # for i := 0 ; i < len ( sep ); i ++ { # hash = hash * PrimeRK + uint 3 2 ( sep [ i ]) # } # var pow , sq uint 3 2 = 1 , PrimeRK # for i := len ( sep ); i > 0 ; i >>= 1 { # if i & 1 != 0 { # pow *= sq # } # sq *= sq # } # return hash , pow
return new ( FibHeapElement ). init ( key , value )
t . Parallel () # # for _ , tc := range testcases { # copied := append ([] interface {}{}, tc . input ...) # if ApplyPermutation ( copied , tc . perm ); ! reflect . DeepEqual ( copied , tc . expected ) { # t . Errorf (" STR ", tc . expected , copied ) # } # }
cases := [] struct { # name string # inputs [] int # target int # expect int # }{ # {" STR ", [] int { 1 , 2 , 2 , 2 , 3 }, 2 , 2 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := BinarySearch ( c . inputs , c . target ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
opts := TwoDimSplit (" STR ", " STR ", " STR ") # b , err := json . MarshalIndent ( opts , " STR " ") # if err != nil { # log . Fatal ( err ) # } # fmt . Println ( string ( b ))
if ipl == nil { # return 0 # } # return len ( ipl . ranges )
if len ( nums ) == 0 { # return [][] int {} # } # used , p , res := make ([] bool , len ( nums )), [] int {}, [][] int {} # generatePermutation ( nums , 0 , p , & res , & used ) # return res
if N == 0 { # return 1 # } # ans , base := 0 , 1 # for N > 0 { # if N & 1 == 0 { # ans += base # } # base , N = base << 1 , N >> 1 # } # return ans
t . Parallel () # for _ , tc := range testcases { # if result := IsHeightBalanced ( tc . root ); result != tc . heightBalanced { # t . Errorf (" STR ", tc . heightBalanced , result ) # } # }
val := big . NewInt ( 2 ) # prod := pow ( val , 1 0 0 0 ) # string := prod . String () # runes := [] rune ( string ) # sum := 0 # for i := range runes { # sum += int ( runes [ i ] - ' 0 ') # } # fmt . Println (" STR ", prod , " STR ", sum )
benchmarkFramework ( b , HeapSort )
diff := 0 # for _ , num := range nums { # diff ^= num # } # diff &= - diff # res := [] int { 0 , 0 } # for _ , num := range nums { # if ( num & diff ) == 0 { # res [ 0 ] ^= num # } else { # res [ 1 ] ^= num # } # } # return res
if head == nil || head . Next == nil || k == 0 { # return head # } # len := 1 # tail := head # for tail . Next != nil { # tail = tail . Next # len ++ # } # tail . Next = head # k = k % len # for i := 0 ; i < len - k ; i ++ { # tail = tail . Next # } # head = tail . Next # tail . Next = nil # return head
l := len ( nums ) # if l == 0 { # return false # } # left , right := 0 , l - 1 # for left <= right { # mid := left + ( right - left )/ 2 # if nums [ mid ] == target { # return true # } else if nums [ mid ] < nums [ right ] { # if nums [ mid ] < target && nums [ right ] >= target { # left = mid + 1 # } else { # right = mid - 1 # } # } else if nums [ mid ] > nums [ right ] { # if nums [ left ] <= target && nums [ mid ] > target { # right = mid - 1 # } else { # left = mid + 1 # } # } else { # right -- # } # # } # return false
if s == " STR " { # return 0 # } # result := len ( s ) # current := make ([] string , 0 , len ( s )) # dfs 1 3 2 ( s , 0 , current , & result ) # return result
var sum int # # for _ , num := range nums { # sum += num # } # # target := sum / 3 # # if sum % 3 != 0 { # return nil , errNotPossible # } # # ans := make ([][] int , 3 ) # pos := 0 # sum = 0 # # for _ , num := range nums { # sum += num # # switch { # case sum < target : # ans [ pos ] = append ( ans [ pos ], num ) # case sum == target : # ans [ pos ] = append ( ans [ pos ], num ) # sum = 0 # pos ++ # default : # return nil , errNotPossible # } # } # # return ans , nil
var ( # str string # err error # ) # if str , err = New (); err != nil { # t . Errorf (" STR ", err ) # t . FailNow () # } # t . Logf (" STR ", str )
res := [][] int {} # n := len ( nums ) # m := make ( map [ int ] int ) # # cur := make ([][] int , ( 1 << uint ( n ))+ 1 ) # cur [ 0 ] = [] int {} # curSize := 1 # # for _ , num := range nums { # k := curSize # index := m [ num ] # m [ num ] = k # for j := index ; j < k ; j ++ { # if len ( cur [ j ]) > 0 && num < cur [ j ][ len ( cur [ j ])- 1 ] { # continue # } # # tmp := append ( cur [ j ], num ) # cur [ curSize ] = tmp # curSize ++ # # if len ( tmp ) > 1 { # res = append ( res , tmp ) # } # } # } # return res
if end < int 6 4 ( 2 ) { # return make ([] int 6 4 , 0 ) # } # # ar := make ([] bool , end ) # ar [ 0 ] = true # ar [ 1 ] = true # ar [ 2 ] = false # # limit := int 6 4 ( math . Sqrt ( float 6 4 ( end ))) + 1 # # n := float 6 4 ( end ) # approxNumberPrimes := int 6 4 (( n / ( math . Log ( n ))) * ( 1 + ( 1 . 2 7 6 2 / math . Log ( n )))) # # primes := make ([] int 6 4 , approxNumberPrimes ) # primes [ 0 ] = 2 # count := 1 # # for i := int 6 4 ( 3 ); i < end ; i += 2 { # if ar [ i ] == false { # primes [ count ] = int 6 4 ( i ) # count ++ # # if i < limit { # for j := i * i ; j < end ; j += i { # ar [ j ] = true # } # } # } # } # # return primes [: count ]
var current , pos , i int # positions := [ 7 ] int { 1 , 1 0 , 1 0 0 , 1 0 0 0 , 1 0 0 0 0 , 1 0 0 0 0 0 , 1 0 0 0 0 0 0 } # var digits [ 7 ] int # var s string # for ; ; i ++ { # s = fmt . Sprint ( i ) # if pos <= positions [ current ] && positions [ current ] < pos + len ( s ) { # digits [ current ] = int ( s [ positions [ current ]- pos ]) - 4 8 # fmt . Printf (" STR ", digits [ current ], i , positions [ current ]) # current ++ # } # pos += len ( s ) # if current == 7 { # break # } # } # fmt . Println ( digits ) # mul := 1 # for _ , d := range digits { # mul *= d # } # fmt . Printf (" STR ", mul )
res := make ([] int , len ( nums )) # var root * node # for i := len ( nums ) - 1 ; i >= 0 ; i -- { # root = insert ( root , nums [ i ], i , 0 , & res ) # } # return res
if n < 1 || m < 1 { # panic (" STR ") # } else if n == 1 || m == 1 { # return 1 # } # return CountPathsBrute ( m - 1 , n ) + CountPathsBrute ( m , n - 1 )
if divide ( 1 0 , 2 ) != 0 && divide ( 1 0 , 3 ) != 1 { # t . Error () # }
qs := [] question 6 9 7 { # # { # para 6 9 7 {[] int { 1 , 2 , 2 , 3 , 1 }}, # ans 6 9 7 { 2 }, # }, # # { # para 6 9 7 {[] int { 1 , 2 , 2 , 3 , 1 , 4 , 2 }}, # ans 6 9 7 { 6 }, # }, # # { # para 6 9 7 {[] int {}}, # ans 6 9 7 { 0 }, # }, # # { # para 6 9 7 {[] int { 1 , 1 , 1 , 1 , 1 }}, # ans 6 9 7 { 5 }, # }, # # { # para 6 9 7 {[] int { 1 , 2 , 2 , 3 , 1 , 4 , 2 , 1 , 2 , 2 , 3 , 1 , 4 , 2 }}, # ans 6 9 7 { 1 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 9 7 , q . para 6 9 7 # fmt . Printf (" STR ", p , findShortestSubArray ( p . one )) # } # fmt . Printf (" STR ")
loadFile () # names := parseNames () # # sort . Strings ( names ) # # totalScore := 0 # # for i , name := range names { # # characters := [] rune ( name ) # # nameValue := 0 # # for _ , char := range characters { # nameValue += getValue ( char ) # } # # totalScore += nameValue * ( i + 1 ) # # } # # fmt . Println ( totalScore ) #
tests := [...] testType { # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : false , # }, # { # in : " STR ", # want : false , # }, # } # # for _ , tt := range tests { # got := isPalindrome ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if len ( arr ) <= 1 { # return arr # } # slow := 0 # fast := 0 # for i := 0 ; i <= len ( arr )- 1 ; i ++ { # if arr [ slow ] != arr [ fast ] { # slow = slow + 1 # arr [ slow ] = arr [ fast ] # } # fast ++ # } # return arr [ 0 : slow + 1 ]
var tests = [] struct { # n int # trees []* TreeNode # }{ # { 0 , nil }, # { # 3 , # []* TreeNode { # newTree ( 1 , nil , 2 , nil , 3 ), # newTree ( 1 , nil , 3 , 2 ), # newTree ( 2 , 1 , 3 ), # newTree ( 3 , 1 , nil , nil , 2 ), # newTree ( 3 , 2 , nil , 1 ), # }, # }, # } # # for _ , tt := range tests { # trees := generateTrees ( tt . n ) # if reflect . DeepEqual ( trees , tt . trees ) == false { # t . Errorf (" STR ", tt . n , trees , tt . trees ) # } # }
if len ( s ) == 0 { # return 0 # } # s = strings . TrimSpace ( s ) # sArr := strings . Split ( s , " STR ") # return len ( sArr [ len ( sArr )- 1 ])
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 3 , 2 , 1 }, 1 }, # {" STR ", [] int { 1 , 2 }, 2 }, # {" STR ", [] int { 2 , 2 , 3 , 1 }, 1 }, # {" STR ", [] int { 1 }, 1 }, # {" STR ", [] int {}, 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
return MapSum { m : make ( map [ string ] int , 1 2 8 ), # keys : make ([] string , 0 , 1 2 8 )}
qs := [] question 1 9 0 { # # { # para 1 9 0 { 4 3 2 6 1 5 9 6 }, # ans 1 9 0 { 9 6 4 1 7 6 1 9 2 }, # }, # # { # para 1 9 0 { 4 2 9 4 9 6 7 2 9 3 }, # ans 1 9 0 { 3 2 2 1 2 2 5 4 7 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 9 0 , q . para 1 9 0 # fmt . Printf (" STR ", p , reverseBits ( p . one )) # } # fmt . Printf (" STR ")
var tests = [] struct { # candidates [] int # target int # combinations [][] int # }{ # {[] int { 2 , 3 , 6 , 7 }, 7 , [][] int {{ 2 , 2 , 3 }, { 7 }}}, # {[] int { 2 , 3 , 5 }, 8 , [][] int {{ 2 , 2 , 2 , 2 }, { 2 , 3 , 3 }, { 3 , 5 }}}, # } # # for _ , tt := range tests { # combinations := combinationSum ( tt . candidates , tt . target ) # if reflect . DeepEqual ( combinations , tt . combinations ) == false { # t . Errorf (" STR ", tt . candidates , tt . target , combinations , tt . combinations ) # } # }
if 1 == n { # return 9 # } # # max := int ( math . Pow 1 0 ( n ) - 1 ) # for v := max - 1 ; v > max / 1 0 ; v -- { # u , _ := strconv . Atoi ( strconv . Itoa ( v ) + reverseInt ( v )) # for x := max ; x * x >= u ; x -- { # if u % x == 0 { # return u % 1 3 3 7 # } # } # } # return 0
println (" STR ", p . a , p . b )
numList , left , right , count , freqMap , res , length := [] element {}, 0 , - 1 , 0 , map [ int ] int {}, make ([] int , 2 ), math . MaxInt 6 4 # for i , ns := range nums { # for _ , v := range ns { # numList = append ( numList , element { val : v , index : i }) # } # } # sort . Sort ( SortByVal { numList }) # for left < len ( numList ) { # if right + 1 < len ( numList ) && count < len ( nums ) { # right ++ # if freqMap [ numList [ right ]. index ] == 0 { # count ++ # } # freqMap [ numList [ right ]. index ]++ # } else { # if count == len ( nums ) { # if numList [ right ]. val - numList [ left ]. val < length { # length = numList [ right ]. val - numList [ left ]. val # res [ 0 ] = numList [ left ]. val # res [ 1 ] = numList [ right ]. val # } # } # freqMap [ numList [ left ]. index ]-- # if freqMap [ numList [ left ]. index ] == 0 { # count -- # } # left ++ # } # } # return res
if len ( arr ) == 0 { # return arr # } # maxElement := max ( arr ) # for exp := 1 ; maxElement / exp > 0 ; exp *= 1 0 { # arr = countSort ( arr , exp ) # } # return arr
sort . Sort ( sort . Reverse ( sort . IntSlice ( d ))) # size := len ( d ) # # lo , hi := 0 , size - 1 # var mi int # for lo <= hi { # mi = ( lo + hi ) / 2 # if d [ mi ] > mi { # lo = mi + 1 # } else { # hi = mi - 1 # } # } # # return lo
lcs := make ([][] int , m + 1 ) # for i := 0 ; i <= m ; i ++ { # lcs [ i ] = make ([] int , n + 1 ) # } # # for i := 0 ; i <= m ; i ++ { # for j := 0 ; j <= n ; j ++ { # if i == 0 || j == 0 { # lcs [ i ][ j ] = 0 # } else if a [ i - 1 ] == b [ j - 1 ] { # lcs [ i ][ j ] = lcs [ i - 1 ][ j - 1 ] + 1 # } else { # lcs [ i ][ j ] = Max ( lcs [ i - 1 ][ j ], lcs [ i ][ j - 1 ]) # } # } # } # return lcs [ m ][ n ]
t . Parallel () # # for _ , tc := range testcases { # if result := LongestIncreasingSubsequence ( tc . seq ); ! reflect . DeepEqual ( result , tc . lis ) { # t . Errorf (" STR ", tc . lis , result ) # } # }
if i < 1 || (( i & 2 ) != 0 ) || (( i & 7 ) == 5 ) || (( i & 1 1 ) == 8 ) { # return false # } # test := int ( math . Sqrt ( float 6 4 ( i ))) # return test * test == i
i , j := 0 , len ( numbers )- 1 # for i < j { # if numbers [ i ]+ numbers [ j ] == target { # return [] int { i + 1 , j + 1 } # } else if numbers [ i ]+ numbers [ j ] < target { # i ++ # } else { # j -- # } # } # return [] int {- 1 , - 1 }
length := len ( nums ) # if length == 0 { # return - 1 # } # if length == 1 { # if nums [ 0 ] != target { # return - 1 # } # return 0 # } # return search 1 ( nums , 0 , length - 1 , target )
u := 0 # for _ , v := range data { # if u == 0 && v >> 7 == 0 { # u = 0 # } else if u == 0 && v >> 5 == 6 { # u = 1 # } else if u == 0 && v >> 4 == 1 4 { # u = 2 # } else if u == 0 && v >> 3 == 3 0 { # u = 3 # } else if u > 0 && v >> 6 == 2 { # u -- # } else { # return false # } # } # return u == 0
res := [] int {} # # var dfs func (* TreeNode , int ) # dfs = func ( node * TreeNode , level int ) { # if node == nil { # return # } # if level == len ( res ) { # res = append ( res , node . Val ) # } else { # res [ level ] = max ( res [ level ], node . Val ) # } # dfs ( node . Left , level + 1 ) # dfs ( node . Right , level + 1 ) # } # # dfs ( root , 0 ) # return res
l := & ListNode { Next : head } # for prev := l ; head != nil ; head = head . Next { # if head . Val == val { # prev . Next = head . Next # } else { # prev = head # } # } # return l . Next
if len ( prices ) == 0 { # return 0 # } # buy := prices [ 0 ] # sale , max := 0 , 0 # for _ , v := range prices [ 1 :] { # if v - buy > 0 { # sale = v - buy # } # if sale > max { # max = sale # } # if v < buy { # buy = v # } # } # return max
return MinStack { # data : make ([] int , 0 ), # min : make ([] int , 0 ), # }
if len ( s ) == 0 { # return 0 # } # # return len ( strings . Fields ( s ))
if a . Cmp ( big . NewInt ( 1 0 )) < 1 || b . Cmp ( big . NewInt ( 1 0 )) < 1 { # return mul ( a , b ) # } # # m := _pivot ( a , b ) # # leftA , rightA := _split ( a , uint ( m )) # leftB , rightB := _split ( b , uint ( m )) # # z 0 := k_multiply ( leftA , leftB ) # z 1 := k_multiply ( rightA , rightB ) # z 2 := k_multiply ( add ( leftA , rightA ), add ( leftB , rightB )) # z 2 = sub ( z 2 , add ( z 0 , z 1 )) # # temp 0 := mul ( z 0 , big . NewInt ( int 6 4 ( math . Pow ( 1 0 . 0 , 2 . 0 * float 6 4 ( m ))))) # temp 1 := mul ( z 2 , big . NewInt ( int 6 4 ( math . Pow ( 1 0 . 0 , float 6 4 ( m ))))) # temp 2 := add ( temp 0 , temp 1 ) # # return add ( temp 2 , z 1 )
low , high := 1 , 1 0 0 0 0 0 0 # for low < high { # mid := low + ( high - low )>> 1 # if calDivisor ( nums , mid , threshold ) { # high = mid # } else { # low = mid + 1 # } # } # return low
return root . SearchHelper ( word , 0 , len ( word ), 0 )
wordsFreq := make ([] int , 0 ) # for _ , word := range words { # wordsFreq = append ( wordsFreq , calculateFrequency ( word )) # } # sort . Ints ( wordsFreq ) # res , n := make ([] int , 0 ), len ( wordsFreq ) # for _ , query := range queries { # queryFreq := calculateFrequency ( query ) # res = append ( res , n - sort . Search ( n , func ( i int ) bool { # return wordsFreq [ i ] > queryFreq # })) # } # return res
curr := root # for curr != nil { # if curr . Child == nil { # curr = curr . Next # } else { # next := curr . Next # node := Solution ( curr . Child ) # curr . Child = nil # curr . Next , node . Prev = node , curr # for curr . Next != nil { # curr = curr . Next # } # if next == nil { # break # } # curr . Next , next . Prev = next , curr # curr = curr . Next # } # } # return root
return Solution { # r : radius , # a : xCenter , # b : yCenter , # }
if s == " STR " { # return " STR " # } # sMap := map [ byte ] int {} # cMap := map [ int ][] byte {} # sb := [] byte ( s ) # for _ , b := range sb { # sMap [ b ]++ # } # for key , value := range sMap { # cMap [ value ] = append ( cMap [ value ], key ) # } # # var keys [] int # for k := range cMap { # keys = append ( keys , k ) # } # sort . Sort ( sort . Reverse ( sort . IntSlice ( keys ))) # res := make ([] byte , 0 ) # for _ , k := range keys { # for i := 0 ; i < len ( cMap [ k ]); i ++ { # for j := 0 ; j < k ; j ++ { # res = append ( res , cMap [ k ][ i ]) # } # } # } # return string ( res )
x := 0 # for j := 0 ; j < len ( nums ); j ++ { # if nums [ j ] != val { # if x != j { # nums [ x ] = nums [ j ] # } # x ++ # } # } # return x
sort . Ints ( A ) # need := 0 # res := 0 # for _ , a := range A { # res += max ( need - a , 0 ) # need = max ( a , need ) + 1 # } # return res
var tests = [] struct { # strs [] string # prefix string # }{ # {[] string {" STR ", " STR ", " STR "}, " STR "}, # {[] string {" STR ", " STR "}, " STR "}, # {[] string {" STR ", " STR ", " STR "}, " STR "}, # {[] string {" STR ", " STR "}, " STR "}, # {[] string {}, " STR "}, # } # # for _ , tt := range tests { # prefix := longestCommonPrefix ( tt . strs ) # if prefix != tt . prefix { # t . Errorf (" STR ", tt . strs , prefix , tt . prefix ) # } # }
return int 6 4 ( offset )<< _cacheOffsetBit + int 6 4 ( size )
t . Parallel () # # for _ , tc := range testcases { # if result := TwentyFourGame ( tc . digits ); result != tc . expected { # t . Errorf (" STR ", tc . digits , tc . expected , result ) # } # }
return k . Width
if len ( this . data ) == 0 { # this . data = append ( this . data , val ) # this . min = append ( this . min , val ) # return # } # # top := this . min [ len ( this . min )- 1 ] # this . data = append ( this . data , val ) # if top > val { # top = val # } # # this . min = append ( this . min , top )
return c . ll . Len ()
return & factorial { # val : make ( map [ int ] int , n ), # }
cur := head # last := head # for i := 0 ; i < n ; i ++ { # if cur . Next != nil { # cur = cur . Next # } else { # return head . Next # } # } # for cur . Next != nil { # cur = cur . Next # last = last . Next # } # last . Next = last . Next . Next # return head
n := len ( start ) # if len ( end ) != n { # return false # } # for i , j := 0 , 0 ; i < n && j < n ; i , j = i + 1 , j + 1 { # for i < n && start [ i ] == ' X ' { # i ++ # } # for j < n && end [ j ] == ' X ' { # j ++ # } # if i == n && j == n { # return true # } # if i == n || j == n || # start [ i ] != end [ j ] || # start [ i ] == ' L ' && j > i || # start [ i ] == ' R ' && i > j { # return false # } # } # return true
res := [] int {} # for _ , v := range asteroids { # for len ( res ) != 0 && res [ len ( res )- 1 ] > 0 && res [ len ( res )- 1 ] < - v { # res = res [: len ( res )- 1 ] # } # if len ( res ) == 0 || v > 0 || res [ len ( res )- 1 ] < 0 { # res = append ( res , v ) # } else if v < 0 && res [ len ( res )- 1 ] == - v { # res = res [: len ( res )- 1 ] # } # } # return res
qs := [] question 4 1 0 { # # { # para 4 1 0 {[] int { 7 , 2 , 5 , 1 0 , 8 }, 2 }, # ans 4 1 0 { 1 8 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 1 0 , q . para 4 1 0 # fmt . Printf (" STR ", p , splitArray ( p . nums , p . m )) # } # fmt . Printf (" STR ")
if len ( s ) == 0 { # return 0 # } # # strs := strings . Fields ( s ) # return len ( strs )
res := make ([] int , 0 ) # for _ , val 1 := range nums { # c := 0 # for _ , val 2 := range nums { # if val 2 < val 1 { # c ++ # } # } # res = append ( res , c ) # } # return res
defer wg . Done () # for i := 1 ; i <= 1 0 ; i ++ { # num := rand . Intn ( 5 0 ) # sqrs <- squarevalue { # input : num , # value : num * num , # } # }
numbers := [] int { 1 , 2 , 3 , 3 , 3 , 3 , 4 , 5 } # k := 3 # fmt . Println ( getNumberOfK ( numbers , k ))
return MyCircularDeque {& node {}, & node {}, 0 , k }
return numPath ( root , sum , true )
type Server struct { # Name string # ID int 3 2 # Enabled bool # } # # a := & Server {} # isZeroA := IsZero ( a ) # # b := & Server { # Name : " STR ", # Enabled : true , # } # isZeroB := IsZero ( b ) # # fmt . Printf (" STR ", isZeroA ) # fmt . Printf (" STR ", isZeroB )
max , factor := 0 , 0 # num := 6 0 0 8 5 1 4 7 5 1 4 3 # for num != 1 { # factor = chop ( num ) # num = num / factor # if factor > max { # max = factor # } # } # fmt . Print (" STR ", max )
s . mtx . RLock () # defer s . mtx . RUnlock () # p , ok := s . m [ id ] # if ! ok { # return Profile {}, ErrNotFound # } # return p , nil
if t . Kind () != Struct { # panic (& TypeError {" STR "}) # } # structIdentifier := t . stripPrefix () # n , _ := readVarint ( unsafe . Pointer ( uintptr ( unsafe . Pointer (& structTypesSidetable )) + uintptr ( structIdentifier ))) # return int ( n )
s := newStruct () # # v := s . Field (" STR "). Tag (" STR ") # if v != "" { # t . Errorf (" STR ", v ) # } # # v = s . Field (" STR "). Tag (" STR ") # if v != " STR " { # t . Errorf (" STR ", v ) # } # # v = s . Field (" STR "). Tag (" STR ") # if v != "" { # t . Errorf (" STR ", v ) # } # # v = s . Field (" STR "). Tag (" STR ") # if v != " STR " { # t . Errorf (" STR ", v ) # } # # v = s . Field (" STR "). Tag (" STR ") # if v != "" { # t . Errorf (" STR ", v ) # }
var charMap = map [ byte ] bool {} # var maxLen = 0 # var currentLen = 0 # # for i := 0 ; i < len ( s ); i ++ { # if charMap [ s [ i ]] == true { # loopIdx := i - currentLen # for loopIdx < i { # delete ( charMap , s [ loopIdx ]) # currentLen -- # # if s [ loopIdx ] == s [ i ] { # break # } # loopIdx ++ # } # } # # charMap [ s [ i ]] = true # currentLen ++ # if currentLen > maxLen { # maxLen = currentLen # } # } # # return maxLen
queue := make ([] int , 0 ) # for _ , num := range A { # for _ , n := range queue { # if n == num { # return num # } # } # # queue = append ( queue , num ) # if len ( queue ) > 4 { # queue = queue [ 1 :] # } # } # # return - 1
log . Printf (" STR ", term ) # # var r [] Result # # time . Sleep ( time . Millisecond * time . Duration ( rand . Int 6 3 n ( 9 0 0 ))) # # r = append ( r , Result { # Engine : " STR ", # Title : " STR ", # Description : " STR ", # Link : " http : , # }) # # log . Printf (" STR ", len ( r )) # results <- r
queue := & Queue {} # queue . queue = make ([] interface {}, 0 ) # queue . len = 0 # queue . lock = new ( sync . Mutex ) # # return queue
index := search ( nums , target ) # if index == - 1 { # return [] int {- 1 , - 1 } # } # # first := index # for { # f := search ( nums [: first ], target ) # if f == - 1 { # break # } # first = f # } # # last := index # for { # l := search ( nums [ last + 1 :], target ) # if l == - 1 { # break # } # last += l + 1 # } # # return [] int { first , last }
starttime := time . Now () # # maxP := int 6 4 ( 1 0 0 0 0 0 0 0 0 0 ) # max := int 6 4 ( 5 0 0 0 0 ) # total := int 6 4 ( 0 ) # # for n := int 6 4 ( 1 ); n < max ; n ++ { # for m := n + 1 ; m < max ; m += 2 { # a := m * m - n * n # b := 2 * m * n # c := m * m + n * n # # if 2 * a == c + 1 || 2 * a == c - 1 { # p := 2 * ( a + c ) # if p <= maxP { # total += p # } # } # # if 2 * b == c + 1 || 2 * b == c - 1 { # p := 2 * ( b + c ) # if p <= maxP { # total += p # } # } # } # } # # fmt . Println ( total ) # # fmt . Println (" STR ", time . Since ( starttime ))
cases := [] struct { # name string # inputs * ListNode # expect int # }{ # {" STR ", & ListNode { 1 , & ListNode { 0 , & ListNode { 1 , nil }}}, 5 }, # {" STR ", & ListNode { 0 , nil }, 0 }, # {" STR ", & ListNode { 1 , & ListNode { 1 , & ListNode { 1 , nil }}}, 7 }, # {" STR ", & ListNode { 0 , & ListNode { 1 , nil }}, 1 }, # {" STR ", & ListNode { 1 , & ListNode { 0 , nil }}, 2 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
size := len ( A ) # h := intHeap ( A ) # # heap . Init (& h ) # # a := heap . Pop (& h ).( int ) # b := heap . Pop (& h ).( int ) # for i := size - 3 ; i >= 0 ; i -- { # c := heap . Pop (& h ).( int ) # if a < b + c { # return a + b + c # } # a , b = b , c # } # return 0
p := make ([] int , len ( seq )) # m := make ([] int , len ( seq )+ 1 ) # var l int # for i := range seq { # lo := 1 # hi := l # for lo <= hi { # mid := ( lo + hi ) / 2 # if ( lo + hi )% 2 != 0 { # mid ++ # } # if seq [ m [ mid ]] <= seq [ i ] { # lo = mid + 1 # } else { # hi = mid - 1 # } # } # newL := lo # p [ i ] = m [ newL - 1 ] # m [ newL ] = i # if newL > l { # l = newL # } # } # s := make ([] int , l ) # k := m [ l ] # for i := len ( s ) - 1 ; i >= 0 ; i -- { # s [ i ] = seq [ k ] # k = p [ k ] # } # return s
return & Node { val , nil , nil }
return syscall . Geteuid ()
ans , z := 0 , x ^ y # for z > 0 { # ans += z & 1 # z >>= 1 # } # return ans
var s int # for _ , c := range m . cache { # s += c . Capacity () # } # return s
numbers := [] int { 1 0 , 1 1 , 1 2 , 1 3 , 1 4 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } # # ans := getLeastNumbers ( numbers , 3 ) # for _ , value := range ans { # fmt . Println ( value ) # } #
if root == nil { # return nil # } # res := [] int {} # stack := []* TreeNode { root } # p := root # for len ( stack ) != 0 { # node := stack [ len ( stack )- 1 ] # l , r := node . Left , node . Right # if l == p || r == p || l == nil && r == nil { # res = append ( res , node . Val ) # stack = stack [: len ( stack )- 1 ] # p = node # } else { # if r != nil { # stack = append ( stack , r ) # } # if l != nil { # stack = append ( stack , l ) # } # } # } # return res
p (" STR ") # total := big . NewInt ( 0 ) # var i int 6 4 # for i = 1 ; i <= 1 0 0 0 ; i ++ { # item := big . NewInt ( i ) # exp := item . Exp ( item , item , nil ) # total = total . Add ( total , exp ) # } # number := total . String () # p ( number [( len ( number ) - 1 0 ):( len ( number ))])
return !( strings . Count ( s , " STR ") > 1 || strings . Contains ( s , " STR "))
if head == nil { # return nil # } # ret := head # for head . Next != nil { # if head . Val == head . Next . Val { # head . Next = head . Next . Next # continue # } # head = head . Next # } # return ret
var result [] int # for i := 0 ; i < len ( nums )- k + 1 ; i ++ { # max := nums [ i ] # for j := i + 1 ; j < i + k ; j ++ { # if nums [ j ] > max { # max = nums [ j ] # } # } # result = append ( result , max ) # } # return result
return ( p 1 . X == p 2 . X ) && ( p 1 . Y == p 2 . Y )
t . Parallel () # cards := NewDeck () # Shuffle ( cards , 5 )
arr := randomSlice ( 0 , 2 0 , 1 0 ) # bst := newBstRecrusive () # for _ , v := range arr { # bst . Insert ( uint 3 2 ( v )) # } # max := int ( bst . Max ( bst . root ).(* bstElement ). Key ) # sort . Ints ( arr ) # if max != arr [ len ( arr )- 1 ] { # t . Log ( fmt . Sprintf (" STR ", arr [ len ( arr )- 1 ], max )) # t . Fail () # }
fmt . Println ( strconv . Itoa ( 1 )) # fmt . Println ( strings . Compare (" STR "," STR ")) # fmt . Println ( math . Abs ( 1 . 0 ))
n := strconv . Itoa ( N ) # ld , ln := len ( D ), len ( n ) # res := 0 # for i := 1 ; i < ln ; i ++ { # res += pow ( ld , i ) # } # for i := 0 ; i < ln ; i ++ { # same := false # for _ , d := range D { # if d [ 0 ] < n [ i ] { # res += pow ( ld , ln - i - 1 ) # } else if d [ 0 ] == n [ i ] { # same = true # } # } # if ! same { # return res # } # } # return res + 1
fmt . Println ( reverseVowels (" STR "))
l := 0 # r := len ( nums ) - 1 # for i := 0 ; i <= r ; i ++ { # if nums [ i ] == 0 { # nums [ i ], nums [ l ] = nums [ l ], nums [ i ] # l ++ # } # if nums [ i ] == 2 { # nums [ i ], nums [ r ] = nums [ r ], nums [ i ] # i -- # r -- # } # }
sum , min , l := 0 , math . MaxInt 3 2 , len ( nums ) # for _ , v := range nums { # sum += v # if min > v { # min = v # } # } # return sum - min * l
m := make ( map [ int ] int ) # # for _ , v := range nums 1 { # if _ , ok := m [ v ]; ok { # m [ v ]++ # } else { # m [ v ] = 1 # } # } # # ret := [] int {} # # for _ , v := range nums 2 { # if val , ok := m [ v ]; val > 0 && ok { # ret = append ( ret , v ) # m [ v ]-- # } # } # return ret
n := len ( s ) # if n < 2 { # return n # } # # dp := make ([][] int , n ) # for i := 0 ; i < n ; i ++ { # dp [ i ] = make ([] int , n ) # dp [ i ][ i ] = 1 # } # # for k := 2 ; k <= n ; k ++ { # for i := 0 ; i + k - 1 < n ; i ++ { # j := i + k - 1 # dp [ i ][ j ] = dp [ i ][ j - 1 ] + 1 # if s [ j - 1 ] == s [ j ] { # dp [ i ][ j ]-- # } # # for k := i + 1 ; k <= j ; k ++ { # if s [ k - 1 ] == s [ j ] { # dp [ i ][ j ] = min ( dp [ i ][ j ], dp [ i ][ k - 1 ]+ dp [ k ][ j ]- 1 ) # } # } # } # } # return dp [ 0 ][ n - 1 ]
solved := false # r := factor # # for i := factor ; solved != true ; i += factor { # for j := factor ; j > 0 ; j -- { # if i % j != 0 { # break # } # if j == 1 { # solved = true # break # } # } # # r = i # } # # fmt . Println (" STR ", r )
t . Run (" STR ", func ( t * testing . T ) { # got := strStr (" STR ", " STR ") # want := 2 # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # }) # # t . Run (" STR ", func ( t * testing . T ) { # got := strStr (" STR ", " STR ") # want := - 1 # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # })
m , n := len ( A ), len ( A [ 0 ]) # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # if i == 0 || i == m - 1 || j == 0 || j == n - 1 { # if A [ i ][ j ] == 1 { # dfsNumEnclaves ( A , i , j ) # } # } # } # } # count := 0 # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # if A [ i ][ j ] == 1 { # count ++ # } # } # } # return count
f := map [ string ] int {} # for _ , word := range words { # f [ word ]++ # } # l := make ([]* entry , 0 , len ( f )) # for word , freq := range f { # l = append ( l , & entry { # word : word , # freq : freq , # }) # } # sort . Slice ( l , func ( i , j int ) bool { # if l [ i ]. freq == l [ j ]. freq { # return l [ i ]. word < l [ j ]. word # } # return l [ i ]. freq > l [ j ]. freq # }) # res := make ([] string , k ) # for i := 0 ; i < k ; i ++ { # res [ i ] = l [ i ]. word # } # return res
return & conn { # conn : netConn , # bw : bufio . NewWriter ( netConn ), # br : bufio . NewReader ( netConn ), # readTimeout : readTimeout , # writeTimeout : writeTimeout , # }
var diff int # sort . Ints ( nums ) # for i := 0 ; i < len ( nums )- 2 ; i ++ { # if i == 0 { # diff = nums [ 0 ] + nums [ 1 ] + nums [ len ( nums )- 1 ] - target # } else if i > 0 && nums [ i ] == nums [ i - 1 ] { # continue # } # j , k := i + 1 , len ( nums )- 1 # for j < k { # if j > i + 1 && nums [ j ] == nums [ j - 1 ] { # j ++ # continue # } # tmp := nums [ i ] + nums [ j ] + nums [ k ] - target # if tmp == 0 { # return target # } else { # if tmp < 0 { # j ++ # } else { # k -- # } # if abs ( tmp ) < abs ( diff ) { # diff = tmp # } # } # } # } # return diff + target
index := make ([] int , len ( nums )) # for i := 0 ; i < len ( nums ); i ++ { # index [ i ] = nums [ i ] + i # } # jump , max_index := 0 , index [ 0 ] # for jump < len ( index ) && jump <= max_index { # if max_index < index [ jump ] { # max_index = index [ jump ] # } # jump ++ # } # # if jump == len ( index ) { # return true # } # return false
total := 1 # for n > 0 { # total *= n # n -- # } # return total
foo := [] string {" STR "} # # defer func () { # err := recover () # if err == nil { # t . Error (" STR ") # } # }() # # _ = Map ( foo )
strSize := len ( A [ 0 ]) # groups := make ( map [[ 2 6 ] int ] bool , len ( A )) # for _ , a := range A { # count := [ 2 6 ] int {} # i := 0 # for i = 0 ; i + 1 < strSize ; i += 2 { # count [ a [ i ]-' a ']++ # count [ a [ i + 1 ]-' a '] += 1 0 0 # } # if i < strSize { # count [ a [ i ]-' a ']++ # } # groups [ count ] = true # } # return len ( groups )
if n < 2 { # return 1 # } # # if answer , ok := table [ n ]; ok { # return answer # } # # answer := int 6 4 ( 1 ) # # for i := 0 ; i < n ; i ++ { # if n - i >= 4 { # answer += tile ( n - i - 4 ) # } # if n - i >= 3 { # answer += tile ( n - i - 3 ) # } # if n - i >= 2 { # answer += tile ( n - i - 2 ) # } # } # # table [ n ] = answer # # return answer #
size := len ( logs ) # # res := make ([] int , n ) # stack := make ([] int , 0 , size ) # endPoint := 0 # lastEndPoint := 0 # # for _ , log := range logs { # fid , soe , ts := analyze ( log ) # # if soe == " STR " { # endPoint = ts # if len ( stack ) > 0 { # res [ stack [ len ( stack )- 1 ]] += endPoint - lastEndPoint # } # stack = append ( stack , fid ) # lastEndPoint = endPoint # } else { # endPoint = ts + 1 # res [ fid ] += endPoint - lastEndPoint # stack = stack [: len ( stack )- 1 ] # lastEndPoint = endPoint # } # # } # # return res
head := createSingleList ([] int { 1 , 2 , 3 , 4 }) # expected := createSingleList ([] int { 2 , 1 , 4 , 3 }) # if res := swapPairs ( head ); ! reflect . DeepEqual ( res , expected ) { # t . Errorf (" STR ", expected , res ) # }
outer : # for { # switch l . next () { # case " STR ": # l . backup () # break outer # case eof : # return l . error (" STR ") # } # } # l . emit ( itemUnit ) # l . chomp () # return byteStart
req_buffer , err := ioutil . ReadAll ( read ) # if err != nil { # log . Printf (" STR ", err . Error ()) # } # return string ( req_buffer )
m = len ( board ) # n = len ( board [ 0 ]) # visited = make ([][] bool , m ) # for i := 0 ; i < m ; i ++ { # visited [ i ] = make ([] bool , n ) # } # for i := 0 ; i < len ( board ); i ++ { # for j := 0 ; j < len ( board [ i ]); j ++ { # if searchWord ( board , word , 0 , i , j ) { # return true # } # } # } # return false
t . Parallel () # # for _ , tc := range testcases { # q := NewQueue () # # for _ , v := range tc . inserts { # q . Enqueue ( v ) # } # # for _ , v := range tc . inserts { # if res , err := q . Dequeue (); err != nil { # t . Errorf (" STR ") # } else if res != v { # t . Errorf (" STR ", v , res ) # } # } # # if _ , err := q . Dequeue (); err == nil { # t . Errorf (" STR ") # } # }
res := 0 # for _ , n := range nums { # res += 1 - len ( strconv . Itoa ( n ))% 2 # } # return res
if N == 0 { # return " STR " # } # res := " STR " # for N != 0 { # remainder := N % (- 2 ) # N = N / (- 2 ) # if remainder < 0 { # remainder += 2 # N ++ # } # res = strconv . Itoa ( remainder ) + res # } # return res
node := & BinaryTree { preorder [ 0 ], nil , nil } # preorder = preorder [ 1 :] # if len ( inorder ) == 1 { # return node , preorder # } # index := search ( inorder , node . value ) # node . left , preorder = Reconstruct ( preorder , inorder [: index ]) # node . right , preorder = Reconstruct ( preorder , inorder [ index + 1 :]) # return node , preorder
open , _ := strconv . ParseFloat ( row [ 1 ], 6 4 ) # return record { # Date : row [ 0 ], # Open : open , # }
if len ( intervals ) == 0 { # return 0 # } # sort . Sort ( Intervals ( intervals )) # dp , res := make ([] int , len ( intervals )), 0 # for i := range dp { # dp [ i ] = 1 # } # for i := 1 ; i < len ( intervals ); i ++ { # for j := 0 ; j < i ; j ++ { # if intervals [ i ][ 0 ] >= intervals [ j ][ 1 ] { # dp [ i ] = max ( dp [ i ], 1 + dp [ j ]) # } # } # } # for _ , v := range dp { # res = max ( res , v ) # } # return len ( intervals ) - res
cur := node .(* gbtElement ) # for ! t . IsNil ( cur . Left ) { # cur = cur . Left # } # return cur
n := len ( row ) # # pairs := make ([][] int , 0 , 3 0 ) # for i := 0 ; i < n ; i += 2 { # if ! isCouple ( row [ i ], row [ i + 1 ]) { # pairs = append ( pairs , makePair ( row [ i ], row [ i + 1 ])) # } # } # # res := 0 # # for len ( pairs ) > 0 { # sort . Slice ( pairs , func ( i , j int ) bool { # return pairs [ i ][ 0 ] < pairs [ j ][ 0 ] # }) # # for len ( pairs ) > 1 && isCouple ( pairs [ 0 ][ 1 ], pairs [ 1 ][ 1 ]) { # pairs = pairs [ 2 :] # res ++ # } # # if len ( pairs ) == 0 { # break # } # # pairs [ 1 ] = makePair ( pairs [ 0 ][ 1 ], pairs [ 1 ][ 1 ]) # pairs = pairs [ 1 :] # res ++ # } # # return res
for n > 0 { # digit := n % 1 0 # digits = append ([] int { digit }, digits ...) # n /= 1 0 # } # return
n := len ( nums ) # sort . Ints ( nums ) # # res := 0 # for i , j := 0 , n - 1 ; i < j ; { # res += nums [ j ] - nums [ i ] # i ++ # j -- # } # return res
if len ( s ) != len ( t ) { # return false # } # # sr := [] rune ( s ) # tr := [] rune ( t ) # # rec := make ( map [ rune ] int , len ( sr )) # for i := range sr { # rec [ sr [ i ]]++ # rec [ tr [ i ]]-- # } # # for _ , n := range rec { # if n != 0 { # return false # } # } # # return true
return ( f - 3 2 ) * 5 / 9
cache , res := make ([][] int , len ( matrix )), 0 # for i := 0 ; i < len ( cache ); i ++ { # cache [ i ] = make ([] int , len ( matrix [ 0 ])) # } # for i , v := range matrix { # for j := range v { # searchPath ( matrix , cache , math . MinInt 6 4 , i , j ) # res = max ( res , cache [ i ][ j ]) # } # } # return res
fmt . Println ( getSmallestNumberByCondition ( isDivisibleBy 1 to 2 0 ))
res := 1 # for i := 0 ; i < len ( b ); i ++ { # res = ( qpow ( res , 1 0 ) * qpow ( a , b [ i ])) % 1 3 3 7 # } # return res
thread := & Thread {} # thread . pc = 0 # thread . stack = NewStack ( MAX_FRAME_DEPTH ) # return thread
cases := [] struct { # name string # inputs * ListNode # expect * ListNode # }{ # {" STR ", # & ListNode { Val : 1 , Next : & ListNode { Val : 2 , Next : & ListNode { Val : 3 , Next : & ListNode { Val : 4 , Next : nil }}}}, # & ListNode { Val : 2 , Next : & ListNode { Val : 1 , Next : & ListNode { Val : 4 , Next : & ListNode { Val : 3 , Next : nil }}}}, # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := swapPairs 1 ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
t = t . Add (- 1 * time . Duration ( t . Hour ()) * time . Hour ) # t = t . Add (- 1 * time . Duration ( t . Minute ()) * time . Minute ) # t = t . Add (- 1 * time . Duration ( t . Second ()) * time . Second ) # return t
random := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # array 1 := make ([] int , random . Intn ( 1 0 0 - 1 0 )+ 1 0 ) # for i := range array 1 { # array 1 [ i ] = random . Intn ( 1 0 0 ) # } # array 2 := make ( sort . IntSlice , len ( array 1 )) # copy ( array 2 , array 1 ) # BubbleSort ( array 1 ) # array 2 . Sort () # for i := range array 1 { # if array 1 [ i ] != array 2 [ i ] { # t . Fail () # } # }
sum , product := 0 , 1 # for ; n > 0 ; n /= 1 0 { # sum += n % 1 0 # product *= n % 1 0 # } # return product - sum
var reversed * SinglyLL # for head != nil { # next := head . Next # head . Next = reversed # reversed = head # head = next # } # return reversed
var tests = [] struct { # citations [] int # h int # }{ # { nil , 0 }, # {[] int { 1 }, 1 }, # {[] int { 0 }, 0 }, # {[] int { 1 , 1 }, 1 }, # {[] int { 1 1 , 1 5 }, 2 }, # {[] int { 0 , 1 , 3 , 5 , 6 }, 3 }, # } # # for _ , tt := range tests { # h := hIndex ( tt . citations ) # if h != tt . h { # t . Errorf (" STR ", tt . citations , h , tt . h ) # } # }
if head == nil { # return nil # } # if head . Next == nil { # return & TreeNode { Val : head . Val } # } # var prev * ListNode # slow := head # fast := head # # for fast . Next != nil && fast . Next . Next != nil { # prev = slow # slow = slow . Next # fast = fast . Next . Next # } # # p := slow # if prev != nil { # prev . Next = nil # } else { # head = nil # } # # return & TreeNode { # Val : p . Val , # Left : sortedListToBST ( head ), # Right : sortedListToBST ( p . Next ), # }
res := [] string {} # # l := len ( a ) # if l == 0 { # return res # } # # begin := a [ 0 ] # str := " STR " # # for i := 0 ; i < l ; i ++ { # if i == l - 1 || a [ i ]+ 1 != a [ i + 1 ] { # if a [ i ] == begin { # str = fmt . Sprintf (" STR ", begin ) # } else { # str = fmt . Sprintf (" STR ", begin , a [ i ]) # } # # if i + 1 < l { # begin = a [ i + 1 ] # } # # res = append ( res , str ) # } # } # # return res
t = make ([] int , len ( word )) # pos , cnd := 2 , 0 # t [ 0 ], t [ 1 ] = - 1 , 0 # for pos < len ( word ) { # if word [ pos - 1 ] == word [ cnd ] { # cnd ++ # t [ pos ] = cnd # pos ++ # } else if cnd > 0 { # cnd = t [ cnd ] # } else { # t [ pos ] = 0 # pos ++ # } # } # return t
return l . insert ( e , l . root . prev )
if len ( nums ) == 0 { # return 0 # } # if len ( nums ) == 1 { # return nums [ 0 ] # } # ret , preMax , preMin := nums [ 0 ], nums [ 0 ], nums [ 0 ] # var temp int # for i := 1 ; i < len ( nums ); i ++ { # temp = preMax # preMax = max ( max ( nums [ i ], nums [ i ]* preMax ), nums [ i ]* preMin ) # preMin = min ( min ( nums [ i ], nums [ i ]* preMin ), nums [ i ]* temp ) # ret = max ( ret , preMax ) # } # return ret
upperBound := float 6 4 ( n ) # lowerBound := float 6 4 ( 0 ) # # var square float 6 4 # var i int # var x float 6 4 # # for math . Abs ( square - n ) > precision && float 6 4 ( i ) < maxIterations { # i ++ # x = ( upperBound - lowerBound )/ 2 + lowerBound # square = x * x # # if square < n { # lowerBound = x # } else { # upperBound = x # } # } # # floorX := math . Floor ( x ) # # if floorX * floorX == n { # x = floorX # } else if ( floorX + 1 )*( floorX + 1 ) == n { # x = floorX + 1 # } # # return x
sum := 0 # for i := 0 ; i < 1 0 0 0 ; i ++ { # if i % 3 == 0 || i % 5 == 0 { sum += i } # } # fmt . Printf (" STR ", sum )
return MaxQueue { # queue : list . New (), # deque : list . New (), # }
if len ( matrix ) == 0 { # return false # } # row , col := 0 , len ( matrix [ 0 ])- 1 # for col >= 0 && row <= len ( matrix )- 1 { # if target == matrix [ row ][ col ] { # return true # } else if target > matrix [ row ][ col ] { # row ++ # } else { # col -- # } # } # return false
_ , isPresent := m [ n ] # return isPresent
if len ( s ) == 0 { # return - 1 # } # # dict := make ( map [ rune ] int , 0 ) # for _ , v := range s { # dict [ v ]++ # } # # ans := - 1 # for id , v := range s { # if 1 == dict [ v ] { # return id # } # } # return ans
var stack [] int # n := len ( arr ) # result := make ([] int , n ) # for i := 2 * n - 1 ; i >= 0 ; i -- { # for len ( stack ) > 0 && stack [ len ( stack )- 1 ] <= arr [ i % n ] { # stack = stack [: len ( stack )- 1 ] # } # if len ( stack ) == 0 { # result [ i % n ] = - 1 # } else { # result [ i % n ] = stack [ len ( stack )- 1 ] # } # stack = append ( stack , arr [ i % n ]) # } # return result
qs := [] question 7 4 8 { # # { # para 7 4 8 {" STR ", [] string {" STR ", " STR ", " STR ", " STR "}}, # ans 7 4 8 {" STR "}, # }, # # { # para 7 4 8 {" STR ", [] string {" STR ", " STR ", " STR ", " STR "}}, # ans 7 4 8 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 4 8 , q . para 7 4 8 # fmt . Printf (" STR ", p , shortestCompletingWord ( p . c , p . w )) # } # fmt . Printf (" STR ")
if len ( s ) == 0 { # return 0 # } # # var dp [ 2 ] int # dp [ 0 ] = 1 # if isOneDigitCode ( s [ 0 ]) { # dp [ 1 ] = 1 # } else { # dp [ 1 ] = 0 # } # # bytes := [] byte ( s ) # for i := 1 ; i < len ( s ); i ++ { # count := 0 # if isOneDigitCode ( bytes [ i ]) { # count += dp [ i % 2 ] # } # # if isTwoDigitCode ( bytes [ i - 1 : i + 1 ]) { # count += dp [( i - 1 )% 2 ] # } # # dp [( i + 1 )% 2 ] = count # } # # return dp [ len ( s )% 2 ]
if req . Method == " STR " { # src , hdr , err := req . FormFile (" STR ") # if err != nil { # # http . Error ( res , err . Error (), 5 0 0 ) # return # } # defer src . Close () # # dst , err := os . Create (" STR " + hdr . Filename ) # if err != nil { # # http . Error ( res , err . Error (), 5 0 0 ) # return # } # defer dst . Close () # # io . Copy ( dst , src ) # } #
for i := range nums { # for j := nums [ i ] - 1 ; j >= 0 && j < len ( nums ); j = nums [ i ] - 1 { # if i == j || nums [ i ] == nums [ j ] { # break # } # nums [ i ], nums [ j ] = nums [ j ], nums [ i ] # } # } # # var i int # for i < len ( nums ) && nums [ i ] == i + 1 { # i ++ # } # return i + 1
n := len ( wall ) # if n == 0 { # return 0 # } # m := map [ int ] int {} # count := 0 # for _ , row := range wall { # l := 0 # for i := 0 ; i < len ( row )- 1 ; i ++ { # l += row [ i ] # m [ l ]++ # count = max ( count , m [ l ]) # } # } # return n - count
return e . Name + " STR "
fmt . Println ( subsetsWithDup ([] int { 1 , 2 , 2 }))
if canReshape ( nums , r , c ) { # return reshape ( nums , r , c ) # } # return nums
i := 1 # for i < len ( A ) && math . Abs ( float 6 4 ( A [ i ])) <= math . Abs ( float 6 4 ( A [ i - 1 ])) { # i ++ # } # # j := i - 1 # result := make ([] int , 0 ) # for j >= 0 && i < len ( A ) { # s 1 , s 2 := A [ j ]* A [ j ], A [ i ]* A [ i ] # if s 1 <= s 2 { # result = append ( result , s 1 ) # j -- # } else { # result = append ( result , s 2 ) # i ++ # } # } # # for j >= 0 { # result = append ( result , A [ j ]* A [ j ]) # j -- # } # # for i < len ( A ) { # result = append ( result , A [ i ]* A [ i ]) # i ++ # } # # return result
m . key = key # m . value = list . New () # m . addValue ( value ) # return m
for _ , row := range A { # for i , j := 0 , len ( row )- 1 ; i <= j ; i , j = i + 1 , j - 1 { # row [ i ], row [ j ] = row [ j ]^ 1 , row [ i ]^ 1 # } # } # return A
start := root # for i , w := range word { # if node := start . Children [ w -" STR "]; node != nil { # start = node # } else { # for _ , nw := range word [ i :] { # start . Children [ nw -" STR "] = & MagicDictionary {} # start = start . Children [ nw -" STR "] # } # break # } # } # start . End = true #
return ListQueue [ len ( ListQueue )- 1 ]
divisors := 1 # for i := 2 ; i * i <= n ; i ++{ # count := 0 # for n % i == 0 { # count ++ # n = n / i # } # divisors *=( count + 1 ) # } # if n > 2 { # divisors *= 2 # } # return divisors
return s . data . Len ()
return FreqStack { # freq : map [ int ] int {}, # }
fmt . Println ( 4 , totalNQueens ( 4 )) # fmt . Println ( 8 , totalNQueens ( 8 ))
i := int ( math . Sqrt ( float 6 4 ( area ))) # for area % i != 0 { # i -- # } # ret := make ([] int , 2 ) # ret [ 0 ] = max ( i , area / i ) # ret [ 1 ] = min ( i , area / i ) # return ret
dp := make ([][] int , m + 1 ) # for i := range dp { # dp [ i ] = make ([] int , n + 1 ) # } # # for _ , s := range strs { # zeros := strings . Count ( s , " STR ") # ones := len ( s ) - zeros # for i := m ; i - zeros >= 0 ; i -- { # for j := n ; j - ones >= 0 ; j -- { # dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i - zeros ][ j - ones ]+ 1 ) # } # } # } # # return dp [ m ][ n ]
tests := [...] testType { # { # in : [] int { 0 , 2 , 1 , - 6 , 6 , - 7 , 9 , 1 , 2 , 0 , 1 }, # want : true , # }, # { # in : [] int { 0 , 2 , 1 , - 6 , 6 , 7 , 9 , - 1 , 2 , 0 , 1 }, # want : false , # }, # { # in : [] int { 3 , 3 , 6 , 5 , - 2 , 2 , 5 , 1 , - 9 , 4 }, # want : true , # }, # { # in : [] int {- 3 , 3 , 3 , - 3 }, # want : false , # }, # { # in : [] int { 1 , 7 , 2 , 6 , 3 , 5 , 8 }, # want : false , # }, # } # for _ , tt := range tests { # got := canThreePartsEqualSum ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
var res [] int # l := len ( nums ) # i := 0 # for i < l { # for 0 < nums [ i ] { # nums [ i ] -= 1 # res = append ( res , nums [ i + 1 ]) # } # i += 2 # } # return res
k := len ( word ); # words , ok := this . trie [ k ]; # if ! ok { # return false ; # } # for _ , cword := range words { # found := true ; # for i := 0 ; i < len ( cword ); i ++ { # if word [ i ] != " STR " && word [ i ] != cword [ i ] { # found = false ; # } # } # if found { # return true ; # } # } # return false ;
if len ( citations ) == 0 { # return 0 # } # l , r := 0 , len ( citations )- 1 # for l < r { # mid := ( l + r ) / 2 # if len ( citations )- mid <= citations [ mid ] { # r = mid # } else { # l = mid + 1 # } # } # if citations [ l ] <= len ( citations ) { # return len ( citations ) - l # } # return 0
result := make ([][] int , n ) # for i := 0 ; i < n ; i ++ { # result [ i ] = make ([] int , n ) # } # # num := 1 # for i := 0 ; 2 * i < n ; i ++ { # if 2 * i == n - 1 { # result [ i ][ i ] = num # } # # for j := i ; j < n - 1 - i ; j ++ { # result [ i ][ j ] = num # num ++ # } # # for j := i ; j < n - 1 - i ; j ++ { # result [ j ][ n - 1 - i ] = num # num ++ # } # # for j := n - 1 - i ; j > i ; j -- { # result [ n - 1 - i ][ j ] = num # num ++ # } # # for j := n - 1 - i ; j > i ; j -- { # result [ j ][ i ] = num # num ++ # } # } # # return result
if nil == nums || len ( nums ) == 0 { # return - 1 # } # if len ( nums ) == 1 { # return 0 # } # # minNumber := nums [ 0 ] # sum := nums [ 0 ] # # for i := 1 ; i < len ( nums ); i ++ { # sum += nums [ i ] # if nums [ i ] < minNumber { # minNumber = nums [ i ] # } # } # # return sum - minNumber * len ( nums )
if fibo ( 1 0 ) != 5 5 { # t . Error (" STR ") # } # # if fibo ( 0 ) != 0 { # t . Error (" STR ") # } # # if fibo ( 3 ) != 2 { # t . Error (" STR ") # } #
StoreUint 8 (& r . Reg , LoadUint 8 (& r . Reg )&^ value )
if st . Len () > superSet . Len () { # return false # } # # for _ , item := range st . GetItems () { # if ! superSet . In ( item ) { # return false # } # } # return true
res = make ([] int , 0 ) # dfs ( root ) # return res
r = rand . New ( rand . NewSource ( 3 1 4 1 5 9 )) # # for _ , tc := range testcases { # head := convertToLL ( tc . input ) # ll := FastShuffle ( head ) # result := convertToSlice ( ll ) # # if ! reflect . DeepEqual ( result , tc . expectedFastShuffle ) { # t . Errorf (" STR ", tc . expectedFastShuffle , result ) # } # }
pid := q . IDs [ p ] # rid := q . IDs [ r ] # for x := range q . IDs { # if q . IDs [ x ] == pid { # q . IDs [ x ] = rid # } # }
n := rng . Intn ( 2 5 ) # runes := make ([] rune , n ) # for i := 0 ; i < ( n + 1 )/ 2 ; i ++ { # r := rune ( rng . Intn ( 0 x 1 0 0 0 )) # runes [ i ] = r # runes [ n - 1 - i ] = r # } # return string ( runes )
res := true # for _ , num := range arr { # if t [ num ] == false { # res = false # break # } # } # return res
qs := [] question 1 1 8 5 { # # { # para 1 1 8 5 { 3 1 , 8 , 2 0 1 9 }, # ans 1 1 8 5 {" STR "}, # }, # # { # para 1 1 8 5 { 1 8 , 7 , 1 9 9 9 }, # ans 1 1 8 5 {" STR "}, # }, # # { # para 1 1 8 5 { 1 5 , 8 , 1 9 9 3 }, # ans 1 1 8 5 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 1 8 5 , q . para 1 1 8 5 # fmt . Printf (" STR ", p , dayOfTheWeek ( p . day , p . month , p . year )) # } # fmt . Printf (" STR ")
words := " STR " # alignedIdx , alignedWords := prettyPrint ( words , 1 5 0 ) # if alignedIdx != 4 8 4 4 2 { # t . Log ( fmt . Sprintf (" STR ", alignedIdx )) # t . Fail () # } # if alignedWords != " STR "+ # " STR "+ # " STR "+ # " STR "+ # " STR "+ # " STR "+ # " STR "+ # " STR "+ # " STR "+ # " STR "+ # " STR " { # t . Log (" STR ") # t . Log ( alignedWords ) # t . Fail () # }
qs := [] question 3 8 9 { # # { # para 3 8 9 {" STR ", " STR "}, # ans 3 8 9 {' e '}, # }, # # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 8 9 , q . para 3 8 9 # fmt . Printf (" STR ", p , findTheDifference ( p . s , p . t )) # } # fmt . Printf (" STR ")
tests := [...] testType { # { # in : " STR ", # want : [] int { 0 , 4 , 1 , 3 , 2 }, # }, # { # in : " STR ", # want : [] int { 0 , 1 , 2 , 3 }, # }, # { # in : " STR ", # want : [] int { 3 , 2 , 0 , 1 }, # }, # } # for _ , tt := range tests { # got := diStringMatch ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
count := [ 2 6 ] int {} # # length := 0 # # for i := 0 ; i < len ( p ); i ++ { # if 0 < i && # ( p [ i - 1 ]+ 1 == p [ i ] || p [ i - 1 ] == p [ i ]+ 2 5 ) { # length ++ # } else { # length = 1 # } # # b := p [ i ] - ' a ' # count [ b ] = max ( count [ b ], length ) # } # # res := 0 # for i := 0 ; i < 2 6 ; i ++ { # res += count [ i ] # } # # return res
if ele , ok := c . cache [ key ]; ok { # c . ll . MoveToFront ( ele ) # kv := ele . Value .(* entry ) # return kv . value , true # } # return
if root == nil { # return [] int {} # } # rets := [] int {} # queue := []* TreeNode { root } # last := root # for len ( queue ) != 0 { # top := queue [ 0 ] # queue = queue [ 1 :] # if top . Left != nil { # queue = append ( queue , top . Left ) # } # if top . Right != nil { # queue = append ( queue , top . Right ) # } # if top == last { # rets = append ( rets , top . Val ) # if len ( queue ) != 0 { # last = queue [ len ( queue )- 1 ] # } # } # } # return rets
strList := [] string {" STR ", " STR "} # fmt . Println ( uniqueMorseRepresentations ( strList ))
steve := Developer { # Employee : Employee { # FirstName : " STR ", # LastName : " STR ", # Dob : time . Date ( 1 9 9 0 , time . February , 1 7 , 0 , 0 , 0 , 0 , time . UTC ), # JobTitle : " STR ", # Location : " STR ", # }, # Skills : [] string {" STR ", " STR ", " STR "}, # } # steve . PrintName () # steve . PrintDetails ()
var sum int # # var f func (* TreeNode , int ) # f = func ( root * TreeNode , num int ) { # if root == nil { # return # } # # num = num * 1 0 + root . Val # if root . Left == nil && root . Right == nil { # sum += num # return # } # # f ( root . Left , num ) # f ( root . Right , num ) # } # # f ( root , 0 ) # return sum
fmt . Println ( findDuplicate ([] int { 1 , 3 , 4 , 2 , 2 })) # fmt . Println ( findDuplicate ([] int { 3 , 1 , 3 , 4 , 2 }))
bind_i := elf . ST_BIND ( l [ i ]. Info ) # bind_j := elf . ST_BIND ( l [ j ]. Info ) # if l [ i ]. Value == l [ j ]. Value && bind_i != elf . STB_WEAK && bind_j == elf . STB_WEAK { # return true # } # return l [ i ]. Value < l [ j ]. Value
if s == " STR " { # return 0 # } # num , lastint , total := 0 , 0 , 0 # for i := 0 ; i < len ( s ); i ++ { # char := s [ len ( s )-( i + 1 ) : len ( s )- i ] # num = roman [ char ] # if num < lastint { # total = total - num # } else { # total = total + num # } # lastint = num # } # return total
cases := [] struct { # name string # inputs int # expect string # }{ # {" STR ", 1 , " STR "}, # {" STR ", 4 , " STR "}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := countAndSay ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
obj := Constructor 2 0 8 () # fmt . Printf (" STR ", obj ) # obj . Insert (" STR ") # fmt . Printf (" STR ", obj ) # param 1 := obj . Search (" STR ") # fmt . Printf (" STR ", param 1 , obj ) # param 2 := obj . Search (" STR ") # fmt . Printf (" STR ", param 2 , obj ) # param 3 := obj . StartsWith (" STR ") # fmt . Printf (" STR ", param 3 , obj ) # obj . Insert (" STR ") # fmt . Printf (" STR ", obj ) # param 4 := obj . Search (" STR ") # fmt . Printf (" STR ", param 4 , obj )
t . Parallel () # for _ , tc := range testcases { # if result := LengthLongestDistinct ( tc . nums ); result != tc . length { # t . Errorf (" STR ", tc . length , result ) # } # }
res = [][] int {} # dfs ( root , sum , [] int {}) # return res
propSums := make ([] int , max ) # amicable := [] int {} # for i := 0 ; i < max ; i ++ { # propSums [ i ] = calcPropSum ( i ) # } # for p := range propSums { # for n := range propSums { # if p == propSums [ n ] && n == propSums [ p ] && p != n { # if ! inSlice ( p , amicable ) { # amicable = append ( amicable , p ) # } # if ! inSlice ( n , amicable ) { # amicable = append ( amicable , n ) # } # break # } # } # } # sum := 0 # for a := range amicable { # sum += amicable [ a ] # } # fmt . Println (" STR ", sum )
if n < 1 { # return 0 # } # sevens := 1 # index := 1 # nums := [] int { 1 } # for index < n { # sevens *= 7 # pos := len ( nums ) # nums = append ( nums , sevens ) # index ++ # for i := 0 ; i < pos ; i ++ { # if index >= n { # break # } # nums = append ( nums , nums [ i ]+ sevens ) # index ++ # } # } # return nums [ n - 1 ]
fmt . Println ( findMin ([] int { 3 , 4 , 5 , 1 , 2 }))
node := hm . getNodeByHash ( hm . hash ( key )) # # if node != nil { # return node . value # } # # return nil
tests := [...] testType { # { # in : [] int { 1 , 3 , 5 , 4 , 7 }, # want : 3 , # }, # { # in : [] int { 2 , 2 , 2 , 2 , 2 }, # want : 1 , # }, # { # in : [] int {}, # want : 0 , # }, # { # in : [] int { 1 , 3 , 5 , 7 }, # want : 4 , # }, # } # for _ , tt := range tests { # got := findLengthOfLCIS ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if sum == target { # * result = append (* result , append ([] int {}, combo ...)) # return # } # for i := startIndex ; i < len ( nums ) && ( sum + nums [ i ]) <= target ; i ++ { # if i != startIndex && nums [ i ] == nums [ i - 1 ] { # continue # } # combinationSum 2 Helper ( nums , append ( combo , nums [ i ]), target , sum + nums [ i ], i + 1 , result ) # }
return w . Writer . Write ([] byte ( str ))
maxSum := root . Val # # var f func (* TreeNode ) int # f = func ( root * TreeNode ) int { # if root == nil { # return 0 # } # # sum := root . Val # # l , r := f ( root . Left ), f ( root . Right ) # if l > 0 { # sum += l # } # if r > 0 { # sum += r # } # # if sum > maxSum { # maxSum = sum # } # # var max int # if l > max { # max = l # } # if r > max { # max = r # } # return root . Val + max # } # # f ( root ) # return maxSum
l . header = & nodeLoopItem { # value : " STR ", # next : nil , # } # headerNode := l . header # for i := 0 ; i < n ; i ++ { # node := & nodeLoopItem { # value : i , # next : nil , # } # headerNode . next = node # headerNode = headerNode . next # }
t . Parallel () # counter := make ([] int , 8 ) # for i := 0 ; i < 1 0 0 0 0 0 0 ; i ++ { # counter [ Rand 7 ()]++ # } # uniform := 1 0 0 0 0 0 0 / 7 # tolerance := 1 5 0 0 # for i := 1 ; i <= 7 ; i ++ { # if counter [ i ] < uniform - tolerance || counter [ i ] > uniform + tolerance { # t . Errorf (" STR ", uniform , counter [ i ]) # } # }
if 0 == x { # return 0 # } # # n := x # for n * n > x { # n = ( n + x / n ) / 2 # } # return n
type B struct { # Foo map [ string ][] int # } # # type A struct { # B * B # } # # b := & B { # Foo : map [ string ][] int { # " STR ": { 8 0 }, # }, # } # # a := & A { B : b } # # m := Map ( a ) # # if typ := reflect . TypeOf ( m ). Kind (); typ != reflect . Map { # t . Errorf (" STR ", typ ) # } # # in , ok := m [" STR "].( map [ string ] interface {}) # if ! ok { # t . Errorf (" STR ", m [" STR "]) # } # # foo := in [" STR "].( map [ string ][] int ) # if name := foo [" STR "]; name [ 0 ] != 8 0 { # t . Errorf (" STR ", name ) # }
t . Parallel () # for _ , tc := range testcases { # if dup := FindDuplicate ( tc . nums ); dup != tc . dup { # t . Errorf (" STR ", tc . dup , dup ) # } # }
result := make ( Matrix , len ( m )) # for i := range result { # result [ i ] = make ([] int , len ( m )) # } # # for i := range m { # for j := range m [ i ] { # result [ j ][ len ( m )- 1 - i ] = m [ i ][ j ] # } # } # # return result
encryptedText := "" # for _ , char := range strings . ToUpper ( text ) { # encryptedChar , err := p . encipher ( char ) # if err != nil { # return " STR ", err # } # encryptedText += encryptedChar # } # return encryptedText , nil
om . store [ k ] = v # om . order = append ( om . order , k )
if len ( nums ) < 2 { # return false # } # elemList := make ([]* elem , len ( nums )) # for i , num := range nums { # elemList [ i ] = & elem { num , i } # } # sort . SliceStable ( elemList , func ( i , j int ) bool { # if elemList [ i ]. val != elemList [ j ]. val { # return elemList [ i ]. val < elemList [ j ]. val # } # return elemList [ i ]. idx < elemList [ j ]. idx # }) # i , j := 0 , 1 # for j < len ( elemList ) { # if elemList [ j ]. val - elemList [ i ]. val <= t { # if abs ( elemList [ j ]. idx - elemList [ i ]. idx ) <= k { # return true # } # j ++ # } else { # i ++ # if j <= i { # j ++ # } # } # } # return false
arr = make ([] int , 2 5 0 0 ) # for i := range arr { # arr [ i ] = ( i * ( 3 * i - 1 )) / 2 # } # min := int (^ uint ( 0 ) >> 1 ) # for i := 1 ; i < len ( arr ); i ++ { # for j := i + 1 ; j < len ( arr ); j ++ { # if isPentagonal ( arr [ j ]- arr [ i ]) && isPentagonal ( arr [ j ]+ arr [ i ]) && arr [ j ]- arr [ i ] < min { # min = arr [ j ] - arr [ i ] # } # } # } # println ( min )
dp := make ([][] int , n ) # for i := 0 ; i < n ; i ++ { # dp [ i ] = make ([] int , m ) # } # for i := 0 ; i < m ; i ++ { # dp [ 0 ][ i ] = 1 # } # for i := 0 ; i < n ; i ++ { # dp [ i ][ 0 ] = 1 # } # for i := 1 ; i < n ; i ++ { # for j := 1 ; j < m ; j ++ { # dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ] # } # } # return dp [ n - 1 ][ m - 1 ]
if s == nil { # return false # } # return equalTrees ( t , s ) || SameTreeSubstructure ( t , s . Left ) || SameTreeSubstructure ( t , s . Right )
t . Parallel () # for _ , tc := range testcases { # if result := TwoClosestPointsBrute ( tc . pts ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
rand . Seed ( time . Now (). UTC (). UnixNano ()) # # if len ( os . Args ) > 1 && os . Args [ 1 ] == " STR " { # handler := func ( w http . ResponseWriter , r * http . Request ) { # lissajous ( w ) # } # http . HandleFunc (" STR ", handler ) # log . Fatal ( http . ListenAndServe (" STR ", nil )) # return # } # lissajous ( os . Stdout )
for i := 0 ; i < len ( config )- 1 ; i ++ { # a , b := float 6 4 ( config [ i ]), float 6 4 ( config [ i + 1 ]) # sum += 1 0 * math . Sqrt ( 2 ) * math . Sqrt ( a + b - 5 0 ) # } # # sum += float 6 4 ( config [ 0 ]) # sum += float 6 4 ( config [ len ( config )- 1 ]) # # return
queue , left , right := []* TreeNode { root . Left , root . Right }, & TreeNode {}, & TreeNode {} # # for len ( queue ) > 0 { # left , right , queue = queue [ 0 ], queue [ 1 ], []* TreeNode {} # # if left == nil && right == nil { # continue # } # if left == nil || right == nil { # return false # } # if left . Val != right . Val { # return false # } # # queue = append ( queue , left . Left , right . Right , left . Right , right . Left ) # } # return true
var p Person # p . FirstName = " STR " # p . LastName = " STR " # p . Dob = time . Date ( 1 9 5 7 , time . February , 1 7 , 0 , 0 , 0 , 0 , time . UTC ) # p . Email = " STR " # p . Location = " STR " # # p 1 := Person { # FirstName : " STR ", # LastName : " STR ", # Dob : time . Date ( 1 9 7 9 , time . February , 1 7 , 0 , 0 , 0 , 0 , time . UTC ), # Email : " STR ", # Location : " STR ", # } # p . PrintName () # p . PrintDetails () # p 1 . PrintName () # p 1 . PrintDetails () #
if nil == head { # return # } # # tail := & CircularListNode { head , nil } # for node := head . Next ; nil != node ; node = node . Next { # currNode := & CircularListNode { node , tail } # tail = currNode # } # # for p , q := head , tail ; ; { # if p == q . ListNode { # p . Next = nil # break # } # if p . Next == q . ListNode { # p . Next . Next = nil # break # } # x , y := p , q # p , q = p . Next , q . Pre # x . Next = y . ListNode # y . Next = p # }
nums , ops := parseString ( input ) # exps := createExpNodes ( nums , ops ) # return calcExpNodes ( exps )
size := len ( S ) # # count := make ([] int , size + 1 ) # for i := 0 ; i < size ; i ++ { # count [ i + 1 ] = count [ i ] # if S [ i ] == ' 1 ' { # count [ i + 1 ]++ # } # } # # res := size # for i := 0 ; i <= size ; i ++ { # tmp := count [ i ] + (( size - i ) - ( count [ size ] - count [ i ])) # res = min ( res , tmp ) # } # # return res
var ss string # var ts string # var ret bool # # ss = " STR " # ts = " STR " # ret = false # # if ret != isAnagram ( ss , ts ) { # t . Fatalf (" STR ", ret ) # } # # ss = " STR " # ts = " STR " # ret = true # # if ret != isAnagram ( ss , ts ) { # t . Fatalf (" STR ", ret ) # } # # ss = " STR " # ts = " STR " # ret = false # # if ret != isAnagram ( ss , ts ) { # t . Fatalf (" STR ", ret ) # }
if n >= 1 0 { # return res [ 1 0 ] # } # return res [ n ]
t . Parallel () # for _ , tc := range testcases { # if result := ProbKnightOnBoard ( tc . row , tc . col , tc . k ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
if factorial ( 2 ) != 2 { # t . Error (" STR ") # } # # if factorial ( 3 ) != 6 { # t . Error (" STR ") # } # # if factorial ( 0 ) != 1 { # t . Error (" STR ") # } # # if factorial ( 5 ) != 1 2 0 { # t . Error (" STR ") # }
var tests = [] struct { # matrix [][] int # target int # found bool # }{ # { # [][] int { # { 1 , 3 , 5 , 7 }, # { 1 0 , 1 1 , 1 6 , 2 0 }, # { 2 3 , 3 0 , 3 4 , 5 0 }, # }, 3 , true , # }, # { # [][] int { # { 1 , 3 , 5 , 7 }, # { 1 0 , 1 1 , 1 6 , 2 0 }, # { 2 3 , 3 0 , 3 4 , 5 0 }, # }, 1 3 , false , # }, # { # [][] int { # { 1 , 3 , 5 , 7 }, # { 1 0 , 1 1 , 1 6 , 2 0 }, # { 2 3 , 3 0 , 3 4 , 5 0 }, # }, 2 3 , true , # }, # { nil , 0 , false }, # } # # for _ , tt := range tests { # found := searchMatrix ( tt . matrix , tt . target ) # if found != tt . found { # t . Errorf (" STR ", tt . matrix , tt . target , found , tt . found ) # } # }
var tests = [] struct { # n , k int # combinations [][] int # }{ # { 4 , 2 , [][] int {{ 1 , 2 }, { 1 , 3 }, { 1 , 4 }, { 2 , 3 }, { 2 , 4 }, { 3 , 4 }}}, # } # # for _ , tt := range tests { # combinations := combine ( tt . n , tt . k ) # if reflect . DeepEqual ( combinations , tt . combinations ) == false { # t . Errorf (" STR ", tt . n , tt . k , combinations , tt . combinations ) # } # }
ans , a , b := " STR ", " STR ", " STR " # if B < A { # A , B = B , A # a , b = b , a # } # Dif := B - A # if A == 1 && B == 1 { # ans = b + a # } else if A == 1 && B < 5 { # for i := 0 ; i < B - 2 ; i ++ { # ans = ans + b # } # ans = b + b + a + ans # } else if ( B - A )/ A >= 1 { # for i := 0 ; i < A ; i ++ { # ans = ans + b + b + a # B = B - 2 # } # for i := 0 ; i < B ; i ++ { # ans = ans + b # } # } else { # for i := 0 ; i < Dif ; i ++ { # ans = ans + b + b + a # B -= 2 # A -- # } # for i := 0 ; i < B ; i ++ { # ans = ans + b + a # } # } # return ans
visited := make ( map [ string ] struct {}) # return cheapestItinerary ( flights , origin , destination , maxConnections , visited )
res := make ([] int , 0 ) # view ( root , & res , 0 ) # return res
negative := dividend ^ divisor < 0 # if dividend < 0 { # dividend = - dividend # } # if divisor < 0 { # divisor = - divisor # } # var multiple int 3 2 # var aMultiple = divisor # for divisor <= dividend { # d := aMultiple # m := int 3 2 ( 1 ) # for divisor + d << 1 < dividend { # d <<= 1 # m <<= 1 # } # multiple += m # # divisor += d # } # if multiple < 0 { # if negative { # return math . MinInt 3 2 # } else { # return math . MaxInt 3 2 # } # } # if negative { # multiple = - multiple # } # if multiple > math . MaxInt 3 2 { # return math . MaxInt 3 2 # } # if multiple < math . MinInt 3 2 { # return math . MinInt 3 2 # } # return int ( multiple )
freq , m := map [ int ] int {}, map [ int ] bool {} # for _ , v := range arr { # freq [ v ]++ # } # for _ , v := range freq { # if _ , ok := m [ v ]; ! ok { # m [ v ] = true # } else { # return false # } # } # return true
return new ( bstIterative )
fmt . Println ( jump ([] int { 2 , 3 , 1 , 1 , 4 }, true )) # fmt . Println ( jump ([] int { 3 , 2 , 1 , 0 , 4 }, true )) # fmt . Println ( jump ([] int { 1 , 2 , 3 }, true )) # fmt . Println ( jump ([] int { 0 , 1 }, true )) # fmt . Println ( jump ([] int { 0 , 2 , 3 }, true )) # fmt . Println ( jump ([] int { 2 , 0 , 0 }, true )) # fmt . Println ( jump ([] int { 2 , 0 , 1 , 0 , 1 }, true ))
return bindataRead ( # _dataRatesJson , # " STR ", # )
return this . m [[ 2 ] int { i , j }]
if grid [ row + 1 ][ col + 1 ] != 5 { # return false # } # data := make ([] int , 1 6 ) # for i := row ; i <= row + 2 ; i ++ { # for j := col ; j <= col + 2 ; j ++ { # data [ grid [ i ][ j ]]++ # } # } # for i := 1 ; i <= 9 ; i ++ { # if data [ i ] != 1 { # return false # } # } # for i := 0 ; i <= 2 ; i ++ { # if grid [ row + i ][ col ]+ grid [ row + i ][ col + 1 ]+ grid [ row + i ][ col + 2 ] != grid [ row ][ col + i ]+ grid [ row + 1 ][ col + i ]+ grid [ row + 2 ][ col + i ] { # return false # } # } # return grid [ row ][ col ]+ grid [ row + 1 ][ col + 1 ]+ grid [ row + 2 ][ col + 2 ] == grid [ row ][ col + 2 ]+ grid [ row + 1 ][ col + 1 ]+ grid [ row + 2 ][ col ]
return i * i * i * i * i
fmt . Println ( canPlaceFlowers ([] int { 0 }, 1 ))
n := len ( candies ) # m := make ( map [ int ] struct {}, n ) # for _ , candy := range candies { # m [ candy ] = struct {}{} # } # return min ( len ( m ), n / 2 )
if len ( s ) != len ( t ) { # return false # } # sMap 1 := make ( map [ uint 8 ] int ) # sMap 2 := make ( map [ uint 8 ] int ) # # for i := 0 ; i < len ( s ); i ++ { # sMap 1 [ s [ i ]] += 1 # sMap 2 [ t [ i ]] += 1 # } # if ! reflect . DeepEqual ( sMap 1 , sMap 2 ) { # return false # } # return true
t := new ( rbt ) # t . Init () # t . gbt . Object = t # return t
ans , l 1 , l 2 , carry := " STR ", len ( a )- 1 , len ( b )- 1 , byte (' 0 ') # for l 1 >= 0 || l 2 >= 0 || carry != ' 0 ' { # v := carry # if l 1 >= 0 { # v += a [ l 1 ] - ' 0 ' # l 1 -- # } # if l 2 >= 0 { # v += b [ l 2 ] - ' 0 ' # l 2 -- # } # carry = ' 0 ' + ( v -' 0 ')/ 2 # v = ' 0 ' + ( v -' 0 ')% 2 # ans = string ( v ) + ans # } # return ans
tmp := make ( map [ int ][] string , len ( ss )/ 2 ) # for _ , s := range ss { # c := encode ( s ) # tmp [ c ] = append ( tmp [ c ], s ) # } # # res := make ([][] string , 0 , len ( tmp )) # for _ , v := range tmp { # res = append ( res , v ) # } # # return res
src , err := os . Open (" STR ") # if err != nil { # panic ( err ) # } # defer src . Close () # # dst 1 , err := os . Create (" STR ") # if err != nil { # panic ( err ) # } # defer dst 1 . Close () # # if false { # bs := make ([] byte , 5 ) # io . ReadFull ( src , bs ) # dst 1 . Write ( bs ) # } # # rdr := io . LimitReader ( src , 1 0 0 ) # io . Copy ( dst 1 , rdr ) #
for i := 2 ; i * i <= n ; i ++ { # if n % i == 0 { # return append ( factor ( n / i ), i ) # } # } # return [] int { n }
type A struct { # Name string # } # a := & A { Name : " STR "} # # type B struct { # * A # } # b := & B {} # b . A = a # # m := Map ( b ) # # if typ := reflect . TypeOf ( m ). Kind (); typ != reflect . Map { # t . Errorf (" STR ", typ ) # } # # in , ok := m [" STR "].( map [ string ] interface {}) # if ! ok { # t . Error (" STR ") # } # # if name := in [" STR "].( string ); name != " STR " { # t . Errorf (" STR ", name ) # }
cases := [] struct { # name string # inputs [] string # expect string # }{ # {" STR ", [] string {" STR ", " STR "}, " STR "}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # }) # }
type Access struct { # Name string # LastAccessed time . Time # Number int # } # # s := & Access { # Name : " STR ", # LastAccessed : time . Now (), # Number : 1 2 3 4 5 6 7 , # } # # fields := Fields ( s ) # # for i , field := range fields { # fmt . Printf (" STR ", i , field . Name ()) # } #
var count int # min := - 1 << 3 1 - 1 # vals := [] int { min , min , min } # for _ , num := range nums { # if num == vals [ 0 ] || num == vals [ 1 ] { # continue # } # if num > vals [ 0 ] { # vals [ 2 ] = vals [ 1 ] # vals [ 1 ] = vals [ 0 ] # vals [ 0 ] = num # count ++ # } else if num > vals [ 1 ] { # vals [ 2 ] = vals [ 1 ] # vals [ 1 ] = num # count ++ # } else if num >= vals [ 2 ] { # vals [ 2 ] = num # count ++ # } # } # if count < 3 { # return vals [ 0 ] # } # return vals [ 2 ]
fmt . Println ( isPalindrome (" STR "))
if player != Red && player != Black { # return fmt . Errorf (" STR ", player ) # } # if cfb . board == nil { # cfb . board = make ( map [ Column ] map [ Row ] Player ) # } # valid := false # for row := Row ( 0 ); row < 6 ; row ++ { # if cfb . board [ col ] == nil { # cfb . board [ col ] = make ( map [ Row ] Player ) # } # if _ , found := cfb . board [ col ][ row ]; ! found { # cfb . board [ col ][ row ] = player # valid = true # break # } # } # if ! valid { # return fmt . Errorf (" STR ") # } # return nil
result := make ([] int , len ( nums )) # for i , v := range nums { # count := 0 # for j := i + 1 ; j < len ( nums ); j ++ { # if v > nums [ j ] { # count ++ # } # } # result [ i ] = count # } # return result
hash , max := make ( map [ int ] deg ), - 1 # for i := 0 ; i < len ( nums ); i ++ { # num := nums [ i ] # if _ , ok := hash [ num ]; ok { # val := hash [ num ] # val . count ++ # if val . count > max { # max = val . count # } # val . j = i # hash [ num ] = val # } else { # val := deg { i , i , 1 } # if val . count > max { # max = val . count # } # hash [ num ] = val # } # } # min := 5 0 0 0 0 # for _ , val := range hash { # v := val . j - val . i + 1 # if val . count == max && v > 0 && v < min { # min = v # } # } # return min
var sumA , sumB int # for _ , a := range A { # sumA += a # } # setB := make ( map [ int ] struct {}) # for _ , b := range B { # sumB += b # setB [ 2 * b ] = struct {}{} # } # # for _ , a := range A { # b 2 := sumB - sumA + 2 * a # if _ , ok := setB [ b 2 ]; ok { # return [] int { a , b 2 / 2 } # } # } # return nil
t . Parallel () # for _ , tc := range testcases { # if result := ThreeSum ( tc . nums , tc . k ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
var sum , carry int # for { # sum = num 1 ^ num 2 # carry = ( num 1 & num 2 ) << 1 # num 1 = sum # num 2 = carry # # if 0 == num 2 { # break # } # } # return num 1
b := filledMultiLRU ( time . Time {}) # # cpu := runtime . GOMAXPROCS ( 0 ) # ch := make ( chan bool ) # worker := func () { # for i := 0 ; i < bb . N / cpu ; i ++ { # b . Set ( randomString ( 2 ), " STR ", time . Time {}) # } # ch <- true # } # for i := 0 ; i < cpu ; i ++ { # go worker () # } # for i := 0 ; i < cpu ; i ++ { # _ = <- ch # }
up := strings . Count ( moves , " STR ") # down := strings . Count ( moves , " STR ") # left := strings . Count ( moves , " STR ") # right := strings . Count ( moves , " STR ") # # return up == down && left == right
return i - 2 , j - 2
nexts := make ( map [ string ][] string , len ( tickets )+ 1 ) # for _ , t := range tickets { # nexts [ t [ 0 ]] = append ( nexts [ t [ 0 ]], t [ 1 ]) # } # # for k := range nexts { # sort . Strings ( nexts [ k ]) # } # # route := make ([] string , 0 , len ( tickets )+ 1 ) # # var visit func ( string ) # var next string # visit = func ( airport string ) { # for len ( nexts [ airport ]) > 0 { # next = nexts [ airport ][ 0 ] # nexts [ airport ] = nexts [ airport ][ 1 :] # visit ( next ) # } # route = append ( route , airport ) # } # # visit (" STR ") # # i , j := 0 , len ( route )- 1 # for i < j { # route [ i ], route [ j ] = route [ j ], route [ i ] # i ++ # j -- # } # # return route
out := 7 4 8 3 1 7 # if x := p 3 7 (); x != out { # t . Errorf (" STR ", x , out ) # }
for i , v := range nums { # if v == val { # return i # } # } # # msg := fmt . Sprintf (" STR ", val , nums ) # panic ( msg )
tmp := make ([] int , n + 1 ) # for i := 2 ; i <= n ; i ++ { # tmp [ i ] = i # } # # curr := 2 # for curr < n { # for i := 2 * curr ; i <= n ; i += curr { # tmp [ i ] = 0 # } # # for curr = curr + 1 ; curr < n && tmp [ curr ] == 0 ; curr ++ { # } # } # # var ret [] int # for _ , n := range tmp { # if n > 0 { # ret = append ( ret , n ) # } # } # # return ret
items := strings . Fields ( sentence ) # for i , item := range items { # if strings . HasPrefix ( item , searchWord ) { # return i + 1 # } # } # return - 1
lp := len ( path ) # stack := make ([] string , 0 , lp / 2 ) # dir := make ([] byte , 0 , lp ) # # for i := 0 ; i < lp ; i ++ { # dir = dir [: 0 ] # for i < lp && path [ i ] != '/' { # dir = append ( dir , path [ i ]) # i ++ # } # # s := string ( dir ) # # switch s { # case " STR ", " STR ": # case " STR ": # if len ( stack ) > 0 { # stack = stack [: len ( stack )- 1 ] # } # default : # stack = append ( stack , s ) # } # } # # return " STR " + strings . Join ( stack , " STR ")
firstRuneAllEven := make ( map [ rune ] bool ) # for _ , word := range dict { # runes := [] rune ( word ) # isEvenLength := len ( runes )% 2 == 0 # firstRune := runes [ 0 ] # if _ , found := firstRuneAllEven [ firstRune ]; ! isEvenLength { # firstRuneAllEven [ firstRune ] = false # } else if ! found && isEvenLength { # firstRuneAllEven [ firstRune ] = true # } # } # var result [] rune # for r , valid := range firstRuneAllEven { # if valid { # result = append ( result , r ) # } # } # sort . Slice ( result , func ( i , j int ) bool { # return result [ i ] < result [ j ] # }) # return result
head := & ListNode { Val : - 1 , Next : nil } # tmp := head # # for i := 0 ; i < len ; i ++ { # tmp . Next = & ListNode { Val : rand . Intn ( max_num ), Next : nil } # tmp = tmp . Next # } # return head . Next
return da . Size == 0
ans := make ([] int , 0 ) # for i := left ; i <= right ; i ++ { # value := i # for ; value > 0 ; value /= 1 0 { # if 0 == value % 1 0 || 0 != ( i %( value % 1 0 )) { # break # } # } # if 0 == value { # ans = append ( ans , i ) # } # } # return ans
arr := [] int { 0 , 1 , 1 , 2 , 3 , 5 , 8 , 1 3 , 2 1 , 3 4 , 5 5 , 8 9 , 1 4 4 , 2 3 3 , 3 7 7 , 6 1 0 } # key := 5 5 # # index := jumpSearch ( arr , key ) # fmt . Println ( index ) #
return Codec {}
plainText := [] byte {} # for _ , ch := range cipherText { # plainText = append ( plainText , key ^ ch ) # } # return plainText
var tests = [] struct { # before [] Interval # after [] Interval # }{ # {[] Interval {{ 1 , 3 }, { 2 , 6 }, { 8 , 1 0 }, { 1 5 , 1 8 }}, [] Interval {{ 1 , 6 }, { 8 , 1 0 }, { 1 5 , 1 8 }}}, # {[] Interval {{ 1 , 4 }, { 4 , 5 }}, [] Interval {{ 1 , 5 }}}, # { nil , nil }, # } # # for _ , tt := range tests { # before := make ([] Interval , len ( tt . before )) # copy ( before , tt . before ) # # after := merge ( tt . before ) # if reflect . DeepEqual ( after , tt . after ) == false { # t . Errorf (" STR ", before , after , tt . after ) # } # }
for _ , n := range ns { # if n > m { # m = n # } # } # # return m
var x IntSet # x . Add ( 1 ) # x . Add ( 1 4 4 ) # x . Add ( 9 ) # x . Add ( 4 2 ) # # fmt . Println (& x ) # fmt . Println ( x . String ()) # fmt . Println ( x ) #
qs := [] question 1 4 7 0 { # # { # para 1 4 7 0 {[] int { 2 , 5 , 1 , 3 , 4 , 7 }, 3 }, # ans 1 4 7 0 {[] int { 2 , 3 , 5 , 4 , 1 , 7 }}, # }, # # { # para 1 4 7 0 {[] int { 1 , 2 , 3 , 4 , 4 , 3 , 2 , 1 }, 4 }, # ans 1 4 7 0 {[] int { 1 , 4 , 2 , 3 , 3 , 2 , 4 , 1 }}, # }, # # { # para 1 4 7 0 {[] int { 1 , 1 , 2 , 2 }, 2 }, # ans 1 4 7 0 {[] int { 1 , 2 , 1 , 2 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 4 7 0 , q . para 1 4 7 0 # fmt . Printf (" STR ", p , shuffle ( p . nums , p . n )) # } # fmt . Printf (" STR ")
sys := System { # Xenia : Xenia {}, # Pillar : Pillar {}, # } # # if err := Copy (& sys , 3 ); err != io . EOF { # fmt . Println ( err ) # }
dp := make ([][] bool , len ( s )+ 1 ) # for i := 0 ; i < len ( s )+ 1 ; i ++ { # dp [ i ] = make ([] bool , len ( p )+ 1 ) # } # dp [ len ( s )][ len ( p )] = true # # for i := len ( s ); i >= 0 ; i -- { # for j := len ( p ) - 1 ; j >= 0 ; j -- { # fm := false # if i < len ( s ) && ( s [ i ] == p [ j ] || p [ j ] == " STR ") { # fm = true # } # # if ( j + 1 ) < len ( p ) && p [ j + 1 ] == " STR " { # dp [ i ][ j ] = dp [ i ][ j + 2 ] || ( fm && dp [ i + 1 ][ j ]) # } else { # dp [ i ][ j ] = fm && dp [ i + 1 ][ j + 1 ] # } # } # } # return dp [ 0 ][ 0 ]
for a := 1 ; a < 1 0 0 0 ; a ++ { # for b := a ; b < 1 0 0 0 ; b ++ { # c := math . Sqrt ( float 6 4 (( a * a )+( b * b ))) # if c == math . Floor ( c ) && int ( c ) > b { # if a + b + int ( c ) == 1 0 0 0 { # fmt . Println ( # " STR ", a , # " STR ", b , # " STR ", c , # ) # fmt . Println ( a * b * int ( c )) # return # } # } # # } # }
return & maxIntStack {}
slice := new ( BitSlice ) # byteLen := length / 8 # if length % 8 > 0 { # byteLen ++ # } # # lockLen := byteLen / 6 4 # if byteLen % 6 4 > 0 { # lockLen ++ # } # # slice . Arr = make ([] byte , byteLen ) # slice . locks = make ([] sync . RWMutex , lockLen ) # slice . len = length # return slice
cases := [] struct { # name string # head * ListNode # G [] int # expect int # }{ # {" STR ", MakeListNode ([] int { 0 , 1 , 2 , 3 }), [] int { 0 , 1 , 3 }, 2 }, # {" STR ", MakeListNode ([] int { 0 , 1 , 2 , 3 , 4 }), [] int { 0 , 3 , 1 , 4 }, 2 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . head , c . G ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . head , c . G ) # } # }) # }
m , n := len ( nums 1 ), len ( nums 2 ) # s := make ([] int , 0 , m + n ) # i , j := 0 , 0 # for i < m && j < n { # v 1 := nums 1 [ i ] # v 2 := nums 2 [ j ] # if v 1 <= v 2 { # s = append ( s , v 1 ) # i ++ # } else { # s = append ( s , v 2 ) # j ++ # } # } # if i < m { # s = append ( s , nums 1 [ i :]...) # } else { # s = append ( s , nums 2 [ j :]...) # } # count := m + n # if count & 1 == 1 { # k := ( count - 1 ) / 2 # return float 6 4 ( s [ k ]) # } # k := count / 2 # return ( float 6 4 ( s [ k - 1 ]) + float 6 4 ( s [ k ])) / 2
fmt . Println ( twoSum 1 ([] int { 2 , 7 , 1 1 , 1 5 }, 9 )) # fmt . Println ( twoSum 2 ([] int { 3 , 2 , 4 }, 6 )) # fmt . Println ( twoSum 3 ([] int { 3 , 3 }, 6 ))
var ret bool # var n int # # n = 3 0 # ret = true # if ret != canWinNim ( n ) { # t . Fatalf (" STR ", ret ) # } # # n = 4 0 # ret = false # if ret != canWinNim ( n ) { # t . Fatalf (" STR ", ret ) # }
testFramework ( t , Mergesort )
if len ( nums ) < 2 { # return false # } # m := make ( map [ int ] bool ) # for _ , v := range nums { # _ , ok := m [ v ] # if ok { # return true # } # m [ v ] = true # } # return false
return new ( task ). init ( r , p , id )
val := 6 0 0 8 5 1 4 7 5 1 4 3 # div , answer := 2 , 0 # max := val / 2 # # if isPrime ( val ){ # answer = val # } else { # for ; div < max ; div , max = div + 1 , val / div { # if val % div == 0 { # if isPrime ( val / div ){ # answer = val / div # return # } else { # if isPrime ( div ){ # answer = div # } # } # } # } # } # # # fmt . Printf (" STR ", answer ) #
doOnce . Do ( func () { # singleton ++ # }) # count ++ # fmt . Println (" STR ", singleton ) # fmt . Println (" STR ", count )
var prev * ListNode # for head != nil { # head . Next , prev , head = prev , head , head . Next # } # return prev
numToPrev , numToNext := make ( map [ int ][] int ), make ( map [ int ][] int ) # for i := 1 ; i <= N ; i ++ { # numToPrev [ i ], numToNext [ i ] = make ([] int , 0 ), make ([] int , 0 ) # } # # for _ , dislike := range dislikes { # prev , next := dislike [ 0 ], dislike [ 1 ] # numToPrev [ next ] = append ( numToPrev [ next ], prev ) # numToNext [ prev ] = append ( numToNext [ prev ], next ) # } # # visited := make ( map [ int ] int ) # for i := 1 ; i <= N ; i ++ { # if _ , exists := visited [ i ]; ! exists { # if ! helper 8 8 6 ( i , 0 , numToPrev , numToNext , visited ) { # return false # } # } # } # # return true
m := len ( matrix ) # if m == 0 { # return 0 # } # n := len ( matrix [ 0 ]) # dp := make ([] int , m + 1 ) # maxEdge , pre := 0 , 0 # for j := 0 ; j < n ; j ++ { # for i := 1 ; i < m + 1 ; i ++ { # tmp := dp [ i ] # if matrix [ i - 1 ][ j ] == ' 1 ' { # dp [ i ] = min ( dp [ i ], min ( dp [ i - 1 ], pre )) + 1 # if dp [ i ] > maxEdge { # maxEdge = dp [ i ] # } # } else { # dp [ i ] = 0 # } # pre = tmp # } # } # return maxEdge * maxEdge
bytes := [] byte ( s ) # lastIndex := len ( bytes ) - 1 # for i := len ( bytes ) - 1 ; i >= 0 ; i -- { # if bytes [ i ] != ' ' { # lastIndex = i # break # } # } # bytes = bytes [: lastIndex + 1 ] # for i := len ( bytes ) - 1 ; i >= 0 ; i -- { # if bytes [ i ] == ' ' { # return len ( bytes ) - 1 - i # } # } # return len ( bytes )
answer := 0 # # for value 1 , value 2 , value 3 := 1 , 1 , 0 ; value 3 < 4 0 0 0 0 0 0 ; value 3 = value 1 + value 2 { # if ( value 3 % 2 == 0 ){ # answer += value 3 # } # value 1 , value 2 = value 2 , value 3 # } # # fmt . Printf (" STR ", answer ) #
return New ( s ). Fields ()
if a < b { # return a # } else { # return b # }
sort . Ints ( nums ) # var res [][] int # for i := 0 ; i < len ( nums )- 2 ; i ++ { # if nums [ i ] > 0 { # break # } # if i > 0 && nums [ i ] == nums [ i - 1 ] { # continue # } # for l , r := i + 1 , len ( nums )- 1 ; l < r ; { # if l > i + 1 && nums [ l ] == nums [ l - 1 ] { # l ++ # continue # } # if r < len ( nums )- 1 && nums [ r ] == nums [ r + 1 ] { # r -- # continue # } # switch sum := nums [ i ] + nums [ l ] + nums [ r ]; { # case sum < 0 : # l ++ # case sum > 0 : # r -- # default : # res = append ( res , [] int { nums [ i ], nums [ l ], nums [ r ]}) # l ++ # r -- # } # } # } # return res
if head == nil { # return nil # } # list := []* ListNode {} # var ptr * ListNode # for ptr = head ; ptr . Next != nil ; ptr = ptr . Next { # list = append ( list , ptr ) # } # list = append ( list , ptr ) # index := len ( list ) - n # if index == 0 { # return head . Next # } # list [ index - 1 ]. Next = list [ index ]. Next # return head
if version 1 == version 2 { # return 0 # } # p 1 , version 1 := con ( version 1 ) # p 2 , version 2 := con ( version 2 ) # if p 1 > p 2 { # return 1 # } else if p 1 < p 2 { # return - 1 # } # return compareVersion ( version 1 , version 2 )
time . Sleep ( time . Duration ( rand . Intn ( 1 0 0 0 )) * time . Millisecond ) # # log . Printf (" STR ", rw . name ) # # rw . WriteLock () # # log . Printf (" STR ", rw . name ) # time . Sleep ( time . Duration ( rand . Intn ( 1 0 0 0 )) * time . Millisecond ) # log . Printf (" STR ", rw . name ) # # rw . WriteUnlock ()
newE := ltHeapElement { Value : i } # h . root = h . merge ( h . root , & newE ).(* ltHeapElement ) # h . len ++
benchmarkHashMapInsertDelete ( b , newOpenHashMap ())
var tests = [] struct { # tree * TreeNode # diff int # }{ # { newTree ( 1 , nil , 3 , 2 ), 1 }, # { newTree ( 1 0 , 4 , 1 5 , 1 , 7 , 1 3 , 1 8 ), 2 }, # } # # for _ , tt := range tests { # diff := getMinimumDifference ( tt . tree ) # if diff != tt . diff { # t . Errorf (" STR ", tt . tree , diff , tt . diff ) # } # }
return big . NewInt ( 0 ). Sub ( a , b )
fmt . Println ( findMaxConsecutiveOnes ([] int {})) # fmt . Println ( findMaxConsecutiveOnes ([] int { 1 , 1 , 0 , 1 , 1 , 1 }))
sort . Strings ( words ) # m := map [ string ] struct {}{} # res := words [ 0 ] # for _ , word := range words { # n := len ( word ) # if n == 1 { # m [ word ] = struct {}{} # } else if _ , ok := m [ word [: n - 1 ]]; ok { # m [ word ] = struct {}{} # if len ( word ) > len ( res ) { # res = word # } # } # } # return res
testFramework ( t , InsertionSort )
var tests = [] struct { # n int # solutions [][] string # }{ # { # 4 , # [][] string { # { # " STR ", # " STR ", # " STR ", # " STR ", # }, # { # " STR ", # " STR ", # " STR ", # " STR ", # }, # }, # }, # } # # for _ , tt := range tests { # solutions := solveNQueens ( tt . n ) # if reflect . DeepEqual ( solutions , tt . solutions ) == false { # t . Errorf (" STR ", tt . n , solutions , tt . solutions ) # } # }
var fib_list [] uint = make ([] uint , num ) # # fib_list [ 0 ] = 0 # fib_list [ 1 ] = 1 # # for i := 2 ; i < len ( fib_list ); i ++ { # fib_list [ i ] = fib_list [ i - 1 ] + fib_list [ i - 2 ] # } # # return fib_list
t . Parallel () # for _ , tc := range testcases { # copied := append ([] int {}, tc . nums ...) # if result := SingleOccurrenceBrute ( copied ); ! reflect . DeepEqual ( result , tc . singleOccurrence ) { # t . Errorf (" STR ", tc . singleOccurrence , result ) # } # }
t . Parallel () # # for _ , tc := range testcases { # if res := LongestPalindromicSubsequenceBrute ( tc . str ); res != tc . expected { # t . Errorf (" STR ", tc . expected , res ) # } # }
t . Parallel () # for _ , tc := range testcases { # if jumps := NumberOfJumps ( tc . n ); jumps != tc . jumps { # t . Errorf (" STR ", tc . n , tc . jumps , jumps ) # } # }
const modBase = 1 0 0 0 0 0 0 0 0 7 # pow 2 := make ([] int , len ( A )+ 1 ) # pow 2 [ 0 ] = int ( 1 ) # for i := 1 ; i < len ( pow 2 ); i ++ { # pow 2 [ i ] = ( pow 2 [ i - 1 ] << 1 ) % modBase # } # # result := 0 # sort . Ints ( A ) # for i , num := range A { # result += num * ( pow 2 [ i ] - 1 ) # result -= num * ( pow 2 [ len ( A )- i - 1 ] - 1 ) # result %= modBase # } # # return result
for i := 0 ; i < len ( arr ); i ++ { # min := i # for j := i + 1 ; j < len ( arr ); j ++ { # if arr [ j ] < arr [ min ] { # min = j # } # } # # arr [ i ], arr [ min ] = arr [ min ], arr [ i ] # } # return arr
keyValueOrChild , keyValueIdx := n . getChildOrKeyValue ( key ) # if _ , ok := keyValueOrChild .(* keyValue ); ok { # n . keyValue = append ( n . keyValue [: keyValueIdx ], n . keyValue [ keyValueIdx + 1 :]...) # n . c = append ( n . c [: keyValueIdx ], n . c [ keyValueIdx + 1 :]...) # }
res := make ([] int , 0 ) # idx , base := 0 , 1 # for ; base <= label ; base , idx = base * 2 , idx + 1 { # } # # base , idx = base / 2 , idx - 1 # for { # nextBase , nextIdx := base / 2 , idx - 1 # res = append ( res , label ) # if nextIdx < 0 { # break # } # diff := ( label - base ) / 2 # label = base - 1 - diff # base , idx = nextBase , nextIdx # } # # for s , e := 0 , len ( res )- 1 ; s < e ; s , e = s + 1 , e - 1 { # res [ s ], res [ e ] = res [ e ], res [ s ] # } # # return res
str 1 := " STR " # fmt . Println ( checkRecord ( str 1 )) # # str 2 := " STR " # fmt . Println ( checkRecord ( str 2 )) #
c := & VariableAccess { Name : " STR "} # scope := & BasicScope { # VarMap : map [ string ] Variable { # " STR ": Variable { Type : TypeList }, # }, # } # # actual , err := c . Type ( scope ) # if err != nil { # t . Fatalf (" STR ", err ) # } # if actual != TypeList { # t . Fatalf (" STR ", actual ) # }
return read ( r , fSize , h )
n := len ( A ) # f , sum := 0 , 0 # for i , a := range A { # f += i * a # sum += a # } # # res := f # for i := n - 1 ; i >= 1 ; i -- { # f += sum - n * A [ i ] # if f > res { # res = f # } # } # return res
dp := make ([][] string , n + 1 ) # dp [ 0 ] = [] string {" STR "} # dp [ 1 ] = [] string {" STR "} # for i := 2 ; i <= n ; i ++ { # for j := i - 1 ; j >= 0 ; j -- { # for _ , l := range dp [ j ] { # for _ , r := range dp [ i - j - 1 ] { # dp [ i ] = append ( dp [ i ], " STR "+ l +" STR "+ r ) # } # } # } # } # return dp [ n ]
qs := [] question 7 3 3 { # # { # para 7 3 3 {[][] int { # { 1 , 1 , 1 }, # { 1 , 1 , 0 }, # { 1 , 0 , 1 }, # }, 1 , 1 , 2 }, # ans 7 3 3 {[][] int { # { 2 , 2 , 2 }, # { 2 , 2 , 0 }, # { 2 , 0 , 1 }, # }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 3 3 , q . para 7 3 3 # fmt . Printf (" STR ", p , floodFill ( p . one , p . sr , p . sc , p . c )) # } # fmt . Printf (" STR ")
return LFUCache { # m : make ( map [ int ]* entry , capacity ), # fh : make ( freqHeap , 0 , capacity ), # cap : capacity , # }
qs := [] question 8 8 8 { # # { # para 8 8 8 {[] int {}, [] int {}}, # ans 8 8 8 {[] int {}}, # }, # # { # para 8 8 8 {[] int { 1 , 1 }, [] int { 2 , 2 }}, # ans 8 8 8 {[] int { 1 , 2 }}, # }, # # { # para 8 8 8 {[] int { 1 , 2 }, [] int { 2 , 3 }}, # ans 8 8 8 {[] int { 1 , 2 }}, # }, # # { # para 8 8 8 {[] int { 2 }, [] int { 1 , 3 }}, # ans 8 8 8 {[] int { 2 , 3 }}, # }, # # { # para 8 8 8 {[] int { 1 , 2 , 5 }, [] int { 2 , 4 }}, # ans 8 8 8 {[] int { 5 , 4 }}, # }, # # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 8 8 , q . para 8 8 8 # fmt . Printf (" STR ", p , fairCandySwap ( p . one , p . two )) # } # fmt . Printf (" STR ")
fmt . Println ( twoSum ([] int {}, 1 0 ))
n := len ( haystack ) # m := len ( needle ) # for i := 0 ; i < n + 1 - m ; i ++ { # matched := true # for j := 0 ; j < m ; j ++ { # if haystack [ i + j ] != needle [ j ] { # matched = false # break # } # } # if matched { # return i # } # } # return - 1
if n < 4 { # return n # } # res := n # for i := 1 ; i <= n ; i ++ { # tmp := i * i # if tmp > n { # break # } else { # res = min ( res , 1 + SmallestNumberOfPerfectSquaresSum ( n - tmp )) # } # } # return res
var tests = [] struct { # integer int # reversed int # }{ # { 1 2 3 , 3 2 1 }, # {- 1 2 3 , - 3 2 1 }, # { 1 2 0 , 2 1 }, # { math . MaxInt 3 2 , 0 }, # { math . MinInt 3 2 , 0 }, # } # # for _ , tt := range tests { # reversed := reverse ( tt . integer ) # if reversed != tt . reversed { # t . Errorf (" STR ", tt . integer , reversed , tt . reversed ) # } # }
pyramid := make ( map [ string ][] string ) # for _ , v := range allowed { # pyramid [ v [: len ( v )- 1 ]] = append ( pyramid [ v [: len ( v )- 1 ]], string ( v [ len ( v )- 1 ])) # } # return dfsT ( bottom , " STR ", pyramid )
cases := [] struct { # name string # inputs string # expect [] int # }{ # {" STR ", " STR ", [] int { 0 , 2 }}, # {" STR ", " STR ", [] int {- 3 4 , - 1 4 , - 1 0 , - 1 0 , 1 0 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := diffWaysToCompute ( c . inputs ) # if len ( got ) != len ( c . expect ) { # t . Fatalf (" STR ", c . expect , got , c . inputs ) # } # m := make ( map [ int ] int ) # for v := range got { # m [ v ]++ # } # for v := range c . expect { # if _ , ok := m [ v ]; ! ok { # t . Fatalf (" STR ", c . expect , got , c . inputs ) # } # } # }) # }
if ans , ok := randMemo [ k ]; ok { # return ans # } # # if k <= 5 5 { # kay := int 6 4 ( k ) # temp := ( 1 0 0 0 0 3 - ( 2 0 0 0 0 3 * kay ) + ( 3 0 0 0 0 7 * kay * kay * kay )) % 1 0 0 0 0 0 0 # randMemo [ k ] = int ( temp ) # return S ( k ) # } # # randMemo [ k ] = ( S ( k - 2 4 ) + S ( k - 5 5 )) % 1 0 0 0 0 0 0 # return S ( k )
first := date [: 4 ] + " STR " # firstDay , _ := time . Parse (" STR ", first ) # dateDay , _ := time . Parse (" STR ", date ) # duration := dateDay . Sub ( firstDay ) # return int ( duration . Hours ())/ 2 4 + 1
if r := l . next (); r != " STR " { # return l . error (" STR ") # } # l . ignore () # for { # switch r := l . next (); { # case unicode . IsNumber ( r ): # case r == " STR ": # fallthrough # case r == eof : # if l . pos == l . start { # return l . error (" STR ") # } # l . emit ( itemLength ) # return nil # default : # return l . error (" STR ") # } # }
if C <= E || G <= A || D <= F || H <= B { # return ( C - A )*( D - B ) + ( G - E )*( H - F ) # } # left := max ( A , E ) # bottom := max ( B , F ) # right := min ( C , G ) # top := min ( D , H ) # return ( C - A )*( D - B ) + ( G - E )*( H - F ) - ( right - left )*( top - bottom )
if x > y { # return x # } # # return y
sourceFileStat , err := os . Stat ( src ) # if err != nil { # return 0 , err # } # # if ! sourceFileStat . Mode (). IsRegular () { # return 0 , fmt . Errorf (" STR ", src ) # } # # source , err := os . Open ( src ) # if err != nil { # return 0 , err # } # defer source . Close () # # destination , err := os . Create ( dst ) # if err != nil { # return 0 , err # } # defer destination . Close () # nBytes , err := io . Copy ( destination , source ) # return nBytes , err
if 1 == num { # return true # } # # for middle := num / 2 ; middle >= 2 ; middle -- { # result := middle * middle # # if result == num { # return true # } else if result < num { # return false # } # } # return false
if len ( aTrack ) > 0 { # cpy := make ([] int , len ( aTrack )) # copy ( cpy , aTrack ) # * res = append (* res , cpy ) # } # for i := startIndex ; i < len ( aChoice ); i ++ { # aTrack = append ( aTrack , aChoice [ i ]) # numCombineTrack ( aTrack , aChoice , i + 1 , res ) # aTrack = aTrack [ 0 : len ( aTrack )- 1 ] # }
return self . operandStack
t . Parallel () # # for _ , tc := range testcases { # input := append ([] int {}, tc . nums ...) # if result := LargestSubsetPairs ( input ); ! reflect . DeepEqual ( result , tc . subset ) { # t . Errorf (" STR ", tc . subset , result ) # } # }
println (" STR ", s . a , s . b , s . c , s . d )
if head == nil { # return nil # } # prev := head # curr := head . Next # for curr != nil { # if prev . Value > curr . Value { # prev . Value , curr . Value = curr . Value , prev . Value # } # if curr . Next != nil && curr . Next . Value > curr . Value { # curr . Value , curr . Next . Value = curr . Next . Value , curr . Value # } # prev = curr . Next # if curr . Next == nil { # break # } # curr = curr . Next . Next # } # return head
cases := [] struct { # name string # n , m int # indices [][] int # expect int # }{ # {" STR ", 2 , 3 , [][] int {{ 0 , 1 }, { 1 , 1 }}, 6 }, # {" STR ", 2 , 2 , [][] int {{ 1 , 1 }, { 0 , 0 }}, 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . n , c . m , c . indices ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . n , c . m , c . indices ) # } # }) # }
root := & TreeNode {} # # return root
return ( ptr + 7 ) &^ 7
qs := [] question 1 6 7 { # # { # para 1 6 7 {[] int { 2 , 7 , 1 1 , 1 5 }, 9 }, # ans 1 6 7 {[] int { 1 , 2 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 6 7 , q . para 1 6 7 # fmt . Printf (" STR ", p . one , twoSum 1 6 7 ( p . one , p . two )) # } # fmt . Printf (" STR ")
return time . Date ( year , time . Month ( month ), day , 0 , 0 , 0 , 0 , time . Local ). Weekday (). String ()
if k == 1 { # return minRotated ( s ) # } # return sorted ( s )
client := & http . Client { # Timeout : 3 0 * time . Second , # } # request , errReq := http . NewRequest (" STR ", url , nil ) # if errReq != nil { # fmt . Println (" STR ", errReq . Error ()) # return # } # request . Header . Add (" STR ", " STR ") # request . Header . Add (" STR ", " STR ") # request . Header . Add (" STR ", " STR ") # request . Header . Add (" STR ", " STR ") # resp , errDo := client . Do ( request ) # if errDo == nil { # defer func () { # _ = resp . Body . Close () # }() # } # if errDo != nil { # fmt . Println (" STR ", errDo . Error ()) # return # } # body , errRead := ioutil . ReadAll ( resp . Body ) # if errRead != nil { # fmt . Println (" STR ", errRead . Error ()) # return # } # ch <- body
if len ( arr ) > 1 { # primeIdx := partition ( arr ) # quickSort ( arr [: primeIdx ]) # quickSort ( arr [ primeIdx + 1 :]) # }
cases := [] struct { # name string # inputs * TreeNode # expect int # }{ # {" STR ", # & TreeNode { Val : 3 , # Left : & TreeNode { Val : 9 , Left : nil , Right : nil }, # Right : & TreeNode { Val : 2 0 , # Left : & TreeNode { Val : 1 5 , Left : nil , Right : nil }, # Right : & TreeNode { Val : 7 , Left : nil , Right : nil }, # }, # }, # 2 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := minDepth ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
fmt . Printf (" STR ", permute ([] int { 1 , 2 , 3 }))
n , ans := len ( nums ), 0 # nums = Sort ( nums ) # for c := 0 ; c < n - 1 ; c ++ { # a , b := n - 1 , c + 1 # for b < a { # if nums [ a ]+ nums [ b ] > nums [ c ] { # ans += ( a - b ) # b ++ # } else { # a -- # } # } # # } # return ans
s := MinStack {} # s . Push ( 1 ) # s . Push ( 2 ) # fmt . Println ( s . Top ()) # fmt . Println ( s . GetMin ()) # s . Pop () # fmt . Println ( s . GetMin ()) # fmt . Println ( s . Top ())
currentLongestWord := "" # scanner := bufio . NewScanner ( rdr ) # scanner . Split ( bufio . ScanWords ) # for scanner . Scan () { # wordOrManyWords := scanner . Text () # wordOrManyWords = strings . Replace ( wordOrManyWords , " STR ", " STR ", - 1 ) # wordOrManyWords = strings . Replace ( wordOrManyWords , " STR ", " STR ", - 1 ) # wordOrManyWords = strings . Replace ( wordOrManyWords , " STR ", " STR ", - 1 ) # for _ , word := range strings . Fields ( wordOrManyWords ) { # if len ( word ) > len ( currentLongestWord ) { # currentLongestWord = word # } # } # } # return currentLongestWord
if k <= 1 { # return 0 # } # count , left , one := 0 , 0 , 1 # for right := 0 ; right < len ( nums ); right ++ { # one *= nums [ right ] # for one >= k { # one /= nums [ left ] # left ++ # } # count += right - left + 1 # } # return count
s 2 := s / 2 # mlimit := int ( math . Sqrt ( float 6 4 ( s 2 ))) - 1 # var a , b , c , k int # loop : # for m := 2 ; m <= mlimit ; m ++ { # if s 2 % m == 0 { # sm := s 2 / m # for sm % 2 == 0 { # sm /= 2 # } # if m % 2 == 1 { # k = m + 2 # } else { # k = m + 1 # } # for k < 2 * m && k <= sm { # if sm % k == 0 && Gcd ( k , m ) == 1 { # d := s 2 / ( k * m ) # n := k - m # a = d * ( m * m - n * n ) # b = 2 * d * m * n # c = d * ( m * m + n * n ) # break loop # } # k += 2 # } # } # } # return a * b * c
iE := i .(* linkedHeapListElement ) # return iE . parent
rec := [ 2 6 ][][ 3 ] int {} # segments , index := split ( text ), 0 # for _ , s := range segments { # b , n := int ( s [ 0 ]-' a '), len ( s ) # rec [ b ] = append ( rec [ b ], [ 3 ] int { index , index + n + 1 , n }) # index += n # } # # res := 0 # for _ , r := range rec { # n := len ( r ) # if n == 0 { # continue # } # ext := 0 # if n > 1 { # ext = 1 # } # con := 0 # if n > 2 { # con = 1 # } # prev := r [ 0 ] # res = max ( res , ext + prev [ 2 ]) # for i := 1 ; i < len ( r ); i ++ { # cur := r [ i ] # if prev [ 1 ] == cur [ 0 ] { # res = max ( res , con + prev [ 2 ]+ cur [ 2 ]) # } else { # res = max ( res , ext + cur [ 2 ]) # } # prev = cur # } # } # # return res
qs := [] question 5 3 7 { # # { # para 5 3 7 {" STR ", " STR "}, # ans 5 3 7 {" STR "}, # }, # # { # para 5 3 7 {" STR ", " STR "}, # ans 5 3 7 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 3 7 , q . para 5 3 7 # fmt . Printf (" STR ", p , complexNumberMultiply ( p . a , p . b )) # } # fmt . Printf (" STR ")
return validIPAddresses ( digits , 0 )
 # n = n ^ ( n >> 1 ) # return ( n & ( n + 1 )) == 0
s := math . Sqrt ( v [ 0 ]* v [ 0 ] + v [ 1 ]* v [ 1 ] + v [ 2 ]* v [ 2 ]) # v [ 0 ] = v [ 0 ] / s # v [ 1 ] = v [ 1 ] / s # v [ 2 ] = v [ 2 ] / s
var tests = [] struct { # digits [] int # plus [] int # }{ # {[] int { 1 , 2 , 3 }, [] int { 1 , 2 , 4 }}, # {[] int { 4 , 3 , 2 , 1 }, [] int { 4 , 3 , 2 , 2 }}, # {[] int { 9 , 9 , 9 , 9 }, [] int { 1 , 0 , 0 , 0 , 0 }}, # } # # for _ , tt := range tests { # digits := make ([] int , len ( tt . digits )) # copy ( digits , tt . digits ) # # plus := plusOne ( tt . digits ) # if reflect . DeepEqual ( plus , tt . plus ) == false { # t . Errorf (" STR ", digits , plus , tt . plus ) # } # }
res := make ( map [ string ] bool , len ( words )) # for _ , w := range words { # var b bytes . Buffer # for i := 0 ; i < len ( w ); i ++ { # fmt . Fprint (& b , table [ w [ i ]-' a ']) # } # res [ b . String ()] = true # } # return len ( res )
if len ( matrix ) == 0 { # return [] int {} # } # r , c := 0 , 0 # m , n := len ( matrix ), len ( matrix [ 0 ]) # ret := make ([] int , m * n ) # for i := 0 ; i < m * n ; i ++ { # ret [ i ] = matrix [ r ][ c ] # if ( r + c )% 2 == 0 { # if c == n - 1 { # r ++ # } else if r == 0 { # c ++ # } else { # r -- # c ++ # } # } else { # if r == m - 1 { # c ++ # } else if c == 0 { # r ++ # } else { # r ++ # c -- # } # } # } # return ret
index 1 := make ([] int , 2 5 6 ) # index 2 := make ([] int , 2 5 6 ) # for i := 0 ; i < len ( s ); i ++ { # if index 1 [ s [ i ]] != index 2 [ t [ i ]] { # return false # } # index 1 [ s [ i ]] = i + 1 # index 2 [ t [ i ]] = i + 1 # } # return true
if len ( this . data ) > 0 { # return this . data [ len ( this . data )- 1 ] # } # # return - 1
dict := make ( map [ int ] int , len ( nums )) # # for _ , value := range nums { # dict [ value ]++ # } # # for _ , v := range dict { # if v > 1 { # return true # } # } # return false
nodes := make ([] int , 0 ) # treeArray ( root , & nodes ) # return binarySearch ( nodes , k )
h . UpScale () # hashKey := h . hash ( key ) # if h . backets [ hashKey ] == nil { # h . backets [ hashKey ] = list . New () # } # e := hashElement { Key : key , Value : value } # le , exist := h . existInList ( key , h . backets [ hashKey ]) # if exist { # le . Value = e # } else { # h . backets [ hashKey ]. PushFront ( e ) # h . Count ++ # }
if root != nil { # inorder ( root . Left ) # println ( root . Val ) # inorder ( root . Right ) # }
if node == nil { # serialized = append ( serialized , " STR ") # } else { # serialized = append ( serialized , fmt . Sprintf (" STR ", node . val )) # serialized = preorderSerialize ( node . left , serialized ) # serialized = preorderSerialize ( node . right , serialized ) # } # return serialized
this . mutex . Lock () # defer this . mutex . Unlock () # # if priority < 0 || priority > this . max { # return nil # } # # if this . total == 0 { # return nil # } # # this . waiting [ priority ] = 0 # ret := this . queues [ priority ]. RemoveWait () # # this . updateRemoval () # # return ret
var diamondMap = map [ byte ] bool {} # for i := 0 ; i < len ( J ); i ++ { # diamondMap [ J [ i ]] = true # } # # cnt := 0 # for i := 0 ; i < len ( S ); i ++ { # if diamondMap [ S [ i ]] == true { # cnt ++ # } # } # return cnt
s = sum # prefixSum = map [ int ] int {} # prefixSum [ 0 ] = 1 # return dfs ( root , 0 )
dp := make ([] int , amount + 1 ) # dp [ 0 ] = 1 # for j := 0 ; j < len ( coins ); j ++ { # for i := 1 ; i <= amount ; i ++ { # if i - coins [ j ] >= 0 { # dp [ i ] += dp [ i - coins [ j ]] # } # } # } # return dp [ amount ]
return me . Network
runtime . GOMAXPROCS ( 2 ) # # var wg sync . WaitGroup # wg . Add ( 2 ) # # fmt . Println (" STR ") # # go func () { # defer wg . Done () # # for count := 0 ; count < 3 ; count ++ { # for char := " STR "; char < " STR "+ 2 6 ; char ++ { # fmt . Printf (" STR ", char ) # } # } # }() # # go func () { # defer wg . Done () # # for count := 0 ; count < 3 ; count ++ { # for char := " STR "; char < " STR "+ 2 6 ; char ++ { # fmt . Printf (" STR ", char ) # } # } # }() # # fmt . Println (" STR ") # wg . Wait () # # fmt . Println (" STR ")
tests := [...] testType { # { # in : 2 , # want : true , # }, # { # in : 3 , # want : false , # }, # } # for _ , tt := range tests { # got := divisorGame ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
m := make ( map [ int ] int ) # for j , v := range nums { # if i , ok := m [ target - v ]; ok { # return [] int { i , j } # } # m [ v ] = j # } # return nil
result := make ([] int , 0 ) # result , ok := flipCore ( root , voyage , 0 , len ( voyage )- 1 , result ) # if ok { # return result # } # # return [] int {- 1 }
n := node .(* gbtElement ) # if t . IsNil ( n . Right ) { # return t . NilNode # } # newNode := n . Right # if n . Parent . Left == n { # n . Parent . Left = newNode # } # if n . Parent . Right == n { # n . Parent . Right = newNode # } # n . Parent , newNode . Parent = newNode , n . Parent # newNode . Left , n . Right = n , newNode . Left # if ! t . IsNil ( n . Right ) { # n . Right . Parent = n # } # return newNode
tests := [...] testType { # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := reverseOnlyLetters ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
frame := self . stack . Pop () # return frame
if n == 0 { # return false # } # for n != 1 { # if n % 4 != 0 { # return false # } # n /= 4 # } # return true
res , sum := 0 , 0 # rec := make ( map [ int ] int , len ( a )) # rec [ 0 ] = 1 # # for i := range a { # sum += a [ i ] # res += rec [ sum - k ] # rec [ sum ]++ # } # # return res
var c ByteCounter # c . Write ([] byte (" STR ")) # fmt . Println ( c ) # # c = 0 # var name = " STR " # fmt . Fprintf (& c , " STR ", name ) # fmt . Println ( c )
sort . Ints ( s 1 ) # sort . Ints ( s 2 ) # return reflect . DeepEqual ( s 1 , s 2 )
minIndex := 0 # maxIndex := bound - 1 # for minIndex <= maxIndex { # midIndex := int (( maxIndex + minIndex ) / 2 ) # midItem := array [ midIndex ] # if number == midItem { # return midIndex # } # if midItem < number { # minIndex = midIndex + 1 # } else if midItem > number { # maxIndex = midIndex - 1 # } # } # return - 1
n := len ( A ) # preSum := make ([] int , n + 1 ) # sum := 0 # res := 0 # for _ , a := range A { # sum += a # tmp := sum - S # if tmp >= 0 { # res += preSum [ tmp ] # } # if sum == S { # res ++ # } # preSum [ sum ]++ # } # return res
left := 0 # right := len ( arr ) - 1 # for left <= right { # mid := left + (( right - left ) >> 1 ) # if target == arr [ mid ] { # return mid # } else if target > arr [ mid ] { # left = mid + 1 # } else if target < arr [ mid ] { # right = mid - 1 # } # } # return - 1
if root == nil { # return 0 # } # return CountNodes ( root . left ) + CountNodes ( root . right ) + 1
n := len ( A ) # # stack , top , pop := make ([] int , n + 1 ), 0 , 0 # stack [ top ] = math . MaxInt 6 4 # # res := 0 # for _ , a := range A { # for stack [ top ] <= a { # pop , top = stack [ top ], top - 1 # res += pop * min ( stack [ top ], a ) # } # stack [ top + 1 ], top = a , top + 1 # } # # for top >= 2 { # pop , top = stack [ top ], top - 1 # res += pop * stack [ top ] # } # # return res
k := getK ( arr ) # array_of_counts := make ([] int , k ) # # for i := 0 ; i < len ( arr ); i ++ { # array_of_counts [ arr [ i ]] += 1 # } # # for i , j := 0 , 0 ; i < k ; i ++ { # for { # if array_of_counts [ i ] > 0 { # arr [ j ] = i # j += 1 # array_of_counts [ i ] -= 1 # continue # } # break # } # }
for i , expr := range n . Exprs { # n . Exprs [ i ] = expr . Accept ( v ) # } # # return v ( n )
heights = append ([] int {- 2 }, heights ...) # heights = append ( heights , - 1 ) # # size := len ( heights ) # # stack := make ([] int , 1 , size ) # end := 1 # # res := 0 # for end < size { # if heights [ stack [ len ( stack )- 1 ]] < heights [ end ] { # stack = append ( stack , end ) # end ++ # continue # } # # begin := stack [ len ( stack )- 2 ] # index := stack [ len ( stack )- 1 ] # height := heights [ index ] # area := ( end - begin - 1 ) * height # # res = max ( res , area ) # # stack = stack [: len ( stack )- 1 ] # } # # return res
t . Parallel () # for _ , tc := range testcases { # if rounds := FairCoinFlipDownToOne ( tc . coins ); rounds != tc . rounds { # t . Errorf (" STR ", tc . coins , tc . rounds , rounds ) # } # }
stringTypes := make ([] string , len ( typesFound )) # i := 0 # for k , _ := range typesFound { # stringTypes [ 0 ] = k . String () # i ++ # } # return strings . Join ( stringTypes , " STR ")
tests := map [ string ] string { # " STR ": " STR ", # " STR ": " STR ", # " STR ": " STR ", # " STR ": " STR ", # } # # for in , want := range tests { # got := toLowerCase ( in ) # if got != want { # t . Fatalf (" STR ", in , got , want ) # } # }
minD := 9 9 9 9 9 9 9 9 9 # for k := 1 ; k < 9 9 9 9 9 9 9 9 ; k ++ { # pK := genPentagonal ( k ) # for j := k - 1 ; j > 0 ; j -- { # pJ := genPentagonal ( j ) # if pK - pJ < minD { # if isPentagonal ( pK - pJ ) && isPentagonal ( pK + pJ ) { # minD = pK - pJ # fmt . Println (" STR ", pK , " STR ", pJ , " STR ", minD ) # break # } # } else { # break # } # } # } # fmt . Println (" STR ", minD )
t . Parallel () # for _ , tc := range testcases { # if result := RunMarkovChain ( tc . start , tc . states , tc . numSteps ); ! close ( result , tc . expected , tc . expectedTolerance ) { # t . Errorf (" STR ", result , tc . expected ) # } # }
println (" STR ", len ( a . a ), a . n )
chArray := [] byte ( S ) # i , j := 0 , len ( S )- 1 # for i < j { # if ! unicode . IsLetter ( rune ( chArray [ i ])) { # i ++ # } else if ! unicode . IsLetter ( rune ( chArray [ j ])) { # j -- # } else { # chArray [ i ], chArray [ j ] = chArray [ j ], chArray [ i ] # i ++ # j -- # } # } # # return string ( chArray )
if strings . Contains ( A , B ) { # return 1 # } # # tempA := A # for i := 0 ; len ( tempA ) <= 1 0 0 0 0 ; i ++ { # tempA += A # if strings . Contains ( tempA , B ) { # return i + 2 # } # } # return - 1
tpl , err := template . ParseGlob (" STR ") # if err != nil { # http . Error ( res , err . Error (), 5 0 0 ) # return # } # var buf bytes . Buffer # err = tpl . ExecuteTemplate (& buf , name , data ) # if err == nil { # type Page struct { # Body template . HTML # } # err = tpl . ExecuteTemplate ( res , " STR ", Page { # Body : template . HTML ( buf . String ()), # }) # } # if err != nil { # http . Error ( res , err . Error (), 5 0 0 ) # return # }
random := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # letters := [] rune (" STR ") # text := make ([] rune , random . Intn ( 1 5 - 1 0 )+ 1 0 ) # for i := range text { # text [ i ] = letters [ rand . Intn ( len ( letters ))] # } # end := random . Intn ( len ( text )- 5 ) + 5 # start := random . Intn ( end ) # result := NaiveStringSearch ( string ( text ), string ( text [ start : end ])) # if result == - 1 { # t . Fail () # }
dp := make ([] int , n + 1 ) # dp [ 0 ], dp [ 1 ] = 1 , 1 # for i := 2 ; i <= n ; i ++ { # dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] # } # return dp [ n ]
count := map [ string ] int {} # m := map [ string ] struct {}{} # for _ , b := range banned { # m [ b ] = struct {}{} # } # bs := [] byte {} # for i := 0 ; i < len ( paragraph ); i ++ { # b := paragraph [ i ] # if b >= ' A ' && b <= ' Z ' || b >= ' a ' && b <= ' z ' { # if b <= ' Z ' { # b += 3 2 # } # bs = append ( bs , b ) # continue # } # if len ( bs ) == 0 { # continue # } # word := string ( bs ) # if _ , ok := m [ word ]; ! ok { # count [ word ]++ # } # bs = bs [: 0 ] # } # if len ( bs ) != 0 { # word := string ( bs ) # if _ , ok := m [ word ]; ! ok { # count [ word ]++ # } # bs = bs [: 0 ] # } # max := 0 # res := " STR " # for word , c := range count { # if c > max { # max = c # res = word # } # } # return res
memo := make ( map [ int ][ 4 ] int ) # # return _getMatrix ( n , memo )
StoreUint 6 4 (& r . Reg , value )
ss := strings . Split ( s , " STR ") # for i , s := range ss { # ss [ i ] = reverse ( s ) # } # return strings . Join ( ss , " STR ")
data , _ := ioutil . ReadFile (" STR ") # numerals = strings . Split ( string ( data ), " STR ") # total := 0 # for _ , numeral := range numerals { # total += len ( numeral ) # total -= len ( findMinimalRepresentation ( numeral )) # } # fmt . Println ( total )
t . Parallel () # # for tcid , tc := range testcases { # if result := IsSoloBlackKingInCheck ( tc . board ); result != tc . inCheck { # t . Errorf (" STR ", tcid , tc . inCheck , result ) # } # }
if *( t . clk ) < t . r + t . startTime { # return wait # } else if t . p > 0 { # return run # } else { # return finish # }
sort . Ints ( nums ) # sets := make ([][] int , 1 , 1 << uint ( len ( nums ))) # for i , j := 0 , 0 ; i < len ( nums ); i = j { # n := len ( sets ) # for k := 0 ; j < len ( nums ) && nums [ i ] == nums [ j ]; j , k = j + 1 , k + n { # for _ , set := range sets [ k :] { # s := make ([] int , len ( set ), len ( set )+ 1 ) # copy ( s , set ) # sets = append ( sets , append ( s , nums [ i ])) # } # } # } # return sets
ones , twos := 0 , 0 # for _ , n := range nums { # ones = ( ones ^ n ) & ^ twos # twos = ( twos ^ n ) & ^ ones # } # return ones
tests := [...] testType { # { # in : [] int { 2 , 1 , 2 }, # want : 5 , # }, # { # in : [] int { 1 , 2 , 1 }, # want : 0 , # }, # { # in : [] int { 3 , 2 , 3 , 4 }, # want : 1 0 , # }, # { # in : [] int { 3 , 6 , 2 , 3 }, # want : 8 , # }, # } # for _ , tt := range tests { # got := largestPerimeter ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
tmp := & ListNode {- 1 , head } # pre := tmp # for i := 0 ; i < m - 1 ; i ++ { # pre = pre . Next # } # cur := pre . Next # for i := 0 ; i < n - m ; i ++ { # move := cur . Next # cur . Next = move . Next # move . Next = pre . Next # pre . Next = move # } # return tmp . Next
cases := [] struct { # name string # inputs [][] int # expect [][] int # }{ # {" STR ", # [][] int {{ 1 0 , 1 , 2 , 7 , 6 , 1 , 5 }, { 8 }}, # [][] int {{ 1 , 7 }, { 1 , 2 , 5 }, { 2 , 6 }, { 1 , 1 , 6 }}, # }, # {" STR ", # [][] int {{ 2 , 5 , 2 , 1 , 2 }, { 5 }}, # [][] int {{ 1 , 2 , 2 }, { 5 }}, # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := combinationSum 2 ( c . inputs [ 0 ], c . inputs [ 1 ][ 0 ]) # # if ! IsEuqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
t . Parallel () # lca := & Node {& Node {& Node {}}} # n 1 := & Node { lca } # n 2 := & Node {& Node {& Node { lca }}} # if result := LowestCommonAncestor ( n 1 , n 2 ); result != lca { # t . Errorf (" STR ") # } # n 3 := & Node {& Node {& Node {}}} # if result := LowestCommonAncestor ( n 3 , n 2 ); result != nil { # t . Errorf (" STR ") # } # cycle := & Node {& Node {}} # cycle . Parent . Parent = cycle # if result := LowestCommonAncestor ( cycle , n 2 ); result != nil { # t . Errorf (" STR ") # } # if result := LowestCommonAncestor ( n 2 , cycle ); result != nil { # t . Errorf (" STR ") # }
var s Stack # if s . Len () != 0 { # t . Fatalf (" STR ", s . Len ()) # } # # n := & LiteralNode { Value : 4 2 } # s . Push ( n ) # # if s . Len () != 1 { # t . Fatalf (" STR ", s . Len ()) # } # # actual := s . Pop () # if ! reflect . DeepEqual ( actual , n ) { # t . Fatalf (" STR ", actual ) # } # # if s . Len () != 0 { # t . Fatalf (" STR ", s . Len ()) # }
return lookup ( func ( i int ) net . IP { # return ipl . ranges [ i ]. First # }, func ( i int ) Range { # return ipl . ranges [ i ] # }, len ( ipl . ranges ), ip )
tests := [...] testType { # { # in : 1 , # want : true , # }, # { # in : 6 , # want : true , # }, # { # in : 8 , # want : true , # }, # { # in : 1 4 , # want : false , # }, # { # in : 0 , # want : false , # }, # { # in : - 3 0 , # want : false , # }, # } # for _ , tt := range tests { # got := isUgly ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if p . val < root . val && q . val < root . val { # return Lowest ( root . left , p , q ) # } # if p . val > root . val && q . val > root . val { # return Lowest ( root . right , p , q ) # } # return root
qs := [] question 8 5 2 { # # { # para 8 5 2 {[] int { 0 , 1 , 0 }}, # ans 8 5 2 { 1 }, # }, # # { # para 8 5 2 {[] int { 0 , 2 , 1 , 0 }}, # ans 8 5 2 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 5 2 , q . para 8 5 2 # fmt . Printf (" STR ", p , peakIndexInMountainArray ( p . one )) # } # fmt . Printf (" STR ")
actMap := make ( map [ string ] int ) # expMap := map [ string ] int { # " STR ": 1 , # " STR ": 2 , # " STR ": 9 9 9 , # " STR ": 1 6 , # " STR ": 9 0 , # } # for i , v := range expMap { # hmap . HashInsert ( i , v ) # value , _ := hmap . HashGet ( i ) # actMap [ i ] = value .( int ) # } # if ! reflect . DeepEqual ( actMap , expMap ) { # t . Log ( fmt . Sprintf (" STR ", expMap ) + fmt . Sprintf (" STR ", actMap )) # t . Fail () # }
b . lock . Lock () # defer b . lock . Unlock () # # var used bool # # e := b . table [ key ] # if e != nil { # used = true # } else { # e , used = b . freeSomeEntry ( now ) # if e == nil { # return # } # } # if used { # b . removeEntry ( e ) # } # # e . key = key # e . value = value # e . expire = expire # b . insertEntry ( e )
arr 2 d := make ([][] int , m ) # # for i := 0 ; i < len ( arr 2 d ); i ++ { # arr 2 d [ i ] = make ([] int , n ) # } # # var MaxNum int # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # if i == 0 && j == 0 { # arr 2 d [ i ][ j ] = 0 # MaxNum = arr 2 d [ i ][ j ] # } else { # # if i > 0 && j > 0 { # arr 2 d [ i ][ j ] = arr 2 d [ i - 1 ][ j ] + arr 2 d [ i ][ j - 1 ] # MaxNum = arr 2 d [ i ][ j ] # } else { # # arr 2 d [ i ][ j ] = 1 # MaxNum = arr 2 d [ i ][ j ] # # } # } # # } # } # fmt . Println ( arr 2 d [ 0 ]) # fmt . Println ( arr 2 d [ 1 ]) # fmt . Println ( arr 2 d [ 2 ]) # # return MaxNum
qs := [] question 8 5 { # # { # para 8 5 {[][] byte {{' 1 ', ' 0 ', ' 1 ', ' 0 ', ' 0 '}, {' 1 ', ' 0 ', ' 1 ', ' 1 ', ' 1 '}, {' 1 ', ' 1 ', ' 1 ', ' 1 ', ' 1 '}, {' 1 ', ' 0 ', ' 0 ', ' 1 ', ' 0 '}}}, # ans 8 5 { 6 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 5 , q . para 8 5 # fmt . Printf (" STR ", p , maximalRectangle ( p . one )) # } # fmt . Printf (" STR ")
size := len ( deck ) # # count := make ( map [ int ] int , size ) # for _ , card := range deck { # count [ card ]++ # } # # d := count [ deck [ 0 ]] # # for _ , c := range count { # d = gcd ( d , c ) # if d == 1 { # return false # } # } # # return true
s , err := GorootVersionString ( goroot ) # if err != nil { # return 0 , 0 , err # } # # if s == " STR " { # return 0 , 0 , errors . New (" STR ") # } # # parts := strings . Split ( s [ 2 :], " STR ") # if len ( parts ) < 2 { # return 0 , 0 , errors . New (" STR ") # } # # var trailing string # n , err := fmt . Sscanf ( s , " STR ", & major , & minor , & trailing ) # if n == 2 && err == io . EOF { # err = nil # } # if err != nil { # return 0 , 0 , fmt . Errorf (" STR ", err ) # } # return
fmt . Println ( possibleBipartition ( 4 , [][] int {[] int { 1 , 2 }, [] int { 1 , 3 }, [] int { 2 , 4 }}))
for _ , r := range A { # for i , j := 0 , len ( r )- 1 ; i <= j ; i , j = i + 1 , j - 1 { # r [ i ], r [ j ] = r [ j ]^ 1 , r [ i ]^ 1 # } # } # return A
return Solution { # o : nums , # }
if _ , in := st . elements [ value ]; in { # return true # } # return false
if len ( prices ) == 0 { # return 0 # } # var profit int # min := prices [ 0 ] # for i := 1 ; i < len ( prices ); i ++ { # if prices [ i ] < min { # min = prices [ i ] # } else { # tmp := prices [ i ] - min # if tmp > profit { # profit = tmp # } # } # } # return profit
for i := 0 ; i < top ; i ++ { # ch <- i # } # close ( ch ) # wg . Done ()
s := make ([] string , 0 , n ) # for i := 1 ; i <= n ; i ++ { # str := " STR " # if i % 3 == 0 { # str += " STR " # } # if i % 5 == 0 { # str += " STR " # } # if str == " STR " { # str = strconv . Itoa ( i ) # } # s = append ( s , str ) # } # return s
p := make ([] int , len ( seq )) # m := make ([] int , len ( seq )+ 1 ) # l := 0 # # for i := range seq { # lo := 1 # hi := l # # for lo <= hi { # mid := ( lo + hi ) / 2 # if ( lo + hi )% 2 != 0 { # mid ++ # } # # if seq [ m [ mid ]] <= seq [ i ] { # lo = mid + 1 # } else { # hi = mid - 1 # } # } # # newL := lo # p [ i ] = m [ newL - 1 ] # m [ newL ] = i # # if newL > l { # l = newL # } # } # # s := make ([] int , l ) # k := m [ l ] # # for i := len ( s ) - 1 ; i >= 0 ; i -- { # s [ i ] = seq [ k ] # k = p [ k ] # } # # return s
i := [ 1 0 ] string {" STR " , " STR " , " STR " , " STR " , " STR " , " STR " , " STR " , " STR " , " STR " } # x := [ 1 0 ] string {" STR " , " STR " , " STR " , " STR " , " STR " , " STR " , " STR " , " STR " , " STR " } # c := [ 1 0 ] string {" STR " , " STR " , " STR " , " STR " , " STR " , " STR " , " STR " , " STR " , " STR " } # m := [ 4 ] string {" STR " , " STR " , " STR " } # return m [ num / 1 0 0 0 ] + c [ num % 1 0 0 0 / 1 0 0 ] + x [ num % 1 0 0 0 % 1 0 0 / 1 0 ] + i [ num % 1 0 0 0 % 1 0 0 % 1 0 ]
t := & ListNode {} # t . Next = head # p := t # for p . Next != nil && p . Next . Next != nil { # if p . Next . Val == p . Next . Next . Val { # dup := p . Next . Val # for p . Next != nil && p . Next . Val == dup { # p . Next = p . Next . Next # } # } else { # p = p . Next # } # } # return t . Next
if targetIndex < 0 || targetIndex >= len ( nums ) { # panic (" STR ") # } # val := nums [ targetIndex ] # left , right := targetIndex - 1 , targetIndex + 1 # for left >= 0 || right < len ( nums ) { # if left >= 0 && nums [ left ] > val { # return left # } else if right < len ( nums ) && nums [ right ] > val { # return right # } # left -- # right ++ # } # return - 1
maxSolutions , maxN := 0 , 0 # for n := 1 ; n <= 1 0 0 0 ; n ++ { # solutions := 0 # for a := 1 ; a < n ; a ++ { # for b := a ; b < ( n - a ); b ++ { # c := n - a - b # if a * a + b * b == c * c { # solutions ++ # } # } # } # if solutions > maxSolutions { # maxN = n # maxSolutions = solutions # } # } # fmt . Println (" STR ", maxSolutions , " STR ", maxN )
xFloat , yFloat , boundFloat := float 6 4 ( x ), float 6 4 ( y ), float 6 4 ( bound ) # ans , m := make ([] int , 0 ), make ( map [ float 6 4 ] bool ) # for i := 0 . 0 ; i < 1 8 && math . Pow ( xFloat , i ) <= boundFloat ; i ++ { # for j := 0 . 0 ; j < 1 8 && math . Pow ( yFloat , j ) <= boundFloat ; j ++ { # if v := math . Pow ( xFloat , i ) + math . Pow ( yFloat , j ); v <= boundFloat && ! m [ v ] { # ans , m [ v ] = append ( ans , int ( v )), true # } # } # } # return ans
fmt . Println ( findDisappearedNumbers ([] int { 4 , 3 , 2 , 7 , 8 , 2 , 3 , 1 }))
numToFBT := make ( map [ int ][]* TreeNode ) # numToFBT [ 0 ] = make ([]* TreeNode , 0 ) # numToFBT [ 1 ] = []* TreeNode {& TreeNode { Val : 0 }} # helper 8 9 4 ( N , numToFBT ) # return numToFBT [ N ]
return int ( math . Floor ( math . Log 1 0 ( float 6 4 ( x )) + 1 . 0 ))
A := new ( point ) # A . x = x # A . y = y # # return A
if len ( A ) != len ( B ) { # return false # } # A = strings . Repeat ( A , 2 ) # return strings . Contains ( A , B )
if x < y { # x = x + y # y = x - y # x = x - y # } # for y != 0 { # x , y = y , x % y # } # return x
var tests = [] struct { # n int # happy bool # }{ # { 1 , true }, # { 1 9 , true }, # { 3 1 3 , true }, # { 3 1 4 , false }, # } # # for _ , tt := range tests { # happy := isHappy ( tt . n ) # if happy != tt . happy { # t . Errorf (" STR ", tt . n , happy , tt . happy ) # } # }
for i := 3 ; i < len ( x ); i ++ { # if x [ i ] >= x [ i - 2 ] && x [ i - 1 ] <= x [ i - 3 ] { # return true # } # if i == 4 && x [ i - 1 ] == x [ i - 3 ] && x [ i ]+ x [ i - 4 ] >= x [ i - 2 ] { # return true # } # if i >= 5 && x [ i - 2 ] >= x [ i - 4 ] && x [ i ]+ x [ i - 4 ] >= x [ i - 2 ] && # x [ i - 1 ] <= x [ i - 3 ] && x [ i - 1 ]+ x [ i - 5 ] >= x [ i - 3 ] { # return true # } # } # return false
arriveTo 8 9 := 0 # # for i := 1 ; i < 1 0 0 0 0 0 0 0 ; i ++ { # # var chain [] int # chain = append ( chain , i ) # # for { # # digits := getDigits ( chain [ len ( chain )- 1 ]) # digitsSum := 0 # # for _ , d := range digits { # digitsSum += d * d # } # # chain = append ( chain , digitsSum ) # # if chain [ len ( chain )- 1 ] == 1 { # # break # } # # if chain [ len ( chain )- 1 ] == 8 9 { # # arriveTo 8 9 ++ # break # } # # } # # } # # fmt . Println ( arriveTo 8 9 ) #
res , evenSum := make ([] int , 0 ), 0 # for _ , val := range A { # if val % 2 == 0 { # evenSum += val # } # } # for _ , query := range queries { # val , index := query [ 0 ], query [ 1 ] # if A [ index ]% 2 == 0 { # evenSum -= A [ index ] # } # A [ index ] += val # if A [ index ]% 2 == 0 { # evenSum += A [ index ] # } # res = append ( res , evenSum ) # } # return res
if drawn == rounds { # if 2 * won > drawn { # return 1 # } else { # return 0 # } # } # # return prob ( won + 1 , drawn + 1 , rounds )* 1 / float 6 4 ( drawn + 2 ) + prob ( won , drawn + 1 , rounds )* float 6 4 ( drawn + 1 )/ float 6 4 ( drawn + 2 ) #
t . Parallel () # for _ , tc := range testcases { # if result := LexicographicallySmallest ( tc . str , tc . k ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
head := & ListNode { Val : - 1 , Next : nil } # tmp := head # for _ , v := range nums { # tmp . Next = & ListNode { Val : v , Next : nil } # tmp = tmp . Next # } # return head . Next
min , max := make ([] int , len ( A )), make ([] int , len ( A )) # # max [ 0 ] = A [ 0 ] # for i := 1 ; i < len ( A ); i ++ { # if A [ i ] > max [ i - 1 ] { # max [ i ] = A [ i ] # } else { # max [ i ] = max [ i - 1 ] # } # } # # min [ len ( A )- 1 ] = A [ len ( A )- 1 ] # for i := len ( A ) - 2 ; i >= 0 ; i -- { # if A [ i ] < min [ i + 1 ] { # min [ i ] = A [ i ] # } else { # min [ i ] = min [ i + 1 ] # } # } # # for i := 0 ; i < len ( A )- 1 ; i ++ { # if max [ i ] <= min [ i + 1 ] { # return i + 1 # } # } # # return - 1
qs := [] question 3 7 2 { # # { # para 3 7 2 { 2 , [] int { 3 }}, # ans 3 7 2 { 8 }, # }, # # { # para 3 7 2 { 2 , [] int { 1 , 0 }}, # ans 3 7 2 { 1 0 2 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 7 2 , q . para 3 7 2 # fmt . Printf (" STR ", p , superPow ( p . a , p . b )) # } # fmt . Printf (" STR ")
node := root # for node != nil { # next := node . Left # for node != nil && node . Left != nil { # node . Left . Next = node . Right # if node . Next != nil { # node . Right . Next = node . Next . Left # } # node = node . Next # } # # node = next # } # # return root
return m . cache [ m . bucketNo ( key )]. Get ( key )
if h . n == 0 { # return 0 # } # i := 1 # for diff := h . n ; diff != 1 ; { # diff = h . n >> uint 3 2 ( i ) # i ++ # } # return i
fmt . Println ( nextGreatestLetter ([] byte {' c ', ' f ', ' j '}, ' a '))
zeroCols := make ( map [ int ] int ) # for i := range matrix { # rowHasZero := false # for j := range matrix [ i ] { # if 0 == matrix [ i ][ j ] { # rowHasZero = true # zeroCols [ j ] = 1 # } # if _ , ok := zeroCols [ j ]; ok { # for k := 0 ; k <= i ; k ++ { # matrix [ k ][ j ] = 0 # } # } # } # if rowHasZero { # for j := range matrix [ i ] { # matrix [ i ][ j ] = 0 # } # } # }
type arg struct { # version 1 string # version 2 string # } # # testCases := [] arg { # { version 1 : " STR ", version 2 : " STR "}, # { version 1 : " STR ", version 2 : " STR "}, # { version 1 : " STR ", version 2 : " STR "}, # } # expected := [] int {- 1 , 1 , 0 } # # for index , data := range testCases { # if res := compareVersion ( data . version 1 , data . version 2 ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
emitter . error = yaml_WRITER_ERROR # emitter . problem = problem # return false
result , gap := 0 , 0 # found 1 := false # for N > 0 { # digit := N & 1 # N = N >> 1 # # if found 1 { # if digit == 1 { # result = int ( math . Max ( float 6 4 ( result ), float 6 4 ( gap + 1 ))) # gap = 0 # } else { # gap ++ # } # } else if digit == 1 { # found 1 = true # } # } # # return result
t . Run (" STR ", func ( t * testing . T ) { # got := searchInsert ([] int { 1 , 3 , 5 , 6 }, 5 ) # want := 2 # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # }) # # t . Run (" STR ", func ( t * testing . T ) { # got := searchInsert ([] int { 1 , 3 , 5 , 6 }, 2 ) # want := 1 # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # }) # # t . Run (" STR ", func ( t * testing . T ) { # got := searchInsert ([] int { 1 , 3 , 5 , 6 }, 7 ) # want := 4 # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # }) # # t . Run (" STR ", func ( t * testing . T ) { # got := searchInsert ([] int { 1 , 3 , 5 , 6 }, 0 ) # want := 0 # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # }) #
o := Constructor 4 () # expect := make ([] int , 0 ) # for idx , act := range actions { # if act == push { # o . Push ( vals [ idx ]) # continue # } # if act == pop { # o . Pop () # continue # } # # if act == top { # top := o . Top () # expect = append ( expect , top ) # continue # } # # m := o . GetMin () # expect = append ( expect , m ) # } # return expect
var tests = [] struct { # nums [] int # target int # position [] int # }{ # {[] int { 5 , 7 , 7 , 8 , 8 , 1 0 }, 8 , [] int { 3 , 4 }}, # {[] int { 5 , 7 , 7 , 8 , 8 , 1 0 }, 6 , [] int {- 1 , - 1 }}, # {[] int { 1 }, 1 , [] int { 0 , 0 }}, # {[] int {}, 0 , [] int {- 1 , - 1 }}, # } # # for _ , tt := range tests { # position := searchRange ( tt . nums , tt . target ) # if reflect . DeepEqual ( position , tt . position ) == false { # t . Errorf (" STR ", tt . nums , tt . target , position , tt . position ) # } # }
pointStack := make ([] int , 0 , len ( ops )) # # for i := range ops { # switch ops [ i ] { # case " STR ": # r 1 := pointStack [ len ( pointStack )- 1 ] # r 2 := pointStack [ len ( pointStack )- 2 ] # pointStack = append ( pointStack , r 1 + r 2 ) # case " STR ": # r 1 := pointStack [ len ( pointStack )- 1 ] # pointStack = append ( pointStack , 2 * r 1 ) # case " STR ": # pointStack = pointStack [: len ( pointStack )- 1 ] # default : # point , _ := strconv . Atoi ( ops [ i ]) # pointStack = append ( pointStack , point ) # } # } # # res := 0 # for _ , p := range pointStack { # res += p # } # return res
t . Parallel () # for _ , tc := range testcases { # if result := PerfectNth ( tc . n ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
cases := [] struct { # name string # inputs [] string # expect bool # }{ # {" STR ", [] string {" STR ", " STR "}, false }, # {" STR ", [] string {" STR ", " STR "}, true }, # {" STR ", [] string {" STR ", " STR "}, false }, # {" STR ", [] string {" STR ", " STR "}, true }, # {" STR ", [] string {" STR ", " STR "}, false }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := isMatch ( c . inputs [ 0 ], c . inputs [ 1 ]) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
if len ( arr ) <= 1 { # return # } # # if low < high { # pivot := partition ( arr , low , high ) # QuickSort ( arr , low , pivot - 1 ) # QuickSort ( arr , pivot + 1 , high ) # }
if root == nil { # return newNode ( val ) # } # if val < root . val { # root . left = insert ( root . left , val ) # } else { # root . right = insert ( root . right , val ) # } # return root
i := int ( 1 ) # return func () int { # i += 2 # return i # }
if n == nil { # return & Tree {} # } # return & Tree { Head : n , Size : 1 }
ret := make ([] int , len ( nums )) # left := 1 # right := 1 # for i := 0 ; i < len ( nums ); i ++ { # if i <= ( len ( nums )- 1 )/ 2 { # ret [ i ] = 1 # ret [ len ( nums )- i - 1 ] = 1 # } # ret [ len ( nums )- i - 1 ] *= right # ret [ i ] *= left # left *= nums [ i ] # right *= nums [ len ( nums )- i - 1 ] # } # return ret
return RandomizedCollection { # a : [] int {}, # idx : make ( map [ int ][] int ), # }
return n > 0 && ( 1 1 6 2 2 6 1 4 6 7 % n == 0 )
return uint 3 2 ( float 3 2 ( v ))
n := len ( words ) # ws := make ([] int , n ) # for i , w := range words { # ws [ i ] = f ( w ) # } # sort . Ints ( ws ) # # res := make ([] int , len ( queries )) # for i , q := range queries { # fq := f ( q ) # res [ i ] = n - sort . Search ( n , func ( i int ) bool { return fq < ws [ i ] }) # } # # return res
digit_fact [' 0 '] = 1 # digit_fact [' 1 '] = 1 # digit_fact [' 2 '] = 2 # fact := 2 # for i := 3 ; i < 1 0 ; i ++ { # digit_fact [ rune ( i + 4 8 )] = i * fact # fact = i * fact # }
res := [] int {} # m 1 := getInts ( a 1 ) # m 2 := getInts ( a 2 ) # # if len ( m 1 ) > len ( m 2 ) { # m 1 , m 2 = m 2 , m 1 # } # for n := range m 1 { # if m 2 [ n ] { # res = append ( res , n ) # } # } # # return res
n := len ( A ) # max , min := A [ 0 ], A [ 0 ] # for i := 1 ; i < n ; i ++ { # if A [ i ] > max { # max = A [ i ] # } else if A [ i ] < min { # min = A [ i ] # } # } # res := max - min - 2 * K # if res < 0 { # return 0 # } # return res
if a == 0 { # return b # } # if b == 0 { # return a # } # return getSum (( a & b )<< 1 , a ^ b )
if root == nil { # return 0 # } # left := maxDepth ( root . Left ) # right := maxDepth ( root . Right ) # # var max int # if left > right { # max = left # } else { # max = right # } # return max + 1
var tests = [] struct { # before [] interface {} # after * TreeNode # }{ # {[] interface {}{ 1 , nil , 0 , 0 , 1 }, newTree ( 1 , nil , 0 , nil , 1 )}, # {[] interface {}{ 1 , 0 , 1 , 0 , 0 , 0 , 1 }, newTree ( 1 , nil , 1 , nil , 1 )}, # {[] interface {}{ 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 }, newTree ( 1 , 1 , 0 , 1 , 1 , nil , 1 )}, # } # # for _ , tt := range tests { # after := pruneTree ( newTree ( tt . before ...)) # if reflect . DeepEqual ( after , tt . after ) == false { # t . Errorf (" STR ", newTree ( tt . before ...), after , tt . after ) # } # }
if 0 == num { # return " STR " # } # # ans := " STR " # neg := false # if num < 0 { # num = - num # neg = true # } # # for 0 != num { # ans = strconv . Itoa ( num % 7 ) + ans # num /= 7 # } # # if neg { # ans = " STR " + ans # } # # return ans
db := database {" STR ": 5 0 , " STR ": 5 } # log . Fatal ( http . ListenAndServe (" STR ", db ))
switch t . Kind () { # case Bool , Int , Int 8 , Int 1 6 , Int 3 2 , Int 6 4 , Uint , Uint 8 , Uint 1 6 , Uint 3 2 , Uint 6 4 , Uintptr : # return true # case Float 3 2 , Float 6 4 , Complex 6 4 , Complex 1 2 8 : # return true # case String : # return true # case UnsafePointer : # return true # case Chan : # return true # case Interface : # return true # case Ptr : # return true # case Slice : # return false # case Array : # return t . elem (). Comparable () # case Func : # return false # case Map : # return false # case Struct : # numField := t . NumField () # for i := 0 ; i < numField ; i ++ { # if ! t . rawField ( i ). Type . Comparable () { # return false # } # } # return true # default : # panic ( TypeError {" STR "}) # }
return minSquared ( n , 0 , n )
l := len ( s ) # if l <= numRows || numRows < 2 { # return s # } # ans , col := make ([] byte , 0 , l ), ( l - 1 )/( numRows - 1 ) # for r := 0 ; r < numRows ; r ++ { # for c := 0 ; c <= col ; c ++ { # if c & 1 == 0 || r > 0 && r < numRows - 1 { # k := ( numRows - 1 )*( c + c & 1 ) + r *( 1 - c & 1 * 2 ) # if k < l { # ans = append ( ans , s [ k ]) # } # } # } # } # return string ( ans )
expression := & ast . UnaryExpr { # OpPos : t . curPos , # Op : t . curToken , # } # t . Next () # x , err := parseConstExpr ( t , precedencePrefix ) # expression . X = x # return expression , err
factors := [] int {} # for n % 2 == 0 { # factors = append ( factors , 2 ) # n = n / 2 # } # for i := 3 ; i <= int ( math . Sqrt ( float 6 4 ( n ))); i += 2 { # for n % i == 0 { # factors = append ( factors , i ) # n = n / i # } # } # if n > 2 { # factors = append ( factors , n ) # } # return factors
w . WriteString (" STR ") # if register . Description != "" { # if isMultiline ( register . Description ) { # for _ , l := range splitLine ( register . Description ) { # w . WriteString (" STR ") # } # } else { # w . WriteString (" STR " + register . Description ) # } # } # w . WriteByte (" STR ") # for _ , bitfield := range register . Bitfields { # if bitfield . Description != "" { # for _ , l := range splitLine ( bitfield . Description ) { # w . WriteString (" STR ") # } # } # fmt . Fprintf ( w , " STR ", bitfield . Name , bitfield . Value ) # }
nn := [] int {} # if len ( nums ) <= 1 { # nn = nums # } else { # nn = append ( nn , nums [ 0 ]) # for i := 1 ; i < len ( nums ); i ++ { # nn = append ( nn , nums [ i ]+ nn [ i - 1 ]) # } # } # return NumArray { # nums : nn , # }
qs := [] question 1 0 5 2 { # # { # para 1 0 5 2 {[] int { 4 , 1 0 , 1 0 }, [] int { 1 , 1 , 0 }, 2 }, # ans 1 0 5 2 { 2 4 }, # }, # # { # para 1 0 5 2 {[] int { 1 }, [] int { 0 }, 1 }, # ans 1 0 5 2 { 1 }, # }, # # { # para 1 0 5 2 {[] int { 1 , 0 , 1 , 2 , 1 , 1 , 7 , 5 }, [] int { 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 }, 3 }, # ans 1 0 5 2 { 1 6 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 5 2 , q . para 1 0 5 2 # fmt . Printf (" STR ", p , maxSatisfied ( p . customers , p . grumpy , p . x )) # } # fmt . Printf (" STR ")
if len ( e ) <= 1 { # return len ( e ) # } # # sort . Sort ( sortedEnvelopes ( e )) # # var tails [] int # # for i := 0 ; i < len ( e ); i ++ { # lo , hi := 0 , len ( tails ) # for lo < hi { # mid := ( lo + hi ) / 2 # if e [ i ][ 1 ] <= tails [ mid ] { # hi = mid # } else { # lo = mid + 1 # } # } # # if lo == len ( tails ) { # tails = append ( tails , e [ i ][ 1 ]) # } else { # tails [ lo ] = e [ i ][ 1 ] # } # } # # return len ( tails )
inf := 1 . 0 # inf /= 0 . 0 # # return uint 3 2 ( inf ), uint 3 2 (- inf ), int 3 2 ( inf ), int 3 2 (- inf )
var reversed * SinglyLL # # for head != nil { # next := head . Next # head . Next = reversed # reversed = head # head = next # } # # return reversed
maxVal = arr [ 0 ] # for i := 1 ; i <= len ( arr )- 1 ; i ++ { # if arr [ i ] > maxVal { # maxVal = arr [ i ] # } # } # return maxVal
err := NotFoundError { # Name : " STR ", # Err : errors . New (" STR "), # } # return err
valuesMap := map [ rune ] int { # ' 2 ': 1 , # ' 3 ': 2 , # ' 4 ': 3 , # ' 5 ': 4 , # ' 6 ': 5 , # ' 7 ': 6 , # ' 8 ': 7 , # ' 9 ': 8 , # ' T ': 9 , # ' J ': 1 0 , # ' Q ': 1 1 , # ' K ': 1 2 , # ' A ': 1 3 , # } # tokens := [] rune ( token ) # return & Card { tokens [ 0 ], tokens [ 1 ], valuesMap [ tokens [ 0 ]]}
r := recover () # if r != nil { # b := make ([] byte , 3 2 7 6 8 ) # runtime . Stack ( b , true ) # fmt . Fprintf ( w , " STR ", time . Now (). UTC (). Format (" STR "), r ) # fmt . Fprintf ( w , " STR ", string ( b )) # os . Exit ( 1 ) # }
positions := make ( map [ string ] Position ) # for _ , rule := range rules { # parts := strings . Split ( rule , " STR ") # to , dir , from := parts [ 0 ], Direction ( parts [ 1 ]), parts [ 2 ] # toPos , toFound := positions [ to ] # fromPos , fromFound := positions [ from ] # delta := directions [ dir ] # switch { # case toFound && fromFound : # if ! checkValid ( fromPos , toPos , dir ) { # return false # } # case toFound && ! fromFound : # positions [ from ] = Position { toPos . X - delta . X , toPos . Y - delta . Y } # case ! toFound && fromFound : # positions [ to ] = Position { fromPos . X + delta . X , fromPos . Y + delta . Y } # default : # positions [ from ] = Position { 0 , 0 } # positions [ to ] = directions [ dir ] # } # } # return true
reverse := func ( nums [] int , start , end int ) { # for start < end { # nums [ start ], nums [ end ] = nums [ end ], nums [ start ] # start , end = start + 1 , end - 1 # } # } # # k = k % len ( nums ) # reverse ( nums , 0 , len ( nums )- k - 1 ) # reverse ( nums , len ( nums )- k , len ( nums )- 1 ) # reverse ( nums , 0 , len ( nums )- 1 )
counts := [ 4 0 0 0 1 ] int {} # max := 0 # # for _ , n := range A { # counts [ n ]++ # if max < n { # max = n # } # } # # res := 0 # # for n := 0 ; n < max ; n ++ { # if counts [ n ] <= 1 { # continue # } # redundance := counts [ n ] - 1 # res += redundance # counts [ n + 1 ] += redundance # } # # redundance := counts [ max ] - 1 # res += ( redundance + 1 ) * redundance / 2 # # return res
node 2 := TreeNode { Val : 2 , Left : nil , Right : nil } # node 4 := TreeNode { Val : 4 , Left : nil , Right : nil } # node 7 := TreeNode { Val : 7 , Left : nil , Right : nil } # node 3 := TreeNode { Val : 3 , Left : & node 2 , Right : & node 4 } # node 6 := TreeNode { Val : 2 , Left : nil , Right : & node 7 } # node 5 := TreeNode { Val : 5 , Left : & node 3 , Right : & node 6 } # # fmt . Println ( findTarget (& node 5 , 9 ))
var tests = [] struct { # l 1 , l 2 [] int # l * ListNode # }{ # { # [] int { 1 , 2 , 4 }, [] int { 1 , 3 , 4 }, # newList ( 1 , 1 , 2 , 3 , 4 , 4 ), # }, # { # [] int { 1 , 2 , 3 }, [] int { 4 , 5 , 6 }, # newList ( 1 , 2 , 3 , 4 , 5 , 6 ), # }, # { # [] int { 2 , 4 , 6 }, [] int { 1 , 3 , 5 }, # newList ( 1 , 2 , 3 , 4 , 5 , 6 ), # }, # } # # for _ , tt := range tests { # l := mergeTwoLists ( newList ( tt . l 1 ...), newList ( tt . l 2 ...)) # if reflect . DeepEqual ( l , tt . l ) == false { # t . Errorf (" STR ", newList ( tt . l 1 ...), newList ( tt . l 2 ...), l , tt . l ) # } # }
res := [] int { 1 } # for len ( res ) < N { # tmp := make ([] int , 0 , len ( res )* 2 ) # for _ , v := range res { # if v * 2 - 1 <= N { # tmp = append ( tmp , v * 2 - 1 ) # } # } # for _ , v := range res { # if v * 2 <= N { # tmp = append ( tmp , v * 2 ) # } # } # res = tmp # } # # return res
fmt . Println (" STR ") # fmt . Println ( seekUsingAPI ()) # fmt . Println ( seekManually ())
delete ( st . elements , value )
maxSizeLog := log 2 Ceil ( maxSize ) # tp . maxSize = ( 1 << maxSizeLog ) - 1 # if tp . maxSize <= 0 { # tp . maxSize = math . MaxInt 3 2 # maxSizeLog = log 2 Ceil ( math . MaxInt 3 2 ) # } # tp . list_of_pools = make ([] pool , maxSizeLog + 1 ) # if drainPeriod > 0 { # tp . drainTicker = time . NewTicker ( drainPeriod ) # go func () { # for _ = range tp . drainTicker . C { # tp . Drain () # } # }() # }
tests := [...] testType { # { # str 1 : " STR ", # str 2 : " STR ", # want : " STR ", # }, # { # str 1 : " STR ", # str 2 : " STR ", # want : " STR ", # }, # { # str 1 : " STR ", # str 2 : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := gcdOfStrings ( tt . str 1 , tt . str 2 ) # if got != tt . want { # t . Fatalf (" STR ", tt . str 1 , got , tt . want ) # } # }
m := make ( map [ string ][] string , len ( path )* 2 ) # for i := 0 ; i < len ( path ); i ++ { # analyze ( path [ i ], m ) # } # # res := make ([][] string , 0 , len ( m )) # for _ , files := range m { # if len ( files ) > 1 { # res = append ( res , files ) # } # } # # return res
res := make ([][] int , 0 , len ( people )) # # sort . Sort ( persons ( people )) # # insert := func ( idx int , person [] int ) { # res = append ( res , person ) # if len ( res )- 1 == idx { # return # } # copy ( res [ idx + 1 :], res [ idx :]) # res [ idx ] = person # } # # for _ , p := range people { # insert ( p [ 1 ], p ) # } # # return res
qs := [] question 5 0 { # # { # para 5 0 { 2 . 0 0 0 0 0 , 1 0 }, # ans 5 0 { 1 0 2 4 . 0 0 0 0 0 }, # }, # # { # para 5 0 { 2 . 1 0 0 0 0 , 3 }, # ans 5 0 { 9 . 2 6 1 0 0 }, # }, # # { # para 5 0 { 2 . 0 0 0 0 0 , - 2 }, # ans 5 0 { 0 . 2 5 0 0 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 0 , q . para 5 0 # fmt . Printf (" STR ", p , myPow ( p . x , p . n )) # } # fmt . Printf (" STR ")
cases := [] struct { # name string # inputs * TreeNode # expect bool # }{ # {" STR ", & TreeNode { 3 , & TreeNode { Val : 9 }, & TreeNode { 2 0 , & TreeNode { Val : 1 5 }, & TreeNode { Val : 7 }}}, true }, # {" STR ", & TreeNode { 1 , & TreeNode { 2 , & TreeNode { 3 , & TreeNode { Val : 4 }, & TreeNode { Val : 4 }}, & TreeNode { Val : 3 }}, & TreeNode { Val : 2 }}, false }, # {" STR ", & TreeNode {}, true }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
n := len ( envelopes ) # if n < 2 { # return n # } # # sort . Slice ( envelopes , func ( i , j int ) bool { # if envelopes [ i ][ 0 ] == envelopes [ j ][ 0 ] { # return envelopes [ i ][ 1 ] > envelopes [ j ][ 1 ] # } # return envelopes [ i ][ 0 ] < envelopes [ j ][ 0 ] # }) # # dp := make ([] int , n ) # res := 1 # for i , envelope := range envelopes { # index := sort . Search ( res , func ( idx int ) bool { # return envelopes [ dp [ idx ]][ 1 ] >= envelope [ 1 ] # }) # dp [ index ] = i # if index >= res { # res ++ # } # } # return res
return & orderLogSlice { log : make ([] interface {}, size ), pos : - 1 , size : size }
fmt . Println ( strconv . Itoa ( 1 )) # fmt . Println ( strings . Compare (" STR ", " STR ")) # fmt . Println ( math . Abs ( 1 . 0 )) # fmt . Println ( unicode . IsDigit (' 1 ')) # fmt . Println ( sort . IsSorted ( nil ))
var i , num int # sign := 1 # if str == "" { # return 0 # } # for i < len ( str ) && str [ i ] == 3 2 { # i ++ # } # # if i >= len ( str ) { # return 0 # } # # if str [ i ] == 4 3 { # i ++ # } else if str [ i ] == 4 5 { # sign = - 1 # i ++ # } # for ; i < len ( str ); i ++ { # if str [ i ] != 0 && ( str [ i ] < 4 8 || str [ i ] > 5 7 ) { # return num * sign # } # n , _ := strconv . Atoi ( string ( str [ i ])) # num = num * 1 0 + n # if num * sign < math . MinInt 3 2 { # return math . MinInt 3 2 # } else if num * sign > math . MaxInt 3 2 { # return math . MaxInt 3 2 # } # } # return num * sign
for ; V > 0 ; V -- { # drop := true # for d := - 1 ; d <= 1 ; d += 2 { # i , best := K , K # for i + d >= 0 && i + d < len ( heights ) && heights [ i + d ] <= heights [ i ] { # if heights [ i + d ] < heights [ i ] { # best = i + d # } # i += d # } # if heights [ best ] < heights [ K ] { # heights [ best ]++ # drop = false # break # } # } # if drop { # heights [ K ]++ # } # } # return heights
if root == nil { # return nil # } # if val < root . val { # root . left = BstDelete ( root . left , val ) # } else if val > root . val { # root . right = BstDelete ( root . right , val ) # } else { # if root . left == nil { # return root . right # } else if root . right == nil { # return root . left # } else { # n := root . right # d := InOrderSuccessor ( n ) # d . left = root . left # return root . right # } # } # return root
dist := math . MaxInt 3 2 # ret := 0 # if len ( nums ) < 3 { # return 0 # } # sort . Ints ( nums ) # l := len ( nums ) # for i := 0 ; i < l - 2 ; i ++ { # if i > 0 && nums [ i ] == nums [ i - 1 ] { # continue # } # begin , end := i + 1 , l - 1 # for begin < end { # sum := nums [ begin ] + nums [ end ] + nums [ i ] # if sum < target { # if target - sum < dist { # dist = target - sum # ret = sum # } # begin ++ # } else if sum > target { # if sum - target < dist { # dist = sum - target # ret = sum # } # end -- # } else { # return sum # } # } # } # return ret
t . Parallel () # for _ , tc := range testcases { # if result := PairsPalindromes ( tc . words ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
var ans int # for i := 2 ; i < n ; i ++ { # if isPrime ( i ) { # ans ++ # } # # } # return ans
res := 0 # var maxDepth func (* TreeNode ) int # maxDepth = func ( node * TreeNode ) int { # if node == nil { # return 0 # } # l , r := maxDepth ( node . Left ), maxDepth ( node . Right ) # res = max ( res , l + r ) # return max ( l , r ) + 1 # } # maxDepth ( root ) # return res
num := [ 2 0 0 ] int {} # num [ 0 ] = 1 # for i := 2 ; i <= N ; i ++ { # for a := 0 ; a < len ( num ); a ++ { # num [ a ] *= i # if a > 0 && num [ a - 1 ] > 9 { # num [ a ] += int ( num [ a - 1 ] / 1 0 ) # num [ a - 1 ] %= 1 0 # } # } # } # sum := 0 # for i := 0 ; i < len ( num ); i ++ { # sum += num [ i ] # } # println ( sum )
t . Parallel () # fewestTurns := SnakesAndLaddersFewestTurns ( # [] Jump {{ 1 , 3 8 }, { 4 , 1 4 }, { 9 , 3 1 }, { 2 1 , 4 2 }, { 2 8 , 8 4 }, { 3 6 , 4 4 }, { 5 1 , 6 7 }, { 7 1 , 9 1 }, { 8 0 , 1 0 0 }}, # [] Jump {{ 1 6 , 6 }, { 4 8 , 2 6 }, { 4 9 , 1 1 }, { 5 6 , 5 3 }, { 6 2 , 1 9 }, { 6 4 , 6 0 }, { 8 7 , 2 4 }, { 9 3 , 7 3 }, { 9 5 , 7 5 }, { 9 8 , 7 8 }}, # 6 , # ) # if fewestTurns != 7 { # t . Errorf (" STR ", fewestTurns ) # }
fmt . Printf (" STR ", summaryRanges ([] int { 0 , 1 , 2 , 4 , 5 , 7 }))
if nil == head { # return true # } # # if nil == h { # h = head # } # flag := true # if nil != head . Next { # flag = flag && isPalindrome ( head . Next ) # } # # flag = flag && ( h . Val == head . Val ) # h = h . Next # return flag
n , prev , c := len ( arr ), arr [ 0 ], 0 # for _ , val := range arr { # if val == prev { # c ++ # if c > n / 4 { # return prev # } # } else { # prev = val # c = 1 # } # } # return 0
var s string # for _ , row := range g { # for _ , col := range row { # s += fmt . Sprintf (" STR ", col ) # } # s += " STR " # } # return s
idx := 0 # for i := 0 ; i < len ( letters ); i ++ { # if letters [ i ] > target { # idx = i # break # } # } # return letters [ idx ]
n := len ( s ) # if n <= 3 { # return s # } # return comma ( s [: n - 3 ]) + " STR " + s [ n - 3 :]
str := [] byte ( s ) # if len ( str ) <= 1 { # return false # } # max := len ( str ) / 2 # for i := 1 ; i <= max ; i ++ { # j := i # idx := 0 # if len ( str )% i > 0 { # continue # } # for ; j < len ( str ); j ++ { # if str [ j ] != str [ idx ] { # break # } # idx ++ # if idx >= i { # idx = 0 # } # } # # if j == len ( str ) { # return true # } # } # return false
if n < 2 { # return n # } # trib , prev , prev 2 := 1 , 1 , 0 # for n > 2 { # trib , prev , prev 2 = trib + prev + prev 2 , trib , prev # n -- # } # return trib
n := len ( nums ) # if n < 2 { # return n # } # k := 0 # for k < n - 1 && nums [ k ] == nums [ k + 1 ] { # k ++ # } # if k == n - 1 { # return 1 # } # res := 2 # small := nums [ k ] < nums [ k + 1 ] # for i := k + 1 ; i < n - 1 ; i ++ { # if ( small && nums [ i + 1 ] < nums [ i ]) || # (! small && nums [ i + 1 ] > nums [ i ]) { # nums [ res ] = nums [ i + 1 ] # res ++ # small = ! small # } # } # return res
qs := [] question 7 2 4 { # # { # para 7 2 4 {[] int { 1 , 7 , 3 , 6 , 5 , 6 }}, # ans 7 2 4 { 3 }, # }, # # { # para 7 2 4 {[] int { 1 , 2 , 3 }}, # ans 7 2 4 {- 1 }, # }, # # { # para 7 2 4 {[] int {- 1 , - 1 , - 1 , - 1 , - 1 , - 1 }}, # ans 7 2 4 {- 1 }, # }, # # { # para 7 2 4 {[] int {- 1 , - 1 , - 1 , - 1 , - 1 , 0 }}, # ans 7 2 4 { 2 }, # }, # # { # para 7 2 4 {[] int { 1 }}, # ans 7 2 4 { 0 }, # }, # # { # para 7 2 4 {[] int {}}, # ans 7 2 4 {- 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 2 4 , q . para 7 2 4 # fmt . Printf (" STR ", p , pivotIndex ( p . nums )) # } # fmt . Printf (" STR ")
m . buckets = buckets # m . cache = make ([]* LRUCache , buckets ) # for i := uint ( 0 ); i < buckets ; i ++ { # m . cache [ i ] = NewLRUCache ( bucket_capacity ) # }
input := bufio . NewScanner ( f ) # for input . Scan () { # counts [ input . Text ()]++ # }
c := & VariableAccess { Name : " STR "} # scope := & BasicScope { # VarMap : map [ string ] Variable { # " STR ": Variable { Type : TypeString }, # }, # } # # actual , err := c . Type ( scope ) # if err != nil { # t . Fatalf (" STR ", err ) # } # if actual != TypeString { # t . Fatalf (" STR ", actual ) # }
var max , left int # count := [ 1 2 8 ] int {} # # for right := 0 ; right < len ( s ); right ++ { # count [ s [ right ]]++ # max = Max ( max , count [ s [ right ]]) # # # if right - left + 1 - max > k { # count [ s [ left ]]-- # left ++ # } # } # # return len ( s ) - left #
s := " STR " # p := " STR " # # fmt . Println ( findAnagrams ( s , p )) # # s 1 := " STR " # p 1 := " STR " # fmt . Println ( findAnagrams ( s 1 , p 1 )) # # s 2 := " STR " # p 2 := " STR " # fmt . Println ( findAnagrams ( s 2 , p 2 ))
fmt . Println ( surfaceArea ([][] int {[] int { 2 }})) # fmt . Println ( surfaceArea ([][] int {[] int { 1 , 2 }, [] int { 3 , 4 }}))
testData := [][] int { # {}, # { 3 , 4 , 6 7 , 8 }, # } # expectedData := [] int { 0 , 6 7 } # # for index , data := range testData { # if res := CalcMaxInt ( data ...); res != expectedData [ index ] { # t . Errorf (" STR ", expectedData [ index ], res ) # } # }
node 3 := TreeNode { Val : 3 , Left : nil , Right : nil } # node 5 := TreeNode { Val : 5 , Left : & node 3 , Right : nil } # node 1 := TreeNode { Val : 1 , Left : nil , Right : & node 5 } # # fmt . Println ( getMinimumDifference (& node 1 )) #
d 1 2 , d 1 3 , d 1 4 := d ( p 1 , p 2 ), d ( p 1 , p 3 ), d ( p 1 , p 4 ) # d 2 3 , d 2 4 := d ( p 2 , p 3 ), d ( p 2 , p 4 ) # d 3 4 := d ( p 3 , p 4 ) # if d 1 2 == d 1 3 { # return d 1 2 != 0 && d 1 4 == d 2 3 && d 2 4 == d 3 4 && d 1 2 == d 2 4 # } # if d 1 2 == d 1 4 { # return d 1 2 != 0 && d 1 3 == d 2 4 && d 2 3 == d 3 4 && d 1 2 == d 2 3 # } # if d 1 3 == d 1 4 { # return d 1 3 != 0 && d 1 2 == d 3 4 && d 2 3 == d 2 4 && d 1 3 == d 2 3 # } # return false
if N == 1 { # return 1 0 # } # # res := 0 # for i := 0 ; i < 1 0 ; i ++ { # res += recur ( N - 1 , i , & rec ) # } # # return res % mod
t . Parallel () # for _ , tc := range testcases { # if result := TopKMostSimilarPairs ( tc . visits , tc . k ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
result := make ([][] int , len ( A [ 0 ])) # for i := 0 ; i < len ( result ); i ++ { # result [ i ] = make ([] int , len ( A )) # } # # for i , row := range A { # for j , num := range row { # result [ j ][ i ] = num # } # } # # return result
if len ( arr ) == 0 || len ( arr ) == 1 { # return # } # axis , pos := arr [ 0 ], len ( arr )- 1 # for i := pos ; i >= 1 ; i -- { # if arr [ i ] > axis { # arr [ i ], arr [ pos ] = arr [ pos ], arr [ i ] # pos -- # } # } # arr [ 0 ], arr [ pos ] = arr [ pos ], arr [ 0 ] # qs ( arr [: pos ]) # qs ( arr [ pos + 1 :])
size := len ( A ) # # if size < 3 { # return false # } # # i := 1 # for i < size && A [ i - 1 ] < A [ i ] { # i ++ # } # # top := i - 1 # # for i < size && A [ i - 1 ] > A [ i ] { # i ++ # } # # return 0 < top && top < size - 1 && i == size
if len ( nums ) == 0 { # return - 1 # } # if len ( nums ) == 1 { # return 0 # } # max , sec := math . MinInt 3 2 , math . MinInt 3 2 # p := - 1 # for i := 0 ; i < len ( nums ); i ++ { # if nums [ i ] > max { # sec = max # max = nums [ i ] # p = i # } else if nums [ i ] > sec { # sec = nums [ i ] # } # } # if max > 2 * sec { # return p # } # return - 1
if oldColor := image [ sr ][ sc ]; oldColor != newColor { # dfs ( image , sr , sc , oldColor , newColor ) # } # return image
var tests = [] struct { # num 1 , num 2 string # sum string # }{ # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # } # # for _ , tt := range tests { # sum := addStrings ( tt . num 1 , tt . num 2 ) # if sum != tt . sum { # t . Errorf (" STR ", tt . num 1 , tt . num 2 , sum , tt . sum ) # } # }
cases := [] struct { # name string # input 1 string # input 2 string # expect int # }{ # {" STR ", " STR ", " STR ", 3 }, # {" STR ", " STR ", " STR ", 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := numJewelsInStones ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 , c . input 1 ) # } # }) # }
nums := [] int {- 2 , 0 , 3 , - 5 , 2 , - 1 } # ranges := [][] int { # { 0 , 2 }, # { 2 , 5 }, # { 0 , 5 }, # } # # expected := [] int { 1 , - 1 , - 3 } # # obj := Constructor ( nums ) # # for index , section := range ranges { # if res := obj . SumRange ( section [ 0 ], section [ 1 ]); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
hs := MinHeap ( nums ) # n := len ( hs ) # heap := & hs # for i := n / 2 - 1 ; i >= 0 ; i -- { # heap . down ( i , n ) # } # return heap
if 1 == digits { # return 1 0 # } # return int ( 9 * math . Pow 1 0 ( digits - 1 ))
cases := [] struct { # name string # input 1 string # input 2 string # expect int # }{ # {" STR ", " STR ", " STR ", 3 }, # {" STR ", " STR ", " STR ", 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := numJewelsInStones 2 ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 , c . input 1 ) # } # }) # }
t . Parallel () # for tcid , tc := range testcases { # tree := copyTree ( tc . input ) # if result := ConvertBinaryTreeToFull ( tree ); ! equalTree ( result , tc . expected ) { # t . Errorf (" STR ", tcid ) # } # }
tests := [...] testType { # { # in : [] int { 1 , 2 , 3 , 4 }, # want : " STR ", # }, # { # in : [] int { 5 , 5 , 5 , 5 }, # want : " STR ", # }, # { # in : [] int { 2 , 0 , 6 , 6 }, # want : " STR ", # }, # } # for _ , tt := range tests { # got := largestTimeFromDigits ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
ak , ajStack := - 1 << 3 1 , make ([] int , 0 , len ( nums )) # for i := len ( nums ) - 1 ; 0 <= i ; i -- { # if nums [ i ] < ak { # return true # } # for len ( ajStack ) > 0 && ajStack [ len ( ajStack )- 1 ] < nums [ i ] { # ak = ajStack [ len ( ajStack )- 1 ] # ajStack = ajStack [: len ( ajStack )- 1 ] # } # ajStack = append ( ajStack , nums [ i ]) # } # return false
var r strings . Builder # for key , val := range res . occurrences { # r . WriteString ( fmt . Sprintf (" STR ", key )) # for i := range val { # r . WriteString ( fmt . Sprintf (" STR ", val [ i ])) # if i != len ( val )- 1 { # r . WriteString (" STR ") # } # } # r . WriteString (" STR ") # } # return r . String ()
if head == nil { # return nil # } # # l := & ListNode { Next : head } # for prev , p := head , head . Next ; p != nil ; p = p . Next { # if prev . Val <= p . Val { # prev = p # continue # } # # q := l # for q . Next . Val < p . Val { # q = q . Next # } # prev . Next = p . Next # p . Next = q . Next # q . Next = p # p = prev # } # return l . Next
m := map [ int ] int {} # var res [] int # for _ , n := range nums 1 { # m [ n ]++ # } # for _ , n := range nums 2 { # if m [ n ] > 0 { # res = append ( res , n ) # m [ n ]-- # } # } # return res
if t 1 == nil { # return copyTree ( t 2 ) # } # if t 2 == nil { # return copyTree ( t 1 ) # } # # return & TreeNode { # Val : t 1 . Val + t 2 . Val , # Left : mergeTrees ( t 1 . Left , t 2 . Left ), # Right : mergeTrees ( t 1 . Right , t 2 . Right ), # }
type Server struct { # Name string # ID int 3 2 # Enabled bool # } # # s := & Server { # Name : " STR ", # ID : 1 3 5 7 9 0 , # Enabled : false , # } # # m := Values ( s ) # # fmt . Printf (" STR ", m )
sign := 1 # # if x < 0 { # sign = - 1 # x = - 1 * x # } # # res := 0 # for x > 0 { # tmp := x % 1 0 # res = res * 1 0 + tmp # x = x / 1 0 # } # res = sign * res # # if res > math . MaxInt 3 2 || res < math . MinInt 3 2 { # res = 0 # } # return res
lru := New ( int 6 4 ( 0 ), nil ) # lru . Add (" STR ", String (" STR ")) # if v , ok := lru . Get (" STR "); ! ok || string ( v .( String )) != " STR " { # t . Fatalf (" STR ") # } # if _ , ok := lru . Get (" STR "); ok { # t . Fatalf (" STR ") # }
if root == nil { # return [][] int {} # } # stack := []* TreeNode { root } # rets := [][] int {} # zigzag := false # for len ( stack ) != 0 { # tmpStack := []* TreeNode {} # ret := [] int {} # for i := range stack { # if zigzag { # ret = append ( ret , stack [ len ( stack )- i - 1 ]. Val ) # } else { # ret = append ( ret , stack [ i ]. Val ) # } # if stack [ i ]. Left != nil { # tmpStack = append ( tmpStack , stack [ i ]. Left ) # } # if stack [ i ]. Right != nil { # tmpStack = append ( tmpStack , stack [ i ]. Right ) # } # } # zigzag = ! zigzag # rets = append ( rets , ret ) # stack = tmpStack # } # return rets
trie . root = & Node { children : map [ int 3 2 ]* Node {}}
ret := [] int { 0 , 1 } # if n < 2 { # return ret [: n + 1 ] # } # base := 2 # n -- # for n > 0 { # for i := len ( ret )- 1 ; i >= 0 ; i --{ # ret = append ( ret , ret [ i ]+ base ) # } # base *= 2 # n -- # } # return ret
var sb strings . Builder # move := func ( x 1 , y 1 , x 2 , y 2 int ) { # for y 1 > y 2 { # y 1 -- # sb . WriteByte (' L ') # } # for x 1 > x 2 { # x 1 -- # sb . WriteByte (' U ') # } # for x 1 < x 2 { # x 1 ++ # sb . WriteByte (' D ') # } # for y 1 < y 2 { # y 1 ++ # sb . WriteByte (' R ') # } # return # } # # x 1 , y 1 := 0 , 0 # for _ , r := range target { # x 2 , y 2 := coordinate ( r ) # move ( x 1 , y 1 , x 2 , y 2 ) # sb . WriteByte ('!') # x 1 , y 1 = x 2 , y 2 # } # return sb . String ()
tests := [...] testType { # { # haystack : " STR ", # needle : " STR ", # want : 2 , # }, { # haystack : " STR ", # needle : " STR ", # want : - 1 , # }, # } # # for _ , tt := range tests { # got := strStr ( tt . haystack , tt . needle ) # if got != tt . want { # t . Fatalf (" STR ", tt . haystack , tt . needle , got , tt . want ) # } # }
_ , combinations := getFactorCombination ( n , 2 , make ([] int , 0 ), make ([][] int , 0 )) # return combinations
if ldc . seq 0 [ i ] != ldc . seq 1 [ j ] { # return ldc . cost [ i - 1 ][ j - 1 ] + r . cost # } # return math . MaxInt 3 2
start , remain , debt := 0 , 0 , 0 # for i := 0 ; i < len ( gas ); i ++ { # # remain += gas [ i ] - cost [ i ] # if remain < 0 { # debt += remain # start = i + 1 # remain = 0 # } # } # if remain + debt >= 0 { # return start # } # return - 1
return t . Align ()
size := len ( nums ) # if k %= size ; k > 0 && k < size { # rotateArray ( nums [: size - k ]) # rotateArray ( nums [ size - k :]) # rotateArray ( nums ) # }
for len ( y ) <= len ( x ) { # if len ( y ) == 0 { # return true # } # if x [ 0 ] == y [ 0 ] { # y = y [ 1 :] # } # x = x [ 1 :] # } # return false
for i := 0 ; i < b . N ; i ++ { # Average ( 7 , 8 , 1 0 ) # }
res := [][] int {} # temp := make ([] int , k + 1 ) # used := make ([] bool , 1 0 ) # # var dfs func ( int , int ) # dfs = func ( idx , remain int ) { # if idx == k { # if remain < 1 0 && ! used [ remain ] { # temp [ idx ] = remain # t := make ([] int , k ) # copy ( t , temp [ 1 :]) # res = append ( res , t ) # } # return # } # # for i := temp [ idx - 1 ] + 1 ; i < 1 0 ; i ++ { # if remain - i < i { # return # } # used [ i ] = true # temp [ idx ] = i # dfs ( idx + 1 , remain - i ) # used [ i ] = false # } # } # # dfs ( 1 , n ) # # return res
sum := 0 # for _ , v := range nums { # sum += v # } # result := float 6 4 ( sum ) / float 6 4 ( len ( nums )) # pow := math . Pow ( 1 0 , float 6 4 ( 2 )) # digit := pow * result # round := math . Floor ( digit ) # return round / pow #
for tx >= sx && ty >= sy { # if tx > ty { # if sy == ty { # return ( tx - sx )% ty == 0 # } # tx %= ty # } else { # if sx == tx { # return ( ty - sy )% tx == 0 # } # ty %= tx # } # } # return false
xs := src . Bounds (). Size (). X # ys := src . Bounds (). Size (). Y # width , height := 1 2 8 , 1 2 8 # if aspect := float 6 4 ( xs ) / float 6 4 ( ys ); aspect < 1 . 0 { # width = int ( 1 2 8 * aspect ) # } else { # height = int ( 1 2 8 / aspect ) # } # xscale := float 6 4 ( xs ) / float 6 4 ( width ) # yscale := float 6 4 ( ys ) / float 6 4 ( height ) # # dst := image . NewRGBA ( image . Rect ( 0 , 0 , width , height )) # # for x := 0 ; x < width ; x ++ { # for y := 0 ; y < height ; y ++ { # srcx := int ( float 6 4 ( x ) * xscale ) # srcy := int ( float 6 4 ( y ) * yscale ) # dst . Set ( x , y , src . At ( srcx , srcy )) # } # } # return dst
n := len ( nums ) # if n == 1 { # return 0 # } # max , maxIndex := - 1 , - 1 # for i , num := range nums { # if num > max { # max , maxIndex = num , i # } # } # for _ , num := range nums { # if num != max && 2 * num > max { # return - 1 # } # } # return maxIndex
qs := [] question 6 7 { # # { # para 6 7 {" STR ", " STR "}, # ans 6 7 {" STR "}, # }, # # { # para 6 7 {" STR ", " STR "}, # ans 6 7 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 7 , q . para 6 7 # fmt . Printf (" STR ", p , addBinary ( p . a , p . b )) # } # fmt . Printf (" STR ")
distribute , _ , _ := helper 9 7 9 ( root ) # return distribute
result := make ([][] int , 0 ) # if numRows <= 0 { # return result # } # # result = append ( result , [] int { 1 }) # for i := 1 ; i < numRows ; i ++ { # row := [] int { 1 } # for j := 1 ; j < i ; j ++ { # row = append ( row , result [ i - 1 ][ j - 1 ]+ result [ i - 1 ][ j ]) # } # # row = append ( row , 1 ) # result = append ( result , row ) # } # # return result
output := make ([] string , 0 ) # for k , v := range CLASS_ACCESS_FLAGS { # if flags & k != 0 { # output = append ( output , v ) # } # } # return strings . Join ( output , " STR ")
return real ( x )
if e . element . list != & b . lruList { # panic (" STR ") # } # # if e . index != - 1 { # heap . Remove (& b . priorityQueue , e . index ) # } # b . lruList . Remove (& e . element ) # b . freeList . PushElementFront (& e . element ) # delete ( b . table , e . key ) # e . key = "" # e . value = nil
if len ( matrix ) == 0 { # return false # } # n , m := len ( matrix ), len ( matrix [ 0 ]) # l , r := 0 , n * m - 1 # # for l < r { # mid := ( l + r ) / 2 # if matrix [ mid / m ][ mid % m ] >= target { # r = mid # } else { # l = mid + 1 # } # } # return matrix [ r / m ][ r % m ] == target
if len ( s ) < 1 0 { # return nil # } # charMap , mp , result := map [ uint 8 ] uint 3 2 {' A ': 0 , ' C ': 1 , ' G ': 2 , ' T ': 3 }, make ( map [ uint 3 2 ] int , 0 ), [] string {} # var cur uint 3 2 # for i := 0 ; i < 9 ; i ++ { # cur = cur << 2 | charMap [ s [ i ]] # } # for i := 9 ; i < len ( s ); i ++ { # cur = (( cur << 2 ) & 0 xFFFFF ) | charMap [ s [ i ]] # if mp [ cur ] == 0 { # mp [ cur ] = 1 # } else if mp [ cur ] == 1 { # mp [ cur ] = 2 # result = append ( result , s [ i - 9 : i + 1 ]) # } # } # return result
n := len ( A ) # sums := make ([] int , n ) # s := 0 # for i := 0 ; i < n ; i ++ { # s += A [ i ] # sums [ i ] = s # } # if s % 3 != 0 { # return false # } # # s /= 3 # i := 0 # for i < n && sums [ i ] != s { # i ++ # } # # s *= 2 # j := n - 1 # for 0 <= j && sums [ j ] != s { # j -- # } # # return i < j
if head == nil || head . Next == nil { # return head # } # secHead := split ( head ) # return merge ( sortList ( head ), sortList ( secHead ))
var subtrees []* TreeNode # cnt := make ( map [ string ] int ) # # var f func (* TreeNode ) string # f = func ( root * TreeNode ) string { # if root == nil { # return " STR " # } # # str := strconv . Itoa ( root . Val ) + " STR " + f ( root . Left ) + " STR " + f ( root . Right ) # # cnt [ str ]++ # if cnt [ str ] == 2 { # subtrees = append ( subtrees , root ) # } # return str # } # f ( root ) # # return subtrees
s := strings . Join ( source , " STR ") + " STR " # s = helper ( s ) # source = split ( s ) # return source
min , max := A [ 0 ], A [ 0 ] # for _ , v := range A { # if min > v { # min = v # } # # if max < v { # max = v # } # } # # return int ( math . Max ( 0 , float 6 4 ( max - min - 2 * K )))
if len ( this . enqueue ) == 0 && len ( this . dequeue ) == 0 { # return true # } # return false
res := 0 # n := len ( nums ) # # for j := 0 ; j < 3 2 ; j ++ { # k := 0 # for i := 0 ; i < n ; i ++ { # k += ( nums [ i ] >> uint ( j )) & 1 # } # res += k * ( n - k ) # } # # return res
if len ( S ) == 0 { # return [] string {} # } # res , pos , c := [] string {}, [] int {}, [] int {} # SS := strings . ToLower ( S ) # for i := 0 ; i < len ( SS ); i ++ { # if isLowerLetter ( SS [ i ]) { # pos = append ( pos , i ) # } # } # for i := 0 ; i <= len ( pos ); i ++ { # findLetterCasePermutation ( SS , pos , i , 0 , c , & res ) # } # return res
var tests = [] struct { # head * ListNode # G [] int # num int # }{ # { newList ( 0 , 1 , 2 , 3 ), [] int { 0 , 1 , 3 }, 2 }, # { newList ( 0 , 1 , 2 , 3 , 4 ), [] int { 0 , 3 , 1 , 4 }, 2 }, # } # # for _ , tt := range tests { # num := numComponents ( tt . head , tt . G ) # if num != tt . num { # t . Errorf (" STR ", tt . head , tt . G , num , tt . num ) # } # }
if root == nil { # return root # } # increasingBST ( root . Left ) # tmp . Right = & TreeNode { # Val : root . Val , # } # tmp = tmp . Right # increasingBST ( root . Right ) # return ret . Right
if ( queue . depth == 0 ) { # queue . current = & QueueItem { item : item , prev : nil } # queue . last = queue . current # queue . depth ++ # return # } # # q := & QueueItem { item : item , prev : nil } # queue . last . prev = q # queue . last = q # queue . depth ++
n := len ( A ) # prev := make ([] float 6 4 , n ) # sum := 0 . # for i , a := range A { # sum += float 6 4 ( a ) # prev [ i ] = sum / float 6 4 ( i + 1 ) # } # dp := make ([] float 6 4 , n ) # for i := 2 ; i <= K ; i ++ { # for j := i ; j <= n ; j ++ { # s , m := 0 ., 0 . # for k := j - 1 ; k >= i - 1 ; k -- { # s += float 6 4 ( A [ k ]) # v := s / float 6 4 ( j - k ) + prev [ k - 1 ] # if v > m { # m = v # } # } # dp [ j - 1 ] = m # } # prev , dp = dp , prev # } # return prev [ n - 1 ]
if n == 0 { # return nil # } # # trees := make ([][][]* TreeNode , n - 1 ) # for i := range trees { # trees [ i ] = make ([][]* TreeNode , n - 1 - i ) # } # for d := 1 ; d < n ; d ++ { # for i := 1 ; i + d <= n ; i ++ { # generate ( trees , i , i + d ) # } # } # return get ( trees , 1 , n )
n := len ( s ) # res := " STR " # for _ , word := range d { # j , l := 0 , len ( word ) # for i := 0 ; i < n ; i ++ { # if j < l && s [ i ] == word [ j ] { # j ++ # } # } # if j == l && l >= len ( res ) && # ( l > len ( res ) || word < res ) { # res = word # } # } # return res
i , j , l := 0 , 1 , len ( s ) # str := make ([] byte , l + 1 ) # for _ , c := range s { # if ' 0 ' <= c && c <= ' 9 ' { # if i > l { # return " STR " # } # str [ i ], i = byte ( c ), i + 2 # } else if j > l { # return " STR " # } else { # str [ j ], j = byte ( c ), j + 2 # } # } # if i == l || j == l { # return string ( str [: l ]) # } # if i == l - 1 { # str [ i ] = str [ 0 ] # return string ( str [ 1 : l + 1 ]) # } # return " STR "
curr := n # for _ , c := range s { # next , ok := curr . children [ c ] # if ! ok { # return false # } # curr = next # } # return true
t . Parallel () # for _ , tc := range testcases { # if reversed := ReverseDirectedGraph ( tc . g ); ! reflect . DeepEqual ( reversed , tc . reversed ) { # t . Errorf (" STR ", tc . reversed , reversed ) # } # }
sort . Ints ( nums ) # ans , diff , n := math . MaxInt 3 2 , math . MaxInt 3 2 , len ( nums ) # for i := 0 ; i < n - 2 ; i ++ { # l , r := i + 1 , n - 1 # for l < r { # sum := nums [ i ] + nums [ l ] + nums [ r ] # if sum < target { # if target - sum < diff { # ans , diff = sum , target - sum # } # l ++ # } else if sum > target { # if sum - target < diff { # ans , diff = sum , sum - target # } # r -- # } else { # return target # } # } # } # return ans
n := len ( S ) # # res := make ([] int , n ) # for i := range res { # res [ i ] = n # } # # left , right := - n , 2 * n # # for i := 0 ; i < n ; i ++ { # j := n - i - 1 # if S [ i ] == C { # left = i # } # if S [ j ] == C { # right = j # } # res [ i ] = min ( res [ i ], dist ( i , left )) # res [ j ] = min ( res [ j ], dist ( j , right )) # } # # return res
if tree . root == nil { # tree . root = & Node { data : i } # return # } # currentNode := tree . root # for { # if i > currentNode . data { # if currentNode . right == nil { # currentNode . right = & Node { data : i , parent : currentNode } # return # } # currentNode = currentNode . right # } else { # if currentNode . left == nil { # currentNode . left = & Node { data : i , parent : currentNode } # return # } # currentNode = currentNode . left # } # }
var ( # n = len ( s ) # cur = n - 1 # ) # # for cur >= 0 { # if n - 1 == cur && s [ cur ] == 3 2 { # cur -- # n -- # continue # } # if s [ cur ] != 3 2 { # cur -- # } else { # break # } # } # return n - cur - 1
if len ( lst ) == 0 { # return nil # } # root := & BinaryTree { lst [ len ( lst )- 1 ], nil , nil } # lst = lst [: len ( lst )- 1 ] # i := len ( lst ) - 1 # for ; i >= 0 && lst [ i ] > root . Value ; i -- { # } # root . Left = BuildTreeFromPostorder ( lst [: i + 1 ]) # root . Right = BuildTreeFromPostorder ( lst [ i + 1 :]) # return root
return b . index
m := make ( map [ int ] int , len ( nums )) # for _ , v := range nums { # m [ v ]++ # } # for v := range m { # if m [ v ] == 1 { # return v # } # } # return 0
dp := make ([][] int , len ( coins )+ 1 ) # for i := 0 ; i <= len ( coins ); i ++ { # dp [ i ] = make ([] int , amount + 1 ) # } # for j := 0 ; j <= amount ; j ++ { # dp [ 0 ][ j ] = amount + 1 # } # dp [ 0 ][ 0 ] = 0 # for i := 1 ; i <= len ( coins ); i ++ { # for j := 0 ; j <= amount ; j ++ { # if j >= coins [ i - 1 ] { # dp [ i ][ j ] = int ( math . Min ( float 6 4 ( dp [ i - 1 ][ j ]), float 6 4 ( dp [ i ][ j - coins [ i - 1 ]]+ 1 ))) # } else { # dp [ i ][ j ] = dp [ i - 1 ][ j ] # } # } # } # if dp [ len ( coins )][ amount ] > amount { # return - 1 # } else { # return dp [ len ( coins )][ amount ] # }
chToParent := make ([] byte , 2 6 ) # for _ , equation := range equations { # ch 1 := equation [ 0 ] # ch 2 := equation [ 3 ] # chToParent [ ch 1 -' a '] = ch 1 # chToParent [ ch 2 -' a '] = ch 2 # } # # for _ , equation := range equations { # if equation [ 1 ] == '=' { # ch 1 := equation [ 0 ] # ch 2 := equation [ 3 ] # union ( chToParent , ch 1 , ch 2 ) # } # } # # for _ , equation := range equations { # if equation [ 1 ] == '!' { # ch 1 := equation [ 0 ] # ch 2 := equation [ 3 ] # # if getParent ( chToParent , ch 1 ) == getParent ( chToParent , ch 2 ) { # return false # } # } # } # # return true
if root == nil { # return nil # } # if val < root . Val { # if root . Left != nil { # insertIntoBST ( root . Left , val ) # } else { # root . Left = & TreeNode { Val : val } # } # } else { # if root . Right != nil { # insertIntoBST ( root . Right , val ) # } else { # root . Right = & TreeNode { Val : val } # } # } # # return root
ret := 0 # for n > 0 { # ret += n / 5 # n /= 5 # } # return ret
edges := graph [ from ] # if edges == nil { # edges = make ( map [ string ] bool ) # graph [ from ] = edges # } # edges [ to ] = true
fmt . Printf (" STR ", nfiles , float 6 4 ( nbytes )/ 1 e 9 )
res := [][] int {} # sort . Slice ( nums , func ( i , j int ) bool { # return nums [ i ] < nums [ j ] # }) # visited := make ( map [ int ] bool ) # helper ( nums , [] int {}, visited , & res ) # return res
return ways ( input , map [ string ][] int {})
tests := [...] testType { # { # name : " STR ", # typed : " STR ", # want : true , # }, # { # name : " STR ", # typed : " STR ", # want : false , # }, # { # name : " STR ", # typed : " STR ", # want : true , # }, # { # name : " STR ", # typed : " STR ", # want : true , # }, # { # name : " STR ", # typed : " STR ", # want : false , # }, # { # name : " STR ", # typed : " STR ", # want : true , # }, # { # name : " STR ", # typed : " STR ", # want : false , # }, # { # name : " STR ", # typed : " STR ", # want : false , # }, # { # name : " STR ", # typed : " STR ", # want : true , # }, # } # for _ , tt := range tests { # got := isLongPressedName ( tt . name , tt . typed ) # if got != tt . want { # t . Fatalf (" STR ", tt . name , tt . typed , got , tt . want ) # } # }
frame := & Frame {} # frame . thread = thread # frame . localVariables = NewLocalVariables ( maxLocals ) # frame . operandStack = NewOperandStack ( maxStack ) # frame . code = code # frame . next = nil # return frame
var result [] string # words := strings . Split ( long , " STR ") # var line [] string # ll := 0 # for i := 0 ; i < len ( words ); i ++ { # switch { # case ll == 0 && len ( words [ i ]) <= k : # line = append ( line , words [ i ]) # ll = len ( words [ i ]) # case ll + len ( words [ i ])+ 1 <= k : # line = append ( line , words [ i ]) # ll += len ( words [ i ]) + 1 # case ll > 0 : # result = append ( result , strings . Join ( line , " STR ")) # line = line [: 0 ] # ll = 0 # i -- # default : # return nil # } # } # if ll > 0 { # result = append ( result , strings . Join ( line , " STR ")) # } # return result
li , err := net . Listen (" STR ", " STR ") # if err != nil { # log . Fatalln ( err ) # } # defer li . Close () # # commands := make ( chan Command ) # go redisServer ( commands ) # # for { # conn , err := li . Accept () # if err != nil { # log . Fatalln ( err ) # } # # go handle ( commands , conn ) # }
m := make ( map [ string ][] string ) # pos := make ( map [ string ] int ) # posI := 0 # # for _ , word := range words { # ana := [] rune ( word ) # sort . Slice ( ana , func ( i , j int ) bool { # return ana [ i ] < ana [ j ] # }) # # anaKey := string ( ana ) # # if _ , seen := pos [ anaKey ]; ! seen { # pos [ anaKey ] = posI # posI ++ # } # # m [ anaKey ] = append ( m [ anaKey ], word ) # } # # res := make ([][] string , len ( m )) # # for k , v := range m { # res [ pos [ k ]] = v # } # # return res
if len ( A ) < 3 { # return 0 # } # # var indexMap = map [ int ] int {} # for i := 0 ; i < len ( A ); i ++ { # indexMap [ A [ i ]] = i # } # # var maxLen = 2 # # for i := 0 ; i < len ( A ); i ++ { # for j := i + 1 ; j < len ( A ); j ++ { # currentLen := 2 # i , j := i , j # for { # sum := A [ i ] + A [ j ] # if indexMap [ sum ] > j { # currentLen ++ # if currentLen > maxLen { # maxLen = currentLen # } # i = j # j = indexMap [ sum ] # } else { # break # } # } # } # } # # if maxLen == 2 { # return 0 # } # return maxLen
dummy := & ListNode { # Next : head , # } # # fast , slow := dummy , dummy # for i := 0 ; i < n ; i ++ { # fast = fast . Next # } # # for fast . Next != nil { # fast = fast . Next # slow = slow . Next # } # # slow . Next = slow . Next . Next # return dummy . Next
if len ( words ) == 0 { # return [] int {} # } # res := [] int {} # counter := map [ string ] int {} # for _ , w := range words { # counter [ w ]++ # } # length , totalLen , tmpCounter := len ( words [ 0 ]), len ( words [ 0 ])* len ( words ), copyMap ( counter ) # for i , start := 0 , 0 ; i < len ( s )- length + 1 && start < len ( s )- length + 1 ; i ++ { # if tmpCounter [ s [ i : i + length ]] > 0 { # tmpCounter [ s [ i : i + length ]]-- # if checkWords ( tmpCounter ) && ( i + length - start == totalLen ) { # res = append ( res , start ) # continue # } # i = i + length - 1 # } else { # start ++ # i = start - 1 # tmpCounter = copyMap ( counter ) # } # } # return res
window := make ( map [ string ] int ) # left , right := 0 , 0 # for right < len ( s ) { # char := string ( s [ right ]) # right ++ # window [ char ]++ # for window [ char ] > 1 { # removeChar := string ( s [ left ]) # window [ removeChar ]-- # left ++ # } # if right - left > length { # length = right - left # } # } # return
if len ( nums ) <= 1 { # return len ( nums ) # } # tail := 1 # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i - 1 ] != nums [ i ] { # nums [ tail ] = nums [ i ] # tail ++ # } # } # fmt . Println ( nums ) # return tail
t . Parallel () # for _ , tc := range testcases { # if max := MaxIf ( tc . a , tc . b ); max != tc . max { # t . Errorf (" STR ", tc . max , max ) # } # }
var stack [] int # for _ , v := range input { # switch v { # case " STR ": # r := stack [ len ( stack )- 2 ] + stack [ len ( stack )- 1 ] # stack = append ( stack [: len ( stack )- 2 ], r ) # case " STR ": # r := stack [ len ( stack )- 2 ] - stack [ len ( stack )- 1 ] # stack = append ( stack [: len ( stack )- 2 ], r ) # case " STR ": # r := stack [ len ( stack )- 2 ] * stack [ len ( stack )- 1 ] # stack = append ( stack [: len ( stack )- 2 ], r ) # case " STR ": # r := stack [ len ( stack )- 2 ] / stack [ len ( stack )- 1 ] # stack = append ( stack [: len ( stack )- 2 ], r ) # default : # i , err := strconv . Atoi ( v ) # if err != nil { # panic (" STR ") # } # stack = append ( stack , i ) # } # } # if len ( stack ) != 1 { # panic (" STR ") # } # return stack [ 0 ]
if p == nil && q == nil { # return true # } # if p == nil || q == nil { # return false # } # return p . Val == q . Val && # isSameTree ( p . Left , q . Left ) && isSameTree ( p . Right , q . Right )
dict := make ( map [ int ] int , 0 ) # # for _ , v := range nums { # temp , ok := dict [ v ] # if ! ok { # dict [ v ] = 1 # } else if 2 == temp { # delete ( dict , v ) # } else { # dict [ v ]++ # } # } # for k := range dict { # return k # } # # return - 1
var s seqStack # s . top = - 1 # result := [] int {} # if root != nil { # for root != nil || s . top != - 1 { # for root != nil { # s . top ++ # s . data = append ( s . data , root ) # s . tag = append ( s . tag , 0 ) # root = root . Left # } # # if s . tag [ s . top ] == 0 { # root = s . data [ s . top ] # s . tag [ s . top ] = 1 # root = root . Right # continue # } # # for s . tag [ s . top ] == 1 { # root = s . data [ s . top ] # s . data = s . data [: len ( s . data )- 1 ] # result = append ( result , root . Val ) # s . top -- # if s . top < 0 { # break # } # } # # root = nil # } # } # return result
if len ( s ) != len ( t ) { # return false # } # # m 1 := make ([] int , 2 5 6 ) # m 2 := make ([] int , 2 5 6 ) # # for i := 0 ; i < len ( s ); i ++ { # if m 1 [ int ( s [ i ])] != m 2 [ int ( t [ i ])] { # return false # } # m 1 [ int ( s [ i ])] = i + 1 # m 2 [ int ( t [ i ])] = i + 1 # } # return true
s := string ( p ) # if _ , ok := w . writes [ s ]; ok { # return # } # n , err = w . w . Write ( p ) # if n != len ( s ) { # s = string ( p [: n ]) # } # w . writes [ s ] = struct {}{} # return
if ipl == nil { # return # } # v 4 := ip . To 4 () # if v 4 != nil { # r , ok = ipl . lookup ( v 4 ) # if ok { # return # } # } # v 6 := ip . To 1 6 () # if v 6 != nil { # return ipl . lookup ( v 6 ) # } # if v 4 == nil && v 6 == nil { # r = Range { # Description : " STR ", # } # ok = true # } # return
result := 0 # for _ , v := range nums { # result += v # } # return result
return h . heap . Pop ()
m := make ( map [ int ][] int , len ( nums )) # for i , v := range nums { # m [ v ] = append ( m [ v ], i ) # } # return Solution { m : m }
cases := [] struct { # name string # inputs int # expect bool # }{ # {" STR ", 1 , true }, # {" STR ", 1 , true }, # {" STR ", 1 , false }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Constructor ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # } # }) # }
n := len ( a ) # if n < 3 { # return 0 # } # # min , max := - 1 << 3 1 , 1 << 3 1 - 1 # # dp := make ([] map [ int ] int , n ) # # res := 0 # for i := 1 ; i < n ; i ++ { # dp [ i ] = make ( map [ int ] int ) # for j := 0 ; j < i ; j ++ { # d := a [ i ] - a [ j ] # # if d <= min || max <= d { # continue # } # # dp [ i ][ d ] += dp [ j ][ d ] + 1 # res += dp [ j ][ d ] # } # } # # return res
testFramework ( t , HeapSort )
t . Parallel () # # for _ , tc := range testcases { # if res := LongestContiguousBrowsingHistory ( tc . user 1 , tc . user 2 ); ! reflect . DeepEqual ( res , tc . expected ) { # t . Errorf (" STR ", tc . expected , res ) # } # }
return n / int ( math . Pow 1 0 ( i - 1 )) % 1 0
i := 0 # # if i > 0 { # return func ( i int ) { println (" STR ", i ) } # } # # return func ( i int ) { println (" STR ", i ) }
sort . Ints ( A ) # for i := 3 ; i >= 0 ; i -- { # if A [ i ] < 3 { # for j := 3 ; j >= 0 ; j -- { # if j != i && A [ i ]* 1 0 + A [ j ] < 2 4 { # for k := 3 ; k >= 0 ; k -- { # if k != i && k != j && A [ k ] < 6 { # l := 6 - i - j - k # return fmt . Sprintf (" STR ", A [ i ], A [ j ], A [ k ], A [ l ]) # } # } # } # } # } # } # return " STR "
fs := frequencySort 7 6 7 ( S ) # if fs == " STR " { # return " STR " # } # bs := [] byte ( fs ) # ans := " STR " # j := ( len ( bs )- 1 )/ 2 + 1 # for i := 0 ; i <= ( len ( bs )- 1 )/ 2 ; i ++ { # ans += string ( bs [ i ]) # if j < len ( bs ) { # ans += string ( bs [ j ]) # } # j ++ # } # return ans
n , values := len ( nums ), make ([] int , 1 0 0 0 0 1 ); # for _ , num := range nums { # values [ num ]++; # } # sort . Slice ( values , func ( i , j int ) bool { # return values [ i ] > values [ j ]; # }) # res , total := 0 , 0 ; # for i := 0 ; i < len ( values ) && values [ i ] > 0 ; i ++ { # total += values [ i ]; # res += 1 ; # if total >= n / 2 { # return res ; # } # } # return n ;
ch := make ( chan string ) # go func () { # for _ , url := range [] string { # " https : , # " https : , # " https : , # " http : , # " https : , # " https : , # " https : , # " http : , # } { # ch <- url # } # close ( ch ) # }() # return ch
tests := [][] int { # [] int { 3 , 2 , 4 }, # [] int { 0 , 8 , 7 , 3 , 3 , 4 , 2 }, # [] int { 0 , 1 }, # } # targets := [] int { # 6 , # 1 1 , # 1 , # } # results := [][] int { # [] int { 1 , 2 }, # [] int { 1 , 3 }, # [] int { 0 , 1 }, # } # caseNum := 3 # for i := 0 ; i < caseNum ; i ++ { # if ret := twoSum ( tests [ i ], targets [ i ]); ret [ 0 ] != results [ i ][ 0 ] && ret [ 1 ] != results [ i ][ 1 ] { # t . Fatalf (" STR ", i , ret ) # } # }
t . Parallel () # for tcid , tc := range testcases { # if result , err := FloorRecursive ( tc . root , tc . target ); result != tc . expectedFloor || # err != tc . expectedFloorErr { # t . Errorf (" STR ", tcid , tc . expectedFloor , tc . expectedFloorErr , result , err ) # } # }
helper ( root ) # return sum
for i := 0 ; i < len ( a ); i ++ { # for a [ i ] != a [ a [ i ]- 1 ] { # a [ i ], a [ a [ i ]- 1 ] = a [ a [ i ]- 1 ], a [ i ] # } # } # # res := make ([] int , 0 , len ( a )) # # for i , n := range a { # if i != n - 1 { # res = append ( res , n ) # } # } # # sort . Ints ( res ) # # return res
var route [] int # var stack [] int # startIdx := getIdx ( start , nodes ) # stack = append ( stack , startIdx ) # for len ( stack ) > 0 { # now := stack [ len ( stack )- 1 ] # route = append ( route , nodes [ now ]) # if len ( stack ) > 1 { # stack = stack [: len ( stack )- 1 ] # } else { # stack = stack [: len ( stack )- 1 ] # } # for i := 0 ; i < len ( edges [ now ]); i ++ { # if edges [ now ][ i ] && notExist ( i , stack ) { # stack = append ( stack , i ) # } # edges [ now ][ i ] = false # edges [ i ][ now ] = false # } # if route [ len ( route )- 1 ] == end { # return route , true # } # } # return nil , false
ret := mymax ( A ) - mymin ( A ) - 2 * K # if ret > 0 { # return ret # } # return 0
e . min = newRsVEBTreeItem ( key , value ) # e . max = e . min
bytes := [] byte ( s ) # i , j := 0 , len ( s )- 1 # for { # for i < len ( s ) && ! isVowel ( bytes [ i ]) { # i ++ # } # for 0 <= j && ! isVowel ( bytes [ j ]) { # j -- # } # # if i >= j { # break # } # # bytes [ i ], bytes [ j ] = bytes [ j ], bytes [ i ] # i ++ # j -- # } # # return string ( bytes )
req , err := http . NewRequest (" STR ", url , nil ) # if err != nil { # return nil , err # } # req . Header . Set (" STR ", bodyType ) # return Do ( http . DefaultClient , req )
if timestamp . Before ( e . lastTimestamp ) || timestamp == e . lastTimestamp { # return e . Current # } # # if e . lastTimestamp . IsZero () { # e . lastTimestamp = timestamp # return e . Current # } # # timeDelta := timestamp . Sub ( e . lastTimestamp ) # e . lastTimestamp = timestamp # # e . Current = e . count ( next , timeDelta ) # return e . Current
w := k . Width # h := k . Height # nk := NewKernel ( h , w ) # # for x := 0 ; x < w ; x ++ { # for y := 0 ; y < h ; y ++ { # nk . Matrix [ x * h + y ] = k . Matrix [ y * w + x ] # } # } # # return nk
if n < 1 0 { # return n == 0 || n == 2 || n == 1 # } # # least := n % 1 0 # rest := n / 1 0 # # return ( least == 0 || least == 2 || least == 1 ) && check ( rest )
for _ , url := range os . Args [ 1 :] { # resp , err := http . Get ( url ) # if err != nil { # fmt . Fprintf ( os . Stderr , " STR ", err ) # os . Exit ( 1 ) # } # b , err := ioutil . ReadAll ( resp . Body ) # resp . Body . Close () # if err != nil { # fmt . Fprintf ( os . Stderr , " STR ", url , err ) # os . Exit ( 1 ) # } # fmt . Printf (" STR ", b ) # }
n := len ( triangle ) # for i := n - 2 ; i >= 0 ; i -- { # for j := 0 ; j < len ( triangle [ i ]); j ++ { # triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]) # } # } # return triangle [ 0 ][ 0 ]
for currentIndex := 1 ; currentIndex < len ( arr ); currentIndex ++ { # temporary := arr [ currentIndex ] # iterator := currentIndex # for ; iterator > 0 && arr [ iterator - 1 ] >= temporary ; iterator -- { # arr [ iterator ] = arr [ iterator - 1 ] # } # arr [ iterator ] = temporary # } # return arr
bytes := [] byte ( s ) # if len ( bytes ) < 2 { # return 0 # } # lengthList := make ([] int , len ( bytes )) # var max int # for i := 1 ; i < len ( bytes ); i ++ { # if bytes [ i ] == ')' { # j := i - lengthList [ i - 1 ] - 1 # if j >= 0 && bytes [ j ] == '(' { # lengthList [ i ] = lengthList [ i - 1 ] + 2 # if j - 1 >= 0 { # lengthList [ i ] += lengthList [ j - 1 ] # } # } # } # if lengthList [ i ] > max { # max = lengthList [ i ] # } # } # return max
tests := [...] testType { # { # in : [] int { 1 , 2 , 3 , 1 }, # want : 4 , # }, # { # in : [] int { 2 , 7 , 9 , 3 , 1 }, # want : 1 2 , # }, # } # for _ , tt := range tests { # got := rob ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
var x , y , z int # var res = make ([] int , 0 , 1 0 ) # var culVal int # res = append ( res , 1 ) # # for len ( res ) < n { # culVal = min ( res [ x ]* 2 , res [ y ]* 3 , res [ z ]* 5 ) # fmt . Println (" STR ", culVal ) # if culVal == res [ x ]* 2 { # x ++ # } # if culVal == res [ y ]* 3 { # y ++ # } # if culVal == res [ z ]* 5 { # z ++ # } # res = append ( res , culVal ) # } # # return res
var digits [ 1 0 ] int # var output = make ([] int , len ( arr )) # # for _ , item := range arr { # digits [( item / exp )% 1 0 ]++ # } # for i := 1 ; i < 1 0 ; i ++ { # digits [ i ] += digits [ i - 1 ] # } # # for i := len ( arr ) - 1 ; i >= 0 ; i -- { # output [ digits [( arr [ i ]/ exp )% 1 0 ]- 1 ] = arr [ i ] # digits [( arr [ i ]/ exp )% 1 0 ]-- # } # # return output
ptr := unsafe . Pointer (& _sbss ) # for ptr != unsafe . Pointer (& _ebss ) { # *(* uint 6 4 )( ptr ) = 0 # ptr = unsafe . Pointer ( uintptr ( ptr ) + 8 ) # } # # src := unsafe . Pointer (& _sidata ) # dst := unsafe . Pointer (& _sdata ) # for dst != unsafe . Pointer (& _edata ) { # *(* uint 6 4 )( dst ) = *(* uint 6 4 )( src ) # dst = unsafe . Pointer ( uintptr ( dst ) + 8 ) # src = unsafe . Pointer ( uintptr ( src ) + 8 ) # }
if len ( nums ) == 0 { # return 0 # } # res := 1 # if len ( nums ) <= 3 { # for i := 0 ; i < len ( nums ); i ++ { # res = res * nums [ i ] # } # return res # } # sort . Ints ( nums ) # if nums [ len ( nums )- 1 ] <= 0 { # return 0 # } # return max ( nums [ 0 ]* nums [ 1 ]* nums [ len ( nums )- 1 ], nums [ len ( nums )- 1 ]* nums [ len ( nums )- 2 ]* nums [ len ( nums )- 3 ])
for i := 1 ; i < 2 0 0 ; i ++ { # triangles [ i ] = ( i * ( i + 1 )) / 2 # trimap [ triangles [ i ]] = true # }
return helper 1 0 8 ( nums , 0 , len ( nums )- 1 )
ch := make ( chan bool , 1 ) # println (" STR ") # go func () { # println (" STR ") # ch <- true # println (" STR ") # }() # println (" STR ") # v := <- ch # println ( v ) #
head := createSinglyLinkedList ([] int { 1 , 2 , 3 , 4 , 5 }) # expected := createSinglyLinkedList ([] int { 5 , 4 , 3 , 2 , 1 }) # if res := reverseList ( head ); ! reflect . DeepEqual ( res , expected ) { # t . Errorf (" STR ", expected , res ) # }
type Location struct { # City string # Country string # } # # type Server struct { # Name string # ID int 3 2 # Enabled bool # Location Location ` structs :" STR "` # } # # s := & Server { # Name : " STR ", # ID : 1 3 5 7 9 0 , # Enabled : false , # Location : Location { City : " STR ", Country : " STR "}, # } # # m := Values ( s ) # # fmt . Printf (" STR ", m )
if b >= m { # return 0 # } # # if n == 0 { # return 1 # } # # mp := m # # if b != 0 { # mp -- # } # # return m * NumberOfValidPlayListsRec ( n - 1 , mp , max ( 0 , b - 1 ))
qs := [] question 5 5 7 { # # { # para 5 5 7 {" STR "}, # ans 5 5 7 {" STR "}, # }, # # { # para 5 5 7 {" STR "}, # ans 5 5 7 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 5 7 , q . para 5 5 7 # fmt . Printf (" STR ", p , reverseWords ( p . s )) # } # fmt . Printf (" STR ")
var left , max , temp int # record := make ([] int , len ( s )) # # for i , b := range s { # if b == '(' { # left ++ # } else if left > 0 { # left -- # record [ i ] = 2 # } # } # # for i := 0 ; i < len ( record ); i ++ { # if record [ i ] == 2 { # j := i - 1 # for record [ j ] != 0 { # j -- # } # record [ i ], record [ j ] = 1 , 1 # } # } # # for _ , r := range record { # if r == 0 { # temp = 0 # continue # } # # temp ++ # if temp > max { # max = temp # } # } # # return max
return fi . mode
res = 0 # dfs ( root , 0 , 1 ) # return res
var s int # var nums [] int # var ret int # nums = [] int { 2 , 3 , 1 , 2 , 4 , 3 } # ret = 2 # s = 7 # if ret != minSubArrayLen ( s , nums ) { # t . Fatalf (" STR ", ret ) # } # # nums = [] int {} # ret = 0 # s = 7 # if ret != minSubArrayLen ( s , nums ) { # t . Fatalf (" STR ", ret ) # }
tbl := [] pout { # {" STR ", " STR ", [] Bytes {{ 0 , 1 2 0 0 , 2 4 0 0 , true }}}, # {" STR ", " STR ", [] Bytes {{ 0 , 1 2 0 0 , - 1 , true }}}, # {" STR ", " STR ", [] Bytes {{- 1 , - 1 , 2 4 0 0 , false }}}, # } # for _ , c := range tbl { # c := c # t . Run ( c . Name , func ( t * testing . T ) { # t . Parallel () # t . Logf (" STR ", c . In ) # got , err := ParseResponse ( c . In ) # if err != nil { # t . Fatal ( err ) # } # c . Out [ 0 ]. Equals ( t , got ) # }) # }
tests := [] int { # 1 2 3 , # - 1 2 3 , # 0 , # - 1 , # 1 5 3 4 2 3 6 4 6 9 , # } # results := [] int { # 3 2 1 , # - 3 2 1 , # 0 , # - 1 , # 0 , # } # caseNum := 5 # for i := 0 ; i < caseNum ; i ++ { # if ret := reverse ( tests [ i ]); ret != results [ i ] { # t . Fatalf (" STR ", i , ret , results [ i ]) # } # }
stringList := make ([] string , len ( nums )) # for i := range nums { # stringList [ i ] = strconv . Itoa ( nums [ i ]) # } # quickSort ( stringList , 0 , len ( stringList )- 1 ) # var ret string # for i := range stringList { # ret += stringList [ i ] # } # if len ( ret ) != 0 && ret [ 0 ] == ' 0 ' { # return " STR " # } # return ret
res := 0 # # for i := 1 ; i < len ( prices ); i ++ { # if prices [ i ] > prices [ i - 1 ] { # res += prices [ i ] - prices [ i - 1 ] # } # } # # return res
visited := make ([][] bool , len ( grid )) # for i := range visited { # visited [ i ] = make ([] bool , len ( grid [ i ])) # } # islands := 0 # for i := range grid { # for j := range grid [ i ] { # if grid [ i ][ j ] == 1 && ! visited [ i ][ j ] { # islands ++ # exploreIsland ( grid , visited , i , j ) # } # } # } # return islands
tests := [...] testType { # { # in : [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # want : 3 , # }, # { # in : [] string {" STR ", " STR ", " STR ", " STR "}, # want : 4 , # }, # { # in : [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # want : 3 , # }, # { # in : [] string {" STR ", " STR ", " STR ", " STR "}, # want : 1 , # }, # } # for _ , tt := range tests { # got := numSpecialEquivGroups ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if head == nil || head . Next == nil { # return nil # } # # frist := head # second := head # isCycle := false # # for frist != nil && second != nil { # frist = frist . Next # if second . Next == nil { # return nil # } # second = second . Next . Next # if frist == second { # isCycle = true # break # } # } # # if ! isCycle { # return nil # } # frist = head # # for frist != second { # frist = frist . Next # second = second . Next # } # return frist #
res = nil # target = val # dfs ( root ) # return res
primes := [] int {} # for i := 1 0 0 0 ; i < 1 0 0 0 0 ; i ++ { # if big . NewInt ( int 6 4 ( i )). ProbablyPrime ( 2 0 ) { # primes = append ( primes , i ) # } # } # # for i := 0 ; i < len ( primes )- 2 ; i ++ { # for j := i + 1 ; j < len ( primes )- 1 ; j ++ { # if sameDigits ( primes [ i ], primes [ j ]) { # for k := j + 1 ; k < len ( primes )- 1 ; k ++ { # if sameDigits ( primes [ j ], primes [ k ]) && primes [ j ]- primes [ i ] == primes [ k ]- primes [ j ] { # fmt . Printf (" STR ", primes [ i ], primes [ j ], primes [ k ]) # } # } # } # } # }
t . Parallel () # for _ , tc := range testcases { # if result := KNearestPoints ( tc . pts , tc . center , tc . k ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
if n <= 3 { # return n - 1 # } # ans := 1 # for n > 4 { # n -= 3 # ans *= 3 # } # return ans * n
if k == 0 || head == nil { # return head # } # # fast := head # for i := 0 ; i < k ; i ++ { # if fast . Next == nil { # return rotateRight ( head , k %( i + 1 )) # } # fast = fast . Next # } # # slow := head # for fast . Next != nil { # slow , fast = slow . Next , fast . Next # } # # newHead := slow . Next # slow . Next , fast . Next = nil , head # # return newHead
recovered = 0 # defer func () { # if r := recover (); r != nil { # recovered += 1 # } # }() # foo () # return recovered
var nums [] float 6 4 # # for i := 0 ; i <= len ( numbers )- 5 0 ; i += 5 0 { # # fmt . Println ( i ) # # str := numbers [ i : i + 5 0 ] # # float , err := strconv . ParseFloat ( str , 6 4 ) # if err != nil { # fmt . Println ( err ) # return # } # # nums = append ( nums , float ) # # } # # var sum float 6 4 # # for _ , num := range nums { # # sum += num # # } # # fmt . Println ( sum ) #
qs := [] question 9 5 3 { # { # para 9 5 3 {[] string {" STR ", " STR "}, " STR "}, # ans 9 5 3 { true }, # }, # # { # para 9 5 3 {[] string {" STR ", " STR ", " STR "}, " STR "}, # ans 9 5 3 { false }, # }, # # { # para 9 5 3 {[] string {" STR ", " STR "}, " STR "}, # ans 9 5 3 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 5 3 , q . para 9 5 3 # fmt . Printf (" STR ", p , isAlienSorted ( p . one , p . two )) # } # fmt . Printf (" STR ")
var a uint = 1 3 1 9 5 # var b uint = 6 0 0 8 5 1 4 7 5 1 4 3 # fmt . Println ( PrimeFactor ( a )) # fmt . Println ( PrimeFactor ( b )) #
res , left , right , maxLeft , maxRight := 0 , 0 , len ( height )- 1 , 0 , 0 # for left <= right { # if height [ left ] <= height [ right ] { # if height [ left ] > maxLeft { # maxLeft = height [ left ] # } else { # res += maxLeft - height [ left ] # } # left ++ # } else { # if height [ right ] >= maxRight { # maxRight = height [ right ] # } else { # res += maxRight - height [ right ] # } # right -- # } # } # return res
tmp 1 , tmp 2 := [] int {}, [] int {} # return MyQueue { Stack : & tmp 1 , Queue : & tmp 2 }
srcFile , err := os . Open ( srcFileName ) # if err != nil { # return fmt . Errorf (" STR ", err ) # } # defer srcFile . Close () # # bs , err := ioutil . ReadAll ( srcFile ) # if err != nil { # return fmt . Errorf (" STR ", err ) # } # # dstFile , err := os . Create ( dstFileName ) # if err != nil { # return fmt . Errorf (" STR ", err ) # } # defer dstFile . Close () # # _ , err = dstFile . Write ( bs ) # if err != nil { # return fmt . Errorf (" STR ", err ) # } # return nil
builder := strings . Builder {} # for i := len ( s ) - 1 ; i >= 0 ; i -- { # builder . WriteByte ( s [ i ]) # } # return builder . String ()
prefixSum := make ([] int , len ( w )) # for i , e := range w { # if i == 0 { # prefixSum [ i ] = e # continue # } # prefixSum [ i ] = prefixSum [ i - 1 ] + e # } # return Solution 5 2 8 { prefixSum : prefixSum }
n := len ( A ) # count := 0 # for i := 0 ; i < n ; i ++ { # if A [ i ] == 0 { # count ++ # } # } # copy := func ( i , j int ) { # if j < n { # A [ j ] = A [ i ] # } # } # i , j := n - 1 , n + count - 1 # for i < j { # copy ( i , j ) # if A [ i ] == 0 { # j -- # copy ( i , j ) # } # i -- # j -- # }
switch { # case n < 1 : # return 0 # case n == 1 : # return 1 # case k == 2 : # highestBitValue := 1 << uint ( bits . Len 6 4 ( uint 6 4 ( n ))- 1 ) # return 2 *( n - highestBitValue ) + 1 # default : # return josephusGeneral ( n , k ) + 1 # }
counts , clone := make ([] int , len ( nums )), make ([] int , len ( nums )) # indices 1 , indices 2 := make ([] int , len ( nums )), make ([] int , len ( nums )) # for i := range indices 1 { # indices 1 [ i ] = i # } # # helper 3 1 5 ( nums , counts , clone , indices 1 , indices 2 , 0 , len ( nums )- 1 ) # return counts
if root == nil { # return false # } # if root . Left == nil && root . Right == nil && sum == root . Val { # return true # } # ret := hasPathSum ( root . Left , sum - root . Val ) # if ! ret { # return hasPathSum ( root . Right , sum - root . Val ) # } # return true
size := len ( A ) # inc , dec := true , true # for i := 1 ; i < size && ( inc || dec ); i ++ { # inc = inc && A [ i - 1 ] <= A [ i ] # dec = dec && A [ i - 1 ] >= A [ i ] # } # # return inc || dec
t . Parallel () # time . Sleep ( 2 * time . Second ) # input , expected := [] int { 7 , 8 , 1 0 }, 8 . 3 3 # result := Average ( input ...) # if result != expected { # # t . Errorf (" STR ", result , expected ) # }
input := " STR " # # got := IsBalanced ( input ) # want := false # # if got != want { # t . Errorf (" STR ", input , got , want ) # }
n := int 6 4 ( 6 0 0 8 5 1 4 7 5 1 4 3 ) # max := math . Ceil ( math . Sqrt ( float 6 4 ( n ))) # # out := generate (& max ) # # for p := range out { # if n % p == 0 { # fmt . Println ( p ) # } # # newout := make ( chan int 6 4 ) # go sieve ( p , out , newout ) # out = newout # }
tempMap := make ( map [ string ] int ) # tempMap [ start ] = count # # wordArr := strings . Split ( start , " STR ") # # for i := 0 ; i < len ( inputArr ); i ++ { # if exist ( wordArr , 0 , end , 0 ) == 2 { # fmt . Println (" STR ", tempMap [ start ]+ 1 ) # fmt . Println (" STR ") # break # } # # if exist ( wordArr , 0 , inputArr [ i ], 0 ) == 2 { # count ++ # tempMap [ inputArr [ i ]] = count # transfer := inputArr [ i ] # inputArr [ i ] = " STR " # wordLadder ( transfer , end , inputArr , count ) # } # # } #
randState = (( randState ^ ( randState << 1 3 )) ^ ( randState >> 7 )) ^ ( randState << 1 7 ) # return randState
if len ( queue . array ) == 0 { # return 0 # } # copied := MyQueue {} # for len ( queue . array ) != 0 { # copied . array = append ( copied . array , queue . delet ()) # } # temp := copied . array [ len ( copied . array )- 1 ] # for len ( copied . array ) != 0 { # queue . array = append ( queue . array , copied . delet ()) # } # return temp
var row , col , box [ 9 ][ 9 ] bool # for i := 0 ; i < 9 ; i ++ { # for j := 0 ; j < 9 ; j ++ { # if board [ i ][ j ] == '.' { # continue # } # cell := board [ i ][ j ] - ' 1 ' # if row [ i ][ cell ] || col [ j ][ cell ] || box [ i / 3 * 3 + j / 3 ][ cell ] { # return false # } # row [ i ][ cell ] = true # col [ j ][ cell ] = true # box [ i / 3 * 3 + j / 3 ][ cell ] = true # } # } # return true
n := len ( S ) # f := 1 # res := 0 # for i := 0 ; i < n ; i ++ { # if S [ i ] == '(' { # f *= 2 # } else { # f /= 2 # } # if S [ i ] == '(' && S [ i + 1 ] == ')' { # f /= 2 # res += f # i ++ # } # } # return res
if root == nil { # return true # } # var stack = []* TreeNode { root } # var minS = [] int {- 1 << 6 3 } # var maxS = [] int { 1 << 6 3 - 1 } # for 0 < len ( stack ) { # pre := len ( stack ) - 1 # root , min , max := stack [ pre ], minS [ pre ], maxS [ pre ] # stack , minS , maxS = stack [: pre ], minS [: pre ], maxS [: pre ] # # for root != nil { # if root . Val <= min || max <= root . Val { # return false # } # minS = append ( minS , root . Val ) # maxS = append ( maxS , max ) # stack = append ( stack , root . Right ) # max = root . Val # root = root . Left # } # } # return true
return e . c . Len ()
n := len ( graph ) # f := newForest ( n ) # for i := 0 ; i < n ; i ++ { # for j := i + 1 ; j < n ; j ++ { # if graph [ i ][ j ] == 1 { # f . union ( i , j ) # } # } # } # area , malware := make ([] int , n ), make ([] int , n ) # for i := 0 ; i < n ; i ++ { # area [ f . root ( i )]++ # } # for _ , i := range initial { # malware [ f . root ( i )]++ # } # tmp , res := 0 , initial [ 0 ] # for _ , i := range initial { # if i < res { # res = i # } # } # for _ , i := range initial { # root := f . root ( i ) # if malware [ root ] == 1 { # if area [ root ] == tmp { # if i < res { # res = i # } # } else if area [ root ] > tmp { # tmp , res = area [ root ], i # } # } # } # return res
lastIdx , res := 0 , 0 # for i := 0 ; i < len ( arr ); i ++ { # if lastIdx < arr [ i ] { # lastIdx = arr [ i ] # continue # } # # if i == lastIdx { # res ++ # lastIdx ++ # } # # } # # return res
if target < 0 { # return # } # # if target == 0 { # c := make ([] int , len ( set )) # copy ( c , set ) # * result = append (* result , c ) # return # } # # for i := pos ; i < len ( candidates ); i ++ { # set = append ( set , candidates [ i ]) # explore ( candidates , target - candidates [ i ], i , result , set ) # set = set [: len ( set )- 1 ] # }
res := math . Pow ( b . x - a . x , 2 . 0 ) + math . Pow ( b . y - a . y , 2 . 0 ) + math . Pow ( b . z - a . z , 2 . 0 ) # return math . Sqrt ( res )
return number == reverse ( number )
return fmt . Sprintf (" STR ", h [:])
squares := [] int { 0 , 1 , 4 , 9 , 1 6 , 2 5 , 3 6 , 4 9 , 6 4 , 8 1 } # # for n != 1 && n != 4 { # var sum int # for num := n ; num != 0 ; num /= 1 0 { # sum += squares [ num % 1 0 ] # } # n = sum # } # return n == 1
return & lexer { # input : input , # state : startResponse , # }
res , count := 0 , 0 # rec := make ([] int , len ( hours )+ 2 ) # for i , h := range hours { # if h > 8 { # count ++ # } else { # count -- # } # if count > 0 { # res = i + 1 # } else { # if rec [ 1 - count ] > 0 { # res = max ( res , i - rec [ 1 - count ]+ 1 ) # } # if rec [- count ] == 0 { # rec [- count ] = i + 1 # } # } # } # return res
sum := 0 # for _ , num := range nums { # sum += num # } # l := 0 # for i , num := range nums { # sum -= num # if l == sum { # return i # } # l += num # } # return - 1
var r = make ([] int , len ( a )+ len ( b )) # var i = 0 # var j = 0 # # for i < len ( a ) && j < len ( b ) { # # if a [ i ] <= b [ j ] { # r [ i + j ] = a [ i ] # i ++ # } else { # r [ i + j ] = b [ j ] # j ++ # } # # } # # for i < len ( a ) { # r [ i + j ] = a [ i ] # i ++ # } # for j < len ( b ) { # r [ i + j ] = b [ j ] # j ++ # } # # return r #
StoreUint 6 4 (& r . Reg , LoadUint 6 4 (& r . Reg )| value )
qs := [] question 9 4 9 { # { # para 9 4 9 {[] int { 1 , 2 , 3 , 4 }}, # ans 9 4 9 {" STR "}, # }, # # { # para 9 4 9 {[] int { 5 , 5 , 5 , 5 }}, # ans 9 4 9 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 4 9 , q . para 9 4 9 # fmt . Printf (" STR ", p , largestTimeFromDigits ( p . one )) # } # fmt . Printf (" STR ")
t . Parallel () # # for tcid , tc := range testcases { # if result := CartesianTree ( tc . seq ); ! equalTree ( result , tc . expected ) { # t . Errorf (" STR ", tcid ) # } # }
largest , largestIdx := h . Key ( i ), i # if h . Valid ( h . Left ( i )) && h . Key ( h . Left ( i )) > largest { # largest , largestIdx = h . Key ( h . Left ( i )), h . Left ( i ) # } # if h . Valid ( h . Right ( i )) && h . Key ( h . Right ( i )) > largest { # _ , largestIdx = h . Key ( h . Right ( i )), h . Right ( i ) # } # if i != largestIdx { # h . Swap ( largestIdx , i ) # h . MaxHeaplify ( largestIdx ) # }
f , err := os . Open ( fileName ) # if err != nil { # panic ( err ) # } # defer f . Close () # # h := md 5 . New () # io . Copy ( h , f ) # return h . Sum ( nil )
for i := 1 ; i < len ( nums ); i ++ { # nums [ i ] += nums [ i - 1 ] # } # # return NumArray { data : nums }
res := 1 . 0 # if n < 0 { # n = - n # x = 1 / x # } # for ; n > 0 ; n >>= 1 { # if n & 1 == 1 { # res *= x # } # x *= x # } # return res
value := & f . value # if f . value . Kind () != reflect . Ptr { # a := f . value . Addr () # value = & a # } # v := strctVal ( value . Interface ()) # t := v . Type () # # field , ok := t . FieldByName ( name ) # if ! ok { # return nil , false # } # # return & Field { # field : field , # value : v . FieldByName ( name ), # }, true
m , n := len ( A ), len ( A [ 0 ]) # res := ( 1 << uint ( n - 1 )) * m # for j := 1 ; j < n ; j ++ { # cur := 0 # for i := 0 ; i < m ; i ++ { # if A [ i ][ j ] == A [ i ][ 0 ] { # cur ++ # } # } # res += max ( cur , m - cur ) * ( 1 << uint ( n - j - 1 )) # } # return res
if tree == nil { # return # } # # minSum = int (^ uint ( 0 ) >> 1 ) # minLevel = minSum # current := make ([]* BinaryTree , 0 , 1 ) # current = append ( current , tree ) # level := 1 # # for len ( current ) != 0 { # nextLevel := make ([]* BinaryTree , 0 , 2 * cap ( current )) # # var sum int # for _ , ptr := range current { # sum += ptr . Value # # if ptr . Left != nil { # nextLevel = append ( nextLevel , ptr . Left ) # } # # if ptr . Right != nil { # nextLevel = append ( nextLevel , ptr . Right ) # } # } # # if sum < minSum { # minSum = sum # minLevel = level # } # level ++ # # current = nextLevel # } # # return minSum , minLevel
r , _ := http . NewRequest (" STR ", " STR ", nil ) # w := httptest . NewRecorder () # http . DefaultServeMux . ServeHTTP ( w , r ) # # var u struct { # Name string # Email string # } # # if err := json . NewDecoder ( w . Body ). Decode (& u ); err != nil { # log . Println (" STR ", err ) # } # # fmt . Println ( u )
var max = sl [ 0 ] # var min = sl [ 0 ] # for _ , s := range sl { # if s > max { # max = s # } # if s < min { # min = s # } # } # return max , min
h = map [ int ] bool {} # res = false # target = k # dfs ( root ) # return res
return uint 3 2 ( n >> _cacheOffsetBit ), int 3 2 ( n )
qs := [] question 2 0 7 { # # { # para 2 0 7 { 2 , [][] int {{ 1 , 0 }}}, # ans 2 0 7 { true }, # }, # # { # para 2 0 7 { 2 , [][] int {{ 1 , 0 }, { 0 , 1 }}}, # ans 2 0 7 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 0 7 , q . para 2 0 7 # fmt . Printf (" STR ", p , canFinish ( p . one , p . pre )) # } # fmt . Printf (" STR ")
clockwiseDis , counterclockwiseDis , n := 0 , 0 , len ( distance ) # for i := start ; i != destination ; i = ( i + 1 ) % n { # clockwiseDis += distance [ i ] # } # for i := destination ; i != start ; i = ( i + 1 ) % n { # counterclockwiseDis += distance [ i ] # } # if clockwiseDis < counterclockwiseDis { # return clockwiseDis # } # return counterclockwiseDis
return Trie {}
tests := [][] int { # [] int { 1 , 1 }, # [] int { 1 , 2 }, # [] int { 1 , 2 , 4 , 3 }, # } # results := [] int { # 1 , # 1 , # 4 , # } # caseNums := 3 # for i := 0 ; i < caseNums ; i ++ { # if ret := maxArea ( tests [ i ]); ret != results [ i ] { # t . Fatalf (" STR ", i , ret , results [ i ]) # } # }
testData := [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "} # expectedData := [] bool { true , true , true , false , true , true , false , false , false , false } # # for i , s := range testData { # result := isValid ( s ) # if result != expectedData [ i ] { # t . Error (" STR ") # } # }
return pq [ i ]. expire . Before ( pq [ j ]. expire )
digits = append ([] int { 0 }, digits ...) # for i := len ( digits ) - 1 ; i >= 0 ; i -- { # if digits [ i ] != 9 { # digits [ i ] += 1 # break # } else { # digits [ i ] = 0 # } # } # if digits [ 0 ] == 0 { # return digits [ 1 :] # } # return digits
if len ( nums ) == len ( res ) { # temp := make ([] int , len ( res )) # copy ( temp , res ) # * final = append (* final , temp ) # return # } # for i := 0 ; i < len ( nums ); i ++ { # if visited [ i ] { # continue # } # if i > 0 && nums [ i ] == nums [ i - 1 ] && ! visited [ i - 1 ] { # continue # } # res = append ( res , nums [ i ]) # visited [ i ] = true # helper ( nums , res , visited , final ) # visited [ i ] = false # res = res [: len ( res ) - 1 ] # }
testData := [][] int { # { 0 , 1 , 0 , 3 , 1 2 }, # } # # expectedData := [][] int { # { 1 , 3 , 1 2 , 0 , 0 }, # } # # for index , data := range testData { # if moveZeroes 2 ( data ); ! reflect . DeepEqual ( data , expectedData [ index ]) { # t . Errorf (" STR ", expectedData [ index ], data ) # } # }
m := map [ string ] int {} # for _ , c := range cpdomains { # ss := strings . Fields ( c ) # n , _ := strconv . Atoi ( ss [ 0 ]) # s := ss [ 1 ] # m [ s ] += n # for i := 0 ; i < len ( s ); i ++ { # if s [ i ] == '.' { # d := s [ i + 1 :] # m [ d ] += n # } # } # } # res := make ([] string , 0 , len ( m )) # for d , n := range m { # res = append ( res , fmt . Sprintf (" STR ", n , d )) # } # return res
if k == 0 { # return [][] int {} # } # c , res := [] int {}, [][] int {} # findcombinationSum 3 ( k , n , 1 , c , & res ) # return res
t . Parallel () # for tcid , tc := range testcases { # input := copySinglyLL ( tc . input ) # if result := MergesortSinglyLinkedList ( input ); ! equal ( result , tc . expected ) { # t . Errorf (" STR ", tcid ) # } # }
text := " STR " # # fmt . Println ( reverseSentence ( text ))
resultArr := make ([] int , 0 , 0 ) # expArr := make ([] int , 0 , 0 ) # tree . PostOrderWalk ( tree . Root (), func ( tree binaryTreeIf , node interface {}) bool { # n := node .(* gbtElement ) # resultArr = append ( resultArr , int ( n . Key )) # return false # }) # expBst := newBstRecrusive () # for _ , v := range data { # expBst . Insert ( uint 3 2 ( v )) # } # expBst . PostOrderWalk ( expBst . Root (), func ( tree binaryTreeIf , node interface {}) bool { # n := node .(* bstElement ) # expArr = append ( expArr , int ( n . Key )) # return false # }) # if ! reflect . DeepEqual ( resultArr , expArr ) { # t . Log ( fmt . Sprintf (" STR ", expArr ) + fmt . Sprintf (" STR ", resultArr )) # t . Fail () # }
tests := [...] testType { # { # a : " STR ", # b : " STR ", # want : 3 , # }, # { # a : " STR ", # b : " STR ", # want : 1 , # }, # { # a : " STR ", # b : " STR ", # want : 2 , # }, # { # a : " STR ", # b : " STR ", # want : - 1 , # }, # } # for _ , tt := range tests { # got := repeatedStringMatch ( tt . a , tt . b ) # if got != tt . want { # t . Fatalf (" STR ", tt . a , tt . b , got , tt . want ) # } # }
rw . write . Add ( 1 ) # # rw . readerControl . Acquire ( rw . maxReads )
if node == nil { # return nil # } # var queue []* graph # var cloneNeighbors []* graph # var cloneNeighbor * graph # newNode := new ( graph ) # newNode . label = node . label # visited := make ( map [* graph ]* graph ) # dict := make ( map [* graph ]* graph ) # dict [ node ] = newNode # queue = append ( queue , node ) # for len ( queue ) > 0 { # node = queue [ 0 ] # queue = queue [ 1 :] # visited [ node ] = node # cloneNode := dict [ node ] # cloneNeighbors = nil # for _ , neighbor := range node . neighbors { # if visited [ neighbor ] == nil { # queue = append ( queue , neighbor ) # } # if dict [ neighbor ] == nil { # cloneNeighbor = new ( graph ) # cloneNeighbor . label = neighbor . label # dict [ neighbor ] = cloneNeighbor # } else { # cloneNeighbor = dict [ neighbor ] # } # cloneNeighbors = append ( cloneNeighbors , cloneNeighbor ) # } # cloneNode . neighbors = cloneNeighbors # } # return newNode
return MagicDictionary {}
var vals [] int # # var f func (* TreeNode , int ) # f = func ( root * TreeNode , depth int ) { # if root == nil { # return # } # # if depth == len ( vals ) { # vals = append ( vals , root . Val ) # } else if root . Val > vals [ depth ] { # vals [ depth ] = root . Val # } # # f ( root . Left , depth + 1 ) # f ( root . Right , depth + 1 ) # } # f ( root , 0 ) # # return vals
qs := [] question 4 4 1 { # # { # para 4 4 1 { 5 }, # ans 4 4 1 { 2 }, # }, # # { # para 4 4 1 { 8 }, # ans 4 4 1 { 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 4 1 , q . para 4 4 1 # fmt . Printf (" STR ", p , arrangeCoins ( p . n )) # } # fmt . Printf (" STR ")
if len ( mice ) != len ( holes ) { # panic (" STR ") # } # sort . Ints ( mice ) # sort . Ints ( holes ) # n := len ( mice ) # var max int # for i := 0 ; i < n ; i ++ { # move := mice [ i ] - holes [ i ] # if move < 0 { # move = - move # } # if move > max { # max = move # } # } # return max
n = ( n >> 1 6 ) | ( n << 1 6 ) # n = (( n & 0 xff 0 0 ff 0 0 ) >> 8 ) | (( n & 0 x 0 0 ff 0 0 ff ) << 8 ) # n = (( n & 0 xf 0 f 0 f 0 f 0 ) >> 4 ) | (( n & 0 x 0 f 0 f 0 f 0 f ) << 4 ) # n = (( n & 0 xcccccccc ) >> 2 ) | (( n & 0 x 3 3 3 3 3 3 3 3 ) << 2 ) # n = (( n & 0 xaaaaaaaa ) >> 1 ) | (( n & 0 x 5 5 5 5 5 5 5 5 ) << 1 ) # return n
return float 6 4 ( item . Quantity ) * item . UnitPrice
qs := [] question 9 7 8 { # # { # para 9 7 8 {[] int { 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 }}, # ans 9 7 8 { 5 }, # }, # # { # para 9 7 8 {[] int { 9 , 9 }}, # ans 9 7 8 { 1 }, # }, # # { # para 9 7 8 {[] int { 9 , 4 , 2 , 1 0 , 7 , 8 , 8 , 1 , 9 }}, # ans 9 7 8 { 5 }, # }, # # { # para 9 7 8 {[] int { 4 , 8 , 1 2 , 1 6 }}, # ans 9 7 8 { 2 }, # }, # # { # para 9 7 8 {[] int { 1 0 0 }}, # ans 9 7 8 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 7 8 , q . para 9 7 8 # fmt . Printf (" STR ", p , maxTurbulenceSize ( p . one )) # } # fmt . Printf (" STR ")
if this . stack 2 . Len () == 0 { # for this . stack 1 . Len () > 0 { # this . stack 2 . PushBack ( this . stack 1 . Remove ( this . stack 1 . Back ())) # } # } # if this . stack 2 . Len () != 0 { # e := this . stack 2 . Back () # this . stack 2 . Remove ( e ) # return e . Value .( int ) # } # return - 1
for i := 0 ; i < 1 0 ; i ++ { # # benchmarkDivideAndConquer ( 1 0 0 , b ) # }
data := make ([] int , 2 ) # data [ 0 ] = math . MaxInt 3 2 # data [ 1 ] = - 1 # check ( root , data ) # return data [ 0 ]
if len ( str ) == * index { # return nil # } # if ( str )[* index ] == " STR " { # (* index ) = * index + 1 # return nil # } # v , _ := strconv . Atoi ( string (( str )[* index ])) # root := & TreeNode { Val : v } # (* index ) = * index + 1 # root . Left = conFromPreStrHelper ( str , index ) # root . Right = conFromPreStrHelper ( str , index ) # # return root
return num > 0 && ( 0 == num &( num - 1 )) && ( num & 0 x 5 5 5 5 5 5 5 5 != 0 )
if nil == root { # return 0 # } # # leftDepth := minDepth ( root . Left ) # rightDepth := minDepth ( root . Right ) # # if 0 == leftDepth || 0 == rightDepth { # return leftDepth + rightDepth + 1 # } else { # if leftDepth < rightDepth { # return leftDepth + 1 # } else { # return rightDepth + 1 # } # }
sundaysCount := 0 # date := Date { 1 , 1 , 1 , 1 9 0 0 } # # for { # # if date . dayWeek == 7 && date . dayMonth == 1 && date . year >= 1 9 0 1 { # sundaysCount ++ # } # # if ( date . dayMonth == 3 1 ) && ( date . month == 1 2 ) && ( date . year == 2 0 0 0 ) { # break # } # # date . next () # # } # # fmt . Println ( sundaysCount ) #
if nil == l 1 { # return l 2 # } # if nil == l 2 { # return l 1 # } # # if l 1 . Val < l 2 . Val { # l 1 . Next = mergeTwoLists ( l 1 . Next , l 2 ) # return l 1 # } else { # l 2 . Next = mergeTwoLists ( l 1 , l 2 . Next ) # return l 2 # }
cases := [] struct { # a , b , expected int # }{ # { # a : 0 , # b : 0 , # expected : 0 , # }, # { # a : 1 , # b : 1 , # expected : 1 , # }, # { # a : - 1 , # b : 1 , # expected : 1 , # }, # { # a : 1 , # b : - 1 , # expected : 1 , # }, # { # a : 1 0 , # b : 2 , # expected : 1 0 , # }, # } # # for _ , c := range cases { # actual := Max ( c . a , c . b ) # if actual != c . expected { # t . Errorf (" STR ", c . expected , actual ) # } # }
return da . ElementData [: da . Size ]
sort . Ints ( tokens ) # # maxScore , score := 0 , 0 # i , j := 0 , len ( tokens )- 1 # # for i <= j { # if P >= tokens [ i ] { # P -= tokens [ i ] # score ++ # maxScore = score # i ++ # } else if score > 0 { # P += tokens [ j ] # score -- # j -- # } else { # break # } # } # # return maxScore
treedata := [] int { 3 , 9 , 2 0 , - 1 , - 1 , 1 5 , 7 } # root := GenTree ( treedata ) # fmt . Println ( root . Val ) # fmt . Println ( root . Left . Left ) # fmt . Println ( root . Right )
var err error # # err = seek ( r , hSize , io . SeekStart , hSize ) # if err != nil { # return err # } # # return read ( r , hSize , h )
data := & Node { data : i } # if list . head == nil { # list . head = data # return # } # current := list . head # for current . next != nil { # current = current . next # } # current . next = data
tests := map [ int ] bool { # 0 : true , # 1 2 1 : true , # 1 2 3 2 1 : true , # 1 2 3 3 2 1 : true , # - 1 2 1 : false , # 1 0 : false , # 1 0 0 : false , # 1 2 3 4 5 : false , # math . MaxInt 3 2 : false , # } # # for in , want := range tests { # got := isPalindrome ( in ) # if got != want { # t . Fatalf (" STR ", in , got , want ) # } # }
type address struct { # Country string ` structs :" STR "` # } # # type person struct { # Name string ` structs :" STR "` # Addresses [] address ` structs :" STR "` # } # # p := person { # Name : " STR ", # Addresses : [] address { # { Country : " STR "}, # { Country : " STR "}, # }, # } # mp := Map ( p ) # # mpAddresses := mp [" STR "].([] interface {}) # if _ , exists := mpAddresses [ 0 ].( map [ string ] interface {})[" STR "]; exists { # t . Errorf (" STR ") # } # # if _ , exists := mpAddresses [ 0 ].( map [ string ] interface {})[" STR "]; ! exists { # t . Errorf (" STR ") # }
nthPrime := 1 # currNum := 3 # currDivisor := 2 # for nthPrime < 1 0 0 0 1 { # stop := int ( math . Ceil ( math . Sqrt ( float 6 4 ( currNum )))) # for currDivisor <= stop { # if ( currNum % currDivisor ) == 0 { # break # } else { # currDivisor ++ # } # if currDivisor > stop { # nthPrime ++ # break # } # } # currNum += 2 # currDivisor = 2 # } # fmt . Printf (" STR ", currNum - 2 )
tests := [...] testType { # { # in : " STR ", # numRows : 3 , # want : " STR ", # }, # { # in : " STR ", # numRows : 4 , # want : " STR ", # }, # { # in : " STR ", # numRows : 1 , # want : " STR ", # }, # } # for _ , tt := range tests { # got := convert ( tt . in , tt . numRows ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
t . Parallel () # # for _ , tc := range testcases { # if next := NextIntSameSetBits ( tc . n ); next != tc . next { # t . Errorf (" STR ", tc . next , next ) # } # }
if size <= 0 { # size = 1 # } # return & Pool { # queue : make ( chan int , size ), # wg : & sync . WaitGroup {}, # }
if rec 1 [ 1 ] < rec 2 [ 3 ] && rec 1 [ 0 ] < rec 2 [ 2 ] && rec 2 [ 1 ] < rec 1 [ 3 ] && rec 2 [ 0 ] < rec 1 [ 2 ] { # return true # } # return false
ans := "" # for i := n ; i < len ( s ); i ++ { # ans += string ( s [ i ]) # } # for i := 0 ; i < n ; i ++ { # ans += string ( s [ i ]) # } # return ans
data := make ([] Data , batch ) # # for { # i , err := pull ( ps , data ) # if i > 0 { # if _ , err := store ( ps , data [: i ]); err != nil { # return err # } # } # # if err != nil { # return err # } # }
if word == " STR " { # return true # } # if b [ i ][ j ] != word [ 0 ] { # return false # } # if len ( word ) == 1 { # return true # } # b [ i ][ j ] = '#' # if i > 0 && help ( b , word [ 1 :], i - 1 , j ) { # return true # } # if j > 0 && help ( b , word [ 1 :], i , j - 1 ) { # return true # } # if i < len ( b )- 1 && help ( b , word [ 1 :], i + 1 , j ) { # return true # } # if j < len ( b [ 0 ])- 1 && help ( b , word [ 1 :], i , j + 1 ) { # return true # } # b [ i ][ j ] = word [ 0 ] # return false
if len ( nums ) == 0 { # return 0 # } # i := 0 # for i < len ( nums ) { # if nums [ i ] < target { # i ++ # } else if nums [ i ] == target { # return i # } else { # break ; # } # } # return i
nums := make ([] int , 0 , len ( tokens )) # for _ , s := range tokens { # if s == " STR " || # s == " STR " || # s == " STR " || # s == " STR " { # b , a := nums [ len ( nums )- 1 ], nums [ len ( nums )- 2 ] # nums = nums [: len ( nums )- 2 ] # nums = append ( nums , compute ( a , b , s )) # } else { # temp , _ := strconv . Atoi ( s ) # nums = append ( nums , temp ) # } # } # # return nums [ 0 ]
vmap := variable . Value .( map [ string ] Variable ) # # return VariableMapValueTypesAreHomogenous ( variableName , vmap )
var b bytes . Buffer # # b . Write ([] byte (" STR ")) # # fmt . Fprintf (& b , " STR ") # # io . Copy ( os . Stdout , & b )
res := make ([] int , 0 , len ( nums 1 )) # nc := make ( map [ int ] int ) # for _ , n := range nums 2 { # nc [ n ]++ # } # for _ , n := range nums 1 { # if nc [ n ] > 0 { # res = append ( res , n ) # nc [ n ]-- # } # } # return res
t . Parallel () # for _ , tc := range testcases { # if result := RegularNumbersFaster ( tc . n ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
return [] float 6 4 { # minimum ( count ), # maximum ( count ), # mean ( count ), # median ( count ), # mode ( count ), # }
if k > len ( s ) { # k = len ( s ) # } # for i := 0 ; i < len ( s ); i = i + 2 * k { # if len ( s )- i >= k { # ss := revers ( s [ i : i + k ]) # s = s [: i ] + ss + s [ i + k :] # } else { # ss := revers ( s [ i :]) # s = s [: i ] + ss # } # } # return s
if len ( S ) == 0 { # return [] string { S } # } # # if len ( S ) == 1 { # if S [ 0 ] >= ' 0 ' && S [ 0 ] <= ' 9 ' { # return [] string { S } # } # # return [] string { strings . ToLower ( S ), strings . ToUpper ( S )} # } # # subStringResult := letterCasePermutation ( S [ 1 :]) # # result := [] string {} # var leadingStrings [] string # if S [ 0 ] >= ' 0 ' && S [ 0 ] <= ' 9 ' { # leadingStrings = [] string { S [: 1 ]} # } else { # leadingStrings = [] string { # strings . ToLower ( S [: 1 ]), # strings . ToUpper ( S [: 1 ]), # } # } # # for i := 0 ; i < len ( leadingStrings ); i ++ { # for j := 0 ; j < len ( subStringResult ); j ++ { # result = append ( result , leadingStrings [ i ]+ subStringResult [ j ]) # } # } # # return result
if len ( s ) != len ( t ) { # return false # } # sMap := make ( map [ byte ] int ) # for i := range s { # if _ , ok := sMap [ s [ i ]]; ok { # sMap [ s [ i ]]++ # } else { # sMap [ s [ i ]] = 1 # } # } # # for i := range t { # if _ , ok := sMap [ t [ i ]]; ok && sMap [ t [ i ]] > 0 { # sMap [ t [ i ]]-- # } else { # return false # } # } # return true
if S == T { # return 0 # } # vertexMap , visited , queue , res := map [ int ][] int {}, make ([] bool , len ( routes )), [] int {}, 0 # for i := 0 ; i < len ( routes ); i ++ { # for _ , v := range routes [ i ] { # tmp := vertexMap [ v ] # tmp = append ( tmp , i ) # vertexMap [ v ] = tmp # } # } # queue = append ( queue , S ) # for len ( queue ) > 0 { # res ++ # qlen := len ( queue ) # for i := 0 ; i < qlen ; i ++ { # vertex := queue [ 0 ] # queue = queue [ 1 :] # for _ , bus := range vertexMap [ vertex ] { # if visited [ bus ] == true { # continue # } # visited [ bus ] = true # for _ , v := range routes [ bus ] { # if v == T { # return res # } # queue = append ( queue , v ) # } # } # } # } # return - 1
m , n := len ( grid ), len ( grid [ 0 ]) # for i := 1 ; i < m ; i ++ { # grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ] # } # for j := 1 ; j < n ; j ++ { # grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ] # } # for i := 1 ; i < m ; i ++ { # for j := 1 ; j < n ; j ++ { # grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]) # } # } # return grid [ m - 1 ][ n - 1 ] #
low := uint 3 2 ( self . table [ index ]. Num ) # high := uint 3 2 ( self . table [ index + 1 ]. Num ) # return int 6 4 ( high )<< 3 2 | int 6 4 ( low )
t . Parallel () # for _ , tc := range testcases { # if result := NaiveIntegerExponentiation ( tc . x , tc . y ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
for k := 0 ; k < len ( arr ); k ++ { # if i != k { # removeArr = append ( removeArr , arr [ k ]) # } # } # return
return new ( copy ). init ( cost )
qs := [] question 1 2 2 { # # { # para 1 2 2 {[] int {}}, # ans 1 2 2 { 0 }, # }, # # { # para 1 2 2 {[] int { 7 , 1 , 5 , 3 , 6 , 4 }}, # ans 1 2 2 { 7 }, # }, # # { # para 1 2 2 {[] int { 7 , 6 , 4 , 3 , 1 }}, # ans 1 2 2 { 0 }, # }, # # { # para 1 2 2 {[] int { 1 , 2 , 3 , 4 , 5 }}, # ans 1 2 2 { 4 }, # }, # # { # para 1 2 2 {[] int { 1 , 2 , 1 0 , 1 1 , 1 2 , 1 5 }}, # ans 1 2 2 { 1 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 2 , q . para 1 2 2 # fmt . Printf (" STR ", p , maxProfit 1 2 2 ( p . one )) # } # fmt . Printf (" STR ")
ans , m , l := make ([] string , 0 ), make ([][ 2 6 ] int , len ( A )), len ( A ) # for i , str := range A { # for _ , c := range str { # m [ i ][ c -' a ']++ # } # } # for i , c := range m [ 0 ] { # for c > 0 { # c -- # for j := 1 ; j < l ; j ++ { # if m [ j ][ i ] > 0 { # m [ j ][ i ]-- # } else { # c = - 1 # break # } # } # if c >= 0 { # ans = append ( ans , fmt . Sprintf (" STR ", i +' a ')) # } # } # } # return ans
in , out := 5 , 4 4 3 8 3 9 # if x := p 3 0 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # }
nums := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } # if N == 1 { # return nums # } # # res := nums [ 1 :] # for n := 1 ; n < N ; n ++ { # tmp := make ([] int , 0 , len ( res )* 2 ) # for _ , v := range res { # r := v % 1 0 # if r - K >= 0 { # tmp = append ( tmp , v * 1 0 + r - K ) # } # if K > 0 && r + K <= 9 { # tmp = append ( tmp , v * 1 0 + r + K ) # } # } # res = tmp # } # # return res
return [] int { 9 , 9 8 7 , 1 2 3 , 5 9 7 , 6 7 7 , 1 2 1 8 , 8 7 7 , 4 7 5 }[ n - 1 ]
frame := self . stack . Peek () # return frame
sum := 0 # var inorder func (* TreeNode ) # inorder = func ( node * TreeNode ) { # if node == nil { # return # } # inorder ( node . Right ) # sum += node . Val # node . Val = sum # inorder ( node . Left ) # } # inorder ( root ) # return root
color := make ([] int , numCourses ) # m := make ( map [ int ][] int ) # for _ , v := range prerequisites { # i , i 2 := v [ 0 ], v [ 1 ] # if _ , has := m [ i ]; ! has { # m [ i ] = [] int {} # } # m [ i ] = append ( m [ i ], i 2 ) # } # isDAG := true # var helper func ( node int ) # helper = func ( node int ) { # if ! isDAG { # return # } # color [ node ] = 1 # for _ , v := range m [ node ] { # switch color [ v ] { # case 1 : # isDAG = false # break # case - 1 : # continue # default : # helper ( v ) # } # } # color [ node ] = - 1 # } # # for k := range m { # helper ( k ) # } # return isDAG
l := LRUCache { # cache : map [ int ]* DLinkedNode {}, # head : initDLinkedNode ( 0 , 0 ), # tail : initDLinkedNode ( 0 , 0 ), # capacity : capacity , # } # l . head . next = l . tail # l . tail . prev = l . head # return l
blocker . Block ()
t . Parallel () # for _ , tc := range testcases { # if result := LiesInsidePolygon ( tc . polygon , tc . p ); result != tc . isInside { # t . Errorf (" STR ", tc . polygon , tc . p , tc . isInside , result ) # } # }
f , err := os . OpenFile ( logFile , os . O_RDWR | os . O_CREATE | os . O_APPEND , 0 6 6 6 ) # if err != nil { # log . Fatalf (" STR ", err . Error ()) # } # # switch level { # case TRACE : # initLog ( f , f , f , f , true ) # return # # case INFO : # initLog ( ioutil . Discard , f , f , f , true ) # return # # case WARNING : # initLog ( ioutil . Discard , ioutil . Discard , f , f , true ) # return # case ERROR : # initLog ( ioutil . Discard , ioutil . Discard , ioutil . Discard , f , true ) # return # # default : # initLog ( ioutil . Discard , ioutil . Discard , ioutil . Discard , ioutil . Discard , false ) # f . Close () # return # # }
k , m , n := 1 , N , N # a , b , c , p := 0 , 0 , 0 , 0 # L : for ; m > 1 ; m -- { # n = m - 1 # for ; n > 1 ; n -- { # k = 1 # for ; k < 3 0 ; k ++ { # if 2 * k * m * ( m + n ) == 1 0 0 0 { # a , b , c = k * ( m * m - n * n ), 2 * k * m * n , k * ( m * m + n * n ) # if a * b * c > 0 { # p = a * b * c # break L # } # } # } # } # } # fmt . Println ( p )
target , r := target / x , target % x # pos , neg := r * 2 , ( x - r )* 2 # # bit := 1 # for target > 0 { # target , r = target / x , target % x # pos , neg = min ( r * bit + pos , ( r + 1 )* bit + neg ), min (( x - r )* bit + pos , ( x - r - 1 )* bit + neg ) # bit ++ # } # # return min ( pos , bit + neg ) - 1
for i := 0 ; i <= len ( a )- len ( b ); i ++ { # if Equal ( a [ i : i + len ( b )], b ) { # return i # } # } # return - 1
a := [] float 6 4 { 1 , 2 , 3 , 4 , 5 , 6 } # A := MakeMatrix ( a , 3 , 2 ) # # for i := 0 ; i < 3 ; i ++ { # if A . GetElm ( 0 , i ) != float 6 4 ( i + 1 ) { # t . Error () # } # }
key = strings . ToUpper ( key ) # chars = strings . ToUpper ( chars )[: size ] # for idx , ch := range chars { # if strings . Contains ( chars [ idx + 1 :], string ( ch )) { # return nil , fmt . Errorf (" STR ", ch ) # } # } # # if len ( key ) != size * size { # return nil , fmt . Errorf (" STR ", len ( key ), size * size ) # } # return & Polybius { size , chars , key }, nil
fmt . Println ( findLUSlength (" STR ", " STR "))
println ( isValidSudoku ( # [][] byte {[] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR "), # [] byte (" STR ")}))
memo := [ 1 0 ] int {} # n := 9 9 9 9 9 9 9 # sum := 0 # for i := 3 ; i < n ; i ++ { # if curiousNumber ( i , memo ) { # sum += i # } # } # # return sum
var s Stack # # n := & LiteralNode { Value : 4 2 } # s . Push ( n ) # # if s . Len () != 1 { # t . Fatalf (" STR ", s . Len ()) # } # # s . Reset () # # if s . Len () != 0 { # t . Fatalf (" STR ", s . Len ()) # }
if len ( vs ) == 0 { # panic (" STR ") # } # m := vs [ 0 ] # for _ , n := range vs [ 1 :] { # if n < m { # m = n # } # } # return m
disct := make ( map [ int ] bool , len ( nums )) # # for _ , number := range nums { # if disct [ number ] { # return true # } else { # disct [ number ] = true # } # } # return false #
random := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # array 1 := make ([] int , random . Intn ( 1 0 0 - 1 0 )+ 1 0 ) # for i := range array 1 { # array 1 [ i ] = random . Intn ( 1 0 0 ) # } # array 2 := make ( sort . IntSlice , len ( array 1 )) # copy ( array 2 , array 1 ) # GnomeSort ( array 1 ) # array 2 . Sort () # for i := range array 1 { # if array 1 [ i ] != array 2 [ i ] { # t . Fail () # } # }
flag . Parse () # fmt . Print ( strings . Join ( flag . Args (), * sep )) # if !* n { # fmt . Println () # }
if num == 0 || num == 1 { # return num # } # # if num % 2 == 0 { # return 4 * generateNthTerm ( num / 2 ) # } # # if num % 2 != 0 { # return 4 * generateNthTerm ( num / 2 ) + 1 # } # # return 0
t . Parallel () # for _ , tc := range testcases { # if result := SmallestDistanceBetweenWords ( tc . text , tc . one , tc . two ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
if root == nil { # return true # } # return recursive ( root . Left , root . Right )
var u , y , v , x int 6 4 = 1 , 1 , 0 , 0 # for a > 0 { # var q int 6 4 = b / a # x , u = u , x - q * u # y , v = v , y - q * v # b , a = a , b - q * a # } # return b , x , y
l . Val = val # l . Next = nil # return l
if n < 0 { # return 1 . 0 / pow ( x , - n ) # } # return pow ( x , n )
var n uintptr # shift := uintptr ( 0 ) # for { # c := *(* byte )( buf ) # # n |= uintptr ( c & 0 x 7 f ) << shift # shift += 7 # # buf = unsafe . Pointer ( uintptr ( buf ) + 1 ) # # if c >> 7 == 0 { # return n , buf # } # }
size := len ( S ) # l , r := 0 , size # a := make ([] int , size + 1 ) # for i , b := range S { # if b == ' I ' { # a [ i ] = l # l ++ # } else { # a [ i ] = r # r -- # } # i ++ # } # # a [ size ] = l # # return a
listener , err := net . Listen (" STR ", " STR ") # if err != nil { # log . Fatal ( err ) # } # # go broadcaster () # for { # conn , err := listener . Accept () # if err != nil { # log . Print ( err ) # continue # } # go handleConn ( conn ) # }
if list . head == nil { # return false # } # if i < 0 { # return false # } # if i == 0 { # list . head = list . head . next # return true # } # current := list . head # for u := 1 ; u < i ; u ++ { # if current . next . next == nil { # return false # } # current = current . next # } # current . next = current . next . next # return true
for i := 1 ; i < 9 ; i ++ { # for j := 1 ; j < 9 ; j ++ { # qty := 2 * ( i + j ) # if qty == 9 || qty == 1 0 { # p ( i , j ) # } # } # }
if nil != node { # return " STR " + strconv . Itoa ( node . Val ) + # " STR " + node . Next . String () + " STR " # } # return " STR "
for k , v := range A { # A [ k ] = v * v # } # sort . Ints ( A ) # return A
left , right := 0 , len ( nums )- 1 # for left < right { # switch { # case nums [ right ] > 0 : # right -- # case nums [ left ] <= 0 : # left ++ # default : # nums [ left ], nums [ right ] = nums [ right ], nums [ left ] # } # } # for left < len ( nums ) && nums [ left ] <= 0 { # left ++ # } # return left
day , month , year := 7 , 1 , 1 9 0 0 # count := 0 # for year <= 2 0 0 0 { # if day == 1 && year > 1 9 0 0 { # count += 1 # } # day += 7 # # var days int # if month == 2 { # if year % 4 == 0 && ( year % 1 0 0 != 0 || year % 4 0 0 == 0 ) { # days = 2 9 # } else { # days = 2 8 # } # } else if month == 9 || month == 4 || month == 6 || month == 1 1 { # days = 3 0 # } else { # days = 3 1 # } # if day > days { # day = day % days # month += 1 # if month > 1 2 { # month = 1 # year += 1 # } # } # } # return count
n := len ( A ) # if len ( B ) != n { # return false # } # if A == B { # s := map [ byte ] struct {}{} # for i := 0 ; i < n ; i ++ { # s [ A [ i ]] = struct {}{} # } # return len ( s ) < n # } # i , count := 0 , 2 # var a , b byte # for count > 0 && i < n { # if A [ i ] != B [ i ] { # a += A [ i ] # b += B [ i ] # count -- # } # i ++ # } # return a == b && A [ i :] == B [ i :]
cases := [] struct { # name string # inputs string # expect int # }{ # {" STR ", " STR ", 4 2 }, # {" STR ", " STR ", - 4 2 }, # {" STR ", " STR ", 4 1 9 3 }, # {" STR ", " STR ", 0 }, # {" STR ", " STR ", - 2 1 4 7 4 8 3 6 4 8 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := myAtoi ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
cases := [] struct { # name string # inputs * TreeNode # expect [][] int # }{ # {" STR ", & TreeNode { 3 , & TreeNode { Val : 9 }, & TreeNode { 2 0 , & TreeNode { Val : 1 5 }, & TreeNode { Val : 7 }}}, [][] int {{ 1 5 , 7 }, { 9 , 2 0 }, { 3 }}}, # {" STR ", & TreeNode { Val : 1 }, [][] int {{ 1 }}}, # {" STR ", & TreeNode {}, [][] int {{ 0 }}}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := Solution ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
qs := [] question 1 3 8 5 { # # { # para 1 3 8 5 {[] int { 4 , 5 , 8 }, [] int { 1 0 , 9 , 1 , 8 }, 2 }, # ans 1 3 8 5 {[] int { 2 }}, # }, # # { # para 1 3 8 5 {[] int { 1 , 4 , 2 , 3 }, [] int {- 4 , - 3 , 6 , 1 0 , 2 0 , 3 0 }, 3 }, # ans 1 3 8 5 {[] int { 2 }}, # }, # # { # para 1 3 8 5 {[] int { 2 , 1 , 1 0 0 , 3 }, [] int {- 5 , - 2 , 1 0 , - 3 , 7 }, 6 }, # ans 1 3 8 5 {[] int { 1 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 3 8 5 , q . para 1 3 8 5 # fmt . Printf (" STR ", p ) # fmt . Printf (" STR ", findTheDistanceValue ( p . arr 1 , p . arr 2 , p . d )) # } # fmt . Printf (" STR ")
if len ( obstacleGrid ) == 0 || len ( obstacleGrid [ 0 ]) == 0 { # return 0 # } # lenX , lenY := len ( obstacleGrid [ 0 ]), len ( obstacleGrid ) # if obstacleGrid [ lenY - 1 ][ lenX - 1 ] == 1 { # return 0 # } # matrix := make ([][] int , lenY ) # flag := true # for y := range matrix { # matrix [ y ] = make ([] int , lenX ) # if obstacleGrid [ y ][ 0 ] == 1 { # flag = false # } # if flag { # matrix [ y ][ 0 ] = 1 # } # } # flag = true # for x := range matrix [ 0 ] { # if obstacleGrid [ 0 ][ x ] == 1 { # flag = false # } # if flag { # matrix [ 0 ][ x ] = 1 # } # } # for y := 1 ; y < lenY ; y ++ { # for x := 1 ; x < lenX ; x ++ { # if obstacleGrid [ y ][ x ] != 1 { # matrix [ y ][ x ] = matrix [ y ][ x - 1 ] + matrix [ y - 1 ][ x ] # } # } # } # return matrix [ lenY - 1 ][ lenX - 1 ]
ans , l := 0 , len ( s ) # index := [ 1 2 8 ] int {} # for i , j := 0 , 0 ; j < l ; j ++ { # if i < index [ s [ j ]] { # i = index [ s [ j ]] # } # if ans < j - i + 1 { # ans = j - i + 1 # } # index [ s [ j ]] = j + 1 # } # return ans
var slice [][] int # slice = pathSumHelper ( root , sum , slice , [] int ( nil )) # return slice
for i := range ch { # fmt . Printf (" STR ", i ) # } # wg . Done ()
res := 0 # n := len ( A ) # sum := make ( map [ int ] int , n * n ) # for i := 0 ; i < n ; i ++ { # for j := 0 ; j < n ; j ++ { # sum [ C [ i ]+ D [ j ]]++ # } # } # # for i := 0 ; i < n ; i ++ { # for j := 0 ; j < n ; j ++ { # res += sum [-( A [ i ] + B [ j ])] # } # } # # return res
var n , longest int # for i := max ; i > 0 ; i -- { # count := 0 # v := i # for v != 1 { # if v % 2 == 0 { # v /= 2 # } else { # v = 3 * v + 1 # } # count ++ # } # if count > longest { # longest = count # n = i # } # } # return n , longest
println ( lengthOfLastWord (" STR "))
ss := strings . Split ( s , " STR ") # for i , s := range ss { # ss [ i ] = revers ( s ) # } # return strings . Join ( ss , " STR ")
size := len ( matrix ) # subsize := size - 1 # for i := 0 ; i < size / 2 ; i ++ { # for j := i ; j < subsize - i ; j ++ { # matrix [ i ][ j ], matrix [ j ][ subsize - i ] = matrix [ j ][ subsize - i ], matrix [ i ][ j ] # matrix [ i ][ j ], matrix [ subsize - i ][ subsize - j ] = matrix [ subsize - i ][ subsize - j ], matrix [ i ][ j ] # matrix [ i ][ j ], matrix [ subsize - j ][ i ] = matrix [ subsize - j ][ i ], matrix [ i ][ j ] # } # }
if m == 0 { # return 0 # } # moved := 0 # for m != n { # m >>= 1 # n >>= 1 # moved ++ # } # return m << uint 3 2 ( moved )
n := len ( nums ) # if n == 0 { # return 0 # } else if n == 1 { # return nums [ 0 ] # } # # return max ( robbing ( nums [ 1 :]), robbing ( nums [: n - 1 ]))
if s == nil { # return Function {}, false # } # # v , ok := s . FuncMap [ n ] # return v , ok
t . Parallel () # for _ , tc := range testcases { # if result := LongestSubKDistinct ( tc . input , tc . k ); result != tc . expected { # t . Errorf (" STR ", tc . input , tc . expected , result , tc . k ) # } # }
reverseNumber := NewBigInt ( 0 ) # reverseNumber . SetString ( reverse ( n . String ()), 1 0 ) # return reverseNumber
for s . clk < s . timeout { # select { # case t := <- input : # s . newTask ( t ) # inputLen := len ( input ) # for i := 0 ; i < inputLen ; i ++ { # t = <- input # s . newTask ( t ) # } # default : # } # # for s . preTasks . Len () > 0 && s . preTasks . tasks [ 0 ]. state () != wait { # temp := heap . Pop ( s . preTasks ).(* task ) # heap . Push ( s . runningTasks , temp ) # } # if s . runningTasks . Len () > 0 { # s . runningTasks . tasks [ 0 ]. run () # output [ 0 ] <- s . runningTasks . tasks [ 0 ] # if s . runningTasks . tasks [ 0 ]. state () == finish { # s . finishedCnt ++ # s . totalCompletedTime += s . runningTasks . tasks [ 0 ]. finishTime - s . runningTasks . tasks [ 0 ]. startTime # heap . Pop ( s . runningTasks ) # } # } else { # output [ 0 ] <- nil # } # <- output [ 1 ] # s . clk ++ # }
return int ( id .( uint 3 2 ))
if uintptr ( bit ) > 3 2 { # panic (" STR ") # } # if reg < registerBase || reg >= registerEnd { # panic (" STR ") # } # return ( reg - registerBase )* 3 2 + uintptr ( bit )* 4 + bitbandBase
half := func ( n int ) ( int , bool ) { # return n / 2 , n % 2 == 0 # } # # fmt . Println ( half ( 2 ))
ret , sum 1 , sum 2 := 0 , 0 , 0 # arr_pre_max := arr [ 0 ] # tarr := make ([] int , len ( arr )) # copy ( tarr , arr ) # sort . Ints ( tarr ) # for i := 0 ; i < len ( arr ); i ++ { # x , y := arr [ i ], tarr [ i ] # sum 1 , sum 2 = sum 1 + x , sum 2 + y # if x > arr_pre_max { # arr_pre_max = x # } # if arr_pre_max == y && sum 1 == sum 2 { # ret ++ # } # } # return ret
pairs := [...][ 2 ] int {{ 6 , 1 3 }, { 1 0 0 0 1 , 1 0 4 7 4 3 }} # for _ , pair := range pairs { # in , out := pair [ 0 ], pair [ 1 ] # if x := p 7 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # } # }
testCases := [][] int { # { 5 , 1 0 , - 5 }, # {- 2 , 2 , - 1 , - 2 }, # {- 2 , - 1 , 1 , 2 }, # { 8 , - 8 }, # { 1 0 , 2 , - 5 }, # } # # expected := [][] int { # { 5 , 1 0 }, # {- 2 }, # {- 2 , - 1 , 1 , 2 }, # {}, # { 1 0 }, # } # # for index , asteroids := range testCases { # if res := asteroidCollision ( asteroids ); ! reflect . DeepEqual ( res , expected [ index ]) { # t . Errorf (" STR ", expected [ index ], res ) # } # }
positive := make ([] int , 1 0 0 0 1 ) # negative := make ([] int , 1 0 0 0 1 ) # for i := 0 ; i < len ( nums ); i ++ { # if nums [ i ] >= 0 { # positive [ nums [ i ]]++ # } else { # negative [- nums [ i ]]++ # } # } # flag := k # for i := 1 0 0 0 0 ; i > - 1 ; i -- { # flag -= positive [ i ] # if flag <= 0 { # return i # } # } # for i := 0 ; i < 1 0 0 0 1 ; i ++ { # flag -= negative [ i ] # if flag <= 0 { # return - i # } # } # return 0
cases := [] struct { # name string # inputs [][] int # expect [] int # }{ # {" STR ", [][] int {{ 5 , 7 , 7 , 8 , 8 , 1 0 }, { 8 }}, [] int { 3 , 4 }}, # {" STR ", [][] int {{ 5 , 7 , 7 , 8 , 8 , 1 0 }, { 6 }}, [] int {- 1 , - 1 }}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := searchRange ( c . inputs [ 0 ], c . inputs [ 1 ][ 0 ]) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
m := make ( map [ int ] int , len ( nums )) # # for i , b := range nums { # if j , ok := m [ target - b ]; ok { # return [] int { j , i } # } # # m [ nums [ i ]] = i # } # # return nil
if n <= 0 || k <= 0 || k > n { # return [][] int {} # } # res := make ([][] int , 0 ) # c := make ([] int , 0 , k ) # generateCombinations ( n , k , 1 , c , & res ) # return res
var x int # for _ , v := range nums { # x = x ^ v # } # return x
if nil == root { # return 0 # } # # sum := 0 # if nil != root . Left && nil == root . Left . Left && nil == root . Left . Right { # sum += root . Left . Val # } else { # sum += sumOfLeftLeaves ( root . Left ) # } # # sum += sumOfLeftLeaves ( root . Right ) # return sum
i , s , w , sum := 1 , 0 , 1 , 1 # for { # for n := 0 ; n < 5 ; n ++ { # if n < 2 { s ++ } # if n == 0 { # w += 2 # } else { # i += s # sum += i # } # } # if w == LIMIT { break } # } # println ( sum )
colors := make ([] color , len ( graph )) # res := make ([] int , 0 , len ( graph )) # # for i := 0 ; i < len ( graph ); i ++ { # if isSafe ( i , colors , graph ) { # res = append ( res , i ) # } # } # # return res
s . mtx . RLock () # defer s . mtx . RUnlock () # p , ok := s . m [ profileID ] # if ! ok { # return [] Address {}, ErrNotFound # } # return p . Addresses , nil
t . Parallel () # # for _ , tc := range testcases { # if result := PascalTriangleRow ( tc . row ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
ans , adjGarden , flowerUsed := make ([] int , N ), make ([][] int , N ), make ([][ 4 ] bool , N ) # for _ , path := range paths { # if path [ 0 ] > path [ 1 ] { # path [ 0 ], path [ 1 ] = path [ 1 ], path [ 0 ] # } # adjGarden [ path [ 0 ]- 1 ] = append ( adjGarden [ path [ 0 ]- 1 ], path [ 1 ]- 1 ) # } # for i := 0 ; i < N ; i ++ { # for flower , used := range flowerUsed [ i ] { # if ! used { # ans [ i ] = flower + 1 # break # } # } # for _ , garden := range adjGarden [ i ] { # flowerUsed [ garden ][ ans [ i ]- 1 ] = true # } # } # return ans
cases := [] struct { # name string # input 1 float 6 4 # input 2 int # expect float 6 4 # }{ # {" STR ", 2 . 0 0 0 0 0 , 1 0 , 1 0 2 4 . 0 0 0 0 0 }, # {" STR ", 2 . 1 0 0 0 0 , 3 , 9 . 2 6 1 0 0 }, # {" STR ", 2 . 0 0 0 0 0 , - 2 , 0 . 2 5 0 0 0 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := fmt . Sprintf (" STR ", myPow ( c . input 1 , c . input 2 )) # if ! reflect . DeepEqual ( got , fmt . Sprintf (" STR ", c . expect )) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 , c . input 2 ) # } # }) # }
t . Parallel () # # for _ , tc := range testcases { # if res := DecryptSecretXorMessage ( tc . encoded ); res != tc . decoded { # t . Errorf (" STR ", tc . decoded , res ) # } # }
size := len ( nums ) # if 2 > size { # return size # } # # first := make ( map [ int ] int , size ) # count := make ( map [ int ] int , size ) # maxCount := 1 # minLen := size # for i , v := range nums { # count [ v ]++ # if 1 == count [ v ] { # first [ v ] = i # } else { # l := i - first [ v ] + 1 # if maxCount < count [ v ] || ( maxCount == count [ v ] && l < minLen ) { # maxCount = count [ v ] # minLen = l # } # } # } # # if len ( count ) == size { # return 1 # } # return minLen
answer := new ( hoop ) # # answer . seen = make ( map [[ N ] bool ] bool ) # # tasty := [ N ] bool {} # answer . seen [ tasty ] = true # # tasty [ 0 ] = true # answer . seen [ tasty ] = true # # answer . fill = N # return answer
var ctr int = 0 # # for cur := ll . Head ; cur != nil ; cur = cur . Next { # ctr += 1 # } # # return ctr
ans , min := 0 , 0 # for i , v := range prices { # if v < prices [ min ] { # min = i # } else if v - prices [ min ] > ans { # ans = v - prices [ min ] # } # } # return ans
stack , result := make ([]* TreeNode , 0 ), make ([] int , 0 ) # var prev * TreeNode # node := root # for node != nil || len ( stack ) > 0 { # for node != nil { # stack = append ( stack , node ) # node = node . Left # } # # node = stack [ len ( stack )- 1 ] # if node . Right != nil && node . Right != prev { # node = node . Right # } else { # result = append ( result , node . Val ) # stack = stack [: len ( stack )- 1 ] # prev , node = node , nil # } # } # # return result
sort . Ints ( nums ) # res := [][] int {} # for i := 0 ; i < len ( nums )- 3 ; i ++ { # if i > 0 && nums [ i - 1 ] == nums [ i ] { # continue # } # for j := i + 1 ; j < len ( nums )- 2 ; j ++ { # if j > i + 1 && nums [ j - 1 ] == nums [ j ] { # continue # } # l , r := j + 1 , len ( nums )- 1 # for l < r { # if l > j + 1 && nums [ l - 1 ] == nums [ l ] { # l ++ # continue # } # tmp := nums [ i ] + nums [ j ] + nums [ l ] + nums [ r ] # if tmp == target { # res = append ( res , [] int { nums [ i ], nums [ j ], nums [ l ], nums [ r ]}) # l ++ # r -- # } else if tmp < target { # l ++ # } else { # r -- # } # } # } # } # return res
if root == nil { # return nil # } # # result , _ := help 8 6 5 ( root ) # return result
h := NewMin () # # h . Insert ( Int ( 8 )) # h . Insert ( Int ( 7 )) # h . Insert ( Int ( 6 )) # h . Insert ( Int ( 3 )) # h . Insert ( Int ( 1 )) # h . Insert ( Int ( 0 )) # h . Insert ( Int ( 2 )) # h . Insert ( Int ( 4 )) # h . Insert ( Int ( 9 )) # h . Insert ( Int ( 5 )) # # sorted := make ([] Int , 0 ) # for h . Len () > 0 { # sorted = append ( sorted , h . Extract ().( Int )) # } # # for i := 0 ; i < len ( sorted )- 2 ; i ++ { # if sorted [ i ] > sorted [ i + 1 ] { # fmt . Println ( sorted ) # t . Error () # } # }
t := & node {} # h := & node { next : t } # return MyLinkedList { # head : h , # tail : t , # }
tests := [...] testType { # { # nums : [] int { 1 , 1 2 , - 5 , - 6 , 5 0 , 3 }, # k : 4 , # want : 1 2 . 7 5 , # }, # } # for _ , tt := range tests { # got := findMaxAverage ( tt . nums , tt . k ) # if got != tt . want { # t . Fatalf (" STR ", tt . nums , tt . k , got , tt . want ) # } # }
cases := [] struct { # name string # inputs * TreeNode # expect [][] int # }{ # {" STR ", & TreeNode { 3 , & TreeNode { 9 , nil , nil }, & TreeNode { 2 0 , & TreeNode { 1 5 , nil , nil }, & TreeNode { 7 , nil , nil }}}, [][] int { # { 3 }, { 2 0 , 9 }, { 1 5 , 7 }, # }}, # {" STR ", & TreeNode { 1 , nil , nil }, [][] int {{ 1 }}}, # {" STR ", nil , [][] int {}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
sort . Ints ( nums ) # res := [][] int {} # # for i := range nums { # if nums [ i ] > 0 { # break # } # if i > 0 && nums [ i ] == nums [ i - 1 ] { # continue # } # # l , r := i + 1 , len ( nums )- 1 # # for l < r { # s := nums [ i ] + nums [ l ] + nums [ r ] # switch { # case s < 0 : # l ++ # case s > 0 : # r -- # default : # res = append ( res , [] int { nums [ i ], nums [ l ], nums [ r ]}) # l , r = next ( nums , l , r ) # } # } # } # # return res
orig := [] rune ( str ) # rev := make ([] rune , len ( orig )) # for i := 0 ; i < len ( orig ); i ++ { # rev [ i ] = orig [ len ( orig )- 1 - i ] # } # return isKPalindromeBrute ( orig , rev , len ( orig ), len ( rev )) <= k * 2
ctoi := func ( chr rune ) int { # return int ( uint 8 ( chr ) - ' 0 ') # } # # ns := make ([] int , len ( N )) # for i , chr := range N { # ns [ i ] = ctoi ( chr ) # } # # product := 1 # for _ , n := range ns [: step ] { # product *= n # } # max := product # # zeroes := 0 # for i := step ; i < len ( N ); i ++ { # prev := ns [ i - step ] # curr := ns [ i ] # # if curr == 0 { # zeroes ++ # } else { # product *= curr # } # # if prev == 0 { # zeroes -- # } else { # product /= prev # } # # if product > max && zeroes == 0 { # max = product # } # } # # fmt . Println ( max )
for i := 1 ; i < len ( arr ); i ++ { # for j := i ; j > 0 ; j -- { # if arr [ j - 1 ] > arr [ j ] { # arr [ j - 1 ], arr [ j ] = arr [ j ], arr [ j - 1 ] # } # } # }
tests := [...] testType { # { # in : 4 , # want : " STR ", # }, # { # in : 2 , # want : " STR ", # }, # { # in : 7 , # want : " STR ", # }, # { # in : 3 0 , # want : " STR ", # }, # } # for _ , tt := range tests { # got := generateTheString ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
qs := [] question 5 0 9 { # # { # para 5 0 9 { 1 }, # ans 5 0 9 { 1 }, # }, # # { # para 5 0 9 { 2 }, # ans 5 0 9 { 1 }, # }, # # { # para 5 0 9 { 3 }, # ans 5 0 9 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 0 9 , q . para 5 0 9 # fmt . Printf (" STR ", p , fib ( p . one )) # } # fmt . Printf (" STR ")
roots := os . Args [ 1 :] # if len ( roots ) == 0 { # roots = [] string {" STR "} # } # # go func () { # os . Stdin . Read ( make ([] byte , 1 )) # close ( done ) # }() # # fileSizes := make ( chan int 6 4 ) # var n sync . WaitGroup # for _ , root := range roots { # n . Add ( 1 ) # go walkDir ( root , & n , fileSizes ) # } # go func () { # n . Wait () # close ( fileSizes ) # }() # # tick := time . Tick ( 5 0 0 * time . Millisecond ) # var nfiles , nbytes int 6 4 # loop : # for { # select { # case <- done : # for range fileSizes { # } # return # case size , ok := <- fileSizes : # if ! ok { # break loop # } # nfiles ++ # nbytes += size # case <- tick : # printDiskUsage ( nfiles , nbytes ) # } # } # printDiskUsage ( nfiles , nbytes )
if length := len ( str ); length < 2 { # return 1 # } # var count int # if first := str [ 0 ]; first == ' 1 ' || ( first == ' 2 ' && str [ 1 ] < ' 7 ') { # count = NumberOfDecodings ( str [ 2 :]) # } # count += NumberOfDecodings ( str [ 1 :]) # return count
if numRows == 1 || len ( s ) <= numRows { # return s # } # bs := [] byte {} # p := numRows * 2 - 2 # for i := 0 ; i < len ( s ); i += p { # bs = append ( bs , s [ i ]) # } # for i := 1 ; i <= numRows - 2 ; i ++ { # bs = append ( bs , s [ i ]) # # for j := p ; j - i < len ( s ); j += p { # bs = append ( bs , s [ j - i ]) # if i + j < len ( s ) { # bs = append ( bs , s [ i + j ]) # } # } # } # for i := numRows - 1 ; i < len ( s ); i += p { # bs = append ( bs , s [ i ]) # } # return string ( bs )
tests := [] string { # " STR ", # " STR ", # " STR ", # " STR ", # } # results := [] string { # " STR ", # " STR ", # " STR ", # " STR ", # } # caseNums := 4 # for i := 0 ; i < caseNums ; i ++ { # if ret := longestPalindrome ( tests [ i ]); ret != results [ i ] { # t . Fatalf (" STR ", i , ret , results [ i ]) # } # }
qs := [] question 7 6 7 { # { # para 7 6 7 {" STR "}, # ans 7 6 7 {" STR "}, # }, # # { # para 7 6 7 {" STR "}, # ans 7 6 7 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 6 7 , q . para 7 6 7 # fmt . Printf (" STR ", p , reorganizeString ( p . one )) # } # fmt . Printf (" STR ")
sequence := [] int {} # # for i := 0 ; i < number ; i ++ { # res := generateNthTerm ( i ) # sequence = append ( sequence , res ) # } # # return sequence
sum := 0 # for i := 1 ; i < 1 0 0 0 0 0 0 ; i ++ { # if isDoublePalindrome ( i ) { # sum += i # } # } # fmt . Println ( sum )
res := make ([] int , 0 , len ( A )) # # sumEven := 0 # for _ , v := range A { # if v % 2 == 0 { # sumEven += v # } # } # # for _ , q := range queries { # v , i := q [ 0 ], q [ 1 ] # old , new := A [ i ], A [ i ]+ v # if old % 2 == 0 { # sumEven -= old # } # if new % 2 == 0 { # sumEven += new # } # res = append ( res , sumEven ) # A [ i ] = new # } # # return res
cases := [] struct { # name string # queries [] int # m int # expect [] int # }{ # {" STR ", [] int { 3 , 1 , 2 , 1 }, 5 , [] int { 2 , 1 , 2 , 1 }}, # {" STR ", [] int { 4 , 1 , 2 , 2 }, 4 , [] int { 3 , 1 , 2 , 0 }}, # {" STR ", [] int { 7 , 5 , 5 , 8 , 3 }, 8 , [] int { 6 , 5 , 0 , 7 , 5 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . queries , c . m ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . queries , c . m ) # } # }) # }
return Solution { head : head }
alphabet := [] rune ( c ) # a := make ([] int , len ( alphabet )* k ) # var seq [] int # var db func ( int , int ) # db = func ( t , p int ) { # if t > k { # if k % p == 0 { # seq = append ( seq , a [ 1 : p + 1 ]...) # } # } else { # a [ t ] = a [ t - p ] # db ( t + 1 , p ) # for j := a [ t - p ] + 1 ; j < len ( c ); j ++ { # a [ t ] = j # db ( t + 1 , t ) # } # } # } # db ( 1 , 1 ) # result := make ([] rune , len ( seq )) # for i , v := range seq { # result [ i ] = alphabet [ v ] # } # return string ( result )
digits := make ([] int , 1 0 ) # for _ , digit := range secret { # digits [ int ( digit -' 0 ')]++ # } # # bull := 0 # for i := 0 ; i < len ( guess ); i ++ { # if secret [ i ] == guess [ i ] { # bull ++ # digits [ int ( guess [ i ]-' 0 ')]-- # } # } # # cow := 0 # for i := 0 ; i < len ( guess ); i ++ { # if secret [ i ] != guess [ i ] && digits [ int ( guess [ i ]-' 0 ')] > 0 { # cow ++ # digits [ int ( guess [ i ]-' 0 ')]-- # } # } # # return fmt . Sprintf (" STR ", bull , cow )
var res uint = 1 # for power > 0 { # # if ( power & 1 ) != 0 { # res = res * n # } # # power = power >> 1 # n = n * n # } # return res
return *(* uint 6 4 )( unsafe . Pointer (& f ))
n := len ( nums ) # for i := 0 ; i < n ; i ++ { # if j := nums [ i ] - 1 ; j >= 0 && j < n { # if nums [ i ] != nums [ j ] { # nums [ i ], nums [ j ] = nums [ j ], nums [ i ] # i -- # } # } # } # for i := 0 ; i < n ; i ++ { # if i != nums [ i ]- 1 { # return i + 1 # } # } # return n + 1
s , n , p , z := " STR ", 0 , 0 , 0 # for a := 9 9 9 ; a > 8 0 0 ; a -- { # L : for b := 9 9 9 ; b > 8 0 0 ; b -- { # n = a * b # s = strconv . Itoa ( n ) # z = int ( len ( s )/ 2 ) # for i := 0 ; i < z ; i ++ { # if s [ i ] != s [ len ( s ) - i - 1 ] { continue L } # } # if p == 0 || n > p { p = n } # } # } # fmt . Println ( p )
var n int # for _ , c := range s { # i := int ( c -' A ') + 1 # n = 2 6 * n + i # } # return n
Points := make ([] point , n ) # for i := 0 ; i < n ; i ++ { # a := makePoint ( float 6 4 ( i ), float 6 4 ( i * i )) # # Points [ i ] = * a # } # # for i := 0 ; i < b . N ; i ++ { # DivideAndConquer ( Points ) # }
parentX , heightX := helper 9 9 3 ( root , 0 , x ) # parentY , heightY := helper 9 9 3 ( root , 0 , y ) # return parentX != parentY && heightX == heightY
l := len ( nums ) # l 2 := 2 * l # ret := make ([] int , l ) # index := make ([] int , l 2 ) # for i := l ; i < l 2 ; i ++ { # index [ i ] = i - l # } # cur := l # for i := l - 1 ; i >= 0 ; i -- { # for cur < l 2 && nums [ index [ cur ]] <= nums [ i ] { # cur ++ # } # if cur == l 2 { # ret [ i ] = - 1 # } else { # ret [ i ] = nums [ index [ cur ]] # } # cur -- # index [ cur ] = i # } # return ret
if len ( A ) == 0 && len ( B ) == 0 { # return true # } # if len ( A ) == 0 || len ( B ) == 0 { # return false # } # a , b := [] byte ( A ), [] byte ( B ) # for k , v := range a { # if v == b [ 0 ] { # c := a [ k :] # c = append ( c , a [: k ]...) # if string ( c ) == string ( b ) { # return true # } # } # } # return false
wc , l := 0 , len ( s )- 1 # for i := l ; i >= 0 ; i -- { # if s [ i ] != " STR " { # wc ++ # } else if wc > 0 { # return wc # } # } # return wc
dic := make ( map [ string ] int , len ( words )) # for _ , w := range words { # dic [ w ]++ # } # # res := 0 # for w := range dic { # if isMatching ( s , w ) { # res += dic [ w ] # } # } # # return res
var n int # for _ , w := range word { # if w >= ' A ' && w <= ' Z ' { # n ++ # } # } # return ( n == 0 || n == len ( word ) || ( n == 1 && word [ 0 ] >= ' A ' && word [ 0 ] <= ' Z '))
qs := [] question 5 9 4 { # # { # para 5 9 4 {[] int { 1 , 3 , 2 , 2 , 5 , 2 , 3 , 7 }}, # ans 5 9 4 { 5 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 5 9 4 , q . para 5 9 4 # fmt . Printf (" STR ", p , findLHS ( p . one )) # } # fmt . Printf (" STR ")
res := [][] int {} # var recur func (* TreeNode , int , [] int ) # recur = func ( node * TreeNode , sum int , path [] int ) { # if node == nil { # return # } # sum -= node . Val # path = append ( path , node . Val ) # if node . Left == nil && node . Right == nil { # if sum == 0 { # tmp := make ([] int , len ( path )) # copy ( tmp , path ) # res = append ( res , tmp ) # return # } # } # recur ( node . Left , sum , path ) # recur ( node . Right , sum , path ) # # } # recur ( root , sum , [] int {}) # return res
n := len ( A ) # if n <= 2 { # return false # } # pass := 0 # for ; pass + 1 < n && A [ pass ] < A [ pass + 1 ]; pass ++ { # } # if pass == 0 || pass == n - 1 { # return false # } # for ; pass + 1 < n && A [ pass ] > A [ pass + 1 ]; pass ++ { # } # return pass == n - 1
sort . Ints ( nums ) # var result [][] int # length := len ( nums ) - 2 # end := len ( nums ) - 1 # for i := 0 ; i < length ; i ++ { # if nums [ i ] > 0 { # break # } # if i > 0 && nums [ i - 1 ] == nums [ i ] { # continue # } # left , right := i + 1 , end # for left < right { # r := nums [ i ] + nums [ left ] + nums [ right ] # if r < 0 { # left ++ # } else if r > 0 { # right -- # } else { # result = append ( result , [] int { nums [ i ], nums [ left ], nums [ right ]}) # for left < right { # if nums [ left ] == nums [ left + 1 ] { # left ++ # } else if nums [ right ] == nums [ right - 1 ] { # right -- # } else { # break # } # } # left ++ # right -- # } # } # } # return result
if b == 0 { # return a % mod # } # # if answer , ok := memo [[ 2 ] int 6 4 { a , b }]; ok { # return answer # } # # answer := int 6 4 ( 1 ) # for i := int 6 4 ( 0 ); i < b ; i ++ { # answer *= a # answer = answer % mod # } # # memo [[ 2 ] int 6 4 { a , b }] = answer # # return answer
count := make ([] int , 1 2 8 ) # for _ , c := range s { # count [ c ]++ # } # ans := 0 # for _ , v := range count { # ans += v / 2 * 2 # if ans % 2 == 0 && v % 2 == 1 { # ans ++ # } # } # return ans
low := int 3 2 ( value ) # high := int 3 2 ( value >> 3 2 ) # self . table [ index ]. Num = low # self . table [ index + 1 ]. Num = high
upperbound := 1 0 0 0 # # value := 1 # answer := 0 # for value < upperbound { # if ( value % 3 == 0 ) || ( value % 5 == 0 ) { # answer = answer + value # } # value ++ # } # # fmt . Printf (" STR ", answer )
for i , j := 0 , len ( s )- 1 ; i < j ; i , j = i + 1 , j - 1 { # s [ i ], s [ j ] = s [ j ], s [ i ] # }
if len ( nums ) == 0 { # return 0 # } # begin := 0 # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] != nums [ begin ] || begin == 0 || nums [ i ] != nums [ begin - 1 ] { # begin ++ # nums [ begin ], nums [ i ] = nums [ i ], nums [ begin ] # } # } # return begin + 1
return self . pc
return new ( FibHeap ). Init ( new ( defalutFibHeapLessMixin ))
if len ( s ) != len ( t ) { # return false # } # ss , tt := countChar ( s ), countChar ( t ) # for k , v := range ss { # v 2 , ok := tt [ k ] # if ! ok || v 2 != v { # return false # } # } # return true
ans := make ([] byte , 0 ) # # for n > 0 { # n -- # ans = append ( ans , byte ( n % 2 6 )+' A ') # n /= 2 6 # } # # for i , j := 0 , len ( ans )- 1 ; i < j ; i , j = i + 1 , j - 1 { # ans [ i ], ans [ j ] = ans [ j ], ans [ i ] # } # return string ( ans )
if n == 1 { # return 0 # } # for i := 2 ; i < n ; i ++ { # if n % i == 0 { # return i + minSteps ( n / i ) # } # } # return n
if n == 0 { # return false # } # # return n &( n - 1 ) == 0
testData := [][] int { # { 0 , 1 , 0 , 3 , 1 2 }, # } # # expectedData := [][] int { # { 1 , 3 , 1 2 , 0 , 0 }, # } # # for index , data := range testData { # if moveZeroes ( data ); ! reflect . DeepEqual ( data , expectedData [ index ]) { # t . Errorf (" STR ", expectedData [ index ], data ) # } # }
n := len ( S ) # res := 0 # L : # for _ , word := range words { # m := len ( word ) # j := 0 # for i := 0 ; i < n ; i ++ { # if j < m && S [ i ] == word [ j ] { # j ++ # } else if i > 1 && S [ i ] == S [ i - 1 ] && S [ i - 1 ] == S [ i - 2 ] { # } else if 0 < i && i < n - 1 && S [ i - 1 ] == S [ i ] && S [ i ] == S [ i + 1 ] { # } else { # continue L # } # } # if j == m { # res ++ # } # } # return res
if n & 1 == 1 { # n -- # } # str := fmt . Sprintf (" STR ", n ) # var sb strings . Builder # for i := 1 ; i < len ( str ); i ++ { # d := str [ i ] - ' 0 ' # if ( str [ i - 1 ]-' 0 ')& 1 == 0 { # switch d { # case 0 , 1 : # sb . WriteRune (' 0 ') # case 2 , 3 : # sb . WriteRune (' 1 ') # case 4 , 5 : # sb . WriteRune (' 2 ') # case 6 , 7 : # sb . WriteRune (' 3 ') # case 8 , 9 : # sb . WriteRune (' 4 ') # } # } else { # switch d { # case 0 , 1 : # sb . WriteRune (' 5 ') # case 2 , 3 : # sb . WriteRune (' 6 ') # case 4 , 5 : # sb . WriteRune (' 7 ') # case 6 , 7 : # sb . WriteRune (' 8 ') # case 8 , 9 : # sb . WriteRune (' 9 ') # } # } # } # res , _ := strconv . Atoi ( sb . String ()) # return res
fmt . Fprint ( os . Stderr , " STR ") # var name string # fmt . Scanln (& name ) # # fmt . Fprint ( os . Stderr , " STR ") # var email string # fmt . Scanln (& email ) # gravatarHash := getGravatarHash ( email ) # fmt . Println (`<! DOCTYPE html > # < html > # < head > # < script > # console . log (" STR "); # </ script > # </ head > # < body > # < h 1 >` + name + `</ h 1 > # < img src =" http : # </ body > # </ html >`)
if len ( nums ) == 0 { # return 0 # } # result := nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # result = gcd ( nums [ i ], result ) # } # return result
for c := 3 ; c > 0 ; c ++ { # # for b := 2 ; b < c ; b ++ { # # for a := 1 ; a < b ; a ++ { # # if ( a * a + b * b == c * c ) && a + b + c == 1 0 0 0 { # # fmt . Println ( a * b * c ) # # return # } # # } # # } # # } #
return PhoneDirectory { # max : maxNumbers , # Used : map [ int ] struct {}{}, # }
node 7 := BinaryTreeNode { value : 7 , left : nil , right : nil } # node 6 := BinaryTreeNode { value : 6 , left : nil , right : nil } # node 5 := BinaryTreeNode { value : 5 , left : & node 7 , right : nil } # node 4 := BinaryTreeNode { value : 4 , left : nil , right : nil } # node 3 := BinaryTreeNode { value : 3 , left : nil , right : & node 6 } # node 2 := BinaryTreeNode { value : 2 , left : & node 4 , right : & node 5 } # node 1 := BinaryTreeNode { value : 1 , left : & node 2 , right : & node 3 } # # fmt . Println ( treeDepth (& node 1 )) # # fmt . Println ( isBalance (& node 1 )) #
result := [][] int {} # for i := 0 ; i < numRows ; i ++ { # row := [] int {} # for j := 0 ; j < i + 1 ; j ++ { # if j == 0 || j == i { # row = append ( row , 1 ) # } else if i > 1 { # row = append ( row , result [ i - 1 ][ j - 1 ]+ result [ i - 1 ][ j ]) # } # } # result = append ( result , row ) # } # return result
cases := [] struct { # name string # inputs * ListNode # expect * ListNode # }{ # {" STR ", # & ListNode { 1 , & ListNode { 1 , & ListNode { 2 , nil }}}, # & ListNode { 1 , & ListNode { 2 , nil }}}, # # {" STR ", # & ListNode { 1 , & ListNode { 1 , & ListNode { 2 , & ListNode { 3 , & ListNode { 3 , nil }}}}}, # & ListNode { 1 , & ListNode { 2 , & ListNode { 3 , nil }}}}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := deleteDuplicates ( c . inputs ) # if ! IsEqual ( ret , c . expect ) { # PList ( ret ) # PList ( c . expect ) # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # # } # }) # }
tree := make ([][] int , N ) # for _ , e := range edges { # i , j := e [ 0 ], e [ 1 ] # tree [ i ] = append ( tree [ i ], j ) # tree [ j ] = append ( tree [ j ], i ) # } # # res := make ([] int , N ) # count := make ([] int , N ) # # isSeen := make ([] bool , N ) # deepFirstSearch ( 0 , isSeen , count , res , tree ) # # # # isSeen = make ([] bool , N ) # deepFirstMove ( 0 , isSeen , count , res , tree ) # # return res
fmt . Println ( reverseStr (" STR ", 2 ))
defer TimeTaken ( time . Now (), " STR ") # # num := 6 0 0 8 5 1 4 7 5 1 4 3 # for ; num % 2 == 0 ; num = num / 2 {} # for i := 3 ; i <= int ( math . Sqrt ( float 6 4 ( num ))+ 1 ); i = i + 2 { # for ; num % i == 0 && i != num ; num = num / i {} # } # fmt . Println ( num )
Args = runtime_args ()
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", # [][] int { # { 2 }, # { 3 , 4 }, # { 6 , 5 , 7 }, # { 4 , 1 , 8 , 3 }, # }, # 1 1 }, # {" STR ", # [][] int { # { 1 }, # { 2 , 3 }, # }, # 3 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := minimumTotal 1 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if digits == " STR " { # return nil # } # # ret := [] string {" STR "} # # for i := 0 ; i < len ( digits ); i ++ { # temp := [] string {} # for j := 0 ; j < len ( ret ); j ++ { # for k := 0 ; k < len ( m [ digits [ i ]]); k ++ { # temp = append ( temp , ret [ j ]+ m [ digits [ i ]][ k ]) # } # } # # ret = temp # } # # return ret
i , j := len ( matrix )- 1 , 0 # for i >= 0 && j < len ( matrix [ i ]) { # switch { # case matrix [ i ][ j ] < target : # j ++ # case matrix [ i ][ j ] > target : # i -- # default : # return true # } # } # return false
result := make ( map [ State ] int ) # probs := buildProbabilities ( states ) # r := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # for i := 0 ; i < numSteps ; i ++ { # p := r . Float 6 4 () # d := probs [ start ] # var last float 6 4 # for _ , t := range d { # if p > last && p < t . p { # result [ t . s ]++ # start = t . s # break # } # last = t . p # } # } # return result
n := len ( s ) # bs , i , j := [] byte ( s ), 0 , n - 1 # for { # for i < n - 1 && ! isVowel ( bs [ i ]) { # i ++ # } # for j > 0 && ! isVowel ( bs [ j ]) { # j -- # } # if i >= j { # break # } # bs [ i ], bs [ j ] = bs [ j ], bs [ i ] # i ++ # j -- # } # return string ( bs )
sat , res := SegmentAreaTree {}, 0 # posXMap , posX , posYMap , posY , lines := discretization 8 5 0 ( rectangles ) # tmp := make ([] int , len ( posYMap )) # for i := 0 ; i < len ( tmp )- 1 ; i ++ { # tmp [ i ] = posY [ i + 1 ] - posY [ i ] # } # sat . Init ( tmp , func ( i , j int ) int { # return i + j # }) # for i := 0 ; i < len ( posY )- 1 ; i ++ { # tmp [ i ] = posY [ i + 1 ] - posY [ i ] # } # for i := 0 ; i < len ( posX )- 1 ; i ++ { # for _ , v := range lines [ posXMap [ posX [ i ]]] { # sat . Update ( posYMap [ v . start ], posYMap [ v . end ], v . state ) # } # res += (( posX [ i + 1 ] - posX [ i ]) * sat . Query ( 0 , len ( posY )- 1 )) % 1 0 0 0 0 0 0 0 0 7 # } # return res % 1 0 0 0 0 0 0 0 0 7
n := len ( nums ) + 2 # inums := make ([] int , n ) # inums [ 0 ], inums [ n - 1 ] = 1 , 1 # copy ( inums [ 1 :], nums ) # # m := make ([][] int , n ) # for i := 0 ; i < n ; i ++ { # m [ i ] = make ([] int , n ) # } # # for i := 2 ; i < n ; i ++ { # for l := 0 ; l < n - i ; l ++ { # r := l + i # for j := l + 1 ; j < r ; j ++ { # tmp := m [ l ][ j ] + inums [ l ]* inums [ j ]* inums [ r ] + m [ j ][ r ] # if tmp > m [ l ][ r ] { # m [ l ][ r ] = tmp # } # # } # } # } # return m [ 0 ][ n - 1 ]
if len ( nums ) == 0 { # return nil # } # mid := len ( nums ) / 2 # return & TreeNode { # Val : nums [ mid ], # Left : sortedArrayToBST ( nums [: mid ]), # Right : sortedArrayToBST ( nums [ mid + 1 :]), # }
fmt . Println (" STR ", os . TempDir ()) # http . ListenAndServe (" STR ", http . HandlerFunc ( func ( res http . ResponseWriter , req * http . Request ) { # if req . Method == " STR " { # src , hdr , err := req . FormFile (" STR ") # if err != nil { # http . Error ( res , err . Error (), 5 0 0 ) # return # } # defer src . Close () # # dst , err := os . Create ( filepath . Join ( os . TempDir (), hdr . Filename )) # if err != nil { # http . Error ( res , err . Error (), 5 0 0 ) # return # } # defer dst . Close () # # io . Copy ( dst , src ) # } # # res . Header (). Set (" STR ", " STR ") # io . WriteString ( res , ` # < form method =" STR " enctype =" STR "> # < input type =" STR " name =" STR "> # < input type =" STR "> # </ form > # `) # }))
var tests = [] struct { # input string # want bool # }{ # {"", true }, # {" STR ", true }, # {" STR ", true }, # {" STR ", false }, # {" STR ", true }, # {" STR ", true }, # {" STR ", true }, # {" STR ", true }, # {" STR ", true }, # {" STR ", true }, # {" STR ", true }, # {" STR ", false }, # {" STR ", false }, # } # for _ , test := range tests { # if got := IsPalindrome ( test . input ); got != test . want { # t . Errorf (" STR ", test . input , got ) # } # }
op := t . lDOperation . init (" STR ", cost ) # op . lDCompute = t # return t
return & Node { Value : i }
var res int # c := common ( root , p , q ) # path ( c , p , q , 0 , & res ) # return res
var nodes [] string # for nil != head { # nodes = append ( nodes , strconv . Itoa ( head . Val )) # head = head . Next # } # return strings . Join ( nodes , " STR ")
t . Parallel () # for _ , tc := range testcases { # var stack StackHeap # for i := range tc . items { # stack . Push ( tc . items [ i ]) # } # for i := range tc . items { # if result := stack . Pop (); result != tc . items [ len ( tc . items )- 1 - i ] { # t . Errorf (" STR ", tc . items [ len ( tc . items )- 1 - i ], result ) # } # } # }
if n == 1 { # return false # } # lim := int ( math . Sqrt ( float 6 4 ( n ))) + 1 # for i := 2 ; i < lim ; i ++ { # if n % i == 0 { # return false # } # } # # return true
qs := [] question 9 6 1 { # { # para 9 6 1 {[] int { 1 , 2 , 3 , 3 }}, # ans 9 6 1 { 3 }, # }, # # { # para 9 6 1 {[] int { 2 , 1 , 2 , 5 , 3 , 2 }}, # ans 9 6 1 { 2 }, # }, # # { # para 9 6 1 {[] int { 5 , 1 , 5 , 2 , 5 , 3 , 5 , 4 }}, # ans 9 6 1 { 5 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 6 1 , q . para 9 6 1 # fmt . Printf (" STR ", p , repeatedNTimes ( p . one )) # } # fmt . Printf (" STR ")
n := len ( A ) # # indexes := [ 1 0 0 0 1 ][] int {} # for i := 0 ; i < n ; i ++ { # indexes [ A [ i ]] = append ( indexes [ A [ i ]], i ) # } # # var dfs func ( int , int ) int # dfs = func ( j , diff int ) int { # next := A [ j ] + diff # if next < 0 || 1 0 0 0 0 < next { # return 0 # } # for _ , k := range indexes [ next ] { # if j < k { # return 1 + dfs ( k , diff ) # } # } # return 0 # } # # res := 0 # for i := 0 ; i < n ; i ++ { # for j := i + 1 ; j < n ; j ++ { # diff := A [ j ] - A [ i ] # res = max ( res , 2 + dfs ( j , diff )) # } # } # # return res
tests := [...] testType { # { # in : 1 9 , # want : true , # }, # { # in : 1 , # want : true , # }, # { # in : 0 , # want : false , # }, # } # for _ , tt := range tests { # got := isHappy ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
ret := [][] int {} # i , j := 0 , 0 # for i < len ( S ) { # for j < len ( S ) && S [ i ] == S [ j ] { # j ++ # } # if j - i >= 3 { # tmp := [] int { i , j - 1 } # ret = append ( ret , tmp ) # } # i = j # } # return ret
tests := [...] testType { # { # in : [] int { 1 0 , 1 5 , 2 0 }, # want : 1 5 , # }, # { # in : [] int { 1 , 1 0 0 , 1 , 1 , 1 , 1 0 0 , 1 , 1 , 1 0 0 , 1 }, # want : 6 , # }, # } # for _ , tt := range tests { # got := minCostClimbingStairs ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
tests := [...] testType { # { # in : [] int { 1 , 2 , 3 }, # want : 6 , # }, # { # in : [] int { 1 , 2 , 3 , 4 }, # want : 2 4 , # }, # { # in : [] int {- 2 , - 1 , 0 , 2 , 3 }, # want : 6 , # }, # { # in : [] int {- 1 , - 2 , - 3 , 5 , 4 , 3 , 2 , 1 }, # want : 6 0 , # }, # } # for _ , tt := range tests { # got := maximumProduct ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
const goal = 1 0 0 0 1 # var i , primes int # # for primes < goal { # i ++ # if isPrime ( i ) { # primes ++ # } # } # # fmt . Println ( i )
_ , err := NumberOfCombinations ( 5 , 6 ) # expectedError := " STR " # if err == nil { # t . Error (" STR ") # } else if err . Error () != expectedError { # t . Errorf (" STR ", err ) # }
select { # case <- done : # return true # default : # return false # }
listNode 1 := & ListNode { # Val : 2 , # Next : & ListNode { # Val : 4 , # Next : & ListNode { # Val : 3 , # Next : nil , # }, # }, # } # listNode 2 := & ListNode { # Val : 5 , # Next : & ListNode { # Val : 6 , # Next : & ListNode { # Val : 4 , # Next : nil , # }, # }, # } # ret := addTwoNumbers ( listNode 1 , listNode 2 ) # if ret . Val != 7 || ret . Next . Val != 0 || ret . Next . Next . Val != 8 { # t . Fatalf (" STR ", ret ) # }
if ! validName . MatchString ( text ) { # result := make ([] rune , 0 , len ( text )) # for _ , c := range text { # if validName . MatchString ( string ( c )) { # result = append ( result , c ) # } else { # result = append ( result , " STR ") # } # } # text = string ( result ) # } # if len ( text ) != 0 && ( text [ 0 ] >= " STR " && text [ 0 ] <= " STR ") { # text = " STR " + text # } # return text
return helper 4 6 ( nums , 0 , make ([][] int , 0 ))
bill := user {" STR ", " STR "} # bill . notify () # # lisa := & user {" STR ", " STR "} # lisa . notify () # # bill . changeEmail (" STR ") # bill . notify () # # lisa . changeEmail (" STR ") # lisa . notify ()
tmp := mySqrt ( num ) # return tmp * tmp == num
if cnt == 1 { # return head , head . Next # } # newHead , restHead := reverseList ( head . Next , cnt - 1 ) # head . Next . Next = head # head . Next = restHead # return newHead , restHead
return constructAllPossibleBSTs ( 1 , n )
var tests = [] struct { # nums [] int # products [] int # }{ # {[] int { 0 , 0 }, [] int { 0 , 0 }}, # {[] int { 1 , 2 , 3 , 4 }, [] int { 2 4 , 1 2 , 8 , 6 }}, # } # # for _ , tt := range tests { # products := productExceptSelf ( tt . nums ) # if reflect . DeepEqual ( products , tt . products ) == false { # t . Errorf (" STR ", tt . nums , products , tt . products ) # } # }
chapts := make ( map [ int ] string ) # # chapts [ 1 ] = " STR " # chapts [ 3 ] = " STR " # chapts [ 2 ] = " STR " # fmt . Println (" STR ") # for k , v := range chapts { # fmt . Println ( k , v ) # } # # var keys [] int # for k := range chapts { # keys = append ( keys , k ) # } # sort . Ints ( keys ) # fmt . Println (" STR ") # for _ , k := range keys { # fmt . Println (" STR ", k , " STR ", chapts [ k ]) # }
s . TotalWriteProcessed = 0 # s . TotalDelProcessed = 0 # s . TotalGetProcessed = 0 # s . TotalFlushProcessed = 0 # s . TotalCompactProcessed = 0 # s . TotalReadBytes = 0 # s . TotalWriteBytes = 0 # s . TotalAddDelay = 0 # s . TotalWriteDelay = 0 # s . TotalDelDelay = 0 # s . TotalGetDelay = 0 # s . TotalFlushDelay = 0 # s . TotalCompactDelay = 0
for _ , a := range s { # if a == e { # return true # } # } # return false
stack := make ([]* TreeNode , 0 ) # node := root # result := make ([] int , 0 ) # for node != nil || len ( stack ) != 0 { # for node != nil { # stack = append ( stack , node ) # result = append ( result , node . Val ) # node = node . Left # } # # node = stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # node = node . Right # } # # return result
fmt . Println ( fourSum ([] int { 1 , 0 , - 1 , 0 , - 2 , 2 }, 0 )) # fmt . Println ( fourSum ([] int {- 3 , 0 , 0 , 1 , 2 ,}, 0 )) # fmt . Println ( fourSum ([] int { 0 , 0 , 0 , 0 }, 0 ))
row , col := len ( grid ), len ( grid [ 0 ]) # for i := 0 ; i < row ; i ++ { # for j := 0 ; j < col ; j ++ { # if i == 0 && j == 0 { # continue # } else if i == 0 { # grid [ i ][ j ] += grid [ i ][ j - 1 ] # } else if j == 0 { # grid [ i ][ j ] += grid [ i - 1 ][ j ] # } else { # grid [ i ][ j ] += max ( grid [ i ][ j - 1 ], grid [ i - 1 ][ j ]) # } # } # } # return grid [ row - 1 ][ col - 1 ]
facts := make ([] int , 1 0 ) # facts [ 0 ], facts [ 1 ] = 1 , 1 # for i := 2 ; i < 1 0 ; i ++ { # facts [ i ] = facts [ i - 1 ] * i # } # sum := 0 # for i := 1 0 ; i < 2 5 4 0 1 6 1 ; i ++ { # sumOfFacts , number := 0 , i # for number > 0 { # d := number % 1 0 # number /= 1 0 # sumOfFacts += facts [ d ] # } # if sumOfFacts == i { # sum += i # } # } # return sum
i := 2 # if number < i { # err := fmt . Errorf (" STR ") # return 0 , err # } # # for i < number { # if number % i == 0 { # number /= i # } else { # i ++ # } # } # # return i , nil
if len ( buildingHeights ) == 0 { # return 0 # } # sunsetViews := 1 # shadow := buildingHeights [ len ( buildingHeights )- 1 ] # for i := len ( buildingHeights ) - 2 ; i >= 0 ; i -- { # if buildingHeights [ i ] > shadow { # sunsetViews ++ # shadow = buildingHeights [ i ] # } # } # return sunsetViews
fmt . Println (" STR ") # panicRecover () # fmt . Println (" STR ")
var err error # # err = seek ( r , fSize , io . SeekStart , fSize ) # if err != nil { # return err # } # # err = seek ( r , 0 , io . SeekStart , 0 ) # if err != nil { # return err # } # # return read ( r , fSize , h )
if len ( s ) < 2 { # return false # } # # newStr := s + s # return strings . Contains ( newStr [ 1 : len ( newStr )- 1 ], s )
head := createSingleLinkedList ([] int {- 1 , 5 , 3 , 4 , 0 }) # expected := createSingleLinkedList ([] int {- 1 , 0 , 3 , 4 , 5 }) # if res := sortList ( head ); ! reflect . DeepEqual ( res , expected ) { # t . Errorf (" STR ", expected , res ) # }
for sumInfo := range sumInfoChannel { # fmt . Println ( sumInfo ) # }
return & Heap { # data : make ([] Item , 0 ), # }
qs := [] question 8 5 1 { # # { # para 8 5 1 {[][] int {{ 1 , 0 }, { 2 , 1 }, { 3 , 1 }, { 3 , 7 }, { 4 , 3 }, { 5 , 3 }}, [] int { 3 , 2 , 5 , 4 , 6 , 1 , 7 , 0 }}, # ans 8 5 1 {[] int { 5 , 5 , 2 , 5 , 4 , 5 , 6 , 7 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 5 1 , q . para 8 5 1 # fmt . Printf (" STR ", p , loudAndRich ( p . richer , p . quiet )) # } # fmt . Printf (" STR ")
qs := [] question 8 6 2 { # { # para 8 6 2 {[] int { 1 }, 1 }, # ans 8 6 2 { 1 }, # }, # # { # para 8 6 2 {[] int { 1 , 2 }, 4 }, # ans 8 6 2 {- 1 }, # }, # # { # para 8 6 2 {[] int { 2 , - 1 , 2 }, 3 }, # ans 8 6 2 { 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 6 2 , q . para 8 6 2 # fmt . Printf (" STR ", p , shortestSubarray ( p . A , p . K )) # } # fmt . Printf (" STR ")
b . StopTimer () # arr := make ([] int , 0 , 0 ) # nodeArr := make ([]* FibHeapElement , 0 , 0 ) # h := NewFibHeap () # for i := 0 ; i < b . N ; i ++ { # n := rand . Intn ( 1 0 0 0 0 ) # nodeArr = append ( nodeArr , h . Insert ( n , n )) # arr = append ( arr , n + rand . Intn ( 5 0 )+ 5 0 ) # } # h . consolidate () # for i := 0 ; i < b . N ; i ++ { # h . ModifyNode ( nodeArr [ i ], arr [ i ], arr [ i ]) # } # b . StartTimer () # for i := 0 ; i < b . N ; i ++ { # h . ExtractMin () # }
c , res := [] int {}, [][] int {} # for k := 0 ; k <= len ( nums ); k ++ { # generateSubsets ( nums , k , 0 , c , & res ) # } # return res
dX := q . X - p . X # dY := q . Y - p . Y # return math . Sqrt ( dX * dX + dY * dY )
var stack [] string # ss := strings . Split ( path , " STR ") # for i := range ss { # s := ss [ i ] # switch s { # case " STR ", " STR ": # case " STR ": # if len ( stack ) == 0 { # continue # } # end := len ( stack ) - 1 # stack = stack [: end ] # default : # stack = append ( stack , s ) # } # } # return " STR " + strings . Join ( stack , " STR ")
t . Run (" STR ", func ( t * testing . T ) { # got := Login () # if got != true { # t . Fail () # } # }) #
if len ( graph ) == 0 || len ( graph ) != len ( graph [ 0 ]) { # return nil # } # # numVertecies := len ( graph ) # # result := make ( Matrix , numVertecies ) # # for i := 0 ; i < numVertecies ; i ++ { # result [ i ] = make ([] float 6 4 , numVertecies ) # for j := 0 ; j < numVertecies ; j ++ { # result [ i ][ j ] = graph [ i ][ j ] # } # } # # for k := 0 ; k < numVertecies ; k ++ { # for i := 0 ; i < numVertecies ; i ++ { # for j := 0 ; j < numVertecies ; j ++ { # if result [ i ][ j ] > result [ i ][ k ]+ result [ k ][ j ] { # result [ i ][ j ] = result [ i ][ k ] + result [ k ][ j ] # } # } # } # } # # return result
return h . tasks [ i ]. p < h . tasks [ j ]. p
t . Parallel () # for _ , tc := range testcases { # if result , err := BruteForceDivision ( tc . dividend , tc . divisor ); result != tc . quotient || err != tc . expectedError { # t . Errorf (" STR ", tc . quotient , tc . expectedError , result , err ) # } # }
word , bit := x / 6 4 , uint ( x % 6 4 ) # for word >= len ( s . words ) { # s . words = append ( s . words , 0 ) # } # s . words [ word ] |= 1 << bit
defer n . Done () # if cancelled () { # return # } # for _ , entry := range dirents ( dir ) { # if entry . IsDir () { # n . Add ( 1 ) # subdir := filepath . Join ( dir , entry . Name ()) # go walkDir ( subdir , n , fileSizes ) # } else { # fileSizes <- entry . Size () # } # }
h . Lock () # defer h . Unlock () # # h . data = append ( h . data , n ) # h . siftUp () # # return
if root == nil { # return nil # } # # res := [] string {} # var dfs func ( string , * TreeNode ) # dfs = func ( pre string , node * TreeNode ) { # if node . Left == nil && node . Right == nil { # res = append ( res , pre + strconv . Itoa ( node . Val )) # return # } # # pre += strconv . Itoa ( node . Val ) + " STR " # if node . Left != nil { # dfs ( pre , node . Left ) # } # if node . Right != nil { # dfs ( pre , node . Right ) # } # # } # dfs (" STR ", root ) # return res
w := strconv . FormatInt ( n , 1 0 ) # # if len ( w ) != 1 9 { # return false # } # # for i := 1 ; i < 1 0 ; i ++ { # if w [ 2 * i - 2 : 2 * i - 1 ] != strconv . Itoa ( i ) { # return false # } # } # # if w [ 1 8 :] != " STR " { # return false # } # # return true
var results [] string # # m := len ( board ) # if m == 0 { # return results # } # # n := len ( board [ 0 ]) # if n == 0 { # return results # } # # trie := buildTrie ( words ) # # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # dfs ( board , i , j , trie , & results ) # } # } # # return results
for a != 0 { # a , b = ( a & b )<< 1 , a ^ b # } # return b
pre 1 , pre 2 , ans := 0 , 0 , 0 # for _ , v := range nums { # if ans = pre 1 + v ; pre 2 > ans { # ans = pre 2 # } # pre 1 , pre 2 = pre 2 , ans # } # return ans
amicable := make ( map [ int ] struct {}) # sum := 0 # # for n := 1 ; n < 1 0 0 0 0 ; n ++ { # if _ , ok := amicable [ n ]; ! ok { # dn := d ( n ) # ddn := d ( dn ) # # if n != dn && n == ddn { # fmt . Printf (" STR ", n , dn , dn , ddn ) # sum += n + dn # } # # amicable [ n ] = struct {}{} # amicable [ dn ] = struct {}{} # } # } # # fmt . Println ( sum )
switch len ( a ) { # case 0 : # return 0 # case 1 : # return a [ 0 ] # case 2 : # if a [ 0 ] > a [ 1 ] { # return a [ 0 ] # } else { # return a [ 1 ] # } # default : # max := math . MinInt 3 2 # for _ , i := range a { # if i > max { # max = i # } # } # return max # }
n := len ( nums ) # sort . Ints ( nums ) # # count := func ( m int ) int { # count , i , j := 0 , 0 , 1 # for j < n { # if nums [ j ]- nums [ i ] <= m { # count += j - i # j ++ # } else { # i ++ # } # } # return count # } # # l := nums [ 1 ] - nums [ 0 ] # for i := 2 ; i < n ; i ++ { # l = min ( l , nums [ i ]- nums [ i - 1 ]) # } # # r := nums [ n - 1 ] - nums [ 0 ] # for l < r { # m := ( l + r ) / 2 # if count ( m ) < k { # l = m + 1 # } else { # r = m # } # } # return l
t 1 _b , t 1 _s , t 2 _b , t 2 _s := math . MinInt 3 2 , 0 , math . MinInt 3 2 , 0 # # for _ , v := range prices { # t 1 _b = max ( t 1 _b , 0 - v ) # t 1 _s = max ( t 1 _s , t 1 _b + v ) # t 2 _b = max ( t 2 _b , t 1 _s - v ) # t 2 _s = max ( t 2 _s , t 2 _b + v ) # } # return t 2 _s
if t != nil { # values = appendValues ( values , t . left ) # values = append ( values , t . value ) # values = appendValues ( values , t . right ) # } # return values
tbl := [] endtoend { # {" STR ", # [] Bytes { # { Start : 0 , End : 1 2 0 0 , Length : 1 2 0 0 , Satisfied : true }}, # [] Bytes { # { Start : 0 , End : 1 2 0 0 , Length : 1 2 0 0 , Satisfied : true }}, # }, # } # for _ , h := range tbl { # h := h # t . Run ( h . Name , func ( t * testing . T ) { # t . Parallel () # for i , in := range h . In { # want := h . Out [ i ] # o , err := FormatResponse ( in ) # if err != nil { # t . Fatal ( err ) # } # t . Logf (" STR ", o ) # got , err := ParseResponse ( o ) # if err != nil { # t . Fatal ( err ) # } # want . Equals ( t , got ) # } # }) # }
return helper 9 5 ( 1 , n )
var ret [] string # var s string # # s = " STR " # ret = [] string {" STR "} # for i , v := range findRepeatedDnaSequences ( s ) { # if ret [ i ] != v { # t . Fatalf (" STR ", ret ) # } # } # # s = " STR " # ret = [] string {" STR ", " STR "} # for i , v := range findRepeatedDnaSequences ( s ) { # if ret [ i ] != v { # t . Fatalf (" STR ", ret ) # } # } #
if len ( matrix ) == 0 || len ( matrix [ 0 ]) == 0 { # return false # } # row := - 1 # for i := 0 ; i < len ( matrix ); i ++ { # if matrix [ i ][ 0 ] <= target && ( i < len ( matrix )- 1 && matrix [ i + 1 ][ 0 ] > target || i == len ( matrix )- 1 ) { # row = i # break # } # } # if row == - 1 { # return false # } # return binarySearch ( matrix [ row ], 0 , len ( matrix [ row ])- 1 , target )
var result [] string # for i , r := range number { # letters := digitMappings [ r ] # if i == 0 { # result = append ( result , letters ...) # } else { # tmp := make ([] string , 0 , len ( letters )* len ( result )) # for _ , part := range result { # for _ , letter := range letters { # tmp = append ( tmp , part + letter ) # } # } # result = tmp # } # } # return result
if K == 0 { # return [] int { target . Val } # } # # nodeToNexts := make ( map [ int ][] int ) # buildGraph 8 6 3 ( root , nodeToNexts ) # dist := 0 # var queue 1 , queue 2 [] int # visited := make ( map [ int ] bool ) # queue 1 = append ( queue 1 , target . Val ) # visited [ target . Val ] = true # for len ( queue 1 ) > 0 { # node := queue 1 [ 0 ] # queue 1 = queue 1 [ 1 :] # # for _ , next := range nodeToNexts [ node ] { # if ! visited [ next ] { # queue 2 = append ( queue 2 , next ) # visited [ next ] = true # } # } # # if len ( queue 1 ) == 0 { # dist ++ # if dist == K { # return queue 2 # } # # queue 1 = queue 2 # queue 2 = make ([] int , 0 ) # } # } # # return make ([] int , 0 )
var tests = [] struct { # before [] int # n int # after * ListNode # }{ # {[] int { 1 , 2 , 3 , 4 , 5 }, 2 , newList ( 1 , 2 , 3 , 5 )}, # } # # for _ , tt := range tests { # after := removeNthFromEnd ( newList ( tt . before ...), tt . n ) # if reflect . DeepEqual ( after , tt . after ) == false { # t . Errorf (" STR ", newList ( tt . before ...), after , tt . after ) # } # }
tests := [...] testType { # { # in : [] int { 1 , 3 , 5 , 7 , 9 }, # want : 6 , # }, # { # in : [] int { 7 , 7 , 7 , 7 }, # want : 3 , # }, # { # in : [] int { 3 , - 1 , - 5 , - 9 }, # want : 3 , # }, # { # in : [] int { 1 , 2 , 3 , 4 }, # want : 3 , # }, # { # in : [] int { 1 , 2 , 3 , 4 , 6 , 8 , 1 0 }, # want : 6 , # }, # { # in : [] int { 1 , 2 }, # want : 0 , # }, # { # in : [] int { 1 , 2 , 4 , 5 , 7 }, # want : 0 , # }, # } # for _ , tt := range tests { # got := numberOfArithmeticSlices ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
np := normalize ( pattern ) # res := make ([] string , 0 , len ( words )) # for _ , w := range words { # if normalize ( w ) == np { # res = append ( res , w ) # } # } # return res
count := 0 # sum := 1 # m := 1 # # for sum <= N { # if 0 == ( N - sum )% m { # count ++ # } # m ++ # sum = ( 1 + m ) * m / 2 # } # return count
if n <= 1 { # return n # } # pre , cur := 1 , 1 # for i := 1 ; i < n ; i ++ { # pre , cur = cur , pre + cur # } # return cur
m , n := len ( s 1 ), len ( s 2 ) # A , B := [] byte ( s 1 ), [] byte ( s 2 ) # # cur := make ([] int , m + 1 ) # prev := make ([] int , m + 1 ) # # for j := 0 ; j < n ; j ++ { # for i := 0 ; i < m ; i ++ { # rec := max ( prev [ i + 1 ], cur [ i ]) # if A [ i ] == B [ j ] { # cur [ i + 1 ] = max ( rec , prev [ i ]+ 1 ) # } else { # cur [ i + 1 ] = rec # } # } # cur , prev = prev , cur # } # return prev [ m ]
t . Parallel () # # for _ , tc := range testcases { # if pyramid , cost := LowestCostPyramid ( tc . stones ); cost != tc . cost || # ! reflect . DeepEqual ( tc . pyramid , pyramid ) { # t . Errorf (" STR ", tc . pyramid , tc . cost , pyramid , cost ) # } # }
res := 0 # for num != 0 { # num = num & ( num - 1 ) # res ++ # } # return res
result := [] int {- 1 , - 1 } # if len ( nums ) <= 0 { # return result # } # # start , high := 0 , len ( nums )- 1 # for start < high { # mid := ( start + high ) / 2 # if nums [ mid ] < target { # start = mid + 1 # } else { # high = mid # } # } # # if nums [ start ] != target { # return result # } # # result [ 0 ] = start # # high = len ( nums ) - 1 # for start < high { # mid := ( start + high + 1 ) / 2 # if nums [ mid ] > target { # high = mid - 1 # } else { # start = mid # } # } # result [ 1 ] = high # # return result
area := 0 # for i := 0 ; i < len ( grid ); i ++ { # for j := 0 ; j < len ( grid [ 0 ]); j ++ { # if grid [ i ][ j ] == 0 { # continue # } # area += grid [ i ][ j ]* 4 + 2 # if i > 0 { # m := min ( grid [ i ][ j ], grid [ i - 1 ][ j ]) # area -= m # } # if i < len ( grid )- 1 { # m := min ( grid [ i ][ j ], grid [ i + 1 ][ j ]) # area -= m # } # if j > 0 { # m := min ( grid [ i ][ j ], grid [ i ][ j - 1 ]) # area -= m # } # if j < len ( grid [ i ])- 1 { # m := min ( grid [ i ][ j ], grid [ i ][ j + 1 ]) # area -= m # } # } # } # return area
ret := 0 # for x != 0 { # ret = ret * 1 0 + x % 1 0 # if ret > math . MaxInt 3 2 || ret < - math . MaxInt 3 2 { # return 0 # } # x /= 1 0 # } # return ret
list . locker . RLock () # # if list . head == nil { # return list # } # # list . locker . RUnlock () # # list . locker . RLock () # first := list . First () # last := list . Last () # list . locker . RUnlock () # list . locker . Lock () # defer list . locker . Unlock () # # for { # if last . next == nil { # return list # } # # if first . Val == value { # first . prev . next = first . next # first . next . prev = first . prev # first . prev = nil # first . next = nil # first . Val = nil # first . list = nil # list . len -- # return list # } else { # first = first . next # } # }
max := 1 0 0 0 # # sum := 0 # iterations := 2 # # previousNumerator , previousDenominator := BigFromInt ( 3 ), BigFromInt ( 2 ) # tempNumerator , tempDenominator := BigFromInt ( 0 ), BigFromInt ( 0 ) # numerator , denominator := BigFromInt ( 7 ), BigFromInt ( 5 ) # # for iterations != max { # tempNumerator . Set ( numerator ) # numerator . Add ( numerator , numerator ) # numerator . Add ( numerator , previousNumerator ) # previousNumerator . Set ( tempNumerator ) # # tempDenominator . Set ( denominator ) # denominator . Add ( denominator , denominator ) # denominator . Add ( denominator , previousDenominator ) # previousDenominator . Set ( tempDenominator ) # # if len ( numerator . String ()) > len ( denominator . String ()) { # sum ++ # } # # iterations ++ # } # # fmt . Println ( sum )
t . Run (" STR ", func ( t * testing . T ) { # t . Parallel () # for _ , tc := range testcases { # if result := ProductsExceptI ( tc . input ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Error (" STR ") # } # } # }) # t . Run (" STR ", func ( t * testing . T ) { # t . Parallel () # for _ , tc := range testcases { # if result := ProductsExceptINoDivision ( tc . input ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Error (" STR ") # } # } # })
return maxCoinsPathRecursive ( grid , 0 , 0 )
if n == nil { # return true # } # if ! IterOnTree ( n . Left , f ) { # return false # } # # f ( n ) # # return IterOnTree ( n . Right , f )
avg := N / part # var first int # if part % 2 == 0 { # first = avg - ( part / 2 - 1 ) # } else { # first = avg - part / 2 # } # # if first <= 0 { # return false , first # } # # last := first + part - 1 # sum := ( first + last ) * part / 2 # if sum == N { # return true , first # } # return false , first
var ss [] byte # if n := len ( s ); n > 0 { # ss = make ([] byte , n ) # for i := 0 ; i < n ; i ++ { # ss [ i ] = s [ n - i - 1 ] # } # } # return string ( ss )
a := uint 3 2 ( 2 ) # # for i := 0 ; i < 1 0 0 0 0 0 ; i ++ { # n , ok := fast_power ( a , i ) # # if ok != nil || n != uint 3 2 ( math . Pow ( float 6 4 ( a ), float 6 4 ( i ))) { # t . Error () # } # }
return fmt . Sprintf (" STR ", n . Name )
digits := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } # for i := 0 ; i < len ( digits ); i ++ { # if digits [ i ] != 0 { # dTemp := make ([] int , len ( digits )) # copy ( dTemp , digits ) # chosen := [] int { dTemp [ i ]} # choice := append ( dTemp [: i ], dTemp [ i + 1 :]...) # findCombos ( chosen , choice ) # } # } # fmt . Println (" STR ", sum )
h . tasks , v = h . tasks [: h . Len ()- 1 ], h . tasks [ h . Len ()- 1 ] # return
var tilt int # # var f func (* TreeNode ) int # f = func ( root * TreeNode ) int { # if root == nil { # return 0 # } # # l := f ( root . Left ) # r := f ( root . Right ) # if l < r { # tilt += r - l # } else { # tilt += l - r # } # return root . Val + l + r # } # f ( root ) # # return tilt
benchmarkFramework ( b , RadixSort )
idx := make ( map [ int ] int ) # for i , v := range row { # idx [ v ] = i # } # ret := 0 # for i := 0 ; i < len ( row ); i += 2 { # tmp := idx [ row [ i ]+ 1 ] # if row [ i ]% 2 == 1 { # tmp = idx [ row [ i ]- 1 ] # } # if tmp == i + 1 { # continue # } else { # row [ i + 1 ], row [ tmp ] = row [ tmp ], row [ i + 1 ] # idx [ row [ i + 1 ]], idx [ row [ tmp ]] = i + 1 , tmp # ret ++ # } # } # return ret #
t . Parallel () # for _ , tc := range testcases { # if result , err := ConvertAnagramToInt ( tc . anagram ); result != tc . sortedInt || err != tc . err { # t . Errorf (" STR ", tc . sortedInt , tc . err , result , err ) # } # }
if len ( A ) < 3 { # return false # } # # i := 1 # for ; i < len ( A ); i ++ { # if A [ i ] == A [ i - 1 ] { # return false # } # # if A [ i ] < A [ i - 1 ] { # break # } # } # # if i == 1 || i == len ( A ) { # return false # } # # for ; i < len ( A ); i ++ { # if A [ i ] >= A [ i - 1 ] { # return false # } # } # # return true
uint 8 SliceDst = make ([] uint 8 , len ( uint 8 SliceSrc )) # copy ( uint 8 SliceDst , uint 8 SliceSrc ) # # intSliceDst = make ([] int 1 6 , len ( intSliceSrc )) # copy ( intSliceDst , intSliceSrc )
if res , ok := dict [ s ]; ok { # return res # } # if len ( s ) == 0 { # return [] string {""} # } # # var res [] string # # for _ , word := range wordDict { # if len ( word ) <= len ( s ) && word == s [: len ( word )] { # for _ , str := range dfs ( s [ len ( word ):], wordDict , dict ) { # if len ( str ) == 0 { # res = append ( res , word ) # } else { # res = append ( res , word +" STR "+ str ) # } # } # # } # } # dict [ s ] = res # return res
m := make ( map [ int ] struct {}, len ( nums )) # for _ , n := range nums { # if _ , ok := m [ n ]; ok { # return true # } # m [ n ] = struct {}{} # } # return false
c := 0 # for i := 0 ; i < len ( startTime ); i ++ { # if queryTime >= startTime [ i ] && queryTime <= endTime [ i ] { # c ++ # } # } # return c
file , err := os . Open ( filename ) # if err != nil { # return err # } # defer file . Close () # wr , err := zw . Create ( filename ) # if err != nil { # return err # } # if _ , err := io . Copy ( wr , file ); err != nil { # return err # } # return nil
carryOne := false # result := & RevLLNum {} # current := result # # for first != nil || second != nil { # current . Next = & RevLLNum {} # current = current . Next # sum := 0 # # switch { # case first == nil : # sum = second . Digit # second = second . Next # case second == nil : # sum = first . Digit # first = first . Next # default : # sum = first . Digit + second . Digit # first = first . Next # second = second . Next # } # # if carryOne { # sum ++ # } # # carryOne = sum > 9 # current . Digit = sum % 1 0 # } # # if carryOne { # current . Next = & RevLLNum { 1 , nil } # } # # return result . Next
factorials := make ([] int , 1 0 ) # factorials [ 0 ] = 1 # for i := 1 ; i <= 9 ; i ++ { # factorials [ i ] = factorials [ i - 1 ] * i # } # powerOfTen := 1 0 # limit := factorials [ 9 ] # for limit > powerOfTen { # limit *= 2 # powerOfTen *= 1 0 # } # # sum := 0 # var localSum , j int # for i := 1 0 ; i < limit ; i ++ { # localSum , j = 0 , i # for j > 9 { # localSum += factorials [ j % 1 0 ] # j /= 1 0 # } # localSum += factorials [ j ] # # if i == localSum { # sum += i # } # } # println ( sum )
var pairs [] Pair # # for a := 0 ; a < ( m / 2 )+ 1 ; a ++ { # b := m - a # if a ^ b == n { # pairs = append ( pairs , Pair { A : a , B : b }) # } # } # # return pairs
tests := [...] testType { # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := reformat ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
qs := [] question 1 7 { # # { # para 1 7 {" STR "}, # ans 1 7 {[] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 7 , q . para 1 7 # fmt . Printf (" STR ", p , letterCombinations ( p . s )) # } # fmt . Printf (" STR ")
if s [ 0 ] == ' 0 ' { # return 0 # } # # n := len ( s ) # dp := make ([] int , n + 1 ) # dp [ 0 ], dp [ 1 ] = 1 , 1 # lastOne , lastTwo := int ( s [ 0 ]-' 0 '), 0 # for i := 2 ; i <= n ; i ++ { # last := int ( s [ i - 1 ] - ' 0 ') # lastOne , lastTwo = last , lastOne * 1 0 + last # if 1 <= lastOne { # dp [ i ] = dp [ i - 1 ] # } # if 1 0 <= lastTwo && lastTwo <= 2 6 { # dp [ i ] += dp [ i - 2 ] # } # } # # return dp [ n ]
input := "" # # got := IsBalanced ( input ) # want := true # # if got != want { # t . Errorf (" STR ", input , got , want ) # }
l := len ( nums ) # if l == 0 { # return 0 # } # max := nums [ l - 1 ] # sum := nums [ l - 1 ] # for i := l - 2 ; i >= 0 ; i -- { # if sum > 0 { # sum += nums [ i ] # } else { # sum = nums [ i ] # } # if sum > max { # max = sum # } # } # return max
for i := ( len ( nums ) - 1 ) / 2 ; i >= 0 ; i -- { # siftDown ( nums , len ( nums ), i ) # } # # for i := len ( nums ) - 1 ; i >= len ( nums )- k ; i -- { # nums [ i ], nums [ 0 ] = nums [ 0 ], nums [ i ] # siftDown ( nums , i , 0 ) # } # return nums [ len ( nums )- k ]
t . Parallel () # for _ , tc := range testcases { # if boats := BoatsNeededForEvacuation ( tc . weights , tc . k ); boats != tc . boats { # t . Errorf (" STR ", tc . boats , boats ) # } # }
ch <- 7 + 1 0 . 5 i # wg . Done ()
t . Parallel () # for _ , tc := range testcases { # if result := SmallestSparseNumberGreaterThan ( tc . n ); result != tc . expected { # t . Errorf (" STR ", tc . n , tc . expected , result ) # } # }
size := len ( nums ) # sum := 0 # max := nums [ 0 ] # for _ , n := range nums { # sum += n # if max < n { # max = n # } # } # # if sum % k != 0 || sum / k < max { # return false # } # # sort . Sort ( sort . Reverse ( sort . IntSlice ( nums ))) # # isUsed := make ([] bool , size ) # # return dfs ( nums , isUsed , k , 0 , 0 , sum / k )
n := len ( nums ) # begin , end := - 1 , - 2 # min , max := nums [ n - 1 ], nums [ 0 ] # for i := 0 ; i < n ; i ++ { # max = mymax ( max , nums [ i ]) # min = mymin ( min , nums [ n - 1 - i ]) # if nums [ i ] < max { # end = i # } # if nums [ n - 1 - i ] > min { # begin = n - 1 - i # } # } # return end - begin + 1
cases := [] struct { # name string # input 1 [] int # input 2 [][] int # expect [] int # }{ # {" STR ", [] int {- 2 , 0 , 3 , - 5 , 2 , - 1 }, [][] int {{ 0 , 2 }, { 2 , 5 }, { 0 , 5 }}, [] int { 1 , - 1 , - 3 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # obj := Constructor 2 ( c . input 1 ) # for i := 0 ; i < len ( c . input 2 ); i ++ { # got := obj . SumRange 2 ( c . input 2 [ i ][ 0 ], c . input 2 [ i ][ 1 ]) # if ! reflect . DeepEqual ( got , c . expect [ i ]) { # t . Fatalf (" STR ", # c . expect [ i ], got , c . input 2 [ i ], c . input 1 [ i ]) # } # } # }) # }
if t 1 == nil && t 2 == nil { # return true # } else if t 1 == nil || t 2 == nil { # return false # } # return t 1 . Val == t 2 . Val && dfs ( t 1 . Right , t 2 . Left ) && dfs ( t 1 . Left , t 2 . Right )
h . heap . Append ( i )
addEdge (" STR ", " STR ") # addEdge (" STR ", " STR ") # addEdge (" STR ", " STR ") # addEdge (" STR ", " STR ") # fmt . Println ( hasEdge (" STR ", " STR ")) # fmt . Println ( hasEdge (" STR ", " STR ")) # fmt . Println ( hasEdge (" STR ", " STR ")) # fmt . Println ( hasEdge (" STR ", " STR ")) # fmt . Println ( hasEdge (" STR ", " STR ")) # fmt . Println ( hasEdge (" STR ", " STR ")) # fmt . Println ( hasEdge (" STR ", " STR ")) # fmt . Println ( hasEdge (" STR ", " STR ")) #
log . Println (" STR ") # s . searchers [" STR "] = bing {}
var ret [] int # var nums [] int # ret = [] int { 0 , 0 , 0 , 1 , 1 , 1 , 2 , 2 , 2 } # nums = [] int { 2 , 0 , 2 , 1 , 1 , 0 , 1 , 0 , 2 } # sortColors ( nums ) # for i , v := range nums { # if ret [ i ] != v { # t . Fatalf (" STR ", ret ) # } # }
return make ( map [ string ][] data , 1 0 2 4 )
if nil == nums { # return - 1 # } # # sort . Ints ( nums ) # left , right := 0 , len ( nums )- 1 # for left <= right { # middle := ( left + right ) / 2 # if nums [ middle ] == middle { # left = middle + 1 # } else if nums [ middle ] > middle { # right = middle - 1 # } # } # return left
s = strings . ToLower ( s ) # # i , j := 0 , len ( s )- 1 # for i < j { # for i < j && ! isChar ( s [ i ]) { # i ++ # } # for i < j && ! isChar ( s [ j ]) { # j -- # } # if s [ i ] != s [ j ] { # return false # } # i ++ # j -- # } # # return true
return ll . top . Val
node 3 5 := TreeNode { Val : 5 } # node 3 7 := TreeNode { Val : 7 } # node 2 2 := TreeNode { Val : 2 } # node 2 5 := TreeNode { Val : 5 , Left : & node 3 5 , Right : & node 3 7 } # node 1 2 := TreeNode { Val : 2 , Left : & node 2 2 , Right : & node 2 5 } # # fmt . Println ( findSecondMinimumValue (& node 1 2 ))
var i int # for i = 0 ; i < len ( bits )- 1 ; i ++ { # if bits [ i ] == 1 { # i ++ # } # } # return i == len ( bits )- 1
n := len ( nums ) # if n < 2 || k < 0 { # return 0 # } # hash , c := make ( map [ int ] int ), 0 # for _ , num := range nums { # hash [ num ]++ # } # if k == 0 { # for _ , v := range hash { # if v >= 2 { # c ++ # } # } # } else { # for key := range hash { # if hash [ key + k ] > 0 { # c ++ # } # } # } # return c
if len ( value ) > 1 0 0 0 0 0 0 { # return protocolError (" STR ") # } # c . bw . WriteString ( cmd ) # c . bw . WriteByte ( space ) # # c . bw . WriteString ( key ) # c . bw . WriteByte ( space ) # # c . bw . Write ( strconv . AppendUint ( c . numScratch [: 0 ], uint 6 4 ( flags ), 1 0 )) # c . bw . WriteByte ( space ) # # c . bw . Write ( strconv . AppendInt ( c . numScratch [: 0 ], int 6 4 ( timeout ), 1 0 )) # c . bw . WriteByte ( space ) # # c . bw . Write ( strconv . AppendInt ( c . numScratch [: 0 ], int 6 4 ( len ( value )), 1 0 )) # if cas != 0 { # c . bw . WriteByte ( space ) # c . bw . Write ( strconv . AppendUint ( c . numScratch [: 0 ], cas , 1 0 )) # } # c . bw . Write ( crlf ) # c . bw . Write ( value ) # _ , err = c . bw . Write ( crlf ) # return
tmp := 0 # for x != 0 { # tmp = tmp * 1 0 + x % 1 0 # x = x / 1 0 # } # if tmp > 1 << 3 1 - 1 || tmp < -( 1 << 3 1 ) { # return 0 # } # return tmp
if nil == head || nil == head . Next { # return head # } # p := new ( ListNode ) # p . Next = head # prev , current := p , p . Next # for current != nil && current . Next != nil { # if current . Val == current . Next . Val { # for current . Next != nil && current . Val == current . Next . Val { # current = current . Next # } # current = current . Next # prev . Next = current # } else { # prev = prev . Next # current = current . Next # } # } # return p . Next
left , right := 0 , len ( nums )- 1 # for left < right { # if nums [ left ]+ nums [ right ] < target { # left ++ # } else if nums [ left ]+ nums [ right ] > target { # right -- # } else { # return [] int { nums [ left ], nums [ right ]} # } # } # return nil
m := make ( map [ int ][] int ) # res := make ([] int , numCourses ) # for _ , p := range prerequisites { # v , ok := m [ p [ 0 ]] # if ! ok { # m [ p [ 0 ]] = [] int { p [ 1 ]} # } else { # m [ p [ 0 ]] = append ( v , p [ 1 ]) # } # } # for i := 0 ; i < numCourses ; i ++ { # if helper ( i , res , m ) == false { # return false # } # } # return true
pr , pn := [] rune ( pattern ), len ( pattern ) # # check := func ( q string ) bool { # pi := 0 # for _ , r := range q { # if pi < pn && pr [ pi ] == r { # pi ++ # continue # } # if ' A ' <= r && r <= ' Z ' { # return false # } # } # return pi == pn # } # # res := make ([] bool , len ( queries )) # for i , q := range queries { # res [ i ] = check ( q ) # } # return res
count := map [ int ] int {} # x := 0 # for _ , d := range deck { # count [ d ]++ # } # for _ , c := range count { # x = gcd ( c , x ) # } # return x > 1
head := word [: 1 ] # tail := word [ 1 :] # if isIn ( head , ' A ', ' Z ') { # return isIn ( tail , ' A ', ' Z ') || isIn ( tail , ' a ', ' z ') # } # return isIn ( tail , ' a ', ' z ')
m := make ( map [ int ] int ) # for _ , n := range nums { # m [ n ]++ # } # q := PriorityQueue {} # for key , count := range m { # heap . Push (& q , & Item { key : key , count : count }) # } # var result [] int # for len ( result ) < k { # item := heap . Pop (& q ).(* Item ) # result = append ( result , item . key ) # } # return result
StoreUint 3 2 (& r . Reg , LoadUint 3 2 (& r . Reg )| value )
var _ Scope = new ( BasicScope )
res := make ([][] int , len ( M )) # for i := range M { # res [ i ] = make ([] int , len ( M [ 0 ])) # } # for y := 0 ; y < len ( M ); y ++ { # for x := 0 ; x < len ( M [ 0 ]); x ++ { # res [ y ][ x ] = smooth ( x , y , M ) # } # } # return res
tests := [...] testType { # { # in : [] string {" STR ", " STR ", " STR "}, # want : 2 , # }, # { # in : [] string {" STR ", " STR ", " STR "}, # want : 3 , # }, # } # # for _ , tt := range tests { # got := numUniqueEmails ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
symbol := [] string {" STR "," STR "," STR "," STR "," STR "," STR "," STR "," STR "," STR "," STR "," STR "," STR "," STR "} # value := [] int { 1 0 0 0 , 9 0 0 , 5 0 0 , 4 0 0 , 1 0 0 , 9 0 , 5 0 , 4 0 , 1 0 , 9 , 5 , 4 , 1 } # var result string # # for i := 0 ; num != 0 ; i ++ { # # for num >= value [ i ] { # num -= value [ i ] # result += symbol [ i ] # } # } # # return result
for i := range nums { # tmp := int ( math . Abs ( float 6 4 ( nums [ i ]))) # if nums [ tmp - 1 ] < 0 { # return int ( math . Abs ( float 6 4 ( nums [ i ]))) # } # nums [ tmp - 1 ] = - nums [ tmp - 1 ] # } # return - 1
defer wg . Done () # # for { # task , ok := <- tasks # if ! ok { # fmt . Printf (" STR ", worker ) # return # } # # fmt . Printf (" STR ", worker , task ) # # sleep := rand . Int 6 3 n ( 1 0 0 ) # time . Sleep ( time . Duration ( sleep ) * time . Millisecond ) # # fmt . Printf (" STR ", worker , task ) # }
m := make ( map [ byte ] int ) # for i := range tiles { # m [ tiles [ i ]]++ # } # arr := make ([] int , 0 ) # for _ , v := range m { # arr = append ( arr , v ) # } # return numTileDFS ( arr )
var res [] int # for i := len ( A ) - 1 ; i >= 0 ; i -- { # res = append ( res , ( A [ i ]+ K )% 1 0 ) # K = ( A [ i ] + K ) / 1 0 # } # for K > 0 { # res = append ( res , K % 1 0 ) # K /= 1 0 # } # return reverse ( res )
acTrie , stateIsTerminal , f := ConstructTrie ( p ) # s = make ([] int , len ( stateIsTerminal )) # i := 0 # acToReturn = acTrie # s [ i ] = - 1 # for current := 1 ; current < len ( stateIsTerminal ); current ++ { # o , parent := GetParent ( current , acTrie ) # down := s [ parent ] # for StateExists ( down , acToReturn ) && GetTransition ( down , o , acToReturn ) == - 1 { # down = s [ down ] # } # if StateExists ( down , acToReturn ) { # s [ current ] = GetTransition ( down , o , acToReturn ) # if stateIsTerminal [ s [ current ]] { # stateIsTerminal [ current ] = true # f [ current ] = ArrayUnion ( f [ current ], f [ s [ current ]]) # } # } else { # s [ current ] = i # } # } # return acToReturn , f , s
var tests = [] struct { # tree * TreeNode # order [][] int # }{ # { # newTree ( 3 , 9 , 2 0 , nil , nil , 1 5 , 7 ), # [][] int { # { 3 }, # { 9 , 2 0 }, # { 1 5 , 7 }, # }, # }, # { # newTree ( 1 , 2 , 2 , 3 , nil , 3 , 3 , 4 ), # [][] int { # { 1 }, # { 2 , 2 }, # { 3 , 3 , 3 }, # { 4 }, # }, # }, # { nil , nil }, # } # # for _ , tt := range tests { # order := levelOrder ( tt . tree ) # if reflect . DeepEqual ( order , tt . order ) == false { # t . Errorf (" STR ", tt . tree , order , tt . order ) # } # }
return helper 1 0 6 ( inorder , postorder , 0 , len ( inorder )- 1 , 0 , len ( postorder )- 1 )
matrix := [][] int { # { 1 , 3 , 3 }, # { 2 , 1 , 3 }, # { 2 , 2 , 1 }, # } # fmt . Println ( getMaxValue ( matrix )) # fmt . Println ( getMaxValue 2 ( matrix ))
arr := randomSlice ( 0 , 2 0 , 1 0 ) # gbt := newGBT () # for _ , v := range arr { # gbt . Insert ( uint 3 2 ( v )) # } # max := int ( gbt . Max ( gbt . Root ()).(* gbtElement ). Key ) # sort . Ints ( arr ) # if max != arr [ len ( arr )- 1 ] { # t . Log ( fmt . Sprintf (" STR ", arr [ len ( arr )- 1 ], max )) # t . Fail () # }
newprob := make ([] float 6 4 , len ( prob )) # newprob [ 0 ] = prob [ 0 ] # for i := 1 ; i < len ( prob ); i ++ { # newprob [ i ] = newprob [ i - 1 ] + prob [ i ] # } # return & randomDistribution { # r : rand . New ( rand . NewSource ( time . Now (). UnixNano ())), # prob : newprob , # vals : vals , # }
common := & Node { 1 0 1 5 , & Node { 4 4 4 , nil }} # one := & Node {" STR ", & Node {" STR ", & Node {" STR ", common }}} # two := & Node { 1 1 1 , common } # return one , two , common
t . Parallel () # funcs := MakeFunctionsOriginal () # for _ , f := range funcs { # if result := f (); result != 3 { # t . Errorf (" STR ", result ) # } # }
return Twitter { # users : make ( map [ int ][] feed ), # follow : make ( map [ int ] map [ int ] struct {}), # }
var tests = [] struct { # N int # gap int # }{ # { 2 2 , 2 }, # { 5 , 2 }, # { 6 , 1 }, # { 8 , 0 }, # } # # for _ , tt := range tests { # gap := binaryGap ( tt . N ) # if gap != tt . gap { # t . Errorf (" STR ", tt . N , gap , tt . gap ) # } # }
raw := make ([]* NestedInteger , 0 ) # deepTraverse ( nestedList , & raw ) # return & NestedIterator { # Raw : raw , # idx : 0 , # }
t . Parallel () # b := NewLRUCache ( 3 ) # if _ , ok := b . Get (" STR "); ok { # t . Error ("") # } # # now := time . Now () # b . Set (" STR ", " STR ", now . Add ( time . Duration (- 2 * time . Second ))) # b . Set (" STR ", " STR ", now . Add ( time . Duration (- 1 * time . Second ))) # b . Set (" STR ", " STR ", now . Add ( time . Duration ( 3 * time . Second ))) # # if v , _ := b . Get (" STR "); v != " STR " { # t . Error (" STR ") # } # # if _ , ok := b . GetNotStale (" STR "); ok { # t . Error (" STR ") # } # if _ , ok := b . GetNotStale (" STR "); ok { # t . Error (" STR ") # } # if v , _ := b . GetNotStale (" STR "); v != " STR " { # t . Error (" STR ") # } # # if b . Len () != 2 { # t . Error (" STR ") # } # if b . Expire () != 1 { # t . Error (" STR ") # }
for d := int ( len ( arr ) / 2 ); d > 0 ; d /= 2 { # for i := d ; i < len ( arr ); i ++ { # for j := i ; j >= d && arr [ j - d ] > arr [ j ]; j -= d { # arr [ j ], arr [ j - d ] = arr [ j - d ], arr [ j ] # } # } # } # return arr
var opensIfWildcardCloses , opensIfWildcardOpens int # # for _ , c := range input { # switch c { # case '(': # opensIfWildcardCloses ++ # opensIfWildcardOpens ++ # case ')': # opensIfWildcardCloses -- # opensIfWildcardOpens -- # case '*': # opensIfWildcardCloses -- # opensIfWildcardOpens ++ # } # # if opensIfWildcardOpens < 0 { # break # } # if opensIfWildcardCloses < 0 { # opensIfWildcardCloses = 0 # } # } # # return opensIfWildcardCloses == 0
row := make ([] int , rowIndex + 1 ) # row [ 0 ], row [ rowIndex ] = 1 , 1 # for i := 1 ; i < rowIndex ; i ++ { # row [ i ] = row [ i - 1 ] * ( rowIndex - i + 1 ) / i # } # return row
readSource () # fmt . Println ( tree ) # solve () # fmt . Println ( tree )
fmt . Println ( orderlyQueue (" STR ", 1 )) # fmt . Println ( orderlyQueue (" STR ", 3 ))
for i := 0 ; i < b . N ; i ++ { # getIter ( n ) # }
var tests = [] struct { # vals [] int # s string # }{ # {[] int {}, " STR "}, # {[] int { 1 , 2 , 3 , 4 }, " STR "}, # } # # for _ , tt := range tests { # s := newList ( tt . vals ...). String () # if s != tt . s { # t . Errorf (" STR ", tt . vals , s , tt . s ) # } # }
m := len ( matrix ) # if m == 0 { # return # } # n := len ( matrix [ 0 ]) # row , col := make ([] bool , m ), make ([] bool , n ) # for i := 0 ; i < m ; i ++{ # for j := 0 ; j < n ; j ++{ # if matrix [ i ][ j ] == 0 { # row [ i ] = true # col [ j ] = true # } # } # } # for i := 0 ; i < m ; i ++{ # for j := 0 ; j < n ; j ++{ # if row [ i ] || col [ j ]{ # matrix [ i ][ j ] = 0 # } # } # } #
if n < 2 { # return nil # } # isNotPrime := make ([] bool , n ) # isNotPrime [ 0 ], isNotPrime [ 1 ] = true , true # for i := 2 ; i <= int ( math . Sqrt ( float 6 4 ( n ))); i ++ { # if ! isNotPrime [ i ] { # for j := i * i ; j < n ; j += i { # isNotPrime [ j ] = true # } # } # } # var primes [] int # for p , notPrime := range isNotPrime { # if ! notPrime { # primes = append ( primes , p ) # } # } # return primes
var pre * TreeNode # helper ( root , & pre ) # return
m := map [ int ] int {} # count := 1 # # for ; num % 2 == 0 ; num = num / 2 { # m [ 2 ]++ # } # for i := 3 ; i <= int ( math . Sqrt ( float 6 4 ( num ))+ 1 ); i = i + 2 { # for ; num % i == 0 && i != num ; num = num / i { # m [ i ]++ # } # } # m [ num ]++ # # for _ , val := range m { # count = count * ( val + 1 ) # } # return count
var nums [] int # var ret int # # ret = 8 # nums = [] int { 1 , 2 , 3 , 4 , 8 , 2 , 9 } # if ret != maxProfit ( nums ) { # t . Fatalf (" STR ", ret ) # } # # ret = 0 # nums = [] int {} # if ret != maxProfit ( nums ) { # t . Fatalf (" STR ", ret ) # }
var scale float 6 4 = 1 # var sum float 6 4 # var px [ 2 ] float 6 4 # # px [ 0 ] = x # px [ 1 ] = y # # for i := 0 ; i < p . n ; i ++ { # val := p . noise 2 ( px ) # sum += val / scale # scale *= p . alpha # px [ 0 ] *= p . beta # px [ 1 ] *= p . beta # } # return sum
this . mutex . Lock () # defer this . mutex . Unlock () # # priority = ClipInt ( priority , 0 , this . max ) # # this . queues [ priority ]. Add ( v ) # this . total ++ # if priority > this . top { # this . top = priority # this . waiting [ priority ] = 0 # }
this . mutex . Lock () # if this . closed { # return # } # this . list . PushBack ( v ) # this . cond . Signal () # this . mutex . Unlock ()
const ( # begin = int 6 4 ( 1 ) # end = int 6 4 ( 1 0 0 ) # ) # # factorial := big . NewInt ( 0 ). MulRange ( begin , end ) # sum , modulo := big . NewInt ( 0 ), big . NewInt ( 0 ) # for factorial . Sign () == 1 { # modulo . Mod ( factorial , big . NewInt ( 1 0 )) # sum . Add ( sum , modulo ) # factorial . Div ( factorial , big . NewInt ( 1 0 )) # } # # fmt . Println ( sum )
var result [] int # for i := range str { # if len ( pattern ) > len ( str )- i { # break # } # complete := true # for j , pr := range pattern { # if pr != rune ( str [ i + j ]) { # complete = false # break # } # } # if complete { # result = append ( result , i ) # } # } # return result
res := 0 # sum := map [ int ] int {} # for _ , a := range A { # for _ , b := range B { # sum [ a + b ]++ # } # } # for _ , c := range C { # for _ , d := range D { # res += sum [-( c + d )] # } # } # return res
nums := make ([] int , 0 , 1 0 ) # # for _ , v := range lists { # nums = append ( nums , MarshalListNodeToSlice ( v )...) # } # nums = QuickSort ( nums ) # # return MarshalSliceToListNode ( nums )
newS := core ( S ) # newT := core ( T ) # # if newS == newT { # return true # } # return false
do := dialOptions { # dial : net . Dial , # } # for _ , option := range options { # option . f (& do ) # } # # netConn , err := do . dial ( network , address ) # if err != nil { # return nil , err # } # c := & conn { # conn : netConn , # bw : bufio . NewWriter ( netConn ), # br : bufio . NewReader ( netConn ), # readTimeout : do . readTimeout , # writeTimeout : do . writeTimeout , # } # # return c , nil
b . lock . Lock () # defer b . lock . Unlock () # # e := b . table [ key ] # if e == nil { # return nil , false # } # # return e . value , true
return x > y
row := len ( matrix ) # if row <= 0 { # return # } # column := len ( matrix [ 0 ]) # for i := 0 ; i < row ; i ++ { # for j := i + 1 ; j < column ; j ++ { # tmp := matrix [ i ][ j ] # matrix [ i ][ j ] = matrix [ j ][ i ] # matrix [ j ][ i ] = tmp # } # } # halfColumn := column / 2 # for i := 0 ; i < row ; i ++ { # for j := 0 ; j < halfColumn ; j ++ { # tmp := matrix [ i ][ j ] # matrix [ i ][ j ] = matrix [ i ][ column - j - 1 ] # matrix [ i ][ column - j - 1 ] = tmp # } # }
if len ( bits )% 8 != 0 { # panic (" STR ") # } # for bits != " STR " { # switch { # case bits [ 0 ] == ' 0 ': # bits = bits [ 8 :] # case bits [ 0 : 3 ] == " STR ": # if ! validBytes ( 1 0 , 1 , bits ) { # return false # } # bits = bits [ 1 6 :] # case bits [ 0 : 4 ] == " STR ": # if ! validBytes ( 1 8 , 2 , bits ) { # return false # } # bits = bits [ 2 4 :] # case bits [ 0 : 5 ] == " STR ": # if ! validBytes ( 2 6 , 3 , bits ) { # return false # } # bits = bits [ 3 2 :] # default : # return false # } # } # return true
if squares < minlength { # return 1 # } # # if answer , ok := memo [[ 2 ] int { squares , minlength }]; ok { # return answer # } # # total := int 6 4 ( 1 ) # # for size := minlength ; size <= squares ; size ++ { # for start := 0 ; start <= squares - size ; start ++ { # answer := int 6 4 ( 1 ) # # answer *= ways ( squares - start - size - 1 , minlength ) # # total += answer # } # # } # # memo [[ 2 ] int { squares , minlength }] = total # # return total
var single int # for _ , num := range nums { # single ^= num # } # # diff := single & (- single ) # once := make ([] int , 2 ) # for _ , num := range nums { # if num & diff == 0 { # once [ 0 ] ^= num # } else { # once [ 1 ] ^= num # } # } # return once
type arg struct { # root , p , q * TreeNode # } # # tree := createBinaryTree ([] int { 6 , 2 , 8 , 0 , 4 , 7 , 9 , - 1 , 1 , 3 , 5 }) # # testCases := [] arg { # { root : tree , p : tree . Left . Right . Left , q : tree . Left . Right . Right }, # { p : & TreeNode { Val : 2 }, q : & TreeNode { Val : 8 }}, # } # expected := []* TreeNode {{ Val : 4 }, nil } # # for index , data := range testCases { # if res := lowestCommonAncestor ( data . root , data . p , data . q ); res != nil && res . Val != expected [ index ]. Val { # t . Errorf (" STR ", expected [ index ], res ) # } else if res == nil && res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
this . mutex . Lock () # defer this . mutex . Unlock () # # if priority < 0 || priority > this . max { # return nil # } # # return this . queues [ priority ]. PeekWait ()
sizeA , sizeB := len ( A ), len ( B ) # res := make ([][] int , 0 , sizeA + sizeB ) # for i , j := 0 , 0 ; i < sizeA && j < sizeB ; { # switch { # case A [ i ][ 1 ] < B [ j ][ 0 ]: # i ++ # case B [ j ][ 1 ] < A [ i ][ 0 ]: # j ++ # default : # res = append ( res , [] int { # max ( A [ i ][ 0 ], B [ j ][ 0 ]), # min ( A [ i ][ 1 ], B [ j ][ 1 ]), # }) # if A [ i ][ 1 ] < B [ j ][ 1 ] { # i ++ # } else { # j ++ # } # } # } # return res
t . Parallel () # # for _ , tc := range testcases { # result := append ( make ([] rune , 0 , len ( tc . input )), tc . input ...) # SegregateValues ( result ) # # if ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
res := make ([] int , len ( seq )) # stack , top := make ([] int , len ( seq )), - 1 # for i , r := range seq { # if r == '(' { # top ++ # stack [ top ], res [ i ] = i , top % 2 # } else { # res [ i ] = res [ stack [ top ]] # top -- # } # } # return res
isBlocked := make ( map [ int ] bool , 1 0 0 0 0 ) # for _ , o := range obstacles { # i , j := o [ 0 ], o [ 1 ] # isBlocked [ encode ( i , j )] = true # } # # x , y , res := 0 , 0 , 0 # index := 0 # # for _ , c := range commands { # switch { # case c == - 2 : # index -- # case c == - 1 : # index ++ # default : # if index < 0 { # index += 1 << 6 3 - 4 # } # index %= 4 # dx , dy := dxs [ index ], dys [ index ] # for c > 0 && ! isBlocked [ encode ( x + dx , y + dy )] { # c -- # x += dx # y += dy # } # res = max ( res , x * x + y * y ) # } # } # # return res
Stderr = log . New ( Writer ( os . Stderr ), " STR ", log . Lshortfile )
memo . mu . Lock () # res , ok := memo . cache [ key ] # memo . mu . Unlock () # if ! ok { # res . value , res . err = memo . f ( key ) # # memo . mu . Lock () # memo . cache [ key ] = res # memo . mu . Unlock () # } # return res . value , res . err
s . data . PushBack ( data )
pt := make ([][] int , numRows ) # for i := range pt { # pt [ i ] = make ([] int , i + 1 ) # } # for i , val := range pt { # pt [ i ][ 0 ], pt [ i ][ len ( val )- 1 ] = 1 , 1 # } # for i := 1 ; i < numRows - 1 ; i ++ { # for j := 0 ; j < len ( pt [ i ])- 1 ; j ++ { # pt [ i + 1 ][ j + 1 ] = pt [ i ][ j ] + pt [ i ][ j + 1 ] # } # } # return pt
triangle := [][] int { # { 2 }, # { 3 , 4 }, # { 6 , 5 , 7 }, # { 4 , 1 , 8 , 3 }, # # } # fmt . Println ( minimumTotal ( triangle ))
for i := 1 ; i > 0 ; i ++ { # # tri := nthTrianglular ( float 6 4 ( i )) # # if numFactors ( int ( tri )) >= 5 0 0 { # # fmt . Println ( int ( tri )) # return # # } # # } #
t . Parallel () # t . Skip (" STR ") # n , length := LongestCollatzSequence ( 1 0 0 0 0 0 0 ) # if n != 8 3 7 7 9 9 || length != 5 2 4 { # t . Errorf (" STR ", n , length ) # }
var err error # var out bytes . Buffer # # cmd := exec . Command (" STR ", " STR ", " STR ") # cmd . Stdout = & out # if workingDir != "" { # cmd . Dir = workingDir # } # err = cmd . Run () # if err != nil { # return "", err # } # return strings . TrimSpace ( out . String ()), nil
if len ( A ) == 0 && len ( B ) == 0 { # return 1 # } else if len ( A ) == 0 || len ( B ) == 0 { # return 0 # } # s := A # i := 0 # m := len ( B )/ len ( A ) + 2 # for i < m { # if strings . Index ( s , B ) > - 1 { # return i + 1 # } # s += A # i ++ # } # return - 1
m := map [ int ] int {} # for i := range nums { # if j , ok := m [ nums [ i ]]; ok { # if i - j <= k { # return true # } # } # m [ nums [ i ]] = i # } # return false
_i := i .(* heapIntArrays ) # (* h ) = append ((* h ), (* _i )...) # return h
if head == nil { # return nil # } # var nums [] int # for head != nil { # nums = append ( nums , head . Val ) # head = head . Next # } # var stack [] int # top := - 1 # stack = append ( stack , 0 ) # top ++ # for i := 1 ; i < len ( nums ); i ++ { # for top != - 1 && nums [ stack [ top ]] < nums [ i ] { # nums [ stack [ top ]] = nums [ i ] # stack = stack [: top ] # top -- # } # stack = append ( stack , i ) # top ++ # } # for top != - 1 { # nums [ stack [ top ]] = 0 # stack = stack [: top ] # top -- # } # return nums
for i , e := other . Len (), other . Rightist (); i > 0 ; i = i - 1 { # nextE := e . left () # other . Remove ( e ) # l . insert ( e , l . root . r ) # e = nextE # } # return l
res := make ([] int , n ) # res [ 0 ] = 1 # i 2 , i 3 , i 5 := 0 , 0 , 0 # for i := 1 ; i < n ; i ++ { # next := min ( 2 * res [ i 2 ], min ( 3 * res [ i 3 ], 5 * res [ i 5 ])) # if next == 2 * res [ i 2 ] { # i 2 ++ # } # if next == 3 * res [ i 3 ] { # i 3 ++ # } # if next == 5 * res [ i 5 ] { # i 5 ++ # } # res [ i ] = next # } # return res [ n - 1 ]
var start * Node # start = cl . Head # # for i := 0 ; i < cl . Size ; i ++ { # fmt . Printf (" STR ", start . Val ) # start = start . Next # } # return start
for row := 0 ; row < len ( mat )- 1 ; row ++ { # r := row # c := 0 # num := mat [ r ][ c ] # for r < len ( mat ) && c < len ( mat [ r ]) { # if mat [ r ][ c ] != num { # return false # } # r ++ # c ++ # } # } # for col := 1 ; col < len ( mat [ 0 ])- 1 ; col ++ { # r := 0 # c := col # num := mat [ r ][ c ] # for r < len ( mat ) && c < len ( mat [ r ]) { # if mat [ r ][ c ] != num { # return false # } # r ++ # c ++ # } # } # return true
if root == nil { # return 0 # } # # max := 0 # helper 2 9 8 ( root , nil , & max ) # return max
m := make ( map [ int ] int , len ( nums )) # # for i , n := range nums { # if m [ target - n ] != 0 { # return [] int { m [ target - n ], i + 1 } # } # m [ n ] = i + 1 # } # # return nil
if n & 2 == 2 { # return false # } # if ( n - 1 )% 6 == 0 { # return false # } # if ( n + 1 )% 6 == 0 { # return false # } # return true
m := make ( map [ string ][] string ) # wordSet := make ( map [ string ] struct {}, len ( wordDict )) # for _ , w := range wordDict { # wordSet [ w ] = struct {}{} # } # # var recur func ( string ) [] string # recur = func ( s string ) [] string { # if v , ok := m [ s ]; ok { # return v # } # res := [] string {} # if _ , ok := wordSet [ s ]; ok { # res = append ( res , s ) # } # for i := 1 ; i < len ( s ); i ++ { # cur := s [ i :] # if _ , ok := wordSet [ cur ]; ok { # strs := recur ( s [: i ]) # for _ , sub := range strs { # res = append ( res , sub +" STR "+ cur ) # } # } # } # m [ s ] = res # return res # } # return recur ( s )
res := make ([] int , 0 , len ( nums )- k + 1 ) # indexs := [] int {} # for i , num := range nums { # for len ( indexs ) != 0 && indexs [ 0 ] <= i - k { # indexs = indexs [ 1 :] # } # j := len ( indexs ) - 1 # for j >= 0 && nums [ indexs [ j ]] <= num { # j -- # } # indexs = append ( indexs [: j + 1 ], i ) # if i >= k - 1 { # res = append ( res , nums [ indexs [ 0 ]]) # } # } # return res
if nil == root { # return 0 # } # # left := maxDepth ( root . Left ) # right := maxDepth ( root . Right ) # # if left >= right { # return left + 1 # } else { # return right + 1 # }
number := " STR " # largestPro := 0 # for i := 0 ; i < len ( number )- 5 ; i ++ { # localPro := 1 # for j := i ; j < i + 5 ; j ++ { # num , _ := strconv . Atoi ( string ( number [ j ])) # localPro *= num # } # if localPro > largestPro { # largestPro = localPro # } # } # println ( largestPro )
res := make ([][] int , 0 , len ( s )/ 3 ) # l , r := 0 , 1 # # for ; r < len ( s ); r ++ { # if s [ l ] != s [ r ] { # l = r # continue # } # # if r - l + 1 == 3 { # res = append ( res , [] int { l , r }) # } else if r - l + 1 > 3 { # res [ len ( res )- 1 ][ 1 ] = r # } # } # # return res
v , _ := tag . Lookup ( key ) # return v
out , err := os . Create ( outdir + " STR " + device . metadata [" STR "].( string ) + " STR ") # if err != nil { # return err # } # defer out . Close () # t := template . Must ( template . New (" STR "). Parse ( " STR " )) # return t . Execute ( out , device . metadata )
fmt . Println ( largeGroupPositions (" STR ")) # fmt . Println ( largeGroupPositions (" STR ")) # fmt . Println ( largeGroupPositions (" STR "))
testCases := [][] int { # { 2 , 2 , 1 }, # { 4 , 1 , 2 , 1 , 2 }, # } # expected := [] int { 1 , 4 } # testFuncs := [] func ([] int ) int { # singleNumber , singleNumber 1 , # } # # for _ , testFunc := range testFuncs { # for index , nums := range testCases { # if res := testFunc ( nums ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # } # }
var p , l , r * TreeNode # # for root != nil { # l = root . Left # # root . Left = r # r = root . Right # # root . Right = p # p = root # root = l # } # return p
if nil == nums || 0 == len ( nums ) || len ( nums )* len ( nums [ 0 ]) != r * c { # return nums # } # # temp := make ([] int , 0 ) # for row := 0 ; row < len ( nums ); row ++ { # for col := 0 ; col < len ( nums [ 0 ]); col ++ { # temp = append ( temp , nums [ row ][ col ]) # } # } # # ans := make ([][] int , r ) # for row := 0 ; row < r ; row ++ { # tmp := make ([] int , c ) # for col := 0 ; col < c ; col ++ { # tmp [ col ] = temp [ row * c + col ] # } # ans [ row ] = tmp # } # return ans
m := make ( map [ rune ][] int , 2 6 ) # for i , r := range ring { # m [ r ] = append ( m [ r ], i ) # } # # ss := make ([] status , 1 , len ( ring )) # ss [ 0 ] = status { # index : 0 , # steps : 0 , # } # # size := len ( ring ) # # for _ , r := range key { # temp := make ([] status , len ( m [ r ])) # for i , d := range m [ r ] { # s := fromTo ( ss [ 0 ], d , size ) # for i := 1 ; i < len ( ss ); i ++ { # s . steps = min ( s . steps , fromTo ( ss [ i ], d , size ). steps ) # } # temp [ i ] = s # } # ss = temp # } # # res := ss [ 0 ]. steps # for i := 1 ; i < len ( ss ); i ++ { # res = min ( res , ss [ i ]. steps ) # } # # return res
return n % 4 != 0
if p != " STR " && s == " STR " { # return false # } # if s == " STR " { # return false # } # return isMatchAux ( s , p , 0 , 0 )
var ret int # for _ , num := range nums { # ret += num # } # return ret
coll := len ( puzzle ) # for row := range puzzle { # rowl := len ( puzzle [ row ]) # for col := range puzzle [ row ] { # if rowl - len ( target )- col < 0 { # break # } # if checkLeftToRight ( puzzle , row , col , target ) { # return true # } # if coll - len ( target )- row >= 0 { # if checkTopToDown ( puzzle , row , col , target ) { # return true # } # } # } # } # return false
n := len ( P ) # # if n < 2 { # return nil # } # # minPair := makePair ( P [ 0 ], P [ 1 ]) # tempPair := makePair ( P [ 0 ], P [ 1 ]) # # min := minPair . distance # for i := 0 ; i < n - 1 ; i ++ { # tempPair . point 1 = P [ i ] # for j := 0 ; j < n ; j ++ { # tempPair . point 2 = P [ j ] # if min > tempPair . distance { # minPair = tempPair # min = tempPair . distance # } # } # } # # return minPair
taskQueue := make ( chan * Task , 1 0 ) # # wg . Add ( noOfWorkers ) # for gr := 1 ; gr <= noOfWorkers ; gr ++ { # go worker ( taskQueue , gr ) # } # # for i := 1 ; i <= 1 0 ; i ++ { # taskQueue <- & Task { # Id : i , # JobId : 1 0 0 + i , # CreatedOn : time . Now (), # } # } # # close ( taskQueue ) # # wg . Wait ()
if node == nil { # return # } # # currentSum := parentSum * 1 0 + node . Val # if node . Left == nil && node . Right == nil { # * resultArr = append (* resultArr , currentSum ) # } # # traverse ( node . Left , currentSum , resultArr ) # traverse ( node . Right , currentSum , resultArr )
result := make ([] int , 0 ) # for i := len ( A ) - 1 ; i >= 0 ; i -- { # j := findLargest ( A , i + 1 ) # # if j != i { # flipFirst ( A , j + 1 ) # flipFirst ( A , i + 1 ) # # result = append ( result , j + 1 ) # result = append ( result , i + 1 ) # } # } # # return result
a , b := analyze ( equation ) # # if a == 0 { # if b == 0 { # return " STR " # } # return " STR " # } # # return " STR " + strconv . Itoa ( b / a )
index := low - 1 # pivotElement := arr [ high ] # for i := low ; i < high ; i ++ { # if arr [ i ] <= pivotElement { # index += 1 # arr [ index ], arr [ i ] = arr [ i ], arr [ index ] # } # } # arr [ index + 1 ], arr [ high ] = arr [ high ], arr [ index + 1 ] # return index + 1
cases := [] struct { # name string # inputs [] int # expect [][] int # }{ # {" STR ", [] int { 1 , 1 , 2 }, [][] int { # { 1 , 1 , 2 }, { 1 , 2 , 1 }, { 2 , 1 , 1 }, # }}, # {" STR ", [] int { 1 , 2 , 3 }, [][] int { # { 1 , 2 , 3 },{ 1 , 3 , 2 },{ 2 , 1 , 3 },{ 2 , 3 , 1 },{ 3 , 1 , 2 },{ 3 , 2 , 1 }, # }}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := Solution ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
qs := [] question 2 8 7 { # # { # para 2 8 7 {[] int { 1 , 3 , 4 , 2 , 2 }}, # ans 2 8 7 { 2 }, # }, # # { # para 2 8 7 {[] int { 3 , 1 , 3 , 4 , 2 }}, # ans 2 8 7 { 3 }, # }, # # { # para 2 8 7 {[] int { 2 , 2 , 2 , 2 , 2 }}, # ans 2 8 7 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 8 7 , q . para 2 8 7 # fmt . Printf (" STR ", p , findDuplicate ( p . one )) # } # fmt . Printf (" STR ")
cases := [] struct { # name string # inputs [][] int # expect [] int # }{ # {" STR ", [][] int {{ 2 , 7 , 1 1 , 1 5 }, { 9 }}, [] int { 0 , 1 }}, # {" STR ", [][] int {{ 3 , 2 , 4 }, { 6 }}, [] int { 1 , 2 }}, # {" STR ", [][] int {{ 2 , 7 , 1 1 , 1 5 }, { 9 }}, [] int { 0 , 1 }}, # {" STR ", [][] int {{ 7 , 6 , 5 , 3 , 2 , 1 , 4 , 9 , 1 0 }, { 1 7 }}, [] int { 0 , 8 }}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := TwoSum 3 ( c . inputs [ 0 ], c . inputs [ 1 ][ 0 ]) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
if nil == root { # return [][] int {} # } # # var vals [][] int # nodes := []* TreeNode { root } # for len ( nodes ) > 0 { # currLevel := [] int {} # copy := nodes [:] # nodes = []* TreeNode {} # for _ , node := range copy { # currLevel = append ( currLevel , node . Val ) # if nil != node . Left { # nodes = append ( nodes , node . Left ) # } # if nil != node . Right { # nodes = append ( nodes , node . Right ) # } # } # vals = append ( vals , currLevel ) # } # return vals
o := & Success {} # o . L = & sync . Mutex {} # return o
tests := [...] testType { # { # in : 1 , # want : " STR ", # }, # { # in : 3 , # want : " STR ", # }, # { # in : 2 6 , # want : " STR ", # }, # { # in : 5 2 , # want : " STR ", # }, # { # in : 2 7 , # want : " STR ", # }, # { # in : 2 8 , # want : " STR ", # }, # { # in : 7 0 1 , # want : " STR ", # }, # { # in : 7 0 3 , # want : " STR ", # }, # { # in : 1 6 9 0 0 , # want : " STR ", # }, # } # for _ , tt := range tests { # got := convertToTitle ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # } # for _ , tt := range tests { # got := convertToTitle 2 ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
dirs := [ 4 ][ 2 ] int {{ 0 , 1 }, { 1 , 0 }, { 0 , - 1 }, {- 1 , 0 }} # m := map [ obstacle ] struct {}{} # for _ , o := range obstacles { # m [ obstacle { o [ 0 ], o [ 1 ]}] = struct {}{} # } # i , j , d := 0 , 0 , 0 # res := 0 # for _ , c := range commands { # if c == - 2 { # d = ( d + 3 ) % 4 # } else if c == - 1 { # d = ( d + 1 ) % 4 # } else { # dx , dy := dirs [ d ][ 0 ], dirs [ d ][ 1 ] # for k := 0 ; k < c ; k ++ { # x , y := i + dx , j + dy # if _ , ok := m [ obstacle { x , y }]; ok { # break # } # i = x # j = y # } # res = max ( res , i * i + j * j ) # } # } # return res
return t . NilNode . Left
found := false # i := 3 # for ! found { # for j := 2 ; j < i ; j ++ { # if isPentagonal ( Pentagonal ( i )+ Pentagonal ( j )) && isPentagonal ( Pentagonal ( i )- Pentagonal ( j )) { # fmt . Printf (" STR ", i , j , Pentagonal ( i )- Pentagonal ( j )) # found = true # } # } # i ++ # }
switch d { # case Sunday : # return " STR " # case Monday : # return " STR " # case Tuesday : # return " STR " # case Wednesday : # return " STR " # case Thursday : # return " STR " # case Friday : # return " STR " # case Saturday : # return " STR " # default : # return " STR " # } #
sum := 0 # # for i := 1 0 ; i < 2 5 0 0 0 0 0 ; i ++ { # n := i # digitSum := 0 # # for n > 0 { # digit := n % 1 0 # digitSum += factorial [ digit ] # n /= 1 0 # } # # if digitSum == i { # fmt . Println ( i ) # sum += i # } # } # # fmt . Println ( sum )
points := [][] int {} # # highs := new ( highHeap ) # heap . Init ( highs ) # pre := 0 # heap . Push ( highs , pre ) # # edges := make ([][ 3 ] int , 0 , 2 * len ( buildings )) # for _ , b := range buildings { # edges = append ( edges , [ 3 ] int { b [ 0 ], b [ 2 ], - 1 }) # edges = append ( edges , [ 3 ] int { b [ 1 ], b [ 2 ], 1 }) # } # sort . Sort ( edgeSlice ( edges )) # # for _ , e := range edges { # if e [ 2 ] < 0 { # heap . Push ( highs , e [ 1 ]) # } else { # i := 0 # for i < len (* highs ) { # if (* highs )[ i ] == e [ 1 ] { # break # } # i ++ # } # heap . Remove ( highs , i ) # } # now := (* highs )[ 0 ] # if pre != now { # points = append ( points , [] int { e [ 0 ], now }) # pre = now # } # } # # return points
if len ( nums ) == 1 { # return nums [ 0 ] # } # preSum , max := nums [ 0 ], nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # currentSum := 0 # if preSum < 0 { # currentSum = nums [ i ] # } else { # currentSum = nums [ i ] + preSum # } # if currentSum > max { # max = currentSum # } # preSum = currentSum # } # return max
testData := [][] int { # { 1 , 5 , 1 1 , 5 }, # { 1 , 2 , 3 , 5 }, # } # # expectedData := [] bool { true , false } # # for index , data := range testData { # if res := canPartition ( data ); res != expectedData [ index ] { # t . Errorf (" STR ", expectedData [ index ], res ) # } # }
const format = " STR " # tw := new ( tabwriter . Writer ). Init ( os . Stdout , 0 , 8 , 2 , " STR ", 0 ) # fmt . Fprintf ( tw , format , " STR ", " STR ", " STR ", " STR ", " STR ") # fmt . Fprintf ( tw , format , " STR ", " STR ", " STR ", " STR ", " STR ") # for _ , t := range tracks { # fmt . Fprintf ( tw , format , t . Title , t . Artist , t . Album , t . Year , t . Length ) # } # tw . Flush ()
p := make ([] int , len ( x )) # m := make ([] int , len ( x )+ 1 ) # l := 0 # for i := range x { # lo := 1 # hi := l # for lo <= hi { # var mid int # if ( lo + hi )% 2 == 0 { # mid = ( lo + hi ) / 2 # } else { # mid = (( lo + hi ) / 2 ) + 1 # } # if x [ m [ mid ]] < x [ i ] { # lo = mid + 1 # } else { # hi = mid - 1 # } # } # newL := lo # p [ i ] = m [ newL - 1 ] # m [ newL ] = i # if newL > l { # l = newL # } # } # s := make ([] int , l ) # k := m [ l ] # for i := range s { # s [ len ( s )- 1 - i ] = x [ k ] # k = p [ k ] # } # return s
s := newStruct () # # b , ok := s . FieldOk (" STR ") # if ! ok { # t . Error (" STR ") # } # # e , ok := b . FieldOk (" STR ") # if ! ok { # t . Error (" STR ") # } # # val , ok := e . Value ().( string ) # if ! ok { # t . Error (" STR ") # } # # if val != " STR " { # t . Errorf (" STR ", val ) # }
i , smallestGoldbachError := 2 , 0 # for smallestGoldbachError == 0 { # if isOddComposite ( i ) && ! respectGoldbach ( i ) { # smallestGoldbachError = i # } # i ++ # } # fmt . Println ( smallestGoldbachError )
var ( # l int # r = len ( nums ) - 1 # ) # # for l <= r { # mid := l + ( r - l )/ 2 # if target == nums [ mid ] { # return mid # } # if target < nums [ mid ] { # r = mid - 1 # } else { # l = mid + 1 # } # } # return l
if head == nil || m == n { # return head # } # fake := & ListNode { Next : head } # tmp := fake # for i := 0 ; i < m - 1 ; i ++ { # tmp = tmp . Next # } # current , post := tmp . Next , tmp . Next . Next # tail := current # count := n - m # var ptr * ListNode # for ; count > 0 ; count -- { # ptr = post . Next # post . Next = current # current = post # post = ptr # } # tail . Next = post # tmp . Next = current # return fake . Next
var tests = [] struct { # n int # b bool # }{ # { 0 , false }, # { 5 , false }, # { 1 6 , true }, # } # # for _ , tt := range tests { # b := isPowerOfFour ( tt . n ) # if b != tt . b { # t . Errorf (" STR ", tt . n , b , tt . b ) # } # }
res := make ([] int , 0 ) # indexes := make ([] int , 0 ) # for i := 0 ; i < len ( nums ); i ++ { # res = append ( res , - 1 ) # } # for i := 0 ; i < len ( nums )* 2 ; i ++ { # num := nums [ i % len ( nums )] # for len ( indexes ) > 0 && nums [ indexes [ len ( indexes )- 1 ]] < num { # index := indexes [ len ( indexes )- 1 ] # res [ index ] = num # indexes = indexes [: len ( indexes )- 1 ] # } # indexes = append ( indexes , i % len ( nums )) # } # return res
sumA , sumB := 0 , 0 # inA := map [ int ] struct {}{} # for _ , a := range A { # sumA += a # inA [ a ] = struct {}{} # } # for _ , b := range B { # sumB += b # } # m := ( sumA - sumB ) / 2 # a , b := 0 , 0 # for _ , b = range B { # a = b + m # if _ , ok := inA [ a ]; ok { # break # } # } # return [] int { a , b }
t . Parallel () # for _ , tc := range testcases { # if moves := TowerOfHanoiMoves ( tc . disks ); ! reflect . DeepEqual ( moves , tc . moves ) { # t . Errorf (" STR ", tc . moves , moves ) # } # }
roman := map [ byte ] int { # ' I ': 1 , ' X ': 1 0 , ' C ': 1 0 0 , ' M ': 1 0 0 0 , ' V ': 5 , ' L ': 5 0 , ' D ': 5 0 0 , # } # var n int # for i := 0 ; i < len ( s ); i ++ { # if j := i + 1 ; j < len ( s ) && roman [ s [ i ]] < roman [ s [ j ]] { # n += roman [ s [ j ]] - roman [ s [ i ]] # i ++ # } else { # n += roman [ s [ i ]] # } # } # return n
testCases := [][] int { # { 1 , 1 , 2 }, # { 0 , 0 , 1 , 1 , 1 , 2 , 2 , 3 , 3 , 4 }, # {}, # } # # expected := [] int { 2 , 5 , 0 } # # for index , data := range testCases { # if res := removeDuplicates ( data ); expected [ index ] != res { # t . Errorf (" STR ", expected [ index ], res ) # } # }
http . HandleFunc (" STR ", rootHandler ) # err := http . ListenAndServe ( # fmt . Sprintf (" STR ", config . Port ), # nil , # ) # if err != nil { # fmt . Println ( err ) # } # select {}
srcFile , err := os . Open (" STR ") # if err != nil { # log . Fatalln ( err ) # } # defer srcFile . Close () # # counts := WordCount ( srcFile ) # fmt . Println (" STR ", counts [" STR "])
fmt . Println ( wordBreak (" STR ", [] string {" STR ", " STR "})) # fmt . Println ( wordBreak (" STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}))
for l , r := 0 , len ( s )- 1 ; l < r ; { # if s [ l ] != s [ r ] { # return isPalindromic ( s , l + 1 , r ) || isPalindromic ( s , l , r - 1 ) # } else { # l ++ # r -- # } # } # return true
if r . lastTimestamp . IsZero () || r . lastTimestamp == now || now . Before ( r . lastTimestamp ) { # return r . Ewma . Current # } # # timeDelta := now . Sub ( r . lastTimestamp ) # # return r . count ( 0 , timeDelta )
m := len ( dungeon ) # if m == 0 { # return 0 # } # n := len ( dungeon [ 0 ]) # dp := make ([][] int , m + 1 ) # for i := 0 ; i < m + 1 ; i ++ { # dp [ i ] = make ([] int , n + 1 ) # for j := 0 ; j < n + 1 ; j ++ { # dp [ i ][ j ] = math . MaxInt 3 2 # } # } # # dp [ m ][ n - 1 ], dp [ m - 1 ][ n ] = 1 , 1 # for i := m - 1 ; i >= 0 ; i -- { # for j := n - 1 ; j >= 0 ; j -- { # need := min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]) - dungeon [ i ][ j ] # if need <= 0 { # dp [ i ][ j ] = 1 # } else { # dp [ i ][ j ] = need # } # } # } # return dp [ 0 ][ 0 ]
fmt . Println ( minPathSum ([][] int {[] int { 1 , 3 , 1 }, [] int { 1 , 5 , 1 }, [] int { 4 , 2 , 1 }}))
res := " STR " # for i := 0 ; i < len ( d ); i ++ { # pointS := 0 # pointD := 0 # for pointS < len ( s ) && pointD < len ( d [ i ]) { # if s [ pointS ] == d [ i ][ pointD ] { # pointD ++ # } # pointS ++ # } # if pointD == len ( d [ i ]) && ( len ( res ) < len ( d [ i ]) || ( len ( res ) == len ( d [ i ]) && res > d [ i ])) { # res = d [ i ] # } # } # return res
self . top -- # high := uint 3 2 ( self . slots [ self . top ]. Num ) # self . top -- # low := uint 3 2 ( self . slots [ self . top ]. Num ) # return int 6 4 ( high )<< 3 2 | int 6 4 ( low )
for _ , test := range xorTestData { # t . Run ( test . description , func ( t * testing . T ) { # encrypted := Encrypt ( byte ( test . key ), [] byte ( test . input )) # if ! reflect . DeepEqual ( string ( encrypted ), test . encrypted ) { # t . Logf (" STR ", test . description ) # t . Fatalf (" STR ", test . encrypted , string ( encrypted )) # } # }) # }
var tests = [] struct { # c int # isSquareSum bool # }{ # { 3 , false }, # { 5 , true }, # { 8 , true }, # { 2 1 , false }, # { 1 9 8 0 1 , true }, # { 2 3 0 5 0 , true }, # } # # for _ , tt := range tests { # isSquareSum := judgeSquareSum ( tt . c ) # if isSquareSum != tt . isSquareSum { # t . Errorf (" STR ", tt . c , isSquareSum , tt . isSquareSum ) # } # }
cases := [] struct { # name string # inputs [] int # expect [][] int # }{ # {" STR ", [] int {- 1 , 0 , 1 , 2 , - 1 , - 4 }, [][] int {{- 1 , - 1 , 2 }, {- 1 , 0 , 1 }}}, # {" STR ", [] int {- 2 , 0 , 0 , 2 , 2 }, [][] int {{- 2 , 0 , 2 }}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := threeSum ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
fmt . Println ( getUglyNumber ( 1 5 0 0 ))
const max = 1 0 0 0 # muls := [ 2 ] int { 3 , 5 } # # var sum int # for i := 0 ; i < max ; i ++ { # for _ , mul := range muls { # if i % mul == 0 { # sum += i # break # } # } # } # # fmt . Println ( sum )
if hm . capacity == 0 { # hm . capacity = defaultCapacity # hm . table = make ([]* node , defaultCapacity ) # } # # node := hm . getNodeByHash ( hash ) # # if node == nil { # hm . table [ hash ] = newNode ( key , value ) # # } else if node . key == key { # hm . table [ hash ] = newNodeWithNext ( key , value , node ) # return value # # } else { # hm . resize () # return hm . putValue ( hash , key , value ) # } # # hm . size ++ # # return value #
if head == nil { # return nil # } # pre , current := head , head # for current != nil { # for current . Next != nil && current . Val == current . Next . Val { # current = current . Next # } # pre . Next = current . Next # pre , current = current . Next , current . Next # } # return head
l , r := 0 , len ( numbers )- 1 # for l < r { # if numbers [ l ]+ numbers [ r ] < target { # l ++ # } else if numbers [ l ]+ numbers [ r ] > target { # r -- # } else { # return [] int { l + 1 , r + 1 } # } # } # return nil
if 0 >= len ( str ) { # return 0 # } # # table := make ([] int , 2 5 6 ) # for i := 0 ; i < len ( str ); i ++ { # table [ str [ i ]]++ # } # for id , value := range table { # if 1 == value { # return byte ( id ) # } # } # return 0
n := len ( s ) # if n == 0 { # return 0 # } # res := 0 # for i := n - 1 ; i >= 0 ; i -- { # if s [ i ] == ' ' { # if res != 0 { # return res # } # continue # } # res ++ # } # return res
l . root . next = & l . root # l . root . prev = & l . root # l . len = 0 # return l
var tests = [] struct { # s string # i int # }{ # {" STR ", 0 }, # {" STR ", 2 }, # {" STR ", - 1 }, # } # # for _ , tt := range tests { # i := firstUniqChar ( tt . s ) # if i != tt . i { # t . Errorf (" STR ", tt . s , i , tt . i ) # } # }
var fname , lname string = " STR ", " STR " # var age int = 3 5 # fmt . Println ( Title ) # fmt . Println (" STR ", fname ) # fmt . Println (" STR ", lname ) # fmt . Println (" STR ", age ) # fmt . Println (" STR ", Country )
cases := [] struct { # name string # inputs [] int # expect bool # }{ # {" STR ", [] int { 5 , 3 , 4 , 5 }, true }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := stoneGame ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if len ( str ) == 0 { # return 0 # } # runes := [] rune ( str ) # var ret int 3 2 # var neg bool # i := 0 # for ; runes [ i ] == rune (' '); i ++ { # } # if runes [ i ] == rune ('-') || runes [ i ] == rune ('+') { # neg = runes [ i ] == rune ('-') # i ++ # } # # for ; i < len ( runes ); i ++ { # if val , ok := toInt ( runes [ i ]); ! ok { # break # } else { # if neg { # if - ret < ( MIN + val )/ 1 0 { # return int ( MIN ) # } # } else { # if ret > ( MAX - val )/ 1 0 { # return int ( MAX ) # } # } # ret = 1 0 * ret + val # } # } # if neg { # return int (- ret ) # } # return int ( ret )
ch := make ( chan string ) # go clientWriter ( conn , ch ) # # who := conn . RemoteAddr (). String () # ch <- " STR " + who # messages <- who + " STR " # entering <- ch # # input := bufio . NewScanner ( conn ) # for input . Scan () { # messages <- who + " STR " + input . Text () # } # # leaving <- ch # messages <- who + " STR " # conn . Close ()
tNode := & TreeNode {} # tNode . val = 3 # # tNode 1 := & TreeNode {} # tNode 1 . val = 5 # # tNode 2 := & TreeNode {} # tNode 2 . val = 1 # # tNode 3 := & TreeNode {} # tNode 3 . val = 6 # # tNode 4 := & TreeNode {} # tNode 4 . val = 2 # # tNode 5 := & TreeNode {} # tNode 5 . val = 0 # # tNode 6 := & TreeNode {} # tNode 6 . val = 8 # # tNode 9 := & TreeNode {} # tNode 9 . val = 7 # # tNode 1 0 := & TreeNode {} # tNode 1 0 . val = 4 # # tNode . left = tNode 1 # tNode . right = tNode 2 # # tNode 1 . left = tNode 3 # tNode 1 . right = tNode 4 # tNode 2 . left = tNode 5 # tNode 2 . right = tNode 6 # # tNode 4 . left = tNode 9 # tNode 4 . right = tNode 1 0 # # luckyNode := Lowest ( tNode , tNode 1 , tNode 2 ) # if luckyNode != tNode { # t . Fatalf (" STR ") # }
has := p . Iter . HasNext () # if ! p . peeked && ! has { # return nil # } else if ! p . peeked { # p . peeked = true # p . peek = p . Iter . Next () # } # return p . peek
l := & ListNode { Next : head } # for i := 0 ; i < n ; i ++ { # head = head . Next # } # # prev := l # for head != nil { # prev = prev . Next # head = head . Next # } # prev . Next = prev . Next . Next # return l . Next
return seek ( r , 0 , io . SeekEnd , 0 )
m , n := len ( A ), len ( B ) # dp := make ([][] int , m + 1 ) # dp [ 0 ] = make ([] int , n + 1 ) # for i := 1 ; i <= m ; i ++ { # dp [ i ] = make ([] int , n + 1 ) # for j := 1 ; j <= n ; j ++ { # if A [ i - 1 ] == B [ j - 1 ] { # dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ] # } else { # dp [ i ][ j ] = max ( dp [ i ][ j - 1 ], dp [ i - 1 ][ j ]) # } # } # } # return dp [ m ][ n ]
return make ([] struct {}, n )
v := ValueOf ( slice ) # if v . Kind () != Slice { # panic (& ValueError { Method : " STR "}) # } # # if v . Len () < 2 { # return func ( i , j int ) {} # } # # typ := v . typecode . Elem () # size := typ . Size () # # header := (* sliceHeader )( v . value ) # tmp := unsafe . Pointer (& make ([] byte , size )[ 0 ]) # # return func ( i , j int ) { # if uint ( i ) >= uint ( header . len ) || uint ( j ) >= uint ( header . len ) { # panic (" STR ") # } # val 1 := unsafe . Pointer ( uintptr ( header . data ) + uintptr ( i )* size ) # val 2 := unsafe . Pointer ( uintptr ( header . data ) + uintptr ( j )* size ) # memcpy ( tmp , val 1 , size ) # memcpy ( val 1 , val 2 , size ) # memcpy ( val 2 , tmp , size ) # }
sum := 0 # # for i := 3 ; i < 1 0 0 0 ; i ++ { # if i % 3 == 0 || i % 5 == 0 { # sum += i # } # } # # fmt . Println ( sum )
n := len ( nums ) # if n == 0 { # return nil # } # # res := [] string {} # begin := nums [ 0 ] # s := " STR " # for i := 0 ; i < n ; i ++ { # if i == n - 1 || nums [ i ]+ 1 != nums [ i + 1 ] { # if nums [ i ] == begin { # s = fmt . Sprintf (" STR ", begin ) # } else { # s = fmt . Sprintf (" STR ", begin , nums [ i ]) # } # # res = append ( res , s ) # if i + 1 < n { # begin = nums [ i + 1 ] # } # } # } # return res
tests := [...] testType { # { # a : " STR ", # b : " STR ", # want : 3 , # }, # { # a : " STR ", # b : " STR ", # want : 6 , # }, # { # a : " STR ", # b : " STR ", # want : 6 , # }, # { # a : " STR ", # b : " STR ", # want : - 1 , # }, # } # for _ , tt := range tests { # got := findLUSlength ( tt . a , tt . b ) # if got != tt . want { # t . Fatalf (" STR ", tt . a , tt . b , got , tt . want ) # } # }
return syscall . Getuid ()
if ! m . exist ( key ) { # e := m . keyL . PushBack ( key ) # m . m [ key ] = [] interface {}{ e , value } # } else { # m . m [ key ].([] interface {})[ 1 ] = value # }
sort . Ints ( nums ) # return nums [ len ( nums )- k ]
if N == 0 || N == 1 { # return N # } # res := fibs [ N ] # if res == 0 { # res = fib ( N - 1 ) + fib ( N - 2 ) # fibs [ N ] = res # } # return res
d := ( sum ( A ) - sum ( B )) / 2 # hash := make ( map [ int ] struct {}, len ( A )) # for _ , val := range A { # hash [ val ] = struct {}{} # } # for _ , val := range B { # if _ , ok := hash [ val + d ]; ok { # return [] int { val + d , val } # } # } # return [] int {}
tests := map [ string ] int { # " STR ": 0 , # " STR ": 4 2 , # " STR ": 1 2 3 , # " STR ": 1 2 3 , # " STR ": 0 , # " STR ": - 4 2 , # " STR ": - 1 2 3 , # " STR ": 0 , # " STR ": 4 1 9 3 , # " STR ": 0 , # " STR ": math . MinInt 3 2 , # " STR ": math . MaxInt 3 2 , # } # # for in , want := range tests { # got := myAtoi ( in ) # if got != want { # t . Fatalf (" STR ", in , got , want ) # } # }
for i := 0 ; i < b . N ; i ++ { # getMatrix ( n ) # }
if root == nil { # return NewNode ( val ) # } # if val < root . val { # root . left = Insert ( root . left , val ) # } else { # root . right = Insert ( root . right , val ) # } # return root
n := len ( A ) # res := 0 # for r := 0 ; r < n ; r ++ { # for c := 0 ; c < n ; c ++ { # a , b := 0 , 0 # for i := 0 ; i < n - r ; i ++ { # for j := 0 ; j < n - c ; j ++ { # a += A [ i ][ j ] & B [ i + r ][ j + c ] # b += B [ i ][ j ] & A [ i + r ][ j + c ] # } # } # res = max ( res , max ( a , b )) # } # } # return res
var recur func ( int , int ) int # recur = func ( l , r int ) int { # if l + 1 >= r { # # return 0 # } # # m := ( l + r ) / 2 # res := recur ( l , m ) + recur ( m , r ) # # i , j := l , m # for i < m && j < r { # if nums [ i ] > 2 * nums [ j ] { # res += m - i # j ++ # } else { # i ++ # } # } # # copy ( nums [ l : r ], merge ( nums [ l : m ], nums [ m : r ])) # # return res # } # return recur ( 0 , len ( nums ))
qs := [] question 3 8 7 { # # { # para 3 8 7 {" STR "}, # ans 3 8 7 { 0 }, # }, # # { # para 3 8 7 {" STR "}, # ans 3 8 7 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 8 7 , q . para 3 8 7 # fmt . Printf (" STR ", p , firstUniqChar ( p . n )) # } # fmt . Printf (" STR ")
t . Parallel () # # for _ , tc := range testcases { # if result := NQueens ( tc . n , [] int {}); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
for i , j := 0 , len ( s )- 1 ; i < j ; { # s [ i ], s [ j ] = s [ j ], s [ i ] # i ++ # j -- # }
ch := make ( chan Edge ) # go func () { # for from , connectedVertices := range g . edges { # for to , _ := range connectedVertices { # if g . isDirected { # ch <- Edge { from , to } # } else { # if from < to { # ch <- Edge { from , to } # } # } # } # } # close ( ch ) # }() # return ch
log . Println (" STR ") # file , err := os . OpenFile ( SOURCE_SOLUTION_README_FILE_PATH , os . O_RDONLY , 0 6 0 0 ) # defer file . Close () # if err != nil { # log . Panicf (" STR ", err . Error ()) # } # # buffer , err := ioutil . ReadAll ( file ) # if err != nil { # log . Panicf (" STR ", err . Error ()) # } # # var tmpRes bytes . Buffer # # tmpl , err := template . New (" STR "). Parse ( string ( buffer )) # err = tmpl . Execute (& tmpRes , problem ) # write ( SOLUTIONS_PATH + problem . PathName +" STR ", string ( tmpRes . Bytes ()))
cases := [] struct { # name string # inputs [] int # target int # expect int # }{ # {" STR ", [] int { 1 , 2 , 2 , 2 , 3 }, 2 , 1 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := BinarySearchLeftBound ( c . inputs , c . target ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if len ( nums ) == 0 || len ( nums ) == 1 { # return 0 # } # low , high := 0 , len ( nums )- 1 # for low <= high { # mid := low + ( high - low )>> 1 # if ( mid == len ( nums )- 1 && nums [ mid - 1 ] < nums [ mid ]) || ( mid > 0 && nums [ mid - 1 ] < nums [ mid ] && ( mid <= len ( nums )- 2 && nums [ mid + 1 ] < nums [ mid ])) || ( mid == 0 && nums [ 1 ] < nums [ 0 ]) { # return mid # } # if mid > 0 && nums [ mid - 1 ] < nums [ mid ] { # low = mid + 1 # } # if mid > 0 && nums [ mid - 1 ] > nums [ mid ] { # high = mid - 1 # } # if mid == low { # low ++ # } # if mid == high { # high -- # } # } # return - 1
tests := [...] testType { # { # in : [][] int { # { 2 , 1 , 1 }, # { 1 , 1 , 0 }, # { 0 , 1 , 1 }, # }, # want : 4 , # }, # { # in : [][] int { # { 2 , 1 , 1 }, # { 0 , 1 , 1 }, # { 1 , 0 , 1 }, # }, # want : - 1 , # }, # { # in : [][] int { # { 0 , 2 }, # }, # want : 0 , # }, # { # in : [][] int { # { 1 , 2 }, # }, # want : 1 , # }, # } # for _ , tt := range tests { # got := orangesRotting ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
t . Run (" STR ", func ( t * testing . T ) { # data 1 := [] int { 1 , 1 , 2 } # got := deleteDuplicates ( MakeListNote ( data 1 )) # want := MakeListNote ([] int { 1 , 2 }) # # if ! Equal ( got , want ) { # fmt . Print (" STR ") # PrintList ( got ) # fmt . Print (" STR ") # PrintList ( want ) # t . Error (" STR ", got , " STR ", want ) # } # }) # # t . Run (" STR ", func ( t * testing . T ) { # got := deleteDuplicates (& ListNode {}) # want := & ListNode {} # if ! Equal ( got , want ) { # fmt . Print (" STR ") # PrintList ( got ) # fmt . Print (" STR ") # PrintList ( want ) # t . Error (" STR ", got , " STR ", want ) # } # })
nums := [][] int { # { 1 , 2 }, # { 3 , 4 }} # # fmt . Println ( matrixReshape ( nums , 1 , 4 )) # fmt . Println ( matrixReshape ( nums , 2 , 4 )) # # fmt . Println ( matrixReshape 2 ( nums , 1 , 4 )) # fmt . Println ( matrixReshape 2 ( nums , 2 , 4 ))
max := int ( math . Ceil ( math . Sqrt ( float 6 4 ( n )))) # divCount := 0 # for i := 1 ; i < int ( max ); i ++ { # if int ( n )% i == 0 { # divCount ++ # if divCount > 1 { # return false # } # } # } # return divCount == 1
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 }, 1 }, # {" STR ", [] int { 1 , 1 , 1 , 2 , 2 , 3 }, 5 }, # {" STR ", [] int { 0 , 0 , 1 , 1 , 1 , 1 , 2 , 3 , 3 }, 7 }, # {" STR ", [] int { 1 , 2 , 3 , 4 }, 4 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := Solution ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # t . Logf (" STR ", c . inputs [: c . expect ]) # }) # }
n 1 , n 2 := len ( nums 1 ), len ( nums 2 ) # if n 1 > n 2 { # n 1 , n 2 , nums 1 , nums 2 = n 2 , n 1 , nums 2 , nums 1 # } # m := make ( map [ int ] struct {}, n 1 ) # for _ , num := range nums 1 { # m [ num ] = struct {}{} # } # # res := make ([] int , 0 , n 1 ) # for _ , num := range nums 2 { # if _ , ok := m [ num ]; ok { # res = append ( res , num ) # delete ( m , num ) # } # } # return res
qs := [] question 1 2 7 { # { # para 1 2 7 {" STR ", " STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 1 2 7 { 5 }, # }, # # { # para 1 2 7 {" STR ", " STR ", [] string {" STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 1 2 7 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 7 , q . para 1 2 7 # fmt . Printf (" STR ", p , ladderLength ( p . b , p . e , p . w )) # } # fmt . Printf (" STR ")
println ( search ([] int { 4 , 5 , 6 , 7 , 0 , 1 , 2 }, 4 ))
var tests = [] struct { # nums [] int # max int # }{ # {[] int { 2 , 3 , - 2 , 4 }, 6 }, # {[] int { 4 , - 2 , 2 , 3 }, 6 }, # {[] int {- 2 , 0 , - 1 }, 0 }, # {[] int {- 2 , - 4 , - 1 }, 8 }, # {[] int {- 2 }, - 2 }, # } # # for _ , tt := range tests { # max := maxProduct ( tt . nums ) # if max != tt . max { # t . Errorf (" STR ", tt . nums , max , tt . max ) # } # }
h . root . prev = & h . root # h . root . next = & h . root # h . root . parent = & h . root # h . root . left = & h . root # h . root . right = & h . root # h . len = 0
mapTmp := make ( map [ int ] bool ) # for _ , val := range nums { # if mapTmp [ val ] { # return val # } else { # mapTmp [ val ] = true # } # } # return 0
stack . sp = & StackItem { item : item , next : stack . sp } # stack . depth ++
starttime := time . Now () # # # top := 1 0 0 0 # # for a := 1 ; a <= top ; a ++ { # for b := a ; b + a <= top && top - a - b >= b ; b ++ { # # c := top - b - a # # if a * a + b * b == c * c { # fmt . Println ( a * b * c ) # } # } # } # # fmt . Println (" STR ", time . Since ( starttime ))
responseChannel := make ( chan * Response , * totalCalls * 2 ) # # benchTime := NewTimer () # benchTime . Reset () # wg := & sync . WaitGroup {} # # for i := 0 ; i < * numConnections ; i ++ { # go StartClient ( # toCall , # * headers , # * requestBody , # * method , # * disableKeepAlives , # responseChannel , # wg , # * totalCalls , # ) # wg . Add ( 1 ) # } # # wg . Wait () # # result := CalcStats ( # responseChannel , # benchTime . Duration (), # ) # return result
return syscall . Getenv ( key )
matches , err := filepath . Glob ( indir + " STR ") # if err != nil { # return err # } # # var wg sync . WaitGroup # workChan := make ( chan string ) # errChan := make ( chan error , 1 ) # for i := 0 ; i < runtime . NumCPU (); i ++ { # go func () { # for filepath := range workChan { # err := processFile ( filepath , outdir ) # wg . Done () # if err != nil { # select { # case errChan <- err : # default : # } # } # } # }() # } # # wg . Add ( len ( matches )) # for _ , filepath := range matches { # fmt . Println ( filepath ) # workChan <- filepath # } # close ( workChan ) # # wg . Wait () # # select { # case err := <- errChan : # return err # default : # return nil # }
for i , x := range numbers { # for j , y := range numbers { # if i != j && x + y == k { # return true # } # } # } # return false
obj := Constructor 2 1 1 () # fmt . Printf (" STR ", obj ) # obj . AddWord (" STR ") # fmt . Printf (" STR ", obj ) # obj . AddWord (" STR ") # fmt . Printf (" STR ", obj ) # obj . AddWord (" STR ") # fmt . Printf (" STR ", obj ) # # param 1 := obj . Search (" STR ") # fmt . Printf (" STR ", param 1 , obj ) # param 2 := obj . Search (" STR ") # fmt . Printf (" STR ", param 2 , obj ) # param 3 := obj . Search (" STR ") # fmt . Printf (" STR ", param 3 , obj ) # param 4 := obj . Search (" STR ") # fmt . Printf (" STR ", param 4 , obj )
str := " STR " # str 2 := " STR " # fmt . Println ( reverseVowels ( str )) # fmt . Println ( reverseVowels ( str 2 ))
var n = 2 0 # for i := 1 ; i < 6 0 9 4 9 3 2 0 ; i ++ { # c := make ( chan int , 1 0 0 ) # go func () { # if valid ( i , n ) { # fmt . Println ( i ) # } # c <- - 1 # }() # <- c # } # fmt . Println ( n )
ret := make ([] int , len ( nums 1 )) # for i := 0 ; i < len ( nums 1 ); i ++ { # index := find ( nums 2 , nums 1 [ i ]) # for j := index ; j < len ( nums 2 ); j ++ { # if nums 2 [ j ] > nums 1 [ i ] { # ret [ i ] = nums 2 [ j ] # break # } # } # if ret [ i ] == 0 { # ret [ i ] = - 1 # } # } # return ret
getNodeCount := func ( head * ListNode ) int { # count := 0 # for head != nil { # count ++ # head = head . Next # } # # return count # } # # count := getNodeCount ( head ) # root , _ := helper 1 0 9 ( head , 0 , count - 1 ) # return root
return env [ v ]
tests := [...] testType { # { # in : 3 , # want : " STR ", # }, # { # in : 4 , # want : " STR ", # }, # { # in : 9 , # want : " STR ", # }, # { # in : 2 0 , # want : " STR ", # }, # { # in : 5 8 , # want : " STR ", # }, # { # in : 1 9 9 4 , # want : " STR ", # }, # { # in : 1 1 1 1 1 , # want : " STR ", # }, # } # for _ , tt := range tests { # got := intToRoman ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
s := newStruct () # # if s . Field (" STR "). Name () != " STR " { # t . Errorf (" STR ") # }
flag . Parse () # roots := flag . Args () # if len ( roots ) == 0 { # roots = [] string {" STR "} # } # # fileSizes := make ( chan int 6 4 ) # go func () { # for _ , root := range roots { # walkDir ( root , fileSizes ) # } # close ( fileSizes ) # }() # # var tick <- chan time . Time # if * verbose { # tick = time . Tick ( 5 0 0 * time . Millisecond ) # } # var nfiles , nbytes int 6 4 # loop : # for { # select { # case size , ok := <- fileSizes : # if ! ok { # break loop # } # nfiles ++ # nbytes += size # case <- tick : # printDiskUsage ( nfiles , nbytes ) # } # } # printDiskUsage ( nfiles , nbytes )
var tests = [] struct { # t 1 , t 2 * TreeNode # merged * TreeNode # }{ # { newTree ( 1 , 3 , 2 , 5 ), newTree ( 2 , 1 , 3 , nil , 4 , nil , 7 ), newTree ( 3 , 4 , 5 , 5 , 4 , nil , 7 )}, # } # # for _ , tt := range tests { # merged := mergeTrees ( tt . t 1 , tt . t 2 ) # if reflect . DeepEqual ( merged , tt . merged ) == false { # t . Errorf (" STR ", tt . t 1 , tt . t 2 , merged , tt . merged ) # } # }
if len ( nums ) == 0 { # return 0 # } # i := 0 # for _ , num := range nums { # if num != nums [ i ] { # i ++ # nums [ i ] = num # } # } # return i + 1
c := 0 # for i := 0 ; i < len ( nums )- 1 ; i ++ { # if nums [ i ] > nums [ i + 1 ] { # if i > 0 { # if nums [ i - 1 ] <= nums [ i + 1 ] { # nums [ i ] = nums [ i - 1 ] # } else { # nums [ i + 1 ] = nums [ i ] # } # } # c ++ # } # } # return c <= 1
return DialOption { func ( do * dialOptions ) { # do . dial = dial # }}
elementSetCh := make ( chan [] string ) # go GenerateElementSet ( elementSetCh , n ) # elementSet := <- elementSetCh # # var recursiveGenerate func ([] string , int , [] string ) # var permutations [] string # recursiveGenerate = func ( previousIteration [] string , n int , elements [] string ) { # if n == 1 { # permutations = append ( permutations , strings . Join ( elements , "")) # } else { # for i := 0 ; i < n ; i ++ { # recursiveGenerate ( previousIteration , n - 1 , elements ) # if n % 2 == 1 { # tmp := elements [ i ] # elements [ i ] = elements [ n - 1 ] # elements [ n - 1 ] = tmp # } else { # tmp := elements [ 0 ] # elements [ 0 ] = elements [ n - 1 ] # elements [ n - 1 ] = tmp # } # } # } # } # recursiveGenerate ( permutations , n , elementSet ) # out <- permutations
if n < 2 { # return false # } # for i := 2 ; i * i <= n ; i ++ { # if n % i == 0 { # return false # } # } # return true
if shell . k < shell . n { # return 1 # } # if answer , ok := table [ shell ]; ok { # return answer # } # # answer := int 6 4 ( 1 ) # # for i := 0 ; i <= shell . k - shell . n ; i ++ { # answer += red ( key { shell . n , i }) # } # # table [ shell ] = answer # # return answer
conn , err := net . Dial (" STR ", " STR ") # if err != nil { # panic ( err ) # } # defer conn . Close () # # bs , _ := ioutil . ReadAll ( conn ) # fmt . Println ( string ( bs )) #
count := make ([] int , n 1 + 1 ) # last := make ([] int , len ( s 2 )) # # j , cnt := 0 , 0 # for k := 1 ; k <= n 1 ; k ++ { # for i := 0 ; i < len ( s 1 ); i ++ { # if s 1 [ i ] == s 2 [ j ] { # j ++ # if j == len ( s 2 ) { # j = 0 # cnt ++ # } # } # } # # if last [ j ] == 0 { # count [ k ] = cnt # last [ j ] = k # } else { # start := last [ j ] # p := k - start # t := cnt - count [ start ] # # ans := ( n 1 - start )/ p * t + count [ start +( n 1 - start )% p ] # return ans / n 2 # } # } # # return cnt / n 2
finish := make ( chan struct {}) # var done sync . WaitGroup # done . Add ( 1 ) # go func () { # defer done . Done () # select { # case <- time . After ( 5 * time . Minute ): # fmt . Println (" STR ") # case <- finish : # } # }() # t 0 := time . Now () # sleep := rand . Int 6 3 n ( 2 0 ) # time . Sleep ( time . Duration ( sleep ) * time . Second ) # close ( finish ) # done . Wait () # fmt . Printf (" STR ", time . Since ( t 0 ))
grids := [][][] byte { # { # {' 1 ', ' 1 ', ' 0 ', ' 0 ', ' 0 '}, # {' 1 ', ' 1 ', ' 0 ', ' 0 ', ' 0 '}, # {' 0 ', ' 0 ', ' 1 ', ' 0 ', ' 0 '}, # {' 0 ', ' 0 ', ' 0 ', ' 1 ', ' 1 '}, # }, # {}, # } # expected := [] int { 3 , 0 } # # for index , grid := range grids { # if res := numIslands ( grid ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # } #
fs := http . FileServer ( http . Dir ( dir )) # log . Print (" STR " + dir + " on http : ) # http . ListenAndServe (" STR ", http . HandlerFunc ( func ( resp http . ResponseWriter , req * http . Request ) { # resp . Header (). Add (" STR ", " STR ") # if strings . HasSuffix ( req . URL . Path , " STR ") { # resp . Header (). Set (" STR ", " STR ") # } # fs . ServeHTTP ( resp , req ) # }))
result := make ([][] int , 0 ) # i := 0 # for i < len ( intervals ) && intervals [ i ][ 1 ] < newInterval [ 0 ] { # result = append ( result , intervals [ i ]) # i ++ # } # # var overlapping [] int # for i < len ( intervals ) && intervals [ i ][ 0 ] <= newInterval [ 1 ] { # if overlapping == nil { # overlapping = make ([] int , 2 ) # overlapping [ 0 ] = intervals [ i ][ 0 ] # } # # overlapping [ 1 ] = intervals [ i ][ 1 ] # i ++ # } # # if overlapping == nil { # result = append ( result , newInterval ) # } else { # p 0 := int ( math . Min ( float 6 4 ( overlapping [ 0 ]), float 6 4 ( newInterval [ 0 ]))) # p 1 := int ( math . Max ( float 6 4 ( overlapping [ 1 ]), float 6 4 ( newInterval [ 1 ]))) # result = append ( result , [] int { p 0 , p 1 }) # } # # for i < len ( intervals ) { # result = append ( result , intervals [ i ]) # i ++ # } # # return result
s := " STR " # expected := " STR " # # if res := reverseWords ( s ); res != expected { # t . Errorf (" STR ", expected , res ) # }
return parser . unread >= length || yaml_parser_update_buffer ( parser , length )
l := len ( digits ) # for i := l - 1 ; i >= 0 ; i -- { # if digits [ i ] < 9 { # digits [ i ]++ # return digits # } # digits [ i ] = 0 # } # res := [] int { 1 } # res = append ( res , digits ...) # return res
if head == nil { return nil } # if head . Next == nil { return & TreeNode { Val : head . Val } } # slow , fast := head , head # var prev * ListNode # for fast != nil && fast . Next != nil { # prev = slow # slow = slow . Next # fast = fast . Next . Next # } # left , right := head , slow . Next # mid := slow # if prev != nil { # prev . Next = nil # } # root := & TreeNode { Val : mid . Val } # root . Left = Solution ( left ) # root . Right = Solution ( right ) # return root
n := len ( nums ) # res := make ([] int , n ) # for i := 0 ; i < n ; i ++ { # res [ i ] = - 1 # } # # s := make ([] int , 0 , n ) # for i := 0 ; i < n * 2 ; i ++ { # for len ( s ) != 0 && nums [ s [ len ( s )- 1 ]] < nums [ i % n ] { # res [ s [ len ( s )- 1 ]] = nums [ i % n ] # s = s [: len ( s )- 1 ] # } # s = append ( s , i % n ) # } # return res
naturals := make ( chan int ) # squares := make ( chan int ) # # go counter ( naturals ) # go squarer ( squares , naturals ) # printer ( squares )
if mem [ x ][ y ] != 0 { # return mem [ x ][ y ] # } # if x == n && y == n { # return 1 # } # count := 0 # if y < n { # count += latticePathsHelper ( n , x , y + 1 , mem ) # } # if x < n { # count += latticePathsHelper ( n , x + 1 , y , mem ) # } # mem [ x ][ y ] = count # return count
fmt . Println (" STR ") # abundantList = buildAbundantList () # fmt . Println ( len ( abundantList )) # sumMap = buildSumOfAbundants () # checkSumOfAbundantsNumbers ()
type Server struct { # Name string ` structs :" STR "` # ID int 3 2 ` structs :" STR "` # Enabled bool ` structs :" STR "` # } # # s := & Server { # Name : " STR ", # ID : 7 8 9 0 1 2 , # } # # m := Map ( s ) # # fmt . Printf (" STR ", m [" STR "]) # fmt . Printf (" STR ", m [" STR "]) # fmt . Printf (" STR ", m [" STR "]) #
widFact := new ( big . Int ). MulRange ( 1 , wid ) # heiFact := new ( big . Int ). MulRange ( 1 , hei ) # numerator := new ( big . Int ). MulRange ( 1 , wid + hei ) # denominator := new ( big . Int ). Mul ( widFact , heiFact ) # paths := new ( big . Int ). Div ( numerator , denominator ) # fmt . Println ( paths )
qs := [] question 1 1 7 5 { # # { # para 1 1 7 5 { 5 }, # ans 1 1 7 5 { 1 2 }, # }, # # { # para 1 1 7 5 { 9 9 }, # ans 1 1 7 5 { 7 5 7 6 3 8 5 4 }, # }, # # { # para 1 1 7 5 { 1 0 0 }, # ans 1 1 7 5 { 6 8 2 2 8 9 0 1 5 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 1 7 5 , q . para 1 1 7 5 # fmt . Printf (" STR ", p , numPrimeArrangements ( p . one )) # } # fmt . Printf (" STR ")
n ^= n >> 2 # return n &( n - 1 ) == 0
if digits == " STR " { # return [] string {} # } # res = [] string {} # findCombination (& digits , 0 , " STR ") # return res
if nil == root { # return nil # } # # return & TreeNode { Val : root . Val , Left : invertTree ( root . Right ), Right : invertTree ( root . Left )}
return parseTag ( st . Get (" STR "))
tests := [...] testType { # { # in : [] int { 2 , 1 }, # want : false , # }, # { # in : [] int { 3 , 5 , 5 }, # want : false , # }, # { # in : [] int { 0 , 3 , 2 , 1 }, # want : true , # }, # { # in : [] int { 1 , 2 , 3 , 2 }, # want : true , # }, # { # in : [] int { 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 }, # want : false , # }, # { # in : [] int { 1 , 2 , 3 , 4 , 5 }, # want : false , # }, # } # for _ , tt := range tests { # got := validMountainArray ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
this . mutex . Lock () # if this . closed { # this . mutex . Unlock () # return nil # } # this . wg . Add ( 1 ) # defer this . wg . Done () # e := this . list . Front () # for e == nil { # this . cond . Wait () # if this . closed { # this . mutex . Unlock () # return nil # } # e = this . list . Front () # } # defer this . mutex . Unlock () # return this . list . Remove ( e )
if _ , ok := interrupts [ name ]; ok { # if interrupts [ name ]. Value != index { # fmt . Fprintf ( os . Stderr , " STR ", # name , interrupts [ name ]. Value , index ) # } # parts := strings . Split ( interrupts [ name ]. Description , " STR " ) # hasDescription := false # for _ , part := range parts { # if part == description { # hasDescription = true # } # } # if ! hasDescription { # interrupts [ name ]. Description += " STR " # } # } else { # interrupts [ name ] = & Interrupt { # Name : name , # HandlerName : interruptName + " STR ", # PeripheralIndex : len ( interrupts ), # Value : index , # Description : description , # } # }
tests := [...] testType { # { # in : 4 , # want : 2 , # }, # { # in : 8 , # want : 2 , # }, # { # in : 0 , # want : 0 , # }, # { # in : 1 , # want : 1 , # }, # } # for _ , tt := range tests { # got := mySqrt ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
last = nil # head = nil # dfs ( root ) # return head
n := len (* pq ) # item := e .(* entry ) # item . index = n # * pq = append (* pq , item )
return v . flags & valueFlagIndirect != 0
t . Parallel () # for tcid , tc := range testcases { # if result := MergeOverlappingIntervals ( tc . input ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tcid , tc . expected , result ) # } # }
n := len ( list ) # left := 0 # right := n - 1 # if n == 1 || list [ left ] < list [ right ] { # return list [ 0 ] # } # for left <= right { # mid := left + ( right - left )/ 2 # if mid > 0 && list [ mid - 1 ] > list [ mid ] { # return list [ mid ] # } else if list [ mid ] > list [ right ] { # left = mid + 1 # } else { # right = mid - 1 # } # } # return - 1
size := len ( persons ) # # votes := make ([] int , size ) # leaders := make ([] int , size ) # # leader := persons [ 0 ] # for i := 0 ; i < size ; i ++ { # p := persons [ i ] # votes [ p ]++ # if votes [ p ] >= votes [ leader ] { # leader = p # } # leaders [ i ] = leader # } # return TopVotedCandidate { times , leaders }
position := generateHash ( key ) # if table . data [ position ] == nil { # return false # } # if table . data [ position ]. key == key { # table . data [ position ] = table . data [ position ]. next # return true # } # current := table . data [ position ] # for current . next != nil { # if current . next . key == key { # current . next = current . next . next # return true # } # current = current . next # } # return false
ans , count := 0 , 0 # for _ , v := range nums { # if 1 == v { # count ++ # if ans < count { # ans = count # } # } else { # count = 0 # } # } # return ans
res := 0 # # var dfs func (* TreeNode , int ) # dfs = func ( node * TreeNode , tmp int ) { # if node == nil { # return # } # # tmp = tmp * 1 0 + node . Val # if node . Left == nil && node . Right == nil { # res += tmp # return # } # dfs ( node . Left , tmp ) # dfs ( node . Right , tmp ) # } # dfs ( root , 0 ) # return res
var i , j = 0 , 0 # # for i < len ( s ) && j < len ( t ) { # if s [ i ] == t [ j ] { # i ++ # } # j ++ # } # return i == len ( s )
var tests = [] struct { # roman string # num int # }{ # {" STR ", 3 }, # {" STR ", 4 }, # {" STR ", 9 }, # {" STR ", 5 8 }, # {" STR ", 5 4 7 }, # {" STR ", 1 9 9 4 }, # } # # for _ , tt := range tests { # num := romanToInt ( tt . roman ) # if num != tt . num { # t . Errorf (" STR ", tt . roman , num , tt . num ) # } # }
testData := [][ 2 ] int { # { 3 , 2 }, # { 5 1 , 9 }, # { 9 , 9 }, # } # # expectedData := [] int { 3 , 1 9 1 6 7 9 7 3 1 1 , 1 2 8 7 0 } # # for index , data := range testData { # if res := uniquePaths ( data [ 0 ], data [ 1 ]); res != expectedData [ index ] { # t . Errorf (" STR ", expectedData [ index ], res ) # } # }
return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { # log . Println (" STR ") # if r . URL . Path == " STR " { # if r . URL . Query (). Get (" STR ") == " STR " { # log . Println (" STR ") # next . ServeHTTP ( w , r ) # } else { # log . Println (" STR ") # return # } # } else { # next . ServeHTTP ( w , r ) # } # # log . Println (" STR ") # })
arr := [] int {- 2 , 1 , - 3 , 4 , - 1 , 2 , 1 , - 5 , 4 } # maxSum := arr [ 0 ] # maxCurrnet := maxSum # for i := 1 ; i < len ( arr ); i ++ { # maxCurrnet = int ( math . Max ( float 6 4 ( arr [ i ]), float 6 4 ( maxCurrnet + arr [ i ]))) # maxSum = int ( math . Max ( float 6 4 ( maxSum ), float 6 4 ( maxCurrnet ))) # } # fmt . Println ( maxSum )
n := len ( difficulty ) # jobs := make ([][ 2 ] int , n ) # for i , d := range difficulty { # jobs [ i ] = [ 2 ] int { d , profit [ i ]} # } # sort . Slice ( jobs , func ( i , j int ) bool { # return jobs [ i ][ 0 ] < jobs [ j ][ 0 ] # }) # sort . Ints ( worker ) # i , maxp := 0 , 0 # res := 0 # for _ , ability := range worker { # for i < n && ability >= jobs [ i ][ 0 ] { # maxp = max ( maxp , jobs [ i ][ 1 ]) # i ++ # } # res += maxp # } # return res
return b . data
if start > destination { # start , destination = destination , start # } # d 1 , d 2 := 0 , 0 # for i := start ; i < destination ; i ++ { # d 1 += distance [ i ] # } # for i := destination ; i < len ( distance ); i ++ { # d 2 += distance [ i ] # } # for i := 0 ; i < start ; i ++ { # d 2 += distance [ i ] # } # if d 1 < d 2 { # return d 1 # } # return d 2
wordsMap := make ( map [ string ] int ) # for _ , v := range words { # wordsMap [ v ] = wordsMap [ v ] + 1 # } # wordLen := len ( words [ 0 ]) # l := wordLen * len ( words ) # e := len ( s ) - l + 1 # var result [] int # for i := 0 ; i < e ; i ++ { # tempMap := make ( map [ string ] int ) # var j int # for ; j < len ( words ); j ++ { # index := i + j * wordLen # word := s [ index : index + wordLen ] # if _ , ok := wordsMap [ word ]; ok { # tempMap [ word ] = tempMap [ word ] + 1 # if tempMap [ word ] > wordsMap [ word ] { # break # } # } else { # break # } # } # if j == len ( words ) { # result = append ( result , i ) # } # } # return result
if len ( s ) != len ( t ) { # return false # } # # m := make ( map [ rune ] int ) # # for _ , r := range s { # m [ r ]++ # } # # for _ , r := range t { # if m [ r ] == 0 { # return false # } # m [ r ]-- # } # # return true
return longestPalindromeLinear ( s )
sumA := 0 # isExist := make ( map [ int ] bool , len ( A )) # for _ , a := range A { # sumA += a # isExist [ a ] = true # } # # sumB := 0 # for _ , b := range B { # sumB += b # } # # halfDiff := ( sumA - sumB ) / 2 # # a , b := 0 , 0 # for _ , b = range B { # a = b + halfDiff # if isExist [ a ] { # break # } # } # # return [] int { a , b }
var tests = [] struct { # rowIndex int # row [] int # }{ # { 3 , [] int { 1 , 3 , 3 , 1 }}, # } # # for _ , tt := range tests { # row := getRow ( tt . rowIndex ) # if reflect . DeepEqual ( row , tt . row ) == false { # t . Errorf (" STR ", tt . rowIndex , row , tt . row ) # } # }
stack := make ([] int , 0 ) # # for _ , asteroid := range asteroids { # flag := true # for len ( stack ) > 0 && asteroid < 0 && stack [ len ( stack )- 1 ] > 0 { # if stack [ len ( stack )- 1 ] == - asteroid { # stack = stack [: len ( stack )- 1 ] # } else if stack [ len ( stack )- 1 ] < - asteroid { # stack = stack [: len ( stack )- 1 ] # continue # } # flag = false # break # } # if flag { # stack = append ( stack , asteroid ) # } # } # return stack
t . Parallel () # # for _ , tc := range testcases { # if res := CoinDenominationsNeeded ( tc . ways ); ! reflect . DeepEqual ( res , tc . denoms ) { # t . Errorf (" STR ", tc . denoms , res ) # } # }
row , col , result := len ( A ), len ( A [ 0 ]), make ([][] int , len ( A [ 0 ])) # for i := range result { # result [ i ] = make ([] int , row ) # } # for i := 0 ; i < row ; i ++ { # for j := 0 ; j < col ; j ++ { # result [ j ][ i ] = A [ i ][ j ] # } # } # return result
if n == 1 { # return # } # maxCake := 0 # maxCakeIndex := 0 # for i := 0 ; i < n ; i ++ { # if arr [ i ] > maxCake { # maxCakeIndex = i # maxCake = arr [ i ] # } # } # reverseCake ( arr , 0 , maxCakeIndex ) # cakeRes = append ( cakeRes , maxCakeIndex + 1 ) # reverseCake ( arr , 0 , n - 1 ) # cakeRes = append ( cakeRes , n ) # # cakeSort ( arr , n - 1 )
tests := [...] struct { # input [] int # expected [] int # }{ # { # input : [] int { 1 , 2 , 3 , 4 }, # expected : [] int { 1 , 2 , 3 , 4 }, # }, # { # input : [] int { 1 , 2 , 3 , NULL , 5 }, # expected : [] int { 1 , 2 , 3 , NULL , 5 }, # }, # { # input : [] int { 1 , 2 , 3 , NULL , 5 , NULL , NULL , NULL }, # expected : [] int { 1 , 2 , 3 , NULL , 5 }, # }, # { # input : nil , # expected : nil , # }, # } # for _ , tc := range tests { # output := TreeNode 2 SliceInt ( SliceInt 2 TreeNode ( tc . input )) # if ! reflect . DeepEqual ( output , tc . expected ) { # t . Fatalf (" STR ", tc . input , output , tc . expected ) # } # }
var vec [ 1 ] float 6 4 # vec [ 0 ] = arg # # t := vec [ 0 ] + N # bx 0 := int ( t ) & BM # bx 1 := ( bx 0 + 1 ) & BM # rx 0 := t - float 6 4 ( int ( t )) # rx 1 := rx 0 - 1 . # # sx := sCurve ( rx 0 ) # u := rx 0 * p . g 1 [ p . p [ bx 0 ]] # v := rx 1 * p . g 1 [ p . p [ bx 1 ]] # # return lerp ( sx , u , v )
qs := [] question 2 0 2 { # # { # para 2 0 2 { 2 0 2 }, # ans 2 0 2 { false }, # }, # # { # para 2 0 2 { 1 9 }, # ans 2 0 2 { true }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 0 2 , q . para 2 0 2 # fmt . Printf (" STR ", p , isHappy ( p . one )) # } # fmt . Printf (" STR ")
t . Parallel () # for _ , tc := range testcases { # var enc string # if enc = RunLengthEncoding ( tc . orig ); enc != tc . encoded { # t . Errorf (" STR ", tc . encoded , enc ) # } # if dec := RunLengthDecoding ( enc ); dec != tc . orig { # t . Errorf (" STR ", tc . orig , dec ) # } # }
n . keyValue = append ( n . keyValue , & keyValue { key , value }) # i := len ( n . keyValue ) - 1 # for ; i > 0 && n . Less ( i , i - 1 ); i -- { # n . Swap ( i - 1 , i ) # } # temp := n . c [ i :] # n . c = append ( n . c [: i ], nil ) # n . c = append ( n . c , temp ...) # return i
qs := [] question 4 0 5 { # # { # para 4 0 5 { 2 6 }, # ans 4 0 5 {" STR "}, # }, # # { # para 4 0 5 {- 1 }, # ans 4 0 5 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 0 5 , q . para 4 0 5 # fmt . Printf (" STR ", p , toHex ( p . one )) # } # fmt . Printf (" STR ")
lessTop := & ListNode {} # less := lessTop # greaterTop := & ListNode {} # greater := greaterTop # for n := head ; n != nil ; n = n . Next { # if n . Val < x { # less . Next = n # less = n # continue # } # greater . Next = n # greater = n # } # less . Next = greaterTop . Next # greater . Next = nil # return lessTop . Next
if head == nil { # return false # } # # slow := head . Next # var fast * ListNode # if slow != nil { # fast = slow . Next # } # # for fast != nil { # if slow == fast { # return true # } # # slow = slow . Next # fast = fast . Next # if fast != nil { # fast = fast . Next # } # } # # return false
if len ( x ) != len ( y ) { # return false # } # for i := 0 ; i < len ( y ); i ++ { # flag := false # for j := 0 ; j < len ( y ); j ++ { # if reflect . DeepEqual ( y [ i ], x [ j ]) { # flag = true # } # } # if flag == false { # return false # } # } # return true
h . binHeapArrayIf . Append ( i ) # for idx := h . Last (); h . Valid ( h . Parent ( idx )) && h . Key ( idx ) > h . Key ( h . Parent ( idx )); { # h . Swap ( idx , h . Parent ( idx )) # idx = h . Parent ( idx ) # }
<- this . pool
if si . pos >= len ( si . Slice ) { # return nil # } # result := si . Slice [ si . pos ] # si . pos ++ # return result
res := 0 . # n := len ( points ) # for i := 0 ; i < n ; i ++ { # for j := i + 1 ; j < n ; j ++ { # for k := j + 1 ; k < n ; k ++ { # res = max ( res , area ( points [ i ], points [ j ], points [ k ])) # } # } # } # return res
head := & list . Element { Value : - 1 } # if this . queue . Len () > 0 { # head = this . queue . Front () # this . queue . Remove ( this . queue . Front ()) # } # if this . deque . Len () > 0 && this . deque . Front (). Value == head . Value { # this . deque . Remove ( this . deque . Front ()) # } # return head . Value .( int )
if w . pos > len ( w . buf ) { # return 0 , fmt . Errorf (" STR ") # } else if w . pos == len ( w . buf ) { # w . buf = append ( w . buf , buf ...) # } else if w . pos + len ( buf ) <= len ( w . buf ) { # copy ( w . buf [ w . pos :], buf ) # } else if w . pos + len ( buf ) > len ( w . buf ) { # overlap := copy ( w . buf [ w . pos :], buf ) # w . buf = append ( w . buf , buf [ overlap :]...) # } # w . pos += len ( buf ) # return len ( buf ), nil
err := da . CheckRangeFromIndex ( index ) # # if err != nil { # return err # } # # da . ElementData [ index ] = element # # return nil
old := * q # n := len ( old ) # item := old [ n - 1 ] # * q = old [ 0 : n - 1 ] # return item
if num 1 == " STR " || num 2 == " STR " { # return " STR " # } # # digitResult := make ( map [ byte ][] byte ) # if len ( num 1 ) > len ( num 2 ) { # return string ( helper 4 3 ([] byte ( num 2 ), [] byte ( num 1 ), 0 , len ( num 1 )- 1 , digitResult )) # } # # return string ( helper 4 3 ([] byte ( num 1 ), [] byte ( num 2 ), 0 , len ( num 2 )- 1 , digitResult ))
var letter byte # for i := 0 ; i < len ( s ); i ++ { # letter ^= s [ i ] # } # for i := 0 ; i < len ( t ); i ++ { # letter ^= t [ i ] # } # return letter
xs := [] int { # 1 , 2 , 3 , 4 , 5 , # } # total := 0 # for _ , x := range xs { # total += x # } # return total
ans := make ([] bool , len ( queries )) # for i , q := range queries { # ptn := [] rune ( pattern ) # for _ , r := range q { # if len ( ptn ) > 0 && ptn [ 0 ] == r { # ptn = ptn [ 1 :] # } else if r >= ' A ' && r <= ' Z ' { # ptn = [] rune { 1 } # break # } # } # ans [ i ] = len ( ptn ) == 0 # } # return ans
fre := make ([] int , 2 6 ) # for _ , t := range text { # fre [ t -' a ']++ # } # return min ( fre [ 1 ], min ( fre [ 0 ], min ( fre [ 1 1 ]/ 2 , min ( fre [ 1 4 ]/ 2 , fre [ 1 3 ]))))
ans := 0 # height , width := len ( grid ), len ( grid [ 0 ]) # # for i := 0 ; i < height ; i ++ { # for j := 0 ; j < width ; j ++ { # tmp := 0 ; # if 1 == grid [ i ][ j ] { # tmp = dfs ( grid , i , j ) # if tmp > ans { # ans = tmp # } # } # } # } # return ans
a , b := 0 , 0 # for i , num := range nums { # if i % 2 == 0 { # a = max ( a + num , b ) # } else { # b = max ( a , b + num ) # } # } # return max ( a , b )
d := make ([][] int , len ( s )+ 1 ) # for i := range d { # d [ i ] = make ([] int , len ( t )+ 1 ) # d [ i ][ 0 ] = i # } # for j := range d [ 0 ] { # d [ 0 ][ j ] = j # } # for j , tr := range t { # for i , sr := range s { # if sr == tr { # d [ i + 1 ][ j + 1 ] = d [ i ][ j ] # } else { # d [ i + 1 ][ j + 1 ] = minimum ( d [ i ][ j + 1 ]+ 1 , # d [ i + 1 ][ j ]+ 1 , # d [ i ][ j ]+ 1 ) # } # } # } # return d [ len ( s )][ len ( t )]
if num == 1 { # return false # } # # sum := 1 # root := int ( math . Sqrt ( float 6 4 ( num ))) # # for i := 2 ; i <= root ; i ++ { # if num % i == 0 { # sum += i + ( num / i ) # } # } # # return sum == num
if len ( matrix ) == 0 || len ( matrix [ 0 ]) == 0 { # return false # } # # m , n := len ( matrix ), len ( matrix [ 0 ]) # start , end , mid := 0 , m * n - 1 , 0 # for start <= end { # mid = start + ( end - start )/ 2 # v := matrix [ mid / n ][ mid % n ] # # if target < v { # end = mid - 1 # } else if target > v { # start = mid + 1 # } else { # return true # } # } # # return false
weight := math . Exp ( float 6 4 ( timeDelta . Nanoseconds ()) * e . weightHelper ) # return e . Current * weight + next *( 1 - weight )
log . SetPrefix (" STR ") # log . SetFlags ( log . Ldate | log . Lmicroseconds | log . Llongfile )
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 2 , 3 }, 6 }, # {" STR ", [] int { 1 , 2 , 3 , 4 }, 2 4 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := maximumProduct 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
starttime := time . Now () # # number := # " STR " # # record := 0 # for i := 0 ; i < len ( number )- 5 ; i ++ { # # prod := 1 # for j := 0 ; j < 5 ; j ++ { # char , _ := strconv . Atoi ( string ( number [ i + j ])) # prod *= char # } # if prod > record { # record = prod # } # } # # fmt . Println ( record ) # # fmt . Println (" STR ", time . Since ( starttime ))
ss := make ([] string , n + 1 ) # for i := 1 ; i <= n ; i ++ { # if i % 1 5 == 0 { # ss [ i ] = " STR " # } else if i % 5 == 0 { # ss [ i ] = " STR " # } else if i % 3 == 0 { # ss [ i ] = " STR " # } else { # ss [ i ] = fmt . Sprintf (" STR ", i ) # } # } # return ss [ 1 :]
xdist := A . x - B . x # ydist := A . y - B . y # # return math . Sqrt ( float 6 4 ( xdist * xdist + ydist * ydist ))
tests := [...] testType { # { # in : [] int { 1 , 4 , 3 , 2 }, # want : 4 , # }, # } # for _ , tt := range tests { # got := arrayPairSum ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
return ( key .( uint 3 2 ) & (( 1 << uint 3 2 ( lgu )) - 1 )) >> uint 3 2 ( lgu >> 1 )
if root == nil { # return [] int {} # } # queue , res := make ([]* TreeNode , 0 ), [] int {} # queue = append ( queue , root ) # for len ( queue ) != 0 { # cRoot := queue [ 0 ] # res = append ( res , cRoot . Val ) # if cRoot . Left != nil { # queue = append ( queue , cRoot . Left ) # } # if cRoot . Right != nil { # queue = append ( queue , cRoot . Right ) # } # queue = queue [ 1 :] # } # return res
sum := 0 # for i := 1 ; i < 1 0 0 0 ; i ++{ # if (( i % 3 == 0 ) || ( i % 5 == 0 )){ # sum += i # } # } # fmt . Println ( sum )
t . Parallel () # # for _ , tc := range testcases { # if result := SumSublist ( tc . L , tc . start , tc . end ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
defer wg . Done () # # next : # for outer := 2 ; outer < 5 0 0 0 ; outer ++ { # for inner := 2 ; inner < outer ; inner ++ { # if outer % inner == 0 { # continue next # } # } # fmt . Printf (" STR ", prefix , outer ) # } # fmt . Println (" STR ", prefix )
t . Parallel () # for _ , tc := range testcases { # if result , _ := Reconstruct ( tc . preorder , tc . inorder ); ! treesEqual ( result , tc . expected ) { # t . Errorf (" STR ") # } # }
if root == nil { # return nil # } # # var queue = []* TreeNode { root } # # for { # counter := len ( queue ) # if counter == 0 { # break # } # # for k , q := range queue [: counter ] { # if q == u { # if k == counter - 1 { # return nil # } else { # return queue [ k + 1 ] # } # } # if q . Left != nil { # queue = append ( queue , q . Left ) # } # if q . Right != nil { # queue = append ( queue , q . Right ) # } # } # queue = queue [ counter :] # } # return nil
return intSqrt ( n )
a , l := 0 , 0 # # for i , _ := range s { # if s [ i ] == ' A ' { # a ++ # } # if s [ i ] == ' L ' { # l ++ # } else { # l = 0 # } # # if a > 1 || l > 2 { # return false # } # # } # # return true
if start >= 0 && start < len ( arr ) && arr [ start ] < len ( arr ) { # jump := arr [ start ] # arr [ start ] += len ( arr ) # return jump == 0 || canReach ( arr , start + jump ) || canReach ( arr , start - jump ) # } # return false
tests := [...] testType { # { # in : " STR ", # want : 9 , # }, # { # in : " STR ", # want : 4 1 , # }, # { # in : " STR ", # want : 6 0 , # }, # { # in : " STR ", # want : 6 1 , # }, # { # in : " STR ", # want : 2 1 4 , # }, # { # in : " STR ", # want : 3 4 5 , # }, # } # for _ , tt := range tests { # got := dayOfYear ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if num == 0 { # return " STR " # } # # minus := " STR " # if num < 0 { # minus = " STR " # num *= - 1 # } # # s := " STR " # # for num > 0 { # s = fmt . Sprintf (" STR ", num % 7 ) + s # num /= 7 # } # # return minus + s
return m . cache [ m . bucketNo ( key )]. Del ( key )
this . mutex . Lock () # defer this . mutex . Unlock () # # if this . total == 0 { # return nil # } # # next := this . nextQueue () # ret := this . queues [ next ]. RemoveWait () # # this . updateRemoval () # # return ret
cipher , _ := NewCipher ( key ) # decrypted := make ([] byte , len ( data )) # size := 3 2 # for bs , be := 0 , size ; bs < len ( data ); bs , be = bs + size , be + size { # cipher . Decrypt ( decrypted [ bs : be ], data [ bs : be ]) # } # return decrypted
s := [][] int {} # return MyCalendar { # cal : s , # }
var tests = [] struct { # a , b [] int # exchange [] int # }{ # {[] int { 1 , 1 }, [] int { 2 , 2 }, [] int { 1 , 2 }}, # {[] int { 1 , 2 }, [] int { 2 , 3 }, [] int { 1 , 2 }}, # {[] int { 2 }, [] int { 1 , 3 }, [] int { 2 , 3 }}, # {[] int { 1 , 2 , 5 }, [] int { 2 , 4 }, [] int { 5 , 4 }}, # { nil , nil , nil }, # } # # for _ , tt := range tests { # exchange := fairCandySwap ( tt . a , tt . b ) # if reflect . DeepEqual ( exchange , tt . exchange ) == false { # t . Errorf (" STR ", tt . a , tt . b , exchange , tt . exchange ) # } # }
s := newStruct () # fields := s . Field (" STR "). Fields () # # if len ( fields ) != 3 { # t . Errorf (" STR ", len ( fields )) # }
obj := Constructor () # obj . Push ( 2 ) # obj . Push ( 3 ) # obj . Push ( 1 ) # obj . Pop () # param_ 3 := obj . Top () # param_ 4 := obj . Min () # fmt . Println ( param_ 3 , param_ 4 )
res := 0 # if n != 0 { # rightMostBitInt := n & - n # nextHigherSetBitInt := n + rightMostBitInt # d := n ^ nextHigherSetBitInt # d /= rightMostBitInt # d >>= 2 # res = nextHigherSetBitInt | d # } # return res
if head == nil || head . Next == nil || k < 2 { # return head # } # # next , ok := needReverse ( head , k ) # if ok { # head , tail := reverse ( head ) # tail . Next = reverseKGroup ( next , k ) # return head # } # # return head
sum := 0 # # for n > 0 { # # x := n % 1 0 # n /= 1 0 # # sum += x * x * x * x * x # } # # return sum
t . clk = & s . clk # t . startTime = s . clk # if t . r == 0 { # heap . Push ( s . runningTasks , t ) # } else { # heap . Push ( s . preTasks , t ) # }
res = 0 # dfs ( root , 0 , 0 ) # return res
n := len ( nums ) # k = k % n # nums = reverseArr ( nums , 0 , n - 1 ) # nums = reverseArr ( nums , 0 , k - 1 ) # nums = reverseArr ( nums , k , n - 1 ) # return nums
tests := [...] testType { # { # in : [][] int { # { 1 , 2 , 3 }, # { 4 , 5 , 6 }, # { 7 , 8 , 9 }, # }, # want : [][] int { # { 1 , 4 , 7 }, # { 2 , 5 , 8 }, # { 3 , 6 , 9 }, # }, # }, # { # in : [][] int { # { 1 , 2 , 3 }, # { 4 , 5 , 6 }, # }, # want : [][] int { # { 1 , 4 }, # { 2 , 5 }, # { 3 , 6 }, # }, # }, # } # for _ , tt := range tests { # got := transpose ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
return me . u . Host
var maxProfit int # for i := range stockPrices { # for j := i + 1 ; j < len ( stockPrices ); j ++ { # if profit := stockPrices [ j ] - stockPrices [ i ]; profit > maxProfit { # maxProfit = profit # } # } # } # return maxProfit
q := New () # # if ! q . isEmpty () || # q . len != 0 || # q . Len () != 0 { # t . Error () # } # # q . Push ( 1 ) # q . Push ( 2 ) # q . Push ( 3 ) # # if q . queue [ 0 ] != 1 || # q . queue [ 1 ] != 2 || # q . queue [ 2 ] != 3 { # fmt . Println ( q . queue ) # t . Error () # } # # if q . Len () != 3 { # t . Error () # } # # a := q . Shift () # # if a != 1 || q . Len () != 2 { # t . Error () # } # # b := q . Peek () # # if b != 2 { # t . Error () # }
if root != nil { # root . Left , root . Right = mirrorTree ( root . Right ), mirrorTree ( root . Left ) # } # return root
nums := make ([] int , 0 ) # for _ , node := range nestedList { # nums = append ( nums , helper 3 4 1 ( node )...) # } # # return & NestedIterator { # index : 0 , # nums : nums , # }
tests := [...] testType { # { # in : [][] int { # { 1 , 3 }, # {- 2 , 2 }, # }, # k : 1 , # want : [][] int { # {- 2 , 2 }, # }, # }, # { # in : [][] int { # { 3 , 3 }, # { 5 , - 1 }, # {- 2 , 4 }, # }, # k : 2 , # want : [][] int { # { 3 , 3 }, # {- 2 , 4 }, # }, # }, # } # for _ , tt := range tests { # got := kClosest ( tt . in , tt . k ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
var res [] int # var max * TreeNode # # for root != nil { # if root . Left == nil { # res = append ( res , root . Val ) # root = root . Right # } else { # max = root . Left # for max . Right != nil { # max = max . Right # } # # max . Right = root # # root , root . Left = root . Left , nil # } # } # return res
qs := [] question 4 0 1 { # # { # para 4 0 1 { 1 }, # ans 4 0 1 {[] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 0 1 , q . para 4 0 1 # fmt . Printf (" STR ", p , readBinaryWatch ( p . n )) # } # fmt . Printf (" STR ")
fmt . Println ( repeatedStringMatch (" STR ", " STR ")) # fmt . Println ( repeatedStringMatch (" STR ", " STR ")) # fmt . Println ( repeatedStringMatch (" STR ", " STR "))
print ( factor ( 6 0 0 8 5 1 4 7 5 1 4 3 ))
op := c . lDOperation . init (" STR ", cost ) # op . lDCompute = c # return c
return & Heap { # data : make ([] Item , 0 ), # min : false , # }
i , j := 0 , 0 # for j < len ( nums ) { # if nums [ j ] != val { # nums [ i ] = nums [ j ] # i ++ # } # # j ++ # } # # return i
ans , n := 0 , len ( A ) # sum := make ( map [ int ] int , n * n ) # for i := 0 ; i < n ; i ++ { # for j := 0 ; j < n ; j ++ { # sum [ A [ i ]+ B [ j ]]++ # } # } # for k := 0 ; k < n ; k ++ { # for l := 0 ; l < n ; l ++ { # ans += sum [- C [ k ]- D [ l ]] # } # } # return ans
obj := Constructor 9 0 1 () # fmt . Printf (" STR ", obj ) # param 1 := obj . Next ( 1 0 0 ) # fmt . Printf (" STR ", param 1 ) # param 2 := obj . Next ( 8 0 ) # fmt . Printf (" STR ", param 2 ) # param 3 := obj . Next ( 6 0 ) # fmt . Printf (" STR ", param 3 ) # param 4 := obj . Next ( 7 0 ) # fmt . Printf (" STR ", param 4 ) # param 5 := obj . Next ( 6 0 ) # fmt . Printf (" STR ", param 5 ) # param 6 := obj . Next ( 7 5 ) # fmt . Printf (" STR ", param 6 ) # param 7 := obj . Next ( 8 5 ) # fmt . Printf (" STR ", param 7 )
low , high := 0 , min ( len ( A ), len ( B )) # for low < high { # mid := ( low + high + 1 ) >> 1 # if hasRepeated ( A , B , mid ) { # low = mid # } else { # high = mid - 1 # } # } # return low
var digits [] int # for i != 0 { # digits = append ( digits , i % 1 0 ) # i /= 1 0 # } # for i := 0 ; i < len ( digits )/ 2 ; i ++ { # if digits [ i ] != digits [ len ( digits )- 1 - i ] { # return false # } # } # return true
dummy , f := deferFunc () # dummy ++ # defer f ( 1 )
Ax , Ay := A [ 0 ], A [ 1 ] # Bx , By := B [ 0 ], B [ 1 ] # return max ( abs ( Ax - Bx ), abs ( Ay - By ))
n := len ( nums ) # m := make ( map [ int ] int , n ) # tmp := make ([] int , n ) # copy ( tmp , nums ) # sort . Ints ( tmp ) # for i , num := range tmp { # m [ num ] = n - i # } # # res := make ([] string , n ) # for i , num := range nums { # switch m [ num ] { # case 1 : # res [ i ] = " STR " # case 2 : # res [ i ] = " STR " # case 3 : # res [ i ] = " STR " # default : # res [ i ] = strconv . Itoa ( m [ num ]) # } # } # return res
ans , m := 0 , [ 6 0 ] int {} # for _ , t := range time { # ans += m [( 6 0 - t % 6 0 )% 6 0 ] # m [ t % 6 0 ]++ # } # return ans
return Multiply ( args , result )
if head == nil || head . Next == nil { # return head # } # # lessHead := & ListNode {} # noLessHead := & ListNode {} # # lessEnd := lessHead # noLessEnd := noLessHead # # for head != nil { # if head . Val < x { # lessEnd . Next = head # lessEnd = lessEnd . Next # } else { # noLessEnd . Next = head # noLessEnd = noLessEnd . Next # } # head = head . Next # } # # lessEnd . Next = noLessHead . Next # noLessEnd . Next = nil # # head = lessHead . Next # return head
done := make ( chan error , 1 ) # t := time . After ( timeout ) # # err := cmd . Start () # if err != nil { # return err # } # go func () { # done <- cmd . Wait () # }() # select { # case err := <- done : # return err # case <- t : # cmd . Process . Kill () # return ErrCommandTimeout # }
cases := [] struct { # name string # inputs * ListNode # expect * ListNode # }{ # {" STR ", MakeListNode ([] int { 1 , 2 , 3 , 4 , 5 }), MakeListNode ([] int { 1 , 3 , 5 , 2 , 4 })}, # {" STR ", MakeListNode ([] int { 2 , 1 , 3 , 5 , 6 , 4 , 7 }), MakeListNode ([] int { 2 , 3 , 6 , 7 , 1 , 5 , 4 })}, # {" STR ", MakeListNode ([] int {}), MakeListNode ([] int {})}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
type address struct { # Country string ` structs :" STR "` # } # # type B struct { # Foo map [ string ][] address # } # # type A struct { # B * B # } # # b := & B { # Foo : map [ string ][] address { # " STR ": { # { Country : " STR "}, # }, # }, # } # # a := & A { B : b } # m := Map ( a ) # # if typ := reflect . TypeOf ( m ). Kind (); typ != reflect . Map { # t . Errorf (" STR ", typ ) # } # # in , ok := m [" STR "].( map [ string ] interface {}) # if ! ok { # t . Errorf (" STR ", m [" STR "]) # } # # foo := in [" STR "].( map [ string ] interface {}) # # addresses := foo [" STR "].([] interface {}) # # addr , ok := addresses [ 0 ].( map [ string ] interface {}) # if ! ok { # t . Errorf (" STR ", m [" STR "]) # } # # if _ , exists := addr [" STR "]; ! exists { # t . Errorf (" STR ") # }
if head == nil || head . Next == nil { # return head # } # # slow := head # fast := head . Next # for fast != nil && fast . Next != nil { # slow = slow . Next # fast = fast . Next . Next # } # # nextHalfHead := slow . Next # slow . Next = nil # l 1 := sortList ( head ) # l 2 := sortList ( nextHalfHead ) # # dummy := & ListNode {} # cur := dummy # for l 1 != nil || l 2 != nil { # if l 1 == nil || ( l 2 != nil && l 1 . Val >= l 2 . Val ) { # cur . Next = l 2 # l 2 = l 2 . Next # } else { # cur . Next = l 1 # l 1 = l 1 . Next # } # # cur = cur . Next # } # # return dummy . Next
n := len ( s ) # freqs := make ([] freq , 1 2 8 ) # for i := 0 ; i < n ; i ++ { # b := s [ i ] # f := freqs [ b ] # f . b = b # f . f ++ # freqs [ b ] = f # } # sort . Slice ( freqs , func ( i , j int ) bool { # return freqs [ i ]. f > freqs [ j ]. f # }) # res := make ([] byte , n ) # i := 0 # for _ , f := range freqs { # if f . f == 0 { # break # } # for j := 0 ; j < f . f ; j ++ { # res [ i ] = f . b # i ++ # } # } # return string ( res )
xs := getXs ( rectangles ) # # idxs := make ( map [ int ] int , 2 * len ( xs )) # for idx , x := range xs { # idxs [ x ] = idx # } # # labels := getLabels ( rectangles ) # # count := make ([] int , len ( xs )) # # curY , curXSum , area := 0 , 0 , 0 # # for _ , l := range labels { # y , x 1 , x 2 , sig := l [ 0 ], l [ 1 ], l [ 2 ], l [ 3 ] # area += ( y - curY ) * curXSum # curY = y # curXSum = 0 # for i := idxs [ x 1 ]; i < idxs [ x 2 ]; i ++ { # count [ i ] += sig # } # for i := 0 ; i + 1 < len ( count ); i ++ { # if count [ i ] > 0 { # curXSum += xs [ i + 1 ] - xs [ i ] # } # } # } # # return area % mod
t . Parallel () # for _ , tc := range testcases { # if result := FlattenMap ( tc . nested ); ! reflect . DeepEqual ( result , tc . flattened ) { # t . Errorf (" STR ", tc . flattened , result ) # } # }
words := strings . Split ( s , " STR ") # # var temp [] string # for _ , word := range words { # temp = append ( temp , reverseString ( word )) # } # return strings . Join ( temp , " STR ")
n := len ( quiet ) # rs := make ([][] int , n ) # for _ , r := range richer { # rs [ r [ 1 ]] = append ( rs [ r [ 1 ]], r [ 0 ]) # } # # res := make ([] int , n ) # for i := 0 ; i < n ; i ++ { # res [ i ] = - 1 # } # # var dfs func ( int ) int # dfs = func ( i int ) int { # if res [ i ] >= 0 { # return res [ i ] # } # res [ i ] = i # for _ , j := range rs [ i ] { # if quiet [ res [ i ]] > quiet [ dfs ( j )] { # res [ i ] = res [ j ] # } # } # return res [ i ] # } # for i := 0 ; i < n ; i ++ { # dfs ( i ) # } # return res
qs := [] question 2 2 9 { # # { # para 2 2 9 {[] int { 3 , 2 , 3 }}, # ans 2 2 9 {[] int { 3 }}, # }, # # { # para 2 2 9 {[] int { 1 , 1 , 1 , 3 , 3 , 2 , 2 , 2 }}, # ans 2 2 9 {[] int { 1 , 2 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 2 9 , q . para 2 2 9 # fmt . Printf (" STR ", p , majorityElement 2 2 9 ( p . s )) # } # fmt . Printf (" STR ")
m , n := len ( nums ), len ( nums [ 0 ]) # if m * n != r * c { # return nums # } # ans := make ([][] int , r ) # for i := 0 ; i < r ; i ++ { # ans [ i ] = make ([] int , c ) # } # i , j := 0 , 0 # for _ , row := range nums { # for _ , v := range row { # ans [ i ][ j ] = v # if j ++; j == c { # i ++ # j = 0 # } # } # } # return ans
return New ( s ). IsZero ()
arr := [] int { 4 , 3 , 2 , 1 } # ms ( arr ) # fmt . Println ( arr )
if ! hasCycle { # return UnmarshalListByRand ( 1 0 0 , len ) # } # # index := rand . Intn ( len ) # head := UnmarshalListByRand ( 1 0 0 , len ) # tmp := head # # for i := 0 ; i < index ; i ++ { # tmp = tmp . Next # } # # tmp . Next = head # return head
if val > this . heap [ this . k - 1 ] { # this . heap [ this . k - 1 ] = val # } # this . heap = InsertSort ( this . heap ) # return this . heap [ this . k - 1 ]
qs := [] question 1 1 3 7 { # # { # para 1 1 3 7 { 1 }, # ans 1 1 3 7 { 1 }, # }, # # { # para 1 1 3 7 { 2 }, # ans 1 1 3 7 { 1 }, # }, # # { # para 1 1 3 7 { 3 }, # ans 1 1 3 7 { 2 }, # }, # # { # para 1 1 3 7 { 4 }, # ans 1 1 3 7 { 4 }, # }, # # { # para 1 1 3 7 { 2 5 }, # ans 1 1 3 7 { 1 3 8 9 5 3 7 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 1 3 7 , q . para 1 1 3 7 # fmt . Printf (" STR ", p , tribonacci ( p . one )) # } # fmt . Printf (" STR ")
t . Run (" STR ", func ( t * testing . T ) { # got := lengthOfLastWord 1 (" STR ") # want := 5 # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # }) # # t . Run (" STR ", func ( t * testing . T ) { # got := lengthOfLastWord 1 (" STR ") # want := 5 # if got != want { # t . Error (" STR ", got , " STR ", want ) # } # }) #
np := 1 0 0 0 1 # total , err := upperBound ( float 6 4 ( np )) # # if err != nil { # fmt . Print ( err ) # return # } # # nums := make ([] bool , total ) # # next := 2 # # MainLoop : # for next < total { # # loop ( total , next , nums ) # # for x := next + 1 ; x < total ; x ++ { # if nums [ x ] != true { # next = x # break # } # # if next > total / 2 { # break MainLoop # } # } # } # # count := 0 # # for x := 1 ; x < total ; x ++ { # if nums [ x ] == false { # if count == np { # fmt . Print ( count , " STR ", x , " STR ") # return # } # count ++ # } # }
var ll [][] int # # if root != nil { # ll = append ( ll , [] int { root . Val }) # recLevelOrder ( root . Left , 1 , & ll ) # recLevelOrder ( root . Right , 1 , & ll ) # } # # return ll
c , err := p . get () # if err != nil { # return errorConnection { err } # } # return & pooledConnection { p : p , c : c }
if n == nil { # return # } # PostOrder ( n . left ) # PostOrder ( n . right ) # fmt . Print ( n . val , " STR ")
files := [] string {} # filepath . Walk (" STR ", func ( path string , fi os . FileInfo , err error ) error { # if fi . IsDir () { # return nil # } # path = strings . Replace ( path , " STR ", " STR ", - 1 ) # if strings . HasSuffix ( path , " STR ") { # files = append ( files , path ) # } # return nil # }) # return files
var result [][] int # helper ( nums , & result , [] int {}) # return result
if len ( chars ) != 2 { # return " STR " # } # row := strings . IndexRune ( p . characters , chars [ 0 ]) # if row < 0 { # return " STR "% c does not exist in characters ", chars [ 0 ] # } # col := strings . IndexRune ( p . characters , chars [ 1 ]) # if col < 0 { # return " STR "% c does not exist in characters ", chars [ 1 ] # } # return string ([] rune ( p . key )[ row * p . size + col ]), nil
r , c := len ( M ), len ( M [ 0 ]) # ans := make ([][] int , r ) # for i := 0 ; i < r ; i ++ { # ans [ i ] = make ([] int , c ) # for j := 0 ; j < c ; j ++ { # sum , count := 0 , 0 # for m := i - 1 ; m <= i + 1 ; m ++ { # for n := j - 1 ; n <= j + 1 ; n ++ { # if m >= 0 && n >= 0 && m < r && n < c { # sum += M [ m ][ n ] # count ++ # } # } # } # ans [ i ][ j ] = sum / count # } # } # return ans
sort . Ints ( heaters ) # ret := - 1 # for _ , house := range houses { # idx := sort . SearchInts ( heaters , house ) # l , r := math . MaxInt 3 2 , math . MaxInt 3 2 # if idx - 1 >= 0 { # l = house - heaters [ idx - 1 ] # } # if idx < len ( heaters ) { # r = heaters [ idx ] - house # } # ret = mymax ( ret , mymin ( l , r )) # } # return ret
return MyHashMap { # m : make ([] int , 1 0 0 0 0 , 1 0 0 0 0 0 1 ), # len : 1 0 0 0 0 , # cap : 1 0 0 0 0 0 1 , # }
isLeftStart := true # remain := n # # min := 1 # step := 1 # for remain > 1 { # if isLeftStart || remain % 2 == 1 { # min += step # } # # isLeftStart = ! isLeftStart # step *= 2 # remain /= 2 # } # # return min
return pc . c . Err ()
var tests = [] struct { # nums 1 , nums 2 [] int # median float 6 4 # }{ # {[] int { 1 , 3 }, [] int { 2 }, 2 }, # {[] int { 1 , 2 }, [] int { 3 , 4 }, 2 . 5 }, # {[] int { 1 , 3 }, [] int { 2 , 4 }, 2 . 5 }, # {[] int { 1 , 4 }, [] int { 2 , 3 }, 2 . 5 }, # {[] int { 2 , 3 }, [] int { 1 , 4 }, 2 . 5 }, # {[] int { 2 , 4 }, [] int { 1 , 3 }, 2 . 5 }, # {[] int { 3 , 4 }, [] int { 1 , 2 }, 2 . 5 }, # } # # for _ , tt := range tests { # median := findMedianSortedArrays ( tt . nums 1 , tt . nums 2 ) # if median != tt . median { # t . Errorf (" STR ", tt . nums 1 , tt . nums 2 , median , tt . median ) # } # }
t . Parallel () # for _ , tc := range testcases { # if result := MostFrequentSubtreeSum ( tc . head ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
sort . Ints ( nums ) # return helper 9 0 ( nums , 0 , make ([] int , 0 ), make ([][] int , 0 ))
return & Map { # data : make ( map [ interface {}] interface {}, 3 2 ), # }
r := matrix [ row ] # for i := 0 ; i < len ( r ); i ++ { # if r [ i ] == 0 { # return true # } # } # return false
ans := [][] int {} # helper (& ans , 0 , nums ) # return ans
sum := 0 # # for _ , heap := range heaps { # sum ^= heap # } # # return sum != 0
res := [] int {} # # sLen , wordsNum := len ( s ), len ( words ) # if sLen == 0 || wordsNum == 0 { # return res # } # wordLen := len ( words [ 0 ]) # remainNum := make ( map [ string ] int , wordsNum ) # count := 0 # # for initialIndex := 0 ; initialIndex < wordLen ; initialIndex ++ { # index := initialIndex # count = initRecord ( words , remainNum ) # # for index + wordsNum * wordLen <= sLen { # word := s [ index + count * wordLen : index +( count + 1 )* wordLen ] # remainTimes , ok := remainNum [ word ] # switch { # case ! ok : # index += wordLen * ( count + 1 ) # if count != 0 { # count = initRecord ( words , remainNum ) # } # case remainTimes == 0 : # index , count = moveIndex ( index , wordLen , count , s , remainNum ) # default : # remainNum [ word ]-- # count ++ # if count == wordsNum { # res = append ( res , index ) # # index , count = moveIndex ( index , wordLen , count , s , remainNum ) # } # } # } # } # return res
for i := 0 ; i < len ( x )/ 2 ; i += 1 { # if string ( x [ i ]) != string ( x [ len ( x )- i - 1 ]) { # return false # } # } # return true
this . removeNode ( node ) # this . addToHead ( node )
list := NewCyclic () # fillList ( list , 3 ) # # want := [] interface {}{ 1 , 2 , 3 } # var got [] interface {} # var start * Node # start = list . Head # # for i := 0 ; i < list . Size ; i ++ { # got = append ( got , start . Val ) # start = start . Next # } # if ! reflect . DeepEqual ( got , want ) { # t . Errorf (" STR ", got , want ) # }
println ( countPrimes ( 1 0 )) # println ( countPrimes ( 2 0 )) # println ( countPrimes ( 1 0 0 ))
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 0 , 1 , 3 , 5 , 6 }, 3 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := hIndex ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
return key .( uint 3 2 ) & (( 1 << uint 3 2 ( lgu >> 1 )) - 1 )
str = strings . TrimSpace ( str ) # if len ( str ) == 0 { # return 0 # } # # neg := false # if str [ 0 ] == '-' { # neg = true # str = str [ 1 :] # } else if str [ 0 ] == '+' { # str = str [ 1 :] # } # # res := 0 # for _ , c := range str { # if c < ' 0 ' || c > ' 9 ' { # break # } # val := int ( c - ' 0 ') # if neg { # if (- 1 * res ) < ( math . MinInt 3 2 + val )/ 1 0 { # return math . MinInt 3 2 # } # } else if res > ( math . MaxInt 3 2 - val )/ 1 0 { # return math . MaxInt 3 2 # } # res = 1 0 * res + val # # } # if neg { # return - 1 * res # } # return res
var num int # for i := 0 ; i < len ( s ); i ++ { # num = num * 2 6 + int ( s [ i ]-' A '+ 1 ) # } # return num
i , fourConsecutive := 6 4 4 , 0 # havePrimeFactors := [ 4 ] bool { false , false , false , false } # for fourConsecutive == 0 { # for j := 0 ; j < len ( havePrimeFactors )- 1 ; j ++ { # havePrimeFactors [ j ] = havePrimeFactors [ j + 1 ] # } # # if numberOfPrimeFactors ( i ) == 4 { # havePrimeFactors [ 3 ] = true # if havePrimeFactors [ 0 ] && havePrimeFactors [ 1 ] && havePrimeFactors [ 2 ] && havePrimeFactors [ 3 ] { # fourConsecutive = i - 3 # } else { # i ++ # } # } else { # havePrimeFactors [ 3 ] = false # i += 4 # } # } # # fmt . Println ( fourConsecutive )
var tests = [] struct { # bits [] int # isOneBit bool # }{ # {[] int { 1 , 0 , 0 }, true }, # {[] int { 1 , 1 , 1 , 0 }, false }, # } # # for _ , tt := range tests { # isOneBit := isOneBitCharacter ( tt . bits ) # if isOneBit != tt . isOneBit { # t . Errorf (" STR ", tt . bits , isOneBit , tt . isOneBit ) # } # }
var res [] int # var stack []* TreeNode # # for 0 < len ( stack ) || root != nil { # for root != nil { # stack = append ( stack , root ) # root = root . Left # } # # top := len ( stack ) - 1 # res = append ( res , stack [ top ]. Val ) # root = stack [ top ]. Right # stack = stack [: top ] # } # return res
minCost , maxBenefit := math . MaxInt 3 2 , 0 # for _ , price := range prices { # minCost = min ( minCost , price ) # maxBenefit = max ( maxBenefit , price - minCost ) # } # return maxBenefit
var tests = [] struct { # nums [] int # s string # }{ # {[] int { 0 , 0 }, " STR "}, # {[] int { 1 0 , 2 }, " STR "}, # {[] int { 3 , 3 0 , 3 4 , 5 , 9 }, " STR "}, # } # # for _ , tt := range tests { # s := largestNumber ( tt . nums ) # if s != tt . s { # t . Errorf (" STR ", tt . nums , s , tt . s ) # } # }
qr := q . Root ( r ) # qp := q . Root ( p ) # if qr == qp { # return # } # # if q . Weights [ qr ] > q . Weights [ qp ] { # q . IDs [ qp ] = qr # q . Weights [ qr ] += q . Weights [ qp ] # } else { # q . IDs [ qr ] = qp # q . Weights [ qp ] += q . Weights [ qr ] # } #
f := float 3 2 (^ uint 3 2 ( 0 )) # return uint 3 2 ( f )
sort . Slice ( courses , func ( i , j int ) bool { # if courses [ i ][ 1 ] == courses [ j ][ 1 ] { # return courses [ i ][ 0 ] < courses [ j ][ 0 ] # } # return courses [ i ][ 1 ] < courses [ j ][ 1 ] # }) # # res := 0 # sum := 0 # h := & highHeap {} # for _ , course := range courses { # if course [ 0 ]+ sum <= course [ 1 ] || ( h . Len () > 0 && course [ 0 ] <= h . Peek ()) { # heap . Push ( h , course [ 0 ]) # sum += course [ 0 ] # if sum > course [ 1 ] { # sum -= heap . Pop ( h ).( int ) # } # res = max ( res , h . Len ()) # } # } # return res
a 2 i := make ( map [ int ][] int , 6 4 ) # for i , a := range arr { # a 2 i [ a ] = append ( a 2 i [ a ], i ) # } # return MajorityChecker { # arr : arr , # a 2 i : a 2 i , # }
cases := [] Case {} # N := 1 0 # for i := 0 ; i < N ; i ++ { # name := " STR " # input := UnmarshalListByRand ( 1 0 0 , 1 0 0 0 0 ) # exect := Solution ( input ) # cases = append ( cases , Case { Name : name , Input : input , Expect : exect }) # } # for _ , c := range cases { # t . Run ( c . Name , func ( t * testing . T ) { # got := Solution ( c . Input ) # if isEqual ( got , c . Expect ) { # t . Fatalf (" STR ", # c . Expect , got , c . Input ) # } # }) # }
curr := head # count := 0 # for curr != nil && count != k { # curr = curr . Next # count ++ # } # # if count == k { # curr = reverseKGroup ( curr , k ) # for count > 0 { # tmp := head . Next # head . Next = curr # curr = head # head = tmp # count -- # } # head = curr # } # return head
 # const Required = 1 0 # const Digits = 1 5 # var Total int 6 4 # NumberStrings := strings . Split ( NumberBlock , " STR ") # for _ , n := range NumberStrings { # Value , Err := strconv . ParseInt ( n [: Digits ], 1 0 , 6 4 ) # if Err != nil { # fmt . Println ( Err ) # } # Total += Value # } # ValStr := fmt . Sprintf (" STR ", Total )[: Required ] # fmt . Println ( ValStr )
var sum int # for i := 1 ; i < 1 0 0 0 ; i ++ { # if ( i % 3 == 0 ) || ( i % 5 == 0 ) { # sum += i # } # } # # return sum
n := 9 9 9 9 9 9 # max := 9 # len := max + 1 # nums := make ([] int , len ) # for i := 0 ; i < len ; i ++ { # nums [ i ] = i # } # # var fact , dig , dig_ int # number := make ([] int , len ) # for i := max ; i >= 0 ; i -- { # fact = factorial ( i ) # fmt . Println (" STR ", fact ) # dig_ = int ( n / fact ) # dig = nums [ dig_ ] # number [ max - i ] = dig # fmt . Println (" STR ", dig ) # nums = append ( nums [: dig_ ], nums [ dig_ + 1 :]...) # n -= fact * dig_ # fmt . Println (" STR ", n ) # } # fmt . Print (" STR ") # for _ , d := range number { # fmt . Print ( d ) # }
if nil == nums 1 || len ( nums 1 ) == 0 { # return nums 1 # } # if nil == nums 2 || len ( nums 2 ) == 0 { # return nums 2 # } # # dict 1 := make ( map [ int ] int , 0 ) # for _ , v := range nums 1 { # dict 1 [ v ]++ # } # # dict 2 := make ( map [ int ] int , 0 ) # for _ , v := range nums 2 { # dict 2 [ v ]++ # } # # ans := make ([] int , 0 ) # for k 1 , v 1 := range dict 1 { # if v 2 , ok := dict 2 [ k 1 ]; ok { # for repeat := minInt ( v 1 , v 2 ); repeat > 0 ; repeat -- { # ans = append ( ans , k 1 ) # } # } # } # return ans
if nil == root { # return 0 # } # return pathSumFrom ( root , sum ) + pathSum ( root . Left , sum ) + pathSum ( root . Right , sum )
for i := range data { # if err := x . Pull (& data [ i ]); err != nil { # return i , err # } # } # # return len ( data ), nil
profit := 0 # for i := 0 ; i < len ( prices )- 1 ; i ++ { # if prices [ i + 1 ] > prices [ i ] { # profit += prices [ i + 1 ] - prices [ i ] # } # } # return profit
t . Parallel () # for _ , tc := range testcases { # if result := MathematicalIf ( tc . x , tc . y , tc . b ); tc . expected != result { # t . Errorf (" STR ", tc . x , tc . y , tc . b , tc . expected , result ) # } # }
n := len ( S ) # # dp := [ 2 0 1 ][ 2 0 1 ] int {} # # for j := 0 ; j <= n ; j ++ { # dp [ 0 ][ j ] = 1 # } # # for i := 0 ; i < n ; i ++ { # count := 0 # if S [ i ] == ' I ' { # for j := 0 ; j < n - i ; j ++ { # count += dp [ i ][ j ] # dp [ i + 1 ][ j ] = count % mod # # } # } else { # for j := n - i - 1 ; j >= 0 ; j -- { # count += dp [ i ][ j + 1 ] # dp [ i + 1 ][ j ] = count % mod # } # } # } # # return dp [ n ][ 0 ]
l := distance ( r . x 1 , r . y 1 , r . x 1 , r . y 2 ) # w := distance ( r . x 1 , r . y 1 , r . x 2 , r . y 1 ) # return l * 2 + w * 2
qs := [] question 4 9 4 { # # { # para 4 9 4 {[] int { 1 , 1 , 1 , 1 , 1 }, 3 }, # ans 4 9 4 { 5 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 9 4 , q . para 4 9 4 # fmt . Printf (" STR ", p , findTargetSumWays ( p . nums , p . S )) # } # fmt . Printf (" STR ")
base := minutesToTest / minutesToDie + 1 # power := 1 # res := 0 # # for power < buckets { # power *= base # res ++ # } # # return res
minVal = item [ 0 ] # for i := 1 ; i < len ( item ); i ++ { # if item [ i ] < minVal { # minVal = item [ i ] # } # } # return minVal
h . hashMapBase . Init ( cap ) # h . backets = make ([]* openHashElement , h . Cap , h . Cap )
s := make ([] rune , 0 ) # for _ , c := range S { # if c == '#' { # if len ( s ) > 0 { # s = s [: len ( s )- 1 ] # } # } else { # s = append ( s , c ) # } # } # s 2 := make ([] rune , 0 ) # for _ , c := range T { # if c == '#' { # if len ( s 2 ) > 0 { # s 2 = s 2 [: len ( s 2 )- 1 ] # } # } else { # s 2 = append ( s 2 , c ) # } # } # return string ( s ) == string ( s 2 )
var off int 6 4 # # switch whence { # case io . SeekCurrent : # off = offset + int 6 4 ( w . pos ) # case io . SeekStart : # off = offset # case io . SeekEnd : # off = int 6 4 ( len ( w . buf )) - offset # default : # return 0 , fmt . Errorf (" STR ") # } # # if off < 0 { # return 0 , fmt . Errorf (" STR ") # } # # w . pos = int ( off ) # # return off , nil
if len ( line ) == 3 { # return 2 # } # # if ans , ok := memo [ keyFun ( line )]; ok { # return ans # } # # ans := int 6 4 ( 0 ) # cans := candidates ( line ) # # for _ , can := range cans { # ans += above ( can ) # } # # memo [ keyFun ( line )] = ans # return ans
if l . Len () == 0 { # return 0 , errors . New (" STR ") # } # # index := 0 # found := - 1 # l . Map ( func ( n * Node ) { # index ++ # if n . Value == node . Value && found == - 1 { # found = index # } # }) # # if found == - 1 { # return 0 , errors . New (" STR ") # } # # return found , nil
if root == nil { # return true # } # res = true # cur = root . Val # dfs ( root ) # return res
b . lock . Lock () # defer b . lock . Unlock () # # return b . lruList . Len ()
t . Parallel () # # ss := NewStockService () # # for _ , tc := range testcases { # switch tc . action { # case " STR ": # ss . AddOrUpdate ( tc . data ) # case " STR ": # ss . Remove ( tc . data . Timestamp ) # } # # if min := ss . Min (); min != tc . min { # t . Errorf (" STR ", tc . min , min ) # } # # if max := ss . Max (); max != tc . max { # t . Errorf (" STR ", tc . max , max ) # } # # if avg := ss . Avg (); avg != tc . avg { # t . Errorf (" STR ", tc . avg , avg ) # } # }
if len ( s ) == 1 { # return numberMap [ s [ 0 ]] # } # returnArr := [] string {} # for _ , e := range numberMap [ s [ 0 ]] { # for _ , e 1 := range depthSolution ( s [ 1 :]) { # returnArr = append ( returnArr , e + e 1 ) # } # } # return returnArr
b := [] byte ( s ) # for i , j := 0 , len ( b )- 1 ; i < j ; i , j = i + 1 , j - 1 { # b [ i ], b [ j ] = b [ j ], b [ i ] # } # return string ( b )
length , newLength := len ( nums ), 1 # for i := 1 ; i < length ; i ++ { # if nums [ i - 1 ] != nums [ i ] { # nums [ newLength ] = nums [ i ] # newLength ++ # } # } # return newLength
if len ( nums ) < 2 { # return len ( nums ) # } # left , right := 0 , 1 # for ; right < len ( nums ); right ++ { # if nums [ left ] == nums [ right ] { # continue # } # left ++ # nums [ left ] = nums [ right ] # } # nums = nums [: left + 1 ] # return len ( nums )
max := 1 0 0 0 # # sum , power := big . NewInt ( 0 ), big . NewInt ( 0 ) # bigI := big . NewInt ( 1 ) # for i := 1 ; i <= max ; i ++ { # bigI = big . NewInt ( int 6 4 ( i )) # power . Exp ( bigI , bigI , nil ) # sum . Add ( sum , power ) # } # # sum . Mod ( sum , big . NewInt ( 1 0 0 0 0 0 0 0 0 0 0 )) # fmt . Println ( sum )
num := 3 8 # expected := 2 # # testFuncs := [] func ( int ) int { # addDigits , # addDigits 1 , # } # # for _ , function := range testFuncs { # if res := function ( num ); res != expected { # t . Errorf (" STR ", expected , res ) # } # }
var numCases int # fmt . Scanf (" STR ", & numCases ) # # for i := 1 ; i <= numCases ; i ++{ # var N int # fmt . Scanf (" STR ",& N ) # EvenSumFibo ( N ) # }
qs := [] question 8 8 1 { # # { # para 8 8 1 {[] int { 1 , 2 }, 3 }, # ans 8 8 1 { 1 }, # }, # # { # para 8 8 1 {[] int { 3 , 2 , 2 , 1 }, 3 }, # ans 8 8 1 { 3 }, # }, # # { # para 8 8 1 {[] int { 3 , 5 , 3 , 4 }, 5 }, # ans 8 8 1 { 4 }, # }, # # { # para 8 8 1 {[] int { 5 , 1 , 4 , 2 }, 6 }, # ans 8 8 1 { 2 }, # }, # # { # para 8 8 1 {[] int { 3 , 2 , 2 , 1 }, 3 }, # ans 8 8 1 { 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 8 1 , q . para 8 8 1 # fmt . Printf (" STR ", p , numRescueBoats ( p . s , p . k )) # } # fmt . Printf (" STR ")
blocker . Sleep ()
fmt . Println ( getTranslation ( 1 2 2 5 8 ))
qs := [] question 4 1 4 { # # { # para 4 1 4 {[] int { 1 , 1 , 2 }}, # ans 4 1 4 { 2 }, # }, # # { # para 4 1 4 {[] int { 3 , 2 , 1 }}, # ans 4 1 4 { 1 }, # }, # # { # para 4 1 4 {[] int { 1 , 2 }}, # ans 4 1 4 { 2 }, # }, # # { # para 4 1 4 {[] int { 2 , 2 , 3 , 1 }}, # ans 4 1 4 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 1 4 , q . para 4 1 4 # fmt . Printf (" STR ", p , thirdMax ( p . one )) # } # fmt . Printf (" STR ")
runtime . GOMAXPROCS ( 1 ) # # var wg sync . WaitGroup # wg . Add ( 2 ) # # fmt . Println (" STR ") # # go func () { # defer wg . Done () # # for count := 0 ; count < 3 ; count ++ { # for char := " STR "; char < " STR "+ 2 6 ; char ++ { # fmt . Printf (" STR ", char ) # } # } # }() # # go func () { # defer wg . Done () # # for count := 0 ; count < 3 ; count ++ { # for char := " STR "; char < " STR "+ 2 6 ; char ++ { # fmt . Printf (" STR ", char ) # } # } # }() # # fmt . Println (" STR ") # wg . Wait () # # fmt . Println (" STR ")
n , ch := len ( t ), t [ len ( t )- 1 ] # for i := 0 ; i < n - 1 ; i ++ { # ch ^= s [ i ] # ch ^= t [ i ] # } # return ch
start := time . Now () # resp , err := http . Get ( url ) # if err != nil { # ch <- fmt . Sprint ( err ) # return # } # # nbytes , err := io . Copy ( ioutil . Discard , resp . Body ) # resp . Body . Close () # if err != nil { # ch <- fmt . Sprintf (" STR ", url , err ) # return # } # secs := time . Since ( start ). Seconds () # ch <- fmt . Sprintf (" STR ", secs , nbytes , url )
customer 0 , customer 1 , maxCustomer 1 , left , right := 0 , 0 , 0 , 0 , 0 # for ; right < len ( customers ); right ++ { # if grumpy [ right ] == 0 { # customer 0 += customers [ right ] # } else { # customer 1 += customers [ right ] # for right - left + 1 > X { # if grumpy [ left ] == 1 { # customer 1 -= customers [ left ] # } # left ++ # } # if customer 1 > maxCustomer 1 { # maxCustomer 1 = customer 1 # } # } # } # return maxCustomer 1 + customer 0
var i int # for i < len ( lst ) && lst [ i ] < pivot { # i ++ # } # # for i < len ( lst ) && lst [ i ] == pivot { # i ++ # } # # for i < len ( lst ) && lst [ i ] > pivot { # i ++ # } # # return i == len ( lst )
http . HandleFunc (" STR ", handler ) # http . HandleFunc (" STR ", counter ) # log . Fatal ( http . ListenAndServe (" STR ", nil ))
abs := func ( a int ) int { # if a < 0 { # return - a # } # return a # } # for i , v := range A { # if abs ( v - i ) > 1 { # return false # } # } # return true
hasLen := make ( map [ int ] bool , len ( words )) # hasWord := make ( map [ string ] bool , len ( words )) # for _ , word := range words { # hasLen [ len ( word )] = true # hasWord [ word ] = true # } # # res := make ([] string , 0 , len ( words )) # for _ , word := range words { # if isConcatenated ( word , hasLen , hasWord , false ) { # res = append ( res , word ) # } # } # # return res
var items [] int # current := list . head # for current != nil { # items = append ( items , current . data ) # current = current . next # } # return items
max := int 6 4 (- 1 << 6 3 ) # for i := 0 ; i < len ( nums )- 1 ; i ++ { # for j := i + 1 ; j < len ( nums ); j ++ { # if result := nums [ i ] ^ nums [ j ]; result > max { # max = result # } # } # } # return max
left , right := head , head # for i := 0 ; i < k ; i ++ { # right = right . Next # } # for right != nil { # right = right . Next # left = left . Next # } # return left
m = root . Val # return dfs ( root )
return & Stack { nums : [] int {}}
file , err := os . Open ( dataFile ) # if err != nil { # return nil , err # } # # defer file . Close () # # var feeds []* Feed # err = json . NewDecoder ( file ). Decode (& feeds ) # # return feeds , err
var tests = [] struct { # deck [] int # has bool # }{ # {[] int { 1 }, false }, # {[] int { 1 , 1 }, true }, # {[] int { 1 , 1 , 1 , 2 , 2 , 2 }, true }, # {[] int { 1 , 1 , 2 , 2 , 2 , 2 }, true }, # {[] int { 1 , 2 , 3 , 4 , 4 , 3 , 2 , 1 }, true }, # {[] int { 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 }, false }, # {[] int { 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 }, true }, # } # # for _ , tt := range tests { # has := hasGroupsSizeX ( tt . deck ) # if has != tt . has { # t . Errorf (" STR ", tt . deck , has , tt . has ) # } # }
max := 2 8 1 2 3 # aboundants := [] int {} # for i := 0 ; i <= max ; i ++ { # if isAboundant ( i ) { # aboundants = append ( aboundants , i ) # } # } # # sumAboundants := map [ int ] bool {} # for i := 0 ; i <= max ; i ++ { # sumAboundants [ i ] = false # } # # for i := 0 ; i <= len ( aboundants )/ 2 ; i ++ { # for j := i ; j <= len ( aboundants ); j ++ { # if aboundants [ i ]+ aboundants [ j ] <= max { # sumAboundants [ aboundants [ i ]+ aboundants [ j ]] = true # } else { # j = len ( aboundants ) # } # } # } # # sum := 0 # for key , value := range sumAboundants { # if value == false { # sum += key # } # } # # fmt . Println ( sum )
return y , x
t . Parallel () # for _ , tc := range testcases { # if result := EggDropDP ( tc . eggs , tc . floors ); result != tc . minimum { # t . Errorf (" STR ", tc . minimum , result ) # } # }
tree := & btree { nil } # numbers := [] int { 5 , 4 , 3 , 2 , 1 , - 1 , 0 } # fmt . Println (" STR ", numbers ) # treesort ( numbers , tree ) # fmt . Println (" STR ", numbers )
println (" STR ", s . a , s . b , s . c )
if _ , ok := g . edges [ vertex ]; ! ok { # g . edges [ vertex ] = make ( map [ VertexId ] int ) # }
if err := toJPEG ( os . Stdin , os . Stdout ); err != nil { # fmt . Fprintf ( os . Stderr , " STR ", err ) # os . Exit ( 1 ) # }
ans , count := 0 , 0 # for _ , v := range nums { # if v == 1 { # count ++ # if count > ans { # ans = count # } # } else { # count = 0 # } # } # return ans
const ( # adjLength = 1 3 # stringSerie = " STR " # ) # # serie := make ([] int , len ( stringSerie )) # for i , runeNum := range stringSerie { # serie [ i ] = int ( runeNum - ' 0 ') # } # # maxProduct := 0 # for i := 0 ; i < len ( serie )- adjLength ; i ++ { # product := 1 # for j := i ; j < i + adjLength ; j ++ { # product *= serie [ j ] # } # if product > maxProduct { # maxProduct = product # } # } # # fmt . Println ( maxProduct )
x , y = find ( x ), find ( y ) # if x != y { # if r [ x ] <= r [ y ] { # p [ x ] = y # r [ y ] += r [ x ] # } else { # p [ y ] = x # r [ x ] += r [ y ] # } # ans -- # }
var ret bool # var s string # var ts string # # ts = " STR " # s = " STR " # ret = true # if ret != isIsomorphic ( s , ts ) { # t . Fatalf (" STR ", ret ) # } # # ts = " STR " # s = " STR " # ret = false # if ret != isIsomorphic ( s , ts ) { # t . Fatalf (" STR ", ret ) # } # # ts = " STR " # s = " STR " # ret = true # if ret != isIsomorphic ( s , ts ) { # t . Fatalf (" STR ", ret ) # }
var sum int # # fmt . Println (" STR ") # for i := 0 ; i < 1 0 0 0 ; i ++ { # if i % 5 == 0 || i % 3 == 0 { # sum += i # } # } # fmt . Println (" STR ", sum )
starttime := time . Now () # # numbs := strings . Split ( numbers , " STR ") # # sum := big . NewInt ( 0 ) # # for _ , number := range numbs { # temp := big . NewInt ( 0 ) # temp . SetString ( number , 1 0 ) # sum = sum . Add ( sum , temp ) # } # # fmt . Println ( sum . String ()[: 1 0 ]) # # fmt . Println (" STR ", time . Since ( starttime ))
t . Parallel () # for _ , tc := range testcases { # if result := FindSmallestMissingPositive ( tc . input ); result != tc . smallestMissingPositive { # t . Errorf (" STR ", tc . input , tc . smallestMissingPositive , result ) # } # }
var tests = [] struct { # s string # valid bool # }{ # {" STR ", true }, # {" STR ", true }, # {" STR ", false }, # {" STR ", false }, # {" STR ", true }, # } # # for _ , tt := range tests { # valid := isValid ( tt . s ) # if valid != tt . valid { # t . Errorf (" STR ", tt . s , valid , tt . valid ) # } # }
benchmarkHashMapInsertDelete ( b , newChainedHashMap ())
nums := [] int { 1 , 3 , 2 , 2 , 5 , 2 , 3 , 7 } # fmt . Println ( findLHS ( nums )) # # nums 2 := [] int { 2 , 2 , 2 , 9 , 3 , 3 , 3 } # fmt . Println ( findLHS ( nums 2 ))
size := len ( nums ) # b := make ( bytes , size ) # resSize := 0 # # for i := range b { # b [ i ] = [] byte ( strconv . Itoa ( nums [ i ])) # resSize += len ( b [ i ]) # } # # sort . Sort ( b ) # # res := make ([] byte , 0 , resSize ) # for i := size - 1 ; i >= 0 ; i -- { # res = append ( res , b [ i ]...) # } # # i := 0 # for i < resSize - 1 && res [ i ] == ' 0 ' { # i ++ # } # # return string ( res [ i :])
fmt . Println ( spiralOrder ([][] int { # # # { 2 , 3 , 4 }, # { 5 , 6 , 7 }, # { 8 , 9 , 1 0 }, # { 1 1 , 1 2 , 1 3 }, # { 1 4 , 1 5 , 1 6 }, # }))
obj := Constructor () # obj . AddAtHead ( 1 ) # obj . AddAtTail ( 3 ) # obj . AddAtIndex ( 1 , 2 ) # got := obj . Get ( 1 ) == 2 # obj . DeleteAtIndex ( 1 ) # got = obj . Get ( 1 ) == 3 && got # obj . AddAtIndex ( 2 , 2 ) # got = obj . Get ( 5 ) == - 1 && got # if ! got { # t . Fatalf (" STR ", got , true ) # }
for n > m { # n &= ( n - 1 ) # } # return n
val , k , _ := v . extractTypeInternal ( current , false ) # return val , k
mod := 1 0 0 0 0 0 0 0 0 7 # n := len ( A ) # sort . Ints ( A ) # dp := make ([] int , n ) # dp [ 0 ] = 1 # res := 1 # for i := 1 ; i < n ; i ++ { # c := 1 # for j , k := 0 , i - 1 ; j <= k ; { # jk := A [ j ] * A [ k ] # if jk == A [ i ] { # p := dp [ j ] * dp [ k ] # if j != k { # p += p # } # c += p # j ++ # k -- # } else if jk < A [ i ] { # j ++ # } else { # k -- # } # } # dp [ i ] = c # res += c # } # return res % mod
fileNameChannel , sumInfoChannel := make ( chan string ), make ( chan string ) # go walkStep (" STR ", fileNameChannel ) # go func () { # runMultiple ( 1 0 0 , func () { # md 5 Step ( fileNameChannel , sumInfoChannel ) # }) # close ( sumInfoChannel ) # }() # printStep ( sumInfoChannel ) #
fmt . Println ( removeDuplicates 1 ([] int { 1 , 1 , 2 })) # fmt . Println ( removeDuplicates 2 ([] int { 0 , 0 , 1 , 1 , 1 , 2 , 2 , 3 , 3 , 4 }))
for fileName := range fileNameChannel { # bs := md 5 file ( fileName ) # sumInfoChannel <- fmt . Sprintf (" STR ", fileName , bs ) # }
for _ , o := range ops { # m = min ( m , o [ 0 ]) # n = min ( n , o [ 1 ]) # } # return m * n
result := make ([] string , 0 ) # return helper 2 2 ( n , n , " STR ", result )
count := 0 # cols := make ([] bool , n ) # for i := 0 ; i < len ( cols ); i ++ { # cols [ i ] = false # } # # d 1 := make ([] bool , 2 * n ) # d 2 := make ([] bool , 2 * n ) # for i := 0 ; i < len ( cols ); i ++ { # d 1 [ i ] = false # d 2 [ i ] = false # } # # helper ( 0 , cols , d 1 , d 2 , n , & count ) # # return count
kv := make ( map [ int ] struct {}) # for _ , val := range A { # if _ , ok := kv [ val ]; ok { # return val # } # kv [ val ] = struct {}{} # } # return 0
if len ( nums ) == 0 || k < 0 { # return 0 # } # m := map [ int ] int {} # for k , v := range nums { # m [ v ] = k # } # res := 0 # for i := 0 ; i < len ( nums ); i ++ { # if val , ok := m [ nums [ i ]+ k ]; ok && val != i { # delete ( m , nums [ i ]+ k ) # res ++ # } # } # return res
if left > right { # return val , - 1 # } # mid := left + (( right - left ) >> 1 ) # if value == arr [ mid ] { # return value , mid # } # if arr [ mid ] < value { # left = mid + 1 # } # if arr [ mid ] > value { # right = mid - 1 # } # return recursionBinarySearch ( arr , left , right , value )
if len ( word ) < 2 { # return true # } # first , second := isCapital ( word [ 0 ]), isCapital ( word [ 1 ]) # if ! second { # return detectOther ( word , false ) # } else if first { # return detectOther ( word , true ) # } # return false
switch v . Kind () { # case reflect . String : # v . SetString ( value ) # # case reflect . Int : # i , err := strconv . ParseInt ( value , 1 0 , 6 4 ) # if err != nil { # return err # } # v . SetInt ( i ) # # case reflect . Bool : # b , err := strconv . ParseBool ( value ) # if err != nil { # return err # } # v . SetBool ( b ) # # default : # return fmt . Errorf (" STR ", v . Type ()) # } # return nil
st := [] int {} # for i := 0 ; i < len ( a ); i ++ { # if a [ i ] > 0 || len ( st ) == 0 || st [ len ( st )- 1 ] < 0 { # st = append ( st , a [ i ]) # } else if st [ len ( st )- 1 ] <= - a [ i ] { # if st [ len ( st )- 1 ] < - a [ i ] { # i -- # } # st = st [: len ( st )- 1 ] # } # } # return st
t . Parallel () # for _ , tc := range testcases { # if result := BoustrophedonOrder ( tc . root ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
s := strings . Builder {} # repeat := len ( B ) / len ( A ) # if len ( B )% len ( A ) != 0 { # repeat ++ # } # for i := 0 ; i < repeat ; i ++ { # s . WriteString ( A ) # } # if strings . Index ( s . String (), B ) != - 1 { # return repeat # } # s . WriteString ( A ) # if strings . Index ( s . String (), B ) != - 1 { # return repeat + 1 # } # return - 1
return " STR "
d , base := 1 , 1 # for n > 9 * base * d { # n -= 9 * base * d # base *= 1 0 # d ++ # } # num := ( n - 1 )/ d + base # for i := 1 ; i < d -( n - 1 )% d ; i ++ { # num /= 1 0 # } # return num % 1 0
if h . backets [ key ] == nil { # return false # } # return h . backets [ key ]. exist
if head == nil || head . Next == nil { # return nil # } # slow , fast := head . Next , head . Next . Next # for fast != nil && fast . Next != nil && slow != fast { # slow , fast = slow . Next , fast . Next . Next # } # if slow != fast { # return nil # } # for slow != head { # slow , head = slow . Next , head . Next # } # return slow
if n == 0 { # return [][] string {} # } # # cols := make ([] bool , n ) # d 1 := make ([] bool , 2 * n ) # d 2 := make ([] bool , 2 * n ) # # board := make ([] string , n ) # # res := [][] string {} # # dfs ( 0 , cols , d 1 , d 2 , board , & res ) # # return res
if s == " STR " { # return [][] string {} # } # res , pal := [][] string {}, [] string {} # findPalindrome ( s , 0 , " STR ", true , pal , & res ) # return res
nums 1 := [] int { 2 , 2 , 3 , 2 } # # fmt . Println ( singleNumber ( nums 1 )) # fmt . Println ( singleNumber 4 ( nums 1 ))
return int 8 ( v )
obj := Constructor 7 0 6 () # obj . Put ( 7 , 1 0 ) # fmt . Printf (" STR ", obj . Get ( 7 )) # obj . Put ( 7 , 2 0 ) # fmt . Printf (" STR ", obj . Get ( 7 )) # param 1 := obj . Get ( 1 0 0 ) # fmt . Printf (" STR ", param 1 ) # obj . Remove ( 7 ) # param 1 = obj . Get ( 7 ) # fmt . Printf (" STR ", param 1 )
x , y := 0 , 1 # return func () int { # ret := x # x , y = y , x + y # return ret # }
l := len ( nums ) # # if l == 0 { # return 0 # } # # if l == 1 { # return nums [ 0 ] # } # # temp := nums [ 0 ] # max := temp # i := 1 # for i < l { # if temp < 0 { # temp = nums [ i ] # } else { # temp += nums [ i ] # } # # if max < temp { # max = temp # } # # i ++ # } # # return max
for i , course := range topoSort ( prereqs ) { # fmt . Printf (" STR ", i + 1 , course ) # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 3 0 , 2 0 , 1 5 0 , 1 0 0 , 4 0 }, 3 }, # {" STR ", [] int { 6 0 , 6 0 , 6 0 }, 3 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
res := [] int {} # stack := []* TreeNode {} # p := root # for len ( stack ) != 0 || p != nil { # for p != nil { # res = append ( res , p . Val ) # stack = append ( stack , p ) # p = p . Left # } # if len ( stack ) != 0 { # p = stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # p = p . Right # } # } # return res
return helper 1 0 5 ( preorder , inorder , 0 , len ( preorder )- 1 , 0 , len ( inorder )- 1 )
if len ( x ) == 0 { # return nil # } # sort . Slice ( x , func ( i , j int ) bool { # if x [ i ]. End < x [ j ]. End { # return true # } else if x [ i ]. End == x [ j ]. End { # return x [ i ]. Start < x [ j ]. Start # } # return false # }) # p := [] Point { x [ 0 ]. End } # last := p [ 0 ] # for _ , interval := range x { # if interval . Start > last { # last = interval . End # p = append ( p , last ) # } # } # return p
t . Parallel () # for _ , tc := range testcases { # if result := PascalTriangleRow ( tc . row ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
arr := randomSlice ( 0 , 2 0 , 1 0 ) # bst := newBstRecrusive () # for _ , v := range arr { # bst . Insert ( uint 3 2 ( v )) # } # sort . Ints ( arr ) # key := getRand (). Intn ( len ( arr )- 2 ) + 1 # result := int ( bst . Predecessor ( bst . Search ( uint 3 2 ( arr [ key ])), bst . Root ()).(* bstElement ). Key ) # if result != arr [ key - 1 ] { # t . Log ( fmt . Sprintf (" STR ", arr [ key ], arr [ key - 1 ], result )) # t . Fail () # }
if len ( lists ) == 0 { # return nil # } else if len ( lists ) == 1 { # return lists [ 0 ] # } # return mergeTwoLists ( mergeKLists ( lists [: len ( lists )/ 2 ]), mergeKLists ( lists [ len ( lists )/ 2 :])) #
r := intSqrt ( num ) # return r * r == num
t . Parallel () # for _ , tc := range testcases { # if result := StartingIndicies ( tc . str , tc . pattern ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
nameLen , namePtr := readVarint ( unsafe . Pointer ( uintptr ( table ) + index )) # return *(* string )( unsafe . Pointer (& stringHeader { # data : namePtr , # len : nameLen , # }))
tests := map [ string ] int { # " STR ": 3 , # " STR ": 1 , # " STR ": 3 , # " STR ": 6 , # } # # for in , want := range tests { # got := lengthOfLongestSubstring ( in ) # if got != want { # t . Fatalf (" STR ", in , got , want ) # } # }
t . Parallel () # for _ , tc := range testcases { # if result := MaxSubArray ( tc . arr ); result != tc . maxSum { # t . Errorf (" STR ", tc . maxSum , result ) # } # }
if len ( pre ) == 0 { # return nil # } # # rootValue := pre [ 0 ] # leftCount := partitionTree ( pre [ 1 :], post [ 0 : len ( post )- 1 ]) # return & TreeNode { # Val : rootValue , # Left : constructFromPrePost ( pre [ 1 : 1 + leftCount ], post [: leftCount ]), # Right : constructFromPrePost ( pre [ 1 + leftCount :], post [ leftCount : len ( post )- 1 ]), # }
var n = [ Pow ] int {} # n [ 0 ] = 1 # for i := 0 ; i < Pow ; i ++ { # for ii := 0 ; ii < len ( n ); ii ++ { # if n [ ii ] > 0 { # n [ ii ] = n [ ii ] << 1 # } # if ii > 0 && n [ ii - 1 ] >= 1 0 { # n [ ii ] += int ( n [ ii - 1 ] / 1 0 ) # n [ ii - 1 ] = n [ ii - 1 ] % 1 0 # } # } # } # sum := 0 # for i := 0 ; i < len ( n ); i ++ { # sum += n [ i ] # } # fmt . Println ( sum )
return validate ( root , 0 , 0 , false , false )
favorites = make ([] string , 3 ) # favorites [ 0 ] = " STR " # favorites [ 1 ] = " STR " # favorites [ 2 ] = " STR "
a , b := analyze ( c 1 ) # c , d := analyze ( c 2 ) # # return fmt . Sprintf (" STR ", a * c - b * d , a * d + b * c )
return WordDictionary { make ( map [ int ][] string )};
var ret , val int # nums 1 := [] int {} # val = 0 # ret = 0 # if removeElement ( nums 1 , val ) != ret { # t . Fatalf (" STR ", ret ) # } # # nums 2 := [] int { 3 , 2 , 2 , 3 } # val = 3 # ret = 2 # if removeElement ( nums 2 , val ) != ret { # t . Fatalf (" STR ", ret ) # } # # nums 3 := [] int { 0 , 1 , 2 , 2 , 3 , 0 , 4 , 2 } # val = 2 # ret = 5 # if removeElement ( nums 3 , val ) != ret { # t . Fatalf (" STR ", ret ) # }
return len ( s . stack )
println ( y {}. name ()) # # var v f = b {} # println ( v . fruit ()) # # println ( a {} == b {}) # println ( a { 2 } == b { 3 })
denominator := big . NewInt ( int 6 4 ( math . Pow ( 1 0 . 0 , float 6 4 ( m )))) # # left = big . NewInt ( 0 ). Div ( a , denominator ) # right = sub ( a , big . NewInt ( 0 ). Mul ( left , denominator )) # # return
if len ( nums ) <= 1 { # return true # } # dp := make ([] bool , len ( nums )) # dp [ 0 ] = true # for i := 0 ; i < len ( nums ); i ++ { # if dp [ i ] == false { # continue # } # for j := 1 ; j <= nums [ i ] && j + i < len ( nums ); j ++ { # dp [ i + j ] = true # } # } # return dp [ len ( nums )- 1 ]
str := " STR " # ans := firstNoRepeatingChar ( str ) # fmt . Printf (" STR ", ans , ans )
var r , n , k , i uint 6 4 # r , n , k = 1 , 2 * x , x # for i = 1 ; i <= k ; i ++ { # r *= n + 1 - i # r /= i # } # return r
if 0 == len ( s ) { # return 0 # } # # digits := map [ byte ] int {' I ': 1 , ' V ': 5 , ' X ': 1 0 , ' L ': 5 0 , ' C ': 1 0 0 , ' D ': 5 0 0 , ' M ': 1 0 0 0 } # sum := digits [ s [ len ( s )- 1 ]] # # for i := len ( s ) - 1 ; i > 0 ; i -- { # cur := digits [ s [ i ]] # pre := digits [ s [ i - 1 ]] # if cur > pre { # sum -= pre # } else { # sum += pre # } # } # return sum
TemplateTestExtendedGCD ( t , ExtendedIterative )
if p == nil && q != nil || p != nil && q == nil { # return false # } # if p == nil && q == nil { # return true # } # if p . Val != q . Val { # return false # } # ret := isSameTree ( p . Left , q . Left ) # if ! ret { # return false # } # return isSameTree ( p . Right , q . Right )
sum 1 , sum 2 := len ( nums ), 0 # for i := range nums { # sum 1 += i # sum 2 += nums [ i ] # } # return sum 1 - sum 2
if root != nil { # root . Left = pruneTree ( root . Left ) # root . Right = pruneTree ( root . Right ) # if root . Left == nil && root . Right == nil && root . Val == 0 { # return nil # } # } # return root
res := strings . Split ( tag , " STR ") # return res [ 0 ], res [ 1 :]
a , b := 0 , 0 # for _ , n := range nums { # a = ( a ^ n ) & ^ b # b = ( b ^ n ) & ^ a # } # return a
arr = make ([] int 6 4 , 8 0 0 0 0 ) # for i := 1 ; i < len ( arr ); i ++ { # arr [ i ] = int 6 4 ( i ) * ( 3 * int 6 4 ( i ) - 1 ) / 2 # } # var tmp int 6 4 # i := 1 4 4 # loop : # for { # tmp = int 6 4 ( i ) * int 6 4 ( 2 * i - 1 ) # if isPentagonal ( tmp ) { # println ( tmp ) # break loop # } # i ++ # }
qs := [] question 1 9 1 { # # { # para 1 9 1 { 5 }, # ans 1 9 1 { 1 }, # }, # { # para 1 9 1 { 1 3 }, # ans 1 9 1 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 9 1 , q . para 1 9 1 # fmt . Printf (" STR ", p , hammingWeight ( p . one )) # } # fmt . Printf (" STR ")
return fmt . Sprintf (" STR ", t . kind , t . tok )
for i , j := x , y ; i <= j ; i , j = i + 1 , j - 1 { # arr [ i ], arr [ j ] = arr [ j ], arr [ i ] # }
x = find ( x ) # y = find ( y ) # if x != y { # if rank [ x ] >= rank [ y ] { # rank [ x ] += rank [ y ] # p [ y ] = x # } else { # rank [ y ] += rank [ x ] # p [ x ] = y # } # }
u , err := user . Current () # if err != nil { # panic (" STR " + err . Error ()) # } # if u . HomeDir == "" { # panic (" STR ") # } # return u . HomeDir
var xor int # for _ , num := range nums { # xor ^= num # } # # lowest := xor & - xor # # var a , b int # for _ , num := range nums { # if num & lowest == 0 { # a ^= num # } else { # b ^= num # } # } # return [] int { a , b }
v , ok := s . LookupVar ( n . Name ) # if ! ok { # return TypeInvalid , fmt . Errorf (" STR ", n . Name ) # } # # return v . Type , nil
n := len ( a ) # if n == 1 { # return 0 # } # # i 1 , i 2 := 0 , 1 # if a [ i 1 ] < a [ i 2 ] { # i 1 , i 2 = i 2 , i 1 # } # # for i := 2 ; i < n ; i ++ { # if a [ i 1 ] < a [ i ] { # i 2 , i 1 = i 1 , i # } else if a [ i 2 ] < a [ i ] { # i 2 = i # } # } # # if a [ i 2 ] == 0 || a [ i 1 ]/ a [ i 2 ] >= 2 { # return i 1 # } # return - 1
prob := [] func (){ nil , nil , allPrimes , largestPalindrome , smallestMult , # sumSqrDif , tenThousandPrime , greatestProductOneThousand , pythaghorasTriplet , # sumPrimesBelow 2 M , highestOfGrid , nthTriangleNumber , largeSum , prob 1 4 , prob 1 5 , # prob 1 6 } # if len ( os . Args ) < 1 { # fmt . Println (" STR ") # } # ex , err := strconv . Atoi ( os . Args [ 1 ]) # if err != nil { # fmt . Println (" STR ") # } # if ex > len ( prob ) { # fmt . Println (" STR ") # } # t := time . Now (). UnixNano () # prob [ ex - 1 ]() # t = time . Now (). UnixNano () - t # fmt . Printf (" STR ", t , t / 1 0 0 0 0 0 0 ) # return #
qs := [] question 2 6 3 { # # { # para 2 6 3 { 6 }, # ans 2 6 3 { true }, # }, # # { # para 2 6 3 { 8 }, # ans 2 6 3 { true }, # }, # # { # para 2 6 3 { 1 4 }, # ans 2 6 3 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 6 3 , q . para 2 6 3 # fmt . Printf (" STR ", p , isUgly ( p . one )) # } # fmt . Printf (" STR ")
helper ( root , nil ) # return root
buf , err := json . Marshal ( itf ) # if err != nil { # panic (" STR " + err . Error ()) # } # return string ( buf )
var result [] int # for i := range nums { # var sum int # for j := i ; j < len ( nums ); j ++ { # sum += nums [ j ] # if sum == k { # return nums [ i : j + 1 ] # } # } # } # return result
if k <= 0 { # return head # } # fake := & ListNode { Next : head } # p := fake # for p != nil { # p . Next = reverseKNodes ( p . Next , k ) # for i := 0 ; p != nil && i < k ; i ++ { # p = p . Next # } # } # return fake . Next
slow , fast := head , head # for fast != nil && fast . Next != nil { # slow = slow . Next # fast = fast . Next . Next # } # head 2 := reverse ( slow ) # for ; head != nil && head 2 != nil ; head , head 2 = head . Next , head 2 . Next { # if head . Val != head 2 . Val { # return false # } # } # return true
if len ( nums ) < 2 { # return len ( nums ) # } # sort . Ints ( nums ) # # max , tmp := 0 , 1 # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ]- 1 == nums [ i - 1 ] { # tmp ++ # } else if nums [ i ] != nums [ i - 1 ] { # if max < tmp { # max = tmp # } # tmp = 1 # } # } # if max < tmp { # return tmp # } # return max
if n == 0 { # return [][] int {} # } # # res := make ([][] int , n ) # for i := range res { # res [ i ] = make ([] int , n ) # } # # top , bottom , left , right := 0 , n - 1 , 0 , n - 1 # num := 1 # for top <= bottom && left <= right { # for j := left ; j <= right ; j ++ { # res [ top ][ j ] = num # num ++ # } # top ++ # for j := top ; j <= bottom ; j ++ { # res [ j ][ right ] = num # num ++ # } # right -- # for j := right ; j >= left ; j -- { # res [ bottom ][ j ] = num # num ++ # } # bottom -- # for j := bottom ; j >= top ; j -- { # res [ j ][ left ] = num # num ++ # } # left ++ # } # # return res
if i < j { # return i # } # return j
var max , left , t int # right := len ( height ) - 1 # for left < right { # if height [ left ] < height [ right ] { # t = height [ left ] * ( right - left ) # left ++ # } else { # t = height [ right ] * ( right - left ) # right -- # } # if t > max { # max = t # } # } # return max
t . Parallel () # for _ , tc := range testcases { # if result := LongestPalindromicSubstringBrute ( tc . input ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
n 1 , n 2 := len ( word 1 ), len ( word 2 ) # # dp := make ([] int , n 2 + 1 ) # for i := 0 ; i < n 1 ; i ++ { # pre := dp [ 0 ] # for j := 0 ; j < n 2 ; j ++ { # tmp := dp [ j + 1 ] # if word 1 [ i ] == word 2 [ j ] { # dp [ j + 1 ] = pre + 1 # } else { # dp [ j + 1 ] = max ( dp [ j + 1 ], dp [ j ]) # } # pre = tmp # } # } # # return n 1 + n 2 - 2 * dp [ n 2 ]
count := [ 1 0 1 ] int {} # for _ , a := range A { # count [ a ]++ # } # # res := 0 # # for Ai := 0 ; Ai <= 1 0 0 ; Ai ++ { # for Aj := Ai ; Aj <= 1 0 0 ; Aj ++ { # Ak := target - Ai - Aj # if Ak < 0 || 1 0 0 < Ak { # continue # } # # switch { # case Ai == Aj && Aj == Ak : # res += count [ Ai ] * ( count [ Ai ] - 1 ) * ( count [ Ai ] - 2 ) / 6 # case Ai == Aj && Aj < Ak : # res += count [ Ai ] * ( count [ Ai ] - 1 ) / 2 * count [ Ak ] # case Aj == Ak : # res += count [ Ai ] * count [ Aj ] * ( count [ Aj ] - 1 ) / 2 # case Aj < Ak : # res += count [ Ai ] * count [ Aj ] * count [ Ak ] # } # } # } # # return res % mod
return i , j - 1
tests := [...] testType { # { # in : 2 , # want : 1 , # }, # { # in : 1 0 , # want : 3 6 , # }, # { # in : 3 , # want : 2 , # }, # { # in : 7 , # want : 1 2 , # }, # { # in : 1 7 , # want : 4 8 6 , # }, # } # for _ , tt := range tests { # got := integerBreak ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
return helper 9 8 8 ( root , make ([] int , 0 ), " STR ")
problems := GetSortedProblemsInstance () # fmt . Println ( len ( problems )) # # for _ , v := range problems { # if v . PaidOnly { # fmt . Println ( v ) # } # fmt . Println ( v ) # } #
var vals [] int # if nil == root { # return vals # } # # nodes := []* TreeNode { root } # for len ( nodes ) > 0 { # node := nodes [ len ( nodes )- 1 ] # for p := node ; nil != p ; p = p . Left { # vals = append ( vals , p . Val ) # if node == p { # nodes = nodes [: len ( nodes )- 1 ] # } # if nil != p . Right { # nodes = append ( nodes , p . Right ) # } # } # } # return vals
t . Parallel () # b := createFilledBucket ( time . Now (). Add ( time . Duration ( 4 ))) # # done := make ( chan bool ) # worker := func () { # expire := time . Now (). Add ( time . Duration ( 4 * time . Second )) # for i := 0 ; i < 1 0 0 0 0 ; i ++ { # b . Set ( randomString ( 2 ), " STR ", expire ) # } # done <- true # } # workers := 4 # for i := 0 ; i < workers ; i ++ { # go worker () # } # for i := 0 ; i < workers ; i ++ { # _ = <- done # }
t . Parallel () # for _ , tc := range testcases { # if result := RotateNew ( tc . original , tc . k ); ! reflect . DeepEqual ( result , tc . rotated ) { # t . Errorf (" STR ", tc . rotated , result ) # } # }
content , err := ioutil . ReadFile (" STR ") # if err != nil { # println (" STR ") # return # } # names := strings . Split ( strings . Replace ( string ( content ), " STR ", " STR ", - 1 ), " STR ") # content = nil # sort . Strings ( names ) # # var sum , score int # for i := 0 ; i < len ( names ); i ++ { # score = 0 # for n := 0 ; n < len ( names [ i ]); n ++ { # score += int ( names [ i ][ n ]) - 6 4 # } # sum += score * ( i + 1 ) # } # println ( sum )
maxd = 0 # val = 0 # dfs ( root , 1 ) # return val
qs := [] question 2 0 9 { # # { # para 2 0 9 { 7 , [] int { 2 , 3 , 1 , 2 , 4 , 3 }}, # ans 2 0 9 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 0 9 , q . para 2 0 9 # fmt . Printf (" STR ", p , minSubArrayLen ( p . s , p . one )) # } # fmt . Printf (" STR ")
fmt . Println ( mostCommonWord (" STR ", [] string {" STR "}))
n := len ( nums ) # if n <= 1 { # return 0 # } # # dp := make ([] int , n ) # for i := 0 ; i < len ( nums ); i ++ { # dp [ i ] = math . MaxInt 3 2 # } # dp [ 0 ] = 0 # # for i := 0 ; i < n - 1 ; i ++ { # for j := 1 ; j <= nums [ i ]; j ++ { # if i + j < n { # dp [ i + j ] = Min ( dp [ i + j ], dp [ i ]+ 1 ) # } # } # } # return dp [ n - 1 ]
reversed := " STR " # lastIndex := len ( s ) - 1 # for i := len ( s ) - 1 ; i >= 0 ; i -- { # if ' ' == s [ i ] { # if i == lastIndex { # lastIndex -- # } else { # reversed += s [ i + 1 : lastIndex + 1 ] + " STR " # lastIndex = i - 1 # } # } else { # if 0 == i && i <= lastIndex { # reversed += s [ i : lastIndex + 1 ] # } # } # } # if len ( reversed ) > 1 && ' ' == reversed [ len ( reversed )- 1 ] { # reversed = reversed [: len ( reversed )- 1 ] # } # return reversed
zero := reflect . Zero ( f . value . Type ()). Interface () # current := f . Value () # # return reflect . DeepEqual ( current , zero )
return new ( rsVEBTreeItem ). init ( key , value )
if root == nil { # return # } # helper ( root . Left , l ) # * l = append (* l , root . Val ) # helper ( root . Right , l )
var m , n int # # if m = len ( obstacleGrid ); m == 0 { # return 0 # } # if n = len ( obstacleGrid [ 0 ]); n == 0 { # return 0 # } # # dp := [][] int {} # for i := 0 ; i <= m ; i ++ { # dp = append ( dp , make ([] int , n + 1 )) # } # dp [ m ][ n - 1 ] = 1 # # for i := m - 1 ; i >= 0 ; i -- { # for j := n - 1 ; j >= 0 ; j -- { # if obstacleGrid [ i ][ j ] != 1 { # dp [ i ][ j ] = dp [ i + 1 ][ j ] + dp [ i ][ j + 1 ] # } # } # } # # return dp [ 0 ][ 0 ]
var limit int = 4 . 0 e 6 # var sum = 2 # fibo := [] int { 1 , 1 , 2 } # for fibo [ 2 ] < limit { # fibo [ 0 ], fibo [ 1 ], fibo [ 2 ] = fibo [ 1 ], fibo [ 2 ], fibo [ 1 ]+ fibo [ 2 ] # if Even ( fibo [ 2 ]) { # sum += fibo [ 2 ] # } # } # # fmt . Println ( fibo , sum )
strs := make ([] string , len ( nums )) # for i , num := range nums { # strs [ i ] = strconv . Itoa ( num ) # } # sort . Slice ( strs , func ( i , j int ) bool { # first , _ := strconv . Atoi ( strs [ i ] + strs [ j ]) # second , _ := strconv . Atoi ( strs [ j ] + strs [ i ]) # return first > second # }) # result , _ := strconv . Atoi ( strings . Join ( strs , " STR ")) # return result
var T [][] int # for i := 0 ; i < len ( A ); i ++ { # for j := 0 ; j < len ( A [ i ]); j ++ { # if j >= len ( T ) { # T = append ( T , nil ) # } # T [ j ] = append ( T [ j ], A [ i ][ j ]) # } # } # return T
rand . Seed ( time . Now (). UnixNano ())
f := largestFactor ( 6 0 0 8 5 1 4 7 5 1 4 3 ) # # fmt . Println ( f ) #
if len ( heights ) < 3 { # return 0 # } # total := 0 # hl := heights [ 0 ] # hri , hr := highestToRight ( heights , 2 ) # for i := 1 ; i < len ( heights )- 1 ; i ++ { # h := min ( hl , hr ) # if cavity := h - heights [ i ]; cavity > 0 { # total += cavity # } # if heights [ i ] > hl { # hl = heights [ i ] # } # if i + 1 == hri { # hri , hr = highestToRight ( heights , hri ) # } # } # return total
qs := [] question 1 7 1 { # # { # para 1 7 1 {" STR "}, # ans 1 7 1 { 1 }, # }, # # { # para 1 7 1 {" STR "}, # ans 1 7 1 { 2 8 }, # }, # # { # para 1 7 1 {" STR "}, # ans 1 7 1 { 7 0 1 }, # }, # # { # para 1 7 1 {" STR "}, # ans 1 7 1 { 7 3 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 7 1 , q . para 1 7 1 # fmt . Printf (" STR ", p , titleToNumber ( p . s )) # } # fmt . Printf (" STR ")
count := map [ string ] int {} # res := []* TreeNode {} # var dfs func (* TreeNode ) string # dfs = func ( node * TreeNode ) string { # if node == nil { # return " STR " # } # l , r := dfs ( node . Left ), dfs ( node . Right ) # k := strconv . Itoa ( node . Val ) + l + r # count [ k ]++ # if count [ k ] == 2 { # res = append ( res , node ) # } # return k # } # dfs ( root ) # return res
openBrackets := make ([] rune , 0 , ( len ( brackets )/ 2 )+ 1 ) # for _ , r := range brackets { # if matchAnyRune ( r , '(', '[', '{') { # openBrackets = append ( openBrackets , r ) # } else if matchAnyRune ( r , ')', ']', '}') { # if len ( openBrackets ) == 0 { # return false # } # var pop rune # pop , openBrackets = openBrackets [ len ( openBrackets )- 1 ], openBrackets [: len ( openBrackets )- 1 ] # if ! IsMatch ( pop , r ) { # return false # } # } # if len ( openBrackets ) > len ( brackets )/ 2 { # return false # } # } # return len ( openBrackets ) == 0
ss := strings . Split ( names , " STR ") # if len ( ss ) == 0 { # return fmt . Errorf (" STR ") # } # for _ , sn := range ss { # err := this . addName ( sn ) # if err != nil { # return err # } # } # return nil
if rowIndex == 0 { # return [] int { 1 } # } # pt := make ([] int , 0 ) # for i := 0 ; i < rowIndex ; i ++ { # tmp := make ([] int , 0 ) # tmp = append ( tmp , 1 ) # for j := 1 ; j < i + 1 ; j ++ { # tmp = append ( tmp , pt [ j ]+ pt [ j - 1 ]) # } # tmp = append ( tmp , 1 ) # pt = tmp # } # return pt
d := [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "} # # ans := make ( map [ string ] int , 0 ) # for _ , word := range words { # ecd := " STR " # for i := 0 ; i < len ( word ); i ++ { # ecd += d [ word [ i ]-' a '] # } # ans [ ecd ]++ # } # return len ( ans )
for _ , tc := range testCases { # t . Run ( tc . name , func ( t * testing . T ) { # actual := Distance ( tc . string 1 , tc . string 2 , tc . insertionCost , tc . substitutionCost , tc . deletionCost ) # if actual != tc . expected { # t . Errorf (" STR ", tc . string 1 , tc . string 2 , tc . expected , actual ) # } # }) # }
max := 0 # var tmp int # for i := 1 ; i < 1 0 0 0 0 ; i ++ { # str := " STR " # for j := 1 ; j < 9 && len ( str ) < 9 ; j ++ { # str += strconv . Itoa ( i * j ) # } # if len ( str ) == 9 && isPandigital ( str ) { # tmp , _ = strconv . Atoi ( str ) # if tmp > max { # max = tmp # } # } # } # println ( max )
cases := [] struct { # name string # inputs bool # expect bool # }{ # {" STR ", true , true }, # {" STR ", true , true }, # {" STR ", false , false }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := Solution ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
var res [] string # if len ( s ) <= 1 0 { # return nil # } # # str := " STR " # rec := make ( map [ string ] int , len ( s )- 9 ) # for i := 0 ; i + 1 0 <= len ( s ); i ++ { # str = s [ i : i + 1 0 ] # if v := rec [ str ]; v == 1 { # res = append ( res , str ) # } # rec [ str ]++ # } # # sort . Strings ( res ) # # return res
std := n & 3 # if std != 1 && std != 2 { # return false # } # # for n > 0 { # if n & 3 != std { # return false # } # n >>= 2 # } # # return true
max := 0 # # for i , j := 0 , - 1 ; i < len ( nums ); i ++ { # if nums [ i ] == 0 { # j = i # } else { # if max < i - j { # max = i - j # } # } # } # # return max
return num > 0 && ( num &( num - 1 )) == 0 && ( num - 1 )% 3 == 0
l := 0 # for _ , v := range nums { # if v != val { # nums [ l ] = v # l ++ # } # } # return l
qs := [] question 1 0 7 8 { # # { # para 1 0 7 8 {" STR ", " STR ", " STR "}, # ans 1 0 7 8 {[] string {" STR ", " STR "}}, # }, # # { # para 1 0 7 8 {" STR ", " STR ", " STR "}, # ans 1 0 7 8 {[] string {" STR ", " STR "}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 7 8 , q . para 1 0 7 8 # fmt . Printf (" STR ", p , findOcurrences ( p . t , p . f , p . s )) # } # fmt . Printf (" STR ")
t . Parallel () # # for _ , tc := range testcases { # if start , end := BusiestBuildingTimes ( tc . moves ); start != tc . start || end != tc . end { # t . Errorf (" STR ", tc . start , tc . end , start , end ) # } # }
t . Parallel () # for _ , tc := range testcases { # if result := MaxWeightPathTriangle ( tc . triangle ); result != tc . maxWeight { # t . Errorf (" STR ", tc . maxWeight , result ) # } # }
var tests = [] struct { # before [] int # after * ListNode # }{ # {[] int { 1 , 2 , 3 , 3 , 4 , 4 , 5 }, newList ( 1 , 2 , 5 )}, # {[] int { 1 , 1 , 1 , 2 , 3 }, newList ( 2 , 3 )}, # } # # for _ , tt := range tests { # after := deleteDuplicates ( newList ( tt . before ...)) # if reflect . DeepEqual ( after , tt . after ) == false { # t . Errorf (" STR ", newList ( tt . before ...), after , tt . after ) # } # }
for i := 1 ; i <= 9 ; i ++ { # d 1 := ( i * i ) / 1 0 # d 2 := ( i * i ) % 1 0 # # if ( a [ d 1 ] && b [ d 2 ]) || ( a [ d 2 ] && b [ d 1 ]) { # } else { # return false # } # } # return true
i := 0 # for i < len ( nums ) && nums [ i ] <= target { # i ++ # } # return i
if root == nil { # return 0 # } # if root . Left == nil && root . Right == nil { # return 1 # } # l := maxDepth ( root . Left ) # r := maxDepth ( root . Right ) # if l > r { # return l + 1 # } # return r + 1
if len ( nums ) == 0 { # return 0 # } # # dp := make ([][] int , len ( nums )) # for i := range dp { # dp [ i ] = make ([] int , len ( nums )) # } # # for le := 1 ; le <= len ( nums ); le ++ { # for i := 0 ; i <= len ( nums )- le ; i ++ { # j := i + le - 1 # for k := i ; k <= j ; k ++ { # left , right := 1 , 1 # if i > 0 { # left = nums [ i - 1 ] # } # # if j < len ( nums )- 1 { # right = nums [ j + 1 ] # } # # coins := left * nums [ k ] * right # if k != i { # coins += dp [ i ][ k - 1 ] # } # # if k != j { # coins += dp [ k + 1 ][ j ] # } # # if coins > dp [ i ][ j ] { # dp [ i ][ j ] = coins # } # } # } # } # # return dp [ 0 ][ len ( nums )- 1 ]
result := " STR " # negative := false # if num < 0 { # negative = true # num = - num # } # # for num > 0 { # result = fmt . Sprintf (" STR ", num % 7 , result ) # num = num / 7 # } # # if len ( result ) == 0 { # result = " STR " # } # # if negative { # result = " STR " + result # } # # return result
q := url . QueryEscape ( strings . Join ( terms , " STR ")) # resp , err := http . Get ( IssuesURL + " STR " + q ) # if err != nil { # return nil , err # } # # if resp . StatusCode != http . StatusOK { # resp . Body . Close () # return nil , fmt . Errorf (" STR ", resp . Status ) # } # # var result IssuesSearchResult # if err := json . NewDecoder ( resp . Body ). Decode (& result ); err != nil { # resp . Body . Close () # return nil , err # } # resp . Body . Close () # return & result , nil
s . Mark = marks
l := len ( A ) / 2 # m := make ( map [ int ] int ) # for _ , v := range A { # if num , ok := m [ v ]; ok { # if num + 1 == l { # return v # } else { # m [ v ]++ # } # } else { # m [ v ] = 1 # } # } # return 0
sort . Ints ( nums ) # ret := 0 # for i := 0 ; i < len ( nums ); i += 2 { # ret += nums [ i ] # } # return ret
l , r := 0 , len ( nums )- 1 # for l < r { # mid := ( l + r + 1 ) / 2 # if nums [ mid ] > nums [ mid - 1 ] { # l = mid # } else { # r = mid - 1 # } # } # return l
sd := [] int 6 4 { 1 , 6 , 3 , 2 , 1 9 2 3 , 1 2 3 , - 1 2 3 , - 2 9 , 3 , 0 , 1 } # sort . Slice ( sd , func ( i , j int ) bool { # return sd [ i ] > sd [ j ] # }) # println (" STR ") # for _ , d := range sd { # println ( d ) # } # # ud := [] uint 6 4 { 1 , 6 , 3 , 2 , 1 9 2 3 , 1 2 3 , 2 9 , 3 , 0 , 1 } # sort . Slice ( ud , func ( i , j int ) bool { # return ud [ i ] > ud [ j ] # }) # println (" STR ") # for _ , d := range ud { # println ( d ) # }
if len ( digits ) == 0 { # return nil # } # # buttons := [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "} # # var combinations [] string # combination := make ([] byte , len ( digits )) # # var f func ( int ) # f = func ( i int ) { # if i == len ( digits ) { # combinations = append ( combinations , string ( combination )) # return # } # # letters := buttons [ digits [ i ]-' 2 '] # for j := 0 ; j < len ( letters ); j ++ { # combination [ i ] = letters [ j ] # f ( i + 1 ) # } # } # f ( 0 ) # # return combinations
sorted := make ([] int , 1 0 0 0 0 ) # # for i := 0 ; i < 1 0 0 0 0 ; i ++ { # sorted [ i ] = 2 * i # } # # for i := 0 ; i < 1 0 0 0 0 ; i ++ { # index := search ( sorted , 2 * i ) # # if index != i { # fmt . Println ( index ) # t . Error () # } # } # # if search ( sorted , 3 ) != - 1 { # t . Error () # }
max := 1 0 0 0 0 0 0 # # circularPrimes , primeRotations := [] int {}, [] int {} # var isCircularPrime bool # for i := 0 ; i < max ; i ++ { # if big . NewInt ( int 6 4 ( i )). ProbablyPrime ( 2 0 ) { # if ! Contains ( circularPrimes , i ) { # isCircularPrime = true # primeRotations = getRotations ( i ) # for i := 0 ; i < len ( primeRotations ); i ++ { # if isCircularPrime { # isCircularPrime = big . NewInt ( int 6 4 ( primeRotations [ i ])). ProbablyPrime ( 2 0 ) # } # } # if isCircularPrime { # fmt . Println ( i ) # for i := 0 ; i < len ( primeRotations ); i ++ { # if ! Contains ( circularPrimes , primeRotations [ i ]) { # circularPrimes = append ( circularPrimes , primeRotations [ i ]) # } # } # } # } # } # } # fmt . Println ( len ( circularPrimes ))
if want . Start != got . Start { # t . Errorf (" STR ", want . Start , got . Start ) # } # if want . End != got . End { # t . Errorf (" STR ", want . End , got . End ) # } # if want . Length != got . Length { # t . Errorf (" STR ", want . Length , got . Length ) # } # if want . Satisfied != got . Satisfied { # t . Errorf (" STR ", want . Satisfied , got . Satisfied ) # }
wm , l := make ( map [ string ] bool ), len ( s ) # for _ , w := range wordDict { # wm [ w ] = true # } # dp := make ([] bool , l + 1 ) # dp [ 0 ] = true # for i := 1 ; i <= l ; i ++ { # for j := 0 ; j < i ; j ++ { # if dp [ j ] && wm [ s [ j : i ]] { # dp [ i ] = true # break # } # } # } # return dp [ l ]
return ( high .( uint 3 2 ) << uint 3 2 ( lgu >> 1 )) | m . Low ( lgu , low ).( uint 3 2 )
qs := [] question 1 3 7 { # # { # para 1 3 7 {[] int { 2 , 2 , 3 , 2 }}, # ans 1 3 7 { 3 }, # }, # # { # para 1 3 7 {[] int { 0 , 1 , 0 , 1 , 0 , 1 , 9 9 }}, # ans 1 3 7 { 9 9 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 3 7 , q . para 1 3 7 # fmt . Printf (" STR ", p , singleNumberII ( p . s )) # } # fmt . Printf (" STR ")
r := make ([] bool , len ( matrix )) # c := make ([] bool , len ( matrix [ 0 ])) # # for i := range matrix { # for j := range matrix [ i ] { # if matrix [ i ][ j ] == 0 { # r [ i ] = true # c [ j ] = true # } # } # } # # for i := range r { # if r [ i ] { # for j := range matrix [ i ] { # matrix [ i ][ j ] = 0 # } # } # } # # for j := range c { # if c [ j ] { # for i := range matrix { # matrix [ i ][ j ] = 0 # } # } # }
n := len ( S ) # bs := [] byte ( S ) # for l , r := 0 , n - 1 ; l < r ; l , r = l + 1 , r - 1 { # for l < r && ! isChar ( bs [ l ]) { # l ++ # } # for l < r && ! isChar ( bs [ r ]) { # r -- # } # if l < r { # bs [ l ], bs [ r ] = bs [ r ], bs [ l ] # } # } # return string ( bs )
ans , m := 0 , make ( map [ int ] int ) # for _ , v := range nums { # m [ v ]++ # } # for n , v := range m { # if k < 0 { # return ans # } else if k == 0 && v >= 2 { # ans ++ # } else if k > 0 && m [ n + k ] > 0 { # ans ++ # } # } # return ans
ans := make ([] string , 0 ) # # for i := 1 ; i <= n ; i ++ { # ans = append ( ans , number ( i )) # } # return ans
n := len ( nums ) # if n == 1 { return [] int { nums [ 0 ]} } # target := make ([] int , n ) # for i , val := range index { # for j := n - 1 ; j > val ; j -- { # target [ j ] = target [ j - 1 ] # } # target [ val ] = nums [ i ] # } # return target
for i := 0 ; i < n ; i ++ { # s += string ( s [ i ]) # } # return s [ n :]
result := 1 # for i := 0 ; i < len ( nums ) && nums [ i ] <= result ; i ++ { # result += nums [ i ] # } # return result
fmt . Println ( IsPalindrome (" STR ")) # fmt . Println ( IsPalindrome (" STR "))
cmpObj , repeatCount := nums [ 0 ], 1 # fillIdx := 0 # for idx := 1 ; idx < len ( nums ); idx ++ { # if nums [ idx ] == cmpObj { # repeatCount ++ # continue # } # # cmpObj = nums [ idx ] # # if repeatCount > 2 { # repeatCount = 2 # } # preObj := nums [ idx - 1 ] # for ; repeatCount > 0 ; repeatCount , fillIdx = repeatCount - 1 , fillIdx + 1 { # nums [ fillIdx ] = preObj # } # repeatCount = 1 # } # if repeatCount > 2 { # repeatCount = 2 # } # # preObj := nums [ len ( nums )- 1 ] # for ; repeatCount > 0 ; repeatCount , fillIdx = repeatCount - 1 , fillIdx + 1 { # nums [ fillIdx ] = preObj # } # # return fillIdx
h . heapIntArrays = h . heapIntArrays . Union (&( i .(* IntArray ). heapIntArrays )).( heapIntArrays ) # h . heap . BuildHeap () # return h
testcases [ 0 ]. largestBST = testcases [ 0 ]. tree . Left # testcases [ 1 ]. largestBST = testcases [ 1 ]. tree . Right # testcases [ 2 ]. largestBST = testcases [ 2 ]. tree
m := make ( map [ int ] int ) # m [ 0 ] = 1 # # var dfs func (* TreeNode , int ) int # dfs = func ( node * TreeNode , curSum int ) int { # if node == nil { # return 0 # } # curSum += node . Val # res := m [ curSum - sum ] # m [ curSum ]++ # res += dfs ( node . Left , curSum ) + dfs ( node . Right , curSum ) # m [ curSum ]-- # return res # } # return dfs ( root , 0 )
var dfs func (* TreeNode ) ( int , int ) # dfs = func ( node * TreeNode ) ( int , int ) { # if node == nil { # return 0 , 0 # } # lRob , lNotRob := dfs ( node . Left ) # rRob , rNotRob := dfs ( node . Right ) # return node . Val + lNotRob + rNotRob , max ( lRob , lNotRob ) + max ( rRob , rNotRob ) # } # return max ( dfs ( root ))
if len ( nums ) == 0 { # return 1 # } # # var arr = make ([] bool , len ( nums )+ 1 ) # var idx = 1 # for i := 0 ; i < len ( nums ); i ++ { # if nums [ i ] >= 0 && nums [ i ] < len ( arr ) { # arr [ nums [ i ]] = true # } # } # # for i := 1 ; i < len ( arr ); i ++ { # if arr [ i ] == false { # idx = i # break # } else { # idx = i + 1 # } # } # # return idx
t . Parallel () # b := createFilledBucket ( time . Now (). Add ( time . Duration ( 4 ))) # # done := make ( chan bool ) # worker := func () { # for i := 0 ; i < 1 0 0 0 0 ; i ++ { # b . Get ( randomString ( 2 )) # } # done <- true # } # workers := 4 # for i := 0 ; i < workers ; i ++ { # go worker () # } # for i := 0 ; i < workers ; i ++ { # _ = <- done # }
var h int # lo , hi := 0 , len ( citations ) # for lo <= hi { # mid := lo + ( hi - lo )/ 2 # # n := len ( citations ) - mid # if n > 0 && citations [ mid ] < n { # lo = mid + 1 # } else if mid > 0 && citations [ mid - 1 ] > n { # hi = mid - 1 # } else { # h = n # break # } # } # return h
tests := [...] testType { # { # in : [] int { 3 , 6 , 1 , 0 }, # want : 1 , # }, # { # in : [] int { 1 , 2 , 3 , 4 }, # want : - 1 , # }, # { # in : [] int { 1 }, # want : 0 , # }, # { # in : [] int { 0 , 0 , 3 , 2 }, # want : - 1 , # }, # { # in : [] int { 3 , 0 , 0 , 2 }, # want : - 1 , # }, # } # for _ , tt := range tests { # got := dominantIndex ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
keys := getKeys ( licensePlate ) # minLen := 1 << 6 3 - 1 # res := " STR " # # for _ , w := range words { # if len ( w ) >= minLen { # continue # } # # isCompleting := true # for k , c := range keys { # if strings . Count ( w , k ) < c { # isCompleting = false # break # } # } # # if isCompleting { # res = w # minLen = len ( w ) # } # } # # return res
if len ( nums ) <= 1 { # return len ( nums ) # } # # sort . Ints ( nums ) # # max , temp := 0 , 1 # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ]- 1 == nums [ i - 1 ] { # temp ++ # } else if nums [ i ] != nums [ i - 1 ] { # temp = 1 # } # if max < temp { # max = temp # } # } # # return max
taken := new ( maxPQ ) # heap . Init ( taken ) # # myCs := cs ( courses ) # sort . Sort ( myCs ) # # var date int # for _ , c := range myCs { # heap . Push ( taken , c [ 0 ]) # date += c [ 0 ] # for date > c [ 1 ] { # date -= heap . Pop ( taken ).( int ) # } # } # # return taken . Len ()
qs := [] question 2 4 2 { # # { # para 2 4 2 {" STR ", " STR "}, # ans 2 4 2 { true }, # }, # { # para 2 4 2 {" STR ", " STR "}, # ans 2 4 2 { false }, # }, # # { # para 2 4 2 {" STR ", " STR "}, # ans 2 4 2 { true }, # }, # # { # para 2 4 2 {" STR ", " STR "}, # ans 2 4 2 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 4 2 , q . para 2 4 2 # fmt . Printf (" STR ", p , isAnagram ( p . one , p . two )) # } # fmt . Printf (" STR ")
visited := make ([][] bool , len ( grid )) # for i := range visited { # visited [ i ] = make ([] bool , len ( grid [ i ])) # for j := range visited [ i ] { # if grid [ i ][ j ] != ' ' { # visited [ i ][ j ] = true # } # } # } # var regions int # for i := range visited { # for j := range visited [ i ] { # if ! visited [ i ][ j ] { # markRegion ( visited , i , j ) # regions ++ # } # } # } # return regions
month , year , days , sun := 1 , 1 9 0 0 , 1 , 0 # for { # switch month { # case 4 , 6 , 9 , 1 1 : # days += 3 0 # case 1 , 3 , 5 , 7 , 8 , 1 0 , 1 2 : # days += 3 1 # case 2 : # if year % 4 == 0 && year % 1 0 0 != 0 { # days += 2 9 # } else { # days += 2 8 # } # } # # if month == 1 2 { # month = 1 # year ++ # } else { # month ++ # } # # if year >= 1 9 0 1 && year <= 2 0 0 0 { # if days % 7 == 0 { # sun ++ # } # } # # if year >= 2 0 0 1 { # break # } # } # return sun
qs := [] question 8 3 8 { # # { # para 8 3 8 {" STR "}, # ans 8 3 8 {" STR "}, # }, # # { # para 8 3 8 {" STR "}, # ans 8 3 8 {" STR "}, # }, # # { # para 8 3 8 {" STR "}, # ans 8 3 8 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 3 8 , q . para 8 3 8 # fmt . Printf (" STR ", p , pushDominoes ( p . one )) # } # fmt . Printf (" STR ")
p , q := 0 , len ( height )- 1 # var ret int # var tmp int # for p < q { # if height [ p ] < height [ q ] { # tmp = height [ p ] * ( q - p ) # p ++ # } else { # tmp = height [ q ] * ( q - p ) # q -- # } # if ret < tmp { # ret = tmp # } # } # return ret
m := make ( map [ int ] int , len ( nums )) # for i , v := range nums { # if p , ok := m [ v ]; ok && i - p <= k { # return true # } # m [ v ] = i # } # return false
res := make ([] Point , len ( points )) # for i , p := range points { # res [ i ] = Point { # X : p [ 0 ], # Y : p [ 1 ], # } # } # return res
for a := ( perimeter - 2 ); a > 2 ; a -- { # for b := ( perimeter - a - 1 ); b > 1 ; b -- { # c := perimeter - a - b # if b > c && a * a == b * b + c * c { # solution = append ( solution , Triangle { a , b , c }) # } # } # } # return
starttime := time . Now () # # top := 1 0 0 # sum := 0 # squaresum := 0 # # for i := 1 ; i <= top ; i ++ { # sum += i # squaresum += i * i # } # # fmt . Println ( sum * sum - squaresum ) # # fmt . Println (" STR ", time . Since ( starttime ))
res := [] string {} # gen ( n , n , " STR ", & res ) # return res
sum := 0 # for K > 0 { # small := 0 # for i := 0 ; i < len ( A ); i ++ { # if A [ i ] < A [ small ] { # small = i # } # } # A [ small ] = A [ small ] * - 1 # K -- # } # for _ , v := range A { # sum += v # } # return sum
low , high := 1 , m * n # for low < high { # mid := low + ( high - low )>> 1 # if counterKthNum ( m , n , mid ) >= k { # high = mid # } else { # low = mid + 1 # } # } # return low
goal := 1 0 0 0 0 0 0 # digits := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } # # var permutationGap int # millionth := " STR " # # for len ( digits ) > 0 { # permutationGap = Factorial ( len ( digits )) / len ( digits ) # for i := 0 ; ; i ++ { # if goal < ( i * permutationGap )+ permutationGap { # millionth += strconv . Itoa ( digits [ i ]) # digits = append ( digits [: i ], digits [ i + 1 :]...) # goal -= i * permutationGap # break # } # } # } # fmt . Println ( millionth )
runes := [] rune ( s ) # for i , j := 0 , len ( runes )- 1 ; i < j ; i , j = i + 1 , j - 1 { # runes [ i ], runes [ j ] = runes [ j ], runes [ i ] # } # # r := string ( runes ) # i := len ( s ) - 1 # for ; i >= 0 && string ( s [: i + 1 ]) != string ( r [ len ( s )- 1 - i :]); i -- { # } # # return string ( r [: len ( s )- i - 1 ]) + s
nodeLevel := level ( root , node , 1 ) # return levelCousins ( root , node , nodeLevel , [] int {})
n := node .(* gbtElement ) # for curNode := t . Min ( n ).(* gbtElement ); ! t . IsNil ( curNode ); { # stop := callback ( t . Object , curNode ) # if stop { # return true # } # curNode = t . Successor ( curNode , n ).(* gbtElement ) # } # return false
dp := make ([] int , K + 1 ) # res := 0 # for dp [ K ] < N { # for i := K ; i > 0 ; i -- { # dp [ i ] += dp [ i - 1 ] + 1 # } # res ++ # } # return res
var iter int 6 4 = 1 # for s > 1 { # if s % 2 == 0 { # s /= 2 # } else { # s = 3 * s + 1 # } # iter ++ # } # return iter
left := len ( nums ) - 2 # if left < 0 { # return # } # for 0 < left && nums [ left ] >= nums [ left + 1 ] { # left -- # } # # right := len ( nums ) - 1 # for left < right && nums [ left ] >= nums [ right ] { # right -- # } # if left != right { # nums [ left ], nums [ right ] = nums [ right ], nums [ left ] # left ++ # } # right = len ( nums ) - 1 # for left < right { # nums [ left ], nums [ right ] = nums [ right ], nums [ left ] # left ++ # right -- # }
res , base := 0 , 1 # for n > 0 { # res += n % 9 * base # base *= 1 0 # n /= 9 # } # return res
tests := [...] testType { # { # in : [] int { 1 , 7 , 3 , 6 , 5 , 6 }, # want : 3 , # }, # { # in : [] int { 1 , 2 , 3 }, # want : - 1 , # }, # { # in : [] int { 0 }, # want : 0 , # }, # { # in : [] int { 0 , 0 }, # want : 0 , # }, # { # in : [] int { 1 , 2 , 1 }, # want : 1 , # }, # { # in : [] int {}, # want : - 1 , # }, # } # for _ , tt := range tests { # got := pivotIndex ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
return pc . c . Gets ( cmd , keys ...)
if len ( nums ) == 0 { # return 0 # } # if len ( nums ) == 1 { # return nums [ 0 ] # } # dp , res := make ([] int , len ( nums )), nums [ 0 ] # dp [ 0 ] = nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # if dp [ i - 1 ] > 0 { # dp [ i ] = nums [ i ] + dp [ i - 1 ] # } else { # dp [ i ] = nums [ i ] # } # res = max ( res , dp [ i ]) # } # return res
var elem , count int # for i := range nums { # if count == 0 { # count ++ # elem = nums [ i ] # } else { # if nums [ i ] != elem { # count -- # } else { # count ++ # } # } # } # return elem
fmt . Printf ("< svg xmlns =' http : + " STR "+ # " STR ", width , height ) # for i := 0 ; i < cells ; i ++ { # for j := 0 ; j < cells ; j ++ { # ax , ay := corner ( i + 1 , j ) # bx , by := corner ( i , j ) # cx , cy := corner ( i , j + 1 ) # dx , dy := corner ( i + 1 , j + 1 ) # fmt . Printf (" STR ", # ax , ay , bx , by , cx , cy , dx , dy ) # } # } # fmt . Println (" STR ")
fmt . Println ( majorityElement ([] int { 6 , 5 , 5 }))
if len ( A ) == 0 || len ( A )% 2 != 0 { # return [] int {} # } # res := make ([] int , len ( A )) # oddIndex := 1 # evenIndex := 0 # for i := 0 ; i < len ( A ); i ++ { # if A [ i ]% 2 == 0 { # res [ evenIndex ] = A [ i ] # evenIndex += 2 # } else { # res [ oddIndex ] = A [ i ] # oddIndex += 2 # } # } # return res
_rand := rand . New ( rand . NewSource ( 1 )) # board := make ([][] int , size , size ) # for i := range board { # board [ i ] = make ([] int , size , size ) # for j := range board [ i ] { # board [ i ][ j ] = _rand . Intn ( 2 0 ) - 1 0 # } # } # return board
tests := [...] testType { # { # in : 2 , # want : [] int { 1 , 2 , 1 }, # }, # { # in : 3 , # want : [] int { 1 , 3 , 3 , 1 }, # }, # { # in : 5 , # want : [] int { 1 , 5 , 1 0 , 1 0 , 5 , 1 }, # }, # } # for _ , tt := range tests { # got := getRow ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
for i := len ( nums ) - 2 ; i >= 0 ; i -- { # if nums [ i ] != 0 { # continue # } # # j := i - 1 # for ; j >= 0 ; j -- { # if i - j < nums [ j ] { # i = j # break # } # } # # if j == - 1 { # return false # } # } # # return true
ret := make ([] int , rowIndex + 1 ) # for k := range ret { # ret [ k ] = 1 # } # for i := 0 ; i < rowIndex - 1 ; i ++ { # for j := i + 1 ; j >= 1 ; j -- { # ret [ j ] = ret [ j ] + ret [ j - 1 ] # } # } # return ret
expected := " STR " # variable := & Variable { # Type : TypeInt , # Value : 4 2 , # } # # actual := variable . String () # # if actual != expected { # t . Fatalf (" STR ", # expected , actual ) # }
var tests = [] struct { # colors [] int # sortedColors [] int # }{ # {[] int { 2 , 0 , 1 }, [] int { 0 , 1 , 2 }}, # {[] int { 2 , 0 , 2 , 1 , 1 , 0 }, [] int { 0 , 0 , 1 , 1 , 2 , 2 }}, # } # # for _ , tt := range tests { # colors := make ([] int , len ( tt . colors )) # copy ( colors , tt . colors ) # # sortColors ( tt . colors ) # if reflect . DeepEqual ( tt . colors , tt . sortedColors ) == false { # t . Errorf (" STR ", colors , tt . colors , tt . sortedColors ) # } # }
s . stack = nil
m := make ( map [ int ] bool ) # for n != 1 && ! m [ n ] { # m [ n ] = true # sum := 0 # for n > 0 { # x := n % 1 0 # sum += x * x # n /= 1 0 # } # n = sum # } # return n == 1
type A struct { # Name string # Value string ` structs :" STR "` # Time time . Time ` structs :" STR "` # } # a := A {} # # m := Map ( a ) # # _ , ok := m [" STR "].( map [ string ] interface {}) # if ok { # t . Error (" STR ") # } # # _ , ok = m [" STR "].( map [ string ] interface {}) # if ok { # t . Error (" STR ") # }
max , c := 0 , 0 # for i := 0 ; i < len ( nums ); i ++ { # c = nums [ i ]* c + nums [ i ] # if c > max { # max = c # } # } # return max
m , n := len ( word 1 ), len ( word 2 ) # # dp := [][] int {} # for i := 0 ; i <= m ; i ++ { # dp = append ( dp , make ([] int , n + 1 )) # } # # for i := 1 ; i <= m ; i ++ { # dp [ i ][ 0 ] = i # } # for i := 1 ; i <= n ; i ++ { # dp [ 0 ][ i ] = i # } # # for i := 1 ; i <= m ; i ++ { # for j := 1 ; j <= n ; j ++ { # if word 1 [ i - 1 ] == word 2 [ j - 1 ] { # dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] # } else { # dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ], min ( dp [ i ][ j - 1 ], dp [ i - 1 ][ j ])) + 1 # # } # } # } # # return dp [ m ][ n ]
runes := [] rune ( str ) # i , j := 0 , len ( str ) - 1 # for j > i { # if runes [ i ] != runes [ j ] { # return false # } # i ++ # j -- # } # return true
n := len ( temperatures ) # res := make ([] int , n ) # # stack := make ([] int , n ) # # top := - 1 # for i := 0 ; i < n ; i ++ { # for top >= 0 && temperatures [ stack [ top ]] < temperatures [ i ] { # res [ stack [ top ]] = i - stack [ top ] # top -- # } # # top ++ # stack [ top ] = i # } # # return res
degreeArray := make ([]* FibHeapElement , h . Degree ()+ 1 , h . Degree ()+ 1 ) # for i , e := h . root . Len (), h . root . Leftist (); i > 0 ; i = i - 1 { # nextE := e . right () # for e 1 := degreeArray [ e . degree ()]; e 1 != nil && e . degree () < h . Degree (); e 1 = degreeArray [ e . degree ()] { # degreeArray [ e . degree ()] = nil # if h . less ( e 1 , e ) { # e , e 1 = e 1 , e # } # e 1 . mark = false # h . root . Remove ( e 1 ) # e . c . PushRight ( e 1 ) # } # degreeArray [ e . degree ()] = e # e = nextE # } # h . min = nil # h . root = newFabHeapElementList ( nil ) # for i := range degreeArray { # if degreeArray [ i ] != nil { # h . root . PushRight ( degreeArray [ i ]) # if h . less ( degreeArray [ i ], h . min ) { # h . min = degreeArray [ i ] # } # } # }
testDatas := [] int { 0 , 1 , 2 , 3 , 3 4 } # expected := [] int { 1 , 1 , 2 , 3 , 9 2 2 7 4 6 5 } # # for i , data := range testDatas { # if steps := climbStairs ( data ); steps != expected [ i ] { # t . Errorf (" STR ", expected [ i ], steps ) # } # }
ints := make ([] bool , n ) # # primes := make ([] uint 6 4 , 0 , n / 4 ) # primes = append ( primes , 2 ) # # var i , j uint 6 4 # # for i = 3 ; i < n ; i += 2 { # if ! ints [ i ] { # primes = append ( primes , i ) # for j = i ; j < n ; j += i { # ints [ j ] = true # } # } # } # # return primes
res , p := make ([] int , len ( queries )), make ([] int , m ) # for i := 0 ; i < m ; i ++ { # p [ i ] = i + 1 # } # for idx , q := range queries { # pos := - 1 # for i , v := range p { # if v == q { # pos = i # break # } # } # res [ idx ] = pos # for i := pos ; i > 0 ; i -- { # p [ i ] = p [ i - 1 ] # } # p [ 0 ] = q # } # return res
i := 0 # tmp := 0 # # for i = len ( arr ) / 2 - 1 ; i >= 0 ; i -- { # arr = sift ( arr , i , len ( arr )) # } # # for i = len ( arr ) - 1 ; i >= 1 ; i -- { # tmp = arr [ 0 ]; # arr [ 0 ] = arr [ i ]; # arr [ i ] = tmp ; # arr = sift ( arr , 0 , i ); # }
var tests = [] struct { # nums [] int # k int # t int # duplicate bool # }{ # {[] int {- 1 , - 1 }, 1 , - 1 , false }, # {[] int {- 3 , 3 }, 2 , 4 , false }, # {[] int { 2 , 1 }, 1 , 1 , true }, # {[] int { 1 , 2 , 3 , 1 }, 3 , 0 , true }, # {[] int { 1 , 0 , 1 , 1 }, 1 , 2 , true }, # {[] int { 1 , 5 , 9 , 1 , 5 , 9 }, 2 , 3 , false }, # } # # for _ , tt := range tests { # duplicate := containsNearbyAlmostDuplicate ( tt . nums , tt . k , tt . t ) # if duplicate != tt . duplicate { # t . Errorf (" STR ", tt . nums , tt . k , tt . t , duplicate , tt . duplicate ) # } # }
if root == nil { # return & TreeNode { # Val : val , # } # } # if val > root . Val { # root . Right = insertIntoBST ( root . Right , val ) # } else { # root . Left = insertIntoBST ( root . Left , val ) # } # return root #
if k < 0 { # return 0 # } # # m := map [ int ] int {} # for _ , num := range nums { # m [ num ]++ # } # # res := 0 # if k == 0 { # for _ , count := range m { # if count > 1 { # res ++ # } # } # } else { # for num := range m { # if m [ num - k ] > 0 { # res ++ # } # } # } # # return res
res := 0 # n := len ( time ) # if n == 0 { # return 0 # } # # for i := 0 ; i + 1 < n ; i ++ { # res += min ( duration , time [ i + 1 ]- time [ i ]) # } # # return res + duration
for a != nil && b != nil { # if a . Value != b . Value { # return false # } # a = a . Next # b = b . Next # } # return a == nil && b == nil
if n <= 0 { # return head # } # dummy := & ListNode {} # dummy . Next = head # # var ( # p = dummy # q = dummy # ) # # for i := 0 ; i < n ; i ++ { # q = q . Next # } # # for q . Next != nil { # p = p . Next # q = q . Next # } # # p . Next = p . Next . Next # return dummy . Next
const maxInt = 0 x 7 fffffff # delay := make ([] int , N + 1 ) # for i := range delay { # delay [ i ] = maxInt # } # # delay [ K ] = 0 # for i := 0 ; i < N - 1 ; i ++ { # for _ , t := range times { # if delay [ t [ 0 ]] < maxInt && delay [ t [ 1 ]] > delay [ t [ 0 ]]+ t [ 2 ] { # delay [ t [ 1 ]] = delay [ t [ 0 ]] + t [ 2 ] # } # } # } # # result := 0 # for i := 1 ; i < len ( delay ); i ++ { # if delay [ i ] == maxInt { # return - 1 # } # # if delay [ i ] > result { # result = delay [ i ] # } # } # # return result
sum := 0 # # for n := 1 ; n < 2 8 1 2 4 ; n ++ { # if ! sumOfAbundants ( n ) { # sum += n # } # # if isAbundant ( n ) { # abundantNumbers [ n ] = struct {}{} # } # } # # fmt . Println ( sum )
variableAccess , ok := n . Target .(* VariableAccess ) # if ! ok { # return TypeInvalid , fmt . Errorf (" STR ") # } # # variable , ok := s . LookupVar ( variableAccess . Name ) # if ! ok { # return TypeInvalid , fmt . Errorf (" STR ", variableAccess . Name ) # } # # switch variable . Type { # case TypeList : # return n . typeList ( variable , variableAccess . Name ) # case TypeMap : # return n . typeMap ( variable , variableAccess . Name ) # default : # return TypeInvalid , fmt . Errorf (" STR ", variable . Type ) # }
point := func ( t int ) int { # if t < lower { # return - 1 # } # if t > upper { # return 1 # } # return 0 # } # # T := 0 # res := 0 # for i , c := range calories { # T += c # if i < k - 1 { # continue # } # if i - k >= 0 { # T -= calories [ i - k ] # } # res += point ( T ) # } # # return res
for i , r := range base 6 4 { # b 6 4 pos [ r ] = i # posb 6 4 [ i ] = r # }
t . Parallel () # for _ , tc := range testcases { # r = rand . New ( rand . NewSource ( 4 2 )) # if median := ApproximateMedian ( tc . unordered ); median != tc . approxMedian { # t . Errorf (" STR ", tc . approxMedian , median ) # } # }
var count int # for i := 0 ; i < n ; i ++ { # for j := 0 ; j < n ; j ++ { # board := make ([][] bool , n ) # for x := range board { # board [ x ] = make ([] bool , n ) # } # board [ i ][ j ] = true # count += knightsTourCounter ( n , board , [][] int {{ i , j }}) # } # } # return count
if a == b { # return - 1 # } # return max ( len ( a ), len ( b ))
if i > j { # return nil # } # node := & Node { # i : i , # j : j , # } # if i == j { # node . sum = nums [ i ] # } else { # m := ( i + j ) / 2 # node . l = buildTree ( nums , i , m ) # node . r = buildTree ( nums , m + 1 , j ) # node . sum = node . l . sum + node . r . sum # } # return node
lastLen := 0 # copied := make ([] rune , len ( input )) # copy ( copied , input ) # # for len ( copied ) != lastLen { # lastLen = len ( copied ) # copied = minimizeQux ( copied ) # } # # return copied
if len ( nums ) == 0 || len ( nums ) < k { # return make ([] int , 0 ) # } # ans := [] int {} # for i := 0 ; i < len ( nums )- k + 1 ; i ++ { # tmp := nums [ i ] # for j := i + 1 ; j < i + k ; j ++ { # if tmp < nums [ j ] { # tmp = nums [ j ] # } # } # ans = append ( ans , tmp ) # } # return ans
if len ( nums ) == 0 { # return [][] int {} # } # used , p , res := make ([] bool , len ( nums )), [] int {}, [][] int {} # sort . Ints ( nums ) # generatePermutation 4 7 ( nums , 0 , p , & res , & used ) # return res
type A struct { # Name string # } # a := & A { Name : " STR "} # # type B struct { # A * A # } # b := & B { A : a } # # m := Map ( b ) # # if typ := reflect . TypeOf ( m ). Kind (); typ != reflect . Map { # t . Errorf (" STR ", typ ) # } # # in , ok := m [" STR "].( map [ string ] interface {}) # if ! ok { # t . Error (" STR ") # } # # if name := in [" STR "].( string ); name != " STR " { # t . Errorf (" STR ", name ) # }
b := [] byte ( s ) # for i := 0 ; i < len ( b ); i += k + k { # r := i + k - 1 # if r >= len ( b ) { # r = len ( b ) - 1 # } # # for l := i ; l < r ; l , r = l + 1 , r - 1 { # b [ l ], b [ r ] = b [ r ], b [ l ] # } # } # return string ( b )
var tests = [] struct { # S string # s [] string # }{ # {" STR ", [] string {" STR ", " STR ", " STR ", " STR "}}, # {" STR ", [] string {" STR ", " STR "}}, # {" STR ", [] string {" STR ", " STR "}}, # {" STR ", [] string {" STR "}}, # } # # for _ , tt := range tests { # s := letterCasePermutation ( tt . S ) # if reflect . DeepEqual ( s , tt . s ) == false { # t . Errorf (" STR ", tt . S , s , tt . s ) # } # }
if len ( nums ) == 0 { # return false # } # step := nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # if step > 0 { # step -- # step = max ( step , nums [ i ]) # } else { # return false # } # } # return true
rand . Seed ( time . Now (). UTC (). UnixNano ()) # # for i := len ( a ) - 1 ; i > 0 ; i -- { # j := rand . Intn ( i + 1 ) # a [ i ], a [ j ] = a [ j ], a [ i ] # } # # return a
t . Parallel () # for _ , tc := range testcases { # if result := ReverseWordsMaintainDelimters ( tc . input ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
var max int # cnt := make ( map [ int ] int ) # # var f func (* TreeNode ) int # f = func ( root * TreeNode ) int { # if root == nil { # return 0 # } # # sum := root . Val # sum += f ( root . Left ) # sum += f ( root . Right ) # # cnt [ sum ]++ # if cnt [ sum ] > max { # max = cnt [ sum ] # } # # return sum # } # f ( root ) # # var sums [] int # for sum , c := range cnt { # if c == max { # sums = append ( sums , sum ) # } # } # # return sums
cases := [] struct { # name string # inputs [][] int # expect float 6 4 # }{ # {" STR ", [][] int {{ 1 , 3 }, { 2 }}, 2 . 0 }, # {" STR ", [][] int {{ 1 , 2 }, { 3 , 4 }}, 2 . 5 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := findMedianSortedArrays ( c . inputs [ 0 ], c . inputs [ 1 ]) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
left := 0 # right := len ( nums ) - 1 # for left <= right { # mid := ( left + right ) / 2 # if nums [ mid ] == target { # return mid # } else if nums [ mid ] > target { # right = mid - 1 # } else { # left = mid + 1 # } # } # return left
max := int 6 4 ( math . Ceil ( math . Sqrt ( float 6 4 ( n )))) # var i int 6 4 # for i = 2 ; i <= max ; i ++ { # if n % i == 0 { # return false # } # } # return true
if n == 0 { # return 0 # } else if n == 1 { # return 1 # } else { # return fib ( n - 1 ) + fib ( n - 2 ) # }
if m == 0 || n == 0 { # return 0 # } # matrix := make ([][] int , n ) # for y := range matrix { # matrix [ y ] = make ([] int , m ) # matrix [ y ][ 0 ] = 1 # } # for x := range matrix [ 0 ] { # matrix [ 0 ][ x ] = 1 # } # for y := 1 ; y < n ; y ++ { # for x := 1 ; x < m ; x ++ { # matrix [ y ][ x ] = matrix [ y ][ x - 1 ] + matrix [ y - 1 ][ x ] # } # } # return matrix [ n - 1 ][ m - 1 ]
dayCount := make ([] int , 1 3 ) # for i := range dayCount { # switch i { # case 9 , 4 , 6 , 1 1 : # dayCount [ i ] = 3 0 # case 2 : # dayCount [ i ] = 2 8 # default : # dayCount [ i ] = 3 1 # } # } # # getDayCount := func ( year , month int ) int { # ret := dayCount [ month ] # # if month == 2 && year % 4 == 0 && ( year % 1 0 0 > 0 || year % 4 0 0 == 0 ) { # ret ++ # } # # return ret # } # # weekDay := 1 # count := 0 # # for year := 1 9 0 0 ; year <= 2 0 0 0 ; year ++ { # for month := 1 ; month <= 1 2 ; month ++ { # if year > 1 9 0 0 && weekDay == 0 { # count ++ # } # # weekDay += getDayCount ( year , month ) # weekDay %= 7 # } # } # # fmt . Println ( count )
defer TimeTaken ( time . Now (), " STR ") # max := 0 # start_index := 0 # # for i := 0 ; i < len ( num )- 1 3 ; i ++ { # check , index := Multi ( i ) # # switch { # case check > max : # max = check # start_index = i # case check == 0 : # i = index # } # } # fmt . Println ( max , " STR ", start_index )
t . Parallel () # # for _ , tc := range testcases { # if result := TransitiveClosure ( tc . g ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
sl := len ( s ) # # num := byteToInt ( s [ 0 ]) # pre := num # for i := 1 ; i < sl ; i ++ { # now := byteToInt ( s [ i ]) # # num += now # if pre < now { # num -= 2 * pre # } # # pre = now # } # return num
for cl . Delete () { # continue # }
if len ( triangle ) == 0 || len ( triangle [ 0 ]) == 0 { # return 0 # } # for i := len ( triangle ) - 2 ; i >= 0 ; i -- { # for j := len ( triangle [ i ]) - 1 ; j >= 0 ; j -- { # minSum := min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]) # minSum += triangle [ i ][ j ] # triangle [ i ][ j ] = minSum # } # } # return triangle [ 0 ][ 0 ]
var sum float 6 4 # for _ , v := range k . Matrix { # sum += math . Abs ( v ) # } # return sum
switch verb { # case " STR ", " STR ": # switch arg .( type ) { # case int : # return true # } # } # return false
tests := [...] testType { # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := toGoatLatin ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if 0 == len ( preorder ) { # return nil # } # # val := preorder [ 0 ] # preorder = preorder [ 1 :] # i := 0 # for i < len ( preorder ) && preorder [ i ] < val { # i ++ # } # return & TreeNode { # val , # bstFromPreorder ( preorder [: i ]), # bstFromPreorder ( preorder [ i :]), # }
num := 1 # for i := 0 ; i < n ; i ++ { # num = num * ( 4 * i + 2 ) / ( i + 2 ) # } # return num
qs := [] question 6 4 5 { # # { # para 6 4 5 {[] int { 1 , 2 , 2 , 4 }}, # ans 6 4 5 {[] int { 2 , 3 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 4 5 , q . para 6 4 5 # fmt . Printf (" STR ", p , findErrorNums ( p . one )) # } # fmt . Printf (" STR ")
cases := [] struct { # name string # inputs []* ListNode # expect * ListNode # }{ # {" STR ", # []* ListNode { # UnmarshalListBySlice ([] int { 1 , 4 , 5 }), # UnmarshalListBySlice ([] int { 1 , 3 , 4 }), # UnmarshalListBySlice ([] int { 2 , 6 }), # }, # UnmarshalListBySlice ([] int { 1 , 1 , 2 , 3 , 4 , 4 , 5 , 6 })}, # } # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := mergeKLists 4 ( c . inputs ) # if ! isEqual ( got , c . expect ) { # PrintList ( got ) # PrintList ( c . expect ) # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
m := map [ int ] int {} # for i := range inorder { # m [ inorder [ i ]] = i # } # return helper ( preorder , 0 , len ( preorder )- 1 , inorder , 0 , len ( inorder )- 1 , m )
return strings . ToUpper ( s )
strings () # int 6 4 s () # int 3 2 s () # int 1 6 s () # int 8 s () # ints () # structs ()
x , y := click [ 0 ], click [ 1 ] # # if board [ x ][ y ] == ' M ' { # board [ x ][ y ] = ' X ' # return board # } # # return bfs ( board , x , y )
if n := len ( nums ); n == 0 { # return 0 , 0 # } else if n == 1 { # return nums [ 0 ], nums [ 0 ] # } # # set := make ( map [ int ] struct {}, len ( nums )) # # for _ , num := range nums { # set [ num ] = struct {}{} # } # # var longest , sAns , eAns int # # for start := range set { # count := 1 # ptr := start + 1 # # for _ , found := set [ ptr ]; found ; _ , found = set [ ptr ] { # count ++ # ptr ++ # } # # if count > longest || ( count == longest && start < sAns ) { # longest = count # sAns = start # eAns = ptr - 1 # } # } # # return sAns , eAns
if nil == head || nil == head . Next { # return head # } # # prePtr := head # currentPtr := head . Next # lastValue := prePtr . Val # # for nil != currentPtr { # if currentPtr . Val != lastValue { # lastValue = currentPtr . Val # prePtr = currentPtr # currentPtr = currentPtr . Next # } else { # prePtr . Next = currentPtr . Next # currentPtr = currentPtr . Next # } # } # return head
fmt . Println ( longestCommonPrefix ([] string {" STR ", " STR ", " STR "})) # fmt . Println ( longestCommonPrefix ([] string {" STR ", " STR ", " STR "}))
for { # h := sha 1 . New () # written , err := io . CopyN ( h , r , pieceLength ) # if written > 0 { # b = h . Sum ( b ) # } # if err == io . EOF { # return b , nil # } # if err != nil { # return b , err # } # }
mod := 1 0 0 0 0 0 0 0 0 7 # m := [ 1 0 1 ] int {} # for _ , a := range A { # m [ a ]++ # } # res := 0 # for i := 0 ; i < 1 0 1 ; i ++ { # for j := i ; j < 1 0 1 ; j ++ { # k := target - i - j # if k > 1 0 0 || k < 0 { # continue # } # if i == j && j == k { # res += m [ i ] * ( m [ i ] - 1 ) * ( m [ i ] - 2 ) / 6 # } else if i == j { # res += m [ i ] * ( m [ i ] - 1 ) / 2 * m [ k ] # } else if j < k { # res += m [ i ] * m [ j ] * m [ k ] # } # } # } # return res % mod
if len ( parts ) == 0 || len ( lens ) == 0 { # return false # } # # if len ( parts ) != len ( lens ) { # return false # } # # test := parts [ 0 ] # for i := 1 ; i < len ( parts ); i ++ { # test = CRC 3 2 Combine ( crc 3 2 . Castagnoli , test , parts [ i ], lens [ i ]) # } # # if test != correct { # return false # } # # return true
var base = 0 # var exp = 1 # var lastChar byte # for i := 0 ; i < len ( S ); i ++ { # if S [ i ] >= ' a ' && S [ i ] <= ' z ' { # base = base * exp + 1 # exp = 1 # lastChar = S [ i ] # } # if S [ i ] >= ' 0 ' && S [ i ] <= ' 9 ' { # exp = ( int ( S [ i ]) - int (' 0 ')) * exp # } # if base * exp == K || ( base * exp > K && K % base == 0 ) { # return string ([] byte { lastChar }) # } # # if base * exp > K { # return decodeAtIndex ( S , K %( base )) # } # } # return " STR "
fmt . Println ( isValid (" STR ")) # fmt . Println ( isValid (" STR "))
valueToPos := make ( map [ int ] int ) # var longest int # for i , v := range nums { # if pos , found := valueToPos [ v ]; found { # if l := len ( valueToPos ); l > longest { # longest = l # } # for val , p := range valueToPos { # if p <= pos { # delete ( valueToPos , val ) # } # } # } # valueToPos [ v ] = i # # } # if l := len ( valueToPos ); l > longest { # longest = l # } # return longest
m , n := len ( s ), len ( t ) # # dp := make ([] int , m + 1 ) # for i := 0 ; i < m + 1 ; i ++ { # dp [ i ] = 1 # } # # var prev int # # for j := 0 ; j < n ; j ++ { # dp [ j ], prev = 0 , dp [ j ] # # for i := j + 1 ; i < m + 1 ; i ++ { # if t [ j ] == s [ i - 1 ] { # dp [ i ], prev = dp [ i - 1 ]+ prev , dp [ i ] # } else { # dp [ i ], prev = dp [ i - 1 ], dp [ i ] # } # } # } # # return dp [ m ]
var dfs func (* TreeNode , int ) int # dfs = func ( node * TreeNode , first int ) int { # if node == nil { # return - 1 # } # if node . Val != first { # return node . Val # } # l , r := dfs ( node . Left , first ), dfs ( node . Right , first ) # if l == - 1 { # return r # } # if r == - 1 { # return l # } # return min ( l , r ) # } # return dfs ( root , root . Val )
fmt . Println ( transpose ([][] int {{ 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 }})) # fmt . Println ( transpose ([][] int {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}))
first := head # for first != nil && first . Next != nil { # second := first . Next # if first . Val == second . Val { # first . Next = second . Next # second . Next = nil # } else { # first = first . Next # } # } # return head
nums := [] int { 1 , 1 2 , - 5 , - 6 , 5 0 , 3 } # # fmt . Println ( findMaxAverage ( nums , 4 )) # # nums 2 := [] int {- 1 } # fmt . Println ( findMaxAverage ( nums 2 , 1 )) #
tests := [...] testType { # { # x : 1 , # y : 4 , # want : 2 , # }, # } # for _ , tt := range tests { # got := hammingDistance ( tt . x , tt . y ) # if got != tt . want { # t . Fatalf (" STR ", tt . x , tt . y , got , tt . want ) # } # }
left , right := 0 , len ( nums )- 1 # for left <= right { # if left == right { # return left # } # mid := left + ( right - left )/ 2 # if nums [ mid ] < nums [ mid + 1 ] { # left = mid + 1 # } else { # right = mid # } # } # return - 1
lru := LRUCache { # Capacity : capacity , # Data : list . New (), # } # return lru
n . notify ()
strs := [] byte ( arr ) # # i , j := 0 , 0 # for i = 1 ; i < len ( strs ); i ++ { # tmp := strs [ i ] # for j = i ; j > 0 && strs [ j - 1 ] > tmp ; j -- { # strs [ j ] = strs [ j - 1 ] # } # strs [ j ] = tmp # } # # return string ( strs )
if len ( input ) != len ( permutation ) { # panic (" STR ") # } # # passed := make ( map [ int ] interface {}, len ( input )) # # for i , pos := range permutation { # if pos < i { # input [ i ] = passed [ pos ] # } else { # passed [ i ] = input [ i ] # input [ i ] = input [ pos ] # } # }
parent := this # for _ , ch := range word { # if child , ok := parent . Children [ ch ]; ok { # parent = child # } else { # newChild := & Trie { IsTerminated : false , Children : make ( map [ rune ]* Trie )} # parent . Children [ ch ] = newChild # parent = newChild # } # } # parent . IsTerminated = true
if s . top == 0 { # return 0 , false # } # i := s . data [ s . top - 1 ] # s . top -= 1 # return i , true
var head = list 1 # b = b - a + 2 # for 1 < a { # list 1 = list 1 . Next # a -- # } # leftTail := list 1 # # for 0 < b { # list 1 = list 1 . Next # b -- # } # rightHead := list 1 # # leftTail . Next = list 2 # for list 2 . Next != nil { # list 2 = list 2 . Next # } # list 2 . Next = rightHead # return head
fmt . Println ( addBinary (" STR ", " STR ")) # fmt . Println ( addBinary (" STR ", " STR "))
n := len ( A ) # bindex := make ([][ 2 ] int , n ) # for i , b := range B { # bindex [ i ][ 0 ], bindex [ i ][ 1 ] = b , i # } # sort . Slice ( bindex , func ( i , j int ) bool { # return bindex [ i ][ 0 ] < bindex [ j ][ 0 ] # }) # sort . Ints ( A ) # l , r := 0 , n - 1 # res := make ([] int , n ) # for _ , a := range A { # if bindex [ l ][ 0 ] < a { # res [ bindex [ l ][ 1 ]] = a # l ++ # } else { # res [ bindex [ r ][ 1 ]] = a # r -- # } # } # return res
if a < 0 { return - a } # return a
node 7 := ListNode { value : 7 , next : nil } # node 6 := ListNode { value : 6 , next : & node 7 } # node 5 := ListNode { value : 5 , next : & node 6 } # node 4 := ListNode { value : 4 , next : & node 5 } # node 3 := ListNode { value : 3 , next : & node 6 } # node 2 := ListNode { value : 2 , next : & node 3 } # node 1 := ListNode { value : 1 , next : & node 2 } # # fmt . Println ( findFirstCommonNode (& node 1 , & node 4 ). value ) #
counts := make ( map [ rune ] int ) # var utflen [ utf 8 . UTFMax + 1 ] int # invalid := 0 # # in := bufio . NewReader ( os . Stdin ) # for { # r , n , err := in . ReadRune () # if err == io . EOF { # break # } # if err != nil { # fmt . Fprintf ( os . Stderr , " STR ", err ) # os . Exit ( 1 ) # } # if r == unicode . ReplacementChar && n == 1 { # invalid ++ # continue # } # counts [ r ]++ # utflen [ n ]++ # } # fmt . Printf (" STR ") # for c , n := range counts { # fmt . Printf (" STR ", c , n ) # } # fmt . Print (" STR ") # for i , n := range utflen { # if i > 0 { # fmt . Printf (" STR ", i , n ) # } # } # if invalid > 0 { # fmt . Printf (" STR ", invalid ) # }
this . queue . PushBack ( value ) # # for this . deque . Len () > 0 && this . deque . Back (). Value .( int ) < value { # this . deque . Remove ( this . deque . Back ()) # } # this . deque . PushBack ( value )
if n . Value < m . Value { # return - 1 # } else if n . Value > m . Value { # return 1 # } else { # return 0 # }
return helper 7 8 4 ( S , 0 , make ([] byte , 0 ), make ([] string , 0 ))
type Server struct { # Name string # ID int 3 2 # Enabled bool # } # # s := & Server { # Name : " STR ", # ID : 1 2 3 4 5 6 , # Enabled : true , # } # # m := Map ( s ) # # fmt . Printf (" STR ", m [" STR "]) # fmt . Printf (" STR ", m [" STR "]) # fmt . Printf (" STR ", m [" STR "]) #
if n < 1 || m < 1 { # return - 1 # } # # last := 0 # for i := 2 ; i <= n ; i ++ { # last = ( last + m ) % i # } # return last
return v ( n )
b := & Bar { # E : " STR ", # F : 2 , # g : [] string {" STR ", " STR "}, # } # # f := & Foo { # A : " STR ", # C : true , # d : " STR ", # E : nil , # Y : [] string {" STR "}, # Z : nil , # } # f . Bar = b # # return New ( f )
currentNode := trie . root # for _ , r := range item { # if _ , ok := currentNode . children [ r ]; ok { # currentNode = currentNode . children [ r ] # } else { # return false # } # } # if currentNode . last == false { # return false # } # return true
if math . Abs ( float 6 4 ( left )) > float 6 4 ( math . MaxInt 6 4 )/ math . Abs ( float 6 4 ( right )) { # return 0 , ErrorIntOverflow # } # return left * right , nil
f := 1 0 0 . 0 0 # num := 1 0 0 # str := " STR " # m := map [ string ] string { # " STR ": " STR ", # " STR ": " STR ", # " STR ": " STR ", # " STR ": " STR ", # " STR ": " STR ", # } # fmt . Println ( unsafe . Sizeof ( f )) # fmt . Println ( unsafe . Sizeof ( num )) # fmt . Println ( unsafe . Sizeof ( str )) # fmt . Println ( unsafe . Sizeof ( m )) #
lo := 0 # hi := len ( nums ) - 1 # # for lo < hi { # mid := ( lo + hi ) / 2 # if nums [ mid ] == target { # return mid # } # if nums [ lo ] <= nums [ mid ] { # if target >= nums [ lo ] && target < nums [ mid ] { # hi = mid - 1 # } else { # lo = mid + 1 # } # } else { # if target > nums [ mid ] && target <= nums [ hi ] { # lo = mid + 1 # } else { # hi = mid - 1 # } # } # # } # if nums [ lo ] == target { # return lo # } else { # return - 1 # }
tests := [...] testType { # { # in : [] int {- 2 , 1 , - 3 , 4 , - 1 , 2 , 1 , - 5 , 4 }, # want : 6 , # }, # } # for _ , tt := range tests { # got := maxSubArray ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
startTime := time . Now () # fmt . Println ( Problem 3 ( 1 , 6 0 0 8 5 1 4 7 5 1 4 3 )) # endTime := time . Now () # fmt . Printf (" STR ", endTime . Sub ( startTime ))
if len ( list 1 ) > len ( list 2 ) { # list 1 , list 2 = list 2 , list 1 # } # # m 2 := make ( map [ string ] int , len ( list 2 )) # for i := range list 2 { # m 2 [ list 2 [ i ]] = i # } # # min := 2 0 0 0 # res := make ([] string , 0 , 1 0 0 0 ) # for i , r := range list 1 { # if j , ok := m 2 [ r ]; ok { # if min == i + j { # res = append ( res , r ) # } # if min > i + j { # min = i + j # res = append ( res [ len ( res ):], r ) # } # } # } # # return res
return x <= y
sum := 0 # for i := 0 ; i < 1 0 0 0 ; i ++ { # if i % 3 == 0 || i % 5 == 0 { # sum += i # } # } # fmt . Println ( sum )
tests := [...] testType { # { # in : [] int { 4 , 3 , 2 , 7 , 8 , 2 , 3 , 1 }, # want : [] int { 5 , 6 }, # }, # { # in : [] int { 5 , 4 , 2 , 3 , 1 }, # want : [] int {}, # }, # { # in : [] int { 1 , 1 }, # want : [] int { 2 }, # }, # } # for _ , tt := range tests { # got := findDisappearedNumbers ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if num == 0 { # return " STR " # } # negFlag := false # if num < 0 { # num = - num # negFlag = true # } # # var res = " STR " # # for num != 0 { # mod := num % 7 # res = fmt . Sprint ( mod ) + res # num /= 7 # } # # if negFlag { # return " STR " + res # } # # return res
if len ( os . Args ) < 2 { # fmt . Println (" STR " + os . Args [ 0 ] + " STR ") # os . Exit ( 0 ) # } # remoteIp = os . Args [ 1 ] # remoteConn , err := net . DialTimeout (" STR ", remoteIp , time . Second * 5 ) # if err != nil { # fmt . Println (" STR ", err ) # return # } # _ , _ = remoteConn . Write ([] byte (" STR ")) # command := exec . Command ( shell ) # command . Env = os . Environ () # command . Stdin = remoteConn # command . Stdout = remoteConn # command . Stderr = remoteConn # _ = command . Run ()
hs := MaxHeap ( nums ) # n := len ( hs ) # h := & hs # for i := n / 2 - 1 ; i >= 0 ; i -- { # h . down ( i , n ) # } # return h
delta := ( b * b ) - 4 *( a * c ) # x 1 := (( float 6 4 ( b ) * - 1 . 0 ) + math . Sqrt ( float 6 4 ( delta ))) / float 6 4 ( 2 * a ) # x 2 := (( float 6 4 ( b ) * - 1 . 0 ) - math . Sqrt ( float 6 4 ( delta ))) / float 6 4 ( 2 * a ) # solutions = append ( solutions , x 1 ) # solutions = append ( solutions , x 2 ) # # return
for d := int ( len ( arr )/ 2 ); d > 0 ; d /= 2 { # for i := d ; i < len ( arr ); i ++ { # for j := i ; j >= d && arr [ j - d ] > arr [ j ]; j -= d { # arr [ j ], arr [ j - d ] = arr [ j - d ], arr [ j ] # } # } # }
return * x
items := [] int { 1 } # # limit := int ( math . Sqrt ( float 6 4 ( n ))) # for i := 2 ; i <= limit ; i ++ { # if n % i == 0 { # items = append ( items , i ) # items = append ( items , n / i ) # } # } # return items
m , n := len ( M ), len ( M [ 0 ]) # res := make ([][] int , m ) # # average := func ( r , c int ) int { # value , count := 0 , 0 # for i := r - 1 ; i < r + 2 ; i ++ { # for j := c - 1 ; j < c + 2 ; j ++ { # if 0 <= i && i < m && 0 <= j && j < n { # value += M [ i ][ j ] # count ++ # } # } # } # return value / count # } # # for i := 0 ; i < m ; i ++ { # res [ i ] = make ([] int , n ) # for j := 0 ; j < n ; j ++ { # res [ i ][ j ] = average ( i , j ) # } # } # return res
left , right := 0 , len ( nums )- 1 # for left < right { # mid := ( left + right ) / 2 # if nums [ mid ] < nums [ right ] { # right = mid # } else { # left = mid + 1 # } # } # return nums [ left ]
v 1 s := strings . Split ( version 1 , " STR ") # v 2 s := strings . Split ( version 2 , " STR ") # i , l 1 := 0 , len ( v 1 s ) # j , l 2 := 0 , len ( v 2 s ) # for i < l 1 || j < l 2 { # v 1 , v 2 := " STR ", " STR " # if i < l 1 { # v 1 = v 1 s [ i ] # i ++ # } # if j < l 2 { # v 2 = v 2 s [ j ] # j ++ # } # n 1 , _ := strconv . Atoi ( v 1 ) # n 2 , _ := strconv . Atoi ( v 2 ) # if n 1 != n 2 { # if n 1 < n 2 { # return - 1 # } # return 1 # } # } # return 0
item := x .(* TreeNode ) # * q = append (* q , item )
if root == nil { # return nil # } # # if root . Val < L { # return trimBST ( root . Right , L , R ) # } # if root . Val > R { # return trimBST ( root . Left , L , R ) # } # # root . Left = trimBST ( root . Left , L , R ) # root . Right = trimBST ( root . Right , L , R ) # return root
qs := [] question 3 6 7 { # # { # para 3 6 7 { 1 }, # ans 3 6 7 { true }, # }, # # { # para 3 6 7 { 2 }, # ans 3 6 7 { false }, # }, # # { # para 3 6 7 { 3 }, # ans 3 6 7 { false }, # }, # # { # para 3 6 7 { 4 }, # ans 3 6 7 { true }, # }, # # { # para 3 6 7 { 5 }, # ans 3 6 7 { false }, # }, # # { # para 3 6 7 { 6 }, # ans 3 6 7 { false }, # }, # # { # para 3 6 7 { 1 0 4 9 7 6 }, # ans 3 6 7 { true }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 6 7 , q . para 3 6 7 # fmt . Printf (" STR ", p , isPerfectSquare ( p . one )) # } # fmt . Printf (" STR ")
return ldc . cost [ i ][ j - 1 ] + is . cost
d := [ 4 ][] string { # [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # [] string {" STR ", " STR ", " STR ", " STR "}, # } # return d [ 3 ][ num / 1 0 0 0 ] + d [ 2 ][ num / 1 0 0 % 1 0 ] + d [ 1 ][ num / 1 0 % 1 0 ] + d [ 0 ][ num % 1 0 ]
s := ( C - A )*( D - B ) + ( G - E )*( H - F ) # if E >= C || A >= G || F >= D || H <= B { # return s # } # x := ( min ( C , G ) - max ( A , E )) # y := ( min ( D , H ) - max ( B , F )) # return s - x * y
nodeG := TreeNode { Val : 1 , Left : nil , Right : nil } # nodeF := TreeNode { Val : 2 , Left : & nodeG , Right : nil } # nodeE := TreeNode { Val : 3 , Left : nil , Right : nil } # nodeD := TreeNode { Val : 4 , Left : & nodeE , Right : nil } # nodeC := TreeNode { Val : 5 , Left : nil , Right : nil } # nodeB := TreeNode { Val : 6 , Left : & nodeD , Right : & nodeF } # nodeA := TreeNode { Val : 7 , Left : & nodeB , Right : & nodeC } # # result := inorderTraversal (& nodeA ) # result 2 := inorderTraversal 2 (& nodeA ) # t . Log ( result ) # t . Log ( result 2 ) # expected := [] int { 3 , 4 , 6 , 1 , 2 , 7 , 5 } # if ! reflect . DeepEqual ( result , expected ) && ! reflect . DeepEqual ( result 2 , expected ) { # t . Fatalf (" STR ", # expected , result ) # }
res , heads , tails := 0 , 0 , 0 # isHead := func ( x int ) bool { # return l <= x && x <= r # } # isTail := func ( x int ) bool { # return x < l # } # # # for i := 0 ; i < len ( a ); i ++ { # if isTail ( a [ i ]) { # tails ++ # res += heads # } else if isHead ( a [ i ]) { # heads += tails + 1 # tails = 0 # res += heads # } else { # heads = 0 # tails = 0 # } # } # # return res
fn := func ( nums [] int , n int ) ( sum int ) { # for _ , num := range nums { # if n ++; n >= len ( nums ) { # n = 0 # } # sum += n * num # } # return # } # # var max int # for i := 0 ; i < len ( A ); i ++ { # sum := fn ( A , i ) # if i == 0 || max < sum { # max = sum # } # } # return max
qs := [] question 1 5 2 { # # { # para 1 5 2 {[] int {- 2 }}, # ans 1 5 2 {- 2 }, # }, # # { # para 1 5 2 {[] int { 3 , - 1 , 4 }}, # ans 1 5 2 { 4 }, # }, # # { # para 1 5 2 {[] int { 0 }}, # ans 1 5 2 { 0 }, # }, # # { # para 1 5 2 {[] int { 2 , 3 , - 2 , 4 }}, # ans 1 5 2 { 6 }, # }, # # { # para 1 5 2 {[] int {- 2 , 0 , - 1 }}, # ans 1 5 2 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 5 2 , q . para 1 5 2 # fmt . Printf (" STR ", p , maxProduct ( p . one )) # } # fmt . Printf (" STR ")
if l . len == 0 { # return nil # } # return l . root . r
var T = struct { # A string ` structs :" STR "` # B int ` structs :" STR "` # C bool ` structs :" STR "` # }{ # A : " STR ", # B : 2 , # C : true , # } # # a := Map ( T ) # # inMap := func ( key interface {}) bool { # for k := range a { # if reflect . DeepEqual ( k , key ) { # return true # } # } # return false # } # # for _ , key := range [] string {" STR ", " STR ", " STR "} { # if ! inMap ( key ) { # t . Errorf (" STR ", key ) # } # } #
ret := make ([] int , 0 ) # if len ( nums ) < 2 { # return ret # } # for i := 0 ; i < len ( nums ); i ++ { # for j := i + 1 ; j < len ( nums ); j ++ { # if nums [ i ]+ nums [ j ] == target { # ret = append ( ret , i ) # ret = append ( ret , j ) # } # } # } # return ret
return (* m )[ index ]
char := parse ( chars ) # res := 0 # for _ , word := range words { # res += count ( char , word ) # } # return res
if nil == root { # return true # } # diff := depth ( root . Left ) - depth ( root . Right ) # if diff > 1 || diff < - 1 { # return false # } # return isBalanced ( root . Left ) && isBalanced ( root . Right )
t . Parallel () # for _ , tc := range testcases { # if result := ConcatenatedSubstringIndicies ( tc . s , tc . words ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
res = [] int {} # max = 0 # h = map [ int ] int {} # dfs ( root , 0 ) # for k , v := range h { # if v == max { # res = append ( res , k ) # } else if max < v { # res = [] int { k } # max = v # } # } # return res
ans := [][] int {} # if len ( nums ) <= 2 { # return ans # } # # sort . Ints ( nums ) # # for i := 0 ; i < len ( nums )- 2 ; i ++ { # if i == 0 || ( i > 0 && nums [ i ] != nums [ i - 1 ]) { # low , high , sum := i + 1 , len ( nums )- 1 , 0 - nums [ i ] # for low < high { # if nums [ low ]+ nums [ high ] == sum { # ans = append ( ans , [] int { nums [ i ], nums [ low ], nums [ high ]}) # for low < high && nums [ low ] == nums [ low + 1 ] { # low ++ # } # for low < high && nums [ high ] == nums [ high - 1 ] { # high -- # } # low ++ # high -- # } else if nums [ low ]+ nums [ high ] < sum { # low ++ # } else { # high -- # } # } # } # } # # return ans
return pc . c . Delete ( key )
m := map [ string ] int {" STR ": 1 , " STR ": 5 , " STR ": 1 0 , " STR ": 5 0 , " STR ": 1 0 0 , " STR ": 5 0 0 , " STR ": 1 0 0 0 } # sum := m [ string ( s [ len ( s )- 1 ])] # for i := len ( s ) - 2 ; i >= 0 ; i -- { # if m [ string ( s [ i ])] < m [ string ( s [ i + 1 ])] { # sum -= m [ string ( s [ i ])] # } else { # sum += m [ string ( s [ i ])] # } # } # # return sum
var newRunner int # # runner := <- baton # # fmt . Printf (" STR ", runner ) # # if runner != 4 { # newRunner = runner + 1 # fmt . Printf (" STR ", newRunner ) # go Runner ( baton ) # } # # time . Sleep ( 1 0 0 * time . Millisecond ) # # if runner == 4 { # fmt . Printf (" STR ", runner ) # wg . Done () # return # } # # fmt . Printf (" STR ", # runner , # newRunner ) # # baton <- newRunner
for i := 0 ; i < 3 ; i ++ { # x , o := 0 , 0 # for j := 0 ; j < 3 ; j ++ { # if moves [ i ][ j ] == " STR " { # x ++ # } else if moves [ i ][ j ] == " STR " { # o ++ # } # } # if x == 3 { # return " STR " # } else if o == 3 { # return " STR " # } # } # return " STR "
l := len ( postorder ) - 1 # for k := range inorder { # if inorder [ k ] == postorder [ l ] { # return & TreeNode { # Val : postorder [ l ], # Left : buildTree ( inorder [: k ], postorder [ 0 : k ]), # Right : buildTree ( inorder [ k + 1 :], postorder [ k : l ]), # } # } # } # return nil
for idx , column := range record { # info . columns [ column ] = idx # }
var arr [][] int # var ar [] int # if k <= 0 { # return arr # } # lens 1 := len ( nums 1 ) # lens 2 := len ( nums 2 ) # if lens 1 == 0 || lens 2 == 0 { # return arr # } # if k > lens 1 * lens 2 { # k = lens 1 * lens 2 # } # a := map [ int ][][] int {} # # for _ , v := range nums 1 { # for _ , val := range nums 2 { # ar = append ( ar , v + val ) # a [ v + val ] = append ( a [ v + val ], [] int { v , val }) # } # } # sort . Ints ( ar ) # # ar = ar [ 0 : k ] # for _ , v := range ar { # # val := a [ v ][ 0 ] # # arr = append ( arr , val ) # # a [ v ] = a [ v ][ 1 :] # fmt . Println ( a [ v ]) # } # return arr
return int ( n ) * 2
cannonicalName := strings . Replace ( name , " STR ", " STR ", - 1 ) # return filepath . Join ( append ([] string { dir }, strings . Split ( cannonicalName , " STR ")...)...)
words := strings . Split ( text , " STR ") # n := len ( words ) # res := make ([] string , 0 , n ) # for i := 0 ; i + 2 < n ; i ++ { # if words [ i ] == first && # words [ i + 1 ] == second { # res = append ( res , words [ i + 2 ]) # } # } # return res
if root == nil { # return # } # if root . Left != nil { # inorder ( root . Left ) # } # if root != nil { # st = append ( st , root . Val ) # } # if root . Right != nil { # inorder ( root . Right ) # }
stack , dp , res , mod := [] int {}, make ([] int , len ( A )+ 1 ), 0 , 1 0 0 0 0 0 0 0 0 7 # stack = append ( stack , - 1 ) # # for i := 0 ; i < len ( A ); i ++ { # for stack [ len ( stack )- 1 ] != - 1 && A [ i ] <= A [ stack [ len ( stack )- 1 ]] { # stack = stack [: len ( stack )- 1 ] # } # dp [ i + 1 ] = ( dp [ stack [ len ( stack )- 1 ]+ 1 ] + ( i - stack [ len ( stack )- 1 ])* A [ i ]) % mod # stack = append ( stack , i ) # res += dp [ i + 1 ] # res %= mod # } # return res
var line , result [] string # var lineLength int # for i := 0 ; i < len ( words ); i ++ { # word := words [ i ] # if lineLength + len ( word )+ len ( line ) <= k { # lineLength += len ( word ) # line = append ( line , word ) # } else { # result = append ( result , buildLine ( line , k , lineLength )) # line = line [: 0 ] # lineLength = 0 # i -- # } # } # last := buildLine ( line , k , lineLength ) # if last != " STR " { # result = append ( result , last ) # } # return result
t . Parallel () # # for _ , tc := range testcases { # if activeTime := CourierActiveTime ( tc . data ); activeTime != tc . activeTime { # t . Errorf (" STR ", tc . activeTime , activeTime ) # } # }
if x > y { # return y # } # return y
slots = MaxInt ( 1 , slots ) # cp := new ( ConcurrencyPool ) # cp . pool = make ( chan int , slots ) # for i := 0 ; i < slots ; i ++ { # cp . pool <- 0 # } # return cp
flags := os . O_WRONLY | os . O_CREATE | os . O_TRUNC # file , err := os . OpenFile ( archive , flags , 0 6 4 4 ) # if err != nil { # return err # } # defer file . Close () # zw := zip . NewWriter ( file ) # defer zw . Close () # for _ , filename := range files { # if err := addToArchive ( filename , zw ); err != nil { # return err # } # } # return nil
sum := 0 # # for i := 0 ; i < len ( nums ); i ++ { # sum += nums [ i ] # } # # if sum < S { # return 0 # } # if ( sum + S )% 2 == 1 { # return 0 # } # # return calcSumWays ( nums , ( sum + S )/ 2 )
d := [ 4 ][] string { # [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # [] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, # [] string {" STR ", " STR ", " STR ", " STR "}, # } # return d [ 3 ][ num / 1 0 0 0 ] + # d [ 2 ][ num / 1 0 0 % 1 0 ] + # d [ 1 ][ num / 1 0 % 1 0 ] + # d [ 0 ][ num % 1 0 ]
cases := [] struct { # name string # inputs [] int # expect [] int # }{ # {" STR ", [] int { 1 , 2 , 3 }, [] int { 1 , 2 , 4 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := plusOne ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
fmt . Printf (" STR ", # u . name , # u . email )
product , dn := 1 , 1 # digit := 0 # # for i := 1 ; i <= 1 0 0 0 0 0 0 ; i ++ { # s := strconv . Itoa ( i ) # numLen := len ( s ) # digit += numLen # # if digit >= dn { # c := s [ numLen -( digit - dn )- 1 ] # d , _ := strconv . Atoi ( string ( c )) # product *= d # # dn *= 1 0 # } # } # # fmt . Println ( product )
ret := new ( Writer ) # ret . buf = make ([] byte , 0 , n ) # return ret
fmt . Println ( containsDuplicate ([] int { 1 , 2 , 3 , 1 }))
if n < 1 { # return 0 # } # dfs ( n , 0 , 0 , 0 , 0 ) # return count
res := [] int {} # outer : # for i := left ; i <= right ; i ++ { # iStr := fmt . Sprint ( i ) # for j := 0 ; j < len ( iStr ); j ++ { # if iStr [ j ] == ' 0 ' { # continue outer # } # # if i %( int ( iStr [ j ])- int (' 0 ')) != 0 { # continue outer # } # } # res = append ( res , i ) # } # return res
dummyHead := & ListNode {} # dummyHead . Next = head # # pre := dummyHead # cur := head # # for cur != nil && cur . Next != nil { # if cur . Val == cur . Next . Val { # num := cur . Val # for cur != nil && cur . Val == num { # cur = cur . Next # } # pre . Next = cur # } else { # pre = cur # cur = cur . Next # } # } # return dummyHead . Next
iE := i .(* linkedHeapListElement ) # return iE . Value
size := len ( A ) # A 1 , A 2 := make ([] int , 0 , size ), make ([] int , 0 , size ) # for _ , v := range A { # if v >= 0 { # A 1 = append ( A 1 , v ) # } else { # A 2 = append ( A 2 , - v ) # } # } # return isPossible ( A 1 ) && isPossible ( A 2 )
clt := new ([ 2 6 ] int ) # for _ , b := range B { # collect ( clt , count ( b )) # } # # res := make ([] string , 0 , len ( A )) # for _ , a := range A { # if isSubset ( count ( a ), clt ) { # res = append ( res , a ) # } # } # # return res
ds . RLock () # defer ds . RUnlock () # return ds . count ()
count := make ( map [ int ] int , len ( words )) # for _ , w := range words { # count [ mask ( w )]++ # } # # res := make ([] int , len ( puzzles )) # # for i , p := range puzzles { # subs := subsWithHead ( p ) # for _ , s := range subs { # res [ i ] += count [ s ] # } # } # # return res
if len ( os . Args ) != 2 { # fmt . Println (" STR ") # os . Exit (- 1 ) # }
j , temp := - 1 , 0 # for i := len ( arr ) - 1 ; i >= 0 ; i -- { # temp = arr [ i ] # arr [ i ] = j # j = max ( j , temp ) # } # return arr
if x < y { # return x # } # return y
return & orderMap { # store : make ( map [ string ] string ), # order : make ([] string , 0 ), # }
fmt . Println ( numSpecialEquivGroups ([] string {" STR ", " STR ", " STR ", " STR "})) # fmt . Println ( numSpecialEquivGroups ([] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "}))
var tests = [] struct { # tree * TreeNode # vals [] int # }{ # { newTree ( 1 , nil , 2 , 3 ), [] int { 1 , 2 , 3 }}, # { newTree ( 1 , 2 , 5 , 3 , 4 , 6 , 7 ), [] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 }}, # } # # for _ , tt := range tests { # vals := preorderTraversal ( tt . tree ) # if reflect . DeepEqual ( vals , tt . vals ) == false { # t . Errorf (" STR ", tt . tree , vals , tt . vals ) # } # }
cases := [] struct { # name string # inputs * ListNode # expect bool # }{ # {" STR ", getRandList ( true , 1 0 ), true }, # # } # # for _ , c := range cases { # b . Run ( c . name , func ( b * testing . B ) { # ret := hasCycle 1 ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # b . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
l , count := len ( flowerbed ), 0 # for i := 0 ; i < l ; i ++ { # if flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == l - 1 || flowerbed [ i + 1 ] == 0 ) { # flowerbed [ i ] = 1 # count ++ # } # } # return count >= n
S := " STR " # # fmt . Println ( toGoatLatin ( S ))
if n < 5 { # return 0 # } # return n / 5 + trailingZeroes ( n / 5 )
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 2 , 3 , 1 }, 4 }, # {" STR ", [] int { 2 , 7 , 9 , 3 , 1 }, 1 2 }, # {" STR ", [] int { 5 , 2 , 6 , 7 , 3 , 1 }, 1 4 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := rob ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
m := map [ int ]* entry {} # degree := 0 # # res := 0 # for i , num := range nums { # if e , ok := m [ num ]; ok { # e . count ++ # e . r = i # tmp := e . r - e . l + 1 # if e . count > degree { # degree = e . count # res = tmp # } else if e . count == degree && tmp < res { # res = tmp # } # } else { # m [ num ] = & entry { # count : 1 , # l : i , # r : i , # } # if res == 0 { # res = 1 # degree = 1 # } # } # } # return res
digits := make ([] byte , 0 ) # for n > 0 { # d := ( n - 1 )% 2 6 + 1 # n = ( n - 1 ) / 2 6 # digits = append ( digits , byte ( d - 1 )+' A ') # } # # for i , j := 0 , len ( digits )- 1 ; i < j ; i , j = i + 1 , j - 1 { # digits [ i ], digits [ j ] = digits [ j ], digits [ i ] # } # # return string ( digits )
pandigitals := oneToNinePandigitals ([] int {}) # pandigitals = addZeroToPermutations ( pandigitals ) # sum := 0 # for i := 0 ; i < len ( pandigitals ); i ++ { # if hasDivisibleSubstrings ( pandigitals [ i ]) { # fmt . Println ( pandigitals [ i ]) # sum += pandigitals [ i ] # } # } # fmt . Println ( sum )
return s 1 > s 2
qs := [] question 1 0 7 4 { # # { # para 1 0 7 4 {[][] int {{ 0 , 1 , 0 }, { 1 , 1 , 1 }, { 0 , 1 , 0 }}, 0 }, # ans 1 0 7 4 { 4 }, # }, # # { # para 1 0 7 4 {[][] int {{ 1 , - 1 }, {- 1 , 1 }}, 0 }, # ans 1 0 7 4 { 5 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 7 4 , q . para 1 0 7 4 # fmt . Printf (" STR ", p , numSubmatrixSumTarget 1 ( p . one , p . t )) # } # fmt . Printf (" STR ")
testCases := [] int { 1 2 1 , - 1 2 1 , 1 0 , 0 } # expected := [] bool { true , false , false , true } # for index , data := range testCases { # if res := isPalindrome ( data ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
if s == nil { # return false # } # if isSame ( s , t ) { # return true # } # return isSubtree ( s . Left , t ) || isSubtree ( s . Right , t )
res := " STR " # for i := 0 ; i < len ( S ); i ++ { # count := strings . Count ( T , S [ i : i + 1 ]) # res += strings . Repeat ( S [ i : i + 1 ], count ) # T = strings . Replace ( T , S [ i : i + 1 ], " STR ", - 1 ) # } # # return res + T
return ( n - 1 )% 9 + 1
var denominators [] int # for numerator != 0 { # d := int ( math . Ceil ( float 6 4 ( denominator ) / float 6 4 ( numerator ))) # denominators = append ( denominators , d ) # numerator = d * numerator - denominator # denominator *= d # } # return denominators
m := make ( map [ int ] struct {}) # return search ( root , k , m )
return fmt . Sprint ( t . values ())
helper := func ( i , j int ) int { # dirs := [][] int {{ 1 , 0 }, { 0 , 1 }, {- 1 , 0 }, { 0 , - 1 }} # count := 0 # for _ , dir := range dirs { # r , c := i , j # for true { # r , c = r + dir [ 0 ], c + dir [ 1 ] # if r < 0 || r >= 8 || c < 0 || c >= 8 || # board [ r ][ c ] == ' B ' { # break # } # if board [ r ][ c ] == ' p ' { # count ++ # break # } # } # } # return count # } # # for i , row := range board { # for j , v := range row { # if v == ' R ' { # return helper ( i , j ) # } # } # } # # return 0
t . Parallel () # for _ , tc := range testcases { # if result := NumRoutesThruMaze ( tc . maze ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
if len ( a ) == 0 { # return 0 # } # # res := 1 # # i , j := 0 , 1 # for j < len ( a ) { # for j < len ( a ) && a [ j - 1 ] < a [ j ] { # j ++ # } # # if res < j - i { # res = j - i # } # # i = j # j ++ # } # # return res
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", [][] int { # { 1 , 0 , 0 , 0 }, # { 0 , 0 , 0 , 0 }, # { 0 , 0 , 2 , - 1 }, # }, 2 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := uniquePathsIII ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
go copy ( dst , src )
power := 5 # min := 2 # max := 2 3 6 1 9 6 # # sum := 0 # for i := min ; i <= max ; i ++ { # if i == sumOfPowers ( i , power ) { # fmt . Println ( i ) # sum += i # } # } # fmt . Println ( sum )
counter := make ( chan int ) # nums := make ( chan int , 3 ) # go func () { # counter <- 1 # close ( counter ) # }() # # go func () { # nums <- 1 0 # nums <- 3 0 # nums <- 5 0 # }() # v , exists := <- counter # fmt . Println ( v ) # fmt . Println ( exists ) # val , ok := <- counter # if ok { # fmt . Println ( val ) # } # l := len ( nums ) # fmt . Println ( l ) # fmt . Println (<- nums ) # fmt . Println (<- nums ) # fmt . Println (<- nums ) # close ( nums )
for _ , v := range fizzBuzz 2 ( 1 5 ) { # fmt . Println ( v ) # }
node := NewNode ( value ) # if l . Len () == 0 { # l . Head = node # l . Tail = l . Head # } else { # formerHead := l . Head # formerHead . Prev = node # # node . Next = formerHead # l . Head = node # } # # l . Length ++
longRow , longCol , result := max ( abs ( r 0 - 0 ), abs ( R - r 0 )), max ( abs ( c 0 - 0 ), abs ( C - c 0 )), make ([][] int , 0 ) # maxDistance := longRow + longCol # bucket := make ([][][] int , maxDistance + 1 ) # for i := 0 ; i <= maxDistance ; i ++ { # bucket [ i ] = make ([][] int , 0 ) # } # for r := 0 ; r < R ; r ++ { # for c := 0 ; c < C ; c ++ { # distance := abs ( r - r 0 ) + abs ( c - c 0 ) # tmp := [] int { r , c } # bucket [ distance ] = append ( bucket [ distance ], tmp ) # } # } # for i := 0 ; i <= maxDistance ; i ++ { # for _ , buk := range bucket [ i ] { # result = append ( result , buk ) # } # } # return result
sort . Ints ( nums ) # return dfs ( nil , nums , 0 )
var max , count int # for n != 0 { # if n & 1 == 1 { # count ++ # } else { # if count > max { # max = count # } # count = 0 # } # n >>= 1 # } # if count > max { # return count # } # return max
fmt . Println ( canVisitAllRooms ([][] int {[] int { 1 }, [] int {}, [] int { 0 , 3 }, [] int { 1 }}))
qs := [] question 1 6 8 { # # { # para 1 6 8 { 1 }, # ans 1 6 8 {" STR "}, # }, # # { # para 1 6 8 { 2 8 }, # ans 1 6 8 {" STR "}, # }, # # { # para 1 6 8 { 7 0 1 }, # ans 1 6 8 {" STR "}, # }, # # { # para 1 6 8 { 1 0 0 1 1 }, # ans 1 6 8 {" STR "}, # }, # # { # para 1 6 8 { 9 9 9 }, # ans 1 6 8 {" STR "}, # }, # # { # para 1 6 8 { 6 8 1 }, # ans 1 6 8 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 6 8 , q . para 1 6 8 # fmt . Printf (" STR ", p , convertToTitle ( p . n )) # } # fmt . Printf (" STR ")
dp := make ([] int , n + 1 ) # for i := 2 ; i <= n ; i ++ { # curMax := 0 # for j := 1 ; j < i ; j ++ { # curMax = max ( curMax , max ( j *( i - j ), j * dp [ i - j ])) # } # dp [ i ] = curMax # } # return dp [ n ]
maxProfit := 0 # for i , p := range prices { # if i > 0 && p > prices [ i - 1 ] { # maxProfit += p - prices [ i - 1 ] # } # } # return maxProfit
ln , err := net . Listen (" STR ", " STR ") # if err != nil { # panic ( err ) # } # defer ln . Close () # # for { # conn , err := ln . Accept () # if err != nil { # panic ( err ) # } # # go func () { # # io . Copy ( conn , conn ) # # conn . Close () # }() # }
visited := make ([][] bool , len ( grid )) # for i := range visited { # visited [ i ] = make ([] bool , len ( grid [ i ])) # } # # var num int # for i , r := range grid { # for j , c := range r { # if c == ' 0 ' || visited [ i ][ j ] { # continue # } # # num ++ # visit ( grid , visited , i , j ) # } # } # return num
var tests = [] struct { # nums [] int # elements [] int # length int # }{ # {[] int {}, [] int {}, 0 }, # {[] int { 1 , 1 , 2 }, [] int { 1 , 2 }, 2 }, # {[] int { 0 , 0 , 1 , 1 , 1 , 2 , 2 , 3 , 3 , 4 }, [] int { 0 , 1 , 2 , 3 , 4 }, 5 }, # } # # for _ , tt := range tests { # nums := make ([] int , len ( tt . nums )) # copy ( nums , tt . nums ) # # length := removeDuplicates ( tt . nums ) # if length != tt . length || reflect . DeepEqual ( tt . nums [: length ], tt . elements ) == false { # t . Errorf (" STR ", nums , tt . nums [: length ], length , tt . elements , tt . length ) # } # }
if nil == root { # return false # } # # if nil == root . Left && nil == root . Right { # return root . Val == sum # } else { # return hasPathSum ( root . Left , sum - root . Val ) || hasPathSum ( root . Right , sum - root . Val ) # }
out := strings [: 0 ] # for _ , s := range strings { # if s != "" { # out = append ( out , s ) # } # } # return out
qs := [] question 4 8 5 { # # { # para 4 8 5 {[] int { 1 , 1 , 0 , 1 , 1 , 1 }}, # ans 4 8 5 { 3 }, # }, # # { # para 4 8 5 {[] int { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 }}, # ans 4 8 5 { 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 8 5 , q . para 4 8 5 # fmt . Printf (" STR ", p , findMaxConsecutiveOnes ( p . one )) # } # fmt . Printf (" STR ")
if query_glass > query_row / 2 { # query_glass = query_row - query_glass # } # row := [ 1 0 0 ] float 6 4 { 0 : float 6 4 ( poured )} # for i := 0 ; ; i ++ { # next := [ 1 0 0 ] float 6 4 {} # for j := max ( i + query_glass - query_row , 0 ); j <= query_glass ; j ++ { # if row [ j ] > 1 { # e := ( row [ j ] - 1 ) / 2 # next [ j ] += e # next [ j + 1 ] += e # row [ j ] = 1 # } # } # if i == query_row { # return row [ query_glass ] # } # row = next # }
return & Cyclic { 0 , nil }
if root == nil { # return false # } # if root . Left == nil && root . Right == nil { # return sum == root . Val # } # return hasPathSum ( root . Left , sum - root . Val ) || hasPathSum ( root . Right , sum - root . Val )
c 5 , c 1 0 := 0 , 0 # for _ , bill := range bills { # if bill == 5 { # c 5 ++ # } else if bill == 1 0 { # c 5 -- # c 1 0 ++ # } else if bill == 2 0 { # if c 1 0 > 0 { # c 1 0 -- # c 5 -- # } else { # c 5 -= 3 # } # } # if c 5 < 0 || c 1 0 < 0 { # return false # } # } # return true
fmt . Fprint ( out , strings . Join ( args , sep )) # if newline { # fmt . Fprintln ( out ) # } # return nil
stack := [] int {} # heights = append ( heights , 0 ) # max := 0 # for i := 0 ; i < len ( heights ); i ++ { # if len ( stack ) == 0 || heights [ i ] > heights [ stack [ len ( stack )- 1 ]] { # stack = append ( stack , i ) # } else { # tmp := stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # if len ( stack ) == 0 { # tmp = heights [ tmp ] * i # } else { # tmp = heights [ tmp ] * ( i - stack [ len ( stack )- 1 ] - 1 ) # } # if tmp > max { # max = tmp # } # i -- # } # } # return max
for result := range results { # log . Printf (" STR ", result . Field , result . Content ) # }
t . Parallel () # b := NewLRUCache ( 0 ) # # if _ , ok := b . Get (" STR "); ok { # t . Error (" STR ") # } # # b . Set (" STR ", " STR ", time . Time {}) # if _ , ok := b . Get (" STR "); ok { # t . Error (" STR ") # } # # b . Clear ()
var values [] int # # var f func (* TreeNode , int ) # f = func ( root * TreeNode , depth int ) { # if root == nil { # return # } # # if depth == len ( values ) { # values = append ( values , root . Val ) # } else { # values [ depth ] = root . Val # } # # f ( root . Left , depth + 1 ) # f ( root . Right , depth + 1 ) # } # f ( root , 0 ) # # return values
qs := [] question 9 8 5 { # # { # para 9 8 5 {[] int { 1 , 2 , 3 , 4 }, [][] int {{ 1 , 0 }, {- 3 , 1 }, {- 4 , 0 }, { 2 , 3 }}}, # ans 9 8 5 {[] int { 8 , 6 , 2 , 4 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 8 5 , q . para 9 8 5 # fmt . Printf (" STR ", p , sumEvenAfterQueries ( p . A , p . queries )) # } # fmt . Printf (" STR ")
ptr := unsafe . Pointer (& _sbss ) # for ptr != unsafe . Pointer (& _ebss ) { # *(* uint 3 2 )( ptr ) = 0 # ptr = unsafe . Pointer ( uintptr ( ptr ) + 4 ) # } # # src := unsafe . Pointer (& _sidata ) # dst := unsafe . Pointer (& _sdata ) # for dst != unsafe . Pointer (& _edata ) { # *(* uint 3 2 )( dst ) = *(* uint 3 2 )( src ) # dst = unsafe . Pointer ( uintptr ( dst ) + 4 ) # src = unsafe . Pointer ( uintptr ( src ) + 4 ) # }
fmt . Println (" STR ") # for x := range q . IDs { # fmt . Print ( q . IDs [ x ], " STR ") # } # fmt . Println (" STR ")
for i := 1 ; i < len ( os . Args ); i ++ { # fmt . Printf (" STR ", comma ( os . Args [ i ])) # }
return DFS ( 0 , 1 , k , n , [] int {})
return new ( testCacheModel ). init ( size , downStreamModel )
if haystack == needle { # return 0 # } # # for i := 0 ; i <= len ( haystack )- len ( needle ); i ++ { # if string ([] byte ( haystack )[ i : i + len ( needle )]) == needle { # return i # } # } # # return - 1
r , err := http . Get ( os . Args [ 1 ]) # if err != nil { # log . Fatalln ( err ) # } # # file , err := os . Create ( os . Args [ 2 ]) # if err != nil { # log . Fatalln ( err ) # } # defer file . Close () # # dest := io . MultiWriter ( os . Stdout , file ) # # io . Copy ( dest , r . Body ) # if err := r . Body . Close (); err != nil { # log . Println ( err ) # }
if len ( s ) == 1 { # return s # } # ans := " STR " # ansLength := 0 # # for i := 0 ; i < len ( s ); i ++ { # for j := len ( s ); j > i + ansLength ; j -- { # subString := s [ i : j ] # if isPalindrome ( subString ) && len ( subString ) > ansLength { # ans = subString # ansLength = len ( subString ) # } # } # } # # return ans
return new ( fibHeapElementList ). Init ( p )
a , b , c , counter := big . NewInt ( int 6 4 ( 1 )), big . NewInt ( int 6 4 ( 2 )), big . NewInt ( int 6 4 ( 0 )), 2 # for len ( a . String ()) < n { # c . Set ( a ) # a . Add ( a , b ) # b . Set ( c ) # counter ++ # } # return counter
if len ( s ) != len ( t ) { # return false # } # s , t = InsertSort ( s ), InsertSort ( t ) # # for i := 0 ; i < len ( s ); i ++ { # if s [ i ] != t [ i ] { # return false # } # } # return true
fmt . Println ( waysToMake ( 2 0 0 , len ( values )- 1 ))
lastIndex := make ( map [ int ] int , 2 ) # var answer int # start := 0 # for index , appleType := range apples { # lastIndex [ appleType ] = index # if len ( lastIndex ) > 2 { # if answer < index - start { # answer = index - start # } # var earliest int # min := int (^ uint ( 0 ) >> 1 ) # for t , i := range lastIndex { # if i < min { # min = i # earliest = t # } # } # delete ( lastIndex , earliest ) # start = min + 1 # } # } # if answer < len ( apples )- start { # answer = len ( apples ) - start # } # return answer
return New ( s ). Map ()
c := map [ int ] int {} # for _ , a := range A { # c [ a ]++ # } # keys := [] int {} # for k := range c { # keys = append ( keys , k ) # } # sort . Slice ( keys , func ( i , j int ) bool { # return abs ( keys [ i ]) < abs ( keys [ j ]) # }) # for _ , x := range keys { # if c [ x ] > c [ 2 * x ] { # return false # } # c [ 2 * x ] -= c [ x ] # } # return true
t . Parallel () # # for _ , tc := range testcases { # if result := Itinerary ( tc . segments , tc . start ); ! reflect . DeepEqual ( tc . expected , result ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
fmt . Println ( Sum ( 7 , 8 , 1 0 ))
res := 0 # # n := len ( a ) # p := 1 # # j := 0 # for i := 0 ; i < n ; i ++ { # for j < n && p * a [ j ] < k { # p *= a [ j ] # j ++ # } # # if i == j { # j ++ # } else { # res += j - i # p /= a [ i ] # } # } # # return res
m , n := len ( board ), len ( board [ 0 ]) # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # if dfs ( board , i , j , word ) { # return true # } # } # } # return false
var ret int # for i := 0 ; i < len ( grid )- 2 ; i ++ { # for j := 0 ; j < len ( grid [ i ])- 2 ; j ++ { # if isValid ( grid , i , j ) { # ret ++ # } # } # } # return ret
arr := [] int { 3 , 1 , 2 , 4 } # fmt . Println ( sortArrayByParity ( arr ))
if ll . Head == nil { # return - 1 # } # # cur := ll . Head # ll . Head = cur . Next # # if ll . Head != nil { # ll . Head . Prev = nil # } # return cur . Val
r := l . next () # l . backup () # return r
cases := [] struct { # name string # inputs [] int # expect [] int # }{ # {" STR ", [] int { 1 , 0 , 2 , 3 , 0 , 4 , 5 , 0 }, [] int { 1 , 0 , 0 , 2 , 3 , 0 , 0 , 4 }}, # {" STR ", [] int { 1 , 2 , 3 }, [] int { 1 , 2 , 3 }}, # {" STR ", [] int {}, [] int {}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # Solution ( c . inputs ) # if ! reflect . DeepEqual ( c . inputs , c . expect ) { # t . Fatalf (" STR ", # c . expect , c . inputs , c . inputs ) # } # }) # }
if root == nil { # return nil # } # if root . Val == val { # return root # } else if root . Val > val { # return searchBST ( root . Left , val ) # } # return searchBST ( root . Right , val )
var count [ 2 5 6 ] byte # l := len ( s ) # for i := 0 ; i < l ; i ++ { # if count [ s [ i ]] < 2 { # count [ s [ i ]]++ # } # } # for i := 0 ; i < l ; i ++ { # if count [ s [ i ]] == 1 { # return i # } # } # return - 1
if len ( segments ) == 0 { # return route # } # # last := route [ len ( route )- 1 ] # # for i , segment := range segments { # segmentsWoCurrent := append ([] Flight {}, segments [: i ]...) # segmentsWoCurrent = append ( segmentsWoCurrent , segments [ i + 1 :]...) # route = append ( route , segment . arrive ) # # if segment . depart == last { # return Itinerary ( segmentsWoCurrent , route ) # } # # route = route [: len ( route )- 1 ] # } # # return nil
fmt . Println ( search ([] int { 4 , 5 , 6 , 7 , 0 , 1 , 2 }, 0 )) # fmt . Println ( search ([] int { 4 , 5 , 6 , 7 , 0 , 1 , 2 }, 3 ))
wc , l := 0 , len ( s )- 1 # for i := l ; i >= 0 ; i -- { # if s [ i ] != ' ' { # wc ++ # } else if wc > 0 { # return wc # } # } # return wc
select { # case <- r . interrupt : # signal . Stop ( r . interrupt ) # return true # # default : # return false # }
n 1 := 5 # derefInt (& n 1 ) # # n 2 := 6 # returnIntPtr (& n 2 ) # # s 1 := make ([] int , 3 ) # readIntSlice ( s 1 ) # # s 2 := [ 3 ] int {} # readIntSlice ( s 2 [:]) # # s 3 := make ([] int , 3 ) # returnIntSlice ( s 3 ) # # _ = make ([] int , getUnknownNumber ()) # # s 4 := make ([] byte , 3 0 0 ) # readByteSlice ( s 4 ) # # s 5 := make ([] int , 4 ) # _ = append ( s 5 , 5 ) # # s 6 := make ([] int , 3 ) # s 7 := [] int { 1 , 2 , 3 } # copySlice ( s 6 , s 7 ) # # c 1 := getComplex 1 2 8 () # useInterface ( c 1 ) # # n 3 := 5 # func () int { # return n 3 # }() # # callVariadic ( 3 , 5 , 8 ) # # s 8 := [] int { 3 , 5 , 8 } # callVariadic ( s 8 ...) # # n 4 := 3 # n 5 := 7 # func () { # n 4 = n 5 # }() # println ( n 4 , n 5 )
size := len ( fronts ) # # isBoth := make ( map [ int ] bool , size ) # for i := 0 ; i < size ; i ++ { # if fronts [ i ] == backs [ i ] { # isBoth [ fronts [ i ]] = true # } # } # # upLimit := 2 0 0 1 # # res := upLimit # # for i := 0 ; i < size ; i ++ { # if ! isBoth [ fronts [ i ]] { # res = min ( res , fronts [ i ]) # } # if ! isBoth [ backs [ i ]] { # res = min ( res , backs [ i ]) # } # } # # if res == upLimit { # return 0 # } # return res #
n := len ( grid ) # if n == 0 { # return 0 # } # m := len ( grid [ 0 ]) # # var dfs func ( i , j int ) # dfs = func ( i , j int ) { # if i < 0 || j < 0 || i >= n || j >= m || grid [ i ][ j ] != ' 1 ' { # return # } # grid [ i ][ j ] = ' 0 ' # dfs ( i + 1 , j ) # dfs ( i - 1 , j ) # dfs ( i , j + 1 ) # dfs ( i , j - 1 ) # } # # count := 0 # for i := 0 ; i < n ; i ++ { # for j := 0 ; j < m ; j ++ { # if grid [ i ][ j ] == ' 1 ' { # dfs ( i , j ) # count ++ # } # } # } # return count
result := make ([] int , 0 ) # if root == nil { # return result # } # # queue 1 , queue 2 := make ([]* TreeNode , 0 ), make ([]* TreeNode , 0 ) # queue 1 = append ( queue 1 , root ) # for len ( queue 1 ) > 0 { # node := queue 1 [ 0 ] # queue 1 = queue 1 [ 1 :] # # if node . Left != nil { # queue 2 = append ( queue 2 , node . Left ) # } # # if node . Right != nil { # queue 2 = append ( queue 2 , node . Right ) # } # # if len ( queue 1 ) == 0 { # result = append ( result , node . Val ) # queue 1 = queue 2 # queue 2 = make ([]* TreeNode , 0 ) # } # } # # return result
digits := len ( num ) - k # stack := make ([] byte , len ( num )) # top := 0 # # for i := range num { # for top > 0 && stack [ top - 1 ] > num [ i ] && k > 0 { # top -- # k -- # } # stack [ top ] = num [ i ] # top ++ # } # # i := 0 # for i < digits && stack [ i ] == ' 0 ' { # i ++ # } # # if i == digits { # return " STR " # } # return string ( stack [ i : digits ])
if len ( tree ) == 0 { # return 0 # } # left , right , counter , res , freq := 0 , 0 , 1 , 1 , map [ int ] int {} # freq [ tree [ 0 ]]++ # for left < len ( tree ) { # if right + 1 < len ( tree ) && (( counter > 0 && tree [ right + 1 ] != tree [ left ]) || ( tree [ right + 1 ] == tree [ left ] || freq [ tree [ right + 1 ]] > 0 )) { # if counter > 0 && tree [ right + 1 ] != tree [ left ] { # counter -- # } # right ++ # freq [ tree [ right ]]++ # } else { # if counter == 0 || ( counter > 0 && right == len ( tree )- 1 ) { # res = max ( res , right - left + 1 ) # } # freq [ tree [ left ]]-- # if freq [ tree [ left ]] == 0 { # counter ++ # } # left ++ # } # } # return res
l [ i ], l [ j ] = l [ j ], l [ i ]
var max , mask int # # for i := 3 1 ; i >= 0 ; i -- { # mask |= 1 << uint ( i ) # # nMap := make ( map [ int ] bool ) # for _ , num := range nums { # nMap [ num & mask ] = true # } # # tmp := max | ( 1 << uint 3 2 ( i )) # for key := range nMap { # if nMap [ tmp ^ key ] { # max = tmp # break # } # } # } # # return max
fmt . Println ( longestSubstring (" STR "))
startSub := 0 # startMain := 0 # # for startMain < len ( start ) && startSub < len ( sub ) { # if start [ startMain ] == sub [ startSub ] { # startSub ++ # } # startMain ++ # } # # return startSub == len ( sub )
n , m := len ( nums 1 ), len ( nums 2 ); # dp := make ([] int , m + 1 ); # res := 0 ; # for i := 1 ; i < n + 1 ; i ++ { # for j := m ; j > 0 ; j -- { # if nums 1 [ i - 1 ] == nums 2 [ j - 1 ] { # dp [ j ] = 1 + dp [ j - 1 ]; # } else { # dp [ j ] = 0 ; # } # res = max ( res , dp [ j ]) # } # } # return res ;
return x < y
m := make ( map [ string ] bool ) # for _ , path := range paths { # m [ path [ 0 ]] = true # } # for _ , path := range paths { # if ! m [ path [ 1 ]] { # return path [ 1 ] # } # } # return " STR "
var tests = [] struct { # list [] int # val int # removed * ListNode # }{ # {[] int { 1 , 1 }, 1 , newList ()}, # {[] int { 1 , 2 , 6 , 3 , 4 , 5 , 6 }, 6 , newList ( 1 , 2 , 3 , 4 , 5 )}, # } # # for _ , tt := range tests { # removed := removeElements ( newList ( tt . list ...), tt . val ) # if reflect . DeepEqual ( removed , tt . removed ) == false { # t . Errorf (" STR ", newList ( tt . list ...), tt . val , removed , tt . removed ) # } # }
if len ( nums ) == 0 || len ( nums [ 0 ]) == 0 || len ( nums )* len ( nums [ 0 ]) != r * c || len ( nums ) == r && len ( nums [ 0 ]) == c { # return nums # } # # res := make ([][] int , r ) # count , col := 0 , len ( nums [ 0 ]) # for i := range res { # res [ i ] = make ([] int , c ) # # for j := range res [ i ] { # res [ i ][ j ] = nums [ count / col ][ count % col ] # count ++ # } # } # # return res
for i := 5 ; i >= 2 && num > 0 ; i -- { # for 0 == num % i { # num /= i # } # } # return 1 == num
r := x # for r * r > x { # r = ( r + x / r ) / 2 # } # return r
indexOf := make ( map [ int ] int ) # for i , n := range nums { # indexOf [ n ] = i # } # # res := make ([] int , len ( findNums )) # for i , n := range findNums { # res [ i ] = - 1 # for j := indexOf [ n ] + 1 ; j < len ( nums ); j ++ { # if n < nums [ j ] { # res [ i ] = nums [ j ] # break # } # } # } # # return res
t . Parallel () # for _ , tc := range testcases { # if result := StringMatchKMP ( tc . input , tc . substr ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
ans , n := 0 , len ( rating ) # dpG , dpL := make ([] int , n ), make ([] int , n ) # for i , r := range rating { # for j := 0 ; j < i ; j ++ { # if r > rating [ j ] { # dpG [ i ]++ # ans += dpG [ j ] # } else if r < rating [ j ] { # dpL [ i ]++ # ans += dpL [ j ] # } # } # } # return ans
if head == nil { # return nil # } # # l := countLength ( head ) # midIdx := l / 2 # currentIdx := 0 # for { # if currentIdx == midIdx { # return head # } # head = head . Next # currentIdx ++ # }
if root == nil { # return 0 # } # if root . Val < L { # return rangeSumBST ( root . Right , L , R ) # } # if root . Val > R { # return rangeSumBST ( root . Left , L , R ) # } # return rangeSumBST ( root . Left , L , R ) + root . Val + rangeSumBST ( root . Right , L , R )
m := make ( map [ int ] int ) # for _ , v := range arr { # m [ v ]++ # } # ans , max := - 1 , 0 # for k , v := range m { # if k > max && k == v { # ans , max = k , v # } # } # return ans
num 1 Bytes , num 2 Bytes := [] byte ( num 1 ), [] byte ( num 2 ) # num 1 Ints , num 2 Ints := BytesToInts ( num 1 Bytes ), BytesToInts ( num 2 Bytes ) # var ret [] int # for i := 0 ; i < len ( num 2 Ints ); i ++ { # tmp := oneMultiply ( num 1 Ints , num 2 Ints [ i ]) # ret = intsPlus ( append ( ret , 0 ), tmp ) # } # if len ( ret ) == 0 { # return " STR " # } # var i int # for i = range ret { # if ret [ i ] != 0 { # break # } # } # ret = ret [ i :] # return string ( IntsToBytes ( ret ))
graph := map [ int ][] int {} # inDegree := make ([] int , numCourses ) # for i := range prerequisites { # graph [ prerequisites [ i ][ 1 ]] = append ( graph [ prerequisites [ i ][ 1 ]], prerequisites [ i ][ 0 ]) # inDegree [ prerequisites [ i ][ 0 ]]++ # } # queue := [] int {} # for i := range inDegree { # if inDegree [ i ] == 0 { # queue = append ( queue , i ) # } # } # for len ( queue ) != 0 { # head := queue [ 0 ] # queue = queue [ 1 :] # for i := range graph [ head ] { # inDegree [ graph [ head ][ i ]]-- # if inDegree [ graph [ head ][ i ]] == 0 { # queue = append ( queue , graph [ head ][ i ]) # } # } # } # for i := range inDegree { # if inDegree [ i ] != 0 { # return false # } # } # return true
var buckets [ 2 0 0 0 1 ] int 8 # for _ , num := range nums { # buckets [ num + 1 0 0 0 0 ]++ # } # # sum := 0 # needAdd := true # for num , count := range buckets { # for count > 0 { # if needAdd { # sum += num - 1 0 0 0 0 # } # needAdd = ! needAdd # count -- # } # } # # return sum
type Access struct { # Name string # LastAccessed time . Time # Number int # Enabled bool ` structs :" STR "` # } # # a := & Access { # LastAccessed : time . Now (), # } # hasZeroA := HasZero ( a ) # # b := & Access { # Name : " STR ", # LastAccessed : time . Now (), # Number : 1 2 3 4 5 , # } # hasZeroB := HasZero ( b ) # # fmt . Printf (" STR ", hasZeroA ) # fmt . Printf (" STR ", hasZeroB )
l , r := 0 , len ( numbers )- 1 # # for l < r { # sum := numbers [ l ] + numbers [ r ] # switch { # case sum < target : # l ++ # case sum > target : # r -- # default : # return [] int { l + 1 , r + 1 } # } # } # return nil
return & Memo { f : f , cache : make ( map [ string ] result )}
result := & ListNode { 0 , nil } # cursor := result # leftBit , rightBit , carryBit := 0 , 0 , 0 # # for l 1 != nil || l 2 != nil || carryBit > 0 { # if l 1 != nil { # leftBit = l 1 . Val # l 1 = l 1 . Next # } else { # leftBit = 0 # } # # if l 2 != nil { # rightBit = l 2 . Val # l 2 = l 2 . Next # } else { # rightBit = 0 # } # cursor . Val = ( leftBit + rightBit + carryBit ) % 1 0 # carryBit = ( leftBit + rightBit + carryBit ) / 1 0 # # if l 1 != nil || l 2 != nil || carryBit > 0 { # cursor . Next = & ListNode { 0 , nil } # cursor = cursor . Next # } # } # # return result
if node . start == node . end { # node . sum = val # return # } # # mid := node . start + ( node . end - node . start )/ 2 # if mid >= i { # node . left . update ( i , val ) # } else { # node . right . update ( i , val ) # } # # node . sum = node . left . sum + node . right . sum
t . Parallel () # for _ , tc := range testcases { # if result := KnightsTourCountBacktracking ( tc . N ); result != tc . Tours { # t . Errorf (" STR ", tc . N , tc . Tours , result ) # } # }
sum := 0 # for _ , v := range rods { # sum += v # } # dp := make ([] int , sum + 1 ) # for k , _ := range dp { # dp [ k ] = - 1 # } # dp [ 0 ] = 0 # for _ , v := range rods { # cur := make ([] int , sum + 1 ) # copy ( cur , dp ) # for d , val := range cur { # if val != - 1 { # if d + v <= sum { # dp [ d + v ] = mymax ( dp [ d + v ], val ) # } # dp [ myabs ( d - v )] = mymax ( dp [ myabs ( d - v )], val + mymin ( v , d )) # } # } # } # return dp [ 0 ]
this . stopTime = time . Now (). UnixNano () # this . running = false
if b == 0 { # return a # } # return Recursive ( b , a % b )
return (* int 3 2 )( unsafe . Pointer ( uintptr ( unsafe . Pointer ( ptr )) + offset * 4 ))
dataToJSON := make ( map [ string ] interface {}) # # dataToJSON [" STR "] = " STR " # dataToJSON [" STR "] = 5 5 . 5 5 # # jsonString , _ := json . Marshal ( dataToJSON ) # var jsonToMap map [ string ] interface {} # json . Unmarshal ( jsonString , & jsonToMap ) # # fmt . Println ( jsonToMap ) # str := jsonToMap [" STR "].( string ) # num := jsonToMap [" STR "].( float 6 4 ) # fmt . Println ( str ) # fmt . Println ( num ) #
res := make ([] int , num + 1 ) # for i := 1 ; i <= num ; i ++ { # res [ i ] = res [ i >> 1 ] + i & 1 # } # return res
m . keyL = list . New () # m . m = make ( map [ interface {}] interface {}) # return m
var seenNeg , seenDecimal , seenE , seenDigit bool # for _ , r := range str { # switch { # case r == '-': # if seenNeg || seenDigit { # return false # } # seenNeg = true # case r == '.': # if seenDecimal || ! seenDigit { # return false # } # seenDecimal = true # case r == ' e ' || r == ' E ': # if seenE || ! seenDigit { # return false # } # seenE = true # case r >= ' 0 ' && r <= ' 9 ': # seenDigit = true # default : # return false # } # } # return seenDigit
if x < 0 || ( x > 0 && x % 1 0 == 0 ) { # return false # } # # var y int # for x > y { # y = y * 1 0 + x % 1 0 # x /= 1 0 # } # return x == y || x == y / 1 0
if ! n . isFull () { # panic (" STR ") # } # n 2 := bt . bTreeIf . newNode ( bt . t ) # n 2 . p = n . p # n 2 . isLeaf = n . isLeaf # n 2 . keyValue = append ( make ([]* keyValue , 0 , 0 ), n . keyValue [ n . t :]...) # n 2 . c = append ( make ([]* bTreeNode , 0 , 0 ), n . c [ n . t :]...) # for _ , v := range n 2 . c { # if v != nil { # v . p = n 2 # } # } # i := n . p . addKeyValue ( n . keyValue [ n . t - 1 ]. key , n . keyValue [ n . t - 1 ]. value ) # n . keyValue = n . keyValue [: n . t - 1 ] # n . c = n . c [: n . t ] # n . p . c [ i ] = n # n . p . c [ i + 1 ] = n 2 # return i
m := map [ byte ] int { # ' I ': 1 , # ' V ': 5 , # ' X ': 1 0 , # ' L ': 5 0 , # ' C ': 1 0 0 , # ' D ': 5 0 0 , # ' M ': 1 0 0 0 , # } # ans , p := 0 , 0 # for i := 0 ; i < len ( s ); i ++ { # k := s [ i ] # if v , ok := m [ k ]; ok { # if v > p { # ans -= p * 2 # } # ans += v # p = v # } # } # return ans
p . pendingBytes = append ( p . pendingBytes , bs ...)
var xMask , yMask int 3 2 # xMask = b # xMask |= xMask << 1 # xMask |= xMask << 2 # xMask |= xMask << 4 # xMask |= xMask << 8 # xMask |= xMask << 1 6 # yMask = ^ xMask # return ( x & xMask ) | ( y & yMask )
sort . Slice ( costs , func ( i int , j int ) bool { # return costs [ i ][ 1 ]- costs [ i ][ 0 ] > costs [ j ][ 1 ]- costs [ j ][ 0 ] # }) # N := len ( costs ) / 2 # sum := 0 # for i := 0 ; i < N ; i ++ { # sum += costs [ i ][ 0 ] + costs [ i + N ][ 1 ] # } # return sum
n := [] int {} # if len ( nums ) <= 1 { # n = nums # } else { # n = append ( n , nums [ 0 ]) # for i := 1 ; i < len ( nums ); i ++ { # n = append ( n , nums [ i ]+ n [ i - 1 ]) # } # } # return NumArray { # n : n , # }
var buf bytes . Buffer # write (& buf , e ) # return buf . String ()
b := make ([] byte , n ) # for i := 0 ; i < n ; i ++ { # b [ i ] = ' x ' # } # if n % 2 == 0 { # b [ n - 1 ] = ' y ' # } # return string ( b )
if t . Kind () != Array { # panic ( TypeError {" STR "}) # } # # arrayIdentifier := t . stripPrefix () # _ , p := readVarint ( unsafe . Pointer ( uintptr ( unsafe . Pointer (& arrayTypesSidetable )) + uintptr ( arrayIdentifier ))) # # arrayLen , _ := readVarint ( p ) # return int ( arrayLen )
ret := 0 # for i := range nums { # ret ^= nums [ i ] # } # return ret
ans := 0 # if nil == root { # return ans # } # # left := depthOfTree ( root . Left , & ans ) # right := depthOfTree ( root . Right , & ans ) # if left + right > ans { # ans = left + right # } # # return ans
b := [] byte ( s ) # l := 0 # for i , v := range s { # if v == ' ' || i == len ( s )- 1 { # r := i - 1 # if i == len ( s )- 1 { # r = i # } # for l < r { # b [ l ], b [ r ] = b [ r ], b [ l ] # l ++ # r -- # } # l = i + 1 # } # } # return string ( b )
tests := [...] testType { # { # in : [] string {" STR "}, # w : [] string {" STR "}, # want : [] int { 1 }, # }, # { # in : [] string {" STR ", " STR "}, # w : [] string {" STR ", " STR ", " STR ", " STR "}, # want : [] int { 1 , 2 }, # }, # } # for _ , tt := range tests { # got := numSmallerByFrequency ( tt . in , tt . w ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
n := len ( nums ) # if 0 == n || 1 == n { # return n # } # # var res , l , r int # # for r < n { # if res < r - l + 1 { # res = r - l + 1 # } # if r + 1 < n && nums [ r + 1 ] <= nums [ r ] { # l = r + 1 # } # r ++ # } # return res
m , n := len ( M ), len ( M [ 0 ]) # N := make ([][] int , m ) # for i := range N { # N [ i ] = make ([] int , n ) # } # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # N [ i ][ j ] = getSurrounding ( M , i , j , m , n ) # } # } # return N
b := [] byte ( s ) # for i , j := 0 , len ( b )- 1 ; i < j ; { # if isVowels ( b [ i ]) && isVowels ( b [ j ]) { # b [ i ], b [ j ] = b [ j ], b [ i ] # i ++ # j -- # } else if isVowels ( b [ i ]) && ! isVowels ( b [ j ]) { # j -- # } else if ! isVowels ( b [ i ]) && isVowels ( b [ j ]) { # i ++ # } else { # i ++ # j -- # } # } # return string ( b )
f := squares () # fmt . Println ( f ()) # fmt . Println ( f ()) # fmt . Println ( f ()) # fmt . Println ( f ())
if len ( a ) < 3 { # return 0 # } # # slices := [] int {} # slice := 2 # preInterval := a [ 1 ] - a [ 0 ] # for i := 2 ; i < len ( a ); i ++ { # interval := a [ i ] - a [ i - 1 ] # if interval == preInterval { # slice ++ # if len ( a )- 1 == i && slice > 2 { # slices = append ( slices , slice ) # } # continue # } # if slice > 2 { # slices = append ( slices , slice ) # } # slice = 2 # preInterval = interval # } # # f := func ( slice int ) int { # if slice < 3 { # return 0 # } # num := 0 # for i := 3 ; i <= slice ; i ++ { # num += ( slice - i ) + 1 # } # return num # } # # sum := 0 # for _ , slice := range slices { # sum += f ( slice ) # } # return sum
if height < tablesize && table [ height ] != 0 { # return table [ height ] # } # # next := 0 # word := strconv . Itoa ( height ) # # for i := 0 ; i < len ( word ); i ++ { # is , _ := strconv . Atoi ( word [ i : i + 1 ]) # next += factorial ( is ) # } # # # if height < tablesize { # table [ height ] = hite ( next ) + 1 # } # # return hite ( next ) + 1
tmp := strings . Trim ( s , " STR ") # start , end , ans := len ( tmp )- 1 , len ( tmp )- 1 , " STR " # for start >= 0 { # for start >= 0 && tmp [ start ] != ' ' { # start -- # } # ans += tmp [ start + 1 : end + 1 ] + " STR " # for start >= 0 && tmp [ start ] == ' ' { # start -- # } # end = start # } # return strings . Trim ( ans , " STR ")
n := len ( nums ) # sum , max := nums [ 0 ], nums [ 0 ] # for i := 1 ; i < n ; i ++ { # sum += nums [ i ] # if nums [ i ] > max { # max = nums [ i ] # } # } # avg := sum / k # if sum % k != 0 || avg < max { # return false # } # sort . Sort ( sort . Reverse ( sort . IntSlice ( nums ))) # used := make ([] bool , n ) # var dfs func ( int , int , int ) bool # dfs = func ( k , start , cur int ) bool { # if k == 1 { # return true # } # if cur == avg { # return dfs ( k - 1 , 0 , 0 ) # } # for i := start ; i < n ; i ++ { # if ! used [ i ] && cur + nums [ i ] <= avg { # used [ i ] = true # if dfs ( k , i + 1 , cur + nums [ i ]) { # return true # } # used [ i ] = false # } # } # return false # } # return dfs ( k , 0 , 0 )
StoreUint 8 (& r . Reg , value )
if bits < 1 { # return nil # } else if bits == 1 { # return [] string {" STR ", " STR "} # } # smaller := GrayCodes ( bits - 1 ) # result := make ([] string , 0 , 2 * len ( smaller )) # for _ , entry := range smaller { # result = append ( result , fmt . Sprintf (" STR ", entry )) # } # for i := range smaller { # result = append ( result , fmt . Sprintf (" STR ", smaller [ len ( smaller )- 1 - i ])) # } # return result
m := map [ int ] bool {} # var res [] int # for _ , n := range nums 1 { # m [ n ] = true # } # for _ , n := range nums 2 { # if m [ n ] { # delete ( m , n ) # res = append ( res , n ) # } # } # return res
testCases := [][] string { # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # {}, # {" STR "}, # } # # expected := [] string { # " STR ", # " STR ", # " STR ", # " STR ", # } # # for index , strs := range testCases { # if res := longestCommonPrefix ( strs ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
for _ , tier := range al { # for _ , url := range tier { # if url != " STR "" { # return true # } # } # } # return false
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 3 , 4 , 5 , 1 , 2 }, 1 }, # {" STR ", [] int { 4 , 5 , 6 , 7 , 0 , 1 , 2 }, 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := findMin ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
qs := [] question 2 6 0 { # # { # para 2 6 0 {[] int { 1 , 2 , 1 , 3 , 2 , 5 }}, # ans 2 6 0 {[] int { 3 , 5 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 6 0 , q . para 2 6 0 # fmt . Printf (" STR ", p , singleNumberIII ( p . s )) # } # fmt . Printf (" STR ")
var tests = [] struct { # numbers [] int # target int # indices [] int # }{ # {[] int { 2 , 7 , 1 1 , 1 5 }, 9 , [] int { 1 , 2 }}, # {[] int { 2 , 3 , 4 , 6 }, 6 , [] int { 1 , 3 }}, # {[] int { 2 , 3 , 4 , 7 }, 8 , nil }, # { nil , 8 , nil }, # } # # for _ , tt := range tests { # indices := twoSum ( tt . numbers , tt . target ) # if reflect . DeepEqual ( indices , tt . indices ) == false { # t . Errorf (" STR ", tt . numbers , tt . target , indices , tt . indices ) # } # }
return v . flags & valueFlagExported != 0
return & Kernel { make ([] float 6 4 , width * height ), width , height }
b := (* root ). Right # bl := b . Left # b . Left = * root # # (* root ). Right = bl # (* root ). Height = height (* root ) # b . Height = height ( b ) # * root = b #
for _ , v := range fs { # v . Write ( str ) # }
total , c := M [ i ][ j ], 1 # if i - 1 >= 0 { # total += M [ i - 1 ][ j ] # c ++ # if j - 1 >= 0 { # total += M [ i - 1 ][ j - 1 ] # c ++ # } # if j + 1 < n { # total += M [ i - 1 ][ j + 1 ] # c ++ # } # } # if i + 1 < m { # total += M [ i + 1 ][ j ] # c ++ # if j - 1 >= 0 { # total += M [ i + 1 ][ j - 1 ] # c ++ # } # if j + 1 < n { # total += M [ i + 1 ][ j + 1 ] # c ++ # } # } # if j - 1 >= 0 { # total += M [ i ][ j - 1 ] # c ++ # } # if j + 1 < n { # total += M [ i ][ j + 1 ] # c ++ # } # return total / c
type Server struct { # Name string ` structs :" STR "` # ID int 3 2 ` structs :" STR "` # Location string # } # # s := & Server { # Location : " STR ", # } # # m := Values ( s ) # # fmt . Printf (" STR ", m )
if nil == data || len ( data ) <= 0 { # return 0 , false # } # var currentSum , greatestSum int # for i := 0 ; i < len ( data ); i ++ { # if currentSum <= 0 { # currentSum = data [ i ] # } else { # currentSum += data [ i ] # } # if currentSum > greatestSum { # greatestSum = currentSum # } # } # return greatestSum , true
m := make ( map [[ 5 2 ] int ] bool ) # for _ , s := range A { # var count [ 5 2 ] int # for i , char := range s { # count [ int ( char )-' a '+ 2 6 *( i % 2 )]++ # } # m [ count ] = true # } # return len ( m )
sum , max := 0 , nums [ 0 ] # for i := 0 ; i < len ( nums ); i ++ { # if sum < 0 { # sum = nums [ i ] # } else { # sum += nums [ i ] # } # # if max < sum { # max = sum # } # } # # return max
size := len ( A ) # # count := make ( map [ int ] int , size ) # for _ , a := range A { # count [ a ]++ # } # # cands := make ( map [ int ][] int , size ) # for x := range count { # for y := range count { # if isSquare ( x + y ) { # cands [ x ] = append ( cands [ x ], y ) # } # } # } # # res := 0 # var dfs func ( int , int ) # dfs = func ( x , remain int ) { # if remain == 0 { # res ++ # return # } # count [ x ]-- # for _ , y := range cands [ x ] { # if count [ y ] > 0 { # dfs ( y , remain - 1 ) # } # } # count [ x ]++ # } # # for x := range count { # dfs ( x , size - 1 ) # } # # return res
cnt := 0 # var d int # for _ , d = range data { # if cnt == 0 { # switch { # case d >> 3 == 3 0 : # cnt = 3 # case d >> 4 == 1 4 : # cnt = 2 # case d >> 5 == 6 : # cnt = 1 # case d >> 7 > 0 : # return false # } # } else { # if d >> 6 != 2 { # return false # } # cnt -- # } # } # # return 0 == cnt
set := map [ int ] int {} # length := 0 # # for n != 0 { # if n < d { # n *= 1 0 # continue # } # n = n % d # if set [ n ] > 0 { # return length # } else { # set [ n ] = 1 # } # length += 1 # } # return 0
left := len ( a ) - 2 # for 0 <= left && a [ left ] >= a [ left + 1 ] { # left -- # } # # # reverse ( a , left + 1 ) # # if left == - 1 { # return # } # # # right := search ( a , left + 1 , a [ left ]) # a [ left ], a [ right ] = a [ right ], a [ left ]
if dp [ t ] > 0 { # return dp [ t ] # } # # n := uint ( math . Log 2 ( float 6 4 ( t ))) + 1 # # if t == 1 << n - 1 { # dp [ t ] = int ( n ) # } else { # dp [ t ] = racecar ( 1 << n - 1 - t ) + int ( n ) + 1 # # for m := uint ( 0 ); m < n - 1 ; m ++ { # dp [ t ] = min ( dp [ t ], racecar ( t - 1 <<( n - 1 )+ 1 << m )+ int ( n - 1 )+ 1 + int ( m )+ 1 ) # # } # } # # return dp [ t ]
data := & Node { data : i } # if list . head != nil { # list . head . prev = data # data . next = list . head # } # list . head = data
random := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # array := make ([] int , random . Intn ( 1 0 0 - 1 0 )+ 1 0 ) # for i := range array { # array [ i ] = random . Intn ( 1 0 0 ) # } # SortArray ( array ) # for _ , value := range array { # result := JumpSearch ( array , value ) # if result == - 1 { # t . Fail () # } # }
g := make ([][][ 2 ] int , n ) # for _ , f := range flights { # g [ f [ 0 ]] = append ( g [ f [ 0 ]], [ 2 ] int { f [ 1 ], f [ 2 ]}) # } # p 1 , p 2 := make ([] int , n ), make ([] int , n ) # q 1 , q 2 := [] int { src }, [] int {} # p 2 [ src ] = 1 # for len ( q 1 ) != 0 && K >= 0 { # for _ , f := range q 1 { # p 1 [ f ] = p 2 [ f ] # } # for _ , f := range q 1 { # p := p 1 [ f ] # for _ , nn := range g [ f ] { # price := p + nn [ 1 ] # dst := nn [ 0 ] # if p 2 [ dst ] == 0 || p 2 [ dst ] > price { # p 2 [ dst ] = price # q 2 = append ( q 2 , dst ) # } # } # } # q 1 , q 2 = q 2 , q 1 [: 0 ] # K -- # } # return p 2 [ dst ] - 1
bytes , err := dataRatesJsonBytes () # if err != nil { # return nil , err # } # # info := bindataFileInfo { name : " STR ", size : 3 3 3 , mode : os . FileMode ( 4 2 0 ), modTime : time . Unix ( 1 4 5 6 5 9 1 4 3 2 , 0 )} # a := & asset { bytes : bytes , info : info } # return a , nil
res := [] int {} # if root == nil { # return res # } # queue := []* TreeNode { root } # # res = [] int { root . Val } # for len ( queue ) > 0 { # l := len ( queue ) # flag := 0 # for i := 0 ; i < l ; i ++ { # node := queue [ i ] # if node . Right != nil { # if flag == 0 { # flag = node . Right . Val # } # queue = append ( queue , node . Right ) # } # if node . Left != nil { # if flag == 0 { # flag = node . Left . Val # } # queue = append ( queue , node . Left ) # } # } # if flag != 0 { # res = append ( res , flag ) # } # queue = queue [ l :] # } # return res
lo , hi := 0 , len ( S ) # ans := make ([] int , hi , hi + 1 ) # for i , v := range S { # if v == ' I ' { # ans [ i ] = lo # lo ++ # } else { # ans [ i ] = hi # hi -- # } # } # return append ( ans , lo )
n := len ( s ) # if n < 2 { # return n # } # max := 0 # for i := 0 ; i < n ; i ++ { # mp := make ( map [ uint 8 ] int ) # mp [ s [ i ]] = 1 # for j := i + 1 ; j < n ; j ++ { # if _ , ok := mp [ s [ j ]]; ! ok { # mp [ s [ j ]] = 1 # } else { # break # } # } # if max < len ( mp ) { # max = len ( mp ) # } # } # return max
for i := 1 ; i <= height ; i ++ { # # numerator *= 1 0 # numerator = numerator % denominator # # } # # return numerator
s := " STR " # tt := " STR " # # fmt . Printf (" STR ", findTheDifference ( s , tt ))
return big . NewInt ( int 6 4 ( x ))
cases := [] struct { # name string # inputs int # expect int # }{ # {" STR ", 1 3 , 4 }, # {" STR ", 2 4 , 5 }, # {" STR ", 3 5 , 6 }, # {" STR ", 9 9 9 , 2 }, # {" STR ", 9 9 9 9 , 1 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if n < 0 { # x = 1 / x # n = - n # } # pow := 1 . 0 # for n != 0 { # if n & 1 != 0 { # pow *= x # } # x *= x # n >>= 1 # } # return pow
var stack []* TreeNode # var prev , newRoot * TreeNode # node := root # for len ( stack ) > 0 || node != nil { # for node != nil { # stack = append ( stack , node ) # node = node . Left # } # # node = stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # if prev != nil { # prev . Right = node # } else { # newRoot = node # } # # prev = node # node = node . Right # prev . Left , prev . Right = nil , nil # } # # return newRoot
fmt . Println ( fairCandySwap ([] int { 1 , 1 }, [] int { 2 , 2 }))
ret := [] int {} # idxArray := [] int {} # for i := range nums { # for len ( idxArray ) != 0 && idxArray [ 0 ] <= i - k { # idxArray = idxArray [ 1 :] # } # j := len ( idxArray ) - 1 # for ; j >= 0 && nums [ idxArray [ j ]] <= nums [ i ]; j -- { # } # idxArray = append ( idxArray [: j + 1 ], i ) # if i >= k - 1 { # ret = append ( ret , nums [ idxArray [ 0 ]]) # } # } # return ret
minimum , maximum , res := nums [ 0 ], nums [ 0 ], nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] < 0 { # maximum , minimum = minimum , maximum # } # maximum = max ( nums [ i ], maximum * nums [ i ]) # minimum = min ( nums [ i ], minimum * nums [ i ]) # res = max ( res , maximum ) # } # return res
switch e := e .( type ) { # case literal : # fmt . Fprintf ( buf , " STR ", e ) # # case Var : # fmt . Fprintf ( buf , " STR ", e ) # # case unary : # fmt . Fprintf ( buf , " STR ", e . op ) # write ( buf , e . x ) # buf . WriteByte (" STR ") # # case binary : # buf . WriteByte (" STR ") # write ( buf , e . x ) # fmt . Fprintf ( buf , " STR ", e . op ) # write ( buf , e . y ) # buf . WriteByte (" STR ") # # case call : # fmt . Fprintf ( buf , " STR ", e . fn ) # for i , arg := range e . args { # if i > 0 { # buf . WriteString (" STR ") # } # write ( buf , arg ) # } # buf . WriteByte (" STR ") # # default : # panic ( fmt . Sprintf (" STR ", e )) # }
return Solution { nums : nums }
if len ( a ) < len ( b ) { # a , b = b , a # } # l := len ( a ) # # isA := trans ( a , l ) # isB := trans ( b , l ) # # return makeString ( add ( isA , isB ))
qs := [] question 2 2 4 { # # { # para 2 2 4 {" STR "}, # ans 2 2 4 { 2 }, # }, # { # para 2 2 4 {" STR "}, # ans 2 2 4 { 3 }, # }, # # { # para 2 2 4 {" STR "}, # ans 2 2 4 { 2 3 }, # }, # # { # para 2 2 4 {" STR "}, # ans 2 2 4 { 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 2 4 , q . para 2 2 4 # fmt . Printf (" STR ", p , calculate ( p . one )) # } # fmt . Printf (" STR ")
primes := [] int { 2 , 3 , 5 , 7 } # truncatablePrimes , reducedNumbers := [] int {}, [] int {} # number := 1 0 # var isTruncatablePrime bool # # for len ( truncatablePrimes ) < 1 1 { # if big . NewInt ( int 6 4 ( number )). ProbablyPrime ( 2 0 ) { # primes = append ( primes , number ) # } # # isTruncatablePrime = true # reducedNumbers = numbersFromNumber ( number ) # for i := 0 ; i < len ( reducedNumbers ) && isTruncatablePrime ; i ++ { # if ! Contains ( primes , reducedNumbers [ i ]) { # isTruncatablePrime = false # } # } # if isTruncatablePrime { # fmt . Println ( number ) # truncatablePrimes = append ( truncatablePrimes , number ) # } # # number ++ # } # # sum := 0 # for i := 0 ; i < len ( truncatablePrimes ); i ++ { # sum += truncatablePrimes [ i ] # } # fmt . Printf (" STR ", sum )
q . list = new ( SingleList ) # q . list . Init ()
return ( num > 0 && (( num & ( num - 1 )) == 0 ))
res := make ([] int , n ) # s := [] int {} # prev := 0 # for _ , log := range logs { # parts := strings . Split ( log , " STR ") # i , _ := strconv . Atoi ( parts [ 0 ]) # t , _ := strconv . Atoi ( parts [ 2 ]) # if len ( s ) != 0 { # res [ s [ len ( s )- 1 ]] += t - prev # } # prev = t # if parts [ 1 ] == " STR " { # s = append ( s , i ) # } else { # res [ s [ len ( s )- 1 ]]++ # s = s [: len ( s )- 1 ] # prev ++ # } # } # return res
tests := [...] testType { # { # in : " STR ", # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR " , # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # { # in : " STR " , # want : " STR ", # }, # { # in : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := simplifyPath ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
ans := 0 # for _ , i := range J { # for _ , j := range S { # if i == j { # ans ++ # } # # } # } # return ans
db := database {" STR ": 5 0 , " STR ": 5 } # http . HandleFunc (" STR ", db . list ) # http . HandleFunc (" STR ", db . price ) # log . Fatal ( http . ListenAndServe (" STR ", nil ))
if N >= 4 8 0 0 { # return 1 # } # n := ( N + 2 4 ) / 2 5 # m := make ([][] float 6 4 , n + 1 ) # for i := 0 ; i < n + 1 ; i ++ { # m [ i ] = make ([] float 6 4 , n + 1 ) # } # var f func ( int , int ) float 6 4 # f = func ( a , b int ) float 6 4 { # if a <= 0 && b <= 0 { # return 0 . 5 # } # if a <= 0 { # return 1 # } # if b <= 0 { # return 0 # } # if m [ a ][ b ] > 0 { # return m [ a ][ b ] # } # m [ a ][ b ] = 0 . 2 5 * ( f ( a - 4 , b ) + f ( a - 3 , b - 1 ) + f ( a - 2 , b - 2 ) + f ( a - 1 , b - 3 )) # return m [ a ][ b ] # } # return f ( n , n )
l := lcm ( p , q ) # if ( l / q )% 2 == 0 { # return 2 # } # return ( l / p ) % 2
if ! condition { # _ , file , line , _ := runtime . Caller ( 1 ) # fmt . Printf (" STR "+ msg +" STR ", append ([] interface {}{ filepath . Base ( file ), line }, v ...)...) # tb . FailNow () # }
if len ( needle ) == 0 { # return 0 # } # next := getNext ( needle ) # var i , j int # for i < len ( haystack ) && j < len ( needle ) { # if j == - 1 || haystack [ i ] == needle [ j ] { # j ++ # i ++ # } else { # j = next [ j ] # } # } # # if j == len ( needle ) { # return i - j # } # return - 1
defer wg . Done () # # for { # ball , ok := <- court # if ! ok { # fmt . Printf (" STR ", name ) # return # } # # n := rand . Intn ( 1 0 0 ) # if n % 1 3 == 0 { # fmt . Printf (" STR ", name ) # # close ( court ) # return # } # # fmt . Printf (" STR ", name , ball ) # ball ++ # # court <- ball # }
if list == nil || list . Size == 0 || index > list . Size - 1 { # return nil # } # # list . mutex . RLock () # defer list . mutex . RUnlock () # # if index == 0 { # return list . Head # } # node := list . Head # var i uint # for i = 0 ; i < index ; i ++ { # node = node . Next # } # return node
sort . Ints ( nums ) # # closest := nums [ 0 ] + nums [ 1 ] + nums [ 2 ] # for i := 0 ; i < len ( nums )- 2 ; i ++ { # if i > 0 && nums [ i ] == nums [ i - 1 ] { # continue # } # # lo , hi := i + 1 , len ( nums )- 1 # for lo < hi { # sum := nums [ i ] + nums [ lo ] + nums [ hi ] # switch { # case sum < target : # lo ++ # case sum > target : # hi -- # default : # return sum # } # # if diff ( sum , target ) < diff ( closest , target ) { # closest = sum # } # } # } # return closest
b := make ([] bool , n ) # var primes [] int # # for i := 2 ; i < n ; i ++ { # if b [ i ] == true { # continue # } # # primes = append ( primes , i ) # # for k := i * i ; k < n ; k += i { # b [ k ] = true # } # } # # return primes
tests := [...] testType { # { # in : [] int { 7 , 1 , 5 , 3 , 6 , 4 }, # want : 5 , # }, # { # in : [] int { 7 , 6 , 4 , 3 , 1 }, # want : 0 , # }, # { # in : [] int { 1 , 1 , 1 , 1 , 1 }, # want : 0 , # }, # { # in : [] int {}, # want : 0 , # }, # } # for _ , tt := range tests { # got := maxProfit ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if N < 2 { # return N # } # # used := make ([] bool , N + 1 ) # # var dfs func ( int ) int # dfs = func ( n int ) int { # if n == 1 { # return 1 # } # res , l := 0 , len ( used ) # for i := n ; i < l ; i += n { # if used [ i ] == false { # used [ i ] = true # res += dfs ( n - 1 ) # used [ i ] = false # } # } # for i := 2 ; i <= l ; i ++ { # t := n / i # if n % i == 0 && used [ t ] == false { # used [ t ] = true # res += dfs ( n - 1 ) # used [ t ] = false # } # } # return res # } # return dfs ( N )
println (" STR ", s . a . aa , s . a . ab , s . b )
indir := os . Args [ 1 ] # outdir := os . Args [ 2 ] # err := generate ( indir , outdir ) # if err != nil { # fmt . Fprintln ( os . Stderr , err ) # os . Exit ( 1 ) # }
b := createFilledBucket ( time . Now (). Add ( time . Duration ( 4 ))) # # cpu := runtime . GOMAXPROCS ( 0 ) # ch := make ( chan bool ) # worker := func () { # for i := 0 ; i < bb . N / cpu ; i ++ { # expire := time . Now (). Add ( time . Duration ( 4 * time . Second )) # b . Set ( randomString ( 2 ), " STR ", expire ) # } # ch <- true # } # for i := 0 ; i < cpu ; i ++ { # go worker () # } # for i := 0 ; i < cpu ; i ++ { # _ = <- ch # }
cur := nums [ 0 ] # sum := nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # if sum >= 0 { # sum += nums [ i ] # } else { # sum = nums [ i ] # } # if cur < sum { # cur = sum # } # } # return cur
if len ( grid ) == 0 { # return 0 # } # ret := 0 # for i := 0 ; i < len ( grid ); i ++ { # for j := 0 ; j < len ( grid [ 0 ]); j ++ { # if grid [ i ][ j ] == ' 1 ' { # helper ( grid , i , j ) # ret ++ # } # } # } # return ret
type args struct { # n int # } # tests := [] struct { # name string # args args # want bool # }{ # } # for _ , tt := range tests { # t . Run ( tt . name , func ( t * testing . T ) { # if got := isPowerOfThree ( tt . args . n ); got != tt . want { # t . Errorf (" STR ", got , tt . want ) # } # }) # }
have := [ 1 2 8 ] int {} # need := [ 1 2 8 ] int {} # for i := range t { # need [ t [ i ]]++ # } # # size , total := len ( s ), len ( t ) # # min := size + 1 # res := " STR " # # for i , j , count := 0 , 0 , 0 ; j < size ; j ++ { # if have [ s [ j ]] < need [ s [ j ]] { # count ++ # } # have [ s [ j ]]++ # # for i <= j && have [ s [ i ]] > need [ s [ i ]] { # have [ s [ i ]]-- # i ++ # } # # width := j - i + 1 # if count == total && min > width { # min = width # res = s [ i : j + 1 ] # } # # } # # return res
fmt . Println ( maxDistToClosest ([] int { 1 , 0 , 0 , 0 }))
dict := [] string {" STR ", " STR "} # obj := Constructor 6 7 6 () # obj . BuildDict ( dict ) # fmt . Printf (" STR ", obj ) # fmt . Println ( obj . Search (" STR ")) # fmt . Println ( obj . Search (" STR ")) # fmt . Println ( obj . Search (" STR ")) # fmt . Println ( obj . Search (" STR ")) # fmt . Println ( obj . Search (" STR ")) # fmt . Println ( obj . Search (" STR "))
u . email = email
var sb strings . Builder # var count int # var last rune # for i , r := range str { # switch { # case i == 0 : # count ++ # last = r # continue # case r == last : # count ++ # default : # sb . WriteString ( strconv . Itoa ( count )) # sb . WriteString ( string ( last )) # count = 1 # last = r # } # } # sb . WriteString ( strconv . Itoa ( count )) # sb . WriteString ( string ( last )) # return sb . String ()
t . Parallel () # for _ , tc := range testcases { # if result := ReverseWords ( tc . input ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
return alertCounter ( value )
for _ , test := range testCases { # t . Run ( test . name , func ( t * testing . T ) { # if output := MoserDeBruijnSequence ( test . inputNum ); ! reflect . DeepEqual ( output , test . expected ) { # t . Errorf (" STR ", test . inputNum , test . expected , output ) # } # }) # }
ans := make ([] int , 0 ) # for _ , v := range findNums { # ans = append ( ans , nextMax ( v , nums )) # } # return ans
l := make ([] int , k + 1 ) # return MyCircularDeque { start : 0 , end : 0 , cap : k + 1 , l : l }
sum , last , toAdd := 1 , 1 , 0 # for i := 1 ; i <= 5 0 0 ; i ++ { # toAdd = i * 2 # for j := 0 ; j < 4 ; j ++ { # sum += ( last + toAdd ) # last = last + toAdd # } # } # fmt . Println (" STR ", sum )
r := regexp . MustCompile (" STR ") # res := [] string {} # # for _ , word := range words { # if r . MatchString ( word ) { # res = append ( res , word ) # } # } # return res
fmt . Println ( combinationSum 3 ( 4 , 2 4 )) # fmt . Println ( combinationSum 3 ( 3 , 7 )) # fmt . Println ( combinationSum 3 ( 3 , 9 ))
n := len ( citations ) # l , r := 0 , n - 1 # for l <= r { # m := ( l + r ) / 2 # if citations [ m ] >= n - m { # r = m - 1 # } else { # l = m + 1 # } # } # return n - l
ball := make ([] int , 2 6 ) # for i := 0 ; i < len ( hand ); i ++ { # ball [ hand [ i ]-' A ']++ # } # # res := dfs ( board +" STR ", ball ) # if res == maxCount { # return - 1 # } # return res
for i , left := range rects { # for j , right := range rects { # if j > i { # if left . TopLeftX > right . TopLeftX { # left , right = right , left # } # if right . TopLeftX < left . TopLeftX + left . Width { # up , dn := left , right # if up . TopLeftY < dn . TopLeftY { # up , dn = dn , up # } # if dn . TopLeftY > up . TopLeftY - up . Height { # return true # } # } # } # } # } # return false
first := 1 # if n % 2 == 0 { # first = 2 # } # # for i := first ; n > 0 ; i *= 4 { # n -= i # } # # if n == 0 { # return true # } # # return false #
if root == nil { # return 0 # } # if root . Left == nil { # return sumOfLeftLeaves ( root . Right ) # } # if root . Left . Left == nil && root . Left . Right == nil { # return root . Left . Val + sumOfLeftLeaves ( root . Right ) # } # return sumOfLeftLeaves ( root . Left ) + sumOfLeftLeaves ( root . Right )
position := generateHash ( key ) # current := table . data [ position ] # for current != nil { # if current . key == key { # return current . data , true # } # current = current . next # } # return 0 , false
m , ans := make ( map [ int ] int ), 0 # first , max := make ( map [ int ] int ), 0 # for i , v := range nums { # m [ v ]++ # if first [ v ] == 0 { # first [ v ] = i + 1 # } # if m [ v ] >= max { # t := i - first [ v ] + 2 # if m [ v ] > max || ( m [ v ] == max && t < ans ) { # ans = t # } # max = m [ v ] # } # } # return ans
const freezingF , boilingF = 3 2 . 0 , 2 1 2 . 0 # fmt . Printf (" STR ", freezingF , fToC ( freezingF )) # fmt . Printf (" STR ", boilingF , fToC ( boilingF ))
Problem 2 ( 4 0 0 0 0 0 0 )
n := len ( bits ) # i := 0 # for i < n - 1 { # if bits [ i ] == 1 { # i += 2 # } else { # i ++ # } # } # return i == n - 1
var one , two , three int # for i := range nums { # three = two & nums [ i ] # two = ^ three & ( two | one & nums [ i ]) # one = ^ three & ( one ^ nums [ i ]) # } # return one
if len ( nums ) == 0 { # return 0 # } # # var i int # for j := 1 ; j < len ( nums ); j ++ { # if nums [ i ] != nums [ j ] { # i ++ # nums [ i ] = nums [ j ] # } # } # return i + 1
sort . Ints ( nums ) # solution := [] int {} # ret := [][] int {[] int {}} # ret = append ( ret , subsetsI ( nums , solution , - 1 )...) # return ret
for _ , tc := range testCases { # t . Run ( tc . name , func ( t * testing . T ) { # actual := Naive ( tc . input , tc . pattern ) # if ! reflect . DeepEqual ( actual , tc . expected ) { # t . Errorf (" STR ", tc . pattern , tc . input , tc . expected , actual ) # } # }) # }
starttime := time . Now () # # sum := 0 # for i := 0 ; i < 1 0 0 0 ; i ++ { # if i % 3 == 0 || i % 5 == 0 { # sum += i # } # } # # fmt . Println ( sum ) # # fmt . Println (" STR ", time . Since ( starttime ))
m , c := nums [ 0 ], 1 # for _ , n := range nums [ 1 :] { # if m == n { # c ++ # } else { # if c --; c == 0 { # m = n # c = 1 # } # } # } # return m
sort . Ints ( nums ) # var max , count int # count = 1 # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] == nums [ i - 1 ]+ 1 { # count ++ # } else if count > max { # max = count # count = 1 # } # } # if count > max { # max = count # } # return max
srcFile , err := os . Open ( srcFileName ) # if err != nil { # return fmt . Errorf (" STR ", err ) # } # defer srcFile . Close () # # dstFile , err := os . Create ( dstFileName ) # if err != nil { # return fmt . Errorf (" STR ", err ) # } # defer dstFile . Close () # # _ , err = io . Copy ( dstFile , srcFile ) # if err != nil { # return fmt . Errorf (" STR ", err ) # } # return nil
if p := n . p ; p != nil { # if n . mark { # p . c . Remove ( n ) # h . root . PushLeft ( n ) # n . mark = false # h . cascadingCut ( p ) # } else { # n . mark = true # } # }
m := map [ byte ] byte { # '(': ')', # '[': ']', # '{': '}', # } # l := len ( s ) # stack := make ([] byte , l ) # top := 0 # for i := 0 ; i < l ; i ++ { # switch s [ i ] { # case '(', '[', '{': # stack [ top ] = m [ s [ i ]] # top ++ # case ')', ']', '}': # if top > 0 && stack [ top - 1 ] == s [ i ] { # top -- # } else { # return false # } # } # } # return top == 0
pairs := [...][ 2 ] int {{ 5 , 1 0 1 }, { 1 0 0 1 , 6 6 9 1 7 1 0 0 1 }} # for _ , pair := range pairs { # in , out := pair [ 0 ], pair [ 1 ] # if x := p 2 8 ( in ); x != out { # t . Errorf (" STR ", in , x , out ) # } # }
n := 1 0 0 # sum := ( n + 1 ) * n / 2 # sqsum := pow ( sum , 2 ) # sumsq := 0 # for i := 1 ; i <= n ; i ++ { # sumsq += pow ( i , 2 ) # } # fmt . Println ( sqsum - sumsq )
return formatAtom ( reflect . ValueOf ( value ))
cipherText := [] byte {} # for _ , ch := range plaintext { # cipherText = append ( cipherText , key ^ ch ) # } # return cipherText
cases := [] struct { # name string # inputs int # expect [] string # }{ # {" STR ", 1 5 , [] string { # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # }}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := fizzBuzz ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
fmt . Println (" STR ", i ) # wg . Done ()
court := make ( chan int ) # # wg . Add ( 2 ) # # go player (" STR ", court ) # go player (" STR ", court ) # # court <- 1 # # wg . Wait ()
return q . IDs [ p ] == q . IDs [ r ]
qs := [] question 1 0 2 5 { # { # para 1 0 2 5 { 2 }, # ans 1 0 2 5 { true }, # }, # # { # para 1 0 2 5 { 3 }, # ans 1 0 2 5 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 2 5 , q . para 1 0 2 5 # fmt . Printf (" STR ", p , divisorGame ( p . one )) # } # fmt . Printf (" STR ")
var x , ret int # x = 1 2 3 # ret = 3 2 1 # fmt . Printf (" STR ", x , reverse ( x )) # if reverse ( x ) != ret { # t . Fatalf (" STR ", ret ) # } # # x = - 1 2 3 # ret = - 3 2 1 # fmt . Printf (" STR ", x , reverse ( x )) # if reverse ( x ) != ret { # t . Fatalf (" STR ", ret ) # } # # x = 1 2 0 # ret = 2 1 # fmt . Printf (" STR ", x , reverse ( x )) # if reverse ( x ) != ret { # t . Fatalf (" STR ", ret ) # } # # x = 1 << 3 1 # ret = 0 # fmt . Printf (" STR ", x , reverse ( x )) # if reverse ( x ) != ret { # t . Fatalf (" STR ", ret ) # }
qs := [] question 9 2 2 { # # { # para 9 2 2 {[] int {}}, # ans 9 2 2 {[] int {}}, # }, # # { # para 9 2 2 {[] int { 1 }}, # ans 9 2 2 {[] int {}}, # }, # # { # para 9 2 2 {[] int { 4 , 2 , 5 , 7 }}, # ans 9 2 2 {[] int { 4 , 5 , 2 , 7 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 2 2 , q . para 9 2 2 # fmt . Printf (" STR ", p , sortArrayByParityII ( p . one )) # } # fmt . Printf (" STR ")
m := len ( grid ) # # size := m * m * 4 # u := newUnion ( size ) # # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < m ; j ++ { # baseIndex := ( i * m + j ) * 4 # top := baseIndex + 0 # right := baseIndex + 1 # down := baseIndex + 2 # left := baseIndex + 3 # switch grid [ i ][ j ] { # case '\\': # u . unite ( top , right ) # u . unite ( down , left ) # case '/': # u . unite ( top , left ) # u . unite ( down , right ) # default : # u . unite ( top , right ) # u . unite ( right , down ) # u . unite ( down , left ) # } # if j + 1 < m { # rsl := baseIndex + 4 + 3 # u . unite ( right , rsl ) # } # if i + 1 < m { # dst := baseIndex + 4 * m # u . unite ( down , dst ) # } # } # } # # return u . count
qs := [] question 2 1 9 { # # { # para 2 1 9 {[] int { 1 , 2 , 3 , 1 }, 3 }, # ans 2 1 9 { true }, # }, # # { # para 2 1 9 {[] int { 1 , 0 , 0 , 1 }, 1 }, # ans 2 1 9 { true }, # }, # # { # para 2 1 9 {[] int { 1 , 2 , 3 , 1 , 2 , 3 }, 2 }, # ans 2 1 9 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 1 9 , q . para 2 1 9 # fmt . Printf (" STR ", p , containsNearbyDuplicate ( p . one , p . k )) # } # fmt . Printf (" STR ")
return ( 4 * n ) - 4
isEven ( 8 )
var ret [] byte # var s [] byte # # s = [] byte (" STR ") # ret = [] byte (" STR ") # reverseString ( s ) # for i , v := range s { # if v != ret [ i ] { # t . Fatalf (" STR ", ret ) # } # }
if ! reflect . DeepEqual ( exp , act ) { # _ , file , line , _ := runtime . Caller ( 1 ) # fmt . Printf (" STR ", filepath . Base ( file ), line , exp , act ) # tb . FailNow () # }
m , n := len ( s 1 ), len ( s 2 ) # if m + n != len ( s 3 ) { # return false # } # # dp := make ([] bool , n + 1 ) # for i := 0 ; i <= m ; i ++ { # for j := 0 ; j <= n ; j ++ { # if i == 0 && j == 0 { # dp [ 0 ] = true # } else if i == 0 { # dp [ j ] = dp [ j - 1 ] && s 2 [ j - 1 ] == s 3 [ i + j - 1 ] # } else if j == 0 { # dp [ j ] = dp [ j ] && s 1 [ i - 1 ] == s 3 [ i + j - 1 ] # } else { # dp [ j ] = ( dp [ j ] && s 1 [ i - 1 ] == s 3 [ i + j - 1 ]) || # ( dp [ j - 1 ] && s 2 [ j - 1 ] == s 3 [ i + j - 1 ]) # } # } # } # return dp [ n ]
defer TimeTaken ( time . Now (), " STR ") # # for i := 2 0 ; ; i += 2 0 { # if i % 1 9 != 0 { # continue # } else if i % 1 7 != 0 { # continue # } else if i % 1 3 != 0 { # continue # } else if i % 1 1 != 0 { # continue # } else if i % 7 != 0 { # continue # } else if i % 1 6 != 0 { # continue # } else if i % 1 8 != 0 { # continue # } else if i % 9 != 0 { # continue # } else if i % 4 != 0 { # continue # } else if i % 8 != 0 { # continue # } else { # fmt . Println ( i ) # break # } # }
result := make ([][] int , 0 ) # cur := make ([] int , 0 ) # return helper 7 7 ( n , k , 1 , cur , result )
r := [] rune ( s ) # for i , j := 0 , len ( r )- 1 ; i < len ( r )/ 2 ; i , j = i + 1 , j - 1 { # r [ i ], r [ j ] = r [ j ], r [ i ] # } # return string ( r )
qs := [] question 3 7 1 { # # { # para 3 7 1 { 1 , 2 }, # ans 3 7 1 { 3 }, # }, # # { # para 3 7 1 {- 2 , 3 }, # ans 3 7 1 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 7 1 , q . para 3 7 1 # fmt . Printf (" STR ", p , getSum ( p . a , p . b )) # } # fmt . Printf (" STR ")
qs := [] question 3 4 5 { # # { # para 3 4 5 {" STR "}, # ans 3 4 5 {" STR "}, # }, # # { # para 3 4 5 {" STR "}, # ans 3 4 5 {" STR "}, # }, # # { # para 3 4 5 {" STR "}, # ans 3 4 5 {" STR "}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 4 5 , q . para 3 4 5 # fmt . Printf (" STR ", p , reverseVowels ( p . one )) # } # fmt . Printf (" STR ")
s 1 , s 2 := []* TreeNode { root 1 }, []* TreeNode { root 2 } # for len ( s 1 ) != 0 && len ( s 2 ) != 0 { # if dfs (& s 1 ) != dfs (& s 2 ) { # return false # } # } # return len ( s 1 ) == 0 && len ( s 2 ) == 0
for d := 0 ; len ( digits ) > 0 ; d ++ { # k := factorial ( len ( digits )) / len ( digits ) # i := ( sequence - 1 ) / k # sequence = sequence - ( i * k ) # solution [ d ] = digits [ i ] # digits = append ( digits [: i ], digits [ i + 1 :]...) # } # fmt . Println (" STR ", solution )
if len ( s ) == 0 { # return false # } # # size := len ( s ) # # ss := ( s + s )[ 1 : size * 2 - 1 ] # # return strings . Contains ( ss , s )
StoreUint 6 4 (& r . Reg , LoadUint 6 4 (& r . Reg )&^( mask << pos )| value << pos )
this . mutex . Lock () # defer this . mutex . Unlock () # # ret := make ( map [ int ] int ) # # for i , q := range this . queues { # if q . Len () > 0 { # ret [ i ] = q . Len () # } # } # # return ret
lowerIndex := firstOccurance ( nums , target ) # first := - 1 # if lowerIndex != len ( nums ) && target == nums [ lowerIndex ] { # first = lowerIndex # } # # upperIndex := lastOccurance ( nums , target ) # last := - 1 # if upperIndex == len ( nums ) && len ( nums ) > 0 && target == nums [ len ( nums )- 1 ] { # last = len ( nums ) - 1 # } else if upperIndex != len ( nums ) && upperIndex > 0 && target == nums [ upperIndex - 1 ] { # last = upperIndex - 1 # } # return [] int { first , last }
ret := [] float 6 4 {} # if root == nil { # return ret # } # cnt , sum := 0 , 0 # q := []* TreeNode { root } # for len ( q ) > 0 { # cnt = len ( q ) # sum = 0 # for i := 0 ; i < cnt ; i ++ { # tmp := q [ 0 ] # q = q [ 1 :] # if tmp . Left != nil { # q = append ( q , tmp . Left ) # } # if tmp . Right != nil { # q = append ( q , tmp . Right ) # } # sum += tmp . Val # } # ret = append ( ret , float 6 4 ( sum )/ float 6 4 ( cnt )) # } # return ret
qs := [] question 8 1 { # # { # para 8 1 {[] int { 2 , 5 , 6 , 0 , 0 , 1 , 2 }, 0 }, # ans 8 1 { true }, # }, # # { # para 8 1 {[] int { 2 , 5 , 6 , 0 , 0 , 1 , 2 }, 3 }, # ans 8 1 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 1 , q . para 8 1 # fmt . Printf (" STR ", p , search ( p . nums , p . target )) # } # fmt . Printf (" STR ")
cases := [] struct { # name string # inputs []* ListNode # expect * ListNode # }{ # {" STR ", # []* ListNode { # UnmarshalListBySlice ([] int { 1 , 4 , 5 }), # UnmarshalListBySlice ([] int { 1 , 3 , 4 }), # UnmarshalListBySlice ([] int { 2 , 6 }), # }, # UnmarshalListBySlice ([] int { 1 , 1 , 2 , 3 , 4 , 4 , 5 , 6 })}, # } # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := mergeKLists 3 ( c . inputs ) # if ! isEqual ( got , c . expect ) { # PrintList ( got ) # PrintList ( c . expect ) # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
total , maxSum , minSum , curMax , curMin := 0 , - 3 0 0 0 0 , 3 0 0 0 0 , 0 , 0 # for _ , a := range A { # curMax = max ( curMax + a , a ) # maxSum = max ( maxSum , curMax ) # curMin = min ( curMin + a , a ) # minSum = min ( minSum , curMin ) # total += a # } # if maxSum < 0 { # return maxSum # } # return max ( maxSum , total - minSum )
originalHead := head # kptr := head # passedHead := false # for i := 0 ; i <= kth ; i ++ { # if head == nil { # passedHead = true # } else { # head = head . Next # } # } # for head != nil { # head = head . Next # kptr = kptr . Next # } # if passedHead { # kptr = kptr . Next # return kptr # } # kptr . Next = kptr . Next . Next # return originalHead
if m > n { # m , n = n , m # } # # lo , hi := 1 , m * n # for lo < hi { # mid := lo + ( hi - lo )/ 2 # c := count ( mid , m , n ) # if c >= k { # hi = mid # } else { # lo = mid + 1 # } # } # # return hi
s , e := newInterval . Start , newInterval . End # l , r := [] Interval {}, [] Interval {} # for _ , i := range intervals { # if i . End < s { # l = append ( l , i ) # } else if i . Start > e { # r = append ( r , i ) # } else { # if i . Start < s { # s = i . Start # } # if i . End > e { # e = i . End # } # } # } # l = append ( l , Interval { Start : s , End : e }) # return append ( l , r ...)
if 0 == len ( nums ) { # return 0 # } # ans , sum := 1 , 1 # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] > nums [ i - 1 ] { # sum ++ # } else { # sum = 1 # } # if sum > ans { # ans = sum # } # } # return ans
return MyCalendarTwo { # over : [][ 2 ] int {}, # cal : [][ 2 ] int {}, # }
n := len ( s ) # # i := 0 # for i < n && ( s [ i ] < ' 0 ' || s [ i ] > ' 9 ') { # i ++ # } # if i == n { # return s # } # # j := i + 1 # # for s [ j ] != '[' { # j ++ # } # # k := j # count := 1 # for count > 0 { # k ++ # if s [ k ] == '[' { # count ++ # } else if s [ k ] == ']' { # count -- # } # } # # num , _ := strconv . Atoi ( s [ i : j ]) # return s [: i ] + times ( decodeString ( s [ j + 1 : k ]), num ) + decodeString ( s [ k + 1 :])
a := [...] int { 0 , 1 , 2 , 3 , 4 , 5 } # reverse ( a [:]) # fmt . Println ( a ) # # s := [] int { 0 , 1 , 2 , 3 , 4 , 5 } # reverse ( s [: 2 ]) # reverse ( s [ 2 :]) # reverse ( s ) # fmt . Println ( s ) # # input := bufio . NewScanner ( os . Stdin ) # outer : # for input . Scan () { # var ints [] int # for _ , s := range strings . Fields ( input . Text ()) { # x , err := strconv . ParseInt ( s , 1 0 , 6 4 ) # if err != nil { # fmt . Fprintln ( os . Stderr , err ) # continue outer # } # ints = append ( ints , int ( x )) # } # reverse ( ints ) # fmt . Printf (" STR ", ints ) # }
t . Parallel () # for _ , tc := range testcases { # if result := DeBruijnSequence ( tc . c , tc . k ); ! reflect . DeepEqual ( result , tc . expected ) { # t . Errorf (" STR ", tc . expected , result ) # } # }
return time . Date ( year , time . Month ( month ), day , 0 , 0 , 0 , 0 , time . Local ). # Weekday (). # String ()
m := map [ int ] struct {}{} # # var dfs func (* TreeNode ) bool # dfs = func ( node * TreeNode ) bool { # if node == nil { # return false # } # if _ , ok := m [ k - node . Val ]; ok { # return true # } # m [ node . Val ] = struct {}{} # return dfs ( node . Left ) || dfs ( node . Right ) # } # return dfs ( root )
defer trace (" STR ")() # time . Sleep ( 1 0 * time . Second )
var tests = [] struct { # tree * TreeNode # vals [] int # }{ # { newTree ( 1 , nil , 2 , 3 ), [] int { 1 , 3 , 2 }}, # { newTree ( 4 , 2 , 6 , 1 , 3 , 5 , 7 ), [] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 }}, # } # # for _ , tt := range tests { # vals := inorderTraversal ( tt . tree ) # if reflect . DeepEqual ( vals , tt . vals ) == false { # t . Errorf (" STR ", tt . tree , vals , tt . vals ) # } # }
for l != nil { # if l . Val == v { # return l # } # l = l . Next # } # return nil
obj := Constructor () # fmt . Println ( obj . Pop_front ()) # fmt . Println ( obj . Pop_front ()) # fmt . Println ( obj . Pop_front ()) # fmt . Println ( obj . Pop_front ()) # fmt . Println ( obj . Pop_front ()) # obj . Push_back ( 1 5 ) # fmt . Println ( obj . Max_value ()) # obj . Push_back ( 9 ) # fmt . Println ( obj . Max_value ())
var caesarTestData = [] struct { # description string # input string # key int # expected string # }{ # { # " STR ", # " STR ", # 3 , # " STR ", # }, # { # " STR ", # " STR ", # 3 , # " STR ", # }, # { # " STR ", # " STR ", # 3 , # " STR ", # }, # { # " STR ", # " STR ", # 1 3 , # " STR ", # }, # { # " STR ", # " STR ", # - 1 3 , # " STR ", # }, # { # " STR ", # " STR ", # 2 6 , # " STR ", # }, # { # " STR ", # " STR ", # 1 0 , # " STR ", # }, # } # # for _ , test := range caesarTestData { # t . Run ( test . description , func ( t * testing . T ) { # actual := Decrypt ( test . input , test . key ) # if actual != test . expected { # t . Logf (" STR ", test . description ) # t . Fatalf (" STR ", # test . input , test . key , test . expected , actual ) # } # }) # }
t . Parallel () # sched := NewScheduler () # sched . Schedule ( func () { fmt . Println (" STR ") }, 1 0 ) # sched . Schedule ( func () { fmt . Println (" STR ") }, 2 0 ) # sched . Schedule ( func () { fmt . Println (" STR ") }, 3 0 ) # sched . Schedule ( func () { time . Sleep ( 1 * time . Second ); fmt . Println (" STR ") }, 1 ) # sched . Shutdown ()
if len ( nums ) == 0 { # return # } # j := 0 # for i := 0 ; i < len ( nums ); i ++ { # if nums [ i ] != 0 { # if i != j { # nums [ i ], nums [ j ] = nums [ j ], nums [ i ] # } # j ++ # } # }
if head == nil { # return head # } # var h ListNode # h . Next = head # now := & h # num := head . Val # for head != nil && head . Next != nil && now . Next != nil { # if head . Next . Val == num { # for head . Next != nil && head . Next . Val == num { # head = head . Next # } # now . Next = head . Next # if head . Next == nil { # break # } # now . Next = head . Next # num = head . Next . Val # head = head . Next # } else { # now . Next = head # now = now . Next # num = head . Next . Val # head = head . Next # } # } # return h . Next
var ri , gi int # # for i , r := range letters { # if r == ' R ' { # letters [ i ], letters [ gi ], letters [ ri ] = letters [ gi ], letters [ ri ], r # gi ++ # ri ++ # } else if r == ' G ' { # letters [ i ], letters [ gi ] = letters [ gi ], r # gi ++ # } # }
if n == 0 { # return math . MaxInt 3 2 # } # # signM , absM := analysis ( m ) # signN , absN := analysis ( n ) # # res , _ := d ( absM , absN , 1 ) # # if signM != signN { # res = res - res - res # } # # if res < math . MinInt 3 2 || res > math . MaxInt 3 2 { # return math . MaxInt 3 2 # } # # return res
ret := 0 # # for _ , chr := range str { # ret += int ( uint 8 ( chr )-' A ') + 1 # } # # return ret
set := make ( map [ string ] bool ) # for _ , email := range emails { # normalized := normalizeEmail ( email ) # if _ , ok := set [ normalized ]; ! ok { # set [ normalized ] = true # } # } # # return len ( set )
ans , n := make ([] rune , 0 , len ( S )), 0 # for _ , c := range S { # if c == '(' { # n ++ # } else { # n -- # } # if ( c == '(' && n != 1 ) || ( c == ')' && n != 0 ) { # ans = append ( ans , c ) # } # } # return string ( ans )
if len ( bits ) == 0 { # return false # } # ret := 0 # for i := len ( bits ) - 2 ; i >= 0 && bits [ i ] == 1 ; i -- { # ret ++ # } # return ret % 2 == 0
return isValid [ encode ( N )]
return convert ( S ) == convert ( T )
return new ( preSchTaskList ). init ( tasks )
fmt . Println (" STR ") # divisorsCount ( 7 ) # i := 1 # # for { # if divisorsCount ( i ) > 5 0 0 { # break # } # i ++ # } # fmt . Println (( i * ( i + 1 )) / 2 )
var ret int # var n int # ret = 4 # n = 1 0 # if ret != countPrimes ( n ) { # t . Fatalf (" STR ", ret ) # } # # ret = 0 # n = 2 # if ret != countPrimes ( n ) { # t . Fatalf (" STR ", ret ) # } #
bytes := [] byte ( s ) # # i , j := 0 , len ( s )- 1 # # for i < j { # bytes [ i ], bytes [ j ] = bytes [ j ], bytes [ i ] # i ++ # j -- # } # # return string ( bytes )
tree := New ( compare ) # # testValues := [] int { 4 , 5 , 3 , 2 , 9 } # for _ , i := range testValues { # tree . Insert ( i ) # } # # max := tree . Max () # if max != 9 { # t . Errorf (" STR ", max ) # } # # min := tree . Min () # if min != 2 { # t . Errorf (" STR ", min ) # }
hashCheck := make ( map [ string ] struct {}) # for index := i ; index < j ; index ++ { # if _ , ok := hashCheck [ string ( str [ index ])]; ok { # return false # } # hashCheck [ string ( str [ index ])] = struct {}{} # } # return true
qs := [] question 1 2 2 1 { # # { # para 1 2 2 1 {" STR "}, # ans 1 2 2 1 { 4 }, # }, # # { # para 1 2 2 1 {" STR "}, # ans 1 2 2 1 { 3 }, # }, # # { # para 1 2 2 1 {" STR "}, # ans 1 2 2 1 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 2 1 , q . para 1 2 2 1 # fmt . Printf (" STR ", p , balancedStringSplit ( p . s )) # } # fmt . Printf (" STR ")
qs := [] question 8 2 8 { # # { # para 8 2 8 {" STR "}, # ans 8 2 8 { 3 5 }, # }, # # { # para 8 2 8 {" STR "}, # ans 8 2 8 { 1 0 }, # }, # # { # para 8 2 8 {" STR "}, # ans 8 2 8 { 8 }, # }, # # { # para 8 2 8 {" STR "}, # ans 8 2 8 { 1 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 2 8 , q . para 8 2 8 # fmt . Printf (" STR ", p , uniqueLetterString ( p . one )) # } # fmt . Printf (" STR ")
first := make ( map [ string ] struct {}) # mutual := make ( map [ string ] struct {}) # # for _ , path := range user 1 { # first [ path ] = struct {}{} # } # # for _ , path := range user 2 { # if _ , found := first [ path ]; found { # mutual [ path ] = struct {}{} # } # } # # var longest [] string # # for i , path 1 := range user 1 { # if _ , common := mutual [ path 1 ]; ! common { # continue # } # # for j , path 2 := range user 2 { # if path 2 == path 1 { # ptrI := i # ptrJ := j # # for ptrI < len ( user 1 ) && ptrJ < len ( user 2 ) && user 1 [ ptrI ] == user 2 [ ptrJ ] { # ptrI ++ # ptrJ ++ # } # # if ptrI - i > len ( longest ) { # longest = user 1 [ i : ptrI ] # } # } # } # } # # return longest
next := make ([][] int , numCourses ) # pre := make ([] int , numCourses ) # for _ , r := range prerequisites { # next [ r [ 1 ]] = append ( next [ r [ 1 ]], r [ 0 ]) # pre [ r [ 0 ]]++ # } # # res := make ([] int , numCourses ) # var i , j int # for i = 0 ; i < numCourses ; i ++ { # # for j = 0 ; j < numCourses ; j ++ { # if pre [ j ] == 0 { # break # } # } # if j == numCourses { # return nil # } # # pre [ j ] = - 1 # for _ , c := range next [ j ] { # pre [ c ]-- # } # # res [ i ] = j # } # return res
var x , y [] int # for i := 0 ; i < 1 0 ; i ++ { # y = appendInt ( x , i ) # fmt . Printf (" STR ", i , cap ( y ), y ) # x = y # }
s := newStruct () # # if ! s . Field (" STR "). IsExported () { # t . Errorf (" STR ") # } # # if ! s . Field (" STR "). IsExported () { # t . Errorf (" STR ") # } # # if s . Field (" STR "). IsExported () { # t . Errorf (" STR ") # }
dummy := & ListNode { # Next : head , # } # # i := 0 # node := dummy # for i < m - 1 { # node = node . Next # i ++ # } # # before := node # node = node . Next # first := node # i ++ # # var prev , after , revHead * ListNode # for i <= n { # after = node . Next # node . Next = prev # prev = node # if i == n { # revHead = node # } # # node = after # i ++ # } # # before . Next , first . Next = revHead , after # return dummy . Next
if len ( pairs )% 2 != 0 { # panic (" STR ") # } # indicies := make ( map [ int ][] int , len ( pairs )/ 2 ) # for i , id := range pairs { # indicies [ id ] = append ( indicies [ id ], i ) # } # if len ( indicies ) != len ( pairs )/ 2 { # panic (" STR ") # } # for _ , pos := range indicies { # if len ( pos ) != 2 { # panic (" STR ") # } # } # return minSwapsAdjacentPairs ( pairs , indicies , 0 )
println (" STR ") # select { # default : # } # println (" STR ") # wg . Done ()
return func ( h http . Handler ) http . Handler { # return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { # log . Println (" STR ") # h . ServeHTTP ( w , r ) # log . Println (" STR ") # }) # }
res := 0 # for ; x != 0 ; x /= 1 0 { # res = res * 1 0 + x % 1 0 # } # return res
result := make ([] int , 0 , int ( num )) # for i := uint 6 4 ( 1 ); i <= num ; i ++ { # result = append ( result , bits . OnesCount 6 4 ( i )) # } # return result
count , countZero , countOne := 0 , 0 , 0 # prev := rune ( s [ 0 ]) # # for _ , r := range s { # if prev == r { # if r == ' 0 ' { # countZero ++ # } else { # countOne ++ # } # } else { # count += min ( countZero , countOne ) # if r == ' 0 ' { # countZero = 1 # } else { # countOne = 1 # } # } # prev = r # } # # return count + min ( countZero , countOne )
t . Parallel () # for _ , tc := range testcases { # if next := NextIntSameSetBits ( tc . n ); next != tc . next { # t . Errorf (" STR ", tc . next , next ) # } # }
random := rand . New ( rand . NewSource ( time . Now (). UnixNano ())) # array := make ([] int , random . Intn ( 1 0 0 - 1 0 )+ 1 0 ) # for i := range array { # array [ i ] = random . Intn ( 1 0 0 ) # } # SortArray ( array ) # for _ , value := range array { # result := TernarySearch ( array , value ) # if result == - 1 { # t . Fail () # } # }
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", [][] int { # { 0 , 1 , 0 , 0 }, # { 1 , 1 , 1 , 0 }, # { 0 , 1 , 0 , 0 }, # { 1 , 1 , 0 , 0 }, # }, 1 6 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := islandPerimeter ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
months := [] int { 3 1 , 2 8 , 3 1 , 3 0 , 3 1 , 3 0 , 3 1 , 3 1 , 3 0 , 3 1 , 3 0 , 3 1 } # year , _ := strconv . Atoi ( date [: 4 ]) # month , _ := strconv . Atoi ( date [ 5 : 7 ]) # day , _ := strconv . Atoi ( date [ 8 :]) # if year % 4 0 0 == 0 || ( year % 4 == 0 && year % 1 0 0 != 0 ) { # months [ 1 ] = 2 9 # } # return sum ( months , month - 1 ) + day
var orders [][] int # leadings := make ( map [ int ] int ) # for i := 0 ; i < len ( times ); i ++ { # t := times [ i ] # p := persons [ i ] # count := 1 # for j , order := range orders { # if p == order [ 0 ] { # count = order [ 1 ] + 1 # orders = append ( orders [: j ], orders [ j + 1 :]...) # } # } # orders = append ( orders , [] int { p , count }) # # max := 1 # for i := len ( orders ) - 1 ; i >= 0 ; i -- { # count := orders [ i ][ 1 ] # if count > max { # p = orders [ i ][ 0 ] # max = count # } # } # leadings [ t ] = p # } # return TopVotedCandidate { times , leadings }
field := t . rawField ( i ) # return StructField { # Name : field . Name , # PkgPath : field . PkgPath , # Type : field . Type , # Tag : field . Tag , # Anonymous : field . Anonymous , # Offset : field . Offset , # }
for i := 0 ; i < b . N ; i ++ { # n := NewNode () # # n . Insert (" STR ") # n . Insert (" STR ") # # n . Find (" STR ") # n . Find (" STR ") # n . Find (" STR ") # }
var buf bytes . Buffer # err = binary . Write (& buf , binary . BigEndian , data ) # b = buf . Bytes () # return
if * requestBody != "" { # return # } # # if * requestBodyFile == "" { # return # } # # data , err := ioutil . ReadFile (* requestBodyFile ) # if err != nil { # fmt . Println ( err ) # panic ( err ) # } # body := string ( data ) # requestBody = & body
res := make ([] string , len ( nums )) # as := make ( athletes , len ( nums )) # # for i := range nums { # as [ i ] = athlete { # sorce : nums [ i ], # index : i , # } # } # # sort . Sort ( as ) # # for i , a := range as { # switch i { # case 0 : # res [ a . index ] = " STR " # case 1 : # res [ a . index ] = " STR " # case 2 : # res [ a . index ] = " STR " # default : # res [ a . index ] = strconv . Itoa ( i + 1 ) # } # } # # return res
if len ( A ) != len ( B ){ # return false # } # return strings . Contains ( A + A , B )
sb := strings . Builder {} # opens := 0 # # for _ , r := range parens { # switch { # case r == '(': # opens ++ # case r == ')' && opens == 0 : # sb . WriteRune ('(') # default : # opens -- # } # # sb . WriteRune ( r ) # } # # for i := 0 ; i < opens ; i ++ { # sb . WriteRune (')') # } # # return sb . String ()
n , m := len ( A ), len ( B ) # prefTable := make ([] int , m + 1 ) # for sp , pp := 1 , 0 ; sp < m ; { # if B [ pp ] == B [ sp ] { # sp ++ # pp ++ # prefTable [ sp ] = pp # } else if pp == 0 { # sp ++ # prefTable [ sp ] = pp # } else { # pp = prefTable [ pp ] # } # } # # for i , j := 0 , 0 ; i < n ; i , j = i + max ( 1 , j - prefTable [ j ]), prefTable [ j ] { # for j < m && A [( i + j )% n ] == B [ j ] { # j ++ # } # if j == m { # if ( i + j )% n == 0 { # return ( i + j ) / n # } else { # return ( i + j )/ n + 1 # } # } # } # return - 1
sema <- struct {}{} # defer func () { <- sema }() # # entries , err := ioutil . ReadDir ( dir ) # if err != nil { # fmt . Fprintf ( os . Stderr , " STR ", err ) # return nil # } # return entries
return math . Sqrt ( math . Pow ( l . p 0 . x - l . p 1 . x , 2 ) + math . Pow ( l . p 0 . y - l . p 1 . y , 2 ))
p := this # for p . Next != nil { # p = p . Next # } # p . Next = & ListNode { Val : val }
configData , err := ioutil . ReadFile (* configFile ) # if err != nil { # fmt . Println ( err ) # panic ( err ) # } # err = json . Unmarshal ( configData , & config ) # if err != nil { # fmt . Println ( err ) # panic ( err ) # }
type TestStruct struct { # A interface {} # } # # expected := [] byte (" STR ") # # a := TestStruct { A : expected } # s := Map ( a ) # if ! reflect . DeepEqual ( s [" STR "], expected ) { # t . Errorf (" STR ", s [" STR "], expected ) # }
res := [][] int {} # if root == nil { # return res # } # var queue = []* TreeNode { root } # var level int # for { # counter := len ( queue ) # if counter == 0 { # break # } # res = append ( res , [] int {}) # for 0 < counter { # counter -- # if queue [ 0 ]. Left != nil { # queue = append ( queue , queue [ 0 ]. Left ) # } # if queue [ 0 ]. Right != nil { # queue = append ( queue , queue [ 0 ]. Right ) # } # res [ level ] = append ( res [ level ], queue [ 0 ]. Val ) # queue = queue [ 1 :] # } # level ++ # } # return res
c . mu . Lock () # err := c . err # if c . err == nil { # c . err = errors . New (" STR ") # err = c . conn . Close () # } # c . mu . Unlock () # return err
node := & BinaryTree { preorder [ 0 ], nil , nil } # preorder = preorder [ 1 :] # # if len ( inorder ) == 1 { # return node , preorder # } # # index := search ( inorder , node . value ) # node . left , preorder = Reconstruct ( preorder , inorder [: index ]) # node . right , preorder = Reconstruct ( preorder , inorder [ index + 1 :]) # # return node , preorder
var ( # low int # high = len ( nums ) - 1 # mid int # ) # for low < high { # mid = low + ( high - low )>> 1 # if nums [ high ] < nums [ mid ] { # low = mid + 1 # } else { # high = mid # } # } # return nums [ low ]
var ret int # var nums [] int # # nums = [] int { 1 , 1 , 0 , 1 , 1 , 1 } # ret = 3 # if ret != findMaxConsecutiveOnes ( nums ) { # t . Fatalf (" STR ", ret ) # }
res = [] int {} # dfs ( root ) # return res
println (" STR ", len ( m )) # println (" STR ", key , " STR ", m [ key ]) # for k , v := range m { # println (" STR ", k , " STR ", v ) # }
if root == nil { # return 0 # } # if root . Left == nil && root . Right == nil { # return 1 # } # # if root . Left == nil { # return minDepth ( root . Right ) + 1 # } # if root . Right == nil { # return minDepth ( root . Left ) + 1 # } # # l := minDepth ( root . Left ) # r := minDepth ( root . Right ) # if l < r { # return l + 1 # } # return r + 1
quick 3 way ( nums , 0 , len ( nums )- 1 ) # return nums
res := make ([] int , n + 1 ) # for i := 1 ; i < n + 1 ; i ++ { # if i % 2 == 0 { # res [ i ] = res [ i / 2 ] # } else { # res [ i ] = res [ i / 2 ] + 1 # } # } # return res
var nums [] int # var ret [] int # # nums = [] int { 1 , 2 , 3 } # ret = [] int { 1 , 2 , 4 } # plus := plusOne ( nums ) # for k , v := range ret { # if plus [ k ] != v { # t . Fatalf (" STR ", plus ) # } # } # nums = [] int { 9 , 9 , 9 } # ret = [] int { 1 , 0 , 0 , 0 } # plus = plusOne ( nums ) # for k , v := range ret { # if plus [ k ] != v { # t . Fatalf (" STR ", plus ) # } # }
result := 0 # for i , p 1 := range points { # sameP , sameX := 1 , 0 # slopeCounts := make ( map [ float 6 4 ] int ) # for j := 0 ; j < i ; j ++ { # p 2 := points [ j ] # if p 1 [ 0 ] == p 2 [ 0 ] && p 1 [ 1 ] == p 2 [ 1 ] { # sameP ++ # } else if p 1 [ 0 ] == p 2 [ 0 ] { # sameX ++ # } else { # slope := float 6 4 ( p 1 [ 1 ]- p 2 [ 1 ]) / float 6 4 ( p 1 [ 0 ]- p 2 [ 0 ]) # if _ , exists := slopeCounts [ slope ]; exists { # slopeCounts [ slope ]++ # } else { # slopeCounts [ slope ] = 1 # } # } # } # # result = int ( math . Max ( float 6 4 ( result ), float 6 4 ( sameP + sameX ))) # for _ , count := range slopeCounts { # result = int ( math . Max ( float 6 4 ( result ), float 6 4 ( count + sameP ))) # } # } # # return result
buf := make ([] byte , 5 0 0 ) # n , err := rand . Read ( buf ) # if n != len ( buf ) || err != nil { # println (" STR ", err ) # } # # sum := 0 # for _ , b := range buf { # sum += int ( b ) # } # if sum < 9 5 * len ( buf ) || sum > 1 5 9 * len ( buf ) { # println (" STR ", sum / len ( buf )) # } else { # println (" STR ") # }
arrSize := rand . Intn ( 1 0 0 ) + 5 0 # arr := make ([] int , arrSize , arrSize ) # for i := range arr { # arr [ i ] = rand . Intn ( 1 0 0 ) # } # sortedArr := make ([] int , 0 , 0 ) # for _ , v := range arr { # h . Append ( v ) # } # for h . Len () > 0 { # sortedArr = append ( sortedArr , h . Pop ().( int )) # } # sort . Sort ( sort . Reverse ( sort . IntSlice ( arr ))) # if ! reflect . DeepEqual ( sortedArr , arr ) { # t . Log ( fmt . Sprintf (" STR ", arr ) + fmt . Sprintf (" STR ", sortedArr )) # t . Fail () # }
words := strings . Split ( text , " STR ") # oneI := getIndex ( words , one , 0 ) # twoI := getIndex ( words , two , 0 ) # if oneI == - 1 || twoI == - 1 { # return - 1 # } # smallest := len ( words ) # for oneI != - 1 && twoI != - 1 { # if dist := abs ( oneI - twoI ); dist < smallest { # smallest = dist # } # if oneI < twoI { # oneI = getIndex ( words , one , oneI + 1 ) # } else { # twoI = getIndex ( words , two , twoI + 1 ) # } # } # return smallest - 1
tests := [...] testType { # { # pattern : " STR ", # str : " STR ", # want : true , # }, # { # pattern : " STR ", # str : " STR ", # want : false , # }, # { # pattern : " STR ", # str : " STR ", # want : false , # }, # { # pattern : " STR ", # str : " STR ", # want : false , # }, # { # pattern : " STR ", # str : " STR ", # want : false , # }, # { # pattern : " STR ", # str : " STR ", # want : true , # }, # { # pattern : " STR ", # str : " STR ", # want : true , # }, # } # for _ , tt := range tests { # got := wordPattern ( tt . pattern , tt . str ) # if got != tt . want { # t . Fatalf (" STR ", tt . pattern , got , tt . want ) # } # }
var Prev , Next * Node # cur := ll . Head # # for cur != nil { # Next = cur . Next # cur . Next = Prev # cur . Prev = Next # Prev = cur # cur = Next # } # # ll . Head = Prev
a , b := - 1 , 1 # return func () int { # c := a + b # a , b = b , c # return c # }
t . Parallel () # for _ , tc := range testcases { # head := createDoublyLL ( tc . data ) # if result := IsPalindromeDoublyLL ( head ); result != tc . isPalindrome { # t . Errorf (" STR ", tc . data , tc . isPalindrome , result ) # } # }
return ll . head . Data
before := n % 2 # n /= 2 # for n > 0 { # if n % 2 == before { # return false # } # before = n % 2 # n /= 2 # } # return true
result := & quickFind {} # result . IDs = make ([] int , n ) # for x := range result . IDs { # result . IDs [ x ] = x # } # return result
cases := [] struct { # name string # inputs string # expect int # }{ # {" STR ", " STR ", 3 }, # {" STR ", " STR ", 1 }, # {" STR ", " STR ", 3 }, # } # b . ResetTimer () # for i := 0 ; i < b . N ; i ++ { # lengthOfLongestSubstring 2 ( cases [ 0 ]. inputs ) # lengthOfLongestSubstring 2 ( cases [ 1 ]. inputs ) # lengthOfLongestSubstring 2 ( cases [ 2 ]. inputs ) # }
var tests = [] struct { # tree * TreeNode # sum int # hasSum bool # }{ # { newTree ( 5 , 4 , 8 , 1 1 , nil , 1 3 , 4 , 7 , 2 , nil , nil , nil , 1 ), 2 2 , true }, # { newTree ( 5 , 4 , 8 , 1 1 , nil , 1 3 , 4 , nil , 2 , nil , nil , nil , 1 ), 2 2 , true }, # } # # for _ , tt := range tests { # hasSum := hasPathSum ( tt . tree , tt . sum ) # if hasSum != tt . hasSum { # t . Errorf (" STR ", tt . tree , tt . sum , hasSum , tt . hasSum ) # } # }
sum := 0 # for _ , num := range nums { # sum += num # } # if sum < S { # return 0 # } # if ( sum + S )% 2 == 1 { # return 0 # } # # target := ( sum + S ) / 2 # dp := make ([] int , target + 1 ) # dp [ 0 ] = 1 # for _ , num := range nums { # for i := target ; i >= num ; i -- { # dp [ i ] += dp [ i - num ] # } # } # return dp [ target ]
if n < 3 { # return n # } # var result uint # var bits , ones int # for n != 0 { # bit := n & 1 # n >>= 1 # if bit == 1 { # ones ++ # } else { # if ones > 1 { # n <<= 1 # n |= 1 # result = 1 << uint ( bits ) # bits -- # } else { # result |= 1 << uint ( bits - 1 ) # } # ones = 0 # } # bits ++ # } # if ones == 1 { # result |= 1 << uint ( bits - 1 ) # } else if ones > 1 { # result = 1 << uint ( bits ) # } # return result
for i := 0 ; i < 1 0 0 ; i ++ { # dst := makeRandomSlice ( i ) # src := makeRandomSlice ( i ) # result 1 := append ( dst , src ...) # result 2 := reflect . AppendSlice ( reflect . ValueOf ( dst ), reflect . ValueOf ( src )). Interface ().([] uint 3 2 ) # if ! sliceEqual ( result 1 , result 2 ) { # println (" STR ", len ( dst ), cap ( dst ), len ( src ), cap ( src )) # } # }
dict := make ( map [ byte ] int , 0 ) # for i := 0 ; i < len ( s ); i ++ { # dict [ s [ i ]]++ # } # # odd := 0 # for _ , v := range dict { # if v & 1 != 0 { # odd ++ # } # } # # ans := len ( s ) # if 0 != odd { # ans -= odd - 1 # } # return ans
tests := [...] testType { # { # in : [] int {- 1 , 2 , 1 , - 4 }, # target : 1 , # want : 2 , # }, # { # in : [] int {- 1 , 0 , 1 , 2 , - 1 , - 4 }, # target : 1 , # want : 1 , # }, # { # in : [] int { 0 , 0 , 0 , 0 }, # target : 1 , # want : 0 , # }, # { # in : [] int {- 2 , 0 , 0 , 2 , 2 , 2 }, # target : 2 , # want : 2 , # }, # { # in : [] int {- 2 , 0 , 0 , 2 , 2 , 2 , 2 }, # target : 1 , # want : 0 , # }, # } # for _ , tt := range tests { # got := threeSumClosest ( tt . in , tt . target ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
arr := [] int { 1 , 1 , 2 , 2 , 1 , 1 } # obj := Constructor 1 1 5 7 ( arr ) # fmt . Printf (" STR ", obj ) # fmt . Printf (" STR ", obj . Query ( 0 , 5 , 4 )) # fmt . Printf (" STR ", obj . Query ( 0 , 3 , 3 )) # fmt . Printf (" STR ", obj . Query ( 2 , 3 , 2 ))
if parser . token_available || yaml_parser_fetch_more_tokens ( parser ) { # return & parser . tokens [ parser . tokens_head ] # } # return nil
primeDiagonals := 0 . 0 # nonPrimeDiagonals := 1 . 0 # n := 1 # ratio := 1 0 0 . 0 # for ratio > 0 . 1 { # ur := 4 * n * n - 2 * n + 1 # if isPrime ( ur ) { # fmt . Println ( ur ) # primeDiagonals += 1 # } else { # nonPrimeDiagonals += 1 # } # ul := 4 * n * n + 1 # if isPrime ( ul ) { # primeDiagonals += 1 # } else { # nonPrimeDiagonals += 1 # } # bl := 4 * n * n + 2 * n + 1 # if isPrime ( bl ) { # primeDiagonals += 1 # } else { # nonPrimeDiagonals += 1 # } # nonPrimeDiagonals += 1 # ratio = primeDiagonals / ( nonPrimeDiagonals + primeDiagonals ) # fmt . Println ( ratio * 1 0 ) # fmt . Println ( primeDiagonals , nonPrimeDiagonals ) # if primeDiagonals /( nonPrimeDiagonals + primeDiagonals ) < 0 . 1 { # fmt . Println (" STR ") # fmt . Println ( n ) # break # } # n += 1 # } #
if head == nil { # return nil # } # odd , even := head , head . Next # eHead := even # for even != nil && even . Next != nil { # odd . Next = even . Next # odd = odd . Next # even . Next = odd . Next # even = even . Next # } # odd . Next = eHead # return head
levels := bfs ( root ) # return pad ( levels )
s . stack = s . stack [: len ( s . stack )- 1 ] # s . minStack = s . minStack [: len ( s . minStack )- 1 ]
file , err := os . Open ( path ) # if err != nil { # panic ( err ) # } # defer file . Close () # # data , err := ioutil . ReadAll ( file ) # return data
if len ( str ) == 0 { # return 0 # } # i := 0 # for str [ i ] == ' ' || str [ i ] == '\ t ' { # i ++ # } # str = str [ i :] # # flag := 1 # switch str [ 0 ] { # case '-': # flag = - 1 # fallthrough # case '+': # str = str [ 1 :] # } # # if len ( str ) == 0 { # return 0 # } # # i = 0 # for str [ i ] == ' 0 ' { # i ++ # } # # result := 0 # for _ , b := range str { # n := int ( b ) - 4 8 # if n < 0 || n > 9 { # break # } # result = result * 1 0 + n # if result > math . MaxInt 3 2 { # if flag == 1 { # return math . MaxInt 3 2 # } else { # return math . MinInt 3 2 # } # } # } # return result * flag
testFramework ( t , RadixSort )
qs := [] question 1 7 2 { # # { # para 1 7 2 { 3 }, # ans 1 7 2 { 0 }, # }, # # { # para 1 7 2 { 5 }, # ans 1 7 2 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 7 2 , q . para 1 7 2 # fmt . Printf (" STR ", p , trailingZeroes ( p . s )) # } # fmt . Printf (" STR ")
if len ( strs ) == 0 { # return " STR " # } # var res string # sort . Strings ( strs ) # for k := range strs [ 0 ] { # flag := true # for i := 0 ; i < len ( strs )- 1 ; i ++ { # if strs [ i ][ k ] != strs [ i + 1 ][ k ] { # flag = false # break # } # } # if flag { # res += strs [ 0 ][ k : k + 1 ] # } else { # break # } # } # return res
if num 1 == " STR " || num 2 == " STR " { # return " STR " # } # m , n := len ( num 1 ), len ( num 2 ) # result := make ([] int , m + n ) # for j := n - 1 ; j >= 0 ; j -- { # for i := m - 1 ; i >= 0 ; i -- { # tmp := int ( num 1 [ i ]-' 0 ')* int ( num 2 [ j ]-' 0 ') + result [ i + j + 1 ] # result [ i + j + 1 ] = tmp % 1 0 # result [ i + j ] += tmp / 1 0 # } # } # if result [ 0 ] == 0 { # result = result [ 1 :] # } # length := len ( result ) # str := make ([] byte , length ) # for k , val := range result { # str [ k ] += byte ( val ) + ' 0 ' # } # return string ( str )
this . enqueue = append ( this . enqueue , x ) #
if K == 0 || # N >= K + W { # return 1 . 0 # } # # dp := make ([] float 6 4 , N + 1 ) # dp [ 0 ] = 1 . 0 # last := 1 . 0 # res := 0 . 0 # for i := 1 ; i <= N ; i ++ { # dp [ i ] = last / float 6 4 ( W ) # # if W <= i { # last -= dp [ i - W ] # } # # if i < K { # last += dp [ i ] # } else { # res += dp [ i ] # } # # } # # return res
var maxCounter , aInMax , bInMax int # maxCounter = 0 # for a := - 9 9 9 ; a < 1 0 0 0 ; a ++ { # for b := - 9 9 9 ; b < 1 0 0 0 ; b ++ { # inner : # for n := 0 ; ; n ++ { # if ! isPrime ( n * n + a * n + b ) { # if n > maxCounter { # maxCounter , aInMax , bInMax = n , a , b # } # break inner # } # } # } # } # println ( aInMax * bInMax )
if len ( nums ) < 2 { # return len ( nums ) # } # ptr := 2 # for i := 2 ; i < len ( nums ); i ++ { # if nums [ i ] == nums [ ptr - 2 ] { # continue # } # nums [ ptr ] = nums [ i ] # ptr ++ # } # return ptr
row , col , complete := findEmpty ( board , n ) # if complete { # return board , complete # } # for choice := 1 ; choice <= n * n ; choice ++ { # isValid := true # gridrow , gridcol := row / n , col / n # for r := n * gridrow ; r < n * gridrow + n ; r ++ { # for c := n * gridcol ; c < n * gridcol + n ; c ++ { # if board [ r * n * n + c ] == choice { # isValid = false # } # } # } # for j := 0 ; j < n * n ; j ++ { # if matchAnyInt ( choice , board [ n * n * j + col ], board [ row * n * n + j ]) { # isValid = false # break # } # } # if isValid { # board [ row * n * n + col ] = choice # var solved bool # board , solved = Solver ( board , n ) # if solved { # return board , solved # } # board [ row * n * n + col ] = 0 # } # } # return board , false
result := & pathCompression {} # result . IDs = make ([] int , n ) # result . Weights = make ([] int , n ) # for x := range result . IDs { # result . IDs [ x ] = x # result . Weights [ x ] = 1 # } # return result
k := make ( map [ int ] int ) # for _ , kvs := range nums { # if _ , ok := k [ kvs ]; ok { # k [ kvs ] += 1 # # } else { # k [ kvs ] = 1 # } # } # p := 0 # for l := range k { # if k [ l ] == 1 { # p = l # } # } # return p
if N == 0 { # return 0 # } # if N == 1 { # return 1 # } # return fib ( N - 1 ) + fib ( N - 2 )
if x > y { # x = y # } # if x > z { # x = z # } # return x
for y > 0 { # x , y = y , x % y # } # return x
n := len ( arr ) # if n == 1 { # if arr [ 0 ] == 1 { # return 1 # } else { # return - 1 # } # } # hash := make ( map [ int ] int ) # for _ , val := range arr { # hash [ val ]++ # } # m := - 1 # for _ , val := range arr { # if hash [ val ] == val && val > m { # m = val # } # } # return m
t . Parallel () # for _ , tc := range testcases { # if survivor := JosephusGeneral ( tc . n , tc . k ); survivor != tc . survivor { # t . Errorf (" STR ", tc . n , tc . k , tc . survivor , survivor ) # } # }
