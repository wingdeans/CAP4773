lru := Constructor ( 2 ) # fmt . Println ( lru . Get ( 2 )) # # lru . Put ( 2 , 6 ) # fmt . Println ( lru . Get ( 1 )) # # lru . Put ( 1 , 5 ) # lru . Put ( 1 , 2 ) # # fmt . Println ( lru . Get ( 1 )) # fmt . Println ( lru . Get ( 2 )) #
if len ( pre ) == 0 { # return nil # } # if len ( pre ) == 1 { # return & TreeNode { Val : pre [ 0 ]} # } # for i := range post { # if post [ i ] == pre [ 1 ] { # return & TreeNode { # Val : pre [ 0 ], # Left : constructFromPrePost ( pre [ 1 : i + 2 ], post [: i + 1 ]), # Right : constructFromPrePost ( pre [ i + 2 :], post [ i + 1 : len ( post )- 1 ]), # } # # } # } # return nil
if root == nil { # return false # } # if root . Left == nil && root . Right == nil { # return sum == root . Val # } # # sum -= root . Val # return hasPathSum ( root . Left , sum ) || hasPathSum ( root . Right , sum )
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 2 , 2 , 3 , 1 }, 2 }, # {" STR ", [] int { 1 , 2 , 2 , 3 , 1 , 4 , 2 }, 6 }, # {" STR ", [] int { 1 }, 1 }, # {" STR ", [] int { 1 0 , 1 0 }, 2 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if l == nil { # return nil # } # return l . Next
n := len ( digits ) # digits [ n - 1 ]++ # # for i := n - 1 ; i > 0 ; i -- { # if digits [ i ] < 1 0 { # break # } # digits [ i ] -= 1 0 # digits [ i - 1 ]++ # } # # if digits [ 0 ] > 9 { # digits [ 0 ] -= 1 0 # digits = append ([] int { 1 }, digits ...) # } # return digits
if root == nil { # return 0 # } # var leftHeight , rightHeight int # if root . Left != nil { # leftHeight = root . Left . Height # } # if root . Right != nil { # rightHeight = root . Right . Height # } # max := leftHeight # if rightHeight > leftHeight { # max = rightHeight # } # return 1 + max
if n == 0 { # return 0 # } # return n + sumNums ( n - 1 )
for { # println (" STR ") # time . Sleep ( time . Second ) # }
num , _ := strconv . ParseUint ( n , 1 0 , 6 4 ) # m := int ( math . Log 2 ( float 6 4 ( num ))) # for i := m ; i >= 1 ; i -- { # k := uint 6 4 ( math . Pow ( float 6 4 ( num ), 1 . 0 / float 6 4 ( i ))) # var sum , a uint 6 4 = 1 , 1 # for j := 1 ; j <= i ; j ++ { # a *= k # sum += a # } # if sum == num { # return strconv . FormatUint ( k , 1 0 ) # } # } # return strconv . FormatUint ( num - 1 , 1 0 )
major , count := nums [ 0 ], 0 # majorMap := make ( map [ int ] int ) # # for _ , v := range nums { # majorMap [ v ]++ # } # # for i , v := range majorMap { # if v > count { # major = i # count = v # } # } # # return major
list := New () # list = Insert ( 1 , list ) # list = Insert ( 2 , list ) # list = Insert ( 3 , list ) # list = Insert ( 1 0 , list ) # list = Insert ( 1 0 3 , list ) # list = Insert ( 5 6 , list ) # # has := Has ( 1 0 3 , list ) # if has != true { # t . Error (" STR ") # } # # if Length ( list ) != 6 { # t . Error (" STR ") # } # # list = Remove ( 1 0 , list ) # # has = Has ( 1 0 , list ) # if has != false { # t . Error (" STR ") # } # # if Length ( list ) != 5 { # t . Error (" STR ") # }
text 1 := " STR " # text 2 := " STR " # fmt . Println ( lengthOfLastWord ( text 1 )) # fmt . Println ( lengthOfLastWord ( text 2 )) # # fmt . Println ( lengthOfLastWord 2 ( text 1 )) # fmt . Println ( lengthOfLastWord 2 ( text 2 )) # # text 3 := " STR " # fmt . Println ( len ( text 3 )) # fmt . Printf (" STR ", text 3 [ 0 ], text 3 [ 0 ], text 3 [ 0 ]) # fmt . Printf (" STR ", text 3 [ 6 ], text 3 [ 6 ], text 3 [ 6 ]) # # text 4 := ' ä¸­ ' # text 5 := ' g ' # fmt . Printf (" STR ", text 4 , text 4 ) # fmt . Printf (" STR ", text 5 , text 5 ) #
tests := [...] testType { # { # ransom : " STR ", # magazine : " STR ", # want : false , # }, # { # ransom : " STR ", # magazine : " STR ", # want : false , # }, # { # ransom : " STR ", # magazine : " STR ", # want : true , # }, # } # for _ , tt := range tests { # got := canConstruct ( tt . ransom , tt . magazine ) # if got != tt . want { # t . Fatalf (" STR ", tt . ransom , tt . magazine , got , tt . want ) # } # }
cur , res := 0 , [] int {} # for _ , v := range A { # if v % 2 == 0 { # cur += v # } # } # for _ , q := range queries { # if A [ q [ 1 ]]% 2 == 0 { # cur -= A [ q [ 1 ]] # } # A [ q [ 1 ]] += q [ 0 ] # if A [ q [ 1 ]]% 2 == 0 { # cur += A [ q [ 1 ]] # } # res = append ( res , cur ) # } # return res
array := [ 2 0 0 0 1 ] int {} # for i := 0 ; i < len ( nums ); i ++ { # array [ nums [ i ]+ 1 0 0 0 0 ]++ # } # flag , sum := true , 0 # for i := 0 ; i < len ( array ); i ++ { # for array [ i ] > 0 { # if flag { # sum = sum + i - 1 0 0 0 0 # } # flag = ! flag # array [ i ]-- # } # } # return sum
if num < 1 { # return false # } # # for num > 1 { # if num % 2 == 0 { # num = num / 2 # } else if num % 3 == 0 { # num = num / 3 # } else if num % 5 == 0 { # num = num / 5 # } else { # return false # } # } # # return true
record := 0 # # for perimeter := 0 ; perimeter < 1 0 0 0 ; perimeter ++ { # # count := 0 # # for a := 1 ; a < perimeter ; a ++ { # # for b := a + 1 ; b < perimeter ; b ++ { # # for c := b + 1 ; c < perimeter ; c ++ { # # if a + b + c == perimeter && a * a + b * b == c * c { # count ++ # # } # # } # # } # # } # # if count > record { # record = count # fmt . Println ( record , perimeter ) # # } # # } #
count := [ 1 0 0 1 ] int {} # for _ , a := range A { # count [ a ]++ # } # res := make ([] int , 0 , len ( A )) # for _ , b := range B { # for count [ b ] > 0 { # res = append ( res , b ) # count [ b ]-- # } # } # for i := 0 ; i < 1 0 0 1 ; i ++ { # for count [ i ] > 0 { # res = append ( res , i ) # count [ i ]-- # } # } # return res
n := len ( logs ) # letters , digits := make ([] string , 0 , n ), [] string {} # for _ , log := range logs { # if log [ strings . IndexByte ( log , ' ')+ 1 ] <= ' 9 ' { # digits = append ( digits , log ) # } else { # letters = append ( letters , log ) # } # } # # sort . Slice ( letters , func ( i , j int ) bool { # s 1 , s 2 := letters [ i ], letters [ j ] # return s 1 [ strings . IndexByte ( s 1 , ' ')+ 1 :] < s 2 [ strings . IndexByte ( s 2 , ' ')+ 1 :] # }) # for _ , log := range digits { # letters = append ( letters , log ) # } # return letters
pivot := rand . Intn ( n ) # v := arr [ pivot ] # left := 0 # # arr [ pivot ], arr [ n - 1 ] = arr [ n - 1 ], arr [ pivot ] # # for j := 0 ; j < n - 1 ; j ++ { # if arr [ j ] <= v { # arr [ j ], arr [ left ] = arr [ left ], arr [ j ] # left ++ # } # } # # if left + 1 >= n { # return arr [ n - 1 ] # } # # arr [ left + 1 ], arr [ n - 1 ] = arr [ n - 1 ], arr [ left + 1 ] # # j := left # # if j < 2 { # return arr [ j ] # } # # if j == i { # return arr [ j ] # } else if j > i { # return RSelect ( arr [: j ], j - 1 , i ) # } else { # return RSelect ( arr [ j :], n - j , i - j ) # }
n := len ( intervals ) # if n == 0 { # return 0 # } # sort . Slice ( intervals , func ( i , j int ) bool { # return intervals [ i ]. End < intervals [ j ]. End # }) # end := intervals [ 0 ]. End # res := 0 # # for i := 1 ; i < n ; i ++ { # if intervals [ i ]. Start >= end { # end = intervals [ i ]. End # } else { # res ++ # } # } # return res
t . Parallel () # for _ , tc := range testcases { # q := & Quack {} # for _ , s := range tc . steps { # switch s . action { # case " STR ": # q . Push ( s . data ) # case " STR ": # if x , err := q . Pop (); x != s . data || err != s . err { # t . Errorf (" STR ", s . data , s . err , x , err ) # } # case " STR ": # if x , err := q . Pull (); x != s . data || err != s . err { # t . Errorf (" STR ", s . data , s . err , x , err ) # } # } # } # }
var n [ 1 0 0 0 ] int # for j := 0 ; j < len ( s ); j ++ { # n [ j ], _ = strconv . Atoi ( string ( s [ j ])) # } # var largest , t int # for i := 0 ; i <= len ( s )- 5 ; i ++ { # t = n [ i ] * n [ i + 1 ] * n [ i + 2 ] * n [ i + 3 ] * n [ i + 4 ] # if largest < t { # largest = t # } # } # return largest
freq := make ( map [ rune ] int ) # for _ , r := range w { # freq [ r ]++ # } # # var result [] int # # for i := range s { # sub := make ( map [ rune ] int ) # for j := i ; j < len ( s ) && j < i + len ( w ); j ++ { # sub [ rune ( s [ j ])]++ # } # # if reflect . DeepEqual ( sub , freq ) { # result = append ( result , i ) # } # } # # return result
diff := m ^ n # for diff &( diff - 1 ) != 0 { # diff &= diff - 1 # } # if diff != 0 { # diff |= diff - 1 # } # return m & n & ^ diff
if K % 2 == 0 || K % 5 == 0 { # return - 1 # } # # r , length := 1 % K , 1 # for r != 0 && length <= K { # r = ( r * 1 0 + 1 ) % K # length ++ # } # # return length
n := len ( s ) # dp := make ([] int , n + 1 ) # for i := 0 ; i < n + 1 ; i ++ { # dp [ i ] = i - 1 # } # for i := 0 ; i < n ; i ++ { # for j := 0 ; i >= j && i + j < n && s [ i - j ] == s [ i + j ]; j ++ { # dp [ i + j + 1 ] = min ( dp [ i + j + 1 ], dp [ i - j ]+ 1 ) # } # for j := 1 ; i + 1 >= j && i + j < n && s [ i - j + 1 ] == s [ i + j ]; j ++ { # dp [ i + j + 1 ] = min ( dp [ i + j + 1 ], dp [ i - j + 1 ]+ 1 ) # } # } # return dp [ n ]
return strings . Index ( haystack , needle )
reader := bufio . NewReader ( os . Stdin ) # fmt . Println (" STR ") # val , _ := reader . ReadString (" STR ") # fmt . Println (" STR ", val )
if len ( seq ) == 1 { # return 1 # } # dp := make ([] int , len ( seq )) # dp [ 0 ] = 1 # maxK := dp [ 0 ] # for i := 1 ; i < len ( seq ); i ++ { # maxLen := dp [ i - 1 ] # for k := 0 ; k <= i ; k ++ { # if seq [ i ] > seq [ k ] { # maxLen = dp [ k ] + 1 # } # } # dp [ i ] = maxLen # if dp [ i ] > maxK { # maxK = dp [ i ] # } # } # fmt . Println (" STR ", dp ) # return maxK
level := TRACE # if level == TRACE { # fmt . Println (" STR ") # } # level = INFO # fmt . Println ( level . String ())
var maxArea int # for row := range matrix { # for col := 0 ; col < len ( matrix [ row ]); col ++ { # if matrix [ row ][ col ] == 1 { # area := areaOfOnes ( matrix , row , col ) # maxArea = max ( area , maxArea ) # } # } # } # return maxArea
return int 6 4 ( len ( w . buf ))
ans := make ([] string , 0 ) # if len ( s ) < 1 0 { # return ans # } # # cache := make ( map [ string ] int ) # for i := 0 ; i <= len ( s )- 1 0 ; i ++ { # curr := s [ i : i + 1 0 ] # if cache [ curr ] == 1 { # ans = append ( ans , curr ) # } # cache [ curr ] += 1 # } # return ans
index := make ( map [ int ] int , len ( nums )) # # for i , b := range nums { # if j , ok := index [ target - b ]; ok { # return [] int { j , i } # } # # index [ b ] = i # } # # return nil
sum := 0 # for _ , v := range A { # if v % 2 == 0 { # sum += v # } # } # ret := [] int {} # for _ , v := range queries { # if A [ v [ 0 ]]% 2 == 0 { # sum -= A [ v [ 0 ]] # } # A [ v [ 0 ]] += v [ 1 ] # if A [ v [ 0 ]]% 2 == 0 { # sum += A [ v [ 0 ]] # } # ret = append ( ret , sum ) # } # return ret
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 2 , 3 , 1 }, 4 }, # {" STR ", [] int { 2 , 7 , 9 , 3 , 1 }, 1 2 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := rob 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if len ( words ) < 2 { # return words # } # answer := make ([] string , 0 , len ( words )) # answer = append ( answer , words [ 0 ]) # remaining := make ( map [ rune ] map [ string ] struct {}, len ( words )) # for i := 1 ; i < len ( words ); i ++ { # word := words [ i ] # firstRune := rune ( word [ 0 ]) # if _ , ok := remaining [ firstRune ]; ! ok { # remaining [ firstRune ] = make ( map [ string ] struct {}) # } # remaining [ firstRune ][ word ] = struct {}{} # } # return circleWords ( answer , remaining )
if K > 1 { # bs := [] byte ( S ) # sort . Slice ( bs , func ( i , j int ) bool { # return bs [ i ] < bs [ j ] # }) # return string ( bs ) # } # n := len ( S ) # res := S # for i := 1 ; i < n ; i ++ { # tmp := S [ i :] + S [: i ] # if res > tmp { # res = tmp # } # } # return res
bob := strings . Builder {} # bob . WriteString ( fmt . Sprintf (" STR ", & n , n . value , n . sum )) # if n . left == nil { # bob . WriteString (" STR ") # } else { # bob . WriteString ( fmt . Sprintf (" STR ", n . left . value , n . left . sum )) # } # # if n . right == nil { # bob . WriteString (" STR ") # } else { # bob . WriteString ( fmt . Sprintf (" STR ", n . right . value , n . right . sum )) # } # # if n . parent == nil { # bob . WriteString (" STR ") # } else { # bob . WriteString ( fmt . Sprintf (" STR ", n . parent . value , n . parent . sum )) # } # # if n . chosen == nil { # bob . WriteString (" STR ") # } else { # bob . WriteString ( fmt . Sprintf (" STR ", n . chosen . value )) # } # return bob . String ()
if tree == nil { # return 0 # } # var leftHeight , rightHeight int # for left := tree ; left != nil ; left = left . Left { # leftHeight ++ # } # for right := tree ; right != nil ; right = right . Right { # rightHeight ++ # } # if leftHeight == rightHeight { # return ( 1 << uint ( leftHeight )) - 1 # } # return CountCompleteBinaryTree ( tree . Left ) + CountCompleteBinaryTree ( tree . Right ) + 1
minIndex := 0 # maxIndex := len ( array ) - 1 # for minIndex <= maxIndex { # midIndex := int (( maxIndex + minIndex ) / 2 ) # midItem := array [ midIndex ] # if number == midItem { # return midIndex # } # if midItem < number { # minIndex = midIndex + 1 # } else if midItem > number { # maxIndex = midIndex - 1 # } # } # return - 1
p := nthPrime ( 6 ) # # fmt . Println ( p ) #
for _ , v := range os . Args [ 1 :] { # f , err := os . Open ( v ) # if err != nil { # log . Fatalln (" STR ", err . Error ()) # } # defer f . Close () # # io . Copy ( os . Stdout , f ) # } # #
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", # [][] int {{ 1 , 2 , 3 }, { 4 }}, # 7 , # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := combinationSum 4 ( c . inputs [ 0 ], c . inputs [ 1 ][ 0 ]) # # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if len ( temp ) == 4 && len ( s ) == 0 { # * result = append (* result , strings . Join ( temp , " STR ")) # return # } # # if len ( temp ) == 4 || len ( s ) > 3 *( 4 - len ( temp )) || len ( s ) < ( 4 - len ( temp )) { # return # } # # for i := 1 ; i <= 3 ; i ++ { # if i > len ( s ) { # continue # } # num , _ := strconv . Atoi ( s [: i ]) # if s [: i ] != strconv . Itoa ( num ) || num > 2 5 5 { # continue # } # # temp = append ( temp , s [: i ]) # dfs ( s [ i :], temp , result ) # temp = temp [: len ( temp )- 1 ] # }
var last , first , second , max * TreeNode # for root != nil { # if root . Left == nil { # if last != nil && root . Val <= last . Val { # if first == nil { # first = last # } # second = root # } # last = root # root = root . Right # } else { # max = root . Left # for max . Right != nil && max . Right != root { # max = max . Right # } # # if max . Right != root { # max . Right = root # root = root . Left # } else { # max . Right = nil # if last != nil && root . Val <= last . Val { # if first == nil { # first = last # } # second = root # } # last = root # root = root . Right # } # } # } # first . Val , second . Val = second . Val , first . Val
m := make ( map [ int ] int ) # for i , v := range B { # m [ v ] = i # } # ret := [] int {} # for _ , v := range A { # ret = append ( ret , m [ v ]) # } # return ret
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 7 , 1 , 5 , 3 , 6 , 4 }, 7 }, # {" STR ", [] int { 1 , 2 , 3 , 4 , 5 }, 4 }, # {" STR ", [] int { 7 , 6 , 4 , 3 , 1 }, 0 }, # } # # for i , c := range cases { # t . Run ( c . name + strconv . Itoa ( i ), func ( t * testing . T ) { # got := maxProfit 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
negative := false # if num < 0 { # negative = true # num = - num # } # # bf := bytes . NewBufferString ("") # for num >= 7 { # mod := num % 7 # num /= 7 # bf . WriteByte ( byte ( mod ) + 4 8 ) # } # # bf . WriteByte ( byte ( num ) + 4 8 ) # if negative { # bf . WriteByte (" STR ") # } # # bs := bf . Bytes () # for s , e := 0 , len ( bs )- 1 ; s < e ; s , e = s + 1 , e - 1 { # bs [ s ], bs [ e ] = bs [ e ], bs [ s ] # } # return string ( bs )
b := intSlice {} # for _ , v := range a { # b = append ( b , v ) # } # return b
t . Parallel () # for _ , tc := range testcases { # if result := MinRemoveColumns ( tc . input ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 7 , 4 , 9 , 2 , 5 }, 6 }, # {" STR ", [] int { 1 , 1 7 , 5 , 1 0 , 1 3 , 1 5 , 1 0 , 5 , 1 6 , 8 }, 7 }, # {" STR ", [] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }, 2 }, # } # # for i , c := range cases { # t . Run ( c . name + strconv . Itoa ( i ), func ( t * testing . T ) { # got := wiggleMaxLength ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
cases := [] struct { # name string # input 1 [] int # input 2 int # expect float 6 4 # }{ # {" STR ", [] int { 1 , 1 2 , - 5 , - 6 , 5 0 , 3 }, 4 , 1 2 . 7 5 }, # {" STR ", [] int { 5 }, 1 , 5 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := findMaxAverage ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 ) # } # }) # }
s := [] string {" STR ", " STR ", " STR "} # res := s [ 0 ] # for _ , item := range s [ 1 :] { # n := len ( item ) # for k := range res { # if k >= n || res [ k ] != item [ k ] { # res = res [: k ] # } # } # } # fmt . Println ( res )
cases := [] struct { # name string # inputs int # expect int # }{ # {" STR ", 1 0 , 1 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := nthUglyNumber ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
size := len ( nums ) # if k <= 1 { # return nums # } # # g := k - 1 # # left := make ([] int , size ) # for i := 0 ; i < size ; i ++ { # if i % g == 0 { # left [ i ] = nums [ i ] # } else { # left [ i ] = max ( nums [ i ], left [ i - 1 ]) # } # } # # right := make ([] int , size ) # right [ size - 1 ] = nums [ size - 1 ] # for j := size - 2 ; j >= 0 ; j -- { # if ( j + 1 )% g == 0 { # right [ j ] = nums [ j ] # } else { # right [ j ] = max ( nums [ j ], right [ j + 1 ]) # } # } # # res := make ([] int , size - k + 1 ) # for i := 0 ; i <= size - k ; i ++ { # res [ i ] = max ( right [ i ], left [ i + k - 1 ]) # } # # return res
qs := [] question 1 2 9 5 { # # { # para 1 2 9 5 {[] int { 1 2 , 3 4 5 , 2 , 6 , 7 8 9 6 }}, # ans 1 2 9 5 { 2 }, # }, # # { # para 1 2 9 5 {[] int { 5 5 5 , 9 0 1 , 4 8 2 , 1 7 7 1 }}, # ans 1 2 9 5 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 9 5 , q . para 1 2 9 5 # fmt . Printf (" STR ", p , findNumbers ( p . one )) # } # fmt . Printf (" STR ")
type testCase struct { # param int # wantToReturn int # listCount int # } # # testCases := [] testCase { # { 5 , 4 , 8 }, # { 3 , 8 , 8 }, # { 8 , 5 , 8 }, # { 8 , 5 , 8 }, # { 2 , 1 4 , 1 4 }, # { 1 3 , 5 6 , 5 8 }, # { 7 , 5 , 5 }, # } # # for _ , tCase := range testCases { # list := NewCyclic () # fillList ( list , tCase . listCount ) # got := JosephusProblem ( list , tCase . param ) # if got != tCase . wantToReturn { # t . Errorf (" STR ", got , tCase . wantToReturn ) # } # }
if root == nil { # return 0 # } # count := 1 # queue := []* TreeNode { root } # for len ( queue ) > 0 { # l := len ( queue ) # for i := 0 ; i < l ; i ++ { # node := queue [ i ] # if node . Left == nil && node . Right == nil { # return count # } # if node . Left != nil { # queue = append ( queue , node . Left ) # } # if node . Right != nil { # queue = append ( queue , node . Right ) # } # } # count ++ # queue = queue [ l :] # } # return count
return float 6 4 ( c . R )* 0 . 3 + float 6 4 ( c . G )* 0 . 6 + float 6 4 ( c . B )* 0 . 1
if 0 == len { # return 0 # } # if 1 == len { # return nums [ 0 ] # } # if v , ok := table [ len ]; ok { # return v # } # max := recusiveRob ( nums , len - 2 , table ) + nums [ len - 1 ] # pre := recusiveRob ( nums , len - 1 , table ) # if pre > max { # max = pre # } # table [ len ] = max # return max
nodeG := TreeNode { Val : 1 , Left : nil , Right : nil } # nodeF := TreeNode { Val : 2 , Left : & nodeG , Right : nil } # nodeE := TreeNode { Val : 3 , Left : nil , Right : nil } # nodeD := TreeNode { Val : 4 , Left : & nodeE , Right : nil } # nodeC := TreeNode { Val : 5 , Left : nil , Right : nil } # nodeB := TreeNode { Val : 6 , Left : & nodeD , Right : & nodeF } # nodeA := TreeNode { Val : 7 , Left : & nodeB , Right : & nodeC } # # result := postorderTraversal (& nodeA ) # result 2 := postorderTraversal 2 (& nodeA ) # expected := [] int { 3 , 4 , 1 , 2 , 6 , 5 , 7 } # if ! reflect . DeepEqual ( result , expected ) && ! reflect . DeepEqual ( result 2 , expected ) { # t . Fatalf (" STR ", # expected , result ) # }
for i , j := 0 , 1 ; i < j && j < len ( nums ); { # if nums [ j ] == nums [ i ] { # nums = append ( nums [: i ], nums [ i + 1 :]...) # j -- # i -- # } # j ++ # i ++ # } # return len ( nums )
cases := [] struct { # name string # inputs int # expect [] int # }{ # {" STR ", 1 , [] int { 1 }}, # {" STR ", 1 4 , [] int { 1 , 3 , 4 , 1 4 }}, # {" STR ", 2 6 , [] int { 1 , 2 , 6 , 1 0 , 2 6 }}, # {" STR ", 1 2 3 4 , [] int { 1 , 3 , 4 , 1 4 , 1 9 , 5 7 , 7 7 , 2 2 9 , 3 0 8 , 9 1 8 , 1 2 3 4 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
list := NewCyclic () # fillList ( list , 3 ) # # want := 2 # wantSize := 2 # list . Delete () # got := list . Head . Val # if want != got { # t . Errorf (" STR ", got , want ) # } # if wantSize != list . Size { # t . Errorf (" STR ", got , want ) # }
qs := [] question 3 3 { # # { # para 3 3 {[] int { 3 , 1 }, 1 }, # ans 3 3 { 1 }, # }, # # { # para 3 3 {[] int { 4 , 5 , 6 , 7 , 0 , 1 , 2 }, 0 }, # ans 3 3 { 4 }, # }, # # { # para 3 3 {[] int { 4 , 5 , 6 , 7 , 0 , 1 , 2 }, 3 }, # ans 3 3 {- 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 3 , q . para 3 3 # fmt . Printf (" STR ", p , search 3 3 ( p . nums , p . target )) # } # fmt . Printf (" STR ")
counter := make ( map [ int ] int ); # for _ , num := range nums { # if v , ok := counter [ num ]; ok { # counter [ num ] = v + 1 ; # } else { # counter [ num ] = 1 ; # } # } # values := make ([] int , 0 , len ( counter )) # for _ , val := range counter { # values = append ( values , val ); # } # sort . Sort ( sort . Reverse ( sort . IntSlice ( values ))); # n := len ( nums ); # res , total := 0 , 0 # for _ , val := range values { # total += val ; # res += 1 ; # if total >= n / 2 { # return res ; # } # } # return n ;
switch u . op { # case " STR ": # return + u . x . Eval ( env ) # case " STR ": # return - u . x . Eval ( env ) # } # panic ( fmt . Sprintf (" STR ", u . op ))
m , n := len ( word 1 ), len ( word 2 ) # dp := make ([][] int , m + 1 ) # for i := range dp { # dp [ i ] = make ([] int , n + 1 ) # dp [ i ][ 0 ] = i # } # for j := range dp [ 0 ] { # dp [ 0 ][ j ] = j # } # for i , v := range word 1 { # for j , vv := range word 2 { # switch vv { # case v : # dp [ i + 1 ][ j + 1 ] = dp [ i ][ j ] # default : # dp [ i + 1 ][ j + 1 ] = minOfThree ( dp [ i + 1 ][ j ]+ 1 , dp [ i ][ j + 1 ]+ 1 , dp [ i ][ j ]+ 1 ) # } # } # } # return dp [ m ][ n ]
if num == 0 { # return false # } # sum := 0 # # for i := 1 ; i <= num / 2 ; i ++ { # if num % i == 0 { # sum += i # # } # # } # return sum == num
cases := [] struct { # name string # A [] int # K int # expect [] int # }{ # {" STR ", [] int { 1 , 2 , 0 , 0 }, 3 4 , [] int { 1 , 2 , 3 , 4 }}, # {" STR ", [] int { 0 }, 0 , [] int { 0 }}, # {" STR ", [] int { 9 , 9 , 9 , 9 , 9 }, 1 , [] int { 1 , 0 , 0 , 0 , 0 , 0 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . A , c . K ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . A , c . K ) # } # }) # }
t . Parallel () # for _ , tc := range testcases { # if result := FindLongestAbsolutePathLength ( tc . fs ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
if z == 0 { # return true # } # # if x + y < z { # return false # } # # if x > y { # x , y = y , x # } # # if x == 0 { # return y == z # } # # for y % x != 0 { # x , y = y % x , x # } # return z % x == 0
cases := [] struct { # name string # inputs int # expect int # }{ # {" STR ", 1 0 , 4 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := countPrimes 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
x , y := len ( grid [ 0 ]), len ( grid ) # newGrid := make ([][] int , y ) # for i := 0 ; i < y ; i ++ { # newGrid [ i ] = make ([] int , x ) # } # for i := 0 ; i < y ; i ++ { # for j := 0 ; j < x ; j ++ { # ny := ( k / x ) + i # if ( j + ( k % x )) >= x { # ny ++ # } # newGrid [ ny % y ][( j +( k % x ))% x ] = grid [ i ][ j ] # } # } # return newGrid
if size < 1 || size > tp . maxSize { # return make ([] byte , size ) # } # var x [] byte # # o := log 2 Ceil ( uint 3 2 ( size )) # p := & tp . list_of_pools [ o ] # p . mu . Lock () # if n := len ( p . list ); n > 0 { # x = p . list [ n - 1 ] # p . list [ n - 1 ] = nil # p . list = p . list [: n - 1 ] # } # p . mu . Unlock () # if x == nil { # x = make ([] byte , 1 << o ) # } # return x [: size ]
var items [] int # # current := list . top # for current != nil { # items = append ( items , current . data ) # current = current . next # } # return items
var n , m , c int # for i := 1 ; ; i ++ { # n , m , c = i * ( i + 1 ) / 2 , int ( math . Sqrt ( float 6 4 ( n ))), 0 # for f := 1 ; f < m ; f ++ { # if n % f == 0 { c ++ } # } # c *= 2 # if m * m == n { c += 1 } # if c > 5 0 0 { # fmt . Println ( n ) # break # } # }
c , visited , res := [] int {}, map [ int ] bool {}, [][] int {} # for i := 0 ; i < len ( nums )- 1 ; i ++ { # if _ , ok := visited [ nums [ i ]]; ok { # continue # } else { # visited [ nums [ i ]] = true # generateIncSubsets ( nums , i , c , & res ) # } # } # return res
var tests = [] struct { # n int # b bool # }{ # { 0 , false }, # { 9 , true }, # { 2 7 , true }, # { 4 5 , false }, # } # # for _ , tt := range tests { # b := isPowerOfThree ( tt . n ) # if b != tt . b { # t . Errorf (" STR ", tt . n , b , tt . b ) # } # }
m := make ( map [ int ] int , len ( nums )) # # for i , v := range nums { # sub := target - v # if j , ok := m [ sub ]; ok { # return [] int { j , i } # } else { # m [ v ] = i # } # } # # return nil
if numerator == 0 { # return " STR " # } # m := [] byte (" STR ") # var ret string # var neg bool # if numerator < 0 { # numerator *= - 1 # neg = ! neg # } # if denominator < 0 { # denominator *= - 1 # neg = ! neg # } # if neg { # ret = " STR " # } # ret += strconv . Itoa ( numerator / denominator ) # remainder := numerator % denominator # if remainder == 0 { # return ret # } # ret += " STR " # floatBytes := [] byte {} # indexMap := map [ int ] int {} # for remainder != 0 { # if idx , ok := indexMap [ remainder ]; ok { # return ret + string ( floatBytes [: idx ]) + " STR " + string ( floatBytes [ idx :]) + " STR " # } # indexMap [ remainder ] = len ( floatBytes ) # remainder *= 1 0 # v := m [ remainder / denominator ] # remainder %= denominator # floatBytes = append ( floatBytes , v ) # } # return ret + string ( floatBytes )
defer conn . Close () # # scanner := bufio . NewScanner ( conn ) # for scanner . Scan () { # ln := scanner . Text () # fs := strings . Fields ( ln ) # # result := make ( chan string ) # commands <- Command { # Fields : fs , # Result : result , # } # # io . WriteString ( conn , <- result +" STR ") # } #
if head == nil { # return nil # } # head . Left = PruneZeroSubtrees ( head . Left ) # head . Right = PruneZeroSubtrees ( head . Right ) # if head . Value == 0 && head . Left == nil && head . Right == nil { # return nil # } # return head
s := " STR " + # " STR " + # " STR " + # " STR " + # " STR " + # " STR " + # " STR " + # " STR " + # " STR " + # " STR " + # " STR " + # " STR " + # " STR " + # " STR " + # " STR " + # " STR " + # " STR " + # " STR " + # " STR " + # " STR " # println (" STR ") # biggest := 0 # for i := 0 ; i + 1 3 < len ( s ); i ++ { # set := s [ i : i + 1 3 ] # res := 1 # for _ , v := range set { # res *= int ( v - ' 0 ') # } # if res > biggest { # biggest = res # println (" STR ", set ) # } # } # println (" STR ", biggest )
n := len ( graph ) # if n == 0 { # return nil # } # res := [] int {} # color := make ([] int , n ) # var dfs func ( int ) bool # dfs = func ( start int ) bool { # if color [ start ] != 0 { # return color [ start ] == 1 # } # color [ start ] = 2 # for _ , node := range graph [ start ] { # if ! dfs ( node ) { # return false # } # } # color [ start ] = 1 # return true # } # for i := 0 ; i < n ; i ++ { # if dfs ( i ) { # res = append ( res , i ) # } # } # return res
if len ( word ) == 0 { # return false # } # b := [] byte ( word ) # for x := range borad { # for y := range borad [ x ] { # if dfs ( x , y , borad , b ) { # return true # } # } # } # return false
if a < b { # return a # } else { # return divide ( a - b , b ) # }
tests := [...] testType { # { # in : 1 3 , # want : 4 , # }, # { # in : 2 , # want : 2 , # }, # { # in : 1 5 , # want : 6 , # }, # { # in : 2 4 , # want : 5 , # }, # } # for _ , tt := range tests { # got := countLargestGroup ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
l := len ( s ) # if l == 0 { # return nil # } # tree := & TreeNode { Val : s [ 0 ]} # node , queue := tree , make ([]* TreeNode , 0 ) # for i := 1 ; i < l ; i ++ { # if s [ i ] != NULL { # node . Left = & TreeNode { Val : s [ i ]} # queue = append ( queue , node . Left ) # } # i ++ # if i < l && s [ i ] != NULL { # node . Right = & TreeNode { Val : s [ i ]} # queue = append ( queue , node . Right ) # } # if len ( queue ) > 0 { # node = queue [ 0 ] # queue = queue [ 1 :] # } else { # break # } # } # return tree
i , j := - 1 , len ( nums ) # for k := 0 ; k < j ; { # if nums [ k ] == 0 && k != i { # i ++ # nums [ i ], nums [ k ] = nums [ k ], nums [ i ] # } else if nums [ k ] == 2 { # j -- # nums [ j ], nums [ k ] = nums [ k ], nums [ j ] # } else { # k ++ # } # }
h 1 , v 1 := projecting ( rec 1 ) # h 2 , v 2 := projecting ( rec 2 ) # return isLineOverlap ( h 1 , h 2 ) && isLineOverlap ( v 1 , v 2 )
if len ( preorder ) == 0 { # return nil # } # # root := & TreeNode { # Val : preorder [ 0 ], # Left : nil , # Right : nil , # } # if len ( preorder ) == 1 { # return root # } # idx := 0 # for idx = 0 ; preorder [ 0 ]!= inorder [ idx ]; idx ++{ # } # root . Left = buildTree ( preorder [ 1 : idx + 1 ], inorder [: idx ]) # root . Right = buildTree ( preorder [ idx + 1 :], inorder [ idx + 1 :]) # return root #
res , round , spDir := [][] int {}, 0 , [][] int { # { 0 , 1 }, # { 1 , 0 }, # { 0 , - 1 }, # {- 1 , 0 }, # } # res = append ( res , [] int { r 0 , c 0 }) # for i := 0 ; len ( res ) < R * C ; i ++ { # for j := 0 ; j < i / 2 + 1 ; j ++ { # r 0 += spDir [ round % 4 ][ 0 ] # c 0 += spDir [ round % 4 ][ 1 ] # if 0 <= r 0 && r 0 < R && 0 <= c 0 && c 0 < C { # res = append ( res , [] int { r 0 , c 0 }) # } # } # round ++ # } # return res
img , kind , err := image . Decode ( in ) # if err != nil { # return err # } # fmt . Fprintln ( os . Stderr , " STR ", kind ) # return jpeg . Encode ( out , img , & jpeg . Options { Quality : 9 5 })
cases := [] struct { # name string # inputs [][] byte # expect int # }{ # {" STR ", [][] byte { # {' 1 ', ' 0 ', ' 1 ', ' 0 ', ' 0 '}, # {' 1 ', ' 0 ', ' 1 ', ' 1 ', ' 1 '}, # {' 1 ', ' 1 ', ' 1 ', ' 1 ', ' 1 '}, # {' 1 ', ' 0 ', ' 0 ', ' 1 ', ' 0 '}, # }, 6 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := maximalRectangle ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
if list . top == nil { # return 0 , false # } # return list . top . data , true
return s . top == 0
m , n := len ( nums ), len ( nums [ 0 ]) # if m * n != r * c { # return nums # } # newNums := make ([][] int , r ) # for i := range newNums { # newNums [ i ] = make ([] int , c ) # } # k := 0 # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # r_ , c_ := k / c , k % c # newNums [ r_ ][ c_ ] = nums [ i ][ j ] # k ++ # } # } # return newNums
t . Parallel () # # for _ , tc := range testcases { # if steps := MinimumStepsPath ( tc . path ); steps != tc . minimumSteps { # t . Errorf (" STR ", tc . minimumSteps , steps ) # } # }
circularsCount := 0 # # for i := 2 ; i < 1 0 0 ; i ++ { # # if ! isPrime ( i ) { # continue # } # # var arr [][] int # arr = append ( arr , getDigits ( i )) # # permutations := getPermutations ( arr ) # # permutationsWithoutDuplicates := removeDuplicates ( permutations ) # # for _ , p := range permutationsWithoutDuplicates { # # if ! isPrime ( formNumber ( p )) { # continue # } # # circularsCount ++ # } # # } # # fmt . Println ( circularsCount ) #
hasSum := [ 3 0 0 1 ] bool {} # hasSum [ 0 ] = true # sum := 0 # for _ , s := range stones { # sum += s # for i := sum ; i >= s ; i -- { # hasSum [ i ] = hasSum [ i ] || hasSum [ i - s ] # } # } # part := sum / 2 # for part >= 0 && ! hasSum [ part ] { # part -- # } # return sum - part - part
return helper 8 9 ( n )
res := 0 # d := map [ byte ] int { # ' I ': 1 , # ' V ': 5 , # ' X ': 1 0 , # ' L ': 5 0 , # ' C ': 1 0 0 , # ' D ': 5 0 0 , # ' M ': 1 0 0 0 , # } # # last := 0 # for i := len ( s ) - 1 ; i >= 0 ; i -- { # tmp := d [ s [ i ]] # sign := 1 # if tmp < last { # sign = - 1 # } # res += sign * tmp # last = tmp # } # return res
tNode := & TreeNode {} # tNode . val = 6 # # tNode 1 := & TreeNode {} # tNode 1 . val = 2 # # tNode 2 := & TreeNode {} # tNode 2 . val = 8 # # tNode 3 := & TreeNode {} # tNode 3 . val = 0 # # tNode 4 := & TreeNode {} # tNode 4 . val = 4 # # tNode 5 := & TreeNode {} # tNode 5 . val = 7 # # tNode 6 := & TreeNode {} # tNode 6 . val = 9 # # tNode 9 := & TreeNode {} # tNode 9 . val = 3 # # tNode 1 0 := & TreeNode {} # tNode 1 0 . val = 5 # # tNode . left = tNode 1 # tNode . right = tNode 2 # # tNode 1 . left = tNode 3 # tNode 1 . right = tNode 4 # tNode 2 . left = tNode 5 # tNode 2 . right = tNode 6 # # tNode 4 . left = tNode 9 # tNode 4 . right = tNode 1 0 # # luckyNode := Lowest ( tNode , tNode 1 , tNode 2 ) # t . Logf (" STR ", luckyNode . val ) # if luckyNode != tNode { # t . Fatalf (" STR ") # }
rows := [] string {" STR ", " STR ", " STR "} # output := make ([] string , 0 ) # for _ , s := range words { # if len ( s ) == 0 { # continue # } # lowerS := strings . ToLower ( s ) # oneRow := false # for _ , r := range rows { # if strings . ContainsAny ( lowerS , r ) { # oneRow = ! oneRow # if ! oneRow { # break # } # } # } # if oneRow { # output = append ( output , s ) # } # } # return output
bytes 1 , bytes 2 := [] byte ( version 1 ), [] byte ( version 2 ) # bToI := map [ byte ] int { # ' 0 ': 0 , # ' 1 ': 1 , # ' 2 ': 2 , # ' 3 ': 3 , # ' 4 ': 4 , # ' 5 ': 5 , # ' 6 ': 6 , # ' 7 ': 7 , # ' 8 ': 8 , # ' 9 ': 9 , # } # i , j := - 1 , - 1 # for i < len ( bytes 1 ) || j < len ( bytes 2 ) { # var num 1 , num 2 int # for i ++; i < len ( bytes 1 ) && bytes 1 [ i ] != '.'; i ++ { # num 1 = num 1 * 1 0 + bToI [ bytes 1 [ i ]] # } # for j ++; j < len ( bytes 2 ) && bytes 2 [ j ] != '.'; j ++ { # num 2 = num 2 * 1 0 + bToI [ bytes 2 [ j ]] # } # if num 1 > num 2 { # return 1 # } else if num 1 < num 2 { # return - 1 # } # } # return 0
if n == 0 { # return 1 . 0 0 0 0 0 # } # if n == 1 { # return x # } # if n < 0 { # return myPow ( 1 . 0 / x , - n ) # } # if n % 2 != 0 { # return x * myPow ( x , n - 1 ) # } # return myPow ( x * x , n / 2 )
sort . Slice ( points , func ( i , j int ) bool { # return points [ i ][ 0 ]* points [ i ][ 0 ]+ points [ i ][ 1 ]* points [ i ][ 1 ] < # points [ j ][ 0 ]* points [ j ][ 0 ]+ points [ j ][ 1 ]* points [ j ][ 1 ] # }) # ans := make ([][] int , K ) # for i := 0 ; i < K ; i ++ { # ans [ i ] = points [ i ] # } # return ans
move := R * C - 1 # x , y , dx , dy , round := r 0 , c 0 , 0 , 1 , 2 # res := [][] int {[] int { x , y }} # for move > 0 { # for m := round / 2 ; m > 0 ; m -- { # x += dx # y += dy # if 0 <= x && x < R && 0 <= y && y < C { # res = append ( res , [] int { x , y }) # move -- # } # } # round ++ # dx , dy = dy , - dx # } # return res
matrix := [][] int { # { 3 , 0 , 1 , 4 , 2 }, # { 5 , 6 , 3 , 2 , 1 }, # { 1 , 2 , 0 , 1 , 5 }, # { 4 , 1 , 0 , 1 , 7 }, # { 1 , 0 , 3 , 0 , 5 }, # } # # obj := Constructor ( matrix ) # # testData := [][] int { # { 2 , 1 , 4 , 3 }, # { 1 , 1 , 2 , 2 }, # { 1 , 2 , 2 , 4 }, # } # expected := [] int { 8 , 1 1 , 1 2 } # # for index , data := range testData { # if res := obj . SumRegion ( data [ 0 ], data [ 1 ], data [ 2 ], data [ 3 ]); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # } # # if res := Constructor ([][] int {}); res . dp != nil { # t . Errorf (" STR ", res . dp ) # } # if res := Constructor ( make ([][] int , 3 )); res . dp != nil { # t . Errorf (" STR ", res . dp ) # }
res , i , max , m := 0 , 0 , 1 , len ( nums ) # # for max <= n { # if i < m && nums [ i ] <= max { # max += nums [ i ] # i ++ # } else { # max <<= 1 # res ++ # } # } # return res
cases := [] struct { # name string # words [] string # chars string # expect int # }{ # {" STR ", [] string {" STR ", " STR ", " STR ", " STR "}, " STR ", 6 }, # {" STR ", [] string {" STR ", " STR ", " STR "}, " STR ", 1 0 }, # {" STR ", [] string {}, " STR ", 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . words , c . chars ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . words , c . chars ) # } # }) # }
lo , hi := 0 , m - 1 # for _ , num := range nums 2 { # p := position ( nums 1 , num , lo , hi ) # lo , hi = p + 1 , hi + 1 # # for i := m ; i > p ; i -- { # nums 1 [ i ] = nums 1 [ i - 1 ] # } # nums 1 [ p ] = num # m ++ # }
l := len ( triangle ) # if l == 0 { # return 0 # } # if l == 1 { # return triangle [ 0 ][ 0 ] # } # dp := make ([] int , l ) # for i := 0 ; i < l ; i ++ { # dp [ i ] = triangle [ l - 1 ][ i ] # } # for i := l - 2 ; i >= 0 ; i -- { # for j := 0 ; j < len ( triangle [ i ]); j ++ { # dp [ j ] = min ( dp [ j ], dp [ j + 1 ]) + triangle [ i ][ j ] # } # } # return dp [ 0 ]
qs := [] question 1 1 2 2 { # # { # para 1 1 2 2 {[] int { 2 , 3 , 1 , 3 , 2 , 4 , 6 , 7 , 9 , 2 , 1 9 }, [] int { 2 , 1 , 4 , 3 , 9 , 6 }}, # ans 1 1 2 2 {[] int { 2 , 2 , 2 , 1 , 4 , 3 , 3 , 9 , 6 , 7 , 1 9 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 1 2 2 , q . para 1 1 2 2 # fmt . Printf (" STR ", p , relativeSortArray ( p . arr 1 , p . arr 2 )) # } # fmt . Printf (" STR ")
return helper ( nums , 0 , len ( nums ))
const sum = 1 0 0 0 # # for a := 1 ; a < sum ; a ++ { # a 2 := a * a # for b := a ; b < sum ; b ++ { # b 2 := b * b # c 2 := a 2 + b 2 # c := int ( math . Sqrt ( float 6 4 ( c 2 ))) # if c * c == c 2 && ( a + b + c ) == sum { # fmt . Println ( a , b , c , a * b * c ) # } # } # }
var res [] int # var stack = []* TreeNode { root } # for 0 < len ( stack ) { # top := len ( stack ) - 1 # root = stack [ top ] # stack = stack [: top ] # if root != nil { # res = append ( res , root . Val ) # stack = append ( stack , root . Right , root . Left ) # } # } # return res
d := [] byte ( dominoes ) # for i := 0 ; i < len ( d ); { # j := i + 1 # for j < len ( d )- 1 && d [ j ] == '.' { # j ++ # } # push ( d [ i : j + 1 ]) # i = j # } # return string ( d )
qs := [] question 2 1 0 { # # { # para 2 1 0 { 2 , [][] int {{ 1 , 0 }}}, # ans 2 1 0 {[] int { 0 , 1 }}, # }, # # { # para 2 1 0 { 2 , [][] int {{ 1 , 0 }, { 0 , 1 }}}, # ans 2 1 0 {[] int { 0 , 1 , 2 , 3 }}, # }, # # { # para 2 1 0 { 4 , [][] int {{ 1 , 0 }, { 2 , 0 }, { 3 , 1 }, { 3 , 2 }}}, # ans 2 1 0 {[] int { 0 , 1 , 2 , 3 }}, # }, # # { # para 2 1 0 { 3 , [][] int {{ 1 , 0 }, { 1 , 2 }, { 0 , 1 }}}, # ans 2 1 0 {[] int {}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 1 0 , q . para 2 1 0 # fmt . Printf (" STR ", p , findOrder ( p . one , p . pre )) # } # fmt . Printf (" STR ")
var lp [] int # lp = make ([] int , upperBound + 1 ) # # var primes [] int # # for i := 2 ; i <= upperBound ; i ++ { # if lp [ i ] == 0 { # lp [ i ] = i # primes = append ( primes , i ) # } # for j := 0 ; j < len ( primes ) && primes [ j ] <= lp [ i ] && i * primes [ j ] <= upperBound ; j ++ { # lp [ i * primes [ j ]] = primes [ j ] # } # } # # return primes
var tests = [] struct { # before [] interface {} # L , R int # after * TreeNode # }{ # {[] interface {}{ 1 , 0 , 2 }, 1 , 2 , newTree ( 1 , nil , 2 )}, # {[] interface {}{ 3 , 0 , 4 , nil , 2 , nil , nil , 1 }, 1 , 3 , newTree ( 3 , 2 , nil , 1 )}, # } # # for _ , tt := range tests { # after := trimBST ( newTree ( tt . before ...), tt . L , tt . R ) # if reflect . DeepEqual ( after , tt . after ) == false { # t . Errorf (" STR ", newTree ( tt . before ...), tt . L , tt . R , after , tt . after ) # } # }
record := make ( map [ int ] int ) # # for i , j := range nums { # complement := target - j # if res , ok := record [ complement ]; ok { # return [] int { res , i } # } # record [ j ] = i # } # return [] int {}
max := nums [ 0 ] # # p 1 , p 2 := nums [ 0 ], nums [ 0 ] # for _ , num := range nums [ 1 :] { # if num < 0 { # p 1 , p 2 = p 2 , p 1 # } # # p 1 *= num # p 2 *= num # if num < p 1 { # p 1 = num # } # if num > p 2 { # p 2 = num # } # # if p 2 > max { # max = p 2 # } # } # # return max
from , to := os . Args [ 1 ], os . Args [ 2 ] # # fromTime , _ := time . Parse (" STR ", from ) # toTime , _ := time . Parse (" STR ", to ) # # dur := toTime . Sub ( fromTime ) # fmt . Println (" STR ", int ( dur /( time . Hour * 2 4 ))) #
if n == 1 { # return false # } # if ( n == 2 || n == 3 ){ # return true # } # for i := 2 ; i <= int ( math . Sqrt ( float 6 4 ( n ))); i ++{ # if n % i == 0 { # return false # } # } # return true
rets := [] int {} # if root == nil { # return rets # } # stack := []* TreeNode {} # p := root # for len ( stack ) != 0 || p != nil { # for p != nil { # rets = append ( rets , p . Val ) # stack = append ( stack , p ) # p = p . Left # } # if len ( stack ) != 0 { # p = stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # p = p . Right # } # } # return rets
if len ( pre ) == 0 || len ( in ) == 0 { # return nil # } # mid := search ( in , pre [ 0 ]) # return & TreeNode { # Val : pre [ 0 ], # Left : buildTree ( pre [ 1 : mid + 1 ], in [: mid + 1 ]), # Right : buildTree ( pre [ mid + 1 :], in [ mid + 1 :]), # }
m := make ( map [ string ] int , len ( cpdomains )) # # for _ , domin := range cpdomains { # d , n := parse ( domin ) # isNew := true # for isNew { # m [ d ] += n # d , isNew = cut ( d ) # } # } # # return getResult ( m )
max := 0 # for _ , num := range nums { # if num > max { # max = num # } # } # distance := 0 # for i := 0 ; max > 0 ; i ++ { # binaryOnes := 0 # for _ , num := range nums { # if 1 == ( num >> uint ( i ) & 1 ) { # binaryOnes += 1 # } # } # distance += ( len ( nums ) - binaryOnes ) * binaryOnes # max >>= 1 # } # return distance
return this . min [ len ( this . min )- 1 ]
r := make ( map [ int ] int , len ( nums )) # for _ , n := range nums { # r [ n ]++ # } # # max := 0 # for n , c 1 := range r { # c 2 , ok := r [ n + 1 ] # if ok { # t := c 1 + c 2 # if max < t { # max = t # } # } # } # # return max
for j := 2 ; ; j ++ { # i := ( j * ( j + 1 )) / 2 # ttlDivisors := 0 # for x := 2 ; x <= i ; x ++ { # if i % x == 0 { # ttlDivisors ++ # } # } # if ttlDivisors > 2 0 0 { # println (" STR ", i ) # return # } # }
weights := make ([] int , len ( peopleWeights )) # copy ( weights , peopleWeights ) # sort . Sort ( sort . Reverse ( sort . IntSlice ( weights ))) # var boats int # for i , weight := range weights { # if weight != - 1 { # if weight > k { # panic (" STR ") # } # remaining := k - weight # weights [ i ] = - 1 # for j := i + 1 ; j < len ( weights ); j ++ { # if weights [ j ] != - 1 && weights [ j ] <= remaining { # weights [ j ] = - 1 # break # } # } # boats ++ # } # } # return boats
primeIdx = 0 # for i := 0 ; i < len ( arr )- 1 ; i ++ { # if arr [ i ] < arr [ len ( arr )- 1 ] { # arr [ i ], arr [ primeIdx ] = arr [ primeIdx ], arr [ i ] # primeIdx ++ # } # } # arr [ primeIdx ], arr [ len ( arr )- 1 ] = arr [ len ( arr )- 1 ], arr [ primeIdx ] # return
var sum int 6 4 = 2 # for i := 3 ; i < 2 0 0 0 0 0 0 ; i += 2 { # if isPrime ( i ) { # sum += int 6 4 ( i ) # } # } # fmt . Println ( sum )
if k == 0 { # return true # } # if sum == target { # return helper ( nums , v , 0 , 0 , k - 1 , target ) # } # if sum > target { # return false # } # for i := l ; i < len ( nums ); i ++ { # if v [ i ] == 1 { # continue # } # v [ i ] = 1 # if helper ( nums , v , i + 1 , sum + nums [ i ], k , target ) { # return true # } # v [ i ] = 0 # } # return false
if n == 0 { # return false # } # for n % 2 == 0 { # n /= 2 # } # return n == 1
tests := [...] testType { # { # in : [] string {" STR ", " STR ", " STR "}, # want : [] string {" STR ", " STR ", " STR "}, # }, # { # in : [] string {" STR ", " STR ", " STR "}, # want : [] string {" STR ", " STR "}, # }, # } # for _ , tt := range tests { # got := commonChars ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
pat := " STR " # re , _ := regexp . Compile ( pat ) # # s = re . ReplaceAllString ( s , " STR ") # s = strings . ToLower ( s ) # if s == " STR " { # return true # } # j := len ( s ) - 1 # for i := 0 ; i < len ( s )/ 2 ; i ++ { # if s [ i ] != s [ j ] { # return false # } # j -- # } # return true
qs := [] question 4 5 5 { # # { # para 4 5 5 {[] int { 1 , 2 , 3 }, [] int { 1 , 1 }}, # ans 4 5 5 { 1 }, # }, # # { # para 4 5 5 {[] int { 1 , 2 }, [] int { 1 , 2 , 3 }}, # ans 4 5 5 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 5 5 , q . para 4 5 5 # fmt . Printf (" STR ", p , findContentChildren ( p . g , p . s )) # } # fmt . Printf (" STR ")
qs := [] question 6 3 8 { # # { # para 6 3 8 {[] int { 2 , 5 }, [][] int {{ 3 , 0 , 5 }, { 1 , 2 , 1 0 }}, [] int { 3 , 2 }}, # ans 6 3 8 { 1 4 }, # }, # # { # para 6 3 8 {[] int { 2 , 3 , 4 }, [][] int {{ 1 , 1 , 0 , 4 }, { 2 , 2 , 1 , 9 }}, [] int { 1 , 2 , 1 }}, # ans 6 3 8 { 1 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 3 8 , q . para 6 3 8 # fmt . Printf (" STR ", p , shoppingOffers ( p . price , p . special , p . needs )) # } # fmt . Printf (" STR ")
if len ( strs ) == 0 { # return " STR " # } else if len ( strs ) == 1 { # return strs [ 0 ] # } # runesList := make ([][] rune , len ( strs )) # for index := range strs { # runesList [ index ] = [] rune ( strs [ index ]) # } # var ret [] rune # var currentRune rune # length := 0 # L : # for { # length ++ # for index := range runesList { # if len ( runesList [ index ]) < length { # break L # } # if index == 0 { # currentRune = runesList [ 0 ][ length - 1 ] # } else { # if runesList [ index ][ length - 1 ] != currentRune { # break L # } # } # } # ret = append ( ret , currentRune ) # } # return string ( ret )
sum := 0 # for i := 0 ; i < 1 0 0 0 ; i ++ { # sum += lengthNumber ( i ) # } # println ( sum + len (" STR "))
if len ( nums ) == 1 { # return 0 # } else if nums [ 0 ] >= len ( nums ) { # return 1 # } # left , right , res := 0 , nums [ 0 ], 0 # for right < len ( nums )- 1 { # max := 0 # for i := left ; i <= right ; i ++ { # if nums [ i ]-( right - i ) >= max { # max = nums [ i ] - ( right - i ) # } # } # left = right # right += max # res ++ # } # if left < len ( nums )- 1 { # res ++ # } # return res
return a + Min ( b )
if numRows == 1 || numRows <= 0 || numRows > len ( s ) { # return s # } # strArr := make ([][] byte , numRows ) # j := 0 # increasing := true # # for i := 0 ; i < len ( s ); i ++ { # strArr [ j ] = append ( strArr [ j ], s [ i ]) # # if increasing { # j ++ # if j == numRows - 1 { # increasing = false # } # } else { # j -- # if j == 0 { # increasing = true # } # } # } # fmt . Println ( strArr ) # res := make ([] byte , 0 ) # # for _ , str := range strArr { # res = append ( res , str ...) # } # return string ( res )
var s = make ([] int , len ( arr )/ 2 + 1 ) # if len ( arr ) < 2 { # return # } # # mid := len ( arr ) / 2 # # sort ( arr [: mid ]) # sort ( arr [ mid :]) # # if arr [ mid - 1 ] <= arr [ mid ] { # return # } # # copy ( s , arr [: mid ]) # # l , r := 0 , mid # # for i := 0 ; ; i ++ { # if s [ l ] <= arr [ r ] { # arr [ i ] = s [ l ] # l ++ # # if l == mid { # break # } # } else { # arr [ i ] = arr [ r ] # r ++ # if r == len ( arr ) { # copy ( arr [ i + 1 :], s [ l : mid ]) # break # } # } # } # return
t . Parallel () # # for _ , tc := range testcases { # if balanced := WildcardParens ( tc . input ); balanced != tc . balanced { # t . Errorf (" STR ", tc . input , tc . balanced , balanced ) # } # }
minIndex := 0 # maxIndex := len ( array ) - 1 # for minIndex <= maxIndex { # midIndex 1 := minIndex + int (( maxIndex - minIndex )/ 3 ) # midIndex 2 := maxIndex - int (( maxIndex - minIndex )/ 3 ) # midItem 1 := array [ midIndex 1 ] # midItem 2 := array [ midIndex 2 ] # if midItem 1 == number { # return midIndex 1 # } else if midItem 2 == number { # return midIndex 2 # } # if midItem 1 < number { # minIndex = midIndex 1 + 1 # } else if midItem 2 > number { # maxIndex = midIndex 2 - 1 # } else { # minIndex = midIndex 1 + 1 # maxIndex = midIndex 2 - 1 # } # } # return - 1
if head == nil { # return false # } # fast := head . Next # slow := head # # for slow != nil && fast != nil && fast . Next != nil { # slow = slow . Next # fast = fast . Next . Next # if fast == slow { # return true # } # } # return false
t . Parallel () # bc := NewBiasedCoin ( 9 9 ) # biasedResults := make ([] int , 2 ) # for i := 0 ; i < 1 0 0 0 0 0 ; i ++ { # biasedResults [ bc . Toss ()]++ # } # if biasedResults [ 1 ] == 0 { # t . Errorf (" STR ") # } # if ratio := biasedResults [ 0 ] / biasedResults [ 1 ]; ratio < 9 0 { # t . Errorf (" STR ", ratio ) # } # ft := NewFairTosser ( bc ) # fairResults := make ([] int , 2 ) # for i := 0 ; i < 1 0 0 0 0 0 ; i ++ { # fairResults [ ft . Toss ()]++ # } # if ratio := float 6 4 ( fairResults [ 0 ]) / float 6 4 ( fairResults [ 1 ]); ratio < 0 . 9 || ratio > 1 . 1 { # t . Errorf (" STR ", ratio ) # }
cases := [] struct { # name string # inputs [] int # target int # expect int # }{ # {" STR ", [] int { 1 , 2 , 2 , 2 , 3 }, 2 , 3 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := BinarySearchRightBound ( c . inputs , c . target ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
total , n := 0 , len ( nums ) # for i := 0 ; i < 3 2 ; i ++ { # bitCount := 0 # for j := 0 ; j < n ; j ++ { # bitCount += ( nums [ j ] >> uint ( i )) & 1 # } # total += bitCount * ( n - bitCount ) # } # return total
nums := make ([] int , n ) # for i := 0 ; i < len ( nums ); i ++ { # nums [ i ] = i # } # # return helper 5 1 ( nums , 0 , make ([][] string , 0 ))
l := len ( nums ) # dp := make ([][] int , l + 1 ) # for k := range dp { # dp [ k ] = make ([] int , l ) # } # for i := l ; i >= 0 ; i -- { # for j := i + 1 ; j < l ; j ++ { # a := nums [ i ] - dp [ i + 1 ][ j ] # b := nums [ j ] - dp [ i ][ j - 1 ] # dp [ i ][ j ] = max ( a , b ) # } # } # return dp [ 0 ][ l - 1 ] >= 0
cases := [] struct { # name string # inputs bool # expect bool # }{ # {" STR ", true , true }, # {" STR ", true , true }, # {" STR ", false , false }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # }) # }
S = S [ 1 : len ( S )- 1 ] # res := [] string {} # for i := 1 ; i < len ( S ); i ++ { # p 1 , p 2 := helper ( S [: i ]), helper ( S [ i :]) # for _ , a := range p 1 { # for _ , b := range p 2 { # res = append ( res , " STR "+ a +" STR "+ b +" STR ") # } # } # } # return res
qs := [] question 9 7 0 { # # { # para 9 7 0 { 2 , 3 , 1 0 }, # ans 9 7 0 {[] int { 2 , 3 , 4 , 5 , 7 , 9 , 1 0 }}, # }, # # { # para 9 7 0 { 3 , 5 , 1 5 }, # ans 9 7 0 {[] int { 2 , 4 , 6 , 8 , 1 0 , 1 4 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 7 0 , q . para 9 7 0 # fmt . Printf (" STR ", p , powerfulIntegers ( p . one , p . two , p . b )) # } # fmt . Printf (" STR ")
s := " STR " # i := len ( s ) - 1 # for i >= 0 && string ( s [ i ]) == " STR " { # i = i - 1 # } # res := 0 # for i >= 0 && string ( s [ i ]) != " STR " { # res = res + 1 # i = i - 1 # } # fmt . Println ( res )
tests := [...] struct { # s 1 [] int # s 2 [] int # expected bool # }{ # { # s 1 : [] int { 1 , 2 , 3 }, # s 2 : [] int { 1 , 2 , 3 }, # expected : true , # }, # { # s 1 : [] int { 1 , 2 , 3 }, # s 2 : [] int { 3 , 2 , 1 }, # expected : true , # }, # { # s 1 : [] int { 1 , 2 , 3 }, # s 2 : [] int { 1 , 2 , 1 }, # expected : false , # }, # } # for _ , tc := range tests { # output := IsEqualSliceInt ( tc . s 1 , tc . s 2 ) # if output != tc . expected { # t . Fatalf (" STR ", tc . s 1 , tc . s 2 , output , tc . expected ) # } # }
for i := 3 ; ; i += 2 { # if ! isPrime ( i ) { # if ! passTest ( i ) { # fmt . Println ( i , " STR ") # return # } # } else { # primes = append ( primes , i ) # } # }
if divisor == 0 { # return math . MaxInt 3 2 # } # flag := 1 # if dividend < 0 { # flag *= - 1 # dividend *= - 1 # } # if divisor < 0 { # flag *= - 1 # divisor *= - 1 # } # var multiple int # for divisor <= dividend { # t := divisor # count := 1 # for t << 1 <= dividend { # t <<= 1 # count <<= 1 # } # multiple += count # dividend -= t # } # if multiple >= math . MaxInt 3 2 { # if flag == 1 { # return math . MaxInt 3 2 # } # return math . MinInt 3 2 # } # return multiple * flag
var perimeter int # for i , r := range grid { # for j , c := range r { # if c == 0 { # continue # } # # perimeter += 4 # # if i > 0 && grid [ i - 1 ][ j ] == 1 { # perimeter -= 2 # } # if j > 0 && r [ j - 1 ] == 1 { # perimeter -= 2 # } # } # } # return perimeter
if seed <= 0 { # return nil # } # # var results = [] uint { seed } # # for seed != 1 { # seed = nextNum ( seed ) # results = append ( results , seed ) # } # # return results
starttime := time . Now () # # fmt . Println (" STR ", time . Since ( starttime )) # # max := 1 # # for i := 0 ; i < grid ; i ++ { # for j := 0 ; j < grid - word + 1 ; j ++ { # total := 1 # totel := 1 # diag := 1 # diag 2 := 1 # # for k := 0 ; k < word ; k ++ { # # totel *= data [ j + k ][ i ] # total *= data [ i ][ j + k ] # # if i < grid - word + 1 { # diag *= data [ i + k ][ j + k ] # diag 2 *= data [ i + k ][ j - k + word - 1 ] # # } # # } # # if total > max { # max = total # } # if totel > max { # max = totel # } # if diag > max { # max = diag # } # if diag 2 > max { # max = diag 2 # } # } # } # fmt . Println ( max ) #
closest := Pos {} # closestDistance := len ( coins ) * 2 # # for _ , coin := range coins { # if dist := abs ( me . Row - coin . Row ) + abs ( me . Col - coin . Col ); dist < closestDistance { # closestDistance = dist # closest = coin # } # } # # return closest
var node 1 , node 2 , prev * TreeNode # cur := root # stack := make ([]* TreeNode , 0 ) # for cur != nil || len ( stack ) != 0 { # for cur != nil { # stack = append ( stack , cur ) # cur = cur . Left # } # # cur = stack [ len ( stack )- 1 ] # stack = stack [: len ( stack )- 1 ] # if prev != nil && prev . Val > cur . Val { # node 2 = cur # if node 1 == nil { # node 1 = prev # } else { # break # } # } # # prev = cur # cur = cur . Right # } # # if node 1 != nil && node 2 != nil { # node 1 . Val , node 2 . Val = node 2 . Val , node 1 . Val # }
n := len ( list ) # if n == 1 { # return true # } # t := 0 # for i := 1 ; i < n ; i ++ { # t = int ( math . Max ( float 6 4 ( t ), float 6 4 ( list [ i - 1 ]))) - 1 # if t < 0 { # return false # } # } # return true
strArr := ReadFileIntoArray ( fileName , " STR ") # # sort . Strings ( strArr ) # # sum := 0 # for i , str := range strArr { # sum += calculateValue ( str , i + 1 ) # } # # return sum
if root == nil { # return # } # sum -= root . Val # path = append ( path , root . Val ) # if root . Left == nil && root . Right == nil { # if sum == 0 { # tmp := make ([] int , 0 ) # tmp = append ( tmp , path ...) # ret = append ( ret , tmp ) # } # path = path [: len ( path )- 1 ] # return # } # help ( root . Left , sum ) # help ( root . Right , sum ) # path = path [: len ( path )- 1 ]
ret := 0 # if len ( nums ) == 0 { # return ret # } # m := make ( map [ int ] int ) # for _ , v := range nums { # if _ , ok := m [ v ]; ok { # m [ v ]++ # } else { # m [ v ] = 1 # } # } # for k , v := range m { # if val , ok := m [ k + 1 ]; ok { # if v + val > ret { # ret = v + val # } # } # } # return ret
count := 0 # for i := 2 ; i < 1 0 0 0 0 0 0 ; i ++ { # if isCircular ( i ) { # fmt . Println (" STR ", i ) # count ++ # } # } # fmt . Println (" STR ", count )
dp := make ([] int , 3 ) # for _ , v := range nums { # tmp := make ([] int , 3 ) # copy ( tmp , dp ) # for i := 0 ; i < 3 ; i ++ { # dp [( v + tmp [ i ])% 3 ] = max ( dp [( v + tmp [ i ])% 3 ], v + tmp [ i ]) # } # } # return dp [ 0 ]
if ! strings . ContainsRune (" STR ", b . op ) { # return fmt . Errorf (" STR ", b . op ) # } # if err := b . x . Check ( vars ); err != nil { # return err # } # return b . y . Check ( vars )
primes := GetPrimeNumbersBelowN ( 1 ) # if len ( primes ) != 0 { # t . Error (" STR ") # }
cases := [] struct { # name string # input 1 [] byte # input 2 int # expect int # }{ # {" STR ", [] byte {" STR ", " STR ", " STR ", " STR ", " STR ", " STR "}, 2 , 8 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := leastInterval ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 , c . input 2 ) # } # }) # }
raw := strings . Split ( path , " STR ") # segs := make ([] string , 0 ) # for _ , r := range raw { # if r == " STR " && len ( segs ) > 0 { # segs = segs [: len ( segs )- 1 ] # } else if r != " STR " && r != " STR " && r != " STR " { # segs = append ( segs , r ) # } # } # # var result string # for _ , seg := range segs { # result = result + " STR " + seg # } # # if result == " STR " { # result = " STR " # } # # return result
if index == 1 { # return [ 3 ] int { 1 , 1 , 1 } # } # # if answer , ok := memo [[ 2 ] int { index , modulus }]; ok { # return answer # } # # answer := trib ( index - 1 , modulus ) # # answer [ 0 ], answer [ 1 ], answer [ 2 ] = answer [ 1 ], answer [ 2 ], ( answer [ 0 ]+ answer [ 1 ]+ answer [ 2 ])% modulus # # memo [[ 2 ] int { index , modulus }] = answer # # return answer
if a > b { # return a # } # return b
var m = map [ int ] int {} # for k , v := range B { # m [ v ] = k # } # # var res [] int # for _ , v := range A { # res = append ( res , m [ v ]) # } # return res
arr := randomSlice ( 0 , 2 0 , 1 0 ) # nodeCnt := 0 # gbt := newGBT () # for _ , v := range arr { # gbt . Insert ( uint 3 2 ( v )) # } # rightRotateNodes := make ([]* gbtElement , 0 , 0 ) # gbt . InOrderWalk ( gbt . Root (), func ( GBT binaryTreeIf , node interface {}) bool { # rotate := getRand (). Intn ( 2 ) # if rotate == 1 { # rightRotateNodes = append ( rightRotateNodes , node .(* gbtElement )) # } # return false # }) # for _ , v := range rightRotateNodes { # gbt . RightRotate ( v ) # } # gbt . InOrderWalk ( gbt . Root (), checkGBT ( t , & nodeCnt , * debug )) # if nodeCnt != len ( arr ) { # t . Log (" STR ", len ( arr ), " STR ", nodeCnt ) # t . Fail () # }
var rst [] int # for _ , num := range nums { # val := num # if num < 0 { # val = - num # } # if val --; nums [ val ] > 0 { # nums [ val ] = - nums [ val ] # } # } # for i , num := range nums { # if num > 0 { # rst = append ( rst , i + 1 ) # } # } # return rst
max 1 , max 2 , max 3 := math . MinInt 3 2 , math . MinInt 3 2 , math . MinInt 3 2 # min 1 , min 2 := math . MaxInt 3 2 , math . MaxInt 3 2 # # for _ , n := range nums { # if n > max 1 { # max 3 , max 2 , max 1 = max 2 , max 1 , n # } else if n > max 2 { # max 3 , max 2 = max 2 , n # } else if n > max 3 { # max 3 = n # } # # if n < min 1 { # min 2 , min 1 = min 1 , n # } else if n < min 2 { # min 2 = n # } # } # return max ( max 2 * max 3 , min 1 * min 2 ) * max 1
tmp := 0 # # for i := 0 ; i < len ( arr )/ 2 ; i ++ { # left := 0 # right := len ( arr ) - 1 # # for left <= right { # # if arr [ left ] > arr [ left + 1 ] { # tmp = arr [ left ] # arr [ left ] = arr [ left + 1 ] # arr [ left + 1 ] = tmp # } # # left ++ # # if arr [ right - 1 ] > arr [ right ] { # tmp = arr [ right - 1 ] # arr [ right - 1 ] = arr [ right ] # arr [ right ] = tmp # } # # right -- # } # }
for cur := ll . Head ; cur != nil ; cur = cur . Next { # fmt . Print ( cur . Val , " STR ") # } # # fmt . Print (" STR ")
if cap ( el ) < 1 || cap ( el ) > tp . maxSize { # return # } # el = el [: cap ( el )] # o := log 2 Floor ( uint 3 2 ( cap ( el ))) # p := & tp . list_of_pools [ o ] # p . mu . Lock () # p . list = append ( p . list , el ) # p . mu . Unlock ()
isExactlyMatch := make ( map [ string ] bool , len ( wordlist )) # cap := make ( map [ string ] int , len ( wordlist )) # vow := make ( map [ string ] int , len ( wordlist )) # for i := len ( wordlist ) - 1 ; i >= 0 ; i -- { # w := wordlist [ i ] # isExactlyMatch [ w ] = true # w = strings . ToLower ( w ) # cap [ w ] = i # vow [ replacingVowel ( w )] = i # } # # corrects := make ([] string , len ( queries )) # for i , q := range queries { # if isExactlyMatch [ q ] { # corrects [ i ] = q # } else if j , ok := cap [ strings . ToLower ( q )]; ok { # corrects [ i ] = wordlist [ j ] # } else if k , ok := vow [ replacingVowel ( q )]; ok { # corrects [ i ] = wordlist [ k ] # } # } # # return corrects
n := rand . Intn ( 1 0 0 ) # println (" STR ", n , " STR ") # for i := 0 ; i < n ; i ++ { # s := make ([] byte , i ) # _ = append ( s , 4 2 ) # }
mu . Lock () # b := balance # mu . Unlock () # return b
starttime := time . Now () # # square := int 6 4 ( 1 ) # i := int 6 4 ( 1 ) # count := 0 # total := int 6 4 ( 0 ) # # for x := int 6 4 ( 1 ); count < height ; x ++ { # test := 1 + 1 4 * x + 5 * x * x # # for square < test { # square += ( 2 * i ) + 1 # i ++ # } # # if test == square { # fmt . Println ( count + 1 , " STR ", x ) # count ++ # total += x # } # # } # # fmt . Println (" STR ") # fmt . Println ( total ) # # fmt . Println (" STR ", time . Since ( starttime ))
dp := make ([][] int , m ) # for i := 0 ; i < m ; i ++ { # dp [ i ] = make ([] int , n ) # } # # for i := 0 ; i < n ; i ++ { # dp [ 0 ][ i ] = 1 # } # # for i := 0 ; i < m ; i ++ { # dp [ i ][ 0 ] = 1 # } # # for i := 1 ; i < m ; i ++ { # for j := 1 ; j < n ; j ++ { # dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ] # } # } # # return dp [ m - 1 ][ n - 1 ]
t . Parallel () # # for _ , tc := range testcases { # if result := SmallestStepsToOne ( tc . n ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
l := len ( digits ) # pos := l - 1 # for pos >= 0 { # digits [ pos ]++ # if digits [ pos ] <= 9 { # return digits # } # # digits [ pos ] = 0 # pos -- # } # # return append ([] int { 1 }, digits ...)
cases := [] struct { # name string # input int # expected bool # }{ # {" STR ", 2 8 , true }, # } # # for _ , testcase := range cases { # t . Run ( testcase . name , func ( t * testing . T ) { # got := checkPerfectNumber ( testcase . input ) # if ! reflect . DeepEqual ( got , testcase . expected ) { # t . Fatalf (" STR ", # testcase . expected , got , testcase . input ) # } # }) # }
res , mask := 0 , 0 # # for i := 3 1 ; i >= 0 ; i -- { # mask |= 1 << uint ( i ) # m := make ( map [ int ] struct {}) # for _ , num := range nums { # m [ num & mask ] = struct {}{} # } # tmp := res | 1 << uint ( i ) # for k := range m { # if _ , ok := m [ tmp ^ k ]; ok { # res = tmp # break # } # } # } # return res
if ll . Head == nil { # return - 1 # } # # if ll . Head . Next == nil { # return ll . DelAtBeg () # } # # cur := ll . Head # for ; cur . Next . Next != nil ; cur = cur . Next { # } # # retval := cur . Next . Val # cur . Next = nil # return retval
ans := [] int {} # # if len ( matrix ) == 0 { # return ans # } # top , bottom , left , right := 0 , len ( matrix )- 1 , 0 , len ( matrix [ 0 ])- 1 # # for top <= bottom && left <= right { # for i := left ; i <= right ; i ++ { # ans = append ( ans , matrix [ top ][ i ]) # } # top ++ # for i := top ; i <= bottom ; i ++ { # ans = append ( ans , matrix [ i ][ right ]) # } # right -- # if top <= bottom { # for i := right ; i >= left ; i -- { # ans = append ( ans , matrix [ bottom ][ i ]) # } # } # bottom -- # if left <= right { # for i := bottom ; i >= top ; i -- { # ans = append ( ans , matrix [ i ][ left ]) # } # } # left ++ # } # return ans
starttime := time . Now () # # frac := big . NewRat ( 2 , 1 ) # n , d := frac . Num (), frac . Denom () # table := big . NewInt ( 0 ) # # two := big . NewRat ( 2 , 1 ) # # var total int # # for i := 0 ; i < top ; i ++ { # frac . Add ( two , frac . Inv ( frac )) # # if len ( table . Add ( n , d ). String ()) > len ( n . String ()) { # total ++ # } # # } # # fmt . Printf (" STR ", total ) # # fmt . Println (" STR ", time . Since ( starttime ))
m := len ( board ) # if m == 0 { # return 0 # } # n := len ( board [ 0 ]) # count := 0 # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # if board [ i ][ j ] == ' X ' && # ( i == 0 || board [ i - 1 ][ j ] == '.') && # ( j == 0 || board [ i ][ j - 1 ] == '.') { # count ++ # } # } # } # return count
a := " STR " # b := " STR " # fmt . Println ( addBinary ( a , b )) # fmt . Println ( addBinary 2 ( a , b ))
for i := 0 ; i < len ( matrix )- 1 ; i ++ { # for j := 0 ; j < len ( matrix [ i ])- 1 ; j ++ { # if matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ] { # return false # } # } # } # return true
m , n := len ( matrix ), 0 # if m != 0 { # n = len ( matrix [ 0 ]) # } # # dp := make ([][] int , m + 1 ) # for i := 0 ; i < m + 1 ; i ++ { # dp [ i ] = make ([] int , n + 1 ) # } # for i := 1 ; i < m + 1 ; i ++ { # for j := 1 ; j < n + 1 ; j ++ { # dp [ i ][ j ] = matrix [ i - 1 ][ j - 1 ] + dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ] - dp [ i - 1 ][ j - 1 ] # } # } # return NumMatrix { dp }
if s . size > 0 { # value := s . top . value # s . top = s . top . next # s . size -- # return value # } # return nil
fmt . Println (" STR ") # fmt . Println (" STR ") # fmt . Println (" STR ") # fmt . Println (" STR ") # var ( # option int # number float 6 4 # ) # fmt . Scanln (& option ) # # fmt . Println ( divider ) # switch option { # case 1 : # fmt . Printf (" STR ") # fmt . Scanln (& number ) # fmt . Println ( divider ) # fmt . Printf (" STR ", number * miTokm ) # case 2 : # fmt . Printf (" STR ", number ) # fmt . Println ( divider ) # fmt . Printf (" STR ", ( number - 3 2 )* 5 / 9 ) # case 3 : # fmt . Printf (" STR ", number ) # fmt . Println ( divider ) # fmt . Printf (" STR ", number * pToKg ) # } # fmt . Println ( divider )
g , f := make ([] int , len ( prices )), make ([] int , len ( prices )) # ans , n , low := 0 , len ( prices ), prices [ 0 ] # # for i := 1 ; i < n ; i ++ { # low = min ( low , prices [ i ]) # f [ i ] = max ( f [ i - 1 ], prices [ i ]- low ) # } # high := prices [ n - 1 ] # for i := n - 2 ; i >= 0 ; i -- { # high = max ( high , prices [ i ]) # g [ i ] = max ( g [ i + 1 ], high - prices [ i ]) # } # # for i := 0 ; i < n ; i ++ { # ans = max ( ans , f [ i ]+ g [ i ]) # } # return ans
n := big . NewInt ( 1 ) # # for i := 2 ; i <= 1 0 0 ; i ++ { # n . Mul ( n , big . NewInt ( int 6 4 ( i ))) # } # # chrToInt := func ( chr rune ) int { # return int ( uint 8 ( chr ) - ' 0 ') # } # # sum := 0 # # for _ , chr := range n . String () { # sum += chrToInt ( chr ) # } # # fmt . Println ( sum )
qs := [] question 2 2 0 { # # { # para 2 2 0 {[] int { 7 , 1 , 3 }, 2 , 3 }, # ans 2 2 0 { true }, # }, # # { # para 2 2 0 {[] int {- 1 , - 1 }, 1 , - 1 }, # ans 2 2 0 { false }, # }, # # { # para 2 2 0 {[] int { 1 , 2 , 3 , 1 }, 3 , 0 }, # ans 2 2 0 { true }, # }, # # { # para 2 2 0 {[] int { 1 , 0 , 1 , 1 }, 1 , 2 }, # ans 2 2 0 { true }, # }, # # { # para 2 2 0 {[] int { 1 , 5 , 9 , 1 , 5 , 9 }, 2 , 3 }, # ans 2 2 0 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 2 0 , q . para 2 2 0 # fmt . Printf (" STR ", p , containsNearbyAlmostDuplicate ( p . one , p . k , p . t )) # } # fmt . Printf (" STR ")
const ( # longNamespace = " STR " # longPackageName = " STR " # ) # type Newtype struct {} # var newtype Newtype # thisPkg := reflect . TypeOf ( newtype ). PkgPath () # var ( # mainPath = " STR " # mainVersion = " STR " # torrentVersion = " STR " # ) # if buildInfo , ok := debug . ReadBuildInfo (); ok { # mainPath = buildInfo . Main . Path # mainVersion = buildInfo . Main . Version # for _ , dep := range append ( buildInfo . Deps , & buildInfo . Main ) { # if dep . Path == thisPkg { # torrentVersion = dep . Version # } # } # } # DefaultExtendedHandshakeClientVersion = fmt . Sprintf ( # " STR ", # mainPath , # mainVersion , # longNamespace , # longPackageName , # torrentVersion , # ) # DefaultUpnpId = fmt . Sprintf (" STR ", mainPath , mainVersion ) # DefaultHttpUserAgent = fmt . Sprintf ( # " STR ", # longNamespace , # longPackageName , # torrentVersion , # )
if len ( nums ) == 0 { # return [][] int {} # } # max := 1 << uint 1 6 ( len ( nums )) # ret := [][] int {} # for i := 0 ; i < max ; i ++ { # bit := i # tmp := [] int {} # for j := 0 ; j < len ( nums ); j ++ { # if bit & 1 == 1 { # tmp = append ( tmp , nums [ j ]) # } # bit >>= 1 # } # ret = append ( ret , tmp ) # } # return ret
ans := make ([] int , 0 ) # # num := int ( math . Sqrt ( float 6 4 ( area ))) # for num > 0 { # if area % num == 0 { # if num >= area / num { # ans = append ( ans , num , area / num ) # } else { # ans = append ( ans , area / num , num ) # } # break # } else { # num -- # } # } # # return ans
type A struct { # Name string # Value int # } # # a := A { # Name : " STR ", # Value : 1 2 3 , # } # # type B struct { # A A ` structs :" STR "` # C int # } # b := & B { A : a , C : 1 2 3 } # # s := Values ( b ) # # if len ( s ) != 2 { # t . Errorf (" STR ") # } # # inSlice := func ( val interface {}) bool { # for _ , v := range s { # if reflect . DeepEqual ( v , val ) { # return true # } # } # return false # } # # for _ , val := range [] interface {}{ 1 2 3 , a } { # if ! inSlice ( val ) { # t . Errorf (" STR ", val ) # } # }
t . Parallel () # # for _ , tc := range testcases { # if flips := FlipsXsBeforeYs ( tc . input ); flips != tc . flips { # t . Errorf (" STR ", tc . flips , flips ) # } # }
for t := m + n - 1 ; t >= 0 ; t --{ # if m == 0 || n == 0 { # if m == 0 { # nums 1 [ t ] = nums 2 [ n - 1 ] # n -- # } else { # nums 1 [ t ] = nums 1 [ m - 1 ] # m -- # } # continue # } # if nums 1 [ m - 1 ]> nums 2 [ n - 1 ]{ # nums 1 [ t ] = nums 1 [ m - 1 ] # m -- # } else { # nums 1 [ t ] = nums 2 [ n - 1 ] # n -- # } # # }
if start == target { # return 0 # } # # for _ , v := range start { # if v < 0 || v > 9 { # panic (" STR ") # } # } # # for _ , v := range target { # if v < 0 || v > 9 { # panic (" STR ") # } # } # # graph := make ([][][] int , 1 0 ) # for i := range graph { # graph [ i ] = make ([][] int , 1 0 ) # for j := range graph [ i ] { # graph [ i ][ j ] = make ([] int , 1 0 ) # } # } # # for _ , de := range deadEnds { # for _ , v := range de { # if v < 0 || v > 9 { # panic (" STR ") # } # } # # x , y , z := de [ 0 ], de [ 1 ], de [ 2 ] # graph [ x ][ y ][ z ] = - 1 # } # # bfs ( graph , start ) # # return graph [ target [ 0 ]][ target [ 1 ]][ target [ 2 ]] - 1
nt := make ( Tree ) # # var firstStart int # for start , toMap := range t { # firstStart = start # # if _ , exists := nt [ start ]; ! exists { # nt [ start ] = make ( map [ int ] struct {}) # } # # for to := range toMap { # if _ , exists := nt [ to ]; ! exists { # nt [ to ] = make ( map [ int ] struct {}) # } # # nt [ start ][ to ] = struct {}{} # nt [ to ][ start ] = struct {}{} # } # } # # visited := make ( map [ int ] struct {}, len ( nt )+ 1 ) # _ , result := dfs ( nt , firstStart , visited , 0 ) # # return result
count := [ 1 0 0 1 ] int {} # for _ , a := range A { # count [ a ]++ # } # # res := make ([] int , 0 , len ( A )) # for _ , b := range B { # for count [ b ] > 0 { # res = append ( res , b ) # count [ b ]-- # } # } # for i := 0 ; i < 1 0 0 1 ; i ++ { # for count [ i ] > 0 { # res = append ( res , i ) # count [ i ]-- # } # } # # return res
wordSet := make ( map [ string ] struct {}, len ( wordDict )) # for _ , w := range wordDict { # wordSet [ w ] = struct {}{} # } # n := len ( s ) # dp := make ([] bool , n + 1 ) # dp [ 0 ] = true # # for i := 1 ; i < n + 1 ; i ++ { # for j := 0 ; j < i ; j ++ { # if dp [ j ] { # if _ , ok := wordSet [ s [ j : i ]]; ok { # dp [ i ] = true # break # } # } # } # } # return dp [ n ]
lenStrs := len ( strs ) # if lenStrs < 1 { # return " STR " # } # d := strs [ 0 ] # lenMin := len ( d ) # for i := 1 ; i < lenStrs ; i ++ { # if lenMin > len ( strs [ i ]) { # lenMin = len ( strs [ i ]) # } # } # var l int # LOOP : # for i := 0 ; i < lenMin ; i ++ { # b := d [ i ] # for ii := 1 ; ii < lenStrs ; ii ++ { # if strs [ ii ][ i ] != b { # break LOOP # } # } # l ++ # } # return string ( d [: l ])
tests := [...] testType { # { # num 1 : " STR ", # num 2 : " STR ", # want : " STR ", # }, # { # num 1 : " STR ", # num 2 : " STR ", # want : " STR ", # }, # { # num 1 : " STR ", # num 2 : " STR ", # want : " STR ", # }, # { # num 1 : " STR ", # num 2 : " STR ", # want : " STR ", # }, # } # for _ , tt := range tests { # got := addStrings ( tt . num 1 , tt . num 2 ) # if got != tt . want { # t . Fatalf (" STR ", tt , got , tt . want ) # } # }
if x == nil || y == nil { # return x == y # } # # panic (" STR ")
m := make ([] int , 2 6 ) # for _ , v := range s { # m [ v -' a ']++ # } # # for _ , v := range s { # if m [ v -' a '] == 1 { # return byte ( v ) # } # } # return ' '
for i := 0 ; i <= len ( str )- len ( sub ); i ++ { # if str [ i : i + len ( sub )] == sub { # return i # } # } # return - 1
sum := make ([] int , len ( nums )) # sum [ 0 ] = nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # sum [ i ] = sum [ i - 1 ] + nums [ i ] # } # ans := float 6 4 ( sum [ k - 1 ]) / float 6 4 ( k ) # for i := k ; i < len ( nums ); i ++ { # ans = max ( ans , float 6 4 ( sum [ i ]- sum [ i - k ])/ float 6 4 ( k )) # } # return ans
res := make ([] int , 0 , n ) # i , j := 1 , n # for i <= j { # if k % 2 == 1 { # res = append ( res , i ) # i ++ # } else { # res = append ( res , j ) # j -- # } # if k > 1 { # k -- # } # } # return res
var items [] int # current := list . tail # for current != nil { # items = append ( items , current . data ) # current = current . prev # } # return items
var q []* Node # var n * Node # # q = append ( q , root ) # # for len ( q ) != 0 { # n , q = q [ 0 ], q [ 1 :] # fmt . Print ( n . val , " STR ") # if n . left != nil { # q = append ( q , n . left ) # } # if n . right != nil { # q = append ( q , n . right ) # } # }
if len ( track ) == k { # copyTrack := make ([] int , len ( track )) # copy ( copyTrack , track ) # combineRes = append ( combineRes , copyTrack ) # return # } # for i := start ; i <= stop ; i ++ { # track = append ( track , arr [ i ]) # traceBackCombine ( arr , i + 1 , stop , k , track ) # track = track [: len ( track )- 1 ] # }
if nil == headA || nil == headB { # return nil # } # # ptrA , ptrB := headA , headB ; # for ptrA != ptrB { # if nil == ptrA { # ptrA = headB # } else { # ptrA = ptrA . Next # } # # if nil == ptrB { # ptrB = headA # } else { # ptrB = ptrB . Next # } # } # # return ptrA
for level := 0 ; level < len ( matrix )/ 2 ; level ++ { # topBoundary := level # leftBoundary := level # bottomBoundary := len ( matrix ) - 1 - level # rightBoundary := len ( matrix ) - 1 - level # for times := 0 ; times < bottomBoundary - topBoundary ; times ++ { # mostLeftTop := matrix [ topBoundary ][ leftBoundary ] # for row := topBoundary ; row < bottomBoundary ; row ++ { # matrix [ row ][ leftBoundary ] = matrix [ row + 1 ][ leftBoundary ] # } # # for col := leftBoundary ; col < rightBoundary ; col ++ { # matrix [ bottomBoundary ][ col ] = matrix [ bottomBoundary ][ col + 1 ] # } # # for row := bottomBoundary ; row > topBoundary ; row -- { # matrix [ row ][ rightBoundary ] = matrix [ row - 1 ][ rightBoundary ] # } # # for col := rightBoundary ; col > leftBoundary + 1 ; col -- { # matrix [ topBoundary ][ col ] = matrix [ topBoundary ][ col - 1 ] # } # matrix [ topBoundary ][ leftBoundary + 1 ] = mostLeftTop # } # }
dictAnagramData := make ([] map [ rune ] int , len ( dict )) # for i , word := range dict { # dictAnagramData [ i ] = make ( map [ rune ] int ) # for _ , r := range word { # dictAnagramData [ i ][ r ]++ # } # } # inputAnagramData := make ( map [ rune ] int ) # for _ , r := range input { # inputAnagramData [ r ]++ # } # var result [] string # for r := ' a '; r <= ' z '; r ++ { # inputAnagramData [ r ]++ # for i , data := range dictAnagramData { # if reflect . DeepEqual ( data , inputAnagramData ) { # result = append ( result , dict [ i ]) # } # } # inputAnagramData [ r ]-- # if inputAnagramData [ r ] == 0 { # delete ( inputAnagramData , r ) # } # } # return result
n := len ( bits ) # if n == 1 { # return true # } # for i := 0 ; i < n ; { # if i == n - 1 { # return true # } # if bits [ i ] == 0 { # i ++ # } else { # i += 2 # } # } # return false
tests := [...] testType { # { # x : 2 . 0 0 0 0 0 , # n : 1 0 , # want : 1 0 2 4 . 0 0 0 0 0 , # }, # { # x : 2 . 1 0 0 0 0 , # n : 3 , # want : 9 . 2 6 1 0 0 , # }, # { # x : 2 . 0 0 0 0 0 , # n : - 2 , # want : 0 . 2 5 0 0 0 , # }, # } # # for _ , tt := range tests { # got := myPow ( tt . x , tt . n ) # got = math . Trunc ( got * 1 e 5 ) / 1 e 5 # if got != tt . want { # t . Fatalf (" STR ", tt . x , tt . n , got , tt . want ) # } # }
m , n := len ( forest ), len ( forest [ 0 ]) # # pq := make ( PQ , 0 , m * n ) # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # if forest [ i ][ j ] > 1 { # pq = append ( pq , & tree { # height : forest [ i ][ j ], # point : point { x : i , y : j }, # }, # ) # } # } # } # heap . Init (& pq ) # # res := 0 # beg := point { x : 0 , y : 0 } # for len ( pq ) > 0 { # next := heap . Pop (& pq ).(* tree ) # end := next . point # steps , isAccessible := bfs ( forest , beg , end ) # if ! isAccessible { # return - 1 # } # res += steps # beg = end # } # # return res
size := len ( points ) # # isExisting := make ( map [[ 2 ] int ] bool , size ) # for _ , p := range points { # x , y := p [ 0 ], p [ 1 ] # isExisting [[ 2 ] int { x , y }] = true # } # # minArea := initialArea # # for i := 0 ; i < size ; i ++ { # xi , yi := points [ i ][ 0 ], points [ i ][ 1 ] # for j := i + 1 ; j < size ; j ++ { # xj , yj := points [ j ][ 0 ], points [ j ][ 1 ] # if xi == xj || yi == yj { # continue # } # area := abs (( xi - xj ) * ( yi - yj )) # if area >= minArea || # ! isExisting [[ 2 ] int { xi , yj }] || # ! isExisting [[ 2 ] int { xj , yi }] { # continue # } # minArea = area # } # } # # if minArea == initialArea { # return 0 # } # return minArea
if head == nil { # return # } # # if depth >= len (* llp ) { # * llp = append (* llp , [] int {}) # } # # (* llp )[ depth ] = append ((* llp )[ depth ], head . Val ) # # recLevelOrder ( head . Left , depth + 1 , llp ) # recLevelOrder ( head . Right , depth + 1 , llp )
res := make ([] int , len ( temperatures )) # stack := make ([] int , len ( temperatures )) # top := - 1 # for i := range temperatures { # for top != - 1 && temperatures [ i ] > temperatures [ stack [ top ]] { # idx := stack [ top ] # top -- # res [ idx ] = i - idx # } # # top ++ # stack [ top ] = i # } # return res
return LoadUint 3 2 (& r . Reg ) != 0
if nil == nums || len ( nums ) == 0 { # return - 1 # } # # preSum := make ([] int , len ( nums )) # preSum [ 0 ] = nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # preSum [ i ] = preSum [ i - 1 ] + nums [ i ] # } # # for i := 0 ; i < len ( nums ); i ++ { # if preSum [ i ]- nums [ i ] == preSum [ len ( nums )- 1 ]- preSum [ i ] { # return i # } # } # return - 1
root := os . Getenv (" STR ") # if root != "" { # if ! isSourceDir ( root ) { # fmt . Fprintln ( os . Stderr , " STR ") # os . Exit ( 1 ) # } # return root # } # # if TINYGOROOT != "" { # if ! isSourceDir ( TINYGOROOT ) { # fmt . Fprintln ( os . Stderr , " STR ") # os . Exit ( 1 ) # } # return TINYGOROOT # } # # path , err := os . Executable () # if err != nil { # panic (" STR " + err . Error ()) # } # root = filepath . Dir ( filepath . Dir ( path )) # if isSourceDir ( root ) { # return root # } # # _ , path , _ , _ = runtime . Caller ( 0 ) # root = filepath . Dir ( filepath . Dir ( path )) # if isSourceDir ( root ) { # return root # } # # fmt . Fprintln ( os . Stderr , " STR ") # os . Exit ( 1 ) # panic (" STR ")
cases := [] struct { # name string # inputs int # expect int # }{ # {" STR ", 2 , 2 }, # {" STR ", 3 , 3 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := climbStairs 2 ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
g := & graph { # linkedList : make ([]* list . List , v ), # v : v , # } # for i , _ := range g . linkedList { # g . linkedList [ i ] = list . New () # } # return g
ans := 0 # la , lb := len ( A ), len ( B ) # dp := make ([][] int , la + 1 ) # for k := range dp { # dp [ k ] = make ([] int , lb + 1 ) # } # for i := la - 1 ; i >= 0 ; i -- { # for j := lb - 1 ; j >= 0 ; j -- { # if A [ i ] == B [ j ] { # dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 # if ans < dp [ i ][ j ] { # ans = dp [ i ][ j ] # } # } # } # } # return ans
months = make ([] int , 1 2 ) # # daysInMonths := [] int { 3 1 , 2 9 , 3 1 , 3 0 , 3 1 , 3 0 , 3 1 , 3 1 , 3 0 , 3 1 , 3 0 } # months [ 0 ] = 0 # for i := range daysInMonths { # months [ i + 1 ] = ( months [ i ] + daysInMonths [ i ]) % 7 # } # # count = 0 # for year := 1 9 0 0 ; year < 2 0 0 0 ; year ++ { # for i := range months { # if ( year % 4 == 0 && i <= 1 ) || (( year + 1 )% 4 == 0 && i > 1 ) { # months [ i ] = ( months [ i ] + 3 6 6 ) % 7 # } else { # months [ i ] = ( months [ i ] + 3 6 5 ) % 7 # } # if months [ i ] == 6 { # count ++ # } # } # } # println ( count )
r := make ([] int , length + 1 ) # r [ 0 ] = 0 # # for j := 1 ; j <= length ; j ++ { # q := - 1 # for i := 1 ; i <= j ; i ++ { # q = Max ( q , price [ i ]+ r [ j - i ]) # } # r [ j ] = q # } # # return r [ length ]
for k := 0 ; k < n - 1 ; k ++ { # rand . Seed ( time . Now (). UnixNano () + int 6 4 ( k )) # num := rand . Intn ( 1 << 1 6 ) + 1 # res = append ( res , num ) # } # s := 0 # for _ , v := range res { # s = s + v # } # res = append ( res , sum - s ) # return
if side == left { # return node . Left # } # return node . Right
sentences := make ([] string , 0 ) # start := 0 # # spaceDelimited := strings . Split ( text , " STR ") # possibleSentence := false # # for i , part := range spaceDelimited { # runes := [] rune ( part ) # if part == " STR " || ! isValid ( runes ) { # possibleSentence = false # continue # } # # if runes [ 0 ] >= ' A ' && runes [ 0 ] <= ' Z ' { # possibleSentence = true # start = i # # continue # } # # if last := runes [ len ( runes )- 1 ]; last == '.' || last == '!' || last == '?' { # if possibleSentence { # sentences = append ( sentences , strings . Join ( spaceDelimited [ start : i + 1 ], " STR ")) # } # } # } # # return sentences
if len ( nums ) <= 1 { # return len ( nums ) # } # /** # retä¿å­æç»ç»æ ï¼ lä¿å­ä¸´æ¶ç»æ # */ # ret , l := 1 , 1 # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] <= nums [ i - 1 ] { # if l > ret { # ret = l # } # l = 1 # } else { # l ++ # } # if ret < l { # ret = l # } # } # return ret
sort . Slice ( costs , func ( i , j int ) bool { # return costs [ i ][ 0 ]- costs [ i ][ 1 ] < costs [ j ][ 0 ]- costs [ j ][ 1 ] # }) # sum := 0 # for i := 0 ; i < len ( costs ); i ++ { # if i < len ( costs )/ 2 { # sum += costs [ i ][ 0 ] # } else { # sum += costs [ i ][ 1 ] # } # } # return sum
nums := [] int {- 2 , 0 , 3 , - 5 , 2 , - 1 } # obj := Constructor ( nums ) # tests := [...] testType { # { # i : 0 , # j : 2 , # want : 1 , # }, # { # i : 2 , # j : 5 , # want : - 1 , # }, # { # i : 0 , # j : 5 , # want : - 3 , # }, # } # for _ , tt := range tests { # got := obj . SumRange ( tt . i , tt . j ) # if got != tt . want { # t . Fatalf (" STR ", tt . i , tt . j , got , tt . want ) # } # }
var h ListNode # h . Next = head # for head != nil && head . Next != nil { # if head . Val == head . Next . Val { # head . Next = head . Next . Next # } else { # head = head . Next # } # } # return h . Next
if len ( nums ) == 0 { # return nil # } # root := new ( TreeNode ) # root . Val = nums [ 0 ] # ch := make ( chan * TreeNode , len ( nums )) # ch <- root # nums = nums [ 1 :] # for i := 0 ; i < len ( nums ); i ++{ # tree := <- ch # if nums [ i ] == - 1 { # tree . Left = nil # } else { # tree . Left = & TreeNode { # Val : nums [ i ], # } # ch <- tree . Left # } # i ++ # if nums [ i ] == - 1 { # tree . Right = nil # } else { # tree . Right = & TreeNode { # Val : nums [ i ], # } # ch <- tree . Right # } # } # return root
heads , tails := 0 , 0 # res := 0 # for _ , a := range A { # if a < L { # tails ++ # res += heads # } else if a <= R { # heads += tails + 1 # tails = 0 # res += heads # } else { # heads , tails = 0 , 0 # } # } # return res
visited := make ( map [ int ] bool ) # _ , ok := visited [ n ] # for n != 1 && ! ok { # visited [ n ] = true # # str := strconv . Itoa ( n ) # n = 0 # for _ , ch := range str { # n += int (( ch - ' 0 ') * ( ch - ' 0 ')) # } # # _ , ok = visited [ n ] # } # # return n == 1
var d int # switch ( str ){ # # case " STR " : # d = 1 # break # case " STR " : # d = 5 # break # case " STR " : # d = 1 0 # break # case " STR " : # d = 5 0 # break # case " STR " : # d = 1 0 0 # break # case " STR " : # d = 5 0 0 # break # case " STR " : # d = 1 0 0 # break # } # # return d
var ret [][] int # l := len ( nums ) # if l == 0 { # return ret # } # helper ( nums , 0 , l - 1 , & ret ) # return ret
qs := [] question 6 3 { # # { # para 6 3 {[][] int { # { 0 , 0 , 0 }, # { 0 , 1 , 0 }, # { 0 , 0 , 0 }, # }}, # ans 6 3 { 2 }, # }, # # { # para 6 3 {[][] int { # { 0 , 0 }, # { 1 , 1 }, # { 0 , 0 }, # }}, # ans 6 3 { 0 }, # }, # # { # para 6 3 {[][] int { # { 0 , 1 , 0 , 0 }, # { 1 , 0 , 0 , 0 }, # { 0 , 0 , 0 , 0 }, # }}, # ans 6 3 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 6 3 , q . para 6 3 # fmt . Printf (" STR ", p , uniquePathsWithObstacles ( p . og )) # } # fmt . Printf (" STR ")
a , b , sum := 0 , 1 , 0 # # for i := 1 ; i <= n ; i ++ { # sum = ( a + b ) % 1 0 0 0 0 0 0 0 0 7 # a = b # b = sum # } # return a
if a == b { # return - 1 # } # if len ( a ) > len ( b ) { # return len ( a ) # } # return len ( b )
cases := [] struct { # name string # input 1 [] int # input 2 [][] int # expect [] int # }{ # {" STR ", [] int {- 2 , 0 , 3 , - 5 , 2 , - 1 }, [][] int {{ 0 , 2 }, { 2 , 5 }, { 0 , 5 }}, [] int { 1 , - 1 , - 3 }}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # obj := Constructor ( c . input 1 ) # for i := 0 ; i < len ( c . input 2 ); i ++ { # got := obj . SumRange ( c . input 2 [ i ][ 0 ], c . input 2 [ i ][ 1 ]) # if ! reflect . DeepEqual ( got , c . expect [ i ]) { # t . Fatalf (" STR ", # c . expect [ i ], got , c . input 2 [ i ], c . input 1 [ i ]) # } # } # }) # }
lenNum := len ( nums ) # if lenNum == 0 { # return 0 # } # for i := 0 ; i < len ( nums ); i ++ { # if nums [ i ] == val { # nums = append ( nums [: i ], nums [ i + 1 :]...) # i -- # lenNum -- # } # } # return lenNum
if root == nil { # return nil # } # h := getHeight ( root ) # w := pow ( 2 , h ) - 1 # ret = make ([][] string , h ) # for k := range ret { # s := make ([] string , w ) # for key := range s { # s [ key ] = " STR " # } # ret [ k ] = s # } # helper ( root , 0 , 0 , w ) # return ret
switch len ( a ) { # case 0 : # return 0 # case 1 : # return a [ 0 ] # case 2 : # if a [ 0 ] > a [ 1 ] { # return a [ 1 ] # } else { # return a [ 0 ] # } # default : # min := math . MaxInt 3 2 # for _ , i := range a { # if i < min { # min = i # } # } # return min # }
qs := [] question 8 4 { # # { # para 8 4 {[] int { 2 , 1 , 5 , 6 , 2 , 3 }}, # ans 8 4 { 1 0 }, # }, # # { # para 8 4 {[] int { 1 }}, # ans 8 4 { 1 }, # }, # # { # para 8 4 {[] int { 1 , 1 }}, # ans 8 4 { 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 4 , q . para 8 4 # fmt . Printf (" STR ", p , largestRectangleArea ( p . one )) # } # fmt . Printf (" STR ")
res := [] int {} # target := [ 2 6 ] int {} # window := [ 2 6 ] int {} # for i := 0 ; i < len ( p ); i ++ { # target [ p [ i ]-' a ']++ # } # # check := func ( i int ) { # if window == target { # res = append ( res , i ) # } # } # # for i := 0 ; i < len ( s ); i ++ { # window [ s [ i ]-' a ']++ # if i == len ( p )- 1 { # check ( 0 ) # } else if len ( p ) <= i { # window [ s [ i - len ( p )]-' a ']-- # check ( i - len ( p ) + 1 ) # } # } # # return res
t := make ( map [ int ] int , len ( nums )) # for i , v := range nums { # if vv , ok := t [ v ]; ok { # return [] int { vv , i } # } # t [ target - v ] = i # } # return nil
writer . Write ( l . Message )
cases := [] struct { # name string # inputs [] int # expect bool # }{ # {" STR ", [] int { 2 , 1 }, false }, # {" STR ", [] int { 3 , 5 , 5 }, false }, # {" STR ", [] int { 3 , 4 , 5 }, false }, # {" STR ", [] int { 0 , 3 , 2 , 1 }, true }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
fmt . Println ( strconv . Itoa ( 1 )) # fmt . Println ( strings . Compare (" STR ", " STR ")) # fmt . Println ( math . Abs ( 1 . 0 )) # fmt . Println ( unicode . IsDigit (' 1 '))
wg . Add ( 2 ) # # fmt . Println (" STR ") # go addTable () # go multiTable () # wg . Wait () # fmt . Println (" STR ")
m := make ( map [ rune ] int ) # for _ , v := range magazine { # m [ v ]++ # } # for _ , v := range ransomNote { # c , ok := m [ v ] # if ok == false || c == 0 { # return false # } # m [ v ]-- # } # return true
if ll . isEmpty () { # return - 1 # } # data := ll . head . Data # # ll . head = ll . head . Next # # if ll . head == nil { # ll . tail = nil # } # # ll . length -- # return data
result := LeastCommonMultiple ( 1 ) # if result != 1 { # t . Errorf (" STR ", result , 1 ) # } # # result = LeastCommonMultiple ( 2 ) # if result != 2 { # t . Errorf (" STR ", result , 2 ) # } # # result = LeastCommonMultiple ( 3 ) # if result != 6 { # t . Errorf (" STR ", result , 6 ) # } # # result = LeastCommonMultiple ( 4 ) # if result != 1 2 { # t . Errorf (" STR ", result , 1 2 ) # } # # result = LeastCommonMultiple ( 1 0 ) # if result != 2 5 2 0 { # t . Errorf (" STR ", result , 2 5 2 0 ) # }
return calc ( 0 , len ( nums )- 1 , nums )
var tests = [] struct { # nums [] int # target int # index int # }{ # {[] int { 1 , 3 , 5 , 6 }, 5 , 2 }, # {[] int { 1 , 3 , 5 , 6 }, 2 , 1 }, # {[] int { 1 , 3 , 5 , 6 }, 7 , 4 }, # {[] int { 1 , 3 , 5 , 6 }, 0 , 0 }, # { nil , 0 , 0 }, # } # # for _ , tt := range tests { # index := searchInsert ( tt . nums , tt . target ) # if index != tt . index { # t . Errorf (" STR ", tt . nums , tt . target , index , tt . index ) # } # }
qs := [] question 2 1 3 { # # { # para 2 1 3 {[] int { 0 , 0 }}, # ans 2 1 3 { 0 }, # }, # # { # para 2 1 3 {[] int { 2 , 3 , 2 }}, # ans 2 1 3 { 3 }, # }, # { # para 2 1 3 {[] int { 1 , 2 , 3 , 1 }}, # ans 2 1 3 { 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 2 1 3 , q . para 2 1 3 # fmt . Printf (" STR ", p , rob 2 1 3 ( p . one )) # } # fmt . Printf (" STR ")
kR , kC := findBlackKing ( board ) # for r := range board { # for c := range board [ r ] { # switch board [ r ][ c ] { # case ' B ': # if bishop ( board , r , c , kR , kC ) { # return true # } # case ' N ': # if knight ( board , r , c , kR , kC ) { # return true # } # case ' P ': # if pawn ( board , r , c , kR , kC ) { # return true # } # case ' R ': # if rook ( board , r , c , kR , kC ) { # return true # } # case ' Q ': # if queen ( board , r , c , kR , kC ) { # return true # } # } # } # } # return false
start , end := 0 , len ( s )- 1 # for start < end { # if ! isAlphanumeric ( s [ start ]) { # start ++ # continue # } # if ! isAlphanumeric ( s [ end ]) { # end -- # continue # } # x := s [ start ] # if s [ start ] >= ' a ' { # x = s [ start ] + ' A ' - ' a ' # } # y := s [ end ] # if s [ end ] >= ' a ' { # y = s [ end ] + ' A ' - ' a ' # } # if x != y { # return false # } # start ++ # end -- # } # return true
if s == " STR "{ # return true # } # ls := len ( s ) # lt := len ( t ) # var flag = false # tmp := 0 # for i := 0 ; i < ls ; i ++ { # for j := tmp ; j < lt ; j ++ { # if s [ i ] == t [ j ] { # flag = true # tmp = j + 1 # break # } # } # if ! flag || i + 1 == ls { # return flag # } else { # flag = false # } # } # return flag
if head == nil || head . Next == nil { # return head # } # tmp := head . Next # head . Next = swapPairs ( tmp . Next ) # tmp . Next = head # return tmp
arr := randomSlice ( 0 , 2 0 , 1 0 ) # resultArr := make ([] int , 0 , 0 ) # expArr := make ([] int , 0 , 0 ) # bst := newBstIterative () # expBst := newBstRecrusive () # for _ , v := range arr { # bst . Insert ( uint 3 2 ( v )) # expBst . Insert ( uint 3 2 ( v )) # } # expBst . PreOrderWalk ( expBst . Root (), func ( tree binaryTreeIf , node interface {}) bool { # n := node .(* bstElement ) # expArr = append ( expArr , int ( n . Key )) # return false # }) # bst . PreOrderWalk ( bst . Root (), func ( tree binaryTreeIf , node interface {}) bool { # n := node .(* bstElement ) # if * debug { # fmt . Println ( n ) # } # resultArr = append ( resultArr , int ( n . Key )) # return false # }) # if ! reflect . DeepEqual ( resultArr , expArr ) { # t . Log ( fmt . Sprintf (" STR ", expArr ) + fmt . Sprintf (" STR ", resultArr )) # t . Fail () # }
if numerator == 0 { # return " STR " # } # res := " STR " # neg := false # if numerator < 0 { # numerator *= - 1 # neg = ! neg # } # if denominator < 0 { # denominator *= - 1 # neg = ! neg # } # if neg { # res = " STR " # } # res += strconv . Itoa ( numerator / denominator ) # rem := numerator % denominator # if rem == 0 { # return res # } # res += " STR " # floatBytes := [] byte {} # itob := [] byte (" STR ") # indexMap := map [ int ] int {} # for rem != 0 { # if index , ok := indexMap [ rem ]; ok { # return res + string ( floatBytes [: index ]) + " STR " + string ( floatBytes [ index :]) + " STR " # } # indexMap [ rem ] = len ( floatBytes ) # rem *= 1 0 # b := itob [ rem / denominator ] # rem %= denominator # floatBytes = append ( floatBytes , b ) # } # return res + string ( floatBytes )
m , n := len ( word 1 ), len ( word 2 ) # # dtab := make ([] int , m + 1 ) # for i := 0 ; i < m + 1 ; i ++ { # dtab [ i ] = i # } # # for j := 1 ; j < n + 1 ; j ++ { # last := dtab [ 0 ] # dtab [ 0 ] = j # # for i := 1 ; i < m + 1 ; i ++ { # if word 1 [ i - 1 ] == word 2 [ j - 1 ] { # dtab [ i ], last = last , dtab [ i ] # } else { # min := last # if dtab [ i ] < min { # min = dtab [ i ] # } # if dtab [ i - 1 ] < min { # min = dtab [ i - 1 ] # } # dtab [ i ], last = min + 1 , dtab [ i ] # } # } # } # return dtab [ m ]
leftNode . keyValue = append ( leftNode . keyValue , mid ) # rightNode . keyValue = append ( leftNode . keyValue , rightNode . keyValue ...) # for _ , v := range leftNode . c { # if v != nil { # v . p = rightNode # } # } # rightNode . c = append ( leftNode . c , rightNode . c ...) # return rightNode
qs := [] question 1 0 4 9 { # # { # para 1 0 4 9 {[] int { 2 , 7 , 4 , 1 , 8 , 1 }}, # ans 1 0 4 9 { 1 }, # }, # # { # para 1 0 4 9 {[] int { 2 1 , 2 6 , 3 1 , 3 3 , 4 0 }}, # ans 1 0 4 9 { 5 }, # }, # # { # para 1 0 4 9 {[] int { 1 , 2 }}, # ans 1 0 4 9 { 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 0 4 9 , q . para 1 0 4 9 # fmt . Printf (" STR ", p , lastStoneWeightII ( p . one )) # } # fmt . Printf (" STR ")
if len ( nums ) < 2 { # return 0 # } # quickSort 1 6 4 ( nums , 0 , len ( nums )- 1 ) # # res := 0 # for i := 0 ; i < len ( nums )- 1 ; i ++ { # if ( nums [ i + 1 ] - nums [ i ]) > res { # res = nums [ i + 1 ] - nums [ i ] # } # } # return res
cubes := make ( map [ string ][] uint 6 4 ) # i := 0 # for true { # i += 1 # cube := uint 6 4 ( i * i * i ) # key := sortedDigits ( cube ) # _ , found := cubes [ key ] # if found { # cubes [ key ] = append ( cubes [ key ], cube ) # if len ( cubes [ key ]) == 5 { # return cubes [ key ][ 0 ] # } # } else { # cubes [ key ] = make ([] uint 6 4 , 1 ) # cubes [ key ][ 0 ] = cube # } # } # return uint 6 4 ( 0 )
m := len ( grid ) # n := len ( grid [ 0 ]) # # dp := make ([][] int , m ) # for i := range dp { # dp [ i ] = make ([] int , n ) # } # # dp [ 0 ][ 0 ] = grid [ 0 ][ 0 ] # # for i := 1 ; i < m ; i ++ { # dp [ i ][ 0 ] = grid [ i ][ 0 ] + dp [ i - 1 ][ 0 ] # } # # for j := 1 ; j < n ; j ++ { # dp [ 0 ][ j ] = grid [ 0 ][ j ] + dp [ 0 ][ j - 1 ] # } # # for i := 1 ; i < m ; i ++ { # for j := 1 ; j < n ; j ++ { # dp [ i ][ j ] = grid [ i ][ j ] + min ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]) # } # } # # return dp [ m - 1 ][ n - 1 ]
size := len ( s ) # for i := range ( s [: size / 2 ]) { # s [ i ], s [ size - 1 - i ] = s [ size - 1 - i ], s [ i ] # } # return s
ans := make ( map [ string ] int , 0 ) # # for _ , item := range cpdomains { # parts := strings . Split ( item , " STR ") # domain := parts [ 1 ] # count , _ := strconv . Atoi ( parts [ 0 ]) # # ans [ domain ] += count # idx := strings . LastIndex ( domain , " STR ") # for i := 0 ; i <= idx ; i ++ { # if domain [ i ] == '.' { # temp := domain [ i + 1 :] # ans [ temp ] += count # } # } # } # # ansList := make ([] string , 0 ) # for k , v := range ans { # ansList = append ( ansList , strconv . Itoa ( v )+" STR "+ k ) # } # return ansList
i := & Index { # Target : & VariableAccess { Name : " STR "}, # Key : & LiteralNode { # Typex : TypeString , # Value : " STR ", # }, # } # # scope := & BasicScope { # VarMap : map [ string ] Variable { # " STR ": Variable { # Type : TypeMap , # Value : map [ string ] Variable { # " STR ": Variable { # Type : TypeInt , # Value : 1 , # }, # " STR ": Variable { # Type : TypeInt , # Value : 2 , # }, # }, # }, # }, # } # # actual , err := i . Type ( scope ) # if err != nil { # t . Fatalf (" STR ", err ) # } # if actual != TypeInt { # t . Fatalf (" STR ", actual ) # }
for i := 0 ; i < 9 ; i ++ { # row := make ( map [ byte ] bool ) # col := make ( map [ byte ] bool ) # boxes := make ( map [ byte ] bool ) # # for j := 0 ; j < 9 ; j ++ { # if board [ i ][ j ] != '.' { # if row [ board [ i ][ j ]] { # return false # } # row [ board [ i ][ j ]] = true # } # if board [ j ][ i ] != '.' { # if col [ board [ j ][ i ]] { # return false # } # col [ board [ j ][ i ]] = true # } # # if board [ i / 3 * 3 + j / 3 ][ i % 3 * 3 + j % 3 ] != '.' { # if boxes [ board [ i / 3 * 3 + j / 3 ][ i % 3 * 3 + j % 3 ]] { # return false # } # boxes [ board [ i / 3 * 3 + j / 3 ][ i % 3 * 3 + j % 3 ]] = true # } # } # } # return true
if len ( b ) > len ( a ) { # a , b = b , a # } # # res := make ([] string , len ( a )+ 1 ) # i , j , k , c := len ( a )- 1 , len ( b )- 1 , len ( a ), 0 # for i >= 0 && j >= 0 { # ai , _ := strconv . Atoi ( string ( a [ i ])) # bj , _ := strconv . Atoi ( string ( b [ j ])) # res [ k ] = strconv . Itoa (( ai + bj + c ) % 2 ) # c = ( ai + bj + c ) / 2 # i -- # j -- # k -- # } # # for i >= 0 { # ai , _ := strconv . Atoi ( string ( a [ i ])) # res [ k ] = strconv . Itoa (( ai + c ) % 2 ) # c = ( ai + c ) / 2 # i -- # k -- # } # # if c > 0 { # res [ k ] = strconv . Itoa ( c ) # } # # return strings . Join ( res , " STR ")
qs := [] question 8 4 1 { # # { # para 8 4 1 {[][] int {{ 1 }, { 2 }, { 3 }, {}}}, # ans 8 4 1 { true }, # }, # # { # para 8 4 1 {[][] int {{ 1 , 3 }, { 3 , 0 , 1 }, { 2 }, { 0 }}}, # ans 8 4 1 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 4 1 , q . para 8 4 1 # fmt . Printf (" STR ", p , canVisitAllRooms ( p . rooms )) # } # fmt . Printf (" STR ")
if x == 2 { return true } # if x % 2 == 0 { return false } # # var i , z int 6 4 = 3 , int 6 4 ( math . Sqrt ( float 6 4 ( x ))) # for ; i <= z ; i += 2 { # if x % i == 0 { return false } # } # return true
for x != nil && y != nil { # # if x . Val != y . Val { # return false # } # # x = x . Next # y = y . Next # } # # if x != nil || y != nil { # return false # } # # return true #
node := NewNode () # # node . Insert (" STR ") # node . Insert (" STR ") # # node . Find (" STR ") # node . Find (" STR ") # node . Find (" STR ")
hashss , pow := HashStr ( substr ) # n := len ( substr ) # var h uint 3 2 # for i := 0 ; i < n ; i ++ { # h = h * PrimeRK + uint 3 2 ( s [ i ]) # } # if h == hashss && s [: n ] == substr { # return 0 # } # for i := n ; i < len ( s ); { # h *= PrimeRK # h += uint 3 2 ( s [ i ]) # h -= pow * uint 3 2 ( s [ i - n ]) # i ++ # if h == hashss && s [ i - n : i ] == substr { # return i - n # } # } # return - 1
length := len ( nums ) # if length <= 2 { # return length # } # # res := 2 # for i := 2 ; i < length ; i ++ { # if nums [ i ] != nums [ res - 2 ] { # nums [ res ] = nums [ i ] # res ++ # } # } # # return res
lengths := make ([] int , len ( nums )) # max := 0 # for i := 0 ; i < len ( nums ); i ++ { # lengths [ i ] = 1 # for j := 0 ; j < i ; j ++ { # if nums [ i ] > nums [ j ] { # lengths [ i ] = int ( math . Max ( float 6 4 ( lengths [ i ]), float 6 4 ( lengths [ j ]+ 1 ))) # } # } # # max = int ( math . Max ( float 6 4 ( max ), float 6 4 ( lengths [ i ]))) # } # # return max
x , o := 0 , 0 # for i := 0 ; i < 3 ; i ++ { # for j := 0 ; j < 3 ; j ++ { # if i == j { # if moves [ i ][ j ] == " STR " { # x ++ # } else if moves [ i ][ j ] == " STR " { # o ++ # } # } # } # if x == 3 { # return " STR " # } else if o == 3 { # return " STR " # } # } # x , o = 0 , 0 # for i := 0 ; i < 3 ; i ++ { # for j := 0 ; j < 3 ; j ++ { # if i + j == 2 { # if moves [ i ][ j ] == " STR " { # x ++ # } else if moves [ i ][ j ] == " STR " { # o ++ # } # } # } # if x == 3 { # return " STR " # } else if o == 3 { # return " STR " # } # } # return " STR "
t . Parallel () # for _ , tc := range testcases { # copied := make ([] int , len ( tc . pairs )) # copy ( copied , tc . pairs ) # if result := MinSwapsAdjacentPairs ( copied ); result != tc . minSwaps { # t . Errorf (" STR ", tc . minSwaps , result ) # } # }
l := new ( ListNode ) # # n := l # for l 1 != nil && l 2 != nil { # if l 1 . Val <= l 2 . Val { # n . Next = l 1 # n = n . Next # l 1 = l 1 . Next # } else { # n . Next = l 2 # n = n . Next # l 2 = l 2 . Next # } # } # # if l 1 != nil { # n . Next = l 1 # } # if l 2 != nil { # n . Next = l 2 # } # # return l . Next
var p Pool # var fin uint 3 2 # const N = 1 0 0 # for i := 0 ; i < N ; i ++ { # v := new ( int ) # runtime . SetFinalizer ( v , func ( vv * int ) { # atomic . AddUint 3 2 (& fin , 1 ) # }) # p . Put ( v ) # } # for i := 0 ; i < N ; i ++ { # p . Get () # } # for i := 0 ; i < 5 ; i ++ { # runtime . GC () # time . Sleep ( time . Millisecond ) # if atomic . LoadUint 3 2 (& fin ) >= N - 2 { # return # } # } # t . Fatalf (" STR ", # atomic . LoadUint 3 2 (& fin ), N )
var b [] byte # # var k byte # for i , j := len ( num 1 )- 1 , len ( num 2 )- 1 ; i >= 0 || j >= 0 ; i , j = i - 1 , j - 1 { # sum := k # if i >= 0 { # sum += num 1 [ i ] - ' 0 ' # } # if j >= 0 { # sum += num 2 [ j ] - ' 0 ' # } # k = sum / 1 0 # b = append ( b , ' 0 '+ sum % 1 0 ) # } # if k > 0 { # b = append ( b , ' 1 ') # } # # for i , j := 0 , len ( b )- 1 ; i < j ; i , j = i + 1 , j - 1 { # b [ i ], b [ j ] = b [ j ], b [ i ] # } # return string ( b )
sumMax := make ([] int , len ( nums )) # sumMaxResult := nums [ 0 ] # for i := 0 ; i < len ( nums ); i ++ { # if i == 0 { # sumMax [ i ] = nums [ i ] # if sumMax [ i ] > sumMaxResult { # sumMaxResult = sumMax [ i ] # } # } else { # if sumMax [ i - 1 ] > 0 { # sumMax [ i ] = sumMax [ i - 1 ] + nums [ i ] # } else { # sumMax [ i ] = nums [ i ] # } # } # # if sumMax [ i ] > sumMaxResult { # sumMaxResult = sumMax [ i ] # } # } # return sumMaxResult
s := " STR " # t 1 := path . Join ( path . Dir ( os . Args [ 0 ]), " STR ") # t 2 := path . Join ( path . Dir ( os . Args [ 0 ]), " STR ") # err := ioutil . WriteFile ( t 1 , [] byte ( s ), os . FileMode ( 0 6 6 6 )) # if err != nil { # log . Fatal ( err ) # } # err = CopyFile ( t 2 , t 1 ) # if err != nil { # log . Fatal ( err ) # } # b , err := ioutil . ReadFile ( t 2 ) # if err != nil { # log . Fatal ( err ) # } # err = os . Remove ( t 1 ) # if err != nil { # log . Fatal ( err ) # } # err = os . Remove ( t 2 ) # if err != nil { # log . Fatal ( err ) # } # fmt . Printf (" STR ", string ( b ))
visited [ start ] = struct {}{} # if start == end { # delete ( visited , start ) # return 0 , nil # } # var results [] int # cells := [] Cell {{ start . row + 1 , start . col }, { start . row - 1 , start . col }, { start . row , start . col - 1 }, { start . row , start . col + 1 }} # for _ , cell := range cells { # if _ , found := visited [ cell ]; ! found && isValidNextCell ( board , cell ) { # dist , err := MinimumSteps ( board , cell , end , visited ) # if err == nil { # results = append ( results , dist ) # } # } # } # sort . Ints ( results ) # delete ( visited , start ) # if len ( results ) == 0 { # return 0 , errNoPath # } # return 1 + results [ 0 ], nil
var b bytes . Buffer # b . Write ([] byte (" STR ")) # # fmt . Fprintf (& b , " STR ") # # b . WriteTo ( os . Stdout )
cases := [] struct { # name string # inputs [] int # expects [] int # }{ # {" STR ", [] int { 0 , 1 , 0 , 3 , 1 2 }, [] int { 1 , 3 , 1 2 , 0 , 0 }}, # } # # for _ , testcase := range cases { # t . Run ( testcase . name , func ( t * testing . T ) { # result := moveZeroes ( testcase . inputs ) # if ! reflect . DeepEqual ( result , testcase . expects ) { # t . Fatalf (" STR ", testcase . expects , result , testcase . inputs ) # } # # }) # }
if len ( nums ) == 1 { # return nums [ 0 ] # } # if len ( nums ) == 2 { # if nums [ 0 ] > nums [ 1 ] { # return nums [ 0 ] # } # return nums [ 1 ] # } # first , second , third := ^ 1 << 3 2 , ^ 1 << 3 2 , ^ 1 << 3 2 # for i := range nums { # if first == nums [ i ] || second == nums [ i ] || third == nums [ i ] { # continue # } # if nums [ i ] > first { # third = second # second = first # first = nums [ i ] # } else if nums [ i ] > second { # third = second # second = nums [ i ] # } else if nums [ i ] > third { # third = nums [ i ] # } # } # if third == ^ 1 << 3 2 { # return first # } # return third
data := [] int { 2 , 4 , 3 , 6 , 3 , 2 , 5 , 5 } # fmt . Println ( findNumbersAppearOnce ( data )) # # data 2 := [] int { 2 , 2 , 2 , 3 , 3 , 3 , 4 } # fmt . Println ( findNumberAppearOnce 2 ( data 2 ))
tests := [...] testType { # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : false , # }, # { # in : " STR ", # want : false , # }, # } # for _ , tt := range tests { # got := judgeCircle ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
c := NewCircularBuffer ( 1 0 ) # # go func () { # for i := 0 ; i < 4 ; i ++ { # v := c . Pop ().( int ) # if i != v { # t . Error ( v ) # } # } # # if c . verifyIsEmpty () != true { # t . Error (" STR ") # } # }() # # c . NBPush ( 3 ) # c . NBPush ( 2 ) # c . NBPush ( 1 ) # c . NBPush ( 0 )
if n % d == 0 { # return n / d # } # return ( n / d ) + 1
if head == nil || head . Next == nil || k < 2 { # return head # } # # p := new ( ListNode ) # s := new ( ListNode ) # l := k # p . Next = head # head = p # s = p # # for s != nil && k != 0 { # s = s . Next # k -- # } # # for s != nil { # reverse (& p , & s ) # k = l # for s != nil && k != 0 { # s = s . Next # k -- # } # } # return head . Next
i := [ 1 0 ] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "} # x := [ 1 0 ] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "} # c := [ 1 0 ] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "} # m := [ 4 ] string {" STR ", " STR ", " STR ", " STR "} # return m [ num / 1 0 0 0 ] + c [ num % 1 0 0 0 / 1 0 0 ] + x [ num % 1 0 0 0 % 1 0 0 / 1 0 ] + i [ num % 1 0 0 0 % 1 0 0 % 1 0 ]
m , n , res := len ( matrix ), len ( matrix [ 0 ]), 0 # for row := range matrix { # for col := 1 ; col < len ( matrix [ row ]); col ++ { # matrix [ row ][ col ] += matrix [ row ][ col - 1 ] # } # } # for i := 0 ; i < n ; i ++ { # for j := i ; j < n ; j ++ { # counterMap , sum := make ( map [ int ] int , m ), 0 # counterMap [ 0 ] = 1 # for row := 0 ; row < m ; row ++ { # if i > 0 { # sum += matrix [ row ][ j ] - matrix [ row ][ i - 1 ] # } else { # sum += matrix [ row ][ j ] # } # res += counterMap [ sum - target ] # counterMap [ sum ]++ # } # } # } # return res
return func ( tree binaryTreeIf , node interface {}) bool { # n := node .(* bstElement ) # if n . left != nil && n . left . Key >= n . Key { # t . Log ( fmt . Sprintf (" STR ", n . left , n )) # t . Fail () # return true # } # if n . right != nil && n . right . Key <= n . Key { # t . Log ( fmt . Sprintf (" STR ", n . right , n )) # t . Fail () # return true # } # if debug { # fmt . Println ( n ) # } # * nodeCnt ++ # return false # }
{ # fmt . Printf (" STR ", BoilingC - FreezingC ) # boilingF := CToF ( BoilingC ) # fmt . Printf (" STR ", boilingF - CToF ( FreezingC )) # } # /* # fmt . Printf (" STR ", boilingF - FreezingC ) # */ #
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", [][] int { # { 0 , 1 , 1 , 1 }, # { 1 , 1 , 1 , 1 }, # { 0 , 1 , 1 , 1 }, # }, 1 5 }, # {" STR ", [][] int { # { 1 , 0 , 1 }, # { 1 , 1 , 0 }, # { 1 , 1 , 0 }, # }, 7 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
l 1 Map := map [ string ] int {} # l 2 Map := map [ string ] int {} # var res [] string # for i := 0 ; i < len ( list 1 ); i ++ { # l 1 Map [ list 1 [ i ]] = i # } # for i := 0 ; i < len ( list 2 ); i ++ { # l 2 Map [ list 2 [ i ]] = i # } # # var max = len ( list 1 ) + len ( list 2 ) # for i := 0 ; i < len ( list 1 ); i ++ { # l 1 Str := list 1 [ i ] # if _ , ok := l 2 Map [ l 1 Str ]; ok { # sum := l 2 Map [ l 1 Str ] + i # if sum < max { # max = sum # res = res [: 0 ] # res = append ( res , list 1 [ i ]) # continue # } # # if sum == max { # res = append ( res , list 1 [ i ]) # continue # } # } # } # # return res #
trie := Constructor () # trie . Insert (" STR ") # fmt . Println ( trie . Search (" STR ")) # fmt . Println ( trie . Search (" STR ")) # fmt . Println ( trie . StartsWith (" STR ")) # trie . Insert (" STR ") # fmt . Println ( trie . Search (" STR "))
if root == nil { # return 0 # } # # ld := maxDepth ( root . Left ) # rd := maxDepth ( root . Right ) # # d := ld # if rd > ld { # d = rd # } # return d + 1
if x < 0 { # return false # } # # s := strconv . Itoa ( x ) # # for i , j := 0 , len ( s )- 1 ; i < j ; i , j = i + 1 , j - 1 { # if s [ i ] != s [ j ] { # return false # } # } # # return true
grid := make ([][] uint 6 4 , size + 1 ) # # for i := 0 ; i < size + 1 ; i ++ { # grid [ i ] = make ([] uint 6 4 , size + 1 ) # } # # for i := 0 ; i < size ; i ++ { # grid [ size ][ i ] = 1 # grid [ i ][ size ] = 1 # } # grid [ size ][ size ] = 0 # # for x := size - 1 ; x >= 0 ; x -- { # for y := size - 1 ; y >= 0 ; y -- { # grid [ x ][ y ] = grid [ x + 1 ][ y ] + grid [ x ][ y + 1 ] # } # } # # return grid [ 0 ][ 0 ] #
return dfs ( root , root )
t . Parallel () # for tcid , tc := range testcases { # if result := MergeBinaryTrees ( tc . one , tc . two ); ! equal ( result , tc . merged ) { # t . Errorf (" STR ", tcid ) # } # }
if len ( nums ) == 0 { # return - 1 # } # start , end := 0 , len ( nums )- 1 # for start <= end { # mid := ( start + end ) / 2 # if nums [ mid ] == target { # return mid # } # if nums [ mid ] > target { # end = mid - 1 # continue # } # if nums [ mid ] < target { # start = mid + 1 # } # } # return - 1
goroot := os . Getenv (" STR ") # if goroot != "" { # return getStandardGoroot ( goroot ) # } # # binpath , err := exec . LookPath (" STR ") # if err == nil { # binpath , err = filepath . EvalSymlinks ( binpath ) # if err == nil { # goroot := filepath . Dir ( filepath . Dir ( binpath )) # if isGoroot ( goroot ) { # return goroot # } # } # } # # if isGoroot ( runtime . GOROOT ()) { # return runtime . GOROOT () # } # # var candidates [] string # switch runtime . GOOS { # case " STR ": # candidates = [] string { # " STR ", # " STR ", # " STR ", # } # case " STR ": # candidates = [] string { # " STR ", # " STR ", # } # } # # for _ , candidate := range candidates { # if isGoroot ( candidate ) { # return candidate # } # } # # return ""
n := len ( pre ) # if n == 0 { # return nil # } # res := & TreeNode { # Val : pre [ 0 ], # } # if n == 1 { # return res # } # l := pre [ 1 ] # i := 0 # for i < n { # if post [ i ] == l { # break # } # i ++ # } # res . Left = constructFromPrePost ( pre [ 1 : i + 2 ], post [: i + 1 ]) # res . Right = constructFromPrePost ( pre [ i + 2 :], post [ i + 1 : n - 1 ]) # return res
if ll . Head == nil { # return - 1 # } # # cur := ll . Head # ll . Head = cur . Next # ll . length -- # # return cur . Val
tests := [...] testType { # { # sentence : " STR ", # searchWord : " STR ", # want : 4 , # }, # { # sentence : " STR ", # searchWord : " STR ", # want : 2 , # }, # { # sentence : " STR ", # searchWord : " STR ", # want : - 1 , # }, # { # sentence : " STR ", # searchWord : " STR ", # want : 4 , # }, # { # sentence : " STR ", # searchWord : " STR ", # want : - 1 , # }, # } # for _ , tt := range tests { # got := isPrefixOfWord ( tt . sentence , tt . searchWord ) # if got != tt . want { # t . Fatalf (" STR ", tt . sentence , got , tt . want ) # } # }
tests := [...] testType { # { # in : [] int {- 1 , 0 , 1 , 2 , - 1 , - 4 }, # want : [][] int { # {- 1 , - 1 , 2 }, # {- 1 , 0 , 1 }, # }, # }, # { # in : [] int { 0 , 0 , 0 , 0 }, # want : [][] int { # { 0 , 0 , 0 }, # }, # }, # { # in : [] int {- 2 , 0 , 0 , 2 , 2 , 2 }, # want : [][] int { # {- 2 , 0 , 2 }, # }, # }, # { # in : [] int {- 2 , 0 , 0 , 2 , 2 , 2 , 2 }, # want : [][] int { # {- 2 , 0 , 2 }, # }, # }, # } # for _ , tt := range tests { # got := threeSum ( tt . in ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
cases := [] struct { # name string # inputs int # expect int # }{ # {" STR ", 4 , 2 }, # {" STR ", 8 , 2 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := mySqrt ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
if n --; n < 2 6 { # return fmt . Sprintf (" STR ", n +' A ') # } # return convertToTitle ( n / 2 6 ) + fmt . Sprintf (" STR ", n % 2 6 +' A ')
pq := PQ ( stones ) # heap . Init (& pq ) # for len ( pq ) >= 2 { # a , b := heap . Pop (& pq ).( int ), heap . Pop (& pq ).( int ) # if a == b { # continue # } # heap . Push (& pq , a - b ) # } # if len ( pq ) == 0 { # return 0 # } # return pq [ 0 ]
return me . Dialer . DialContext ( ctx , me . Network , addr )
var p * ListNode # # for head != nil { # tmp := head . Next # head . Next = p # p = head # head = tmp # } # return p
if prevV , found := kvs . keyToVals [ k ]; found { # delete ( kvs . valToKeys [ prevV ], k ) # # if len ( kvs . valToKeys [ prevV ]) == 0 { # delete ( kvs . valToKeys , prevV ) # } # } # # kvs . keyToVals [ k ] = v # if m , exists := kvs . valToKeys [ v ]; exists { # m [ k ] = struct {}{} # } else { # kvs . valToKeys [ v ] = make ( map [ int ] struct {}) # kvs . valToKeys [ v ][ k ] = struct {}{} # }
if num <= 1 { # return false # } # for i := 2 ; i * i <= num ; i ++ { # if num % i == 0 { # return false # } # } # return true
s := " STR " # k := 2 # # fmt . Println ( reverseStr ( s , k )) # # s 1 := " STR " # k 1 := 2 # fmt . Println ( reverseStr ( s 1 , k 1 ))
if x % 2 == 0 { # return false # } # # l := int ( math . Sqrt ( float 6 4 ( x ))) # for i := 1 ; i >= l ; i += 2 { # fmt . Println (" STR ", x , i , l ) # if x % i == 0 { # return false # } # } # # return true
count := len ( B ) / len ( A ) # if len ( B )% len ( A ) > 0 { # count ++ # } # for times := 0 ; times < 2 ; times ++ { # a := strings . Repeat ( A , count ) # if strings . Index ( a , B ) != - 1 { # return count # } # count ++ # } # return - 1
tests := [...] testType { # { # in : [] int { 1 , 2 , 0 , 0 }, # k : 3 4 , # want : [] int { 1 , 2 , 3 , 4 }, # }, # { # in : [] int { 2 , 1 , 5 }, # k : 8 0 6 , # want : [] int { 1 , 0 , 2 , 1 }, # }, # { # in : [] int { 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 }, # k : 1 , # want : [] int { 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 }, # }, # } # for _ , tt := range tests { # got := addToArrayForm ( tt . in , tt . k ) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
for end >= len ( t ) { # return "" # } # d := make ([] uint 8 , end - begin + 1 ) # for j , i := 0 , begin ; i <= end ; i , j = i + 1 , j + 1 { # d [ j ] = t [ i ] # } # return string ( d )
newItem := & Item { value , list . head , list . last , list } # list . locker . Lock () # defer list . locker . Unlock () # # if list . head == nil { # list . head = newItem # list . last = newItem # } else { # list . head . prev = newItem # list . head = newItem # list . last . next = newItem # } # # list . len ++ # # return list
if head == nil || head . Next == nil { # return true # } # fast , slow , tmp := head , head , head # var l ListNode # for fast != nil && fast . Next != nil { # fast = fast . Next . Next # tmp = slow . Next # slow . Next = l . Next # l . Next = slow # slow = tmp # } # if fast != nil { # slow = slow . Next # } # tmp = l . Next # for slow != nil && tmp != nil && slow . Val == tmp . Val { # slow , tmp = slow . Next , tmp . Next # } # return slow == nil
str := "" # for i , v := range name { # if v == " STR " && name [ i - 1 ] != " STR " { # str = str + " STR " # continue # } # if v == " STR " { # continue # } # if v == " STR " { # str = str + " STR " # continue # } # if v == " STR " { # str = str + " STR " # continue # } # # if v == " STR " && name [ i - 1 ] != " STR " { # str = str + " STR " # continue # } # # if v == " STR " { # continue # } # if v == " STR " { # continue # } # if v == 3 9 { # continue # } # if v == " STR " { # continue # } # if i > 0 && name [ i - 1 ] == " STR " { # str = str + string ( v ) # continue # } # str = str + string ( v ) # } # if name [ len ( name )- 1 :] == " STR " { # name = name [: len ( name )- 1 ] # } # return str
indexs := make ([][] int , 1 7 ) # count := make ([] int , len ( words )) # for i , word := range words { # l := len ( word ) # indexs [ l ] = append ( indexs [ l ], i ) # count [ i ] = 1 # } # # res := 1 # for length := 1 ; length + 1 <= 1 6 ; length ++ { # for _ , i := range indexs [ length ] { # for _ , j := range indexs [ length + 1 ] { # if count [ j ] > count [ i ] { # continue # } # if isPredecessor ( words [ i ], words [ j ]) { # count [ j ] = count [ i ] + 1 # } # } # } # } # # for _ , v := range count { # res = max ( res , v ) # } # return res
slow , fast := a [ 0 ], a [ a [ 0 ]] # for slow != fast { # slow , fast = a [ slow ], a [ a [ fast ]] # } # # slow = 0 # for slow != fast { # slow , fast = a [ slow ], a [ fast ] # } # # return slow
testCases := [][] int { # { 1 , 1 , 1 , 2 , 2 , 3 }, # { 1 , 2 , 2 }, # { 0 , 0 , 1 , 1 , 1 , 1 , 2 , 3 , 3 }, # {}, # { 1 }, # { 2 , 2 }, # { 2 , 2 , 2 }, # } # expected := [] int { 5 , 3 , 7 , 0 , 1 , 2 , 2 } # # for index , data := range testCases { # if res := removeDuplicates ( data ); res != expected [ index ] { # t . Errorf (" STR ", expected [ index ], res ) # } # }
dp := make ([] int , n + 1 ) # dp [ 1 ] = 1 # dp [ 2 ] = 1 # for i := 3 ; i <= n ; i ++ { # dp [ i ] = - 1 # for j := 1 ; j < i ; j ++ { # dp [ i ] = max ( dp [ i - j ]* j , max ( dp [ i ], j *( i - j ))) # } # } # return dp [ n ]
if nil == nums || len ( nums ) < 1 { # return 0 # } # # var idx int # for i := 0 ; i < len ( nums ); i ++ { # if nums [ i ] != val { # nums [ idx ] = nums [ i ] # idx ++ # } # } # return idx
var minT int # for i := 0 ; i < len ( inputTri ); i ++ { # if i == 0 { # minT += inputTri [ 0 ][ 0 ] # continue # } # # intSort := inputTri [ i ] # sort . Ints ( intSort ) # minT += intSort [ 0 ] # # } # return minT
TYPE_REGISTRY [ reflect . TypeOf ( Person {}). String ()] = reflect . TypeOf ( Person {}) # TYPE_REGISTRY [ reflect . TypeOf ( PersonDTO {}). String ()] = reflect . TypeOf ( PersonDTO {}) # # model := Person { ID : 7 , Name : " STR ", Phone : " STR ", DateOfBirth : time . Now ()} # val := ToDTO ( model ) # # fmt . Println ( model ) # # dto := val .( PersonDTO ) # fmt . Println ( dto ) # # checkdto := model . ToDTO () # # fmt . Println ( reflect . DeepEqual ( dto , checkdto ))
pos := make ([] int 6 4 , len ( num 1 )+ len ( num 2 )) # ans := "" # # for i := len ( num 1 ) - 1 ; i >= 0 ; i -- { # for j := len ( num 2 ) - 1 ; j >= 0 ; j -- { # mul := ( num 1 [ i ] - " STR ") * ( num 2 [ j ] - " STR ") # p 1 , p 2 := i + j , i + j + 1 # sum := int 6 4 ( mul ) + pos [ p 2 ] # # pos [ p 1 ] += sum / 1 0 # pos [ p 2 ] = sum % 1 0 # # } # } # # for _ , v := range pos { # ans += strconv . Itoa ( int ( v )) # } # ans = strings . TrimLeft ( ans , " STR ") # if len ( ans ) == 0 { # return " STR " # } # # return ans
res := make ([] int , 0 ) # if n % 2 == 0 { # for i := 0 ; i < n / 2 ; i ++ { # res = append ( res , - i - 1 ) # res = append ( res , i + 1 ) # } # } else { # for i := 0 ; i < n / 2 ; i ++ { # res = append ( res , - i - 1 ) # res = append ( res , i + 1 ) # } # res = append ( res , 0 ) # } # return res
sl := len ( s ) # tl := len ( t ) # if sl != tl { # return false # } # var sc [ 2 5 6 ] int # for i := 0 ; i < sl ; i ++ { # sc [ s [ i ]]++ # } # for i := 0 ; i < tl ; i ++ { # sc [ t [ i ]]-- # if sc [ t [ i ]] < 0 { # return false # } # } # return true
currentPath := parentPath + " STR " + fmt . Sprint ( node . Val ) # if parentPath == " STR " { # currentPath = fmt . Sprint ( node . Val ) # } # if node . Left == nil && node . Right == nil { # resultMap [ currentPath ] = struct {}{} # } # # if node . Left != nil { # traverse ( node . Left , currentPath , resultMap ) # } # # if node . Right != nil { # traverse ( node . Right , currentPath , resultMap ) # }
w := [] int { 1 , 3 } # sol := Constructor 5 2 8 ( w ) # fmt . Printf (" STR ", sol . PickIndex ()) # fmt . Printf (" STR ", sol . PickIndex ()) # fmt . Printf (" STR ", sol . PickIndex ()) # fmt . Printf (" STR ", sol . PickIndex ()) # fmt . Printf (" STR ", sol . PickIndex ()) # fmt . Printf (" STR ", sol . PickIndex ())
t . Parallel () # for _ , tc := range testcases { # if result := NumberOfFriendGroups ( tc . friends ); result != tc . distinctGroups { # t . Errorf (" STR ", tc . distinctGroups , result ) # } # }
sort . Sort ( stringSlice ( d )) # for i := range d { # if isSub ( s , d [ i ]) { # return d [ i ] # } # } # return " STR "
n := len ( deck ) # sort . Ints ( deck ) # q := make ([] int , n , 2 * n ) # for i := 0 ; i < n ; i ++ { # q [ i ] = i # } # index := 0 # res := make ([] int , n ) # for i := 0 ; i < n ; i ++ { # res [ q [ index ]] = deck [ i ] # index ++ # if i != n - 1 { # q = append ( q , q [ index ]) # index ++ # } # } # return res
str = strings . TrimSpace ( str ) # prefix := " STR " # if strings . HasPrefix ( str , " STR ") || strings . HasPrefix ( str , " STR ") { # prefix = str [ 0 : 1 ] # str = str [ 1 :] # } # i := strings . IndexFunc ( str , func ( r rune ) bool { # return ! unicode . IsDigit ( r ) # }) # if i > - 1 { # str = str [ 0 : i ] # } # r , _ := strconv . Atoi ( prefix + str ) # if r < math . MinInt 3 2 { # r = math . MinInt 3 2 # } else if r > math . MaxInt 3 2 { # r = math . MaxInt 3 2 # } # return r
sum := 0 # for i := 0 ; i <= 9 9 9 9 9 ; i ++ { # if isProdPandigital ( i ) { # sum += i # } # } # fmt . Println ( sum )
size := len ( position ) # rs := make ([] record , size ) # for i := range rs { # p , s := position [ i ], speed [ i ] # rs [ i ] = record { # initPos : p , # arrivalTime : float 6 4 ( target - p ) / float 6 4 ( s ), # } # } # # sort . Slice ( rs , func ( i int , j int ) bool { # return rs [ i ]. initPos > rs [ j ]. initPos # }) # # fleetTime := 0 . # res := 0 # # for _ , r := range rs { # at := r . arrivalTime # if fleetTime < at { # fleetTime = at # res ++ # } # } # # return res
if len ( loc ) == 0 { # return nil # } else if len ( loc ) == 1 { # return [] int { 1 } # } # bonuses := make ([] int , 0 , len ( loc )) # segs := segments ( loc ) # for _ , seg := range segs { # asc , run := seg . ascending , seg . run # segBonuses := make ([] int , run ) # for i := range segBonuses { # segBonuses [ i ] = i # } # if ! asc { # for i := 0 ; i < len ( segBonuses )/ 2 ; i ++ { # segBonuses [ i ], segBonuses [ len ( segBonuses )- 1 - i ] = segBonuses [ len ( segBonuses )- 1 - i ], segBonuses [ i ] # } # } # bonuses = append ( bonuses , segBonuses ...) # } # for i , x := range bonuses { # bonuses [ i ] = x + 1 # } # return bonuses
qs := [] question 1 2 3 4 { # # { # para 1 2 3 4 {" STR "}, # ans 1 2 3 4 { 0 }, # }, # # { # para 1 2 3 4 {" STR "}, # ans 1 2 3 4 { 1 }, # }, # # { # para 1 2 3 4 {" STR "}, # ans 1 2 3 4 { 2 }, # }, # # { # para 1 2 3 4 {" STR "}, # ans 1 2 3 4 { 3 }, # }, # # { # para 1 2 3 4 {" STR "}, # ans 1 2 3 4 { 3 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 3 4 , q . para 1 2 3 4 # fmt . Printf (" STR ", p , balancedString ( p . s )) # } # fmt . Printf (" STR ")
arr := randomSlice ( 0 , 2 0 , 1 0 ) # bst := newBstRecrusive () # for _ , v := range arr { # bst . Insert ( uint 3 2 ( v )) # } # sort . Ints ( arr ) # key := getRand (). Intn ( len ( arr )- 2 ) + 1 # result := int ( bst . Successor ( bst . Search ( uint 3 2 ( arr [ key ])), bst . Root ()).(* bstElement ). Key ) # if result != arr [ key + 1 ] { # t . Log ( fmt . Sprintf (" STR ", arr [ key ], arr [ key + 1 ], result )) # t . Fail () # }
var prev * ListNode # slow , fast := head , head # for fast != nil && fast . Next != nil { # fast = fast . Next . Next # next := slow . Next # slow . Next = prev # prev , slow = slow , next # } # # prev , head = slow , prev # if fast != nil { # slow = slow . Next # } # # palindrome := true # for head != nil { # if head . Val != slow . Val { # palindrome = false # } # next := head . Next # head . Next = prev # prev , head = head , next # # slow = slow . Next # } # return palindrome
t . Parallel () # # for _ , tc := range testcases { # if celeb := FindCelebrity ( tc . knows , tc . numPeople ); celeb != tc . celeb { # t . Errorf (" STR ", tc . celeb , celeb ) # } # }
dirs := strings . FieldsFunc ( path , func ( s rune ) bool { # if s == '/' { # return true # } # return false # }) # for i := 0 ; i < len ( dirs ); i ++ { # if dirs [ i ] == " STR " { # dirs = append ( dirs [: i ], dirs [ i + 1 :]...) # i -- # } else { # if dirs [ i ] == " STR " { # if i == 0 { # dirs = dirs [ 1 :] # i -- # continue # } # dirs = append ( dirs [: i - 1 ], dirs [ i + 1 :]...) # i -= 2 # } # } # } # res := " STR " # for i := 0 ; i < len ( dirs ); i ++ { # res += dirs [ i ] # if i != len ( dirs )- 1 { # res += " STR " # } # } # return res
n := len ( ratings ) # if n <= 1 { # return n # } # # left := make ([] int , n ) # right := make ([] int , n ) # left [ 0 ] = 1 # right [ n - 1 ] = 1 # # for i := 1 ; i < n ; i ++ { # if ratings [ i - 1 ] < ratings [ i ] { # left [ i ] = left [ i - 1 ] + 1 # } else { # left [ i ] = 1 # } # # if ratings [ n - i - 1 ] > ratings [ n - i ] { # right [ n - i - 1 ] = right [ n - i ] + 1 # } else { # right [ n - i - 1 ] = 1 # } # } # # res := 0 # for i := 0 ; i < n ; i ++ { # res += max ( left [ i ], right [ i ]) # } # # return res
var alen , blen int = len ( a ), len ( b ) # var plus bool # var add string # var result string # # for alen > 0 || blen > 0 { # # var ha int = threeCul ( a , alen ) # var hb int = threeCul ( b , blen ) # var hc int # if plus { # hc = 1 # } else { # hc = 0 # } # # if ha + hb + hc == 3 { # # plus = true # add = " STR " # # } else if ha + hb + hc == 2 { # # add = " STR " # plus = true # # } else { # add = strconv . Itoa ( ha + hb + hc ) # plus = false # } # # result += add # # alen -- # blen -- # # } # if plus { # result += " STR " # } # # printReslut ( result ) #
out := " STR " # if x := p 1 3 (); x != out { # t . Errorf (" STR ", x , out ) # }
tests := [...] testType { # { # in : [] int {- 2 , 0 , - 3 }, # want : [] int {- 3 , 0 , - 2 }, # }, # } # for _ , tt := range tests { # minStack , got := Constructor (), make ([] int , 0 ) # for _ , x := range tt . in { # minStack . Push ( x ) # } # got = append ( got , minStack . GetMin ()) # minStack . Pop () # got = append ( got , minStack . Top ()) # got = append ( got , minStack . GetMin ()) # if ! reflect . DeepEqual ( got , tt . want ) { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
abort := make ( chan struct {}) # go func () { # os . Stdin . Read ( make ([] byte , 1 )) # abort <- struct {}{} # }() # # fmt . Println (" STR ") # select { # case <- time . After ( 1 0 * time . Second ): # case <- abort : # fmt . Println (" STR ") # return # } # launch ()
a := " STR " # b := " STR " # # fmt . Println ( repeatedStringMatch ( a , b )) # # aa := " STR " # bb := " STR " # fmt . Println ( repeatedStringMatch ( aa , bb )) # # fmt . Println ( repeatedStringMatch 2 ( a , b )) # fmt . Println ( repeatedStringMatch 2 ( aa , bb ))
result := make ([] interface {}, len ( input )) # for to , from := range permutationPosition { # result [ to ] = input [ from ] # } # return result
for i := 0 ; i < len ( matrix ); i ++ { # for j := 1 ; j < len ( matrix [ 0 ]); j ++ { # matrix [ i ][ j ] += matrix [ i ][ j - 1 ] # } # } # sum , absMax , absMaxFound := make ([] int , len ( matrix )), 0 , false # for y 1 := 0 ; y 1 < len ( matrix [ 0 ]); y 1 ++ { # for y 2 := y 1 ; y 2 < len ( matrix [ 0 ]); y 2 ++ { # for x := 0 ; x < len ( matrix ); x ++ { # if y 1 == 0 { # sum [ x ] = matrix [ x ][ y 2 ] # } else { # sum [ x ] = matrix [ x ][ y 2 ] - matrix [ x ][ y 1 - 1 ] # } # } # curMax := kadaneK ( sum , k ) # if ! absMaxFound || curMax > absMax { # absMax = curMax # absMaxFound = true # } # } # } # return absMax
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 2 , 6 , 4 , 8 , 1 0 , 9 , 1 5 }, 5 }, # {" STR ", [] int { 1 , 2 , 3 , 3 , 3 }, 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
var d , max int # # if N &( N - 1 ) == 0 { # return 0 # } # # for ; N > 0 ; N >>= 1 { # if N & 1 == 1 { # if max == 0 { # max = 1 # } # if d > max { # max = d # } # d = 0 # } # if max > 0 { # d ++ # } # } # return max
if len ( board ) <= 0 || len ( word ) <= 0 { # return false # } # # mask := make ([][] int , len ( board )) # for i := 0 ; i < 3 ; i ++ { # mask [ i ] = make ([] int , len ( board [ i ])) # for j := 0 ; j < len ( board [ i ]); j ++ { # mask [ i ][ j ] = 0 # } # } # # for i := 0 ; i < len ( board ); i ++ { # for j := 0 ; j < len ( board [ i ]); j ++ { # wordArr := strings . Split ( word , " STR ") # # if board [ i ][ j ] == wordArr [ 0 ] { # if getExist ( board , wordArr , 0 , i , j , mask ) { # fmt . Println ( mask ) # return true # } # } # # } # } # # return false
testResult := 0 # for i := 2 ; i < 9 2 2 3 3 7 2 0 3 6 8 5 4 7 7 5 8 0 7 ; i ++ { # testResult = doTest ( i ) # if testResult == 1 { # fmt . Println (" STR ", i ) # break # } else { # i = testResult # } # }
ans := len ( nums ) # for i , num := range nums { # ans ^= i ^ num # } # return ans
qs := [] question 8 6 7 { # # { # para 8 6 7 {[][] int {{ 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 }}}, # ans 8 6 7 {[][] int {{ 1 , 4 , 7 }, { 2 , 5 , 8 }, { 3 , 6 , 9 }}}, # }, # # { # para 8 6 7 {[][] int {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}}, # ans 8 6 7 {[][] int {{ 1 , 4 }, { 2 , 5 }, { 3 , 6 }}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 6 7 , q . para 8 6 7 # fmt . Printf (" STR ", p , transpose ( p . A )) # } # fmt . Printf (" STR ")
i := 0 # j := 1 # for i < len ( A ) && j < len ( A ) { # for i < len ( A ) && A [ i ]% 2 == 0 { # i += 2 # } # # for j < len ( A ) && A [ j ]% 2 == 1 { # j += 2 # } # # if i < len ( A ) && j < len ( A ) { # A [ i ], A [ j ] = A [ j ], A [ i ] # i += 2 # j += 2 # } # } # # return A
u := newUnion ( 2 0 0 0 0 ) # for _ , s := range stones { # u . union ( s [ 0 ], s [ 1 ]+ 1 0 0 0 0 ) # } # # keeps := make ( map [ int ] int , 1 0 0 0 ) # for _ , s := range stones { # root := u . find ( s [ 0 ]) # keeps [ root ]++ # } # # return len ( stones ) - len ( keeps )
licensePlate = strings . ToLower ( licensePlate ) # chars := [ 2 6 ] int {} # for i := 0 ; i < len ( licensePlate ); i ++ { # b := licensePlate [ i ] # if ' a ' <= b && b <= ' z ' { # chars [ b -' a ']++ # } # } # # match := func ( word string ) bool { # cs := [ 2 6 ] int {} # for i := 0 ; i < len ( word ); i ++ { # b := word [ i ] # if ' a ' <= b && b <= ' z ' { # cs [ b -' a ']++ # } # } # for i , c := range cs { # if c < chars [ i ] { # return false # } # } # return true # } # # min := math . MaxInt 3 2 # res := " STR " # for _ , word := range words { # if len ( word ) > min { # continue # } # # word = strings . ToLower ( word ) # if match ( word ) && len ( word ) < min { # min = len ( word ) # res = word # } # } # return res
shadowHead := & ListNode { Next : head } # prevNode := shadowHead # for i := 1 ; i < m ; i ++ { # prevNode = prevNode . Next # head = head . Next # } # mNode := head # nNode := head . Next # for i := m ; i < n ; i ++ { # nextNNode := nNode . Next # nNode . Next = head # head = nNode # nNode = nextNNode # } # mNode . Next = nNode # prevNode . Next = head # return shadowHead . Next
return len (* h )
/* # n := len ( nums ) # s 1 , s 2 := 0 , ( 1 + n )* n / 2 # for _ , n := range nums { # s 1 += n # } # return s 2 - s 1 # */ # sum := len ( nums ) # for i , n := range nums { # sum += i - n # } # return sum
words := strings . Split ( str , " STR ") # for i := 0 ; i < len ( words )/ 2 ; i ++ { # words [ i ], words [ len ( words )- 1 - i ] = words [ len ( words )- 1 - i ], words [ i ] # } # return strings . Join ( words , " STR ")
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 4 , 3 , 2 }, 4 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := arrayPairSum ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
qs := [] question 8 8 7 { # # { # para 8 8 7 { 1 , 2 }, # ans 8 8 7 { 2 }, # }, # # { # para 8 8 7 { 2 , 6 }, # ans 8 8 7 { 3 }, # }, # # { # para 8 8 7 { 3 , 1 4 }, # ans 8 8 7 { 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 8 8 7 , q . para 8 8 7 # fmt . Printf (" STR ", p , superEggDrop ( p . k , p . n )) # } # fmt . Printf (" STR ")
var tests = [] struct { # pre [] int # post [] int # tree * TreeNode # }{ # {[] int { 1 , 2 , 4 , 5 , 3 , 6 , 7 }, [] int { 4 , 5 , 2 , 6 , 7 , 3 , 1 }, newTree ( 1 , 2 , 3 , 4 , 5 , 6 , 7 )}, # {[] int { 1 , 2 , 3 , 4 }, [] int { 3 , 4 , 2 , 1 }, newTree ( 1 , 2 , nil , 3 , 4 )}, # } # # for _ , tt := range tests { # tree := constructFromPrePost ( tt . pre , tt . post ) # if reflect . DeepEqual ( tree , tt . tree ) == false { # t . Errorf (" STR ", tt . pre , tt . post , tree , tt . tree ) # } # }
n := len ( nums ) # dp := make ([][] int , n ) # for i , num := range nums { # dp [ i ] = make ([] int , n ) # dp [ i ][ i ] = num # } # # for k := 2 ; k <= n ; k ++ { # for i := 0 ; i <= n - k ; i ++ { # j := i + k - 1 # dp [ i ][ j ] = max ( nums [ i ]- dp [ i + 1 ][ j ], nums [ j ]- dp [ i ][ j - 1 ]) # } # } # return dp [ 0 ][ n - 1 ] >= 0
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 2 , 5 , 3 , 4 , 1 }, 3 }, # {" STR ", [] int { 2 , 1 , 4 }, 0 }, # {" STR ", [] int { 1 , 2 , 3 , 4 }, 4 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if len ( queue . array ) == 0 { # return 0 # } # copied := MyQueue {} # for len ( queue . array ) != 1 { # copied . array = append ( copied . array , queue . delet ()) # } # temp := queue . delet () # for len ( copied . array ) != 0 { # queue . array = append ( queue . array , copied . delet ()) # } # return temp
t . Parallel () # for _ , tc := range testcases { # if result := ConvertRomanNumeralToInteger ( tc . roman ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
if 0 == len ( pre ) { # return nil # } # if 1 == len ( pre ) { # return & TreeNode { Val : pre [ 0 ]} # } # # root := & TreeNode { Val : pre [ 0 ]} # pre = pre [ 1 :] # post = post [: len ( post )- 1 ] # i := 0 # for i < len ( post ) { # if pre [ 0 ] == post [ i ] { # break # } # i ++ # } # root . Left = constructFromPrePost ( pre [: i + 1 ], post [: i + 1 ]) # root . Right = constructFromPrePost ( pre [ i + 1 :], post [ i + 1 :]) # return root
cases := [] struct { # name string # inputs [] int # expect * ListNode # } { # { # " STR ", # [] int { 1 , 2 , 3 , 4 }, # UnmarshalListBySlice ([] int { 1 , 4 , 2 , 3 }), # }, # { # " STR ", # [] int { 1 , 2 , 3 , 4 , 5 }, # UnmarshalListBySlice ([] int { 1 , 5 , 2 , 4 , 3 }), # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # linkedList := UnmarshalListBySlice ( c . inputs ) # Solution ( linkedList ) # if ! isEqual ( linkedList , c . expect ) { # PrintList ( linkedList ) # PrintList ( c . expect ) # t . Fatalf (" STR ", c . expect , linkedList , c . inputs ) # } # }) # }
var nums [] int # var ret bool # var k int # # nums = [] int { 1 , 2 , 3 , 1 } # k = 3 # ret = true # if ret != containsNearbyDuplicate ( nums , k ) { # t . Fatalf (" STR ", ret ) # } # # nums = [] int { 1 , 0 , 1 , 1 } # k = 1 # ret = true # if ret != containsNearbyDuplicate ( nums , k ) { # t . Fatalf (" STR ", ret ) # } # # nums = [] int { 1 , 2 , 3 , 1 , 2 , 3 } # k = 2 # ret = false # if ret != containsNearbyDuplicate ( nums , k ) { # t . Fatalf (" STR ", ret ) # }
if x == 0 { # return 0 # } # var ret float 6 4 # if n < 0 { # ret = 1 / myPow ( x , - n ) # } else if n == 0 { # ret = 1 # } else if n == 1 { # ret = x # } else if n % 2 == 0 { # ret = myPow ( x , n / 2 ) # ret *= ret # } else { # ret = myPow ( x , n / 2 ) # ret *= ret * x # } # return ret
if nil == root { # return true # } # ok := preOrderTraversal ( root . Left , preVal ) # if ! ok { # return false # } # if root . Val <= * preVal { # return false # } # * preVal = root . Val # return preOrderTraversal ( root . Right , preVal )
if len ( its ) <= 1 { # return its # } # # sort . Slice ( its , func ( i int , j int ) bool { # return its [ i ]. Start < its [ j ]. Start # }) # # res := make ([] Interval , 0 , len ( its )) # # temp := its [ 0 ] # for i := 1 ; i < len ( its ); i ++ { # if its [ i ]. Start <= temp . End { # temp . End = max ( temp . End , its [ i ]. End ) # } else { # res = append ( res , temp ) # temp = its [ i ] # } # } # res = append ( res , temp ) # # return res
cases := [] struct { # name string # inputs bool # expect bool # }{ # {" STR ", true , true }, # {" STR ", true , true }, # {" STR ", false , false }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if queryGlass > queryRow / 2 { # queryGlass = queryRow - queryGlass # } # # row := [ 1 0 0 ] float 6 4 { 0 : float 6 4 ( poured )} # i := 0 # for { # nextRow := [ 1 0 0 ] float 6 4 {} # for j := max ( i + queryGlass - queryRow , 0 ); j <= queryGlass ; j ++ { # if row [ j ] > 1 { # nextRow [ j ] += ( row [ j ] - 1 ) / 2 # nextRow [ j + 1 ] += ( row [ j ] - 1 ) / 2 # row [ j ] = 1 # } # } # # if i == queryRow { # return row [ queryGlass ] # } # # row = nextRow # i ++ # }
for i := 0 ; i < b . N ; i ++ { # Add ( 1 , 1 ) # }
if " STR " == needle { # return 0 # } # # for i := 0 ; i <= len ( haystack )- len ( needle ); i ++ { # for j := 0 ; j < len ( needle ) && haystack [ i + j ] == needle [ j ]; j ++ { # if j == len ( needle )- 1 { # return i # } # } # } # return - 1
endIndex := 0 # c := 0 # for i := 0 ; i <= len ( s )- 3 ; i ++ { # now := string ( s [ i ]) # next := string ( s [ i + 1 ]) # end := string ( s [ i + 2 ]) # if now == next && end != now { # if c == 0 { # newStr = newStr + s [ 0 : i ] # } # if c > 0 { # newStr = newStr + s [ endIndex : i ] # } # endIndex = i + 3 # c ++ # res = append ( res , [] string { now , next , end }) # } # } # newStr = newStr + s [ endIndex :] # return res , newStr
res , left , right := 0 , 0 , 0 # for left < len ( A ) { # if right < len ( A ) && (( A [ right ] == 0 && K > 0 ) || A [ right ] == 1 ) { # if A [ right ] == 0 { # K -- # } # right ++ # } else { # if K == 0 || ( right == len ( A ) && K > 0 ) { # res = max ( res , right - left ) # } # if A [ left ] == 0 { # K ++ # } # left ++ # } # } # return res
if n < 3 { # return 0 # } # primes := make ([] bool , n ) # count := 1 # for i := 3 ; i < n ; i += 2 { # if ! primes [ i ] { # count ++ # for j := i * i ; j < n ; j += i + i { # primes [ j ] = true # } # } # } # return count
sum := 0 # for n := 2 ; n < 5 0 0 0 0 0 ; n ++ { # base := 1 # digitsum := 0 # for base < n { # num := n / base % 1 0 # digitsum += int ( math . Pow ( float 6 4 ( num ), float 6 4 ( power ))) # base *= 1 0 # } # if digitsum == n { # sum += n # } # } # return sum
cases := [] struct { # name string # inputs int # expect int # }{ # {" STR ", 2 , 2 }, # {" STR ", 3 , 3 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := climbStairs 1 ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
done := false # # tmp := 0 # maxChild := 0 # # for ( i * 2 + 1 < arrLen ) && (! done ) { # if i * 2 + 1 == arrLen - 1 { # maxChild = i * 2 + 1 # } else if ( arr [ i * 2 + 1 ] > arr [ i * 2 + 2 ]) { # maxChild = i * 2 + 1 # } else { # maxChild = i * 2 + 2 # } # # if arr [ i ] < arr [ maxChild ] { # tmp = arr [ i ] # arr [ i ] = arr [ maxChild ] # arr [ maxChild ] = tmp # i = maxChild # } else { # done = true # } # } # # return arr
switch l . peek () { # case eof : # l . emit ( itemEOF ) # return nil # case " STR ": # return byteSuffixRange ( l ) # } # return firstByte ( l )
n := len ( nums ) # res := make ([] float 6 4 , n - k + 1 ) # w := newWindow ( nums , k ) # # for i := 0 ; i + k < n ; i ++ { # res [ i ] = w . median () # w . update ( i , i + k , nums [ i + k ]) # } # res [ n - k ] = w . median () # return res
m := len ( word 1 ) # n := len ( word 2 ) # cost := 0 # # dp := make ([][] int , m + 1 ) # for i := range dp { # dp [ i ] = make ([] int , n + 1 ) # } # # for i := 0 ; i <= m ; i ++ { # dp [ i ][ 0 ] = i # } # for j := 0 ; j <= n ; j ++ { # dp [ 0 ][ j ] = j # } # # for i := 1 ; i <= m ; i ++ { # for j := 1 ; j <= n ; j ++ { # dp [ i ][ j ] = min ( dp [ i - 1 ][ j ]+ 1 , dp [ i ][ j - 1 ]+ 1 ) # # if word 1 [ i - 1 ] == word 2 [ j - 1 ] { # cost = 0 # } else { # cost = 1 # } # # dp [ i ][ j ] = min ( dp [ i ][ j ], dp [ i - 1 ][ j - 1 ]+ cost ) # } # } # # return dp [ m ][ n ]
if root == nil { # return nil # } # s := []* TreeNode { root } # res := [][] int {} # for len ( s ) != 0 { # tmp := []* TreeNode {} # l := [] int {} # for _ , node := range s { # l = append ( l , node . Val ) # if node . Left != nil { # tmp = append ( tmp , node . Left ) # } # if node . Right != nil { # tmp = append ( tmp , node . Right ) # } # } # res = append ( res , l ) # s = tmp # } # return res
for i := 1 0 ; i >= 0 ; i -- { # var aPhone [] phoneDataList # for _ , v := range arr { # bitNumStr := v [ i : i + 1 ] # bitNum , _ := strconv . Atoi ( bitNumStr ) # item := phoneDataList { # PhoneNumStr : v , # BitNum : bitNum , # } # aPhone = append ( aPhone , item ) # } # sort . Slice ( aPhone , func ( i , j int ) bool { # if aPhone [ i ]. BitNum < aPhone [ j ]. BitNum { # return true # } # return false # }) # var aPhoneNum [] string # for _ , v := range aPhone { # aPhoneNum = append ( aPhoneNum , v . PhoneNumStr ) # } # copy ( arr , aPhoneNum ) # } # return
if root == nil { # return nil # } # # ret := append ([] int {}, root . Val ) # if left := preorderTraversal ( root . Left ); left != nil { # ret = append ( ret , left ...) # } # if right := preorderTraversal ( root . Right ); right != nil { # ret = append ( ret , right ...) # } # # return ret
if len ( ratings ) == 0 { # return 0 # } # reduceLength , growLength := 0 , 1 # # pre := 1 # ret := 1 # for i := 1 ; i < len ( ratings ); i ++ { # if ratings [ i ] < ratings [ i - 1 ] { # reduceLength ++ # if reduceLength >= pre { # ret ++ # } # ret += reduceLength # growLength = 1 # } else { # cur := 1 # if ratings [ i ] > ratings [ i - 1 ] { # cur = growLength + 1 # } # growLength = cur # ret += cur # reduceLength = 0 # pre = cur # } # } # return ret
s := Solution 4 9 7 { # rects : rects , # arr : make ([] int , len ( rects )), # } # # for i := 0 ; i < len ( rects ); i ++ { # area := ( rects [ i ][ 2 ] - rects [ i ][ 0 ] + 1 ) * ( rects [ i ][ 3 ] - rects [ i ][ 1 ] + 1 ) # if area < 0 { # area = - area # } # if i == 0 { # s . arr [ 0 ] = area # } else { # s . arr [ i ] = s . arr [ i - 1 ] + area # } # } # return s
searchValue := 1 0 0 # arr := [] int { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 0 } # fmt . Println ( arr ) # # found := search ( arr , searchValue ) # # if found == - 1 { # fmt . Println (" STR ") # } else { # fmt . Printf (" STR ", found ) # } #
arrSize := rand . Intn ( 1 0 0 ) + 5 0 # arrSize 1 := rand . Intn ( arrSize ) # arr := make ([] int , arrSize , arrSize ) # for i := range arr { # arr [ i ] = rand . Intn ( 1 0 0 ) # } # sortedArr := make ([] int , 0 , 0 ) # h 1 , h 2 := NewFibHeap (), NewFibHeap () # for i , v := range arr { # if i < arrSize 1 { # h 1 . Insert ( v , v ) # } else { # h 2 . Insert ( v , v ) # } # } # h 1 = h 1 . Union ( h 2 ) # h 2 = nil # for h 1 . n > 0 { # min := h 1 . ExtractMin () # sortedArr = append ( sortedArr , min . Key .( int )) # } # sort . Sort ( sort . Reverse ( sort . IntSlice ( arr ))) # if ! reflect . DeepEqual ( sortedArr , arr ) { # t . Log ( fmt . Sprintf (" STR ", arr ) + fmt . Sprintf (" STR ", sortedArr )) # t . Fail () # }
n := len ( nums ) # # getIndex := func ( i int ) int { # index := i + nums [ i ] # if index >= 0 { # return index % n # } # return n + ( index % n ) # } # # for i , num := range nums { # if num == 0 { # continue # } # j , k := i , getIndex ( i ) # for nums [ k ]* num > 0 && nums [ getIndex ( k )]* num > 0 { # if j == k { # if j == getIndex ( j ) { # break # } # return true # } # j , k = getIndex ( j ), getIndex ( getIndex ( k )) # } # j = i # for nums [ j ]* num > 0 { # next := getIndex ( j ) # nums [ j ] = 0 # j = next # } # } # return false
cases := [] struct { # name string # input 1 string # input 2 string # expect bool # }{ # {" STR ", " STR ", " STR ", false }, # {" STR ", " STR ", " STR ", false }, # {" STR ", " STR ", " STR ", true }, # {" STR ", " STR ", " STR ", true }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := canConstruct ( c . input 1 , c . input 2 ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . input 1 , c . input 2 ) # } # }) # }
qs := [] question 4 7 4 { # # { # para 4 7 4 {[] string {" STR ", " STR ", " STR ", " STR ", " STR "}, 5 , 3 }, # ans 4 7 4 { 4 }, # }, # # { # para 4 7 4 {[] string {" STR ", " STR ", " STR "}, 1 , 1 }, # ans 4 7 4 { 2 }, # }, # # { # para 4 7 4 {[] string {}, 0 , 0 }, # ans 4 7 4 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 4 7 4 , q . para 4 7 4 # fmt . Printf (" STR ", p , findMaxForm ( p . strs , p . m , p . n )) # } # fmt . Printf (" STR ")
n := NewNode ( val ) # cl . Size ++ # if cl . Head == nil { # n . Prev = n # n . Next = n # cl . Head = n # } else { # n . Prev = cl . Head . Prev # n . Next = cl . Head # cl . Head . Prev . Next = n # cl . Head . Prev = n # }
for i := 0 ; i < len ( matrix ); i ++ { # x , y := i , 0 # for j := 1 ; true ; j ++ { # x , y = x + 1 , y + 1 # if x < 0 || y < 0 || x >= len ( matrix ) || y >= len ( matrix [ 0 ]) { # break # } # # if matrix [ x ][ y ] != matrix [ x - 1 ][ y - 1 ] { # return false # } # } # } # for i := 1 ; i < len ( matrix [ 0 ]); i ++ { # x , y := 0 , i # for j := 1 ; true ; j ++ { # x , y = x + 1 , y + 1 # if x < 0 || y < 0 || x >= len ( matrix ) || y >= len ( matrix [ 0 ]) { # break # } # if matrix [ x ][ y ] != matrix [ x - 1 ][ y - 1 ] { # return false # } # } # } # return true
if 0 == len ( preorder ) { # return nil # } # # root := preorder [ 0 ] # i := 0 # for ; i < len ( inorder ); i ++ { # if root == inorder [ i ] { # break # } # } # # return & TreeNode { # Val : root , # Left : buildTree ( preorder [ 1 : i + 1 ], inorder [: i ]), # Right : buildTree ( preorder [ i + 1 :], inorder [ i + 1 :]), # }
start , end := 0 , len ( nums )- 1 # var mid int # for start <= end { # mid = ( start + end + 1 ) / 2 # if nums [ mid ] == target { # return mid # } # if nums [ mid ] < target { # start = mid + 1 # } else { # end = mid - 1 # } # } # return start
cases := [] struct { # name string # inputs int # expect bool # }{ # {" STR ", 1 9 , true }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := isHappy 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
qs := [] question 1 3 0 0 { # # { # para 1 3 0 0 {[] int { 4 , 9 , 3 }, 1 0 }, # ans 1 3 0 0 { 3 }, # }, # # { # para 1 3 0 0 {[] int { 2 , 3 , 5 }, 1 0 }, # ans 1 3 0 0 { 5 }, # }, # # { # para 1 3 0 0 {[] int { 6 0 8 6 4 , 2 5 1 7 6 , 2 7 2 4 9 , 2 1 2 9 6 , 2 0 2 0 4 }, 5 6 8 0 3 }, # ans 1 3 0 0 { 1 1 3 6 1 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 3 0 0 , q . para 1 3 0 0 # fmt . Printf (" STR ", p , findBestValue ( p . arr , p . target )) # } # fmt . Printf (" STR ")
c . Fail () # # c . finished = true # c . Error (" STR ")
n := len ( s ) # dp := make ([][] int , n ) # for i := 0 ; i < n ; i ++ { # dp [ i ] = make ([] int , n ) # dp [ i ][ i ] = 1 # } # # for k := 2 ; k <= n ; k ++ { # for i := 0 ; i + k - 1 < n ; i ++ { # j := i + k - 1 # if s [ i ] == s [ j ] { # dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] + 2 # } else { # dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j - 1 ]) # } # } # } # return dp [ 0 ][ n - 1 ]
n := len ( heights ) # if heights == nil || n == 0 { # return 0 # } # # lessFromLeft := make ([] int , n ) # lessFromRight := make ([] int , n ) # lessFromLeft [ 0 ] = - 1 # lessFromRight [ n - 1 ] = n # # for i := 1 ; i < n ; i ++ { # p := i - 1 # for p >= 0 && heights [ p ] >= heights [ i ] { # p = lessFromLeft [ p ] # } # lessFromLeft [ i ] = p # } # # for i := n - 2 ; i >= 0 ; i -- { # p := i + 1 # for p < n && heights [ p ] >= heights [ i ] { # p = lessFromRight [ p ] # } # lessFromRight [ i ] = p # } # # max := 0 # for i := 0 ; i < n ; i ++ { # tmp := heights [ i ] * ( lessFromRight [ i ] - lessFromLeft [ i ] - 1 ) # if tmp > max { # max = tmp # } # } # return max
t := [] int {} # for _ , n := range nums { # j := sort . Search ( len ( t ), func ( i int ) bool { # return t [ i ] >= n # }) # if j == len ( t ) { # t = append ( t , n ) # } else { # t [ j ] = n # } # } # return len ( t )
err := seek ( r , fSize , io . SeekStart , fSize ) # if err != nil { # return err # } # # return read ( r , 1 , nil )
tests := [...] testType { # { # s : " STR ", # p : " STR ", # want : false , # }, # { # s : " STR ", # p : " STR ", # want : true , # }, # { # s : " STR ", # p : " STR ", # want : true , # }, # { # s : " STR ", # p : " STR ", # want : true , # }, # { # s : " STR ", # p : " STR ", # want : false , # }, # { # s : " STR ", # p : " STR ", # want : false , # }, # } # for _ , tt := range tests { # got := isMatch ( tt . s , tt . p ) # if got != tt . want { # t . Fatalf (" STR ", tt . s , tt . p , got , tt . want ) # } # }
sLen , wordsLen := len ( s ), len ( words ) # if sLen == 0 || wordsLen == 0 { # return nil # } # wLen := len ( words [ 0 ]) # if sLen < wordsLen * wLen { # return nil # } # # count := map [ string ] int {} # for _ , w := range words { # count [ w ]++ # } # indexes := [] int {} # for i := 0 ; i < sLen - wordsLen * wLen + 1 ; i ++ { # seen := map [ string ] int {} # j := 0 # for j < wordsLen { # word := s [ i + j * wLen : i +( j + 1 )* wLen ] # if _ , ok := count [ word ]; ok { # seen [ word ]++ # if seen [ word ] > count [ word ] { # break # } # } else { # break # } # j ++ # } # if j == wordsLen { # indexes = append ( indexes , i ) # } # } # return indexes
n := len ( nums ) # if n == 0 { # return nil # } # head := & ListNode { Val : nums [ 0 ], Next : nil } # cur := head # for i := 1 ; i < n ; i ++ { # newNode := & ListNode { Val : nums [ i ], Next : nil } # cur . Next = newNode # cur = newNode # } # return head
preSum := make ([] int , len ( arr )+ 1 ) # preSum [ 0 ] = 0 # for i := 0 ; i <= len ( arr )- 1 ; i ++ { # preSum [ i + 1 ] = arr [ i ] + preSum [ i ] # } # for i := 0 ; i <= len ( arr ); i ++ { # for j := 0 ; j < i ; j ++ { # if preSum [ i ]- preSum [ j ] == targetSum { # fmt . Println (" STR ", j , i , arr [ j : i ]) # c ++ # } # } # } # return
var i , j , t , n int # for j < len ( nums ) { # for t < s && j < len ( nums ) { # t += nums [ j ] # j ++ # } # for t >= s && i < len ( nums ) { # if n == 0 || n > j - i { # n = j - i # } # t -= nums [ i ] # i ++ # } # } # return n
if head == nil { # return nil # } # # tmp := head # for tmp . Next != nil { # if tmp . Val == tmp . Next . Val { # tmp . Next = tmp . Next . Next # } else { # tmp = tmp . Next # } # } # return head
cumm := make ( map [ int ] int ) # for _ , row := range bricks { # last := 0 # for _ , brick := range row { # last += brick # cumm [ last ]++ # } # delete ( cumm , last ) # } # var most int # for _ , count := range cumm { # if count > most { # most = count # } # } # return len ( bricks ) - most
ans := points [ 0 ][ 0 ] * ( points [ 1 ][ 1 ] - points [ 2 ][ 1 ]) # ans += points [ 1 ][ 0 ] * ( points [ 2 ][ 1 ] - points [ 0 ][ 1 ]) # ans += points [ 2 ][ 0 ] * ( points [ 0 ][ 1 ] - points [ 1 ][ 1 ]) # return ans != 0
b := inSlice {} # for _ , v := range a { # b = append ( b , v ) # } # return b
const P = 1 0 # N := int ( 1 e 6 ) # if testing . Short () { # N /= 1 0 0 # } # var p Pool # done := make ( chan bool ) # for i := 0 ; i < P ; i ++ { # go func () { # var v interface {} = 0 # for j := 0 ; j < N ; j ++ { # if v == nil { # v = 0 # } # p . Put ( v ) # v = p . Get () # if v != nil && v .( int ) != 0 { # t . Fatalf (" STR ", v ) # } # } # done <- true # }() # } # for i := 0 ; i < P ; i ++ { # <- done # }
for i := 1 ; i < len ( houses ); i ++ { # for j := range houses [ i ] { # houses [ i ][ j ] += minimum ( houses [ i - 1 ], j ) # } # } # return minimum ( houses [ len ( houses )- 1 ], - 1 )
p := 0 # for i := 0 ; i < len ( nums ); i ++ { # if nums [ i ] != 0 { # nums [ p ] = nums [ i ] # if p != i { # nums [ i ] = 0 # } # p ++ # } # }
m := make ( map [ rune ] int ) # start , max := - 1 , 0 # # for k , v := range s { # if last , ok := m [ v ]; ok && last > start { # start = last # } # m [ v ] = k # if k - start > max { # max = k - start # } # } # return max
if num == 0 { # return " STR " # } # if num < 0 { # num += 1 << 3 2 # } # mp := map [ int ] string { # 0 : " STR ", 1 : " STR ", 2 : " STR ", 3 : " STR ", 4 : " STR ", 5 : " STR ", 6 : " STR ", 7 : " STR ", 8 : " STR ", 9 : " STR ", # 1 0 : " STR ", 1 1 : " STR ", 1 2 : " STR ", 1 3 : " STR ", 1 4 : " STR ", 1 5 : " STR ", # } # var bitArr [] string # for num > 0 { # bitArr = append ( bitArr , mp [ num % 1 6 ]) # num /= 1 6 # } # str := " STR " # for i := len ( bitArr ) - 1 ; i >= 0 ; i -- { # str += bitArr [ i ] # } # return str
m , n := len ( M ), len ( M [ 0 ]) # # S := [ 3 0 1 ][ 3 0 1 ] int {} # for i := 1 ; i <= m ; i ++ { # for j := 1 ; j <= n ; j ++ { # S [ i ][ j ] = S [ i ][ j - 1 ] + M [ i - 1 ][ j - 1 ] # } # } # # res := 0 # # for y 1 := 0 ; y 1 < n ; y 1 ++ { # for y 2 := y 1 + 1 ; y 2 <= n ; y 2 ++ { # count := make ( map [ int ] int , m ) # sum := 0 # for x := 0 ; x <= m ; x ++ { # sum += S [ x ][ y 2 ] - S [ x ][ y 1 ] # res += count [ sum - target ] # count [ sum ]++ # } # } # } # # return res
z := int ( len ( s ) / 2 ) # for i := 0 ; i < z ; i ++ { # if s [ i ] != s [ len ( s )- i - 1 ] { # return false # } # } # # return true
maxPriority = MaxInt ( 0 , maxPriority ) # waitLimit = MaxInt ( 0 , waitLimit ) # pq := new ( PriorityQueue ) # pq . max = maxPriority # pq . waitLimit = waitLimit # pq . queues = make ([]* Queue , maxPriority + 1 ) # for i := range pq . queues { # pq . queues [ i ] = NewQueue () # } # pq . waiting = make ([] int , maxPriority + 1 ) # return pq
text := strings . ToLower ( paragraph ) # # reg := regexp . MustCompile (" STR ") # result := reg . FindAllString ( text , - 1 ) # # ans := make ( map [ string ] int , 0 ) # # for _ , word := range result { # if ! isContain ( banned , word ) { # ans [ word ]++ # } # } # # maxTime := 0 # var ansString string # for k , v := range ans { # if v > maxTime { # maxTime = v # ansString = k # } # } # return ansString
o := make ( map [ string ] int , len ( words )* 5 ) # for k := 0 ; k < len ( words ); k ++ { # for i := 0 ; i <= 1 0 && i <= len ( words [ k ]); i ++ { # for j := len ( words [ k ]); 0 <= j && len ( words [ k ])- 1 0 <= j ; j -- { # pps := words [ k ][: i ] + " STR " + words [ k ][ j :] # o [ pps ] = k # } # } # } # return WordFilter { ords : o }
return a % 2 == 0
size := len ( A ) # # i , j := 0 , size - 1 # minAbs := abs ( A [ 0 ]) # for i <= j { # minAbs = min ( minAbs , abs ( A [ i ])) # if A [ i ] >= 0 { # A [ i ], A [ j ] = A [ j ], A [ i ] # j -- # continue # } # i ++ # } # # negatives := A [: j + 1 ] # negSize := j + 1 # # sum := 0 # if K >= negSize { # if ( K - negSize )& 1 == 1 { # sum -= minAbs * 2 # } # } else { # sort . Ints ( negatives ) # } # # index := min ( K , negSize ) # for i := 0 ; i < index ; i ++ { # sum -= A [ i ] # } # for i := index ; i < size ; i ++ { # sum += A [ i ] # } # # return sum
if len ( s ) == i { # return 1 # } # if ' 0 ' == s [ i ] { # return 0 # } # if v , ok := table [ i ]; ok { # return v # } # num := decode ( s , i + 1 , table ) # if i < len ( s )- 1 { # if ' 1 ' == s [ i ] { # num += decode ( s , i + 2 , table ) # } else if ' 2 ' == s [ i ] && s [ i + 1 ] <= ' 6 ' { # num += decode ( s , i + 2 , table ) # } # } # table [ i ] = num # return num
for _ , test := range xorTestData { # t . Run ( test . description , func ( t * testing . T ) { # decrypted := Decrypt ( byte ( test . key ), [] byte ( test . encrypted )) # # if ! reflect . DeepEqual ( string ( decrypted ), test . input ) { # t . Logf (" STR ", test . description ) # t . Fatalf (" STR ", test . input , string ( decrypted )) # } # }) # }
fmap := make ([][][] int , n ) # for i := range flights { # src := flights [ i ][ 0 ] # fmap [ src ] = append ( fmap [ src ], flights [ i ][ 1 :]) # } # # pq := make ( PQ , 0 , n ) # heap . Push (& pq , & city { # price : 0 , # id : src , # countdown : k + 1 , # }) # # for len ( pq ) > 0 { # ct , _ := heap . Pop (& pq ).(* city ) # # if ct . id == dst { # return ct . price # } # # if ct . countdown > 0 { # nexts := fmap [ ct . id ] # for _ , n := range nexts { # heap . Push (& pq , & city { # id : n [ 0 ], # price : ct . price + n [ 1 ], # countdown : ct . countdown - 1 , # }) # } # } # } # # return - 1
freq := make ( map [ int ] int ) # need := make ( map [ int ] int ) # for _ , v := range arr { # freq [ v ]++ # } # for _ , v := range arr { # if freq [ v ] == 0 { # continue # } # if need [ v ] > 0 { # freq [ v ]-- # need [ v ]-- # need [ v + 1 ]++ # } else if freq [ v ] > 0 && freq [ v + 1 ] > 0 && freq [ v + 2 ] > 0 { # freq [ v ]-- # freq [ v + 1 ]-- # freq [ v + 2 ]-- # need [ v + 3 ]++ # } else { # return false # } # } # return true
lru := Constructor ( 2 ) # lru . Put ( 1 , 1 ) # lru . Put ( 2 , 2 ) # fmt . Println ( lru . Get ( 1 )) # lru . Put ( 3 , 3 ) # fmt . Println ( lru . Get ( 2 )) # lru . Put ( 4 , 4 ) # fmt . Println ( lru . Get ( 1 )) # fmt . Println ( lru . Get ( 3 )) # fmt . Println ( lru . Get ( 4 ))
m := make ( map [ int ] bool , len ( nums )) # for _ , n := range nums { # if m [ n ] { # return true # } # m [ n ] = true # } # # return false
sub := len ( nums ) - 1 # sum := 0 # for _ , n := range nums { # sum += n # for sum > 0 && sub > 0 { # sum -= sub # sub -- # } # } # return sum
str := [] string {" STR ", " STR ", " STR "} # dic := make ( map [ byte ] int ) # for i := 0 ; i < len ( str ); i ++ { # for j := 0 ; j < len ( str [ i ]); j ++ { # dic [ str [ i ][ j ]] = i # } # } # ret := make ([] string , 0 , len ( words )) # for _ , word := range words { # flag := true # for i := 0 ; flag && i < len ( word )- 1 ; i ++ { # if dic [ word [ i ]] != dic [ word [ i + 1 ]] { # flag = false # } # } # if flag { # ret = append ( ret , word ) # } # } # return ret
flag , res := false , 0 # for i := 0 ; i < 4 ; i ++ { # for j := 0 ; j < 4 ; j ++ { # if i == j { # continue # } # for k := 0 ; k < 4 ; k ++ { # if i == k || j == k { # continue # } # l := 6 - i - j - k # hour := A [ i ]* 1 0 + A [ j ] # min := A [ k ]* 1 0 + A [ l ] # if hour < 2 4 && min < 6 0 { # if hour * 6 0 + min >= res { # res = hour * 6 0 + min # flag = true # } # } # } # } # } # if flag { # return fmt . Sprintf (" STR ", res / 6 0 , res % 6 0 ) # } else { # return " STR " # }
if num == 0 { # return " STR " # } # # res := " STR " # for i := 0 ; num > 0 ; i ++ { # if num % 1 0 0 0 != 0 { # res = lessK ( num % 1 0 0 0 ) + thousands [ i ] + " STR " + res # } # num /= 1 0 0 0 # } # return strings . TrimRight ( res , " STR ")
return len ( in )
if root == nil { # return nil # } # # if root . Left == nil && root . Right == nil { # return [] int { root . Val } # } # # res := inorderTraversal ( root . Left ) # res = append ( res , root . Val ) # res = append ( res , inorderTraversal ( root . Right )...) # return res
str 1 := strings . Builder {} # for _ , s := range word 1 { # str 1 . WriteString ( s ) # } # str 2 := strings . Builder {} # for _ , s := range word 2 { # str 2 . WriteString ( s ) # } # return str 1 . String () == str 2 . String ()
node . prev . next = node . next # node . next . prev = node . prev
g , start := buildAdjacencyMatrix ( weights ) # if len ( g ) == 0 { # return 0 # } # for n := range g { # start = n # break # } # newStart , _ := farthestNode ( start , g ) # _ , dist := farthestNode ( newStart , g ) # return dist
cases := [] struct { # name string # inputs string # expect string # }{ # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # {" STR ", " STR ", " STR "}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := longestPalindrome 3 ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
sums := make ([] int , len ( nums )+ 1 ) # for i , num := range nums { # sums [ i + 1 ] = sums [ i ] + num # } # # clone := make ([] int , len ( sums )) # return helper 3 2 7 ( sums , clone , 0 , len ( sums )- 1 , lower , upper )
f , _ := ReadFile (" STR ") # fmt . Println (" STR ", f ) # fmt . Println ( string ( f ))
position := generateHash ( key ) # if table . data [ position ] == nil { # table . data [ position ] = & TableItem { key : key , data : i } # return # } # current := table . data [ position ] # for current . next != nil { # current = current . next # } # current . next = & TableItem { key : key , data : i }
dp := [ 1 0 1 ][ 1 0 1 ] int {} # # for n := K + 1 ; n <= N ; n ++ { # dp [ n ][ n ] = factorial ( n ) # for l := n + 1 ; l <= L ; l ++ { # count := dp [ n - 1 ][ l - 1 ]* n + dp [ n ][ l - 1 ]*( n - K ) # dp [ n ][ l ] = count % mod # } # } # return dp [ N ][ L ]
prevRun , curRun , ans := 0 , 1 , 0 # for i := 1 ; i < len ( s ); i ++ { # if s [ i ] == s [ i - 1 ] { # curRun ++ # } else { # prevRun = curRun # curRun = 1 # } # if prevRun >= curRun { # ans ++ # } # } # return ans
hash := make ( map [ int ] int ) # for _ , val := range arr 1 { # hash [ val ]++ # } # res , others := make ([] int , 0 ), make ([] int , 0 ) # for _ , val := range arr 2 { # if n , ok := hash [ val ]; ok { # for i := 0 ; i < n ; i ++ { # res = append ( res , val ) # } # } # delete ( hash , val ) # } # for k , v := range hash { # for i := 0 ; i < v ; i ++ { # others = append ( others , k ) # } # } # sort . Ints ( others ) # res = append ( res , others ...) # return res
if root == nil { # return false # } # if root . Left == nil && root . Right == nil { # return root . Val == sum # } # return hasPathSum ( root . Left , sum - root . Val ) || hasPathSum ( root . Right , sum - root . Val )
digits := map [ int ] bool { # 1 : false , # 2 : false , # 3 : false , # 4 : false , # 5 : false , # 6 : false , # 7 : false , # 8 : false , # 9 : false , # } # pandigital := make ( map [ int ] bool ) # # findAllPandigitals (" STR ", digits , pandigital ) # # sum := 0 # fmt . Println ( len ( pandigital )) # for key , _ := range ( pandigital ) { # sum += key # } # # return sum
var lastIndexOf [ 2 6 ] int # for i , v := range S { # lastIndexOf [ v -' a '] = i # } # # var arr [] int # for start , end := 0 , 0 ; start < len ( S ); start = end + 1 { # end = lastIndexOf [ S [ start ]-' a '] # for i := start ; i < end ; i ++ { # if end < lastIndexOf [ S [ i ]-' a '] { # end = lastIndexOf [ S [ i ]-' a '] # } # } # arr = append ( arr , end - start + 1 ) # } # return arr
int 1 , nonRepeating 1 , repeating 1 := normalizeRational ( S ) # int 2 , nonRepeating 2 , repeating 2 := normalizeRational ( T ) # return int 1 == int 2 && nonRepeating 1 == nonRepeating 2 && repeating 1 == repeating 2
a , l := 0 , 0 # # for i , _ := range s { # if s [ i ] == " STR " { # a ++ # } # if s [ i ] == " STR " { # l ++ # } else { # l = 0 # } # # if a > 1 || l > 2 { # return false # } # # } # # return true
newnumerator = num # newdenominator = denom # s := strconv . Itoa ( num ) # slist := strings . Split ( s , " STR ") # t := strconv . Itoa ( denom ) # tlist := strings . Split ( t , " STR ") # # if slist [ 1 ] == " STR " { # return # } # # if slist [ 0 ] == tlist [ 0 ] { # newnumerator , _ = strconv . Atoi ( slist [ 1 ]) # newdenominator , _ = strconv . Atoi ( tlist [ 1 ]) # # } else if slist [ 0 ] == tlist [ 1 ] { # newnumerator , _ = strconv . Atoi ( slist [ 1 ]) # newdenominator , _ = strconv . Atoi ( tlist [ 0 ]) # } else if slist [ 1 ] == tlist [ 0 ] { # newnumerator , _ = strconv . Atoi ( slist [ 0 ]) # newdenominator , _ = strconv . Atoi ( tlist [ 1 ]) # } else if slist [ 1 ] == tlist [ 1 ] { # newnumerator , _ = strconv . Atoi ( slist [ 0 ]) # newdenominator , _ = strconv . Atoi ( tlist [ 0 ]) # # } # # return
for { # select { # case user := <- cs . Join : # cs . Users [ user . Name ] = user # go func () { # cs . Input <- Message { # Username : " STR ", # Text : fmt . Sprintf (" STR ", user . Name ), # } # }() # case user := <- cs . Leave : # delete ( cs . Users , user . Name ) # go func () { # cs . Input <- Message { # Username : " STR ", # Text : fmt . Sprintf (" STR ", user . Name ), # } # }() # case msg := <- cs . Input : # for _ , user := range cs . Users { # select { # case user . Output <- msg : # default : # } # } # } # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 2 , 2 , 3 , 2 }, 3 }, # {" STR ", [] int { 0 , 1 , 0 , 1 , 0 , 1 , 9 9 }, 9 9 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := singleNumber 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
cases := [] struct { # name string # inputs [] int # expects [] int # }{ # {" STR ", [] int { 0 , 1 , 0 , 3 , 1 2 }, [] int { 1 , 3 , 1 2 , 0 , 0 }}, # {" STR ", [] int { 0 }, [] int { 0 }}, # {" STR ", [] int { 1 }, [] int { 1 }}, # } # # for i , testcase := range cases { # t . Run ( testcase . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # result := moveZeroes 2 ( testcase . inputs ) # if ! reflect . DeepEqual ( result , testcase . expects ) { # t . Fatalf (" STR ", testcase . expects , result , testcase . inputs ) # } # # }) # }
for i := len ( nums ) - 1 ; i >= 1 ; i -- { # if nums [ i ] > nums [ i - 1 ] { # minMax , minMaxIdx := nums [ i ], i # for j := i ; j < len ( nums ); j ++ { # if nums [ j ] < minMax && nums [ j ] > nums [ i - 1 ] { # minMax , minMaxIdx = nums [ j ], j # } # } # # nums [ i - 1 ], nums [ minMaxIdx ] = nums [ minMaxIdx ], nums [ i - 1 ] # subSlice := nums [ i :] # sort . Slice ( subSlice , func ( x , y int ) bool { # return subSlice [ x ] < subSlice [ y ] # }) # break # } # } # return nums
for i := 0 ; i < r ; i ++ { # if board [ i ][ c ] == " STR " { # return false ; # } # } # for i , j := r , c ; i >= 0 && j >= 0 ; i , j = i - 1 , j - 1 { # if board [ i ][ j ] == " STR " { # return false ; # } # } # for i , j := r , c ; i >= 0 && j < len ( board ); i , j = i - 1 , j + 1 { # if board [ i ][ j ] == " STR " { # return false ; # } # } # return true ;
low , high := 1 , len ( A )- 2 # for low <= high { # mid := low + ( high - low )/ 2 # if A [ mid ] > A [ mid - 1 ] && A [ mid ] > A [ mid + 1 ] { # return mid # } # # if A [ mid ] > A [ mid - 1 ] && A [ mid ] < A [ mid + 1 ] { # low = mid + 1 # continue # } # # if A [ mid ] < A [ mid - 1 ] && A [ mid ] > A [ mid + 1 ] { # high = mid - 1 # continue # } # } # return 0
println (" STR ", len ( s . a ), cap ( s . a ), s . a [ 0 ], s . a [ 1 ], s . b )
tmp := make ([] string , len ( nums )) # for i := range tmp { # tmp [ i ] = strconv . Itoa ( nums [ i ]) # } # sort . Slice ( tmp , func ( i , j int ) bool { # return tmp [ i ]+ tmp [ j ] > tmp [ j ]+ tmp [ i ] # }) # res := strings . Join ( tmp , " STR ") # if res [ 0 ] == ' 0 ' { # return " STR " # } # return res
sum := 0 # # for i := 2 ; i < ( 9 * 9 * 9 * 9 * 9 )* 6 ; i ++ { # htou := ( i % 1 0 0 0 0 0 0 ) / 1 0 0 0 0 0 # ttou := ( i % 1 0 0 0 0 0 ) / 1 0 0 0 0 # thou := ( i % 1 0 0 0 0 ) / 1 0 0 0 # hund := ( i % 1 0 0 0 ) / 1 0 0 # tens := ( i % 1 0 0 ) / 1 0 # ones := ( i % 1 0 ) / 1 # # digitSum := # ( htou * htou * htou * htou * htou ) + # ( ttou * ttou * ttou * ttou * ttou ) + # ( thou * thou * thou * thou * thou ) + # ( hund * hund * hund * hund * hund ) + # ( tens * tens * tens * tens * tens ) + # ( ones * ones * ones * ones * ones ) # # if digitSum == i { # sum += i # fmt . Println ( htou , ttou , thou , hund , tens , ones ) # fmt . Println ( i ) # } # } # # fmt . Println ( sum )
s = strings . Trim ( s , " STR ") # pointSeen , eSeen , numberSeen := false , false , false # for i := 0 ; i < len ( s ); i ++ { # c := s [ i ] # if c >= ' 0 ' && c <= ' 9 ' { # numberSeen = true # } else if c == '.' { # if eSeen || pointSeen { # return false # } # pointSeen = true # } else if c == ' e ' { # if eSeen || ! numberSeen { # return false # } # numberSeen = false # eSeen = true # } else if c == '-' || c == '+' { # if i != 0 && s [ i - 1 ] != ' e ' { # return false # } # } else { # return false # } # } # return numberSeen
lenY , lenX := len ( s )+ 1 , len ( p )+ 1 # dp := make ([][] bool , lenY ) # for y := 0 ; y < lenY ; y ++ { # dp [ y ] = make ([] bool , lenX ) # } # dp [ 0 ][ 0 ] = true # for x := 1 ; x < lenX ; x ++ { # if p [ x - 1 ] == '*' { # dp [ 0 ][ x ] = dp [ 0 ][ x - 1 ] # } # } # for y := 1 ; y < lenY ; y ++ { # for x := 1 ; x < lenX ; x ++ { # switch p [ x - 1 ] { # case '*': # dp [ y ][ x ] = dp [ y ][ x - 1 ] || dp [ y - 1 ][ x ] # case '?', s [ y - 1 ]: # dp [ y ][ x ] = dp [ y - 1 ][ x - 1 ] # } # } # } # return dp [ len ( s )][ len ( p )]
f := func ( w http . ResponseWriter , r * http . Request ) { # w . WriteHeader ( 2 0 0 ) # w . Header (). Set (" STR ", " STR ") # fmt . Fprintln ( w , feed ) # } # # return httptest . NewServer ( http . HandlerFunc ( f ))
qs := [] question 7 8 1 { # { # para 7 8 1 {[] int { 1 , 1 , 2 }}, # ans 7 8 1 { 5 }, # }, # # { # para 7 8 1 {[] int { 1 0 , 1 0 , 1 0 }}, # ans 7 8 1 { 1 1 }, # }, # # { # para 7 8 1 {[] int {}}, # ans 7 8 1 { 0 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 7 8 1 , q . para 7 8 1 # fmt . Printf (" STR ", p , numRabbits ( p . one )) # } # fmt . Printf (" STR ")
count := make ( map [ string ] int , 3 0 0 ) # var sb strings . Builder # for _ , r := range A { # r 0 := r [ 0 ] # for _ , x := range r { # sb . WriteByte ( byte ( x ^ r 0 + ' 0 ')) # } # count [ sb . String ()]++ # sb . Reset () # } # # res := 0 # # for _ , c := range count { # res = max ( res , c ) # } # # return res
if len ( inorder ) == 0 { # return nil # } # # n := len ( postorder ) - 1 # i := findIndex ( inorder , postorder [ n ]) # return & TreeNode { # Val : postorder [ n ], # Left : buildTree ( inorder [: i ], postorder [: i ]), # Right : buildTree ( inorder [ i + 1 :], postorder [ i : n ]), # }
result , h := [][] int {}, & minHeap {} # if len ( nums 1 ) == 0 || len ( nums 2 ) == 0 || k == 0 { # return result # } # if len ( nums 1 )* len ( nums 2 ) < k { # k = len ( nums 1 ) * len ( nums 2 ) # } # heap . Init ( h ) # for _ , num := range nums 1 { # heap . Push ( h , [] int { num , nums 2 [ 0 ], 0 }) # } # for len ( result ) < k { # min := heap . Pop ( h ).([] int ) # result = append ( result , min [: 2 ]) # if min [ 2 ] < len ( nums 2 )- 1 { # heap . Push ( h , [] int { min [ 0 ], nums 2 [ min [ 2 ]+ 1 ], min [ 2 ] + 1 }) # } # } # return result
for i , n := range numbers { # for j := i + 1 ; j < len ( numbers ); j ++ { # sum := n + numbers [ j ] # if sum == target { # return [] int { i + 1 , j + 1 } # } # if sum > target { # break # } # } # } # return nil
qs := [] question 1 5 0 { # # { # para 1 5 0 {[] string {" STR "}}, # ans 1 5 0 { 1 8 }, # }, # # { # para 1 5 0 {[] string {" STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 1 5 0 { 9 }, # }, # { # para 1 5 0 {[] string {" STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 1 5 0 { 6 }, # }, # # { # para 1 5 0 {[] string {" STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR ", " STR "}}, # ans 1 5 0 { 2 2 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 5 0 , q . para 1 5 0 # fmt . Printf (" STR ", p , evalRPN ( p . one )) # } # fmt . Printf (" STR ")
size := len ( nums ) # if size == 0 { # return nil # } # tmp 1 , tmp 2 := 1 , 1 # vals := make ([] int , size ) # for i := 0 ; i < size ; i ++ { # vals [ i ] = 1 # } # for i , j := 0 , size - 1 ; i < size ; i , j = i + 1 , j - 1 { # vals [ i ] *= tmp 1 # tmp 1 *= nums [ i ] # vals [ j ] *= tmp 2 # tmp 2 *= nums [ j ] # } # return vals
defer c . Close () # for { # _ , err := io . WriteString ( c , time . Now (). Format (" STR ")) # if err != nil { # return # } # time . Sleep ( 1 * time . Second ) # }
n := len ( board ) # rectSets := make ([] int 1 6 , n * n / 9 ) # for i := 0 ; i < n ; i ++ { # rowSet , colSet := int 1 6 ( 0 ), int 1 6 ( 0 ) # for j := 0 ; j < n ; j ++ { # if num := board [ i ][ j ]; num != " STR " { # numBit := int 1 6 ( 1 << ( num - " STR ")) # if rowSet & numBit > 0 { # return false # } # rowSet |= numBit # # if rectSets [( n / 3 )*( i / 3 )+ j / 3 ]& numBit > 0 { # return false # } # rectSets [( n / 3 )*( i / 3 )+ j / 3 ] |= numBit # } # # if num := board [ j ][ i ]; num != " STR " { # numBit := int 1 6 ( 1 << ( num - " STR ")) # if colSet & numBit > 0 { # return false # } # colSet ^= numBit # } # } # } # return true
if len ( xs ) <= 1 { # return xs # } # lastElement := xs [ len ( xs )- 1 ] # rest := reverse ( xs [: len ( xs )- 1 ]) # ys := [] int { lastElement } # ys = append ( ys , rest ...) # return ys
return NewPriorityQueueWithWaitLimit ( maxPriority , 0 )
if list . rear == nil { # return 0 , false # } # return list . rear . data , true
cases := [] struct { # name string # inputs InputCase # expect [] int # }{ # { # " STR ", # InputCase { # [] int { 1 , 2 , 3 , 4 , 5 }, # 2 , # }, # [] int { 4 , 5 , 1 , 2 , 3 }, # }, # { # " STR ", # InputCase { # [] int { 0 , 1 , 2 }, # 4 , # }, # [] int { 2 , 0 , 1 }, # }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # listNode := UnmarshalListBySlice ( c . inputs . element ) # ret := Solution ( listNode , c . inputs . k ) # if ! isEqual ( ret , UnmarshalListBySlice ( c . expect )) { # PrintList ( ret ) # PrintList ( UnmarshalListBySlice ( c . expect )) # t . Fatalf (" STR ", c . expect , ret , c . inputs ) # } # }) # }
t . Parallel () # for _ , tc := range testcases { # if regions := DistinctRegions ( tc . grid ); regions != tc . regions { # t . Errorf (" STR ", tc . regions , regions ) # } # }
n := len ( points ) # diffMap := make ( map [ Point ] int , n ) # # for i := 0 ; i < n ; i ++ { # diffMap [ points [ i ]]++ # } # # size := len ( diffMap ) # # if size <= 2 { # return n # } # # max := 0 # if size < n { # points = make ([] Point , 0 , size ) # for p := range diffMap { # points = append ( points , p ) # } # } # # for i := 0 ; i < size - 1 ; i ++ { # for j := i + 1 ; j < size ; j ++ { # count := 0 # for k := 0 ; k < size ; k ++ { # if isSameLine ( points [ i ], points [ j ], points [ k ]) { # count += diffMap [ points [ k ]] # } # } # if max < count { # max = count # } # } # } # # return max
t . Parallel () # # for _ , tc := range testcases { # if result := IsKPalindromeBrute ( tc . input , tc . k ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
tests := [...] testType { # { # in : " STR ", # want : 6 , # }, # { # in : " STR ", # want : 4 , # }, # } # for _ , tt := range tests { # got := countBinarySubstrings ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
if nil == nums || len ( nums ) < 1 { # return 0 # } # # if 1 == len ( nums ) { # return nums [ 0 ] # } else if 2 == len ( nums ) { # return maxInt ( nums [ 0 ], nums [ 1 ]) # } # # f := make ([] int , len ( nums )) # f [ 0 ] = nums [ 0 ] # f [ 1 ] = maxInt ( nums [ 0 ], nums [ 1 ]) # for i := 2 ; i < len ( nums ); i ++ { # f [ i ] = maxInt ( nums [ i ]+ f [ i - 2 ], f [ i - 1 ]) # } # # return f [ len ( nums )- 1 ]
s := " STR " # dict := make ( map [ string ] int ) # for _ , v := range s { # _ , exist := dict [ string ( v )] # if exist == false { # dict [ string ( v )] = 1 # } else { # dict [ string ( v )] = dict [ string ( v )] + 1 # } # } # # var res [] string # for k , v := range dict { # if v > 1 { # res = append ( res , k ) # } # } # fmt . Println ( strings . Join ( res , " STR "))
size := len ( quiet ) # # rs := make ([][] int , size ) # for _ , r := range richer { # x , y := r [ 0 ], r [ 1 ] # rs [ y ] = append ( rs [ y ], x ) # } # # res := make ([] int , size ) # for i := range res { # res [ i ] = - 1 # } # # var dfs func ( int ) int # dfs = func ( i int ) int { # if res [ i ] >= 0 { # return res [ i ] # } # res [ i ] = i # for _ , j := range rs [ i ] { # if quiet [ res [ i ]] > quiet [ dfs ( j )] { # res [ i ] = res [ j ] # } # } # return res [ i ] # } # # for i := 0 ; i < size ; i ++ { # dfs ( i ) # } # # return res
cases := [] struct { # name string # inputs [][] int # expect [] int # }{ # {" STR ", [][] int {{ 2 , 7 , 1 1 , 1 5 }, { 9 }}, [] int { 0 , 1 }}, # {" STR ", [][] int {{ 3 , 2 , 4 }, { 6 }}, [] int { 1 , 2 }}, # {" STR ", [][] int {{ 2 , 7 , 1 1 , 1 5 }, { 9 }}, [] int { 0 , 1 }}, # {" STR ", [][] int {{ 7 , 6 , 5 , 3 , 2 , 1 , 4 , 9 , 1 0 }, { 1 7 }}, [] int { 0 , 8 }}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := TwoSum 1 ( c . inputs [ 0 ], c . inputs [ 1 ][ 0 ]) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
if n == 0 { # return big . NewInt ( 1 ), big . NewInt ( 1 ) # } # if n == 1 { # return big . NewInt ( 3 ), big . NewInt ( 2 ) # } # if mem 1 [ n ] != nil { # return mem 1 [ n ], mem 2 [ n ] # } # num 1 , den 1 := Expansion ( n - 1 , mem 1 , mem 2 ) # num 2 , den 2 := Expansion ( n - 2 , mem 1 , mem 2 ) # result 1 , result 2 := big . NewInt ( 0 ). Add ( big . NewInt ( 0 ). Mul ( big . NewInt ( 2 ), num 1 ), num 2 ), # big . NewInt ( 0 ). Add ( big . NewInt ( 0 ). Mul ( big . NewInt ( 2 ), den 1 ), den 2 ) # mem 1 [ n ] = result 1 # mem 2 [ n ] = result 2 # return result 1 , result 2
if nil == nums { # return 0 # } # # ans , cnt := 0 , 0 # for i := 0 ; i < len ( nums ); i ++ { # if 0 == i || nums [ i - 1 ] < nums [ i ] { # cnt ++ # if cnt > ans { # ans = cnt # } # } else { # cnt = 1 # } # } # return ans
if len ( nums ) == 0 { # return - 1 # } # # binarySearch := func ( nums [] int , start , end , target int ) int { # for start <= end { # mid := ( start + end ) / 2 # if nums [ mid ] == target { # return mid # } # # if nums [ mid ] < target { # start = mid + 1 # } else { # end = mid - 1 # } # } # # return - 1 # } # # left , right , smallest := 0 , len ( nums )- 1 , 0 # for nums [ left ] > nums [ right ] { # if right == left + 1 { # smallest = right # break # } # # mid := ( left + right ) / 2 # if nums [ mid ] > nums [ left ] { # left = mid # } else { # right = mid # } # } # # if target >= nums [ 0 ] { # end := smallest - 1 # if smallest == 0 { # end = len ( nums ) - 1 # } # # return binarySearch ( nums , 0 , end , target ) # } # # return binarySearch ( nums , smallest , len ( nums )- 1 , target )
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 2 , 3 , 1 }, 2 }, # {" STR ", [] int { 1 , 2 , 1 , 3 , 5 , 6 , 4 }, 5 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := findPeakElement ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
qs := [] question 1 { # { # para 1 {[] int { 3 , 2 , 4 }, 6 }, # ans 1 {[] int { 1 , 2 }}, # }, # # { # para 1 {[] int { 3 , 2 , 4 }, 5 }, # ans 1 {[] int { 0 , 1 }}, # }, # # { # para 1 {[] int { 0 , 8 , 7 , 3 , 3 , 4 , 2 }, 1 1 }, # ans 1 {[] int { 1 , 3 }}, # }, # # { # para 1 {[] int { 0 , 1 }, 1 }, # ans 1 {[] int { 0 , 1 }}, # }, # # { # para 1 {[] int { 0 , 3 }, 5 }, # ans 1 {[] int {}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 , q . para 1 # fmt . Printf (" STR ", p , twoSum ( p . nums , p . target )) # } # fmt . Printf (" STR ")
s := " STR " # c , i , j := 0 , len ( a )- 1 , len ( b )- 1 # for i >= 0 || j >= 0 { # aNum , bNum := 0 , 0 # if i >= 0 { # aNum = int ( a [ i ]) - int (' 0 ') # i -- # } # if j >= 0 { # bNum = int ( b [ j ]) - int (' 0 ') # j -- # } # cNum := aNum + bNum + c # s = strconv . Itoa ( cNum % 2 ) + s # c = cNum / 2 # } # # if c == 0 { # return s # } # return " STR " + s
if root == nil { # return & TreeNode { # Val : val , # } # } # if val < root . Val { # root . Left = insertIntoBST ( root . Left , val ) # } else { # root . Right = insertIntoBST ( root . Right , val ) # } # return root
var wg sync . WaitGroup # for i := 0 ; i < n ; i ++ { # wg . Add ( 1 ) # go func () { # callback () # wg . Done () # }() # } # wg . Wait ()
p , q := headA , headB # # for p != q { # if p != nil { # p = p . Next # } else { # p = headB # } # # if q != nil { # q = q . Next # } else { # q = headA # } # } # return p
s := MyStack {} # fmt . Println ( s . Empty ()) # s . Push ( 1 ) # s . Push ( 2 ) # s . Push ( 3 ) # fmt . Println ( s . Pop ())
qs := [] question 9 3 { # # { # para 9 3 {" STR "}, # ans 9 3 {[] string {" STR ", " STR "}}, # }, # # { # para 9 3 {" STR "}, # ans 9 3 {[] string {" STR "}}, # }, # # { # para 9 3 {" STR "}, # ans 9 3 {[] string {" STR ", " STR "}}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 9 3 , q . para 9 3 # fmt . Printf (" STR ", p , restoreIPAddresses ( p . s )) # } # fmt . Printf (" STR ")
lines := make ([] strings . Builder , k ) # pos := 0 # goingUp := false # for _ , r := range letters { # switch { # case pos == k : # goingUp = true # pos -= 2 # case pos == - 1 : # goingUp = false # pos += 2 # } # for i := range lines { # if i == pos { # lines [ i ]. WriteRune ( r ) # } else { # lines [ i ]. WriteRune (' ') # } # } # switch { # case goingUp : # pos -- # case ! goingUp : # pos ++ # } # } # for _ , line := range lines { # fmt . Fprintln ( out , line . String ()) # }
fmt . Println () # fmt . Println (" STR ", label ) # fmt . Println (" STR ", s ) # fmt . Println (" STR ", len ( s )) # fmt . Println (" STR ", cap ( s ))
if cmd == "" { # return nil , nil # } # if c . writeTimeout != 0 { # c . conn . SetWriteDeadline ( time . Now (). Add ( c . writeTimeout )) # } # if err = c . writeGetCommand ( cmd , keys ); err == nil { # err = c . bw . Flush () # } # if err != nil { # return nil , c . fatal ( err ) # } # if c . readTimeout != 0 { # c . conn . SetReadDeadline ( time . Now (). Add ( c . readTimeout )) # } # res , err = c . readGetReply () # return
f , ok := s . FieldOk ( name ) # if ! ok { # panic (" STR ") # } # # return f
for n := 0 ; n < 6 ; n ++ { # time . Sleep ( time . Microsecond ) # ch <- 1 2 + n # }
p . mu . Lock () # var x interface {} # if n := len ( p . list ); n > 0 { # x = p . list [ n - 1 ] # p . list [ n - 1 ] = nil # p . list = p . list [: n - 1 ] # } # p . mu . Unlock () # if x == nil && p . New != nil { # x = p . New () # } # return x
n := len ( rects ) # total := 0 # counts := make ([] int , n ) # rs := make ([]* rect , n ) # for i , r := range rects { # w , h := r [ 2 ]- r [ 0 ]+ 1 , r [ 3 ]- r [ 1 ]+ 1 # total += w * h # counts [ i ] = total # rs [ i ] = & rect { # x : r [ 0 ], # y : r [ 1 ], # w : w , # h : h , # } # } # return Solution { # counts : counts , # rects : rs , # }
if node == nil { # return # } # # currentPath := append ([] int {}, parentPath ...) # currentPath = append ( currentPath , node . Val ) # currentSum := parentSum + node . Val # # if node . Left == nil && node . Right == nil && currentSum == target { # * result = append (* result , currentPath ) # return # } # # if node . Left != nil { # traverse ( node . Left , currentSum , currentPath , target , result ) # } # # if node . Right != nil { # traverse ( node . Right , currentSum , currentPath , target , result ) # }
tests := [...] testType { # { # in : [] int { 1 , 2 , 3 , 4 , 4 , 3 , 2 , 1 }, # want : true , # }, # { # in : [] int { 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 }, # want : false , # }, # { # in : [] int { 1 }, # want : false , # }, # { # in : [] int { 1 , 1 }, # want : true , # }, # { # in : [] int { 1 , 1 , 2 , 2 , 2 , 2 }, # want : true , # }, # } # for _ , tt := range tests { # got := hasGroupsSizeX ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
cases := [] struct { # name string # amount int # coins [] int # expect int # }{ # {" STR ", 5 , [] int { 1 , 2 , 5 }, 4 }, # {" STR ", 1 0 , [] int { 1 0 }, 1 }, # {" STR ", 3 , [] int { 2 }, 0 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . amount , c . coins ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . amount , c . coins ) # } # }) # }
gap := 3 3 3 0 # for i := 1 0 0 0 ; i <= 9 9 9 9 ; i ++ { # if isPrime ( i ) { # if isPrime ( i + gap ) { # if isPrime ( i + 2 * gap ) { # fmt . Println ( i , i + gap , i + gap + gap ) # } # } # } # }
if s 1 != s 2 { # if s 1 . rank < s 2 . rank { # s 1 . p = s 2 # return s 2 # } # s 2 . p = s 1 # if s 1 . rank == s 2 . rank { # s 1 . rank ++ # } # return s 1 # } # return s 1
return RLEIterator { n : len ( A ), l : A }
l := len ( intervals ) # var ( # starts [] int # ends [] int # res [] Interval # ) # for _ , v := range intervals { # starts = append ( starts , v . Start ) # ends = append ( ends , v . End ) # } # sort . Ints ( starts ) # sort . Ints ( ends ) # for i , j := 0 , 0 ; i < l ; i ++ { # if i == l - 1 || starts [ i + 1 ] > ends [ i ] { # res = append ( res , Interval { Start : starts [ j ], End : ends [ i ]}) # j = i + 1 # } # } # return res
if startIdx > endIdx { # return # } # # mid := startIdx + ( endIdx - startIdx )/ 2 # if mid == 0 && nums [ mid ] > nums [ mid + 1 ] { # res = append ( res , mid ) # return # } # # if mid == len ( nums )- 1 && nums [ mid ] > nums [ mid - 1 ] { # res = append ( res , mid ) # return # } # # if mid > 0 && mid < len ( nums )- 1 && nums [ mid ] > nums [ mid - 1 ] && # nums [ mid ] > nums [ mid + 1 ] { # res = append ( res , mid ) # return # } # find ( nums , startIdx , mid - 1 ) # find ( nums , mid + 1 , endIdx )
n := len ( s ) # if n % 2 == 1 { # return false # } # pairs := map [ byte ] byte { # " STR ": " STR ", # " STR ": " STR ", # " STR ": " STR ", # } # stack := [] byte {} # for i := 0 ; i < n ; i ++ { # if pairs [ s [ i ]] > 0 { # if len ( stack ) == 0 || stack [ len ( stack )- 1 ] != pairs [ s [ i ]] { # return false # } # stack = stack [: len ( stack )- 1 ] # } else { # stack = append ( stack , s [ i ]) # } # } # return len ( stack ) == 0
if n < 1 { # panic (" STR ") # } # start := " STR " # for i := 1 ; i < n ; i ++ { # var parts [] string # var c rune # count := 0 # for i , r := range start { # switch { # case i == 0 : # c = r # count = 1 # case c != r : # parts = append ( parts , fmt . Sprintf (" STR ", count , string ( c ))) # c = r # count = 1 # default : # count ++ # } # } # parts = append ( parts , fmt . Sprintf (" STR ", count , string ( c ))) # start = strings . Join ( parts , " STR ") # } # return start
fmt . Println ( isBipartite ([][] int {[] int { 1 , 3 }, [] int { 0 , 2 }, [] int { 1 , 3 }, [] int { 0 , 2 }})) # fmt . Println ( isBipartite ([][] int {[] int { 1 , 2 , 3 }, [] int { 0 , 2 }, [] int { 0 , 1 , 3 }, [] int { 0 , 2 }})) # fmt . Println ( isBipartite ([][] int {[] int {}, # [] int { 2 , 4 , 6 }, [] int { 1 , 4 , 8 , 9 }, # [] int { 7 , 8 }, [] int { 1 , 2 , 8 , 9 }, # [] int { 6 , 9 }, [] int { 1 , 5 , 7 , 8 , 9 }, # [] int { 3 , 6 , 9 }, [] int { 2 , 3 , 4 , 6 , 9 }, # [] int { 2 , 4 , 5 , 6 , 7 , 8 }, # }))
var tests = [] struct { # a , b int # }{ # { 1 , 2 }, # {- 2 , 3 }, # {- 1 , - 1 }, # } # # for _ , tt := range tests { # sum := getSum ( tt . a , tt . b ) # if tt . a + tt . b != sum { # t . Errorf (" STR ", tt . a , tt . b , sum , tt . a + tt . b ) # } # }
now := time . Now () # # err := this . currentFile . Close () # if err != nil { # return err # } # # newFilename := this . filename + fmt . Sprintf (" STR ", now . UnixNano ()/ 1 0 0 0 0 0 0 ) # err = os . Rename ( this . filename , newFilename ) # if err != nil { # return err # } # # f , err := os . OpenFile ( this . filename , os . O_CREATE | os . O_WRONLY | os . O_TRUNC , 0 6 4 4 ) # if err != nil { # return err # } # this . currentFile = f # startTime := this . startTime # this . startTime = now # this . byteCount = 0 # # if this . rotateCallback != nil { # this . rotateCallback ( newFilename , startTime , closing , this . opaque ) # } # # return nil
para := " STR " # banned := [] string {" STR "} # # fmt . Println ( mostCommonWord ( para , banned ))
if len ( nums ) == 0 { # return 0 # } # if len ( nums ) == 1 { # return nums [ 0 ] # } # ret := make ([] int , len ( nums )) # ret [ 0 ] = nums [ 0 ] # max := ret [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # tmp := ret [ i - 1 ] + nums [ i ] # if tmp > nums [ i ] { # ret [ i ] = tmp # } else { # ret [ i ] = nums [ i ] # } # if max < ret [ i ] { # max = ret [ i ] # } # } # return max
if num == 0 { # return " STR " # } # # res := " STR " # i := 0 # # for num > 0 { # if num % 1 0 0 0 != 0 { # res = lessK ( num % 1 0 0 0 ) + thousand [ i ] + " STR " + res # } # # num /= 1 0 0 0 # i ++ # } # # return strings . TrimRight ( res , " STR ")
c := NewCircularBuffer ( 1 0 ) # # for i := 0 ; i < 4 ; i ++ { # c . NBPush ( i ) # } # # for i := 0 ; i < 4 ; i ++ { # v := c . Get ().( int ) # if i != v { # t . Error ( v ) # } # } # # if c . verifyIsEmpty () != true { # t . Error (" STR ") # }
carry := 1 # for i := len ( digits )- 1 ; i >= 0 ; i -- { # sum := carry + digits [ i ] # if sum < 1 0 { # digits [ i ] = sum # return digits # } # digits [ i ] = sum % 1 0 # carry = 1 # } # if carry == 1 { # return append ([] int { carry }, digits ...) # } # return digits
var tests = [] struct { # nums [] int # val int # after [] int # }{ # {[] int { 3 , 2 , 2 , 3 }, 3 , [] int { 2 , 2 }}, # {[] int { 0 , 1 , 2 , 2 , 3 , 0 , 4 , 2 }, 2 , [] int { 0 , 1 , 3 , 0 , 4 }}, # } # # for _ , tt := range tests { # nums := make ([] int , len ( tt . nums )) # copy ( nums , tt . nums ) # # length := removeElement ( tt . nums , tt . val ) # if reflect . DeepEqual ( tt . nums [: length ], tt . after ) == false { # t . Errorf (" STR ", nums , tt . val , tt . nums [: length ], tt . after ) # } # }
l := len ( matrix ) # t := make ([][] int , l ) # for i := 0 ; i < l ; i ++ { # t [ i ] = make ([] int , l ) # copy ( t [ i ], matrix [ i ]) # } # for i := 0 ; i < l ; i ++ { # for j := 0 ; j < l ; j ++ { # matrix [ j ][ l - 1 - i ] = t [ i ][ j ] # } # }
a , b , c := math . MinInt 6 4 , math . MinInt 6 4 , math . MinInt 6 4 # for _ , v := range nums { # if v > a { # c = b # b = a # a = v # } else if v < a && v > b { # c = b # b = v # } else if v < b && v > c { # c = v # } # } # if c == math . MinInt 6 4 { # return a # } # return c
sort . Slice ( points , func ( i int , j int ) bool { # return dist ( points [ i ]) < dist ( points [ j ]) # }) # return points [: K ]
var ( # carry = 1 # index = len ( digits ) - 1 # ) # for index >= 0 { # sum := carry + digits [ index ] # digits [ index ] = sum % 1 0 # carry = sum / 1 0 # index -- # } # # if carry > 0 { # digits = append ( digits , 0 ) # copy ( digits [ 1 :], digits [ 0 :]) # digits [ 0 ] = carry # } # return digits
if nil == root { # return [][] int {} # } # # var allVals [][] int # nodes := []* TreeNode { root } # level := 0 # for len ( nodes ) > 0 { # var vals [] int # tmp := nodes [:] # nodes = []* TreeNode {} # for _ , p := range tmp { # if 0 == level % 2 { # vals = append ( vals , p . Val ) # } else { # vals = append ([] int { p . Val }, vals ...) # } # if nil != p . Left { # nodes = append ( nodes , p . Left ) # } # if nil != p . Right { # nodes = append ( nodes , p . Right ) # } # } # allVals = append ( allVals , vals ) # level ++ # } # return allVals
l , r := 0 , 0 # for i := 0 ; i < len ( s ); i ++ { # if s [ i ] == '(' { # l ++ # r ++ # } else if s [ i ] == ')' { # if l > 0 { # l -- # } # r -- # } else { # if l > 0 { # l -- # } # r ++ # } # if r < 0 { # return false # } # } # return l == 0
if len ( board ) == 0 { # return # } # m , n := len ( board ), len ( board [ 0 ]) # for i := 0 ; i < m ; i ++ { # search ( board , i , 0 ) # search ( board , i , n - 1 ) # } # for i := 0 ; i < n ; i ++ { # search ( board , 0 , i ) # search ( board , m - 1 , i ) # } # for x := range board { # for y := range board [ x ] { # b := & board [ x ][ y ] # switch * b { # case '#': # * b = ' O ' # case ' O ': # * b = ' X ' # } # } # }
max , prod := 0 , 0 # for i := 1 0 0 ; i < 1 0 0 0 ; i ++ { # for j := i ; j < 1 0 0 0 ; j ++ { # prod = i * j # if isPalindrome ( prod ) && prod > max { # max = prod # } # } # } # fmt . Println ( max )
return formatText ( r . element . Description )
res := make ([] int , 2 ) # xor := nums [ 0 ] # for i := 1 ; i < len ( nums ); i ++ { # xor ^= nums [ i ] # } # bit := xor &^ ( xor - 1 ) # n 1 , n 2 := 0 , 0 # for _ , v := range nums { # if v & bit > 0 { # n 1 ^= v # } else { # n 2 ^= v # } # } # res [ 0 ] = n 1 # res [ 1 ] = n 2 # return res
m := make ( map [ rune ] int ) # for _ , r := range magazine { # m [ r ] = m [ r ] + 1 # } # for _ , r := range ransomNote { # if m [ r ]--; m [ r ] < 0 { # return false # } # } # return true
result := make ([][] int , 0 ) # if root == nil { # return result # } # # queue 1 , queue 2 := make ([]* TreeNode , 0 ), make ([]* TreeNode , 0 ) # level := make ([] int , 0 ) # queue 1 = append ( queue 1 , root ) # for len ( queue 1 ) > 0 { # node := queue 1 [ 0 ] # queue 1 = queue 1 [ 1 :] # level = append ( level , node . Val ) # # if node . Left != nil { # queue 2 = append ( queue 2 , node . Left ) # } # # if node . Right != nil { # queue 2 = append ( queue 2 , node . Right ) # } # # if len ( queue 1 ) == 0 { # queue 1 = queue 2 # queue 2 = make ([]* TreeNode , 0 ) # result = append ( result , level ) # level = make ([] int , 0 ) # } # } # # return result
_ = <- b . avail # # b . lock . Lock () # defer b . lock . Unlock () # # if b . start == b . pos { # panic (" STR ") # } # # v := b . buffer [ b . start ] # b . buffer [ b . start ] = nil # b . start = ( b . start + 1 ) % b . size # # return v
charMap := [] byte {' 0 ', ' 1 ', ' 2 ', ' 3 ', ' 4 ', ' 5 ', ' 6 ', ' 7 ', ' 8 ', ' 9 ', ' a ', ' b ', ' c ', ' d ', ' e ', ' f '} # # if 0 == num { # return " STR " # } # # numUint 3 2 := uint 3 2 ( num ) # ans := make ([] byte , 0 ) # for 0 != numUint 3 2 { # ans = append ( ans , charMap [ numUint 3 2 & 1 5 ]) # numUint 3 2 >>= 4 # } # # for i , j := 0 , len ( ans )- 1 ; i < j ; { # ans [ i ], ans [ j ] = ans [ j ], ans [ i ] # i ++ # j -- # } # return string ( ans )
vowel := map [ rune ] bool { # ' a ': true , # ' e ': true , # ' i ': true , # ' o ': true , # ' u ': true , # } # p , q := 0 , len ( s )- 1 # ret := [] byte ( s ) # for p < q { # _ , ok 1 := vowel [ unicode . ToLower ( rune ( ret [ p ]))] # if ! ok 1 { # p ++ # } # _ , ok 2 := vowel [ unicode . ToLower ( rune ( ret [ q ]))] # if ! ok 2 { # q -- # } # if ok 1 && ok 2 { # ret [ p ], ret [ q ] = ret [ q ], ret [ p ] # p ++ # q -- # } # } # return string ( ret )
if root == nil { # return 0 # } # res = - 1 << 6 3 # dfs ( root ) # return res
if len (* ret ) == l { # return true # } # * ret += " STR " # for i := 0 ; i < k ; i ++ { # * ret = (* ret )[: len (* ret )- 1 ] # * ret += string ( i + ' 0 ') # t , _ := strconv . Atoi ( string ((* ret )[ len (* ret )- n :])) # if v [ t ] == 0 { # v [ t ] = 1 # if dfs ( v , ret , n , k , l ) { # return true # } # v [ t ] = 0 # } # } # * ret = (* ret )[: len (* ret )- 1 ] # return false
this . mutex . Lock () # defer this . mutex . Unlock () # # return this . total
var y int # for x != 0 { # y = y * 1 0 + x % 1 0 # if y < - 1 << 3 1 || y > 1 << 3 1 - 1 { # return 0 # } # x /= 1 0 # } # return y
num := [] int { 2 , 6 , 4 , 8 , 1 0 , 9 , 1 5 } # num 2 := [] int { 1 , 2 , 3 , 4 } # # fmt . Println ( findUnsortedSubarray ( num )) # fmt . Println ( findUnsortedSubarray ( num 2 ))
cases := [] struct { # name string # inputs [] int # expect [] int # }{ # {" STR ", [] int { 1 , 2 , 3 }, [] int { 1 , 3 , 2 }}, # {" STR ", [] int { 3 , 2 , 1 }, [] int { 1 , 2 , 3 }}, # {" STR ", [] int { 1 , 1 , 5 }, [] int { 1 , 5 , 1 }}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # nextPermutation ( c . inputs ) # if ! reflect . DeepEqual ( c . inputs , c . expect ) { # t . Fatalf (" STR ", # c . expect , c . inputs , c . inputs ) # } # }) # }
count , month , day := 0 , 1 , 1 # for year := 1 9 0 0 ; year < 2 0 0 1 ; year ++ { # for month = 1 ; month < 1 3 ; month ++ { # switch month { # case 1 , 3 , 5 , 7 , 8 , 1 0 , 1 2 : day += 3 1 # case 4 , 6 , 9 , 1 1 : day += 3 0 # case 2 : { # if year % 4 == 0 { # if year % 1 0 0 == 0 { # if year % 4 0 0 == 0 { day += 2 9 } # } else { day += 2 9 } # } # } # } # day = day % 7 # if day == 0 && year > 1 9 0 0 { count ++ } # } # } # println ( count )
var ret bool # var nums [][] byte # ret = true # nums = [][] byte { # {' 5 ', ' 3 ', '.', '.', ' 7 ', '.', '.', '.', '.'}, # {' 6 ', '.', '.', ' 1 ', ' 9 ', ' 5 ', '.', '.', '.'}, # {'.', ' 9 ', ' 8 ', '.', '.', '.', '.', ' 6 ', '.'}, # {' 8 ', '.', '.', '.', ' 6 ', '.', '.', '.', ' 3 '}, # {' 4 ', '.', '.', ' 8 ', '.', ' 3 ', '.', '.', ' 1 '}, # {' 7 ', '.', '.', '.', ' 2 ', '.', '.', '.', ' 6 '}, # {'.', ' 6 ', '.', '.', '.', '.', ' 2 ', ' 8 ', '.'}, # {'.', '.', '.', ' 4 ', ' 1 ', ' 9 ', '.', '.', ' 5 '}, # {'.', '.', '.', '.', ' 8 ', '.', '.', ' 7 ', ' 9 '}, # } # if ret != isValidSudoku ( nums ) { # t . Fatalf (" STR ", ret ) # }
b . lock . Lock () # defer b . lock . Unlock () # # e := len ( b . avail ) == 0 # if e { # if b . pos != b . start { # panic (" STR ") # } # } # return e
sum := 0 # for _ , val := range arr { # sum += val # } # return sum
return b [ i ] >= ' 0 ' && b [ i ] <= ' 9 ' || b [ i ] >= ' A ' && b [ i ] <= ' Z ' || b [ i ] >= ' a ' && b [ i ] <= ' z ' || b [ i ] == ' _ ' || b [ i ] == '-'
ans := make ([] rune , 0 ) # ans = append ( ans , " STR ") # for i := 0 ; i < len ( s ); i ++ { # ans = append ( ans , rune ( s [ i ]), " STR ") # } # return string ( ans )
if root == nil { # return nil # } # s := []* TreeNode { root } # res := [][] int {} # for len ( s ) != 0 { # tmp := []* TreeNode {} # l := [] int {} # for _ , node := range s { # l = append ( l , node . Val ) # if node . Left != nil { # tmp = append ( tmp , node . Left ) # } # if node . Right != nil { # tmp = append ( tmp , node . Right ) # } # } # res = append ( res , l ) # s = tmp # } # i , j := 0 , len ( res )- 1 # for i < j { # res [ i ], res [ j ] = res [ j ], res [ i ] # i ++ # j -- # } # # return res
current := int 6 4 ( 1 ) # for i := 0 ; i < height ; i ++ { # current = ( current * 2 ) % 1 0 0 0 0 0 0 0 0 0 0 # } # return current
qs := [] question 1 3 8 9 { # # { # para 1 3 8 9 {[] int { 0 , 1 , 2 , 3 , 4 }, [] int { 0 , 1 , 2 , 2 , 1 }}, # ans 1 3 8 9 {[] int { 0 , 4 , 1 , 3 , 2 }}, # }, # # { # para 1 3 8 9 {[] int { 1 , 2 , 3 , 4 , 0 }, [] int { 0 , 1 , 2 , 3 , 0 }}, # ans 1 3 8 9 {[] int { 0 , 1 , 2 , 3 , 4 }}, # }, # # { # para 1 3 8 9 {[] int { 1 }, [] int { 0 }}, # ans 1 3 8 9 {[] int { 1 }}, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 3 8 9 , q . para 1 3 8 9 # fmt . Printf (" STR ", p ) # fmt . Printf (" STR ", createTargetArray ( p . nums , p . index )) # } # fmt . Printf (" STR ")
ans , sec := 0 , 0 # for i , v := range nums { # if v > nums [ ans ] { # ans , sec = i , nums [ ans ] # } else if v > sec && i != ans { # sec = v # } # } # if nums [ ans ] >= 2 * sec { # return ans # } # return - 1
if ans , ok := randMemo [ k ]; ok { # return ans # } # # if k <= 5 5 { # kay := int 6 4 ( k ) # temp := (( 1 0 0 0 0 3 - ( 2 0 0 0 0 3 * kay ) + ( 3 0 0 0 0 7 * kay * kay * kay )) % 1 0 0 0 0 0 0 ) - 5 0 0 0 0 0 # # randMemo [ k ] = ( temp ) # return S ( k ) # } # # randMemo [ k ] = (( S ( k - 2 4 ) + S ( k - 5 5 ) + 1 0 0 0 0 0 0 ) % 1 0 0 0 0 0 0 ) - 5 0 0 0 0 0 # return S ( k )
for digits := 2 ; ; digits ++ { # findAllCombos ( 0 , 1 , 0 , digits ) # }
n := len ( arr ) # j := 0 # for i := 0 ; i < n ; i ++ { # if arr [ i ] != val { # arr [ j ] = arr [ i ] # j = j + 1 # } # } # return j
delta := make ( map [ int ] int , len ( nums )/ 2 ) # delta [ 0 ] = - 1 # # ones , zeros , res := 0 , 0 , 0 # # for i := range nums { # if nums [ i ] == 1 { # ones ++ # } else { # zeros ++ # } # # if j , ok := delta [ ones - zeros ]; ok { # res = max ( res , i - j ) # } else { # delta [ ones - zeros ] = i # } # } # # return res
i := len ( nums ) - 2 # # for i >= 0 && nums [ i + 1 ] <= nums [ i ] { # i -- # } # if i >= 0 { # j := len ( nums ) - 1 # for j >= 0 && nums [ j ] <= nums [ i ] { # j -- # } # nums [ i ], nums [ j ] = nums [ j ], nums [ i ] # } # reverse ( nums , i + 1 )
fmt . Println (" STR ") # fmt . Println (" STR ") # # euler 1 := Mul 3 And 5 ( 1 0 0 0 ) # fmt . Printf (" STR ", euler 1 ) # fmt . Println (" STR ") # # euler 2 := FibEvenTotal ( 4 0 0 0 0 0 0 ) # fmt . Printf (" STR ", euler 2 ) # fmt . Println (" STR ") # # euler 3 , _ := LargestPrimeFactor ( 6 0 0 8 5 1 4 7 5 1 4 3 ) # fmt . Printf (" STR ", euler 3 ) # fmt . Println (" STR ") # # euler 4 := LargestPalindromeProduct ( 3 ) # fmt . Printf (" STR ", euler 4 ) # fmt . Println (" STR ") # # euler 5 := LeastCommonMultiple ( 2 0 ) # fmt . Printf (" STR ", euler 5 ) # fmt . Println (" STR ")
arrayChar := [] byte (" STR ") # permutation ( arrayChar , 0 )
min := 2 # max := 9 9 9 # # remainders := [] int {} # cycleLength := 0 # var container , remainder int # for i := max ; i >= min && cycleLength < i ; i -- { # remainders = [] int {} # remainder = 1 # for remainder != 0 && ! Contains ( remainders , remainder ) { # remainders = append ( remainders , remainder ) # remainder = ( remainder * 1 0 ) % i # } # if len ( remainders ) > cycleLength { # cycleLength = len ( remainders ) # container = i # } # } # fmt . Println ( container )
preSum , res := 0 , 0 # count := make ([] int , len ( A )+ 1 ) # count [ 0 ] = 1 # for _ , n := range A { # preSum += n # if preSum >= S { # res += count [ preSum - S ] # } # count [ preSum ]++ # } # return res
if len ( matrix ) == 0 { # return false # } # rLen := len ( matrix ) # cLen := len ( matrix [ 0 ]) # # for r , c := 0 , cLen - 1 ; r < rLen && c >= 0 ; { # if matrix [ r ][ c ] == target { # return true # } # if matrix [ r ][ c ] > target { # c -- # } else { # r ++ # } # } # return false
res := [] string {} # outer : # for i := 0 ; i < len ( words ); i ++ { # wordL := strings . ToLower ( words [ i ]) # for j := 1 ; j < len ( wordL ); j ++ { # if byteMap [ wordL [ j ]] != byteMap [ wordL [ j - 1 ]] { # continue outer # } # } # res = append ( res , words [ i ]) # } # return res
for i := 0 ; i < len ( A ); i ++ { # n , r := len ( A [ i ]), A [ i ] # for j := 0 ; j < n / 2 ; j ++ { # r [ j ], r [ n - j - 1 ] = 1 - r [ n - j - 1 ], 1 - r [ j ] # } # if n % 2 == 1 { # r [ n / 2 ] = 1 - r [ n / 2 ] # } # } # return A
if nil == nums || len ( nums ) == 0 { # return 0 # } # # numsBackup := make ([] int , len ( nums )) # copy ( numsBackup , nums ) # sort . Ints ( nums ) # left , right := 0 , len ( nums )- 1 # for ; left < len ( nums ) && nums [ left ] == numsBackup [ left ]; { # left ++ # } # if left == len ( nums ) { # return 0 # } # # for ; right >= 0 && nums [ right ] == numsBackup [ right ]; { # right -- # } # return right - left + 1
if n == 0 { # return " STR " # } # # res := make ([] byte , n ) # # rec := make ([] byte , n ) # for i := 0 ; i < n ; i ++ { # rec [ i ] = byte ( i ) + ' 1 ' # } # # k -- # # base := 1 # for i := 2 ; i < n ; i ++ { # base *= i # } # # for i := 0 ; i < n - 1 ; i ++ { # idx := k / base # res [ i ] = rec [ idx ] # rec = append ( rec [: idx ], rec [ idx + 1 :]...) # k %= base # base /= ( n - i - 1 ) # } # res [ n - 1 ] = rec [ 0 ] # # return string ( res )
romanMap := map [ string ] int { # " STR ": 1 , # " STR ": 5 , # " STR ": 1 0 , # " STR ": 5 0 , # " STR ": 1 0 0 , # " STR ": 5 0 0 , # " STR ": 1 0 0 0 , # } # romanManyMap := map [ string ] int { # " STR ": 4 , # " STR ": 9 , # " STR ": 4 0 , # " STR ": 9 0 , # " STR ": 4 0 0 , # " STR ": 9 0 0 , # } # var ret int # for k , v := range romanManyMap { # if strings . Contains ( s , k ) { # s = strings . Replace ( s , k , strconv . Itoa ( v ), - 1 ) # ret += v # } # } # for k := range s { # if romanMap [ s [ k : k + 1 ]] != 0 { # ret += romanMap [ s [ k : k + 1 ]] # } # } # return ret
cases := [] struct { # name string # inputs * TreeNode # sum int # expect [][] int # }{ # {" STR ", # & TreeNode { Val : 5 , # Left : & TreeNode { Val : 4 , Left : nil , Right : nil }, # Right : & TreeNode { Val : 8 , Left : nil , Right : nil }, # }, # 9 , # [][] int {[] int { 5 , 4 }}, # }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := pathSum ( c . inputs , c . sum ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
cases := [] struct { # name string # nums [] int # k int # expect bool # }{ # {" STR ", [] int { 1 , 2 , 3 , 1 }, 3 , true }, # {" STR ", [] int { 1 , 0 , 1 , 1 }, 1 , true }, # {" STR ", [] int { 1 , 2 , 3 , 1 , 2 , 3 }, 2 , false }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . nums , c . k ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . nums , c . k ) # } # }) # }
slow := nums [ nums [ 0 ]] # fast := nums [ nums [ nums [ 0 ]]] # for slow != fast { # slow = nums [ slow ] # fast = nums [ nums [ fast ]] # } # # dup := nums [ 0 ] # for dup != slow { # dup = nums [ dup ] # slow = nums [ slow ] # } # return dup
dp := make ([][] int , m + 1 ) # for i := 0 ; i < m + 1 ; i ++ { # dp [ i ] = make ([] int , n + 1 ) # } # # for _ , str := range strs { # numZeros , numOnes := 0 , 0 # for i := 0 ; i < len ( str ); i ++ { # if str [ i ] == ' 0 ' { # numZeros ++ # } else { # numOnes ++ # } # } # # for i := m ; i >= numZeros ; i -- { # for j := n ; j >= numOnes ; j -- { # tmp := dp [ i - numZeros ][ j - numOnes ] + 1 # if tmp > dp [ i ][ j ] { # dp [ i ][ j ] = tmp # } # } # } # } # return dp [ m ][ n ]
sum := big . NewInt ( 0 ) # # for i := int 6 4 ( 1 ); i <= 1 0 0 0 ; i ++ { # # toBeAdded := big . NewInt ( 1 ) # # j := big . NewInt ( i ) # # toBeAdded = toBeAdded . Exp ( j , j , nil ) # # sum = sum . Add ( sum , toBeAdded ) # # } # # text , _ := sum . MarshalText () # # fmt . Printf (" STR ", text [ len ( text ) - 1 0 : ]) #
t . Parallel () # # for _ , tc := range testcases { # if result := NaiveIntegerExponentiation ( tc . x , tc . y ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
qs := [] question 1 2 0 1 { # # { # para 1 2 0 1 { 3 , 2 , 3 , 5 }, # ans 1 2 0 1 { 4 }, # }, # # { # para 1 2 0 1 { 4 , 2 , 3 , 4 }, # ans 1 2 0 1 { 6 }, # }, # # { # para 1 2 0 1 { 5 , 2 , 1 1 , 1 3 }, # ans 1 2 0 1 { 1 0 }, # }, # # { # para 1 2 0 1 { 1 0 0 0 0 0 0 0 0 0 , 2 , 2 1 7 9 8 3 6 5 3 , 3 3 6 9 1 6 4 6 7 }, # ans 1 2 0 1 { 1 9 9 9 9 9 9 9 8 4 }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 1 2 0 1 , q . para 1 2 0 1 # fmt . Printf (" STR ", p , nthUglyNumber ( p . n , p . a , p . b , p . c )) # } # fmt . Printf (" STR ")
cases := [] struct { # name string # inputs * ListNode # expect * ListNode # }{ # {" STR ", & ListNode { 1 , nil }, & ListNode { 1 , nil }}, # {" STR ", & ListNode { 1 , & ListNode { 2 , & ListNode { 3 , nil }}}, # & ListNode { 2 , & ListNode { 3 , nil }}}, # {" STR ", & ListNode { 1 , & ListNode { 2 , & ListNode { 3 , & ListNode { 4 , nil }}}}, # & ListNode { 3 , & ListNode { 4 , nil }}}, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := Solution ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
if head == nil || head . Next == nil { # return head # } # # var ( # pre = head # cur = head . Next # ) # # for cur != nil { # if cur . Val == pre . Val { # pre . Next = cur . Next # cur = cur . Next # } else { # pre = cur # cur = cur . Next # } # } # return head
if ll . Head == nil { # return - 1 # } # # if ll . Head . Next == nil { # return ll . DelAtBeg () # } # # cur := ll . Head # # for ; cur . Next . Next != nil ; cur = cur . Next { # } # # retval := cur . Next . Val # cur . Next = nil # ll . length -- # return retval #
if l 1 == nil { # return l 2 # } # if l 2 == nil { # return l 1 # } # # if l 1 . Val < l 2 . Val { # l 1 . Next = mergeTwoLists ( l 1 . Next , l 2 ) # return l 1 # } # l 2 . Next = mergeTwoLists ( l 2 . Next , l 1 ) # return l 2
t . Parallel () # # for _ , tc := range testcases { # if result := BalanceParens ( tc . parens ); result != tc . expected { # t . Errorf (" STR ", tc . expected , result ) # } # }
if len ( nums ) < 2 { # return false # } # m := make ( map [ int ] int ) # for i , v := range nums { # val , ok := m [ nums [ i ]] # if ok { # if val + k >= i { # return true # } # } # m [ v ] = i # } # return false
mux := http . NewServeMux () # mux . HandleFunc (" STR ", index ) # mux . HandleFunc (" STR ", message ) # server := & http . Server { # Addr : " STR ", # Handler : middlewareFirst ( middlewareSecond ( mux )), # } # log . Println (" STR ") # server . ListenAndServe ()
m := 1 0 0 0 0 0 0 0 0 7 # dp := make ([][] int , n + 1 ) # for i := range dp { # dp [ i ] = make ([] int , k + 1 ) # dp [ i ][ 0 ] = 1 # } # # for i := 1 ; i <= n ; i ++ { # maxJ := min ( k , i *( i - 1 )/ 2 ) # for j := 1 ; j <= maxJ ; j ++ { # dp [ i ][ j ] = ( dp [ i ][ j - 1 ] + dp [ i - 1 ][ j ]) % m # if j >= i { # dp [ i ][ j ] -= dp [ i - 1 ][ j - i ] # if dp [ i ][ j ] < 0 { # dp [ i ][ j ] += m # } # } # } # } # # return dp [ n ][ k ]
last := len ( p . stack ) - 1 # x := p . stack [ last ] # if x . kind == " STR " { # x . size += p . rtotal # p . stack = p . stack [: last ] # } # t := & token { kind : " STR ", size : - p . rtotal } # p . tokens = append ( p . tokens , t ) # p . stack = append ( p . stack , t ) # p . rtotal ++
p := - 1 # for i := 1 ; i < len ( nums ); i ++ { # if nums [ i ] < nums [ i - 1 ] { # if p != - 1 { # return false # } # p = i - 1 # } # } # return p == - 1 || # p == 0 || # p == len ( nums )- 2 || # nums [ p - 1 ] <= nums [ p + 1 ] || # nums [ p ] <= nums [ p + 2 ]
tests := [...] testType { # { # in : [] string {" STR ", " STR ", " STR "}, # want : " STR ", # }, # { # in : [] string {" STR ", " STR ", " STR "}, # want : " STR ", # }, # { # in : nil , # want : " STR ", # }, # } # # for _ , tt := range tests { # got := longestCommonPrefix ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
n := len ( A ) # if n < 3 { # return 0 # } # res := 0 # # for i , j := 0 , 0 ; i < n ; { # j = i + 2 # for j < n && A [ j ]- A [ j - 1 ] == A [ j - 1 ]- A [ j - 2 ] { # j ++ # } # j -- # res += ( j - i - 1 ) * ( j - i ) / 2 # i = j # } # return res
dp := make ([][] int , m ) # for i := 0 ; i < m ; i ++ { # dp [ i ] = make ([] int , n ) # dp [ i ][ 0 ] = 1 # } # # for i := 0 ; i < n ; i ++ { # dp [ 0 ][ i ] = 1 # } # # for i := 1 ; i < m ; i ++ { # for j := 1 ; j < n ; j ++ { # dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ] # } # } # return dp [ m - 1 ][ n - 1 ]
t := & trie { make ( map [ rune ]* trie )} # for _ , word := range words { # curr := t # for _ , r := range word { # if _ , exists := curr . letters [ r ]; ! exists { # curr . letters [ r ] = & trie { make ( map [ rune ]* trie )} # } # curr = curr . letters [ r ] # } # } # return t
expMap := map [ string ] int { # " STR ": 1 , # " STR ": 2 , # " STR ": 9 9 9 , # " STR ": 1 6 , # " STR ": 9 0 , # " STR ": 9 0 , # " STR ": 1 , # " STR ": 2 , # " STR ": 9 9 9 , # " STR ": 1 6 , # " STR ": 9 0 , # " STR ": 9 0 , # } # for i , v := range expMap { # hmap .( hashMap ). HashInsert ( i , v ) # hmap .( hashMap ). HashDelete ( i ) # value , exist := hmap .( hashMap ). HashGet ( i ) # if value != nil { # t . Log ( fmt . Sprintf (" STR ", i ) + fmt . Sprintf (" STR ", value )) # t . Fail () # } # if exist { # t . Log ( fmt . Sprintf (" STR ", i )) # t . Fail () # } # }
var tests = [] struct { # nums [] int # permutations [][] int # }{ # {[] int { 1 , 2 , 3 }, [][] int {{ 1 , 2 , 3 }, { 2 , 1 , 3 }, { 3 , 2 , 1 }, { 1 , 3 , 2 }, { 2 , 3 , 1 }, { 3 , 1 , 2 }}}, # } # # for _ , tt := range tests { # permutations := permute ( tt . nums ) # if reflect . DeepEqual ( permutations , tt . permutations ) == false { # t . Errorf (" STR ", tt . nums , permutations , tt . permutations ) # } # }
copied := make ([] int , len ( citations )) # copy ( copied , citations ) # sort . Slice ( copied , func ( i , j int ) bool { # return copied [ i ] > copied [ j ] # }) # for paper , citationCount := range copied { # if citationCount < paper + 1 { # return paper # } # } # return len ( copied )
tailType , theOther := - 1 , - 1 # tailCount , count := 0 , 0 # res := 0 # # for _ , t := range trees { # count ++ # if t != tailType && t != theOther { # count = tailCount + 1 # } # # res = max ( res , count ) # # tailCount ++ # if t != tailType { # theOther , tailType = tailType , t # tailCount = 1 # } # } # # return res
l := len ( seats ) # ret := [] int {} # for k , v := range seats { # if v == 1 { # ret = append ( ret , k ) # } # } # m := len ( ret ) # pre := ret [ 0 ] # max := mymax ( pre , l - 1 - ret [ m - 1 ]) # for _ , v := range ret { # max = mymax ( max , ( v - pre )/ 2 ) # pre = v # } # return max
blackMap := map [ int ] int {} # for i := 0 ; i < len ( blacklist ); i ++ { # blackMap [ blacklist [ i ]] = 1 # } # M := N - len ( blacklist ) # for _ , value := range blacklist { # if value < M { # for { # if _ , ok := blackMap [ N - 1 ]; ok { # N -- # } else { # break # } # } # blackMap [ value ] = N - 1 # N -- # } # } # return Solution { BlackMap : blackMap , M : M }
for a := 1 ; a < 1 0 0 0 ; a ++{ # for b := a + 1 ; b < 1 0 0 0 ; b ++{ # for c := b + 1 ; c <= 1 0 0 0 ; c ++{ # if ( a * a )+( b * b ) == ( c * c ){ # if a + b + c == 1 0 0 0 { # fmt . Println ( a , b , c ) # fmt . Println ( a * b * c ) # } # } # } # } # }
fmt . Println ( detectCapitalUse (" STR ")) # fmt . Println ( detectCapitalUse (" STR ")) # fmt . Println ( detectCapitalUse (" STR "))
res := [] float 6 4 {} # nodes := []* TreeNode { root } # for len ( nodes ) != 0 { # n := len ( nodes ) # sum := 0 # for _ , node := range nodes { # sum += node . Val # if node . Left != nil { # nodes = append ( nodes , node . Left ) # } # if node . Right != nil { # nodes = append ( nodes , node . Right ) # } # } # res = append ( res , float 6 4 ( sum )/ float 6 4 ( n )) # nodes = nodes [ n :] # } # return res
var left , right , res int # min := len ( nums ) + 1 # for right < len ( nums ) { # for ; res < s && right < len ( nums ); right ++ { # res += nums [ right ] # } # for ; res >= s ; left ++ { # res -= nums [ left ] # if right - left < min { # min = right - left # } # } # } # if min == len ( nums )+ 1 { # return 0 # } # return min
prevNo , prevYes := 0 , 0 # # for _ , v := range nums { # tmp := prevNo # prevNo = max ( prevNo , prevYes ) # prevYes = v + tmp # } # return max ( prevNo , prevYes )
if i < 0 || j < 0 || i >= len ( image ) || j >= len ( image [ 0 ]) || image [ i ][ j ] != c 0 { # return # } # image [ i ][ j ] = c 1 # dfs ( image , i , j - 1 , c 0 , c 1 ) # dfs ( image , i , j + 1 , c 0 , c 1 ) # dfs ( image , i - 1 , j , c 0 , c 1 ) # dfs ( image , i + 1 , j , c 0 , c 1 )
r := root .(* gbtElement ) # if r == nil { # r = t . Root ().(* gbtElement ) # } # n := node .(* gbtElement ) # if t . IsNil ( n ) { # return t . NilNode # } # if ! t . IsNil ( n . Right ) { # return t . Min ( n . Right ) # } # cur := n # for cur != r && cur . Parent . Left != cur { # cur = cur . Parent # } # if cur == r { # return t . NilNode # } # return cur . Parent
var ( # s string # c byte # ) # an , bn := len ( a )- 1 , len ( b )- 1 # for an >= 0 && bn >= 0 { # ac , bc := a [ an ], b [ bn ] # cc := ac - ' 0 ' + bc - ' 0 ' + c # s , c = string ( cc % 2 +' 0 ')+ s , cc / 2 # an , bn = an - 1 , bn - 1 # } # for an >= 0 { # cc := a [ an ] - ' 0 ' + c # s , c = string ( cc % 2 +' 0 ')+ s , cc / 2 # an -- # } # for bn >= 0 { # cc := b [ bn ] - ' 0 ' + c # s , c = string ( cc % 2 +' 0 ')+ s , cc / 2 # bn -- # } # if c == 1 { # s = " STR " + s # } # return s
for i := 0 ; i < b . N ; i ++ { # RecursivePower ( 1 0 , 5 ) # }
seed := time . Now (). UTC (). UnixNano () # t . Logf (" STR ", seed ) # rng := rand . New ( rand . NewSource ( seed )) # # for i := 0 ; i < 1 0 0 0 ; i ++ { # p := randomPalindrome ( rng ) # if ! IsPalindrome ( p ) { # t . Errorf (" STR ", p ) # } # }
la := len ( a ) # lb := len ( b ) # if lb > la { # tmp := a # a = b # b = tmp # la = len ( a ) # lb = len ( b ) # } # if la > lb { # for i := la - lb ; i > 0 ; i -- { # b = " STR " + b # } # } # plus := 0 # res := " STR " # for i := la - 1 ; i != - 1 ; i -- { # ans := int ( a [ i ]) + int ( b [ i ]) + plus # # if ans >= 9 8 { # res = string ( ans -' 2 ') + res # plus = 1 # } else { # res = string ( ans -' 0 ') + res # plus = 0 # } # } # if plus == 1 { # res = " STR " + res # } # return res #
maxTime := 0 # for i := range tasks { # tasks [ i ]. clk = & s . clk # tasks [ i ]. startTime = s . clk # maxTime += tasks [ i ]. r + tasks [ i ]. p # } # if timeout > maxTime { # s . timeout = timeout # } else { # s . timeout = maxTime # } # # s . preTasks , s . runningTasks = newPreSchTaskList ( tasks ), newRunningSchTaskList ([]* task {}) # return s
if S == " STR " { # return 0 # } # n := len ( S ) # for i := 1 ; i * 2 <= n ; i ++ { # left := S [: i ] # if strings . HasSuffix ( S , left ) { # return 2 + longestDecomposition ( S [ i : n - i ]) # } # } # return 1
unionSet := New () # for _ , item := range st . GetItems () { # unionSet . Add ( item ) # } # for _ , item := range st 2 . GetItems () { # unionSet . Add ( item ) # } # return unionSet
num := 1 1 # res := 0 # for num > 0 { # if num & 1 == 1 { # res = res + 1 # } # num = num >> 1 # } # fmt . Println ( res )
this . mutex . Lock () # this . list . Init () # this . closed = true # this . cond . Broadcast () # this . mutex . Unlock () # this . wg . Wait ()
if len ( nums ) == 0 { # return - 1 # } # # lo , hi := 0 , len ( nums )- 1 # for lo <= hi { # mid := lo + ( hi - lo )/ 2 # switch { # case nums [ mid ] < target : # lo = mid + 1 # case nums [ mid ] > target : # hi = mid - 1 # default : # return mid # } # } # return - 1
return searchInsertI ( nums , 0 , len ( nums )- 1 , target )
reverse := func ( str string ) string { # n := len ( str ) # ss := make ([] rune , n ) # for i , s := range str { # ss [ n - i - 1 ] = s # } # return string ( ss ) # } # var ( # i int # s 2 string # ) # for j , r := range s { # if r != ' ' { # continue # } # s 2 += reverse ( s [ i : j ]) + " STR " # i = j + 1 # } # s 2 += reverse ( s [ i :]) # return s 2
maxprofit := 0 # for i := 0 ; i < len ( prices ); i ++ { # for j := i + 1 ; j < len ( prices ); j ++ { # profit := prices [ j ] - prices [ i ] # if profit > maxprofit { # maxprofit = profit # } # } # } # return maxprofit
line , err := c . readLine () # if err != nil { # return c . fatal ( err ) # } # switch { # case bytes . Equal ( line , replyTouched ): # return nil # case bytes . Equal ( line , replyNotFound ): # return ErrNotFound # } # return protocolError (" STR ")
if nil == root { # return nil # } # # if root . Val < L { # return trimBST ( root . Right , L , R ) # } # if root . Val > R { # return trimBST ( root . Left , L , R ) # } # root . Left = trimBST ( root . Left , L , R ) # root . Right = trimBST ( root . Right , L , R ) # return root
for l 1 != nil && l 2 != nil { # if l 1 . Val != l 2 . Val { # return false # } # l 1 = l 1 . Next # l 2 = l 2 . Next # } # if l 1 == nil && l 2 != nil { # return false # } # if l 1 != nil && l 2 == nil { # return false # } # return true
profits := make ([][] int , k + 1 ) # for i := range profits { # profits [ i ] = make ([] int , len ( prices )+ 1 ) # } # # for i := 1 ; i <= k ; i ++ { # diff := - int (^ uint ( 0 )>> 1 ) - 1 # for j := 1 ; j < len ( prices ); j ++ { # diff = max ( diff , profits [ i - 1 ][ j - 1 ]- prices [ j - 1 ]) # profits [ i ][ j ] = max ( profits [ i ][ j - 1 ], prices [ j ]+ diff ) # } # } # # return profits [ k ][ len ( prices )- 1 ]
if head == nil || head . Next == nil { # return head # } # # curr := head # # for curr . Next != nil { # if curr . Next . Val == curr . Val { # curr . Next = curr . Next . Next # } else { # curr = curr . Next # } # } # # return head
if this . running { # return time . Duration ( time . Now (). UnixNano () - this . startTime ) # } else { # return time . Duration ( this . stopTime - this . startTime ) # }
size := len ( unordered ) # sampleSize := int ( 0 . 5 * float 6 4 ( size )) # picks := make ( map [ int ] struct {}, sampleSize ) # for len ( picks ) < sampleSize { # picks [ r . Intn ( size )] = struct {}{} # } # nums := make ([] int , 0 , len ( picks )) # for pick := range picks { # nums = append ( nums , unordered [ pick ]) # } # sort . Ints ( nums ) # mid := len ( nums ) / 2 # return ( nums [ mid ] + nums [ mid + 1 ]) / 2
i := 1 0 0 # f := float 6 4 ( i ) # fmt . Println ( reflect . TypeOf ( f )) # var x interface {} = float 6 4 ( 1 0 0 ) # y := x .( float 6 4 ) # fmt . Println ( reflect . TypeOf ( y )) # # fmt . Println ( strconv . Itoa ( i )) #
size := len ( bs ) # if size == 0 { # return 0 # } # # sort . Sort ( balloons ( bs )) # # res := 0 # end := bs [ 0 ][ 1 ] # # for i := 1 ; i < size ; i ++ { # if bs [ i ][ 0 ] <= end { # continue # } # res ++ # end = bs [ i ][ 1 ] # } # # res ++ # # return res
sum := 0 # for i := 0 ; i < len ( nums ); i ++ { # sum += nums [ i ] # } # if sum == nums [ 0 ] { # return 0 # } # half := 0 # for i := 1 ; i < len ( nums ); i ++ { # half += nums [ i - 1 ] # if sum - nums [ i ]- half == half { # return i # } # } # return - 1
t . Parallel () # # for testNo , testVector := range listOfTestVectors { # ts := time . Now () # ss := (& Rate {}). Init ( 2 , 1 * time . Second ) # for i , l := range testVector { # ts = ts . Add ( time . Duration ( l . delay * # float 6 4 ( time . Second . Nanoseconds ()))) # # if l . update { # ss . Touch ( l . key , ts ) # } # # if l . rateLo != - 1 || l . rateHi != - 1 { # rateLo , rateHi := ss . GetSingle ( l . key , ts ) # if l . rateLo != - 1 && rateLo != l . rateLo { # t . Errorf (" STR "+ # " STR ", # testNo , i , l . rateLo , rateLo ) # } # if l . rateHi != - 1 && rateHi != l . rateHi { # t . Errorf (" STR "+ # " STR ", # testNo , i , l . rateHi , rateHi ) # } # } # } # }
n := len ( edges ) # ls := make ([] int , n ) # zs := make ([] int , n ) # for _ , e := range edges { # i := e [ 0 ] - 1 # for ls [ i ] != 0 { # i = ls [ i ] - 1 # } # j := e [ 1 ] - 1 # for ls [ j ] != 0 { # j = ls [ j ] - 1 # } # if i == j { # return e # } # if zs [ i ] >= zs [ j ] { # zs [ i ] += zs [ j ] + 1 # ls [ j ] = i + 1 # } else { # zs [ j ] += zs [ i ] + 1 # ls [ i ] = j + 1 # } # } # return nil
bytes := make ([] byte , l ) # for i := 0 ; i < l ; i ++ { # bytes [ i ] = byte ( 6 5 + rand . Intn ( 9 0 - 6 5 )) # } # return string ( bytes )
qs := [] question 3 2 6 { # # { # para 3 2 6 { 2 7 }, # ans 3 2 6 { true }, # }, # # { # para 3 2 6 { 0 }, # ans 3 2 6 { false }, # }, # # { # para 3 2 6 { 9 }, # ans 3 2 6 { true }, # }, # # { # para 3 2 6 { 4 5 }, # ans 3 2 6 { false }, # }, # } # # fmt . Printf (" STR ") # # for _ , q := range qs { # _ , p := q . ans 3 2 6 , q . para 3 2 6 # fmt . Printf (" STR ", p , isPowerOfThree ( p . one )) # } # fmt . Printf (" STR ")
m , n := len ( A ), len ( A [ 0 ]) # # res := make ([][] int , n ) # for i := 0 ; i < n ; i ++ { # res [ i ] = make ([] int , m ) # } # # for i := 0 ; i < m ; i ++ { # for j := 0 ; j < n ; j ++ { # res [ j ][ i ] = A [ i ][ j ] # } # } # # return res
valToCount := make ( map [ int ] int ) # var count int # for _ , val := range deck { # valToCount [ val ]++ # count = valToCount [ val ] # } # # gcdVal := count # for _ , c := range valToCount { # gcdVal = gcd ( gcdVal , c ) # } # # return gcdVal >= 2
i , _ := g . edges [ from ][ to ] # j , _ := g . edges [ to ][ from ] # # if i == - 1 || j == - 1 { # return errors . New (" STR ") # } # # g . edges [ from ][ to ] = - 1 # # if ! g . isDirected { # g . edges [ to ][ from ] = - 1 # } # # g . edgesCount -- # # return nil
cases := [] struct { # name string # inputs int # expect [] string # }{ # {" STR ", 3 , [] string { # " STR ", # " STR ", # " STR ", # " STR ", # " STR ", # }}, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := generateParenthesis ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
if root == nil { # return # } # # if root . Left != nil || root . Right != nil { # root . Left , root . Right = root . Right , root . Left # } # # reverseTree ( root . Left ) # reverseTree ( root . Right )
s . lock . Lock () # defer s . lock . Unlock () # # s . nodes = append ( s . nodes , node )
if head == nil || head . Next == nil { # return head # } # fast := head # slow := head # for fast != nil { # if fast . Next == nil { # break # } # fast = fast . Next # slow = slow . Next # if fast . Next != nil { # fast = fast . Next # } # } # return slow
count := [ 1 2 1 ] int {} # for _ , age := range ages { # count [ age ]++ # } # sum , min := 0 , 1 5 # res := 0 # for i := 1 5 ; i <= 1 2 0 ; i ++ { # for min <= i / 2 + 7 { # sum -= count [ min ] # min ++ # } # sum += count [ i ] # res += count [ i ] * ( sum - 1 ) # } # return res
if len ( nums ) == 0 { # return - 1 # } # # sumArr := make ([] lrSum , len ( nums )) # # rSum := 0 # for i := len ( nums ) - 1 ; i >= 0 ; i -- { # rSum += nums [ i ] # sumArr [ i ]. RSum = rSum # } # # lSum := 0 # for i := 0 ; i < len ( nums ); i ++ { # lSum += nums [ i ] # sumArr [ i ]. LSum = lSum # } # fmt . Println ( sumArr ) # # if sumArr [ 1 ]. RSum == 0 { # return 0 # } # # for i := 1 ; i < len ( nums )- 1 ; i ++ { # if sumArr [ i - 1 ]. LSum == sumArr [ i + 1 ]. RSum { # return i # } # } # # if sumArr [ len ( sumArr )- 2 ]. LSum == 0 { # return len ( sumArr ) - 1 # } # # return - 1
tests := [...] testType { # { # day : 3 1 , # month : 8 , # year : 2 0 1 9 , # want : " STR ", # }, # { # day : 1 5 , # month : 8 , # year : 1 9 9 3 , # want : " STR ", # }, # { # day : 1 , # month : 1 , # year : 1 9 7 0 , # want : " STR ", # }, # { # day : 2 5 , # month : 3 , # year : 1 9 9 3 , # want : " STR ", # }, # { # day : 3 0 , # month : 6 , # year : 2 0 0 0 , # want : " STR ", # }, # } # for _ , tt := range tests { # got := dayOfTheWeek ( tt . day , tt . month , tt . year ) # if got != tt . want { # t . Fatalf (" STR ", tt , got , tt . want ) # } # }
if root == nil { # return root # } # # if root . Val > p . Val && root . Val > q . Val { # return lowestCommonAncestor ( root . Left , p , q ) # } # # if root . Val < p . Val && root . Val < q . Val { # return lowestCommonAncestor ( root . Right , p , q ) # } # return root
if nums == nil { # return nil # } # var n 1 , n 2 , bit int # for _ , n := range nums { # bit ^= n # } # bit = bit & ^( bit - 1 ) # for _ , n := range nums { # if n & bit == bit { # n 1 ^= n # } else { # n 2 ^= n # } # } # return [] int { n 1 , n 2 }
if x < 0 { # return false # } # bits := 1 # tmp := x # for { # if tmp < 1 0 { # break # } # tmp = tmp / 1 0 # bits ++ # } # i , j := 1 , bits # for i < j { # left := ( x / divisor ( i )) % 1 0 # right := ( x / divisor ( j )) % 1 0 # if left != right { # return false # } # i , j = i + 1 , j - 1 # } # return true
n := len ( nums ) # dp := make ([] int , n + 1 ) # for i := 1 ; i < n + 1 ; i ++ { # dp [ i ] = dp [ i - 1 ] + nums [ i - 1 ] # } # return NumArray { dp }
if len ( preorder ) == 0 { # return nil # } # res := & TreeNode { # Val : preorder [ 0 ], # } # if len ( preorder ) == 1 { # return res # } # idx := func ( val int , nums [] int ) int { # for i , v := range nums { # if v == val { # return i # } # } # return - 1 # }( res . Val , inorder ) # if idx == - 1 { # return nil # } # res . Left = buildTree ( preorder [ 1 : idx + 1 ], inorder [: idx ]) # res . Right = buildTree ( preorder [ idx + 1 :], inorder [ idx + 1 :]) # return res
var tests = [] struct { # nums [] int # solution [][] int # }{ # { # [] int { 0 , 0 , 0 , 0 }, # [][] int { # { 0 , 0 , 0 }, # }, # }, # { # [] int {- 1 , 0 , 1 , 2 , - 1 , - 4 }, # [][] int { # {- 1 , - 1 , 2 }, # {- 1 , 0 , 1 }, # }, # }, # { # [] int {- 4 , 1 , 3 , 3 , 3 , 1 }, # [][] int { # {- 4 , 1 , 3 }, # }, # }, # } # # for _ , tt := range tests { # solution := threeSum ( tt . nums ) # if reflect . DeepEqual ( solution , tt . solution ) == false { # t . Errorf (" STR ", tt . nums , solution , tt . solution ) # } # }
left := 0 # right := len ( arr ) - 1 # for left <= right { # pivot := partition ( arr , left , right ) # if pivot == k - 1 { # return arr [ pivot ] # } else if pivot < k - 1 { # left = pivot + 1 # } else { # right = pivot - 1 # } # } # return 0
if len ( nums ) < 2 { # return # } # reverse := func ( start , end int ) { # for start < end { # nums [ start ], nums [ end ] = nums [ end ], nums [ start ] # start ++ # end -- # } # } # # p := - 1 # for i := len ( nums ) - 2 ; i >= 0 ; i -- { # if nums [ i ] < nums [ i + 1 ] { # p = i # break # } # } # # if p == - 1 { # reverse ( 0 , len ( nums )- 1 ) # return # } # nextP := 0 # for i := len ( nums ) - 1 ; i >= 0 ; i -- { # if nums [ i ] > nums [ p ] { # nextP = i # break # } # } # nums [ p ], nums [ nextP ] = nums [ nextP ], nums [ p ] # # reverse ( p + 1 , len ( nums )- 1 )
if head == nil || head . Next == nil { # return head # } # # if head . Val == head . Next . Val { # val := head . Val # head = head . Next . Next # # for head != nil && head . Val == val { # head = head . Next # } # return deleteDuplicates ( head ) # } # head . Next = deleteDuplicates ( head . Next ) # return head
res := [] string {} # preWords := make ( map [ string ] struct {}) # sort . Slice ( words , func ( i , j int ) bool { # return len ( words [ i ]) < len ( words [ j ]) # }) # canFrom := func ( word string ) bool { # n := len ( word ) # if len ( preWords ) == 0 { # return false # } # dp := make ([] bool , n + 1 ) # dp [ 0 ] = true # for i := 1 ; i < n + 1 ; i ++ { # for j := 0 ; j < i ; j ++ { # if ! dp [ j ] { # continue # } # if _ , ok := preWords [ word [ j : i ]]; ok { # dp [ i ] = true # break # } # } # } # return dp [ n ] # } # # for _ , word := range words { # if canFrom ( word ) { # res = append ( res , word ) # } # preWords [ word ] = struct {}{} # } # return res
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 1 , 2 , 3 , 1 }, 4 }, # {" STR ", [] int { 2 , 7 , 9 , 3 , 1 }, 1 2 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # got := rob 3 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
var curiousFractions float 6 4 = 1 . 0 # # for i := 1 0 . 0 ; i < 9 9 ; i ++ { # for j := i + 1 ; j <= 9 9 ; j ++ { # iStr := strconv . Itoa ( int ( i )) # jStr := strconv . Itoa ( int ( j )) # # if iStr [ 1 : 2 ] != jStr [ 0 : 1 ] { # continue # } # # halfI , _ := strconv . Atoi ( iStr [ 0 : 1 ]) # halfJ , _ := strconv . Atoi ( jStr [ 1 : 2 ]) # # if halfJ == 0 || halfI == 0 { # continue # } # # halfFI := float 6 4 ( halfI ) # halfFJ := float 6 4 ( halfJ ) # # if i / j == halfFI / halfFJ { # fmt . Printf (" STR ", i , j ) # curiousFractions *= i / j # } # } # } # # return curiousFractions
var nodes [] withNo # preNo := 0 # no := 1 # nodes = append ( nodes , withNo { root , no }) # for len ( nodes ) > 0 { # node := nodes [ 0 ] # if preNo + 1 != node . No { # return false # } # nodes = nodes [ 1 :] # no ++ # if nil != node . Left { # nodes = append ( nodes , withNo { node . Left , no }) # } # no ++ # if nil != node . Right { # nodes = append ( nodes , withNo { node . Right , no }) # } # preNo = node . No # } # return true
copy ( nums 1 [ n :], nums 1 ) # cur , i , j := 0 , n , 0 # for j < n { # if i < m + n && nums 1 [ i ] < nums 2 [ j ] { # nums 1 [ cur ], i = nums 1 [ i ], i + 1 # } else { # nums 1 [ cur ], j = nums 2 [ j ], j + 1 # } # cur ++ # }
if n == 1 { # return number [: k ] # } # visit , total := map [ string ] bool {}, int ( math . Pow ( float 6 4 ( k ), float 6 4 ( n ))) # str := make ([] byte , 0 , total + n - 1 ) # for i := 1 ; i != n ; i ++ { # str = append ( str , ' 0 ') # } # dfsCrackSafe ( total , n , k , & str , & visit ) # return string ( str )
naturals := make ( chan int ) # squares := make ( chan int ) # # go func () { # for x := 0 ; x < 1 0 0 ; x ++ { # naturals <- x # } # close ( naturals ) # }() # # go func () { # for x := range naturals { # squares <- x * x # } # close ( squares ) # }() # # for x := range squares { # fmt . Println ( x ) # }
e := NewEwmaRate ( time . Duration ( 1 * time . Second )) # # if e . CurrentNow () != 0 { # t . Error (" STR ") # } # # e . UpdateNow () # rate := e . CurrentNow () # if !( rate >= 0 . 0 && rate < 0 . 2 ) { # t . Errorf (" STR ", rate ) # }
dirs := [][] int {{ 0 , 1 }, { 1 , 0 }, { 0 , - 1 }, {- 1 , 0 }} # dirIndex := 0 # obs := make ( map [[ 2 ] int ] bool ) # for _ , ob := range obstacles { # obs [[ 2 ] int { ob [ 0 ], ob [ 1 ]}] = true # } # # pos := [ 2 ] int { 0 , 0 } # result := 0 # for _ , command := range commands { # if command == - 1 { # dirIndex = ( dirIndex + 1 ) % 4 # } else if command == - 2 { # dirIndex = ( dirIndex + 3 ) % 4 # } else { # for i := 0 ; i < command ; i ++ { # next := [ 2 ] int { pos [ 0 ] + dirs [ dirIndex ][ 0 ], pos [ 1 ] + dirs [ dirIndex ][ 1 ]} # if _ , exists := obs [ next ]; exists { # break # } # # pos = next # dist := pos [ 0 ]* pos [ 0 ] + pos [ 1 ]* pos [ 1 ] # result = int ( math . Max ( float 6 4 ( result ), float 6 4 ( dist ))) # } # } # } # # return result
searchFirstOrLast := func ( nums [] int , target int , isFirst bool ) int { # left , right := 0 , len ( nums )- 1 # for left <= right { # mid := ( left + right ) / 2 # if nums [ mid ] == target { # if isFirst { # if mid == 0 || nums [ mid - 1 ] != target { # return mid # } # # right = mid - 1 # } else { # if mid == len ( nums )- 1 || nums [ mid + 1 ] != target { # return mid # } # # left = mid + 1 # } # } else if nums [ mid ] < target { # left = mid + 1 # } else { # right = mid - 1 # } # } # # return - 1 # } # # result := make ([] int , 0 ) # result = append ( result , searchFirstOrLast ( nums , target , true )) # result = append ( result , searchFirstOrLast ( nums , target , false )) # return result
var res [] int # var max * TreeNode # # for root != nil { # if root . Left == nil { # res = append ( res , root . Val ) # root = root . Right # } else { # max = root . Left # for max . Right != nil && max . Right != root { # max = max . Right # } # # if max . Right == nil { # max . Right = root # root = root . Left # } else { # max . Right = nil # res = append ( res , root . Val ) # root = root . Right # } # } # } # return res
m := make ( map [ int ] int , len ( nums )) # sum 1 , sum 2 := 0 , 0 # for _ , v := range nums { # if _ , ok := m [ v ]; ! ok { # m [ v ]++ # sum 1 += v # } # sum 2 += v # } # return 2 * sum 1 - sum 2
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 }, 6 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := trap ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
sort . Strings ( words ) # m := make ( map [ string ] bool ) # ret := " STR " # for _ , w := range words { # if len ( w ) == 1 || m [ w [ 0 : len ( w )- 1 ]] == true { # if len ( ret ) < len ( w ) { # ret = w # } # m [ w ] = true # } # } # return ret
l . header = & node { # value : " STR ", # next : nil , # } # lnk := l . header # for i := 0 ; i < n ; i ++ { # node := & node { # value : i , # next : nil , # } # lnk . next = node # lnk = lnk . next # }
sold , rest , hold := 0 , 0 , math . MinInt 3 2 # for _ , v := range prices { # pre_sold := sold # sold = hold + v # hold = mymax ( hold , rest - v ) # rest = mymax ( rest , pre_sold ) # } # return mymax ( rest , sold )
n := len ( queries ) # # cnt := make ([] int , 1 , n + 1 ) # c := 0 # for _ , l := range s { # c ^= 1 << uint ( l -' a ') # cnt = append ( cnt , c ) # } # # res := make ([] bool , n ) # for i , q := range queries { # lo , hi , k := q [ 0 ], q [ 1 ], q [ 2 ] # if k >= 1 3 { # res [ i ] = true # continue # } # remains := bits ( cnt [ hi + 1 ] ^ cnt [ lo ]) # res [ i ] = remains / 2 <= k # } # # return res
return len ( m )
r := [] rune ( s ) # if len ( r ) <= k { # return string ( r ) # } # letters := make ( map [ rune ] int ) # var curL , maxL , curR , maxR int # for curR < len ( r ) { # if _ , found := letters [ r [ curR ]]; len ( letters ) < k || found { # letters [ r [ curR ]]++ # curR ++ # if curR - curL > maxR - maxL { # maxL , maxR = curL , curR # } # } else { # for len ( letters ) >= k { # if count := letters [ r [ curL ]]; count == 1 { # delete ( letters , r [ curL ]) # } else { # letters [ r [ curL ]]-- # } # curL ++ # } # } # # } # return string ( r [ maxL : maxR ])
if n < 1 { # panic (" STR ") # } # seen := make ( map [ int ] struct {}) # q := [] int { n } # var steps int # for len ( q ) != 0 { # nextQ := make ([] int , 0 , 2 * len ( q )) # for _ , v := range q { # if v == 1 { # nextQ = nil # break # } else if _ , found := seen [ v ]; ! found { # seen [ v ] = struct {}{} # nextQ = append ( nextQ , v - 1 ) # a := v # for b := int ( math . Sqrt ( float 6 4 ( v ))); b > 0 ; b -- { # if v % b == 0 { # a = v / b # break # } # } # nextQ = append ( nextQ , a ) # } # } # q = nextQ # steps ++ # } # return steps - 1
cases := [] struct { # name string # inputs [][] int # expect int # }{ # {" STR ", [][] int { # { 0 , 1 , 0 , 0 }, # { 1 , 1 , 1 , 0 }, # { 0 , 1 , 0 , 0 }, # { 1 , 1 , 0 , 0 }, # }, 1 6 }, # } # # for i , c := range cases { # t . Run ( c . name +" STR "+ strconv . Itoa ( i ), func ( t * testing . T ) { # got := islandPerimeter 2 ( c . inputs ) # if ! reflect . DeepEqual ( got , c . expect ) { # t . Fatalf (" STR ", # c . expect , got , c . inputs ) # } # }) # }
i , j := 0 , 0 # v 1 , v 2 := 0 , 0 # for i < len ( version 1 ) || j < len ( version 2 ) { # for ; i < len ( version 1 ); i ++ { # if '.' == version 1 [ i ] { # i ++ # break # } # if 0 == v 1 && ' 0 ' == version 1 [ i ] { # continue # } # v 1 = 1 0 * v 1 + int ( version 1 [ i ]-' 0 ') # } # # for ; j < len ( version 2 ); j ++ { # if '.' == version 2 [ j ] { # j ++ # break # } # if 0 == v 2 && ' 0 ' == version 2 [ j ] { # continue # } # v 2 = 1 0 * v 2 + int ( version 2 [ j ]-' 0 ') # } # # if v 1 != v 2 { # break # } # v 1 , v 2 = 0 , 0 # } # # if v 1 > v 2 { # return 1 # } # if v 1 < v 2 { # return - 1 # } # return 0
if root == nil { # return 0 # } # var queue = []* TreeNode { root } # var res , level , sum int # var max = - 1 << 6 3 # for { # counter := len ( queue ) # if counter == 0 { # break # } # level ++ # for _ , q := range queue [: counter ] { # sum += q . Val # if q . Left != nil { # queue = append ( queue , q . Left ) # } # # if q . Right != nil { # queue = append ( queue , q . Right ) # } # } # if max < sum { # max = sum # res = level # } # sum = 0 # queue = queue [ counter :] # } # # return res
str := " STR " # fmt . Println ( reverseWords ( str ))
m := make ( map [ int ] bool ) # for _ , n := range nums { # if m [ n ] { # return true # } # # m [ n ] = true # } # # return false
textLength := len ( text ) # patternLength := len ( pattern ) # if patternLength > textLength { # return - 1 # } # for i := 0 ; i < textLength - patternLength + 1 ; i ++ { # matchesCount := 0 # for j := 0 ; j < patternLength ; j ++ { # if text [ i + j ] != pattern [ j ] { # break # } # matchesCount ++ # } # if matchesCount == patternLength { # return i # } # } # return - 1
copyTrack := make ([] int , len ( track )) # copy ( copyTrack , track ) # subsetRes = append ( subsetRes , copyTrack ) # for i := start ; i < len ( arr ); i ++ { # track = append ( track , arr [ i ]) # traceBackSubset ( arr , i + 1 , track ) # track = track [: len ( track )- 1 ] # }
cases := [] struct { # name string # inputs [] int # expect int # }{ # {" STR ", [] int { 2 , 3 , 1 , 1 , 4 }, 2 }, # {" STR ", [] int { 2 }, 0 }, # {" STR ", [] int { 1 0 , 3 , 4 }, 1 }, # {" STR ", [] int { 4 , 1 , 1 , 3 , 1 , 1 , 1 }, 2 }, # } # # for _ , c := range cases { # t . Run ( c . name , func ( t * testing . T ) { # ret := jump 3 ( c . inputs ) # if ! reflect . DeepEqual ( ret , c . expect ) { # t . Fatalf (" STR ", # c . expect , ret , c . inputs ) # } # }) # }
for i , j := 0 , len ( numbers )- 1 ; i < j ; { # if numbers [ i ]+ numbers [ j ] == target { # return [] int { i + 1 , j + 1 } # } # # if numbers [ i ]+ numbers [ j ] > target { # j -- # } else { # i ++ # } # } # # return [] int {- 1 , - 1 }
start := make ([] rune , len ([] rune ( initial ))) # copy ( start , [] rune ( initial )) # result := make ([] rune , len ( start )) # changed := true # for changed { # changed = false # for i , domino := range start { # if domino == '.' { # switch { # case i != 0 && i != len ( start )- 1 && start [ i - 1 ] == ' R ' && start [ i + 1 ] == ' L ': # result [ i ] = start [ i ] # case i != 0 && start [ i - 1 ] == ' R ': # result [ i ] = ' R ' # changed = true # case i != len ( start )- 1 && start [ i + 1 ] == ' L ': # result [ i ] = ' L ' # changed = true # default : # result [ i ] = start [ i ] # } # } else { # result [ i ] = start [ i ] # } # } # copy ( start , result ) # } # return string ( result )
t , r , res := make ([] int , len ( matrix [ 0 ])), make ([] int , len ( matrix [ 0 ])), [] int {} # for _ , val := range matrix { # m , k := val [ 0 ], 0 # for j := 0 ; j < len ( matrix [ 0 ]); j ++ { # if val [ j ] < m { # m = val [ j ] # k = j # } # if t [ j ] < val [ j ] { # t [ j ] = val [ j ] # } # } # # if t [ k ] == m { # r [ k ] = m # } # } # for k , v := range r { # if v > 0 && v == t [ k ] { # res = append ( res , v ) # } # } # return res
m , n := len ( A ), len ( A [ 0 ]) # res := n - 1 # # dp := make ([] int , n ) # for i := 0 ; i < n ; i ++ { # dp [ i ] = 1 # } # # for j := 0 ; j < n ; j ++ { # for i := 0 ; i < j ; i ++ { # k := 0 # for ; k < m ; k ++ { # if A [ k ][ i ] > A [ k ][ j ] { # break # } # } # if k == m && # dp [ j ] < dp [ i ]+ 1 { # dp [ j ] = dp [ i ] + 1 # } # } # res = min ( res , n - dp [ j ]) # } # # return res
if root == nil { # return 0 # } # return Max ( maxDepth ( root . Left ), maxDepth ( root . Right )) + 1
if root == nil { # return 0 # } # # return sumOfLeafChildren ( root )
segs := strings . Split ( equation , " STR ") # x 1 , val 1 := normalize ( segs [ 0 ]) # x 2 , val 2 := normalize ( segs [ 1 ]) # # x := x 1 - x 2 # val := val 2 - val 1 # # if x == 0 && val == 0 { # return " STR " # } # # if x == 0 { # return " STR " # } # # return fmt . Sprintf (" STR ", val / x )
letters := [] rune ( word ) # exists := false # for row := range board { # for col := range board [ row ] { # exists = exists || search ( board , row , col , letters , make ( map [ Position ] struct {})) # if exists { # return true # } # } # } # return false
var tests = [] struct { # list [] int # sortedList * ListNode # }{ # { # [] int { 4 , 2 , 1 , 3 }, # newList ( 1 , 2 , 3 , 4 ), # }, # { # [] int {- 1 , 5 , 3 , 4 , 0 }, # newList (- 1 , 0 , 3 , 4 , 5 ), # }, # { # [] int { 1 , 2 , 3 , 4 }, # newList ( 1 , 2 , 3 , 4 ), # }, # { # [] int { 4 , 3 , 2 , 1 }, # newList ( 1 , 2 , 3 , 4 ), # }, # { # nil , # nil , # }, # } # # for _ , tt := range tests { # sortedList := sortList ( newList ( tt . list ...)) # if reflect . DeepEqual ( sortedList , tt . sortedList ) == false { # t . Errorf (" STR ", newList ( tt . list ...), sortedList , tt . sortedList ) # } # }
if nil == numbers || 0 >= len ( numbers ) { # return 0 # } # ans := numbers [ 0 ] # times := 1 # for i := 1 ; i < len ( numbers ); i ++ { # if 0 == times { # ans = numbers [ i ] # times = 1 # } else if ans == numbers [ i ] { # times ++ # } else { # times -- # } # } # return ans
num , den := 1 , 1 # for a := 1 ; a < 1 0 ; a ++ { # for b := 1 ; b < 1 0 ; b ++ { # for c := 1 ; c < 1 0 ; c ++ { # if c != b && c != a && isSpecial ( a , b , c ) { # num *= ( a * 1 0 + c ) # den *= ( c * 1 0 + b ) # } # } # } # } # fmt . Println (" STR ", num ) # fmt . Println (" STR ", den )
node := root # for node != target { # path = append ( path , node ) # if target . Val < node . Val { # node = node . Left # } else { # node = node . Right # } # } # path = append ( path , node ) # return
tests := [...] testType { # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : false , # }, # { # in : " STR ", # want : true , # }, # { # in : " STR ", # want : false , # }, # } # for _ , tt := range tests { # got := validPalindrome ( tt . in ) # if got != tt . want { # t . Fatalf (" STR ", tt . in , got , tt . want ) # } # }
